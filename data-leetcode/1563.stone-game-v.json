[
    {
        "title": "Sales Analysis III",
        "question_content": "Table: Product\n\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| product_id   | int     |\n| product_name | varchar |\n| unit_price   | int     |\n+--------------+---------+\nproduct_id is the primary key (column with unique values) of this table.\nEach row of this table indicates the name and the price of each product.\n\nTable: Sales\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| seller_id   | int     |\n| product_id  | int     |\n| buyer_id    | int     |\n| sale_date   | date    |\n| quantity    | int     |\n| price       | int     |\n+-------------+---------+\nThis table can have duplicate rows.\nproduct_id is a foreign key (reference column) to the Product table.\nEach row of this table contains some information about one sale.\n\n&nbsp;\nWrite a solution to&nbsp;report&nbsp;the products that were only sold in the first quarter of 2019. That is, between 2019-01-01 and 2019-03-31 inclusive.\nReturn the result table in any order.\nThe result format is in the following example.\n&nbsp;\nExample 1:\n\nInput: \nProduct table:\n+------------+--------------+------------+\n| product_id | product_name | unit_price |\n+------------+--------------+------------+\n| 1          | S8           | 1000       |\n| 2          | G4           | 800        |\n| 3          | iPhone       | 1400       |\n+------------+--------------+------------+\nSales table:\n+-----------+------------+----------+------------+----------+-------+\n| seller_id | product_id | buyer_id | sale_date  | quantity | price |\n+-----------+------------+----------+------------+----------+-------+\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\n| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |\n| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |\n+-----------+------------+----------+------------+----------+-------+\nOutput: \n+-------------+--------------+\n| product_id  | product_name |\n+-------------+--------------+\n| 1           | S8           |\n+-------------+--------------+\nExplanation: \nThe product with id 1 was only sold in the spring of 2019.\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\nThe product with id 3 was sold after spring 2019.\nWe return only product 1 as it is the product that was only sold in the spring of 2019.",
        "solutions": [
            {
                "id": 315906,
                "title": "simple-mysql-solution",
                "content": "```\\nSELECT s.product_id, product_name\\nFROM Sales s\\nLEFT JOIN Product p\\nON s.product_id = p.product_id\\nGROUP BY s.product_id\\nHAVING MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE) AND\\n       MAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT s.product_id, product_name\\nFROM Sales s\\nLEFT JOIN Product p\\nON s.product_id = p.product_id\\nGROUP BY s.product_id\\nHAVING MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE) AND\\n       MAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2185158,
                "title": "easiest-solution-ever",
                "content": "```\\n# Wherever you are given a range, keep MIN() and MAX() in mind\\nSELECT Product.product_id, Product.product_name FROM Product \\nJOIN Sales \\nON Product.product_id = Sales.product_id \\nGROUP BY Sales.product_id \\nHAVING MIN(Sales.sale_date) >= \"2019-01-01\" AND MAX(Sales.sale_date) <= \"2019-03-31\";\\n```",
                "solutionTags": [],
                "code": "```\\n# Wherever you are given a range, keep MIN() and MAX() in mind\\nSELECT Product.product_id, Product.product_name FROM Product \\nJOIN Sales \\nON Product.product_id = Sales.product_id \\nGROUP BY Sales.product_id \\nHAVING MIN(Sales.sale_date) >= \"2019-01-01\" AND MAX(Sales.sale_date) <= \"2019-03-31\";\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 397232,
                "title": "beat-95-simple-subquery",
                "content": "```\\nSELECT product_id, product_name \\nFROM Product \\nWHERE product_id IN\\n(SELECT product_id\\nFROM Sales\\nGROUP BY product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND MAX(sale_date) <= \\'2019-03-31\\')\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT product_id, product_name \\nFROM Product \\nWHERE product_id IN\\n(SELECT product_id\\nFROM Sales\\nGROUP BY product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND MAX(sale_date) <= \\'2019-03-31\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 705419,
                "title": "ms-sql-99-01-faster-group-by-having",
                "content": "```\\nselect s.product_id, p.product_name\\nfrom sales s, product p\\nwhere s.product_id = p.product_id\\ngroup by s.product_id, p.product_name\\nhaving min(s.sale_date) >= \\'2019-01-01\\' \\n    and max(s.sale_date) <= \\'2019-03-31\\'\\n```",
                "solutionTags": [],
                "code": "```\\nselect s.product_id, p.product_name\\nfrom sales s, product p\\nwhere s.product_id = p.product_id\\ngroup by s.product_id, p.product_name\\nhaving min(s.sale_date) >= \\'2019-01-01\\' \\n    and max(s.sale_date) <= \\'2019-03-31\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2510838,
                "title": "mysql-beginner-level-faster-than-98-simple-short-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome.***\\n*====================================================================*\\n\\u2705 **MySQL Code :**\\n Your runtime beats 98.65 % of mysql submissions.\\n```\\nSELECT product_id, product_name\\nFROM Sales \\nJOIN Product \\nUsing(product_id)\\nGROUP BY product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND MAX(sale_date) <= \\'2019-03-31\\' \\n```\\n**Runtime:** 980 ms\\n**Memory Usage:**  0B\\n________________________________\\n__________________________________\\n\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT product_id, product_name\\nFROM Sales \\nJOIN Product \\nUsing(product_id)\\nGROUP BY product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND MAX(sale_date) <= \\'2019-03-31\\' \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3447908,
                "title": "superb-logic-with-min-and-max",
                "content": "\\n# Logic min and max\\n```\\nselect product_id,product_name\\nfrom product natural join sales\\ngroup by product_id\\nhaving min(sale_date)>=\\'2019-01-01\\' and max(sale_date)<=\\'2019-03-31\\'\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect product_id,product_name\\nfrom product natural join sales\\ngroup by product_id\\nhaving min(sale_date)>=\\'2019-01-01\\' and max(sale_date)<=\\'2019-03-31\\'\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3007366,
                "title": "mysql-solution-easy-solution",
                "content": "\\n# Code\\n```\\nselect product_id,product_name \\nfrom Product where product_id not \\nin \\n(\\n    select p.product_id from Product p left join Sales s \\n    on p.product_id=s.product_id \\n    where s.sale_date <date(\\'2019-01-01\\') \\n    or\\n    s.sale_date >date(\\'2019-03-31\\') \\n    or\\n    s.seller_id is null \\n);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect product_id,product_name \\nfrom Product where product_id not \\nin \\n(\\n    select p.product_id from Product p left join Sales s \\n    on p.product_id=s.product_id \\n    where s.sale_date <date(\\'2019-01-01\\') \\n    or\\n    s.sale_date >date(\\'2019-03-31\\') \\n    or\\n    s.seller_id is null \\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2546294,
                "title": "1084-sales-analysis-iii",
                "content": "```\\nSELECT product_id, product_name FROM Sales \\nJOIN Product USING(product_id)\\nGROUP BY product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND MAX(sale_date) <= \\'2019-03-31\\' ;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT product_id, product_name FROM Sales \\nJOIN Product USING(product_id)\\nGROUP BY product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND MAX(sale_date) <= \\'2019-03-31\\' ;",
                "codeTag": "Unknown"
            },
            {
                "id": 311443,
                "title": "simple-mysql-solution",
                "content": "```\\nSELECT product_id, product_name\\nFROM product\\nJOIN SALES\\nUSING(product_id)\\nGROUP BY product_id\\nHAVING sum(CASE WHEN sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' THEN 1 ELSE 0 end) > 0\\nAND sum(CASE WHEN sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' THEN 0 else 1 end) = 0\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT product_id, product_name\\nFROM product\\nJOIN SALES\\nUSING(product_id)\\nGROUP BY product_id\\nHAVING sum(CASE WHEN sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' THEN 1 ELSE 0 end) > 0\\nAND sum(CASE WHEN sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' THEN 0 else 1 end) = 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 416341,
                "title": "solution-without-join-using-not-in-and-not-between",
                "content": "```\\nSELECT Product.product_id, Product.product_name\\nFROM Product\\nWHERE product_id NOT IN (SELECT product_id FROM Sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\');\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Product.product_id, Product.product_name\\nFROM Product\\nWHERE product_id NOT IN (SELECT product_id FROM Sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3039007,
                "title": "absolutely-the-simplest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect product_id,product_name\\nfrom product p join sales s \\nusing(product_id)\\ngroup by product_id\\nhaving sum(sale_date<\"2019-01-01\")=0\\nand sum(sale_date>\"2019-03-31\")=0\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect product_id,product_name\\nfrom product p join sales s \\nusing(product_id)\\ngroup by product_id\\nhaving sum(sale_date<\"2019-01-01\")=0\\nand sum(sale_date>\"2019-03-31\")=0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2699868,
                "title": "mysql-subquery-left-join",
                "content": "# Write your MySQL query statement below\\n```\\n\\nWITH cte AS\\n(SELECT product_id FROM Sales\\nWHERE sale_date > \\'2019-03-31\\'\\nOR sale_date < \\'2019-01-01\\')\\n\\nSELECT DISTINCT s.product_id , p.product_name\\nFROM Sales s\\nLEFT JOIN Product p\\nON s.product_id=p.product_id  \\nWHERE s.product_id NOT \\nIN(SELECT product_id FROM cte); \\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nWITH cte AS\\n(SELECT product_id FROM Sales\\nWHERE sale_date > \\'2019-03-31\\'\\nOR sale_date < \\'2019-01-01\\')\\n\\nSELECT DISTINCT s.product_id , p.product_name\\nFROM Sales s\\nLEFT JOIN Product p\\nON s.product_id=p.product_id  \\nWHERE s.product_id NOT \\nIN(SELECT product_id FROM cte); \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2291562,
                "title": "mysql-simple-mysql-solution-using-having-clause-group-by",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 998 ms, faster than 87.37% of MySQL online submissions for Sales Analysis III.\\n# Memory Usage: 0B, less than 100.00% of MySQL online submissions for Sales Analysis III.\\n\\n\\tselect p.product_id, p.product_name\\n\\tfrom Product p\\n\\tinner join Sales s on p.product_id = s.product_id\\n\\tgroup by s.product_id\\n\\thaving min(sale_date) >= \\'2019-01-01\\'\\n\\tand max(sale_date) <= \\'2019-03-31\\';",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 998 ms, faster than 87.37% of MySQL online submissions for Sales Analysis III.\\n# Memory Usage: 0B, less than 100.00% of MySQL online submissions for Sales Analysis III.\\n\\n\\tselect p.product_id, p.product_name\\n\\tfrom Product p\\n\\tinner join Sales s on p.product_id = s.product_id\\n\\tgroup by s.product_id\\n\\thaving min(sale_date) >= \\'2019-01-01\\'\\n\\tand max(sale_date) <= \\'2019-03-31\\';",
                "codeTag": "Unknown"
            },
            {
                "id": 1414644,
                "title": "mysql-having",
                "content": "```\\nSELECT \\n        p.product_id, p.product_name\\nFROM \\n        product p\\nJOIN \\n        Sales s\\nON \\n        p.product_id = s.product_id \\n\\nGROUP BY s.product_id\\n        \\n      HAVING  max(s.sale_date)<= \\'2019-03-31\\'\\n      AND MIN(s.sale_date)>=\\'2019-01-01\\';",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n        p.product_id, p.product_name\\nFROM \\n        product p\\nJOIN \\n        Sales s\\nON \\n        p.product_id = s.product_id \\n\\nGROUP BY s.product_id\\n        \\n      HAVING  max(s.sale_date)<= \\'2019-03-31\\'\\n      AND MIN(s.sale_date)>=\\'2019-01-01\\';",
                "codeTag": "Unknown"
            },
            {
                "id": 1278034,
                "title": "using-having-no-sub-query-needed",
                "content": "SELECT s.product_id, p.product_name\\nFROM Sales s JOIN Product p\\nON p.product_id = s.product_id\\nGROUP BY s.product_id\\nHAVING MIN(s.sale_date) >= \\'2019-01-01\\' AND MAX(s.sale_date) <=\\'2019-03-31 \\'\\n",
                "solutionTags": [],
                "code": "SELECT s.product_id, p.product_name\\nFROM Sales s JOIN Product p\\nON p.product_id = s.product_id\\nGROUP BY s.product_id\\nHAVING MIN(s.sale_date) >= \\'2019-01-01\\' AND MAX(s.sale_date) <=\\'2019-03-31 \\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2598194,
                "title": "sql-beginner-simple-logic",
                "content": "\\tselect\\n\\t\\ts.product_id, p.product_name\\n\\tfrom \\n\\t\\tSales s join Product p\\n\\ton\\n\\t\\ts.product_id = p.product_id\\n\\tgroup by\\n\\t\\ts.product_id \\n\\thaving\\n\\t\\tmin(s.sale_date) >= \"2019-01-01\" \\n\\t\\tAND\\n\\t\\tmax(s.sale_date) <= \"2019-03-31\"",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tselect\\n\\t\\ts.product_id, p.product_name\\n\\tfrom \\n\\t\\tSales s join Product p\\n\\ton\\n\\t\\ts.product_id = p.product_id\\n\\tgroup by\\n\\t\\ts.product_id \\n\\thaving\\n\\t\\tmin(s.sale_date) >= \"2019-01-01\" \\n\\t\\tAND\\n\\t\\tmax(s.sale_date) <= \"2019-03-31\"",
                "codeTag": "Unknown"
            },
            {
                "id": 1976451,
                "title": "mysql-ms-sql-and-oracle-solution-with-explanations",
                "content": "We may have 4 cases here:\\n1) product has no any sales\\n2) product sold in the spring of 2019 only\\n3) product sold in other periods, but not in the spring of 2019\\n4) product sold in the spring of 2019 and in other periods\\n\\nThe 2nd case only is correct for the task condition (**only sold in the spring of 2019, between 2019-01-01 and 2019-03-31 inclusive**)\\n\\nAt the first we have to extract all lines from sales and join them with products, group them by product id and name (the 1st case goes away).\\n\\nWe may calculate count of sale lines that out of the spring 2019 period:\\n```SUM(CASE WHEN sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 0 ELSE 1 END)```\\nIf this sum is 0, it means that all sales of this product belong to the spring 2019 period (3rd and 4th cases went away)\\n\\nFinally we have the solution:\\n\\n\\n```\\nSELECT\\n    p.product_id,\\n    p.product_name\\nFROM Sales s\\nINNER JOIN Product p ON s.product_id = p.product_id\\nGROUP BY\\n    p.product_id,\\n    p.product_name\\nHAVING\\n    SUM(CASE WHEN sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 0 ELSE 1 END) = 0\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```SUM(CASE WHEN sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 0 ELSE 1 END)```\n```\\nSELECT\\n    p.product_id,\\n    p.product_name\\nFROM Sales s\\nINNER JOIN Product p ON s.product_id = p.product_id\\nGROUP BY\\n    p.product_id,\\n    p.product_name\\nHAVING\\n    SUM(CASE WHEN sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 0 ELSE 1 END) = 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152778,
                "title": "mssql-solution",
                "content": "```\\nSELECT\\n    product_id,\\n    product_name\\nFROM\\n    Product\\nWHERE\\n    product_id IN\\n    (\\n        SELECT\\n            product_id\\n        FROM\\n            Sales\\n        GROUP BY\\n            product_id\\n        HAVING\\n            MAX(sale_date) <= \\'2019-03-31\\'\\n            AND MIN(sale_date) >= \\'2019-01-01\\'\\n    )\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT\\n    product_id,\\n    product_name\\nFROM\\n    Product\\nWHERE\\n    product_id IN\\n    (\\n        SELECT\\n            product_id\\n        FROM\\n            Sales\\n        GROUP BY\\n            product_id\\n        HAVING\\n            MAX(sale_date) <= \\'2019-03-31\\'\\n            AND MIN(sale_date) >= \\'2019-01-01\\'\\n    )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2070643,
                "title": "accepted-solution-for-mysql-clean-simple-code",
                "content": "```\\nSELECT p.product_id, p.product_name\\nFROM Product p JOIN Sales s ON p.product_id=s.product_id\\nGROUP BY p.product_id\\nHAVING MIN(s.sale_date) >= \\'2019-01-01\\' \\nAND MAX(s.sale_date) <= \\'2019-03-31\\';\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT p.product_id, p.product_name\\nFROM Product p JOIN Sales s ON p.product_id=s.product_id\\nGROUP BY p.product_id\\nHAVING MIN(s.sale_date) >= \\'2019-01-01\\' \\nAND MAX(s.sale_date) <= \\'2019-03-31\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 663175,
                "title": "easiest-mysql-solution",
                "content": "select \\nproduct_id, product_name\\nfrom product\\nwhere product_id not in\\n(select product_id\\nfrom sales\\nwhere sale_date <\\'2019-01-01\\'or sale_date>\\'2019-03-31\\')",
                "solutionTags": [],
                "code": "select \\nproduct_id, product_name\\nfrom product\\nwhere product_id not in\\n(select product_id\\nfrom sales\\nwhere sale_date <\\'2019-01-01\\'or sale_date>\\'2019-03-31\\')",
                "codeTag": "Unknown"
            },
            {
                "id": 313681,
                "title": "simple-solution",
                "content": "```\\nselect a.product_id, product_name\\nfrom Sales a\\ninner join Product b\\non a.product_id = b.product_id\\ngroup by a.product_id\\nhaving min(sale_date)>=\\'2019-01-01\\' and max(sale_date)<=\\'2019-03-31\\'\\n;\\n```",
                "solutionTags": [],
                "code": "```\\nselect a.product_id, product_name\\nfrom Sales a\\ninner join Product b\\non a.product_id = b.product_id\\ngroup by a.product_id\\nhaving min(sale_date)>=\\'2019-01-01\\' and max(sale_date)<=\\'2019-03-31\\'\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3274988,
                "title": "easy-to-understand-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.product_id, p.product_name\\nfrom sales s, product p\\nwhere s.product_id = p.product_id\\ngroup by s.product_id, p.product_name\\nhaving min(s.sale_date) >= \\'2019-01-01\\' AND max(s.sale_date) <= \\'2019-03-31\\';\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.product_id, p.product_name\\nfrom sales s, product p\\nwhere s.product_id = p.product_id\\ngroup by s.product_id, p.product_name\\nhaving min(s.sale_date) >= \\'2019-01-01\\' AND max(s.sale_date) <= \\'2019-03-31\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2718164,
                "title": "easy-mysql-solution-left-join-inner-joins",
                "content": "```\\n# Write your MySQL query statement below\\nWITH rejected_ids AS (\\n    SELECT s.product_id\\n    FROM sales s\\n    WHERE s.sale_date NOT BETWEEN DATE(\\'2019-01-01\\') AND DATE(\\'2019-03-31\\')\\n)\\nSELECT DISTINCT p.product_id, p.product_name\\nFROM product p\\nINNER JOIN sales s ON s.product_id = p.product_id\\nLEFT JOIN rejected_ids r ON r.product_id = p.product_id\\nWHERE s.sale_date BETWEEN DATE(\\'2019-01-01\\') AND DATE(\\'2019-03-31\\') AND r.product_id IS NULL\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH rejected_ids AS (\\n    SELECT s.product_id\\n    FROM sales s\\n    WHERE s.sale_date NOT BETWEEN DATE(\\'2019-01-01\\') AND DATE(\\'2019-03-31\\')\\n)\\nSELECT DISTINCT p.product_id, p.product_name\\nFROM product p\\nINNER JOIN sales s ON s.product_id = p.product_id\\nLEFT JOIN rejected_ids r ON r.product_id = p.product_id\\nWHERE s.sale_date BETWEEN DATE(\\'2019-01-01\\') AND DATE(\\'2019-03-31\\') AND r.product_id IS NULL\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2607248,
                "title": "simplest-solution-using-having",
                "content": "```\\nSELECT Product.product_id, Product.product_name\\nFROM Product \\nINNER JOIN Sales \\nON Product.product_id = Sales.product_id \\nGROUP BY Sales.product_id \\nHAVING MIN(Sales.sale_date) >= \"2019-01-01\" AND MAX(Sales.sale_date) <= \"2019-03-31\"\\n```\\nIf it helped or you learned a new way, kindly upvote. Thanks :)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Product.product_id, Product.product_name\\nFROM Product \\nINNER JOIN Sales \\nON Product.product_id = Sales.product_id \\nGROUP BY Sales.product_id \\nHAVING MIN(Sales.sale_date) >= \"2019-01-01\" AND MAX(Sales.sale_date) <= \"2019-03-31\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2356133,
                "title": "my-straight-forward-solution-using-mysql-min",
                "content": "```\\nSELECT P.PRODUCT_ID, P.PRODUCT_NAME\\n    FROM PRODUCT P\\nJOIN SALES S\\n    USING (PRODUCT_ID)\\nGROUP BY PRODUCT_ID\\n    HAVING MIN(S.SALE_DATE) >= \\'2019-01-01\\'  \\n    AND \\n    MAX(S.SALE_DATE) <= \\'2019-03-31\\'\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT P.PRODUCT_ID, P.PRODUCT_NAME\\n    FROM PRODUCT P\\nJOIN SALES S\\n    USING (PRODUCT_ID)\\nGROUP BY PRODUCT_ID\\n    HAVING MIN(S.SALE_DATE) >= \\'2019-01-01\\'  \\n    AND \\n    MAX(S.SALE_DATE) <= \\'2019-03-31\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176928,
                "title": "don-t-know-the-answer",
                "content": "![image](https://assets.leetcode.com/users/images/a3b1fb94-0a62-42f6-a1a9-0602786b8dce_1655784039.0457337.gif)\\n\\n\\n```\\nselect distinct p.product_id, product_name \\nfrom product p left join \\nsales s on p.product_id=s.product_id\\ngroup by p.product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' \\n    and max(sale_date) <= \\'2019-03-31\\';\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct p.product_id, product_name \\nfrom product p left join \\nsales s on p.product_id=s.product_id\\ngroup by p.product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' \\n    and max(sale_date) <= \\'2019-03-31\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2057726,
                "title": "mysql-2-simple-solutions-with-comment-runtime-846ms-faster-than-99",
                "content": "Where and Select\\n```sql\\nSELECT\\n    product_id,\\n    product_name\\nFROM Product\\n# get product where only sold in first quarter 2019\\nWHERE product_id NOT IN (\\n    # get all product_id in table Sales Where not sold in first quarter 2019\\n    SELECT\\n        product_id\\n    FROM Sales\\n    WHERE sale_date < \"2019-01-01\" OR sale_date > \\'2019-03-31\\'\\n);\\n```\\nHaving and Quarter\\n```sql\\nSELECT\\n    p.product_id,\\n    p.product_name\\nFROM Product AS p\\n# join product and sales table\\nJOIN Sales AS s ON p.product_id = s.product_id\\nGROUP BY p.product_id\\n# where in quarter only 1\\nHAVING MAX(QUARTER(sale_date)) = 1;\\n```\\n# Upvote for your support",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT\\n    product_id,\\n    product_name\\nFROM Product\\n# get product where only sold in first quarter 2019\\nWHERE product_id NOT IN (\\n    # get all product_id in table Sales Where not sold in first quarter 2019\\n    SELECT\\n        product_id\\n    FROM Sales\\n    WHERE sale_date < \"2019-01-01\" OR sale_date > \\'2019-03-31\\'\\n);\\n```\n```sql\\nSELECT\\n    p.product_id,\\n    p.product_name\\nFROM Product AS p\\n# join product and sales table\\nJOIN Sales AS s ON p.product_id = s.product_id\\nGROUP BY p.product_id\\n# where in quarter only 1\\nHAVING MAX(QUARTER(sale_date)) = 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 455306,
                "title": "simple-mysql-using-having-sum-0",
                "content": "```\\nSELECT s.product_id,\\nproduct_name\\nFROM sales s\\nJOIN product p\\nON s.product_id=p.product_id\\nGROUP BY s.product_id\\nHAVING SUM(IF(sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\',0,1))=0\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT s.product_id,\\nproduct_name\\nFROM sales s\\nJOIN product p\\nON s.product_id=p.product_id\\nGROUP BY s.product_id\\nHAVING SUM(IF(sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\',0,1))=0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3104708,
                "title": "mysql-solution",
                "content": "# Code\\n```\\nSELECT s.product_id, product_name\\nFROM Sales s\\nLEFT JOIN Product p\\nON s.product_id = p.product_id\\nGROUP BY s.product_id\\nHAVING MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE) AND\\n       MAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT s.product_id, product_name\\nFROM Sales s\\nLEFT JOIN Product p\\nON s.product_id = p.product_id\\nGROUP BY s.product_id\\nHAVING MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE) AND\\n       MAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2300497,
                "title": "using-inner-join-and-group-by",
                "content": "SELECT \\n    p.product_id,\\n    p.product_name\\n    FROM Product p INNER JOIN Sales s\\n    ON p.product_id = s.product_id\\n    GROUP BY product_id\\n    HAVING MIN(sale_date) >= \\'2019-01-01\\' AND MAX(sale_date) <= \\'2019-03-31\\';",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT \\n    p.product_id,\\n    p.product_name\\n    FROM Product p INNER JOIN Sales s\\n    ON p.product_id = s.product_id\\n    GROUP BY product_id\\n    HAVING MIN(sale_date) >= \\'2019-01-01\\' AND MAX(sale_date) <= \\'2019-03-31\\';",
                "codeTag": "Unknown"
            },
            {
                "id": 2255746,
                "title": "simple-sol-with-one-subquery",
                "content": "```\\nSELECT DISTINCT p.product_id, product_name \\nFROM Product p \\nJOIN Sales s ON s.product_id = p.product_id \\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\n      AND p.product_id NOT IN (\\n                            SELECT product_id \\n                            FROM Sales \\n                            WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n                         );\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT p.product_id, product_name \\nFROM Product p \\nJOIN Sales s ON s.product_id = p.product_id \\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\n      AND p.product_id NOT IN (\\n                            SELECT product_id \\n                            FROM Sales \\n                            WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n                         );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2088673,
                "title": "using-inner-join-and-group-by",
                "content": "```\\nSELECT s.product_id,p.product_name FROM Sales as s INNER JOIN Product as p ON s.product_id=p.product_id GROUP BY s.product_id HAVING MIN(sale_date)>=\\'2019-01-01\\' AND MAX(sale_date)<=\\'2019-03-31\\';\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT s.product_id,p.product_name FROM Sales as s INNER JOIN Product as p ON s.product_id=p.product_id GROUP BY s.product_id HAVING MIN(sale_date)>=\\'2019-01-01\\' AND MAX(sale_date)<=\\'2019-03-31\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918312,
                "title": "simple-mssql-solution",
                "content": "```\\nselect product_id, product_name\\nfrom product \\nwhere product_id not in(select product_id from sales where sale_date<\\'2019-01-01\\' or sale_date>\\'2019-03-31\\')\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect product_id, product_name\\nfrom product \\nwhere product_id not in(select product_id from sales where sale_date<\\'2019-01-01\\' or sale_date>\\'2019-03-31\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1792402,
                "title": "easy-to-understand-my-sql-solution-without-join-or-cte",
                "content": "easy my sql solution \\n```\\nselect product_id, product_name from product where product_id not in ( \\nselect product_id from sales\\nwhere sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```",
                "solutionTags": [],
                "code": "```\\nselect product_id, product_name from product where product_id not in ( \\nselect product_id from sales\\nwhere sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1585922,
                "title": "mysql-min-and-max-approach",
                "content": "select p.product_id, p.product_name\\nfrom product p\\ninner join sales s on s.product_id = p.product_id\\ngroup by p.product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select p.product_id, p.product_name\\nfrom product p\\ninner join sales s on s.product_id = p.product_id\\ngroup by p.product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1572898,
                "title": "elegant-select-solution",
                "content": "```\\nSELECT \\n\\tproduct_id,\\n\\tproduct_name \\nFROM\\n\\tProduct\\nWHERE product_id NOT IN\\n\\t(SELECT\\n\\t\\tproduct_id\\n\\tFROM \\n\\t\\tSales\\n\\tWHERE\\n\\t\\tsale_date \\n    NOT BETWEEN \\n     \\'2019-01-01\\' AND \\'2019-03-31\\')\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n\\tproduct_id,\\n\\tproduct_name \\nFROM\\n\\tProduct\\nWHERE product_id NOT IN\\n\\t(SELECT\\n\\t\\tproduct_id\\n\\tFROM \\n\\t\\tSales\\n\\tWHERE\\n\\t\\tsale_date \\n    NOT BETWEEN \\n     \\'2019-01-01\\' AND \\'2019-03-31\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1100376,
                "title": "faster-than-100-of-ms-sql-server-online-submissions",
                "content": "```\\nSELECT p.product_id,\\n       p.product_name\\nFROM   product p\\n       JOIN sales s\\n         ON p.product_id = s.product_id\\nGROUP  BY p.product_id,\\n          p.product_name\\nHAVING Min(sale_date) >= \\'2019-01-01\\'\\n       AND Max(sale_date) <= \\'2019-03-31\\' \\n```",
                "solutionTags": [],
                "code": "```\\nSELECT p.product_id,\\n       p.product_name\\nFROM   product p\\n       JOIN sales s\\n         ON p.product_id = s.product_id\\nGROUP  BY p.product_id,\\n          p.product_name\\nHAVING Min(sale_date) >= \\'2019-01-01\\'\\n       AND Max(sale_date) <= \\'2019-03-31\\' \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536680,
                "title": "mysql-solution-for-sales-analysis-iii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the given solution is to select the product_id and product_name of products that had sales between a specific date range and had sales overall. The approach involves performing an inner join between the Sales table and the Product table using the product_id column. The results are then grouped by product_id. The HAVING clause is used to compare the sum of sales within the specific date range with the overall sum of sales.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Perform an inner join between the Sales table and the Product table using the product_id column.\\n1. Group the results by product_id.\\n1. Use the HAVING clause to filter the grouped results based on the comparison of the sum of sales within the date range and the overall sum of sales.\\n1. Return the product_id and product_name columns of the selected products.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution depends on the size of the Sales table, the indexing of the relevant columns, and the efficiency of the join and grouping operations. If the tables are properly indexed on the product_id and sale_date columns, and the date range filter can be efficiently applied, the time complexity can be estimated as O(n * log n), where n is the number of rows in the Sales table.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this solution depends on the size of the resulting dataset, which includes the product_id and product_name columns.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n  select product_id, product_name from Sales\\n  inner join product using(product_id)\\n  group by product_id\\n  having sum(if(sale_date between \\'2019-01-01\\' and \\'2019-03-31\\', 1, 0)) = sum(if(sale_date, 1, 0))\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n  select product_id, product_name from Sales\\n  inner join product using(product_id)\\n  group by product_id\\n  having sum(if(sale_date between \\'2019-01-01\\' and \\'2019-03-31\\', 1, 0)) = sum(if(sale_date, 1, 0))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3276377,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect product_id, product_name from Product natural join Sales\\ngroup by product_id \\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect product_id, product_name from Product natural join Sales\\ngroup by product_id \\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3271156,
                "title": "mysql-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.product_id, p.product_name\\nfrom sales s, product p\\nwhere s.product_id = p.product_id\\ngroup by s.product_id, p.product_name\\nhaving min(s.sale_date) >= \\'2019-01-01\\' AND max(s.sale_date) <= \\'2019-03-31\\'\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.product_id, p.product_name\\nfrom sales s, product p\\nwhere s.product_id = p.product_id\\ngroup by s.product_id, p.product_name\\nhaving min(s.sale_date) >= \\'2019-01-01\\' AND max(s.sale_date) <= \\'2019-03-31\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3101008,
                "title": "simple-query-sales-analysis-iii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT DISTINCT A.product_id, B.product_name FROM Sales A LEFT JOIN Product B \\nON A.product_id = B.product_id LEFT JOIN \\n(SELECT DISTINCT product_id FROM Sales WHERE sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\') \\nC ON A.product_id = C.product_id\\nWHERE C.product_id is null;\\n\\n```\\nPlease upvote!!",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT A.product_id, B.product_name FROM Sales A LEFT JOIN Product B \\nON A.product_id = B.product_id LEFT JOIN \\n(SELECT DISTINCT product_id FROM Sales WHERE sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\') \\nC ON A.product_id = C.product_id\\nWHERE C.product_id is null;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027757,
                "title": "faster-than-98-73-left-join-is-faster-than-in",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT DISTINCT A.product_id, B.product_name\\nFROM Sales A LEFT JOIN Product B ON A.product_id = B.product_id LEFT JOIN (SELECT DISTINCT product_id FROM Sales WHERE sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\') C ON A.product_id = C.product_id\\nWHERE C.product_id is null\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT DISTINCT A.product_id, B.product_name\\nFROM Sales A LEFT JOIN Product B ON A.product_id = B.product_id LEFT JOIN (SELECT DISTINCT product_id FROM Sales WHERE sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\') C ON A.product_id = C.product_id\\nWHERE C.product_id is null\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2598662,
                "title": "simple-solution",
                "content": "```\\nSELECT\\n    DISTINCT p.product_id, p.product_name\\nFROM\\n    Product p INNER JOIN Sales s ON p.product_id = s.product_id\\nWHERE\\n    sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' AND p.product_id NOT IN (\\n        SELECT\\n            p.product_id\\n        FROM\\n            Product p INNER JOIN Sales s ON p.product_id = s.product_id \\n        WHERE\\n            sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\n    )\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT\\n    DISTINCT p.product_id, p.product_name\\nFROM\\n    Product p INNER JOIN Sales s ON p.product_id = s.product_id\\nWHERE\\n    sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' AND p.product_id NOT IN (\\n        SELECT\\n            p.product_id\\n        FROM\\n            Product p INNER JOIN Sales s ON p.product_id = s.product_id \\n        WHERE\\n            sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\n    )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2571262,
                "title": "simple-solution-without-joins",
                "content": "select product_id ,product_name\\n    from product \\n    where product_id not in (select product_id from sales where  sale_date                                  not between \\'2019-01-01\\' AND \\'2019-03-31\\' ) and product_id in (select product_id from sales)\\n",
                "solutionTags": [],
                "code": "select product_id ,product_name\\n    from product \\n    where product_id not in (select product_id from sales where  sale_date                                  not between \\'2019-01-01\\' AND \\'2019-03-31\\' ) and product_id in (select product_id from sales)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2456314,
                "title": "faster-than-93-61-mysql-easy-solution",
                "content": "```\\nSELECT product_id, product_name\\nFROM Product\\nWHERE product_id IN (\\n    SELECT product_id FROM Sales\\n    GROUP BY product_id\\n    HAVING MIN(sale_date) >= \\'2019-01-01\\' AND MAX(sale_date) <= \\'2019-03-31\\');",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT product_id, product_name\\nFROM Product\\nWHERE product_id IN (\\n    SELECT product_id FROM Sales\\n    GROUP BY product_id\\n    HAVING MIN(sale_date) >= \\'2019-01-01\\' AND MAX(sale_date) <= \\'2019-03-31\\');",
                "codeTag": "Unknown"
            },
            {
                "id": 2406532,
                "title": "easy-to-understand-mysql-solution-using-a-subquery",
                "content": "```\\nSELECT product_id, product_name FROM product\\n\\nWHERE product_id IN \\n\\n\\t(SELECT DISTINCT product_id FROM sales\\n\\n     GROUP BY product_id \\n\\n     HAVING MIN(sale_date)>= \\'2019-01-01\\' \\n            AND  MAX(sale_date) <= \\'2019-03-31\\')\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT product_id, product_name FROM product\\n\\nWHERE product_id IN \\n\\n\\t(SELECT DISTINCT product_id FROM sales\\n\\n     GROUP BY product_id \\n\\n     HAVING MIN(sale_date)>= \\'2019-01-01\\' \\n            AND  MAX(sale_date) <= \\'2019-03-31\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2288137,
                "title": "mysql-2-solutions",
                "content": "```\\nselect p.product_id, p.product_name\\nfrom Product p\\nleft join Sales s\\non p.product_id = s.product_id\\ngroup by p.product_id\\nhaving sum(s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\') = count(s.sale_date) \\n\\nOR\\n\\nselect p.product_id, p.product_name\\nfrom Product p\\ninner join Sales s on p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(sale_date) >= \\'2019-01-01\\'\\nand max(sale_date) <= \\'2019-03-31\\';\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect p.product_id, p.product_name\\nfrom Product p\\nleft join Sales s\\non p.product_id = s.product_id\\ngroup by p.product_id\\nhaving sum(s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\') = count(s.sale_date) \\n\\nOR\\n\\nselect p.product_id, p.product_name\\nfrom Product p\\ninner join Sales s on p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(sale_date) >= \\'2019-01-01\\'\\nand max(sale_date) <= \\'2019-03-31\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2132902,
                "title": "simple-having-solution",
                "content": "select product_id, product_name\\nfrom Product\\nwhere product_id in \\n(select product_id\\nfrom Sales\\ngroup by product_id\\nhaving max(sale_date) <= \\'2019-03-31\\' and min(sale_date) >= \\'2019-01-01\\')",
                "solutionTags": [],
                "code": "select product_id, product_name\\nfrom Product\\nwhere product_id in \\n(select product_id\\nfrom Sales\\ngroup by product_id\\nhaving max(sale_date) <= \\'2019-03-31\\' and min(sale_date) >= \\'2019-01-01\\')",
                "codeTag": "Unknown"
            },
            {
                "id": 2011803,
                "title": "multiple-ways-of-solving-in-mysql",
                "content": "**Approach 1(With CTE)**\\n\\n```\\nWITH sell_history AS (\\n    SELECT\\n        s.product_id,\\n        SUM(CASE WHEN sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) sold_outside,\\n        SUM(CASE WHEN sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) sold_inside\\n    FROM sales s \\n    GROUP BY s.product_id\\n)\\n\\nSELECT\\n    s.product_id,\\n    p.product_name\\nFROM sell_history s \\nLEFT JOIN product p ON p.product_id = s.product_id\\nWHERE s.sold_outside = 0 \\nAND s.sold_inside > 0;\\n```\\n\\n**Approach 2(Using subquery with JOIN & GROUP BY)**\\n\\n```\\nSELECT\\n    s.product_id,\\n    p.product_name\\nFROM sales s \\nLEFT JOIN product p ON p.product_id = s.product_id\\nGROUP BY s.product_id\\nHAVING s.product_id NOT IN (\\n    SELECT product_id FROM sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n);\\n```\\n\\n**Approach 3(Using subquery with no JOIN)**\\n\\n```\\nSELECT\\n    product_id,\\n    product_name\\nFROM product\\nWHERE product_id NOT IN (\\n    SELECT product_id FROM sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH sell_history AS (\\n    SELECT\\n        s.product_id,\\n        SUM(CASE WHEN sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) sold_outside,\\n        SUM(CASE WHEN sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) sold_inside\\n    FROM sales s \\n    GROUP BY s.product_id\\n)\\n\\nSELECT\\n    s.product_id,\\n    p.product_name\\nFROM sell_history s \\nLEFT JOIN product p ON p.product_id = s.product_id\\nWHERE s.sold_outside = 0 \\nAND s.sold_inside > 0;\\n```\n```\\nSELECT\\n    s.product_id,\\n    p.product_name\\nFROM sales s \\nLEFT JOIN product p ON p.product_id = s.product_id\\nGROUP BY s.product_id\\nHAVING s.product_id NOT IN (\\n    SELECT product_id FROM sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n);\\n```\n```\\nSELECT\\n    product_id,\\n    product_name\\nFROM product\\nWHERE product_id NOT IN (\\n    SELECT product_id FROM sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1717963,
                "title": "mysql-very-simple-solution",
                "content": "```\\n# Write your MySQL query statement below\\nselect p.product_id, p.product_name\\nfrom product p\\njoin sales s\\non p.product_id=s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date)>=\\'2019-01-01\\' and max(s.sale_date)<=\\'2019-03-31\\'\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect p.product_id, p.product_name\\nfrom product p\\njoin sales s\\non p.product_id=s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date)>=\\'2019-01-01\\' and max(s.sale_date)<=\\'2019-03-31\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1044546,
                "title": "mysql",
                "content": "```\\nSELECT Product.product_id,product_name\\nFROM Product\\nINNER JOIN Sales USING(product_id)\\nGROUP BY Product.product_id\\nHAVING SUM(CASE WHEN\\n           sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 0\\n           ELSE 1\\n           END)=0;",
                "solutionTags": [],
                "code": "```\\nSELECT Product.product_id,product_name\\nFROM Product\\nINNER JOIN Sales USING(product_id)\\nGROUP BY Product.product_id\\nHAVING SUM(CASE WHEN\\n           sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 0\\n           ELSE 1\\n           END)=0;",
                "codeTag": "Unknown"
            },
            {
                "id": 959078,
                "title": "easy-mysql-solution",
                "content": "```\\nSELECT sales.product_id, product_name\\nFROM product\\n    JOIN sales ON product.product_id = sales.product_id\\nGROUP BY product_id\\nHAVING SUM(sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\') = COUNT(sale_date)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nSELECT sales.product_id, product_name\\nFROM product\\n    JOIN sales ON product.product_id = sales.product_id\\nGROUP BY product_id\\nHAVING SUM(sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\') = COUNT(sale_date)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 703365,
                "title": "can-someone-please-tell-me-what-s-wrong-with-this-code",
                "content": "```\\nselect p.product_id,p.product_name from Product p join Sales s on p.product_id=s.product_id \\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\';\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nselect p.product_id,p.product_name from Product p join Sales s on p.product_id=s.product_id \\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371244,
                "title": "beats-80",
                "content": "```\\nselect temp.product_id, Product.product_name\\nfrom (select product_id, \\n       sum(case when sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' then 0 else 1 end) as val\\nfrom Sales\\ngroup by product_id\\nhaving val = 0) temp\\njoin Product\\non Product.product_id = temp.product_id\\n```",
                "solutionTags": [],
                "code": "```\\nselect temp.product_id, Product.product_name\\nfrom (select product_id, \\n       sum(case when sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' then 0 else 1 end) as val\\nfrom Sales\\ngroup by product_id\\nhaving val = 0) temp\\njoin Product\\non Product.product_id = temp.product_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358559,
                "title": "simple-not-in-solution",
                "content": "select product_id,product_name from Product where product_id not in(select product_id from Sales where sale_date < \\'2019-01-01\\' or sale_date>\\'2019-03-31\\')",
                "solutionTags": [],
                "code": "select product_id,product_name from Product where product_id not in(select product_id from Sales where sale_date < \\'2019-01-01\\' or sale_date>\\'2019-03-31\\')",
                "codeTag": "Unknown"
            },
            {
                "id": 3952868,
                "title": "easy-pandas-sollution-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem seems to involve analyzing sales data and filtering it based on specific criteria. We are given two DataFrames: one containing product information and another containing sales data. The goal appears to be to filter the sales data to include only records that fall within a certain date range (January 1, 2019, to March 31, 2019) and then merge this filtered data with the product information to get a final DataFrame.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First, we need to organize the sales data so we can work with it more easily. To do this, we group the sales data by each product (using \\'product_id\\') and find the earliest (\\'min\\') and latest (\\'max\\') sale dates for each product.\\n2. Next, we need to filter the sales data to include only the records where the sale date falls between January 1, 2019, and March 31, 2019. This step ensures we\\'re only looking at sales within our target date range.\\n3. Now, we have a list of products that were sold during the specific time frame. We want to know the names of these products too, not just their IDs. To do this, we merge (combine) the filtered sales data with the product information. We match them using the \\'product_id\\', and we keep only the \\'product_id\\' and \\'product_name\\' for our final result.\\n4. Return the resulting DataFrame as the answer.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nOverall time complexity is O(n).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef sales_analysis(product: pd.DataFrame, sales: pd.DataFrame) -> pd.DataFrame:\\n    # Group the \\'sales\\' DataFrame by \\'product_id\\' and calculate the minimum and maximum sale dates for each product\\n    sales = sales.groupby(\\'product_id\\')[\\'sale_date\\'].agg([\\'min\\', \\'max\\']).reset_index()\\n    \\n    # Filter the sales data to include only records with sale dates between January 1, 2019, and March 31, 2019\\n    sales = sales[(sales[\\'min\\'] >= \\'2019-01-01\\') & (sales[\\'max\\'] <= \\'2019-03-31\\')]\\n    \\n    # Merge the filtered sales data with the \\'product\\' DataFrame based on \\'product_id\\', keeping only \\'product_id\\' and \\'product_name\\' columns\\n    result = pd.merge(sales, product, on=\\'product_id\\', how=\\'inner\\')[[\\'product_id\\', \\'product_name\\']]\\n    \\n    # Return the resulting DataFrame\\n    return result\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef sales_analysis(product: pd.DataFrame, sales: pd.DataFrame) -> pd.DataFrame:\\n    # Group the \\'sales\\' DataFrame by \\'product_id\\' and calculate the minimum and maximum sale dates for each product\\n    sales = sales.groupby(\\'product_id\\')[\\'sale_date\\'].agg([\\'min\\', \\'max\\']).reset_index()\\n    \\n    # Filter the sales data to include only records with sale dates between January 1, 2019, and March 31, 2019\\n    sales = sales[(sales[\\'min\\'] >= \\'2019-01-01\\') & (sales[\\'max\\'] <= \\'2019-03-31\\')]\\n    \\n    # Merge the filtered sales data with the \\'product\\' DataFrame based on \\'product_id\\', keeping only \\'product_id\\' and \\'product_name\\' columns\\n    result = pd.merge(sales, product, on=\\'product_id\\', how=\\'inner\\')[[\\'product_id\\', \\'product_name\\']]\\n    \\n    # Return the resulting DataFrame\\n    return result\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3416857,
                "title": "mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect p.product_id,p.product_name from Product p,Sales s where p.product_id=s.product_id group by s.product_id having min(s.sale_date)>=\\'2019-01-01\\' and max(s.sale_date)<=\\'2019-03-31\\';\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect p.product_id,p.product_name from Product p,Sales s where p.product_id=s.product_id group by s.product_id having min(s.sale_date)>=\\'2019-01-01\\' and max(s.sale_date)<=\\'2019-03-31\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3254250,
                "title": "solution-with-not-exists-sql-server",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n-- WITH CTE AS (SELECT\\r\\n--     P.product_id,\\r\\n--     P.product_name\\r\\n-- FROM\\r\\n--     Product P\\r\\n-- INNER JOIN\\r\\n--     Sales S ON P.product_id = S.product_id\\r\\n-- AND\\r\\n--     S.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\r\\n-- )\\r\\n-- SELECT DISTINCT\\r\\n--     *\\r\\n-- FROM\\r\\n--     CTE C\\r\\n-- WHERE\\r\\n--      NOT EXISTS (\\r\\n\\r\\n--         SELECT 1\\r\\n--         FROM\\r\\n--             (\\r\\n--                     SELECT\\r\\n--                         P.product_id,\\r\\n--                         P.product_name\\r\\n--                     FROM\\r\\n--                         Product P\\r\\n--                     INNER JOIN\\r\\n--                         Sales S ON P.product_id = S.product_id\\r\\n--                     AND\\r\\n--                         S.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\r\\n--             )sub\\r\\n--          WHERE\\r\\n--             C.product_id = sub.product_id\\r\\n\\r\\n-- )\\r\\n\\r\\n\\r\\nSELECT\\r\\nDISTINCT\\r\\n    P.product_id,\\r\\n\\r\\n    P.product_name\\r\\n\\r\\nFROM\\r\\n\\r\\n    Product P\\r\\n\\r\\nINNER JOIN\\r\\n\\r\\n    Sales S ON P.product_id = S.product_id\\r\\n\\r\\nAND\\r\\n\\r\\n    S.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\r\\nWHERE\\r\\n    NOT EXISTS\\r\\n        (\\r\\n\\r\\n            SELECT\\r\\n                1\\r\\n            FROM\\r\\n                Sales SS\\r\\n            WHERE\\r\\n                SS.product_id = S.product_id\\r\\n            AND\\r\\n                SS.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\r\\n        )\\r\\n\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n-- WITH CTE AS (SELECT\\r\\n--     P.product_id,\\r\\n--     P.product_name\\r\\n-- FROM\\r\\n--     Product P\\r\\n-- INNER JOIN\\r\\n--     Sales S ON P.product_id = S.product_id\\r\\n-- AND\\r\\n--     S.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\r\\n-- )\\r\\n-- SELECT DISTINCT\\r\\n--     *\\r\\n-- FROM\\r\\n--     CTE C\\r\\n-- WHERE\\r\\n--      NOT EXISTS (\\r\\n\\r\\n--         SELECT 1\\r\\n--         FROM\\r\\n--             (\\r\\n--                     SELECT\\r\\n--                         P.product_id,\\r\\n--                         P.product_name\\r\\n--                     FROM\\r\\n--                         Product P\\r\\n--                     INNER JOIN\\r\\n--                         Sales S ON P.product_id = S.product_id\\r\\n--                     AND\\r\\n--                         S.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\r\\n--             )sub\\r\\n--          WHERE\\r\\n--             C.product_id = sub.product_id\\r\\n\\r\\n-- )\\r\\n\\r\\n\\r\\nSELECT\\r\\nDISTINCT\\r\\n    P.product_id,\\r\\n\\r\\n    P.product_name\\r\\n\\r\\nFROM\\r\\n\\r\\n    Product P\\r\\n\\r\\nINNER JOIN\\r\\n\\r\\n    Sales S ON P.product_id = S.product_id\\r\\n\\r\\nAND\\r\\n\\r\\n    S.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\r\\nWHERE\\r\\n    NOT EXISTS\\r\\n        (\\r\\n\\r\\n            SELECT\\r\\n                1\\r\\n            FROM\\r\\n                Sales SS\\r\\n            WHERE\\r\\n                SS.product_id = S.product_id\\r\\n            AND\\r\\n                SS.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\r\\n        )\\r\\n\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3208631,
                "title": "solution-with-except",
                "content": "\\n\\n\\n**select product_id, product_name from product where product_id in (\\n    select product_id from sales \\n    where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\n    except \\n    select product_id from sales \\n    where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\'\\n)**\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "\\n\\n\\n**select product_id, product_name from product where product_id in (\\n    select product_id from sales \\n    where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\n    except \\n    select product_id from sales \\n    where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\'\\n)**\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2906856,
                "title": "mysql-beats-100-only-with-one-select-inner-join-easy-to-understand-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n100%\\n\\n- Space complexity:\\n100%\\n\\n# Code\\n```\\nselect p.product_id, p.product_name from Product as p inner join Sales as s on \\np.product_id=s.product_id group by p.product_id \\nhaving min(sale_date)>=\\'2019-01-01\\' and max(sale_date)<=\\'2019-03-31\\'\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect p.product_id, p.product_name from Product as p inner join Sales as s on \\np.product_id=s.product_id group by p.product_id \\nhaving min(sale_date)>=\\'2019-01-01\\' and max(sale_date)<=\\'2019-03-31\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2563330,
                "title": "mysql-somple-solution-w-distinct",
                "content": "That\\'s all:\\n```\\nSELECT DISTINCT s.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE\\n    sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n    AND s.product_id NOT IN (\\n        SELECT product_id\\n        FROM sales\\n        WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n    );\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT s.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE\\n    sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n    AND s.product_id NOT IN (\\n        SELECT product_id\\n        FROM sales\\n        WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n    );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2546563,
                "title": "simple-solution",
                "content": "```sql\\nSELECT Sales.product_id, Product.product_name\\nFROM Sales\\nLEFT JOIN Product\\nUSING(product_id)\\nGROUP BY product_id\\nHAVING MIN(Sales.sale_date) >= \\'2019-01-01\\'\\nAND MAX(Sales.sale_date) <= \\'2019-03-31\\'\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT Sales.product_id, Product.product_name\\nFROM Sales\\nLEFT JOIN Product\\nUSING(product_id)\\nGROUP BY product_id\\nHAVING MIN(Sales.sale_date) >= \\'2019-01-01\\'\\nAND MAX(Sales.sale_date) <= \\'2019-03-31\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2522386,
                "title": "easy-solution-sql",
                "content": "~~~\\nselect product.product_id,product_name from product\\njoin sales on product.product_id=sales.product_id\\ngroup by product.product_id\\nhaving max(sale_date) <= \"2019-03-31\" and min(sale_date)>= \"2019-01-01\"\\n~~~\\n",
                "solutionTags": [],
                "code": "~~~\\nselect product.product_id,product_name from product\\njoin sales on product.product_id=sales.product_id\\ngroup by product.product_id\\nhaving max(sale_date) <= \"2019-03-31\" and min(sale_date)>= \"2019-01-01\"\\n~~~\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2492955,
                "title": "mysql-4-solutions-very-easy-if-having-join",
                "content": "### \\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F Hello, here are my solutions to the problem.\\n### Please upvote to motivate me post future solutions. HAPPY CODING \\u2764\\uFE0F\\n##### Any suggestions and improvements are always welcome.\\n##### Solution 1: If, join, long \\uD83E\\uDD26\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n##### \\u2705 Runtime: 1642 ms, faster than 32.63% of MySQL .\\n\\n```\\nwith q as (\\nselect \\n    product_id,\\n    sum(if(sale_date between \\'2019-01-01\\' and \\'2019-03-31\\', 1, 0)) sold_in_period,\\n    sum(if(sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\', 1, 0)) sold_not_in_period\\nfrom sales\\ngroup by 1\\nhaving sold_in_period > 0 and sold_not_in_period = 0\\n)\\nselect\\n    p.product_id,\\n    product_name\\nfrom product p join q\\non p.product_id = q.product_id\\n```\\n##### Solution 2: Same, but withoun join with from twice and work faster \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n##### \\u2705 Runtime: 1016 ms, faster than 88.22% of MySQL.\\n\\n```\\n# Write your MySQL query statement below\\nwith q as (\\nselect \\n    product_id,\\n    sum(if(sale_date between \\'2019-01-01\\' and \\'2019-03-31\\', 1, 0)) sold_in_period,\\n    sum(if(sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\', 1, 0)) sold_not_in_period\\nfrom sales\\ngroup by 1\\nhaving sold_in_period > 0 and sold_not_in_period = 0\\n)\\nselect\\n    p.product_id,\\n    product_name\\nfrom product p, q\\nwhere p.product_id = q.product_id\\n```\\n##### Solution 3: Same, with in close \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n##### \\u2705 Runtime: 1157 ms, faster than 67.46% of MySQL.\\n\\n```\\nwith q as (\\nselect \\n    product_id,\\n    sum(if(sale_date between \\'2019-01-01\\' and \\'2019-03-31\\', 1, 0)) sold_in_period,\\n    sum(if(sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\', 1, 0)) sold_not_in_period\\nfrom sales\\ngroup by 1\\nhaving sold_in_period > 0 and sold_not_in_period = 0\\n)\\nselect\\n    product_id,\\n    product_name\\nfrom product\\nwhere product_id in (select product_id from q)\\n```\\n##### Solution 4: MIn and max, with join, work fast, but you can do it with where close or in close (work longer)  \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n##### I really don\\'t  like joins, but work faster\\n##### \\u2705 Runtime: 996 ms, faster than 91.25% of MySQL.\\n```\\nwith q as (\\nselect product_id\\nfrom sales\\ngroup by 1\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'\\n)\\nselect\\n    p.product_id,\\n    product_name\\nfrom product p join q\\non p.product_id = q.product_id\\n```\\n\\n##### If you like the solutions, please upvote \\uD83D\\uDD3C\\n##### For any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith q as (\\nselect \\n    product_id,\\n    sum(if(sale_date between \\'2019-01-01\\' and \\'2019-03-31\\', 1, 0)) sold_in_period,\\n    sum(if(sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\', 1, 0)) sold_not_in_period\\nfrom sales\\ngroup by 1\\nhaving sold_in_period > 0 and sold_not_in_period = 0\\n)\\nselect\\n    p.product_id,\\n    product_name\\nfrom product p join q\\non p.product_id = q.product_id\\n```\n```\\n# Write your MySQL query statement below\\nwith q as (\\nselect \\n    product_id,\\n    sum(if(sale_date between \\'2019-01-01\\' and \\'2019-03-31\\', 1, 0)) sold_in_period,\\n    sum(if(sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\', 1, 0)) sold_not_in_period\\nfrom sales\\ngroup by 1\\nhaving sold_in_period > 0 and sold_not_in_period = 0\\n)\\nselect\\n    p.product_id,\\n    product_name\\nfrom product p, q\\nwhere p.product_id = q.product_id\\n```\n```\\nwith q as (\\nselect \\n    product_id,\\n    sum(if(sale_date between \\'2019-01-01\\' and \\'2019-03-31\\', 1, 0)) sold_in_period,\\n    sum(if(sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\', 1, 0)) sold_not_in_period\\nfrom sales\\ngroup by 1\\nhaving sold_in_period > 0 and sold_not_in_period = 0\\n)\\nselect\\n    product_id,\\n    product_name\\nfrom product\\nwhere product_id in (select product_id from q)\\n```\n```\\nwith q as (\\nselect product_id\\nfrom sales\\ngroup by 1\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'\\n)\\nselect\\n    p.product_id,\\n    product_name\\nfrom product p join q\\non p.product_id = q.product_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2386450,
                "title": "simple-easy-to-understand-solution",
                "content": "\\'\\'\\'\\n\\n\\n\\tselect s.product_id, p.product_name\\n\\tfrom sales s, product p\\n\\twhere s.product_id = p.product_id\\n\\tgroup by s.product_id, p.product_name\\n\\thaving min(s.sale_date) >= \\'2019-01-01\\' \\n\\t\\tand max(s.sale_date) <= \\'2019-03-31\\'\\n\\'\\'\\'",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\'\\'\\'\\n\\n\\n\\tselect s.product_id, p.product_name\\n\\tfrom sales s, product p\\n\\twhere s.product_id = p.product_id\\n\\tgroup by s.product_id, p.product_name\\n\\thaving min(s.sale_date) >= \\'2019-01-01\\' \\n\\t\\tand max(s.sale_date) <= \\'2019-03-31\\'\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2373175,
                "title": "mysql-solution",
                "content": "select distinct p1.product_id, p1.product_name\\nfrom Product p1, Sales s1\\nwhere p1.product_id not in(\\n    select product_id \\n    from Sales\\n    where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\n    and p1.product_id = s1.product_id",
                "solutionTags": [],
                "code": "select distinct p1.product_id, p1.product_name\\nfrom Product p1, Sales s1\\nwhere p1.product_id not in(\\n    select product_id \\n    from Sales\\n    where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\n    and p1.product_id = s1.product_id",
                "codeTag": "Unknown"
            },
            {
                "id": 2340435,
                "title": "explained-mysql-joins-having-group-by",
                "content": "```\\n\\n# So this command will give wrong answer because as there are duplicate\\n#in the sales table therefore if you see in example acc. to this query ,  G4 will\\n#also be printed because it has been bought in the spring  but if you see it is \\n#also been bought after the spring therefore we  have to use group by so that \\n#we get onlt those products that have only been bought in the spring\\n\\n# SELECT s.product_id, p.product_name \\n#FROM Product AS p INNER JOIN Sales AS s\\n#ON  s.product_id=p.product_id \\n#WHERE s.sale_date >= \\'2019-01-01\\' AND  s.sale_date <=\\'2019-03-31\\';\\n\\n\\n#*************************************************************************************\\n\\n\\n# therefore we will group on the basis of product ID and we will then check\\n#what are the minimum and maximum sale date for each product and \\n#thereofore if that product sale is in spring\\n\\nSELECT p.product_id, p.product_name \\nFROM Product AS p INNER JOIN Sales AS s \\nON  s.product_id=p.product_id \\nGROUP BY s.product_id \\nHAVING MIN(s.sale_date)>=\\'2019-01-01\\' AND  MAX(s.sale_date) <=\\'2019-03-31\\';\\n```",
                "solutionTags": [],
                "code": "```\\n\\n# So this command will give wrong answer because as there are duplicate\\n#in the sales table therefore if you see in example acc. to this query ,  G4 will\\n#also be printed because it has been bought in the spring  but if you see it is \\n#also been bought after the spring therefore we  have to use group by so that \\n#we get onlt those products that have only been bought in the spring\\n\\n# SELECT s.product_id, p.product_name \\n#FROM Product AS p INNER JOIN Sales AS s\\n#ON  s.product_id=p.product_id \\n#WHERE s.sale_date >= \\'2019-01-01\\' AND  s.sale_date <=\\'2019-03-31\\';\\n\\n\\n#*************************************************************************************\\n\\n\\n# therefore we will group on the basis of product ID and we will then check\\n#what are the minimum and maximum sale date for each product and \\n#thereofore if that product sale is in spring\\n\\nSELECT p.product_id, p.product_name \\nFROM Product AS p INNER JOIN Sales AS s \\nON  s.product_id=p.product_id \\nGROUP BY s.product_id \\nHAVING MIN(s.sale_date)>=\\'2019-01-01\\' AND  MAX(s.sale_date) <=\\'2019-03-31\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2306205,
                "title": "sql-for-dummies",
                "content": "\\tselect p.product_id, product_name \\n\\tfrom product p, sales s\\n\\twhere p.product_id = s.product_id\\n\\tgroup by p.product_id\\n\\thaving min(s.sale_date)>= \\'2019-01-01\\' and max(s.sale_date) <= \\'2019-03-31\\';",
                "solutionTags": [],
                "code": "\\tselect p.product_id, product_name \\n\\tfrom product p, sales s\\n\\twhere p.product_id = s.product_id\\n\\tgroup by p.product_id\\n\\thaving min(s.sale_date)>= \\'2019-01-01\\' and max(s.sale_date) <= \\'2019-03-31\\';",
                "codeTag": "Unknown"
            },
            {
                "id": 2277182,
                "title": "faster-than-95-27-of-oracle-online-submissions-for-sales-analysis-iii",
                "content": "```\\nselect p.product_id\\n        ,p.product_name\\nfrom product p\\njoin (select s.product_id from sales s\\n      group by s.product_id\\n      having min(s.sale_date) >= \\'2019-01-01\\'\\n      and max(s.sale_date) <= \\'2019-03-31\\') s1\\non\\np.product_id = s1.product_id\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect p.product_id\\n        ,p.product_name\\nfrom product p\\njoin (select s.product_id from sales s\\n      group by s.product_id\\n      having min(s.sale_date) >= \\'2019-01-01\\'\\n      and max(s.sale_date) <= \\'2019-03-31\\') s1\\non\\np.product_id = s1.product_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2249483,
                "title": "mysql-easy-solution-with-explanation-in-comment",
                "content": "```\\nSELECT\\n    product_id, product_name\\nFROM\\n    Product\\nWHERE\\n\\t# First, find out the product that were sold in 2019 Q1\\n    product_id IN (\\n        SELECT product_id\\n        FROM Sales\\n        WHERE\\n            sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n    )\\n    AND \\n\\t# Then, we have to eliminate the products which were sold besides 2019 Q1 \\n\\t# That is, we only pick those products which had never been sold \"except 2019 Q1\" (not between 2019/1/1 and 2019/3/31)\\n    product_id NOT IN (\\n        SELECT product_id\\n        FROM Sales\\n        WHERE\\n            sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n    )\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    product_id, product_name\\nFROM\\n    Product\\nWHERE\\n\\t# First, find out the product that were sold in 2019 Q1\\n    product_id IN (\\n        SELECT product_id\\n        FROM Sales\\n        WHERE\\n            sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n    )\\n    AND \\n\\t# Then, we have to eliminate the products which were sold besides 2019 Q1 \\n\\t# That is, we only pick those products which had never been sold \"except 2019 Q1\" (not between 2019/1/1 and 2019/3/31)\\n    product_id NOT IN (\\n        SELECT product_id\\n        FROM Sales\\n        WHERE\\n            sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n    )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2245933,
                "title": "mysql-solution-using-min-only",
                "content": "```\\nselect s.product_id, p.product_name\\nfrom Sales s\\njoin Product p using (product_id)\\ngroup by s.product_id having min(s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\') = 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect s.product_id, p.product_name\\nfrom Sales s\\njoin Product p using (product_id)\\ngroup by s.product_id having min(s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\') = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2226877,
                "title": "mysql-simple-approach",
                "content": "```\\nSELECT s.product_id, product_name\\nFROM Sales s LEFT JOIN Product p\\nON s.product_id = p.product_id\\nGROUP BY s.product_id\\nHAVING MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE) AND\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE);",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT s.product_id, product_name\\nFROM Sales s LEFT JOIN Product p\\nON s.product_id = p.product_id\\nGROUP BY s.product_id\\nHAVING MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE) AND\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE);",
                "codeTag": "Unknown"
            },
            {
                "id": 2203936,
                "title": "my-simple-sql-solution",
                "content": "\\n```\\n\\nSELECT\\n    p.product_id, p.product_name \\nFROM \\n    Product p\\nJOIN \\n    Sales s on p.product_id = s.product_id\\nGROUP BY \\n    s.product_id\\nHAVING \\n    min(s.sale_date) >= \\'2019-01-01\\' \\n    and \\n    max(s.sale_date) <= \\'2019-03-31\\' \\n; \\n```\\n\\nPlease Upvote if you like the solution.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nSELECT\\n    p.product_id, p.product_name \\nFROM \\n    Product p\\nJOIN \\n    Sales s on p.product_id = s.product_id\\nGROUP BY \\n    s.product_id\\nHAVING \\n    min(s.sale_date) >= \\'2019-01-01\\' \\n    and \\n    max(s.sale_date) <= \\'2019-03-31\\' \\n; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192529,
                "title": "mysql-solution-faster-than-97-93",
                "content": "```\\nSELECT \\nDISTINCT # return just once if more than 1 is sold in requested time\\nProduct.product_id, Product.product_name\\nFROM\\nProduct\\nINNER JOIN\\nSales\\nON Product.product_id = Sales.product_id\\nWHERE\\nSales.sale_date BETWEEN CAST(\\'2019-01-01\\' AS DATE) AND CAST(\\'2019-03-31\\' AS DATE) # sale has to be in requested period\\nAND\\nProduct.product_id NOT IN # sale MUST NOT BE before OR after requested dates\\n(SELECT Product.product_id\\nFROM\\nProduct\\nINNER JOIN\\nSales\\nON Product.product_id = Sales.product_id\\nWHERE\\nSales.sale_date < CAST(\\'2019-01-01\\' AS DATE) \\nOR \\nSales.sale_date > CAST(\\'2019-03-31\\' AS DATE))\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\nDISTINCT # return just once if more than 1 is sold in requested time\\nProduct.product_id, Product.product_name\\nFROM\\nProduct\\nINNER JOIN\\nSales\\nON Product.product_id = Sales.product_id\\nWHERE\\nSales.sale_date BETWEEN CAST(\\'2019-01-01\\' AS DATE) AND CAST(\\'2019-03-31\\' AS DATE) # sale has to be in requested period\\nAND\\nProduct.product_id NOT IN # sale MUST NOT BE before OR after requested dates\\n(SELECT Product.product_id\\nFROM\\nProduct\\nINNER JOIN\\nSales\\nON Product.product_id = Sales.product_id\\nWHERE\\nSales.sale_date < CAST(\\'2019-01-01\\' AS DATE) \\nOR \\nSales.sale_date > CAST(\\'2019-03-31\\' AS DATE))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2157668,
                "title": "mysql",
                "content": "SELECT product_id,product_name FROM Product\\nLEFT JOIN Sales USING(product_id)\\nGROUP BY product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\'AND MAX(sale_date) < \\'2019-04-01\\'\\n    \\n",
                "solutionTags": [],
                "code": "SELECT product_id,product_name FROM Product\\nLEFT JOIN Sales USING(product_id)\\nGROUP BY product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\'AND MAX(sale_date) < \\'2019-04-01\\'\\n    \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2120559,
                "title": "two-solution-inspired-by-other-solutions-and-as-beginner",
                "content": "\\n\\n```\\n# 1St Method\\nSELECT product_id, product_name \\nFROM Product\\nWHERE product_id NOT IN\\n(\\nSELECT product_id FROM Sales WHERE sale_date < \"2019-01-01\" OR sale_date > \"2019-03-31\"\\n);\\n\\n\\n\\n# 2nd Method using Group by\\nSELECT Sales.product_id, Product.product_name \\nFROM Sales \\nJOIN Product \\nON Product.product_id = Sales.product_id\\nGROUP BY product_id \\nHAVING MIN(sale_date) >= \"2019-01-01\" AND MAX(sale_date) <= \"2019-03-31\";\\n```",
                "solutionTags": [],
                "code": "```\\n# 1St Method\\nSELECT product_id, product_name \\nFROM Product\\nWHERE product_id NOT IN\\n(\\nSELECT product_id FROM Sales WHERE sale_date < \"2019-01-01\" OR sale_date > \"2019-03-31\"\\n);\\n\\n\\n\\n# 2nd Method using Group by\\nSELECT Sales.product_id, Product.product_name \\nFROM Sales \\nJOIN Product \\nON Product.product_id = Sales.product_id\\nGROUP BY product_id \\nHAVING MIN(sale_date) >= \"2019-01-01\" AND MAX(sale_date) <= \"2019-03-31\";\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2005173,
                "title": "sub-query-and-between",
                "content": "select product_id,product_name from product\\nwhere product_id not in\\n(select product_id from sales\\nwhere sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\');",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select product_id,product_name from product\\nwhere product_id not in\\n(select product_id from sales\\nwhere sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\');",
                "codeTag": "Unknown"
            },
            {
                "id": 1993614,
                "title": "simple-mysql-solution",
                "content": "```\\nSELECT Product.product_id, Product.product_name\\nFROM Product\\nWHERE product_id NOT IN (SELECT product_id FROM Sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\');\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Product.product_id, Product.product_name\\nFROM Product\\nWHERE product_id NOT IN (SELECT product_id FROM Sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1970379,
                "title": "mysql-solution",
                "content": "```\\nselect p.product_id, p.product_name from Product p \\n where p.product_id not in(\\n\\tselect s.product_id from Sales s \\n\\twhere sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\'\\n);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect p.product_id, p.product_name from Product p \\n where p.product_id not in(\\n\\tselect s.product_id from Sales s \\n\\twhere sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\'\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969189,
                "title": "mysql-easy-implemenation",
                "content": "```\\nSELECT Product.product_id, Product.product_name\\nFROM Product JOIN Sales\\nON Product.product_id = Sales.product_id\\nGROUP BY product_id \\nHAVING MIN(sale_date) >= \"2019-01-01\" AND MAX(sale_date) <=\"2019-03-31\"\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Product.product_id, Product.product_name\\nFROM Product JOIN Sales\\nON Product.product_id = Sales.product_id\\nGROUP BY product_id \\nHAVING MIN(sale_date) >= \"2019-01-01\" AND MAX(sale_date) <=\"2019-03-31\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1942711,
                "title": "oracle-solution-using-between",
                "content": "select product_id,product_name from Product where product_id not in \\n(select product_id from Sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\');",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "select product_id,product_name from Product where product_id not in \\n(select product_id from Sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\');",
                "codeTag": "Unknown"
            },
            {
                "id": 1939350,
                "title": "mysql-solution-database",
                "content": "Output :\\nView table have all the products that were sold only in spring 2019\\n(between 2019-01-01 and 2019-03-31)\\n\\n### *METHOD -1*\\n\\n##### USING JOIN \\n\\n-->First find those product_id where date is between 2019-01-01 and 2019-03-31 and sold only in spring 2019\\n    * Now group by the prduct_id\\n    * Then filter those data only where sale date is in spring 2019 \\n                     \\n\\t\\t\\t\\t\\t group by product_id\\n                     having min(sale_date)>=\\'2019-01-01\\' and max(sale_date)<=\\'2019-03-31\\'\\n        \\n * Now in select we will include the product_id and sale_date(if you wouldn\\'t include \\n       sale_date here it would give you error while using with having caluse)\\n         \\n                  select product_id , sale_date\\n                   from Sales\\n    \\n    Code to find the product_id require in the view table:\\n    \\n        select product_id , sale_date\\n        from Sales\\n        group by product_id\\n        having min(sale_date)>=\\'2019-01-01\\' and max(sale_date)<=\\'2019-03-31\\'\\n\\n  -> By joining the product table with above table inorder to obtaine the view table:\\n  \\n          select temp.product_id , Product.product_name \\n          from \\n          (select product_id , sale_date\\n           from Sales\\n           group by product_id\\n           having min(sale_date)>=\\'2019-01-01\\' and max(sale_date)<=\\'2019-03-31\\') temp\\n           left join Product\\n           on temp.product_id = Product.product_id;\\n         \\n -> we have use left join here beacuse in this case temp table was our primary table.\\n#####     *METHOD  2*\\n    \\n**WithOut Join** \\nfirstly find all those product id which are not sold in spring 2019 and also those who are sold more than 1 times\\n                           \\n\\t\\t\\t\\t\\t\\t   select product_id\\n                           from Sales\\n                          where sale_date not between  \\'2019-01-01\\' and \\'2019-03-31\\'\\nThen print the product_id , product_name  of those how doesn\\'t have product_id in above table \\n                   \\n\\t\\t\\t\\t   select product_id , product_name \\n                   from Product \\n                   where product_id not in(select product_id\\n                                                            from Sales\\n                                                             where sale_date not between  \\'2019-01-01\\' and \\'2019-03-31\\');",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "Output :\\nView table have all the products that were sold only in spring 2019\\n(between 2019-01-01 and 2019-03-31)\\n\\n### *METHOD -1*\\n\\n##### USING JOIN \\n\\n-->First find those product_id where date is between 2019-01-01 and 2019-03-31 and sold only in spring 2019\\n    * Now group by the prduct_id\\n    * Then filter those data only where sale date is in spring 2019 \\n                     \\n\\t\\t\\t\\t\\t group by product_id\\n                     having min(sale_date)>=\\'2019-01-01\\' and max(sale_date)<=\\'2019-03-31\\'\\n        \\n * Now in select we will include the product_id and sale_date(if you wouldn\\'t include \\n       sale_date here it would give you error while using with having caluse)\\n         \\n                  select product_id , sale_date\\n                   from Sales\\n    \\n    Code to find the product_id require in the view table:\\n    \\n        select product_id , sale_date\\n        from Sales\\n        group by product_id\\n        having min(sale_date)>=\\'2019-01-01\\' and max(sale_date)<=\\'2019-03-31\\'\\n\\n  -> By joining the product table with above table inorder to obtaine the view table:\\n  \\n          select temp.product_id , Product.product_name \\n          from \\n          (select product_id , sale_date\\n           from Sales\\n           group by product_id\\n           having min(sale_date)>=\\'2019-01-01\\' and max(sale_date)<=\\'2019-03-31\\') temp\\n           left join Product\\n           on temp.product_id = Product.product_id;\\n         \\n -> we have use left join here beacuse in this case temp table was our primary table.\\n#####     *METHOD  2*\\n    \\n**WithOut Join** \\nfirstly find all those product id which are not sold in spring 2019 and also those who are sold more than 1 times\\n                           \\n\\t\\t\\t\\t\\t\\t   select product_id\\n                           from Sales\\n                          where sale_date not between  \\'2019-01-01\\' and \\'2019-03-31\\'\\nThen print the product_id , product_name  of those how doesn\\'t have product_id in above table \\n                   \\n\\t\\t\\t\\t   select product_id , product_name \\n                   from Product \\n                   where product_id not in(select product_id\\n                                                            from Sales\\n                                                             where sale_date not between  \\'2019-01-01\\' and \\'2019-03-31\\');",
                "codeTag": "Unknown"
            },
            {
                "id": 1912348,
                "title": "mysql-without-min-max-subquery",
                "content": "```\\n\\nselect\\ns.product_id, product_name\\nfrom Sales s\\njoin product p\\non (p.product_id=s.product_id)\\ngroup by product_id, product_name\\nhaving sum(case when sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' then 0 else 1 end)=0 \\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nselect\\ns.product_id, product_name\\nfrom Sales s\\njoin product p\\non (p.product_id=s.product_id)\\ngroup by product_id, product_name\\nhaving sum(case when sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' then 0 else 1 end)=0 \\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1898936,
                "title": "groupby-having",
                "content": "-- get min, max product sales date by using group by product_id\\n-- filter products that min sales_date >=2019-1-1 and max sale_date <=2019-3-31\\n-- return selected products\\n\\n```\\nselect p.product_id, p.product_name\\nfrom Sales s\\njoin Product p\\n\\ton s.product_id=p.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date)>=\\'2019-1-1\\' and max(s.sale_date)<=\\'2019-3-31\\';\\n```",
                "solutionTags": [],
                "code": "```\\nselect p.product_id, p.product_name\\nfrom Sales s\\njoin Product p\\n\\ton s.product_id=p.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date)>=\\'2019-1-1\\' and max(s.sale_date)<=\\'2019-3-31\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1894997,
                "title": "simple-mysql-solution-2-different-solutions",
                "content": "```\\nselect product.product_id, product_name\\nfrom product join sales on product.product_id = sales.product_id\\ngroup by product_id, product_name\\nhaving SUM(sale_date BETWEEN \"2019-01-01\" AND \"2019-03-31\") > 0\\nand SUM(sale_date > \"2019-03-31\" or sale_date < \"2019-01-01\") = 0\\n\\nselect product.product_id, product_name\\nfrom product join sales on product.product_id = sales.product_id\\ngroup by product_id having min(sale_date) >= \"2019-01-01\" and max(sale_date) <= \"2019-03-31\"\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect product.product_id, product_name\\nfrom product join sales on product.product_id = sales.product_id\\ngroup by product_id, product_name\\nhaving SUM(sale_date BETWEEN \"2019-01-01\" AND \"2019-03-31\") > 0\\nand SUM(sale_date > \"2019-03-31\" or sale_date < \"2019-01-01\") = 0\\n\\nselect product.product_id, product_name\\nfrom product join sales on product.product_id = sales.product_id\\ngroup by product_id having min(sale_date) >= \"2019-01-01\" and max(sale_date) <= \"2019-03-31\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884795,
                "title": "simple-mysql",
                "content": "```\\n# Write your MySQL query statement below\\nselect p.product_id, p.product_name from product p inner join  sales s on s.product_id = p.product_id group by s.product_id having min(s.sale_date) >= \"2019-01-01\" and max(s.sale_date) <= \"2019-03-31\";\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect p.product_id, p.product_name from product p inner join  sales s on s.product_id = p.product_id group by s.product_id having min(s.sale_date) >= \"2019-01-01\" and max(s.sale_date) <= \"2019-03-31\";\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1559756,
                "title": "mysql-simple-solution",
                "content": "SELECT product_id, product_name \\nFROM Product \\nWHERE product_id NOT IN (\\n    SELECT product_id \\n\\tFROM Sales \\n    WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n)",
                "solutionTags": [],
                "code": "SELECT product_id, product_name \\nFROM Product \\nWHERE product_id NOT IN (\\n    SELECT product_id \\n\\tFROM Sales \\n    WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n)",
                "codeTag": "Unknown"
            },
            {
                "id": 1397615,
                "title": "mysql-using-group-by",
                "content": "```\\n\\nselect p.product_id, p.product_name\\nfrom product p, sales s\\nwhere p.product_id= s.product_id\\ngroup by p.product_id\\nhaving sum(case when  sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' then 1 else 0 end) >0\\nand sum( case when  sale_date < \\'2019-01-01\\'  then 1 else 0 end) = 0\\nand sum( case when  sale_date > \\'2019-03-31\\' then 1 else 0 end) =0\\n```",
                "solutionTags": [],
                "code": "```\\n\\nselect p.product_id, p.product_name\\nfrom product p, sales s\\nwhere p.product_id= s.product_id\\ngroup by p.product_id\\nhaving sum(case when  sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' then 1 else 0 end) >0\\nand sum( case when  sale_date < \\'2019-01-01\\'  then 1 else 0 end) = 0\\nand sum( case when  sale_date > \\'2019-03-31\\' then 1 else 0 end) =0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1203987,
                "title": "group-by-min-max",
                "content": "check min(), max() in 2019 spring.\\n```\\nselect p.product_id, p.product_name\\nfrom\\n(\\n  select product_id, max(sale_date) lo, min(sale_date) hi\\n  from sales\\n  group by product_id\\n  having max(sale_date) <= \\'2019-03-31\\' and min(sale_date) >= \\'2019-01-01\\'\\n) t, product p\\nwhere t.product_id = p.product_id;\\n```",
                "solutionTags": [],
                "code": "```\\nselect p.product_id, p.product_name\\nfrom\\n(\\n  select product_id, max(sale_date) lo, min(sale_date) hi\\n  from sales\\n  group by product_id\\n  having max(sale_date) <= \\'2019-03-31\\' and min(sale_date) >= \\'2019-01-01\\'\\n) t, product p\\nwhere t.product_id = p.product_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 987529,
                "title": "mysql-faster-than-95",
                "content": "select p.product_id, p.product_name \\nfrom product p\\nleft join sales s on\\np.product_id = s.product_id\\ngroup by p.product_id\\nhaving min(s.sale_date)>=\\'2019-01-01\\' and max(s.sale_date)<=\\'2019-03-31\\'\\n",
                "solutionTags": [],
                "code": "select p.product_id, p.product_name \\nfrom product p\\nleft join sales s on\\np.product_id = s.product_id\\ngroup by p.product_id\\nhaving min(s.sale_date)>=\\'2019-01-01\\' and max(s.sale_date)<=\\'2019-03-31\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 923751,
                "title": "simple-join-having-min-max",
                "content": "```\\n# Write your MySQL query statement below\\nselect \\n    distinct p.product_id,\\n    p.product_name\\nfrom product p\\nleft join sales s\\non p.product_id = s.product_id\\ngroup by p.product_id\\nhaving max(s.sale_date) between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand min(s.sale_date) between \\'2019-01-01\\' and \\'2019-03-31\\'\\n \\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\n    distinct p.product_id,\\n    p.product_name\\nfrom product p\\nleft join sales s\\non p.product_id = s.product_id\\ngroup by p.product_id\\nhaving max(s.sale_date) between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand min(s.sale_date) between \\'2019-01-01\\' and \\'2019-03-31\\'\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 919456,
                "title": "simple-subquery-beats-98-6",
                "content": "SELECT product_id, product_name\\nFROM Product\\nWHERE product_id NOT IN\\n(\\nSELECT product_id\\nFROM Sales\\nWHERE sale_date NOT BETWEEN \"2019-01-01\" AND \"2019-03-31\")\\n\\nFilter out the records which fall in the given interval. Display the records which are not those records basically.",
                "solutionTags": [],
                "code": "SELECT product_id, product_name\\nFROM Product\\nWHERE product_id NOT IN\\n(\\nSELECT product_id\\nFROM Sales\\nWHERE sale_date NOT BETWEEN \"2019-01-01\" AND \"2019-03-31\")\\n\\nFilter out the records which fall in the given interval. Display the records which are not those records basically.",
                "codeTag": "Unknown"
            },
            {
                "id": 480223,
                "title": "multiple-oracle-solutions",
                "content": "```\\n/* Write your PL/SQL query statement below */\\nselect p.product_id, p.product_name \\nfrom Product p INNER JOIN Sales s on p.product_id = s.product_id\\ngroup by p.product_id, p.product_name\\nhaving MIN(s.sale_date) >= to_date(\\'2019-01-01\\',\\'YYYY-MM-DD\\') and \\nMAX(s.sale_date) <= to_date(\\'2019-03-31\\',\\'YYYY-MM-DD\\')\\n```\\n\\n```\\n/* Write your PL/SQL query statement below */\\nselect a.product_id,a.product_name\\nfrom product a inner join sales b on a.product_id = b.product_id\\nwhere b.sale_date between to_date(\\'2019-01-01\\',\\'YYYY-MM-DD\\') and to_date(\\'2019-03-31\\',\\'YYYY-MM-DD\\')\\nMINUS\\nselect a.product_id,a.product_name\\nfrom product a inner join sales b on a.product_id = b.product_id\\nwhere NOT (b.sale_date between to_date(\\'2019-01-01\\',\\'YYYY-MM-DD\\') and to_date(\\'2019-03-31\\',\\'YYYY-MM-DD\\'))\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect p.product_id, p.product_name \\nfrom Product p INNER JOIN Sales s on p.product_id = s.product_id\\ngroup by p.product_id, p.product_name\\nhaving MIN(s.sale_date) >= to_date(\\'2019-01-01\\',\\'YYYY-MM-DD\\') and \\nMAX(s.sale_date) <= to_date(\\'2019-03-31\\',\\'YYYY-MM-DD\\')\\n```\n```\\n/* Write your PL/SQL query statement below */\\nselect a.product_id,a.product_name\\nfrom product a inner join sales b on a.product_id = b.product_id\\nwhere b.sale_date between to_date(\\'2019-01-01\\',\\'YYYY-MM-DD\\') and to_date(\\'2019-03-31\\',\\'YYYY-MM-DD\\')\\nMINUS\\nselect a.product_id,a.product_name\\nfrom product a inner join sales b on a.product_id = b.product_id\\nwhere NOT (b.sale_date between to_date(\\'2019-01-01\\',\\'YYYY-MM-DD\\') and to_date(\\'2019-03-31\\',\\'YYYY-MM-DD\\'))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 356735,
                "title": "simply-one-line-solution",
                "content": "select s.product_id, p.product_name \\nfrom Sales s left join Product p \\non s.product_id=p.product_id \\ngroup by product_id \\nhaving min(sale_date)>=\\'2019-01-01\\' and max(sale_date) <=\\'2019-03-31\\'",
                "solutionTags": [],
                "code": "select s.product_id, p.product_name \\nfrom Sales s left join Product p \\non s.product_id=p.product_id \\ngroup by product_id \\nhaving min(sale_date)>=\\'2019-01-01\\' and max(sale_date) <=\\'2019-03-31\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 311599,
                "title": "mysql-using-not-in",
                "content": "```\\nselect distinct product_id, product_name\\nfrom sales join product using(product_id)\\nwhere sale_date between cast(\\'2019-01-01\\' as DATE) and cast(\\'2019-03-31\\' as DATE)\\nand product_id not in (select distinct product_id\\n                        from sales\\n                        where sale_date < cast(\\'2019-01-01\\' as DATE) or sale_date > cast(\\'2019-03-31\\' as DATE))\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct product_id, product_name\\nfrom sales join product using(product_id)\\nwhere sale_date between cast(\\'2019-01-01\\' as DATE) and cast(\\'2019-03-31\\' as DATE)\\nand product_id not in (select distinct product_id\\n                        from sales\\n                        where sale_date < cast(\\'2019-01-01\\' as DATE) or sale_date > cast(\\'2019-03-31\\' as DATE))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065755,
                "title": "sales-analysis-iii-pandas-easy",
                "content": "[see the successfully Accepted Submission](https://leetcode.com/submissions/detail/1053850673/)\\n```\\nimport pandas as pd\\n\\ndef sales_analysis(product: pd.DataFrame, sales: pd.DataFrame) -> pd.DataFrame:\\n    # First, we convert \\'sale_date\\' column to datetime if it\\'s not already in datetime format\\n    sales[\\'sale_date\\'] = pd.to_datetime(sales[\\'sale_date\\'])\\n\\n    # Secondly, the \\'product\\' with \\'sales\\' based on \\'product_id\\' are merged\\n    merged_data = pd.merge(product, sales, on=\\'product_id\\', how=\\'inner\\')\\n\\n    # Then, we apply group by for \\'product_id\\' and apply aggregation functions\\n    result = merged_data.groupby(\\'product_id\\').agg(\\n        min_sale_date=(\\'sale_date\\', \\'min\\'),\\n        max_sale_date=(\\'sale_date\\', \\'max\\'),\\n        product_name=(\\'product_name\\', \\'first\\')  # Include \\'product_name\\' in the aggregation\\n    )\\n    \\n    # In the next step, the dates after January (including January) are filtered\\n    after_january = (result[\\'min_sale_date\\'] >= \\'2019-01-01\\')\\n    \\n    # At the same time, the dates before March (including March) are also filtered\\n    before_march = (result[\\'max_sale_date\\'] <= \\'2019-03-31\\')\\n\\n    # After that, the results based on date criteria are filtered. The criteria is reporting the products that were only sold in the first quarter of 2019. That is, between 2019-01-01 and 2019-03-31 inclusive.\\n    filtered_df = result[after_january & before_march]\\n\\n    # Next, the index to make \\'product_id\\' a regular column is reset.\\n    new_df = filtered_df.reset_index(inplace=False)\\n\\n    # Finally, we select the desired columns \\'product_id\\' and \\'product_name\\'\\n    quarter_products  = new_df[[\\'product_id\\', \\'product_name\\']]\\n\\n    return quarter_products\\n    \\n```\\n\\n**SQL**\\n\\n[see the successfully Accepted Submission](https://leetcode.com/submissions/detail/1061692619/)\\n\\n```\\nSELECT _sales.product_id, product_name\\nFROM Sales _sales \\n\\nLEFT JOIN Product _product\\nON _sales.product_id = _product.product_id\\n\\nGROUP BY _sales.product_id\\nHAVING MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE) \\nAND\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE);\\n```\\n\\n```\\n-- Select the product_id and product_name columns\\nSELECT _sales.product_id, product_name\\n-- From the Sales table, alias it as \"_sales\"\\nFROM Sales _sales \\n\\n-- Perform a LEFT JOIN with the Product table, alias it as \"_product\"\\nLEFT JOIN Product _product\\n-- Match records where the product_id in Sales matches the product_id in Product\\nON _sales.product_id = _product.product_id\\n\\n-- Group the result set by the product_id from Sales\\nGROUP BY _sales.product_id\\n\\n-- Filter the grouped results based on certain conditions\\n-- Keep groups where the minimum sale_date is greater than or equal to \\'2019-01-01\\'\\n-- AND where the maximum sale_date is less than or equal to \\'2019-03-31\\'\\nHAVING MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE) \\nAND\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE);\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a99c5d9e-1502-4422-8df2-cd1b28a1c36a_1695148155.081576.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\nimport pandas as pd\\n\\ndef sales_analysis(product: pd.DataFrame, sales: pd.DataFrame) -> pd.DataFrame:\\n    # First, we convert \\'sale_date\\' column to datetime if it\\'s not already in datetime format\\n    sales[\\'sale_date\\'] = pd.to_datetime(sales[\\'sale_date\\'])\\n\\n    # Secondly, the \\'product\\' with \\'sales\\' based on \\'product_id\\' are merged\\n    merged_data = pd.merge(product, sales, on=\\'product_id\\', how=\\'inner\\')\\n\\n    # Then, we apply group by for \\'product_id\\' and apply aggregation functions\\n    result = merged_data.groupby(\\'product_id\\').agg(\\n        min_sale_date=(\\'sale_date\\', \\'min\\'),\\n        max_sale_date=(\\'sale_date\\', \\'max\\'),\\n        product_name=(\\'product_name\\', \\'first\\')  # Include \\'product_name\\' in the aggregation\\n    )\\n    \\n    # In the next step, the dates after January (including January) are filtered\\n    after_january = (result[\\'min_sale_date\\'] >= \\'2019-01-01\\')\\n    \\n    # At the same time, the dates before March (including March) are also filtered\\n    before_march = (result[\\'max_sale_date\\'] <= \\'2019-03-31\\')\\n\\n    # After that, the results based on date criteria are filtered. The criteria is reporting the products that were only sold in the first quarter of 2019. That is, between 2019-01-01 and 2019-03-31 inclusive.\\n    filtered_df = result[after_january & before_march]\\n\\n    # Next, the index to make \\'product_id\\' a regular column is reset.\\n    new_df = filtered_df.reset_index(inplace=False)\\n\\n    # Finally, we select the desired columns \\'product_id\\' and \\'product_name\\'\\n    quarter_products  = new_df[[\\'product_id\\', \\'product_name\\']]\\n\\n    return quarter_products\\n    \\n```\n```\\nSELECT _sales.product_id, product_name\\nFROM Sales _sales \\n\\nLEFT JOIN Product _product\\nON _sales.product_id = _product.product_id\\n\\nGROUP BY _sales.product_id\\nHAVING MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE) \\nAND\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE);\\n```\n```\\n-- Select the product_id and product_name columns\\nSELECT _sales.product_id, product_name\\n-- From the Sales table, alias it as \"_sales\"\\nFROM Sales _sales \\n\\n-- Perform a LEFT JOIN with the Product table, alias it as \"_product\"\\nLEFT JOIN Product _product\\n-- Match records where the product_id in Sales matches the product_id in Product\\nON _sales.product_id = _product.product_id\\n\\n-- Group the result set by the product_id from Sales\\nGROUP BY _sales.product_id\\n\\n-- Filter the grouped results based on certain conditions\\n-- Keep groups where the minimum sale_date is greater than or equal to \\'2019-01-01\\'\\n-- AND where the maximum sale_date is less than or equal to \\'2019-03-31\\'\\nHAVING MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE) \\nAND\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE);\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4022014,
                "title": "fast-and-efficient-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the unique product IDs and names from the first quarter sales that are not present in the rest of the sales data.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve the problem of finding unique product IDs and names from the first quarter sales that are not present in the rest of the sales data, the following approach is taken:\\n- Filter the `sales` DataFrame to obtain the sales data for the first quarter, defined as the period from `\"2019-01-01\"` to `\"2019-03-31\"`. This is done by creating a boolean mask using the `>=` and `<=` operators on the `\"sale_date\"` column.\\n- Drop any duplicate rows based on the `product_id` in the first quarter sales using the `drop_duplicates` method. This ensures that only unique product IDs are considered.\\n- Separate the rest of the sales data by filtering the `sales` DataFrame based on the condition that the `\"sale_date\"` is either before the start of the first quarter or after the end of the first quarter. This is done using the `|` (`OR`) operator.\\n- Use the `isin` method to create **a boolean mask** that identifies the product IDs from the first quarter sales that are also present in the rest of the sales data.\\n- Invert the boolean mask using the `~` operator to select the product IDs from the first quarter sales that are not present in the rest of the sales data.\\n- Merge the filtered first quarter sales with the `product` DataFrame based on the `product_id` using the `merge` method. This ensures that the resulting DataFrame contains the corresponding product names.\\n- Return the resulting DataFrame with only the `product_id` and `product_name` columns.\\n\\nThis approach efficiently filters and merges the data to obtain the desired result. By dropping duplicate rows and using the `isin` method, we ensure that only unique product IDs and names are returned. The use of boolean masks allows for easy identification of product IDs that are present or not present in the rest of the sales data.\\n# Complexity\\n#### Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n + m)$$ The time complexity of this approach is dependent on the size of the `sales` DataFrame. The filtering and merging operations have a time complexity of $$O(n)$$, where $$n$$ is the number of rows in the DataFrame. The use of `isin` has a time complexity of $$O(m)$$, where $$m$$ is the number of unique product IDs in the first quarter sales (`first_q_sales`). \\n#### Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIn the given approach, the space complexity can be analyzed as follows:\\n- The `sales` DataFrame for the first quarter is filtered and stored in memory. The size of this DataFrame depends on the number of rows and columns in the original data, but for the purpose of space complexity analysis, we can assume it takes $$O(n)$$ space, where $$n$$ is the number of records in the first quarter sales data.\\n- The duplicate rows are dropped from the first quarter `sales` DataFrame, resulting in a new DataFrame with unique product IDs. The space required for this operation is proportional to the number of unique product IDs, which we can assume to be $$O(m)$$, where $$m$$ is the number of unique product IDs in the first quarter sales data.\\n- Another DataFrame is created to store the rest of the sales data that is not in the first quarter. The space required for this DataFrame is again proportional to the number of records in the rest of the sales data, which we can assume to be $$O(k)$$, where $$k$$ is the number of records in the rest of the sales data.\\n- A boolean mask is created to identify the product IDs from the first quarter sales that are also present in the rest of the sales data. This boolean mask requires additional space to store the boolean values for each product ID. Since the size of the mask is equal to the number of unique product IDs in the first quarter sales data, we can assume its space complexity to be $$O(m)$$.\\n- The inverted boolean mask is used to select the product IDs from the first quarter sales that are not present in the rest of the sales data. This selection operation does not require any additional memory as it operates on the existing boolean mask.\\n- Finally, the resulting DataFrame with the selected product IDs and names is returned. The space required for this DataFrame is again proportional to the number of unique product IDs in the first quarter sales data, which we can assume to be $$O(m)$$.\\n\\n**TL;DR** \\nOverall, the space complexity of the approach can be approximated as $$O(n + m + k)$$, where $$n$$ is the number of records in the first quarter sales data, $$m$$ is the number of unique product IDs in the first quarter sales data, and $$k$$ is the number of records in the rest of the sales data.\\n# Running & Memory\\n![Screenshot 2023-09-09 at 15.34.45.png](https://assets.leetcode.com/users/images/acc345a4-fde5-4d4a-81c9-0a580ec5360c_1694256298.5338826.png)\\n\\n# Code\\n```\\nimport pandas as pd\\n\\n\\ndef sales_analysis(product: pd.DataFrame, sales: pd.DataFrame) -> pd.DataFrame:\\n    start, finish = \"2019-01-01\", \"2019-03-31\"\\n    first_q_sales = sales[\\n        (sales[\"sale_date\"] >= start) & (sales[\"sale_date\"] <= finish)\\n    ][[\"product_id\"]].drop_duplicates()\\n    other_sales = sales[(sales[\"sale_date\"] < start) | (sales[\"sale_date\"] > finish)][\\n        [\"product_id\"]\\n    ]\\n    mask = first_q_sales[\"product_id\"].isin(other_sales[\"product_id\"])\\n    return first_q_sales[~mask].merge(product, on=\"product_id\")[\\n        [\"product_id\", \"product_name\"]\\n    ]\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\n\\ndef sales_analysis(product: pd.DataFrame, sales: pd.DataFrame) -> pd.DataFrame:\\n    start, finish = \"2019-01-01\", \"2019-03-31\"\\n    first_q_sales = sales[\\n        (sales[\"sale_date\"] >= start) & (sales[\"sale_date\"] <= finish)\\n    ][[\"product_id\"]].drop_duplicates()\\n    other_sales = sales[(sales[\"sale_date\"] < start) | (sales[\"sale_date\"] > finish)][\\n        [\"product_id\"]\\n    ]\\n    mask = first_q_sales[\"product_id\"].isin(other_sales[\"product_id\"])\\n    return first_q_sales[~mask].merge(product, on=\"product_id\")[\\n        [\"product_id\", \"product_name\"]\\n    ]\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3958999,
                "title": "easy-to-understand-beginner-friendly",
                "content": "# EASY TO UNDERSTAND, BEGINNER FRIENDLY \\uD83D\\uDD25\\n<!-- x your first thoughts on how to solve this problem. -->\\n easy to understand \\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect p.product_id, p.product_name \\nfrom Product p\\nWHERE p.product_id IN (SELECT s.product_id FROM Sales s \\n          WHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\') \\nAND p.product_id NOT IN (SELECT s.product_id FROM Sales s \\n          WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect p.product_id, p.product_name \\nfrom Product p\\nWHERE p.product_id IN (SELECT s.product_id FROM Sales s \\n          WHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\') \\nAND p.product_id NOT IN (SELECT s.product_id FROM Sales s \\n          WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3958993,
                "title": "where-not-between-easy-solution",
                "content": "# Intuition\\nFast and clearly to understanf for beginners\\n\\n\\n# Code\\n```\\nSELECT product_id, product_name\\nFROM product\\nWHERE product_id IN (\\n    SELECT product_id\\n    FROM sales\\n    WHERE sale_date  BETWEEN \\'2019-01-01\\' AND  \\'2019-03-31\\'\\n) AND product_id NOT IN (\\n    SELECT product_id\\n    FROM sales\\n    WHERE sale_date NOT  BETWEEN \\'2019-01-01\\' AND  \\'2019-03-31\\'\\n);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT product_id, product_name\\nFROM product\\nWHERE product_id IN (\\n    SELECT product_id\\n    FROM sales\\n    WHERE sale_date  BETWEEN \\'2019-01-01\\' AND  \\'2019-03-31\\'\\n) AND product_id NOT IN (\\n    SELECT product_id\\n    FROM sales\\n    WHERE sale_date NOT  BETWEEN \\'2019-01-01\\' AND  \\'2019-03-31\\'\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3930752,
                "title": "pandas-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef sales_analysis(product: pd.DataFrame, sales: pd.DataFrame) -> pd.DataFrame:\\n  data = product.merge(sales, how =\\'left\\', on = \\'product_id\\').query(\"sale_date < \\'2019-01-01\\' or sale_date>\\'2019-03-31\\' or sale_date.isnull()\")\\n  data_1 = product[[\\'product_id\\',\\'product_name\\']].query(\"~product_id.isin(@data[\\'product_id\\'])\")\\n  return data_1\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef sales_analysis(product: pd.DataFrame, sales: pd.DataFrame) -> pd.DataFrame:\\n  data = product.merge(sales, how =\\'left\\', on = \\'product_id\\').query(\"sale_date < \\'2019-01-01\\' or sale_date>\\'2019-03-31\\' or sale_date.isnull()\")\\n  data_1 = product[[\\'product_id\\',\\'product_name\\']].query(\"~product_id.isin(@data[\\'product_id\\'])\")\\n  return data_1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3589300,
                "title": "fast-and-simple-query-by-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect s.product_id, p.product_name from Product p\\njoin Sales s on p.product_id = s.product_id\\ngroup by product_id\\nhaving max(s.sale_date) <= \\'2019-03-31\\' and min(s.sale_date) >= \\'2019-01-01\\'\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.product_id, p.product_name from Product p\\njoin Sales s on p.product_id = s.product_id\\ngroup by product_id\\nhaving max(s.sale_date) <= \\'2019-03-31\\' and min(s.sale_date) >= \\'2019-01-01\\'\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3552745,
                "title": "using-inner-join",
                "content": "# Code\\n```\\nSELECT S.product_id, P.product_name FROM Product P\\nINNER JOIN Sales S ON P.product_id = S.product_id\\nGROUP BY S.product_id \\nHAVING MIN(S.sale_date) >= \\'2019-01-01\\' AND MAX(S.sale_date) <= \\'2019-03-31\\';\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT S.product_id, P.product_name FROM Product P\\nINNER JOIN Sales S ON P.product_id = S.product_id\\nGROUP BY S.product_id \\nHAVING MIN(S.sale_date) >= \\'2019-01-01\\' AND MAX(S.sale_date) <= \\'2019-03-31\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3436113,
                "title": "using-over-partition-clause",
                "content": "\\n\\n\\n# using sub Queries \\n```\\nselect p.product_id, p.product_name\\nfrom Product p\\nwhere (select min(s.sale_date) from Sales s where s.product_id = p.product_id) >= \\'2019-01-01\\' and\\n(select max(s.sale_date) from Sales s where s.product_id = p.product_id) <= \\'2019-03-31\\';\\n```\\n\\n# Using over() partition Clause\\n```\\nselect distinct p.product_id, p.product_name\\nfrom \\n(select *, min(sale_date) over(partition by product_id) as minD, max(sale_date) over(partition by product_id) as maxD from Sales) a join Product p on a.product_id = p.product_id\\nwhere minD >= \\'2019-01-01\\' and maxD <= \\'2019-03-31\\';\\n```\\n\\n\\n# Approach\\nThe given SQL query retrieves a list of distinct product IDs and product names for all products that were sold between January 1st, 2019 and March 31st, 2019.\\n\\nThe query first selects all columns from the \"Sales\" table and adds two additional columns using the \"min\" and \"max\" functions over the \"sale_date\" column, respectively. These functions are used to calculate the earliest and latest sale dates for each product, which are labeled as \"minD\" and \"maxD\". The \"partition by\" clause is used with the \"over\" clause to group the sales data by product ID.\\n\\nThe result of the subquery is then joined with the \"Product\" table on the common \"product_id\" column. This allows the product name to be added to the final result set.\\n\\nFinally, the \"WHERE\" clause filters the result set to only include products that have a minimum sale date of January 1st, 2019 or later and a maximum sale date of March 31st, 2019 or earlier. The \">= \\'2019-01-01\\'\" and \"<= \\'2019-03-31\\'\" conditions are used to achieve this.\\n\\nIn summary, this SQL query selects distinct product IDs and names for products that were sold between January 1st, 2019 and March 31st, 2019, and sorts them by product ID.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect p.product_id, p.product_name\\nfrom Product p\\nwhere (select min(s.sale_date) from Sales s where s.product_id = p.product_id) >= \\'2019-01-01\\' and\\n(select max(s.sale_date) from Sales s where s.product_id = p.product_id) <= \\'2019-03-31\\';\\n```\n```\\nselect distinct p.product_id, p.product_name\\nfrom \\n(select *, min(sale_date) over(partition by product_id) as minD, max(sale_date) over(partition by product_id) as maxD from Sales) a join Product p on a.product_id = p.product_id\\nwhere minD >= \\'2019-01-01\\' and maxD <= \\'2019-03-31\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3101115,
                "title": "ms-sql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT DISTINCT\\n    p.product_id,\\n    p.product_name \\nFROM Sales s\\nJOIN Product p\\n    ON p.product_id = s.product_id \\nWHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND NOT EXISTS (\\n    SELECT 1\\n    FROM Sales s\\n    WHERE s.product_id = p.product_id\\n    AND s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n)\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT DISTINCT\\n    p.product_id,\\n    p.product_name \\nFROM Sales s\\nJOIN Product p\\n    ON p.product_id = s.product_id \\nWHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND NOT EXISTS (\\n    SELECT 1\\n    FROM Sales s\\n    WHERE s.product_id = p.product_id\\n    AND s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3085299,
                "title": "mysql-min-max-having",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT p.product_id,p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id=s.product_id\\nGROUP BY s.product_id\\nHAVING MIN(s.sale_date)>\\'2018-12-31\\' AND MAX(s.sale_date)<\\'2019-04-01\\'\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT p.product_id,p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id=s.product_id\\nGROUP BY s.product_id\\nHAVING MIN(s.sale_date)>\\'2018-12-31\\' AND MAX(s.sale_date)<\\'2019-04-01\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3050808,
                "title": "easiest-mysql-solution",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect product_id,product_name from Product\\nwhere product_id not in (select distinct product_id\\nfrom Sales\\nwhere sale_date<\\'2019-01-01\\' or sale_date>\\'2019-03-31\\') \\nand product_id in (select distinct product_id from\\nSales)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect product_id,product_name from Product\\nwhere product_id not in (select distinct product_id\\nfrom Sales\\nwhere sale_date<\\'2019-01-01\\' or sale_date>\\'2019-03-31\\') \\nand product_id in (select distinct product_id from\\nSales)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2978055,
                "title": "solution-for-1084-sales-analysis-iii",
                "content": "# Intuition\\r\\nObtain all the product id that were sold apart from requested dates.\\r\\noutput unique pid, pnames that are not in above result\\r\\n\\r\\n# Approach\\r\\nUse temp table to join both sales and pproduct table\\r\\nInner join is needed.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n# Write your MySQL query statement below\\r\\n/* creating temp table*/\\r\\nWITH new_tbl AS\\r\\n\\r\\n(SELECT a.product_id AS pid,a.product_name AS pname, b.sale_date AS sd\\r\\nFROM Product AS a\\r\\nINNER JOIN Sales AS b\\r\\nON a.product_id = b.product_id)\\r\\n\\r\\n/*main query*/\\r\\nSELECT pid AS product_id,pname AS product_name\\r\\nFROM new_tbl\\r\\nWHERE pid NOT IN \\r\\n/* sub query to identify all the product id that were sold apart from requested dates.*/\\r\\n(\\r\\nSELECT pid FROM new_tbl \\r\\nWHERE sd NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\r\\n)\\r\\n\\r\\n/* use group by to obtain unique values */\\r\\nGROUP BY pid\\r\\n;\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\n# Write your MySQL query statement below\\r\\n/* creating temp table*/\\r\\nWITH new_tbl AS\\r\\n\\r\\n(SELECT a.product_id AS pid,a.product_name AS pname, b.sale_date AS sd\\r\\nFROM Product AS a\\r\\nINNER JOIN Sales AS b\\r\\nON a.product_id = b.product_id)\\r\\n\\r\\n/*main query*/\\r\\nSELECT pid AS product_id,pname AS product_name\\r\\nFROM new_tbl\\r\\nWHERE pid NOT IN \\r\\n/* sub query to identify all the product id that were sold apart from requested dates.*/\\r\\n(\\r\\nSELECT pid FROM new_tbl \\r\\nWHERE sd NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\r\\n)\\r\\n\\r\\n/* use group by to obtain unique values */\\r\\nGROUP BY pid\\r\\n;\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2976646,
                "title": "my-sql-solution-left-join-having",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSelect X.product_id, product_name\\nFrom(\\nSelect Product.product_id, product_name,sale_date\\nFrom Product left join Sales on Product.product_id = Sales.product_id\\nGroup by Product.product_id\\nHaving sale_date between \\'2019-01-01\\' and \\'2019-03-31\\') X\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSelect X.product_id, product_name\\nFrom(\\nSelect Product.product_id, product_name,sale_date\\nFrom Product left join Sales on Product.product_id = Sales.product_id\\nGroup by Product.product_id\\nHaving sale_date between \\'2019-01-01\\' and \\'2019-03-31\\') X\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2703382,
                "title": "mysql-solution",
                "content": "```\\nselect s.product_id, product_name\\nfrom sales s\\nleft join product p on s.product_id= p.product_id\\ngroup by s.product_id\\nhaving min(sale_date)>= cast(\"2019-01-01\" as date) and\\n       max(sale_date)<= cast(\"2019-03-31\" as date)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.product_id, product_name\\nfrom sales s\\nleft join product p on s.product_id= p.product_id\\ngroup by s.product_id\\nhaving min(sale_date)>= cast(\"2019-01-01\" as date) and\\n       max(sale_date)<= cast(\"2019-03-31\" as date)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621684,
                "title": "left-join",
                "content": "SELECT p.product_id,p.product_name FROM Product p\\nLEFT JOIN Sales s\\nON p.product_id=s.product_id\\nGROUP BY p.product_id\\nHAVING MIN(s.sale_date)>= \\'2019-01-01\\' AND MAX(s.sale_date)<=\\'2019-03-31\\';",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT p.product_id,p.product_name FROM Product p\\nLEFT JOIN Sales s\\nON p.product_id=s.product_id\\nGROUP BY p.product_id\\nHAVING MIN(s.sale_date)>= \\'2019-01-01\\' AND MAX(s.sale_date)<=\\'2019-03-31\\';",
                "codeTag": "Unknown"
            },
            {
                "id": 2621522,
                "title": "left-join-group-by-having-solution",
                "content": "```\\nSELECT p.product_id , p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nGROUP BY s.product_id\\nHAVING MIN(s.sale_date) >= \\'2019-01-01\\' AND MAX(s.sale_date) <= \\'2019-03-31\\'\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT p.product_id , p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nGROUP BY s.product_id\\nHAVING MIN(s.sale_date) >= \\'2019-01-01\\' AND MAX(s.sale_date) <= \\'2019-03-31\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2596861,
                "title": "any-idea-why-this-answer-is-not-correct",
                "content": "SELECT p.product_id, p.product_name\\nFROM Product P\\nJOIN Sales S \\n     ON P.product_id = S.product_id\\n  WHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n   AND P.product_id NOT IN (SELECT S.product_id FROM Sales WHERE sale_date NOT BETWEEN\\n                        \\'2019-01-01\\' AND \\'2019-03-31\\')",
                "solutionTags": [],
                "code": "SELECT p.product_id, p.product_name\\nFROM Product P\\nJOIN Sales S \\n     ON P.product_id = S.product_id\\n  WHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\n   AND P.product_id NOT IN (SELECT S.product_id FROM Sales WHERE sale_date NOT BETWEEN\\n                        \\'2019-01-01\\' AND \\'2019-03-31\\')",
                "codeTag": "Unknown"
            },
            {
                "id": 2583690,
                "title": "simplest-sql-solution",
                "content": "\\nselect p.product_id, p.product_name\\nfrom Product as p join Sales as s\\non p.product_id = s.product_id\\ngroup by p.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' AND max(s.sale_date) <= \\'2019-03-31\\'",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\nselect p.product_id, p.product_name\\nfrom Product as p join Sales as s\\non p.product_id = s.product_id\\ngroup by p.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' AND max(s.sale_date) <= \\'2019-03-31\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2550154,
                "title": "mysql-in-not-in-and-cte-clear-logic",
                "content": "```\\nwith \\ncte1 as (select product_id from Sales where sale_date between \"2019-01-01\" and \"2019-03-31\"), \\ncte2 as (select product_id from Sales where sale_date not between \"2019-01-01\" and \"2019-03-31\")\\n\\nselect product_id, product_name from Product \\nwhere product_id in (select product_id from cte1) and product_id not in (select product_id from cte2);\\n```",
                "solutionTags": [],
                "code": "```\\nwith \\ncte1 as (select product_id from Sales where sale_date between \"2019-01-01\" and \"2019-03-31\"), \\ncte2 as (select product_id from Sales where sale_date not between \"2019-01-01\" and \"2019-03-31\")\\n\\nselect product_id, product_name from Product \\nwhere product_id in (select product_id from cte1) and product_id not in (select product_id from cte2);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2538398,
                "title": "mysql-simple-and-clean-solution",
                "content": "**Please Upvote if it helped you !!!**\\n```\\nselect product.product_id ,product.product_name from product\\nwhere product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\' ) \\nand\\nproduct_id in (select product_id from sales where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\');\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect product.product_id ,product.product_name from product\\nwhere product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\' ) \\nand\\nproduct_id in (select product_id from sales where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2535087,
                "title": "mysql-join-not-in",
                "content": "```\\nSELECT P.product_id as product_id, P.product_name AS product_name\\nFROM Product as P\\nLEFT JOIN Sales as S\\nON P.product_id=S.product_id\\nWHERE P.product_id NOT IN (\\n    SELECT product_id as sold_product\\n    From Sales\\n    WHERE sale_date <\\'2019-01-01\\' OR sale_date >\\'2019-03-31\\'\\n    )\\nAND S.product_id IS NOT NULL\\nGROUP by P.product_id,P.product_name;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT P.product_id as product_id, P.product_name AS product_name\\nFROM Product as P\\nLEFT JOIN Sales as S\\nON P.product_id=S.product_id\\nWHERE P.product_id NOT IN (\\n    SELECT product_id as sold_product\\n    From Sales\\n    WHERE sale_date <\\'2019-01-01\\' OR sale_date >\\'2019-03-31\\'\\n    )\\nAND S.product_id IS NOT NULL\\nGROUP by P.product_id,P.product_name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2517742,
                "title": "mysql-simple-solution",
                "content": "```\\nselect product_id, product_name from product\\nwhere product_id not in (\\n    select product_id from sales\\n    where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\'\\n) and product_id in (select product_id from sales)\\n```",
                "solutionTags": [],
                "code": "```\\nselect product_id, product_name from product\\nwhere product_id not in (\\n    select product_id from sales\\n    where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\'\\n) and product_id in (select product_id from sales)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2500255,
                "title": "very-simple-solution",
                "content": "```\\nwith bounds as (select S.product_id, max(S.sale_date) as upper, min(S.sale_date) as lower from Sales S group by S.product_id)\\n\\nselect \\n  P.product_id, \\n  P.product_name \\nfrom bounds inner join Product p on bounds.product_id = P.product_id \\nwhere upper <= \"2019-03-31\" and lower >= \"2019-01-01\"\\n```",
                "solutionTags": [],
                "code": "```\\nwith bounds as (select S.product_id, max(S.sale_date) as upper, min(S.sale_date) as lower from Sales S group by S.product_id)\\n\\nselect \\n  P.product_id, \\n  P.product_name \\nfrom bounds inner join Product p on bounds.product_id = P.product_id \\nwhere upper <= \"2019-03-31\" and lower >= \"2019-01-01\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2495182,
                "title": "easiest-subquery-solution-without-having-clause",
                "content": "```\\nselect product_id, product_name from product where product_id not in (select product_id from sales s where s.sale_date > \\'2019-03-31\\' or s.sale_date < \\'2019-01-01\\') and product_id in (select product_id from sales s);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect product_id, product_name from product where product_id not in (select product_id from sales s where s.sale_date > \\'2019-03-31\\' or s.sale_date < \\'2019-01-01\\') and product_id in (select product_id from sales s);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2492699,
                "title": "solution-easy-to-understand-98-73-fast",
                "content": "**This is most  EASIEST solution you will get**\\n```\\nSELECT a.product_id,a.product_name FROM Product a JOIN Sales b\\nON a.product_id=b.product_id\\nGROUP BY b.product_id\\nHAVING MIN(b.sale_date)>=\"2019-01-01\" AND MAX(b.sale_date)<=\"2019-03-31\" ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT a.product_id,a.product_name FROM Product a JOIN Sales b\\nON a.product_id=b.product_id\\nGROUP BY b.product_id\\nHAVING MIN(b.sale_date)>=\"2019-01-01\" AND MAX(b.sale_date)<=\"2019-03-31\" ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2453272,
                "title": "mysql-solution-using-group-by",
                "content": "```\\nselect p.product_id,product_name from product p\\ninner join sales s on p.product_id=s.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect p.product_id,product_name from product p\\ninner join sales s on p.product_id=s.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2442601,
                "title": "ms-sql-server-solution-using-except",
                "content": "```\\nselect product_id, product_name from product where\\nproduct_id in (\\nselect distinct product_id from sales where sale_date between\\'2019-01-01\\'\\nand \\'2019-03-31\\'\\n\\nexcept\\n\\nselect distinct product_id from sales where sale_date<\\'2019-01-01\\'\\nor sale_date>\\'2019-03-31\\')",
                "solutionTags": [],
                "code": "```\\nselect product_id, product_name from product where\\nproduct_id in (\\nselect distinct product_id from sales where sale_date between\\'2019-01-01\\'\\nand \\'2019-03-31\\'\\n\\nexcept\\n\\nselect distinct product_id from sales where sale_date<\\'2019-01-01\\'\\nor sale_date>\\'2019-03-31\\')",
                "codeTag": "Unknown"
            },
            {
                "id": 2433342,
                "title": "can-someone-explain-why-this-code-doesn-t-work",
                "content": "\"\"\"\\nSELECT DISTINCT(PRODUCT_ID),PRODUCT_NAME FROM PRODUCT \\nWHERE PRODUCT_ID  NOT IN\\n(SELECT DISTINCT(PRODUCT_ID) FROM SALES \\nWHERE SALE_DATE BETWEEN \"2019-03-31\" AND \"2019-12-31\");\\n\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\nSELECT DISTINCT(PRODUCT_ID),PRODUCT_NAME FROM PRODUCT \\nWHERE PRODUCT_ID  NOT IN\\n(SELECT DISTINCT(PRODUCT_ID) FROM SALES \\nWHERE SALE_DATE BETWEEN \"2019-03-31\" AND \"2019-12-31\");\\n\"\"\"",
                "codeTag": "Unknown"
            },
            {
                "id": 2432520,
                "title": "mysql-simple-solution",
                "content": "select distinct product.product_id, product.product_name\\nfrom product inner join sales on product.product_id = sales.product_id\\nwhere product.product_id not in (select sales.product_id\\n                                from sales\\n                                where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\');",
                "solutionTags": [],
                "code": "select distinct product.product_id, product.product_name\\nfrom product inner join sales on product.product_id = sales.product_id\\nwhere product.product_id not in (select sales.product_id\\n                                from sales\\n                                where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\');",
                "codeTag": "Unknown"
            },
            {
                "id": 2403818,
                "title": "mysql-solution-using-min-and-max",
                "content": "select product_id , product_name\\nfrom product \\nwhere product_id in \\n(select product_id\\nfrom sales\\ngroup by product_id\\nhaving min(sale_date) between \\'2019-01-01\\' and \\'2019-03-31\\' and max(sale_date) between \\'2019-01-01\\' and \\'2019-03-31\\')",
                "solutionTags": [],
                "code": "select product_id , product_name\\nfrom product \\nwhere product_id in \\n(select product_id\\nfrom sales\\ngroup by product_id\\nhaving min(sale_date) between \\'2019-01-01\\' and \\'2019-03-31\\' and max(sale_date) between \\'2019-01-01\\' and \\'2019-03-31\\')",
                "codeTag": "Unknown"
            },
            {
                "id": 2359055,
                "title": "simple-mysql-solution-with-left-join-group-by-having",
                "content": "```\\nSELECT p.product_id, p.product_name\\nFROM Sales s\\nLEFT JOIN Product p\\nON s.product_id = p.product_id\\nGROUP BY s.product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND MAX(sale_date) <= \\'2019-03-31\\';\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT p.product_id, p.product_name\\nFROM Sales s\\nLEFT JOIN Product p\\nON s.product_id = p.product_id\\nGROUP BY s.product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND MAX(sale_date) <= \\'2019-03-31\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2302837,
                "title": "simple-sql-query",
                "content": "```\\nwith temp as (select seller_id,product_id,buyer_id,max(sale_date) as mx,min(sale_date) as mn\\n              from sales\\n              group by product_id)\\n              \\nselect a.product_id,a.product_name\\nfrom product a\\ninner join temp b\\non a.product_id=b.product_id\\nwhere b.mn>=\\'2019-01-01\\' and b.mx<=\\'2019-03-31\\';\\n```",
                "solutionTags": [],
                "code": "```\\nwith temp as (select seller_id,product_id,buyer_id,max(sale_date) as mx,min(sale_date) as mn\\n              from sales\\n              group by product_id)\\n              \\nselect a.product_id,a.product_name\\nfrom product a\\ninner join temp b\\non a.product_id=b.product_id\\nwhere b.mn>=\\'2019-01-01\\' and b.mx<=\\'2019-03-31\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298919,
                "title": "mysql-simple-solution-using-group-by-and-having",
                "content": "Runtime: 1002 ms, faster than 86.86% of MySQL online submissions for Sales Analysis III.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Sales Analysis III.\\n```\\nSELECT product_id, product_name\\nFROM Sales \\nJOIN Product \\nUsing(product_id)\\nGROUP BY product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND MAX(sale_date) <= \\'2019-03-31\\'",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "Runtime: 1002 ms, faster than 86.86% of MySQL online submissions for Sales Analysis III.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Sales Analysis III.\\n```\\nSELECT product_id, product_name\\nFROM Sales \\nJOIN Product \\nUsing(product_id)\\nGROUP BY product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND MAX(sale_date) <= \\'2019-03-31\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2297203,
                "title": "use-in-and-not-in-easy-solution",
                "content": "select  product_id ,   product_name\\nfrom Product\\nwhere product_id in  \\n    (select  product_id from Sales\\n    where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' )\\nand product_id not in \\n    (select  product_id from Sales\\n    where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\' )",
                "solutionTags": [],
                "code": "select  product_id ,   product_name\\nfrom Product\\nwhere product_id in  \\n    (select  product_id from Sales\\n    where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' )\\nand product_id not in \\n    (select  product_id from Sales\\n    where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\' )",
                "codeTag": "Unknown"
            },
            {
                "id": 2277345,
                "title": "without-joins-without-having-only-not-in-in-between-clause",
                "content": "```\\n# Write your MySQL query statement below\\nselect product_id, product_name from Product where product_id not in (select distinct product_id from Sales where DATE(sale_date) not between \\'2019-01-01\\' and \\'2019-03-31\\') and product_id in (select distinct product_id from Sales);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect product_id, product_name from Product where product_id not in (select distinct product_id from Sales where DATE(sale_date) not between \\'2019-01-01\\' and \\'2019-03-31\\') and product_id in (select distinct product_id from Sales);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2270013,
                "title": "mysql",
                "content": "select distinct(s.product_id), p.product_name\\nfrom product p, sales s\\nwhere p.product_id=s.product_id \\nand s.sale_date>=\"2019-01-01\" and s.sale_date<=\"2019-03-31\" and s.product_id not in \\n(select product_id from sales where sale_date>\"2019-03-31\" or sale_date<\"2019-01-01\" )",
                "solutionTags": [],
                "code": "select distinct(s.product_id), p.product_name\\nfrom product p, sales s\\nwhere p.product_id=s.product_id \\nand s.sale_date>=\"2019-01-01\" and s.sale_date<=\"2019-03-31\" and s.product_id not in \\n(select product_id from sales where sale_date>\"2019-03-31\" or sale_date<\"2019-01-01\" )",
                "codeTag": "Unknown"
            },
            {
                "id": 2265610,
                "title": "fresher-s-solution",
                "content": "```\\nselect p.product_id, p.product_name\\nfrom product p left join sales s\\nusing(product_id)\\ngroup by p.product_id\\nHAVING MIN(s.sale_date) >= \\'2019-01-01\\' AND\\n       MAX(s.sale_date) <= \\'2019-03-31\\'\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect p.product_id, p.product_name\\nfrom product p left join sales s\\nusing(product_id)\\ngroup by p.product_id\\nHAVING MIN(s.sale_date) >= \\'2019-01-01\\' AND\\n       MAX(s.sale_date) <= \\'2019-03-31\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261027,
                "title": "short-and-beat-98-queries",
                "content": "```\\nSELECT product_id, product_name FROM Product\\nWHERE product_id IN\\n(SELECT product_id\\nFROM Sales\\nGROUP BY 1\\nHAVING SUM(IF(sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\',0 ,1 ))=0)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT product_id, product_name FROM Product\\nWHERE product_id IN\\n(SELECT product_id\\nFROM Sales\\nGROUP BY 1\\nHAVING SUM(IF(sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\',0 ,1 ))=0)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2245134,
                "title": "mysql-easy-solution-analytical-function",
                "content": "select prd.product_id,prd.product_name from product prd\\ninner join (select product_id from (select product_id,quarter(sale_date) as qrtr,row_number() over(partition by product_id order by quarter(sale_date) desc) rnk from sales) temp where rnk=1 and qrtr=1) sale \\non prd.product_id=sale.product_id",
                "solutionTags": [],
                "code": "select prd.product_id,prd.product_name from product prd\\ninner join (select product_id from (select product_id,quarter(sale_date) as qrtr,row_number() over(partition by product_id order by quarter(sale_date) desc) rnk from sales) temp where rnk=1 and qrtr=1) sale \\non prd.product_id=sale.product_id",
                "codeTag": "Unknown"
            },
            {
                "id": 2220387,
                "title": "mysql-84-faster-easy-solution-with-explanation",
                "content": "```\\n# Write your MySQL query statement below\\n#Selecting all product_ids that were sold out of the given interval.\\nwith sb as(\\n    select \\n    product_id\\n    from sales \\n    where date(sale_date) < \"2019-01-01\" or date(sale_date) > \"2019-03-31\"\\n)\\n\\n#selecting all products that were sold IN given interval and having ID not equal to ones being sold outside of the 1st quarter\\nselect \\ndistinct a.product_id,\\na.product_name\\n\\nfrom product a \\ninner join sales s on a.product_id = s.product_id\\n\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand a.product_id not in (select product_id from sb)\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n#Selecting all product_ids that were sold out of the given interval.\\nwith sb as(\\n    select \\n    product_id\\n    from sales \\n    where date(sale_date) < \"2019-01-01\" or date(sale_date) > \"2019-03-31\"\\n)\\n\\n#selecting all products that were sold IN given interval and having ID not equal to ones being sold outside of the 1st quarter\\nselect \\ndistinct a.product_id,\\na.product_name\\n\\nfrom product a \\ninner join sales s on a.product_id = s.product_id\\n\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand a.product_id not in (select product_id from sb)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2188092,
                "title": "mssql-solution",
                "content": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT S.product_id, P.product_name\\nFROM Sales AS S\\nJOIN Product AS P\\n    ON S.product_id = P.product_id\\nGROUP BY S.product_id, P.product_name\\nHAVING MIN(S.sale_date)>= \\'2019-01-01\\' \\n     AND MAX(S.sale_date) <= \\'2019-03-31\\'",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT S.product_id, P.product_name\\nFROM Sales AS S\\nJOIN Product AS P\\n    ON S.product_id = P.product_id\\nGROUP BY S.product_id, P.product_name\\nHAVING MIN(S.sale_date)>= \\'2019-01-01\\' \\n     AND MAX(S.sale_date) <= \\'2019-03-31\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2178009,
                "title": "with-left-join-and-group-by-and-having",
                "content": "```\\nselect s.product_id,p.product_name from Product p left join Sales s on p.product_id=s.product_id group by s.product_id having min(s.sale_date)>=\\'2019-01-01\\' and max(s.sale_date) <=\\'2019-03-31\\';\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.product_id,p.product_name from Product p left join Sales s on p.product_id=s.product_id group by s.product_id having min(s.sale_date)>=\\'2019-01-01\\' and max(s.sale_date) <=\\'2019-03-31\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2169860,
                "title": "why-does-it-work-with-group-by-and-not-with-between-without-group-by",
                "content": "SELECT P.PRODUCT_ID,P.PRODUCT_NAME FROM PRODUCT P JOIN SALES S\\nON P.PRODUCT_ID=S.PRODUCT_ID  GROUP BY 1,2 HAVING MIN(SALE_DATE) >= \\'2019-01-01\\' AND\\nMAX(SALE_DATE)<=\\'2019-03-31\\'\\n\\n",
                "solutionTags": [],
                "code": "SELECT P.PRODUCT_ID,P.PRODUCT_NAME FROM PRODUCT P JOIN SALES S\\nON P.PRODUCT_ID=S.PRODUCT_ID  GROUP BY 1,2 HAVING MIN(SALE_DATE) >= \\'2019-01-01\\' AND\\nMAX(SALE_DATE)<=\\'2019-03-31\\'\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2161395,
                "title": "ms-sql-solution-solved-the-time-limit-issue",
                "content": "```\\n/* Write your T-SQL query statement below */\\n\\n\\n;with tmp as \\n(\\n    select product_id\\n    from Sales \\n    group by product_id\\n    having min(sale_date)>=\\'2019-01-01\\' and max(sale_date)<=\\'2019-03-31\\'\\n)\\n\\nselect a.product_id, a.product_name\\nfrom Product a\\njoin tmp b on a.product_id=b.product_id\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\n\\n;with tmp as \\n(\\n    select product_id\\n    from Sales \\n    group by product_id\\n    having min(sale_date)>=\\'2019-01-01\\' and max(sale_date)<=\\'2019-03-31\\'\\n)\\n\\nselect a.product_id, a.product_name\\nfrom Product a\\njoin tmp b on a.product_id=b.product_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141982,
                "title": "mysql-solution-easy-approach",
                "content": "**Approach:**\\n```\\nSELECT product_id_table.product_id, Product.product_name\\nFROM\\n(SELECT DISTINCT(product_id) AS product_id FROM Sales\\nWHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND product_id NOT IN\\n(SELECT product_id FROM Sales\\nWHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'))\\nAS product_id_table\\nLEFT JOIN Product ON product_id_table.product_id = Product.product_id;\\n```\\n\\n**Approach:**\\n```\\nSELECT Sales.product_id, Product.product_name \\nFROM Sales LEFT JOIN Product\\nON Sales.product_id = Product.product_id\\nGROUP BY Sales.product_id\\nHAVING \\nmin(Sales.sale_date) >= \\'2019-01-01\\' AND\\nmax(Sales.sale_date) <= \\'2019-03-31\\';\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT product_id_table.product_id, Product.product_name\\nFROM\\n(SELECT DISTINCT(product_id) AS product_id FROM Sales\\nWHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND product_id NOT IN\\n(SELECT product_id FROM Sales\\nWHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'))\\nAS product_id_table\\nLEFT JOIN Product ON product_id_table.product_id = Product.product_id;\\n```\n```\\nSELECT Sales.product_id, Product.product_name \\nFROM Sales LEFT JOIN Product\\nON Sales.product_id = Product.product_id\\nGROUP BY Sales.product_id\\nHAVING \\nmin(Sales.sale_date) >= \\'2019-01-01\\' AND\\nmax(Sales.sale_date) <= \\'2019-03-31\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2105498,
                "title": "mysql-easiest-solution",
                "content": "**Pls Upvote if you like the Solution!**\\n```\\nSELECT product_id, product_name\\nFROM Sales \\nJOIN Product \\nUsing(product_id)\\nGROUP BY product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND MAX(sale_date) <= \\'2019-03-31\\'",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**Pls Upvote if you like the Solution!**\\n```\\nSELECT product_id, product_name\\nFROM Sales \\nJOIN Product \\nUsing(product_id)\\nGROUP BY product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND MAX(sale_date) <= \\'2019-03-31\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2087365,
                "title": "beats-90-precise-mysql",
                "content": "```sql\\nSELECT\\n\\ts.product_id,\\n\\tproduct_name\\nFROM\\n\\tsales s\\n\\tINNER JOIN product p ON p.product_id = s.product_id\\nGROUP BY\\n\\t1, 2\\nHAVING\\n\\tMIN(sale_date) >= \\'2019-01-01\\'\\n\\tAND MAX(sale_date) <= \\'2019-03-31\\'\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT\\n\\ts.product_id,\\n\\tproduct_name\\nFROM\\n\\tsales s\\n\\tINNER JOIN product p ON p.product_id = s.product_id\\nGROUP BY\\n\\t1, 2\\nHAVING\\n\\tMIN(sale_date) >= \\'2019-01-01\\'\\n\\tAND MAX(sale_date) <= \\'2019-03-31\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2057241,
                "title": "5-lines-of-code-in-mysql-very-easy-to-understand",
                "content": "**MySQL**\\n```\\nselect product_id, product_name\\nfrom product\\njoin sales using(product_id)\\ngroup by product_id\\nhaving max(quarter(sale_date)) = 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect product_id, product_name\\nfrom product\\njoin sales using(product_id)\\ngroup by product_id\\nhaving max(quarter(sale_date)) = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2034851,
                "title": "using-join-and-between",
                "content": "```\\nselect product_id,product_name\\nfrom Product where\\nproduct_id not in (\\n\\t\\t\\t\\tselect p.product_id from Product p \\n\\t\\t\\t\\t join Sales s on p.product_id = s.product_id\\n\\t\\t\\t\\t\\twhere sale_date \\n\\t\\t\\t\\t\\t\\t\\tnot between date(\\'2019-01-01\\') and date(\\'2019-03-31\\')\\n\\t\\t\\t\\t\\t)\\n```",
                "solutionTags": [],
                "code": "```\\nselect product_id,product_name\\nfrom Product where\\nproduct_id not in (\\n\\t\\t\\t\\tselect p.product_id from Product p \\n\\t\\t\\t\\t join Sales s on p.product_id = s.product_id\\n\\t\\t\\t\\t\\twhere sale_date \\n\\t\\t\\t\\t\\t\\t\\tnot between date(\\'2019-01-01\\') and date(\\'2019-03-31\\')\\n\\t\\t\\t\\t\\t)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2033916,
                "title": "simple-mysql-solution",
                "content": "```\\n SELECT product_id, product_name \\n FROM Product NATURAL JOIN Sales \\n GROUP BY product_id \\n HAVING MIN(sale_date) >= \\'2019-01-01\\' AND \\n MAX(sale_date) <= \\'2019-03-31\\'\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n SELECT product_id, product_name \\n FROM Product NATURAL JOIN Sales \\n GROUP BY product_id \\n HAVING MIN(sale_date) >= \\'2019-01-01\\' AND \\n MAX(sale_date) <= \\'2019-03-31\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030834,
                "title": "runtime-4036-ms-faster-than-97-40-of-ms-sql-server",
                "content": "```\\nWITH spring AS(\\nSELECT DISTINCT p.product_id, p.product_name\\nFROM Sales s\\nLEFT JOIN Product p\\nON p.product_id = s.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' )\\n\\nSELECT s.product_id,s.product_name\\nFROM spring s\\nLEFT JOIN (SELECT *\\n           FROM Sales\\n           WHERE  sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')a\\nON s.product_id = a.product_id\\nWHERE a.product_id IS NULL\\n```",
                "solutionTags": [],
                "code": "```\\nWITH spring AS(\\nSELECT DISTINCT p.product_id, p.product_name\\nFROM Sales s\\nLEFT JOIN Product p\\nON p.product_id = s.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' )\\n\\nSELECT s.product_id,s.product_name\\nFROM spring s\\nLEFT JOIN (SELECT *\\n           FROM Sales\\n           WHERE  sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')a\\nON s.product_id = a.product_id\\nWHERE a.product_id IS NULL\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019287,
                "title": "using-left-join-between-having-87-4",
                "content": "```\\nselect a.product_id,a.product_name from Product as a left join Sales as b on a.product_id = b.product_id group by b.product_id having min(b.sale_date) >=\\'2019-01-01\\' and max(b.sale_date) <=\\'2019-03-31\\'; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect a.product_id,a.product_name from Product as a left join Sales as b on a.product_id = b.product_id group by b.product_id having min(b.sale_date) >=\\'2019-01-01\\' and max(b.sale_date) <=\\'2019-03-31\\'; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1998970,
                "title": "please-someone-help-me-with-this",
                "content": "select product_id,product_name from\\n(select p.product_id,p.product_name,s.sale_date from Product p\\ninner join Sales s on s.product_id = p.product_id)\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'",
                "solutionTags": [],
                "code": "select product_id,product_name from\\n(select p.product_id,p.product_name,s.sale_date from Product p\\ninner join Sales s on s.product_id = p.product_id)\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1997350,
                "title": "using-case-and-left-join",
                "content": "```\\nSELECT product_id, product_name from (\\n   select p.product_id, p.product_name, SUM(\\n       CASE\\n            WHEN s.sale_date>=\\'2019-01-01\\' and s.sale_date<=\\'2019-03-31\\' THEN 1\\n            ELSE 0\\n       END\\n   ) as count1,\\n    SUM(\\n       CASE\\n            WHEN s.sale_date<\\'2019-01-01\\' or s.sale_date>\\'2019-03-31\\' THEN 1\\n            ELSE 0\\n        END\\n   ) as count2 from Product p LEFT JOIN Sales s on p.product_id=s.product_id group by p.product_id\\n)as temp WHERE count1>0 and count2=0;\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT product_id, product_name from (\\n   select p.product_id, p.product_name, SUM(\\n       CASE\\n            WHEN s.sale_date>=\\'2019-01-01\\' and s.sale_date<=\\'2019-03-31\\' THEN 1\\n            ELSE 0\\n       END\\n   ) as count1,\\n    SUM(\\n       CASE\\n            WHEN s.sale_date<\\'2019-01-01\\' or s.sale_date>\\'2019-03-31\\' THEN 1\\n            ELSE 0\\n        END\\n   ) as count2 from Product p LEFT JOIN Sales s on p.product_id=s.product_id group by p.product_id\\n)as temp WHERE count1>0 and count2=0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994995,
                "title": "using-except",
                "content": "select p.product_id, product_name\\nfrom product p inner join sales s\\non p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\n\\nexcept\\n\\nselect p.product_id, product_name\\nfrom product p inner join sales s\\non p.product_id = s.product_id\\nwhere sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\'",
                "solutionTags": [],
                "code": "select p.product_id, product_name\\nfrom product p inner join sales s\\non p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\n\\nexcept\\n\\nselect p.product_id, product_name\\nfrom product p inner join sales s\\non p.product_id = s.product_id\\nwhere sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\'",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1566151,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1717077,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576616,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570629,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570114,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1568561,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569778,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1699405,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573062,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1574954,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1566151,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1717077,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576616,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570629,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570114,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1568561,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569778,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1699405,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573062,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1574954,
                "content": [
                    {
                        "username": "AshleyMeow",
                        "content": "Product 2, G4 is also between 2019-1-1 to 2019-3-31, why in the correct answer it is not supposed to be included? Or am I understanding the problem wrong? Thank yo uso much !"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "[@Preksha_Sharma](/Preksha_Sharma) Nice catch!"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "You are probably looking at the seller_id instead of the product_id in sales table."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "In my opinion, it is necessary to take into account the date of the LAST SALE. Take another look at the explanation:\\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\\n"
                    },
                    {
                        "username": "Preksha_Sharma",
                        "content": "I think it is because we are asked the product which are ONLY in the first three quarter....Focus on that ONLY part\\n"
                    },
                    {
                        "username": "aakriti16",
                        "content": "because G4 also sold on 2019-06-02 which is not first quarter "
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select p.product_id, p.product_name\\nfrom Product p join Sales s\\non p.product_id = s.product_id\\ngroup by s.product_id\\nhaving min(s.sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'"
                    },
                    {
                        "username": "Dushyantsinh",
                        "content": "[@weebhav](/weebhav) Here the problem statement states that report the products that were only sold in the first quarter of 2019. But the product_id 2 was also sold in other quarter so we aren\\'t supposed to include that in our result. That\\'s why we are grouping them by product_id.\\n\\nIf you had grouped them by sale_date then it would have included product_id 2 also which we don\\'t want hence we have to group them by product_id."
                    },
                    {
                        "username": "weebhav",
                        "content": "Hey can you explain the impact group by has in the product_id 2 in the sample example given in the problem? or how does group by work generally in such scenario\\'s.\\nAny reply would be highly appreciated!!"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "like the idea "
                    },
                    {
                        "username": "Chloe4max",
                        "content": "Many people might think my solution is redundant while they only need 1 condition \\'\\'where sale_date < \\'2019-01-01\\' or sale_date > \\'2019-03-31\\'\\' and pass all the test cases. However I think my solution also covers the case when the products have never been sold.\\n\\nselect distinct\\np.product_id,\\np.product_name\\nfrom Product p\\nleft join Sales s on p.product_id = s.product_id\\nwhere sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (select distinct product_id from Sales where sale_date > \\'2019-03-31\\' or  sale_date < \\'2019-01-01\\')\\n\\n\\n"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I have a similar query, but it is failing.\\n\\n```sql\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nINNER JOIN Sales s ON s.product_id = p.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\nAND p.product_id NOT IN (\\n  SELECT product_id FROM Sales WHERE sale_date < \\'2019-01-01\\' OR sale_date > \\'2019-03-31\\'\\n);\\n```"
                    },
                    {
                        "username": "nikitaTiwari08",
                        "content": "mine is exactly similar to this except I\\'ve used right join (with product being on right ) which shouldn\\'t matter , however it is giving me wrong answer.\\ni don\\'t understand what\\'s wrong with this:\\n\\nselect distinct p.product_id , p.product_name\\nfrom Sales s \\nright join Product p on (s.product_id = p.product_id)\\nwhere s.sale_date  between (\\'2019-01-01\\' AND \\'2019-03-31\\') AND p.product_id not in (select distinct product_id \\n                                                                                  from Sales\\n                                                                                  where sale_date > \\'2019-03-31\\'\\n                                                                                  OR sale_date < \\'2019-01-01\\' )"
                    },
                    {
                        "username": "ssuresh1999",
                        "content": "I think product1  and 2 where sold in spring between 2019-01-01 and 2019-03-31\\nproduct 1 on 1/21 and 2 on 2/17 so why is that only S8 is the correct answer"
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "product_ID 1:Its only sold in spring between 2019-01-01 and 2019-03-31\\nwhere as,\\nproduct_ID 2: Sold in Spring as well as after spring (i.e 2019-06-02) \\nBut in the Description it is mentioned we only need those product which are only sold in spring "
                    },
                    {
                        "username": "bondshinra",
                        "content": "Because we are looking for products ONLY sold in Q1, the G4 was sold in 06-02 as well"
                    },
                    {
                        "username": "Gensun",
                        "content": "# Write your MySQL query statement below\\nSELECT P1.product_id, P1.product_name\\nFROM Product AS P1\\nWHERE P1.product_id NOT IN\\n(SELECT S1.product_id\\nFROM Sales AS S1\\nWHERE S1.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\')"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "[@Gensun](/Gensun) It\\'s not passing all the tests..."
                    },
                    {
                        "username": "AmadeusSquared",
                        "content": "[@Haidram](/Haidram)  \\n\\n\\nSELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s ON p.product_id = s.product_id\\nWHERE s.product_id IS NOT NULL\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(CASE WHEN s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = COUNT(s.product_id) AND\\n       SUM(CASE WHEN s.sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' THEN 1 ELSE 0 END) = 0"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer bro......not passing the final test case"
                    },
                    {
                        "username": "Sachi12345",
                        "content": "# Write your MySQL query statement below\\n\\n\\nSELECT product_id,product_NAME FROM Product \\nWHERE product_id IN (\\nSELECT product_id FROM Sales GROUP BY 1 HAVING\\nMAX(sale_date) <= CAST(\\'2019-03-31\\' AS DATE)\\nAND MIN(sale_date) >= CAST(\\'2019-01-01\\' AS DATE))\\n"
                    },
                    {
                        "username": "ssiddhant462",
                        "content": "sale_date is already date type."
                    },
                    {
                        "username": "jyothidundi91",
                        "content": "Sorry for dumb question!\\n\\n seller_id | product_id | buyer_id | sale_date  | quantity | price |\\n+-----------+------------+----------+------------+----------+-------+\\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\\n\\nSpring time covers from Jan to Mar, in that case it should be twp records. Can any one help?"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "that is why there is \"ONLY\" mentioned in the question. So product should not be sold in any other quarter except Jan to mar. I believe it make sense"
                    },
                    {
                        "username": "nynptel",
                        "content": " `select s.product_id, product_name\\nfrom Sales s\\nleft join Product p on s.product_id = p.product_id\\ngroup by product_id\\nhaving min(sale_date) >= \\'2019-01-01\\' and max(sale_date) <= \\'2019-03-31\\'`"
                    },
                    {
                        "username": "vashdevl",
                        "content": "product Id 2 was sold in feb 17 2019 . why is this not valid row for the spring of 2019 ?\\n    | 2        | 2019-02-17 | 1        | 800"
                    },
                    {
                        "username": "weizhao5",
                        "content": "\\n\\'\\'\\'\\nselect distinct s.product_id,p.product_name \\nfrom sales s join product p on s.product_id = p.product_id\\nwhere s.product_id not in\\n(\\nselect product_id\\nfrom sales\\nwhere not (sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')); \\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576207,
                "content": [
                    {
                        "username": "bbwxnl",
                        "content": "WITH C AS (SELECT a.product_id,product_name,sale_date\\nfrom Product as a \\njoin Sales as b\\nusing(product_id))\\n\\nSELECT distinct product_id,product_name\\nfrom c\\nwhere sale_date between \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND product_id NOT IN \\n(SELECT product_id\\nFROM c\\nWHERE sale_date  not between \\'2019-01-01\\' AND \\'2019-03-31\\' )\\n"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "Not pasing the second test case. I am suffering the same with my almost correct solution!\\n\\n\"select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')\""
                    },
                    {
                        "username": "ketulshukla",
                        "content": "Not sure why the following query is incorrect? \\nselect distinct(s.product_id), p.product_name \\n\\nfrom Sales s \\n\\nleft join Product p\\n\\non s.product_id= p.product_id\\n\\nwhere s.sale_date>=\\'2019-01-01\\' and s.sale_date<=\\'2019-03-31\\'"
                    },
                    {
                        "username": "abhishek_nitk",
                        "content": "**\\nselect product_id,product_name\\nfrom Product\\nwhere product_id not in (select product_id from Sales where EXTRACT(MONTH FROM sale_date)>3)**"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer on last test case"
                    },
                    {
                        "username": "vizzy205",
                        "content": "can anyone tell why my code doesn\\'t work?\\n `result=product.merge(sales,how=\\'inner\\',on=\\'product_id\\') \\n    id=list(result[\\'product_id\\'].unique())\\n\\n    product_id=[]\\n    product_name=[]\\n\\n    for i in id:\\n        row=result[(result[\\'product_id\\']==i) & (\\'2019-01-01\\'<=result[\\'sale_date\\']) & (result[\\'sale_date\\']<=\\'2019-03-31\\')]\\n        original_row=result[result[\\'product_id\\']==i]\\n\\n        if len(row)==len(original_row):\\n            product_id.append(row[\\'product_id\\'])\\n            product_name.append(row[\\'product_name\\'])\\n\\n    return pd.DataFrame({\\'product_id\\':product_id,\\'product_name\\':product_name}).`"
                    },
                    {
                        "username": "manweiho2001",
                        "content": "Hi, can somebody tell me what is wrong with this solution: \\nSELECT Product.product_id, product_name FROM Product INNER JOIN Sales ON Product.product_id = Sales.product_id WHERE Sales.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' GROUP BY Sales.product_id;"
                    },
                    {
                        "username": "feelingfine",
                        "content": "Use except to filter out common values"
                    },
                    {
                        "username": "Hemanth43744",
                        "content": "select p.product_id,p.product_name from product p\njoin sales s on p.product_id = s.product_id \nwhere s.sale_date between '2019-01-01' and '2019-31' "
                    },
                    {
                        "username": "KAMISETTY_NAVITHASRI",
                        "content": "SELECT S.product_id,P.product_name\\nFROM Sales AS S\\njoin Product as P\\non P.product_id=S.product_id\\nGROUP BY S.product_id\\nHAVING MIN(S.sale_date) >= \\'2019-01-01\\' AND MAX(S.sale_date) <= \\'2019-03-31\\';\\n"
                    },
                    {
                        "username": "stellasuhy",
                        "content": "Why doesn\\'t this return any record?\\n\\nSELECT product_id, product_name FROM Product \\nWHERE product_id IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date BETWEEN 2019-01-01 AND 2019-03-31\\n)\\nAND product_id NOT IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date > 2019-03-31 OR sale_date < 2019-01-01\\n);"
                    },
                    {
                        "username": "srik_3",
                        "content": "can someone help identifying with whats wrong with this query -TIA\n\n\n\nwith cte as\n(select product_id ,sale_date  from Sales\nwhere product_id not in \n(select product_id from Sales where\nsale_date > '2019-03-31' or sale_date < '2019-01-01'))\n\n\nselect A.product_id , B.product_name from cte A join Product B\non A.product_id =B.product_id"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT\\nA.product_id,\\nB.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n\\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    }
                ]
            },
            {
                "id": 1574663,
                "content": [
                    {
                        "username": "bbwxnl",
                        "content": "WITH C AS (SELECT a.product_id,product_name,sale_date\\nfrom Product as a \\njoin Sales as b\\nusing(product_id))\\n\\nSELECT distinct product_id,product_name\\nfrom c\\nwhere sale_date between \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND product_id NOT IN \\n(SELECT product_id\\nFROM c\\nWHERE sale_date  not between \\'2019-01-01\\' AND \\'2019-03-31\\' )\\n"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "Not pasing the second test case. I am suffering the same with my almost correct solution!\\n\\n\"select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')\""
                    },
                    {
                        "username": "ketulshukla",
                        "content": "Not sure why the following query is incorrect? \\nselect distinct(s.product_id), p.product_name \\n\\nfrom Sales s \\n\\nleft join Product p\\n\\non s.product_id= p.product_id\\n\\nwhere s.sale_date>=\\'2019-01-01\\' and s.sale_date<=\\'2019-03-31\\'"
                    },
                    {
                        "username": "abhishek_nitk",
                        "content": "**\\nselect product_id,product_name\\nfrom Product\\nwhere product_id not in (select product_id from Sales where EXTRACT(MONTH FROM sale_date)>3)**"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer on last test case"
                    },
                    {
                        "username": "vizzy205",
                        "content": "can anyone tell why my code doesn\\'t work?\\n `result=product.merge(sales,how=\\'inner\\',on=\\'product_id\\') \\n    id=list(result[\\'product_id\\'].unique())\\n\\n    product_id=[]\\n    product_name=[]\\n\\n    for i in id:\\n        row=result[(result[\\'product_id\\']==i) & (\\'2019-01-01\\'<=result[\\'sale_date\\']) & (result[\\'sale_date\\']<=\\'2019-03-31\\')]\\n        original_row=result[result[\\'product_id\\']==i]\\n\\n        if len(row)==len(original_row):\\n            product_id.append(row[\\'product_id\\'])\\n            product_name.append(row[\\'product_name\\'])\\n\\n    return pd.DataFrame({\\'product_id\\':product_id,\\'product_name\\':product_name}).`"
                    },
                    {
                        "username": "manweiho2001",
                        "content": "Hi, can somebody tell me what is wrong with this solution: \\nSELECT Product.product_id, product_name FROM Product INNER JOIN Sales ON Product.product_id = Sales.product_id WHERE Sales.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' GROUP BY Sales.product_id;"
                    },
                    {
                        "username": "feelingfine",
                        "content": "Use except to filter out common values"
                    },
                    {
                        "username": "Hemanth43744",
                        "content": "select p.product_id,p.product_name from product p\njoin sales s on p.product_id = s.product_id \nwhere s.sale_date between '2019-01-01' and '2019-31' "
                    },
                    {
                        "username": "KAMISETTY_NAVITHASRI",
                        "content": "SELECT S.product_id,P.product_name\\nFROM Sales AS S\\njoin Product as P\\non P.product_id=S.product_id\\nGROUP BY S.product_id\\nHAVING MIN(S.sale_date) >= \\'2019-01-01\\' AND MAX(S.sale_date) <= \\'2019-03-31\\';\\n"
                    },
                    {
                        "username": "stellasuhy",
                        "content": "Why doesn\\'t this return any record?\\n\\nSELECT product_id, product_name FROM Product \\nWHERE product_id IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date BETWEEN 2019-01-01 AND 2019-03-31\\n)\\nAND product_id NOT IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date > 2019-03-31 OR sale_date < 2019-01-01\\n);"
                    },
                    {
                        "username": "srik_3",
                        "content": "can someone help identifying with whats wrong with this query -TIA\n\n\n\nwith cte as\n(select product_id ,sale_date  from Sales\nwhere product_id not in \n(select product_id from Sales where\nsale_date > '2019-03-31' or sale_date < '2019-01-01'))\n\n\nselect A.product_id , B.product_name from cte A join Product B\non A.product_id =B.product_id"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT\\nA.product_id,\\nB.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n\\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    }
                ]
            },
            {
                "id": 1576873,
                "content": [
                    {
                        "username": "bbwxnl",
                        "content": "WITH C AS (SELECT a.product_id,product_name,sale_date\\nfrom Product as a \\njoin Sales as b\\nusing(product_id))\\n\\nSELECT distinct product_id,product_name\\nfrom c\\nwhere sale_date between \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND product_id NOT IN \\n(SELECT product_id\\nFROM c\\nWHERE sale_date  not between \\'2019-01-01\\' AND \\'2019-03-31\\' )\\n"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "Not pasing the second test case. I am suffering the same with my almost correct solution!\\n\\n\"select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')\""
                    },
                    {
                        "username": "ketulshukla",
                        "content": "Not sure why the following query is incorrect? \\nselect distinct(s.product_id), p.product_name \\n\\nfrom Sales s \\n\\nleft join Product p\\n\\non s.product_id= p.product_id\\n\\nwhere s.sale_date>=\\'2019-01-01\\' and s.sale_date<=\\'2019-03-31\\'"
                    },
                    {
                        "username": "abhishek_nitk",
                        "content": "**\\nselect product_id,product_name\\nfrom Product\\nwhere product_id not in (select product_id from Sales where EXTRACT(MONTH FROM sale_date)>3)**"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer on last test case"
                    },
                    {
                        "username": "vizzy205",
                        "content": "can anyone tell why my code doesn\\'t work?\\n `result=product.merge(sales,how=\\'inner\\',on=\\'product_id\\') \\n    id=list(result[\\'product_id\\'].unique())\\n\\n    product_id=[]\\n    product_name=[]\\n\\n    for i in id:\\n        row=result[(result[\\'product_id\\']==i) & (\\'2019-01-01\\'<=result[\\'sale_date\\']) & (result[\\'sale_date\\']<=\\'2019-03-31\\')]\\n        original_row=result[result[\\'product_id\\']==i]\\n\\n        if len(row)==len(original_row):\\n            product_id.append(row[\\'product_id\\'])\\n            product_name.append(row[\\'product_name\\'])\\n\\n    return pd.DataFrame({\\'product_id\\':product_id,\\'product_name\\':product_name}).`"
                    },
                    {
                        "username": "manweiho2001",
                        "content": "Hi, can somebody tell me what is wrong with this solution: \\nSELECT Product.product_id, product_name FROM Product INNER JOIN Sales ON Product.product_id = Sales.product_id WHERE Sales.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' GROUP BY Sales.product_id;"
                    },
                    {
                        "username": "feelingfine",
                        "content": "Use except to filter out common values"
                    },
                    {
                        "username": "Hemanth43744",
                        "content": "select p.product_id,p.product_name from product p\njoin sales s on p.product_id = s.product_id \nwhere s.sale_date between '2019-01-01' and '2019-31' "
                    },
                    {
                        "username": "KAMISETTY_NAVITHASRI",
                        "content": "SELECT S.product_id,P.product_name\\nFROM Sales AS S\\njoin Product as P\\non P.product_id=S.product_id\\nGROUP BY S.product_id\\nHAVING MIN(S.sale_date) >= \\'2019-01-01\\' AND MAX(S.sale_date) <= \\'2019-03-31\\';\\n"
                    },
                    {
                        "username": "stellasuhy",
                        "content": "Why doesn\\'t this return any record?\\n\\nSELECT product_id, product_name FROM Product \\nWHERE product_id IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date BETWEEN 2019-01-01 AND 2019-03-31\\n)\\nAND product_id NOT IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date > 2019-03-31 OR sale_date < 2019-01-01\\n);"
                    },
                    {
                        "username": "srik_3",
                        "content": "can someone help identifying with whats wrong with this query -TIA\n\n\n\nwith cte as\n(select product_id ,sale_date  from Sales\nwhere product_id not in \n(select product_id from Sales where\nsale_date > '2019-03-31' or sale_date < '2019-01-01'))\n\n\nselect A.product_id , B.product_name from cte A join Product B\non A.product_id =B.product_id"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT\\nA.product_id,\\nB.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n\\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    }
                ]
            },
            {
                "id": 2031696,
                "content": [
                    {
                        "username": "bbwxnl",
                        "content": "WITH C AS (SELECT a.product_id,product_name,sale_date\\nfrom Product as a \\njoin Sales as b\\nusing(product_id))\\n\\nSELECT distinct product_id,product_name\\nfrom c\\nwhere sale_date between \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND product_id NOT IN \\n(SELECT product_id\\nFROM c\\nWHERE sale_date  not between \\'2019-01-01\\' AND \\'2019-03-31\\' )\\n"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "Not pasing the second test case. I am suffering the same with my almost correct solution!\\n\\n\"select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')\""
                    },
                    {
                        "username": "ketulshukla",
                        "content": "Not sure why the following query is incorrect? \\nselect distinct(s.product_id), p.product_name \\n\\nfrom Sales s \\n\\nleft join Product p\\n\\non s.product_id= p.product_id\\n\\nwhere s.sale_date>=\\'2019-01-01\\' and s.sale_date<=\\'2019-03-31\\'"
                    },
                    {
                        "username": "abhishek_nitk",
                        "content": "**\\nselect product_id,product_name\\nfrom Product\\nwhere product_id not in (select product_id from Sales where EXTRACT(MONTH FROM sale_date)>3)**"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer on last test case"
                    },
                    {
                        "username": "vizzy205",
                        "content": "can anyone tell why my code doesn\\'t work?\\n `result=product.merge(sales,how=\\'inner\\',on=\\'product_id\\') \\n    id=list(result[\\'product_id\\'].unique())\\n\\n    product_id=[]\\n    product_name=[]\\n\\n    for i in id:\\n        row=result[(result[\\'product_id\\']==i) & (\\'2019-01-01\\'<=result[\\'sale_date\\']) & (result[\\'sale_date\\']<=\\'2019-03-31\\')]\\n        original_row=result[result[\\'product_id\\']==i]\\n\\n        if len(row)==len(original_row):\\n            product_id.append(row[\\'product_id\\'])\\n            product_name.append(row[\\'product_name\\'])\\n\\n    return pd.DataFrame({\\'product_id\\':product_id,\\'product_name\\':product_name}).`"
                    },
                    {
                        "username": "manweiho2001",
                        "content": "Hi, can somebody tell me what is wrong with this solution: \\nSELECT Product.product_id, product_name FROM Product INNER JOIN Sales ON Product.product_id = Sales.product_id WHERE Sales.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' GROUP BY Sales.product_id;"
                    },
                    {
                        "username": "feelingfine",
                        "content": "Use except to filter out common values"
                    },
                    {
                        "username": "Hemanth43744",
                        "content": "select p.product_id,p.product_name from product p\njoin sales s on p.product_id = s.product_id \nwhere s.sale_date between '2019-01-01' and '2019-31' "
                    },
                    {
                        "username": "KAMISETTY_NAVITHASRI",
                        "content": "SELECT S.product_id,P.product_name\\nFROM Sales AS S\\njoin Product as P\\non P.product_id=S.product_id\\nGROUP BY S.product_id\\nHAVING MIN(S.sale_date) >= \\'2019-01-01\\' AND MAX(S.sale_date) <= \\'2019-03-31\\';\\n"
                    },
                    {
                        "username": "stellasuhy",
                        "content": "Why doesn\\'t this return any record?\\n\\nSELECT product_id, product_name FROM Product \\nWHERE product_id IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date BETWEEN 2019-01-01 AND 2019-03-31\\n)\\nAND product_id NOT IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date > 2019-03-31 OR sale_date < 2019-01-01\\n);"
                    },
                    {
                        "username": "srik_3",
                        "content": "can someone help identifying with whats wrong with this query -TIA\n\n\n\nwith cte as\n(select product_id ,sale_date  from Sales\nwhere product_id not in \n(select product_id from Sales where\nsale_date > '2019-03-31' or sale_date < '2019-01-01'))\n\n\nselect A.product_id , B.product_name from cte A join Product B\non A.product_id =B.product_id"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT\\nA.product_id,\\nB.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n\\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    }
                ]
            },
            {
                "id": 2000583,
                "content": [
                    {
                        "username": "bbwxnl",
                        "content": "WITH C AS (SELECT a.product_id,product_name,sale_date\\nfrom Product as a \\njoin Sales as b\\nusing(product_id))\\n\\nSELECT distinct product_id,product_name\\nfrom c\\nwhere sale_date between \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND product_id NOT IN \\n(SELECT product_id\\nFROM c\\nWHERE sale_date  not between \\'2019-01-01\\' AND \\'2019-03-31\\' )\\n"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "Not pasing the second test case. I am suffering the same with my almost correct solution!\\n\\n\"select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')\""
                    },
                    {
                        "username": "ketulshukla",
                        "content": "Not sure why the following query is incorrect? \\nselect distinct(s.product_id), p.product_name \\n\\nfrom Sales s \\n\\nleft join Product p\\n\\non s.product_id= p.product_id\\n\\nwhere s.sale_date>=\\'2019-01-01\\' and s.sale_date<=\\'2019-03-31\\'"
                    },
                    {
                        "username": "abhishek_nitk",
                        "content": "**\\nselect product_id,product_name\\nfrom Product\\nwhere product_id not in (select product_id from Sales where EXTRACT(MONTH FROM sale_date)>3)**"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer on last test case"
                    },
                    {
                        "username": "vizzy205",
                        "content": "can anyone tell why my code doesn\\'t work?\\n `result=product.merge(sales,how=\\'inner\\',on=\\'product_id\\') \\n    id=list(result[\\'product_id\\'].unique())\\n\\n    product_id=[]\\n    product_name=[]\\n\\n    for i in id:\\n        row=result[(result[\\'product_id\\']==i) & (\\'2019-01-01\\'<=result[\\'sale_date\\']) & (result[\\'sale_date\\']<=\\'2019-03-31\\')]\\n        original_row=result[result[\\'product_id\\']==i]\\n\\n        if len(row)==len(original_row):\\n            product_id.append(row[\\'product_id\\'])\\n            product_name.append(row[\\'product_name\\'])\\n\\n    return pd.DataFrame({\\'product_id\\':product_id,\\'product_name\\':product_name}).`"
                    },
                    {
                        "username": "manweiho2001",
                        "content": "Hi, can somebody tell me what is wrong with this solution: \\nSELECT Product.product_id, product_name FROM Product INNER JOIN Sales ON Product.product_id = Sales.product_id WHERE Sales.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' GROUP BY Sales.product_id;"
                    },
                    {
                        "username": "feelingfine",
                        "content": "Use except to filter out common values"
                    },
                    {
                        "username": "Hemanth43744",
                        "content": "select p.product_id,p.product_name from product p\njoin sales s on p.product_id = s.product_id \nwhere s.sale_date between '2019-01-01' and '2019-31' "
                    },
                    {
                        "username": "KAMISETTY_NAVITHASRI",
                        "content": "SELECT S.product_id,P.product_name\\nFROM Sales AS S\\njoin Product as P\\non P.product_id=S.product_id\\nGROUP BY S.product_id\\nHAVING MIN(S.sale_date) >= \\'2019-01-01\\' AND MAX(S.sale_date) <= \\'2019-03-31\\';\\n"
                    },
                    {
                        "username": "stellasuhy",
                        "content": "Why doesn\\'t this return any record?\\n\\nSELECT product_id, product_name FROM Product \\nWHERE product_id IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date BETWEEN 2019-01-01 AND 2019-03-31\\n)\\nAND product_id NOT IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date > 2019-03-31 OR sale_date < 2019-01-01\\n);"
                    },
                    {
                        "username": "srik_3",
                        "content": "can someone help identifying with whats wrong with this query -TIA\n\n\n\nwith cte as\n(select product_id ,sale_date  from Sales\nwhere product_id not in \n(select product_id from Sales where\nsale_date > '2019-03-31' or sale_date < '2019-01-01'))\n\n\nselect A.product_id , B.product_name from cte A join Product B\non A.product_id =B.product_id"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT\\nA.product_id,\\nB.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n\\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    }
                ]
            },
            {
                "id": 1979551,
                "content": [
                    {
                        "username": "bbwxnl",
                        "content": "WITH C AS (SELECT a.product_id,product_name,sale_date\\nfrom Product as a \\njoin Sales as b\\nusing(product_id))\\n\\nSELECT distinct product_id,product_name\\nfrom c\\nwhere sale_date between \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND product_id NOT IN \\n(SELECT product_id\\nFROM c\\nWHERE sale_date  not between \\'2019-01-01\\' AND \\'2019-03-31\\' )\\n"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "Not pasing the second test case. I am suffering the same with my almost correct solution!\\n\\n\"select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')\""
                    },
                    {
                        "username": "ketulshukla",
                        "content": "Not sure why the following query is incorrect? \\nselect distinct(s.product_id), p.product_name \\n\\nfrom Sales s \\n\\nleft join Product p\\n\\non s.product_id= p.product_id\\n\\nwhere s.sale_date>=\\'2019-01-01\\' and s.sale_date<=\\'2019-03-31\\'"
                    },
                    {
                        "username": "abhishek_nitk",
                        "content": "**\\nselect product_id,product_name\\nfrom Product\\nwhere product_id not in (select product_id from Sales where EXTRACT(MONTH FROM sale_date)>3)**"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer on last test case"
                    },
                    {
                        "username": "vizzy205",
                        "content": "can anyone tell why my code doesn\\'t work?\\n `result=product.merge(sales,how=\\'inner\\',on=\\'product_id\\') \\n    id=list(result[\\'product_id\\'].unique())\\n\\n    product_id=[]\\n    product_name=[]\\n\\n    for i in id:\\n        row=result[(result[\\'product_id\\']==i) & (\\'2019-01-01\\'<=result[\\'sale_date\\']) & (result[\\'sale_date\\']<=\\'2019-03-31\\')]\\n        original_row=result[result[\\'product_id\\']==i]\\n\\n        if len(row)==len(original_row):\\n            product_id.append(row[\\'product_id\\'])\\n            product_name.append(row[\\'product_name\\'])\\n\\n    return pd.DataFrame({\\'product_id\\':product_id,\\'product_name\\':product_name}).`"
                    },
                    {
                        "username": "manweiho2001",
                        "content": "Hi, can somebody tell me what is wrong with this solution: \\nSELECT Product.product_id, product_name FROM Product INNER JOIN Sales ON Product.product_id = Sales.product_id WHERE Sales.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' GROUP BY Sales.product_id;"
                    },
                    {
                        "username": "feelingfine",
                        "content": "Use except to filter out common values"
                    },
                    {
                        "username": "Hemanth43744",
                        "content": "select p.product_id,p.product_name from product p\njoin sales s on p.product_id = s.product_id \nwhere s.sale_date between '2019-01-01' and '2019-31' "
                    },
                    {
                        "username": "KAMISETTY_NAVITHASRI",
                        "content": "SELECT S.product_id,P.product_name\\nFROM Sales AS S\\njoin Product as P\\non P.product_id=S.product_id\\nGROUP BY S.product_id\\nHAVING MIN(S.sale_date) >= \\'2019-01-01\\' AND MAX(S.sale_date) <= \\'2019-03-31\\';\\n"
                    },
                    {
                        "username": "stellasuhy",
                        "content": "Why doesn\\'t this return any record?\\n\\nSELECT product_id, product_name FROM Product \\nWHERE product_id IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date BETWEEN 2019-01-01 AND 2019-03-31\\n)\\nAND product_id NOT IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date > 2019-03-31 OR sale_date < 2019-01-01\\n);"
                    },
                    {
                        "username": "srik_3",
                        "content": "can someone help identifying with whats wrong with this query -TIA\n\n\n\nwith cte as\n(select product_id ,sale_date  from Sales\nwhere product_id not in \n(select product_id from Sales where\nsale_date > '2019-03-31' or sale_date < '2019-01-01'))\n\n\nselect A.product_id , B.product_name from cte A join Product B\non A.product_id =B.product_id"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT\\nA.product_id,\\nB.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n\\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    }
                ]
            },
            {
                "id": 1966645,
                "content": [
                    {
                        "username": "bbwxnl",
                        "content": "WITH C AS (SELECT a.product_id,product_name,sale_date\\nfrom Product as a \\njoin Sales as b\\nusing(product_id))\\n\\nSELECT distinct product_id,product_name\\nfrom c\\nwhere sale_date between \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND product_id NOT IN \\n(SELECT product_id\\nFROM c\\nWHERE sale_date  not between \\'2019-01-01\\' AND \\'2019-03-31\\' )\\n"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "Not pasing the second test case. I am suffering the same with my almost correct solution!\\n\\n\"select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')\""
                    },
                    {
                        "username": "ketulshukla",
                        "content": "Not sure why the following query is incorrect? \\nselect distinct(s.product_id), p.product_name \\n\\nfrom Sales s \\n\\nleft join Product p\\n\\non s.product_id= p.product_id\\n\\nwhere s.sale_date>=\\'2019-01-01\\' and s.sale_date<=\\'2019-03-31\\'"
                    },
                    {
                        "username": "abhishek_nitk",
                        "content": "**\\nselect product_id,product_name\\nfrom Product\\nwhere product_id not in (select product_id from Sales where EXTRACT(MONTH FROM sale_date)>3)**"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer on last test case"
                    },
                    {
                        "username": "vizzy205",
                        "content": "can anyone tell why my code doesn\\'t work?\\n `result=product.merge(sales,how=\\'inner\\',on=\\'product_id\\') \\n    id=list(result[\\'product_id\\'].unique())\\n\\n    product_id=[]\\n    product_name=[]\\n\\n    for i in id:\\n        row=result[(result[\\'product_id\\']==i) & (\\'2019-01-01\\'<=result[\\'sale_date\\']) & (result[\\'sale_date\\']<=\\'2019-03-31\\')]\\n        original_row=result[result[\\'product_id\\']==i]\\n\\n        if len(row)==len(original_row):\\n            product_id.append(row[\\'product_id\\'])\\n            product_name.append(row[\\'product_name\\'])\\n\\n    return pd.DataFrame({\\'product_id\\':product_id,\\'product_name\\':product_name}).`"
                    },
                    {
                        "username": "manweiho2001",
                        "content": "Hi, can somebody tell me what is wrong with this solution: \\nSELECT Product.product_id, product_name FROM Product INNER JOIN Sales ON Product.product_id = Sales.product_id WHERE Sales.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' GROUP BY Sales.product_id;"
                    },
                    {
                        "username": "feelingfine",
                        "content": "Use except to filter out common values"
                    },
                    {
                        "username": "Hemanth43744",
                        "content": "select p.product_id,p.product_name from product p\njoin sales s on p.product_id = s.product_id \nwhere s.sale_date between '2019-01-01' and '2019-31' "
                    },
                    {
                        "username": "KAMISETTY_NAVITHASRI",
                        "content": "SELECT S.product_id,P.product_name\\nFROM Sales AS S\\njoin Product as P\\non P.product_id=S.product_id\\nGROUP BY S.product_id\\nHAVING MIN(S.sale_date) >= \\'2019-01-01\\' AND MAX(S.sale_date) <= \\'2019-03-31\\';\\n"
                    },
                    {
                        "username": "stellasuhy",
                        "content": "Why doesn\\'t this return any record?\\n\\nSELECT product_id, product_name FROM Product \\nWHERE product_id IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date BETWEEN 2019-01-01 AND 2019-03-31\\n)\\nAND product_id NOT IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date > 2019-03-31 OR sale_date < 2019-01-01\\n);"
                    },
                    {
                        "username": "srik_3",
                        "content": "can someone help identifying with whats wrong with this query -TIA\n\n\n\nwith cte as\n(select product_id ,sale_date  from Sales\nwhere product_id not in \n(select product_id from Sales where\nsale_date > '2019-03-31' or sale_date < '2019-01-01'))\n\n\nselect A.product_id , B.product_name from cte A join Product B\non A.product_id =B.product_id"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT\\nA.product_id,\\nB.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n\\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    }
                ]
            },
            {
                "id": 1959660,
                "content": [
                    {
                        "username": "bbwxnl",
                        "content": "WITH C AS (SELECT a.product_id,product_name,sale_date\\nfrom Product as a \\njoin Sales as b\\nusing(product_id))\\n\\nSELECT distinct product_id,product_name\\nfrom c\\nwhere sale_date between \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND product_id NOT IN \\n(SELECT product_id\\nFROM c\\nWHERE sale_date  not between \\'2019-01-01\\' AND \\'2019-03-31\\' )\\n"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "Not pasing the second test case. I am suffering the same with my almost correct solution!\\n\\n\"select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')\""
                    },
                    {
                        "username": "ketulshukla",
                        "content": "Not sure why the following query is incorrect? \\nselect distinct(s.product_id), p.product_name \\n\\nfrom Sales s \\n\\nleft join Product p\\n\\non s.product_id= p.product_id\\n\\nwhere s.sale_date>=\\'2019-01-01\\' and s.sale_date<=\\'2019-03-31\\'"
                    },
                    {
                        "username": "abhishek_nitk",
                        "content": "**\\nselect product_id,product_name\\nfrom Product\\nwhere product_id not in (select product_id from Sales where EXTRACT(MONTH FROM sale_date)>3)**"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer on last test case"
                    },
                    {
                        "username": "vizzy205",
                        "content": "can anyone tell why my code doesn\\'t work?\\n `result=product.merge(sales,how=\\'inner\\',on=\\'product_id\\') \\n    id=list(result[\\'product_id\\'].unique())\\n\\n    product_id=[]\\n    product_name=[]\\n\\n    for i in id:\\n        row=result[(result[\\'product_id\\']==i) & (\\'2019-01-01\\'<=result[\\'sale_date\\']) & (result[\\'sale_date\\']<=\\'2019-03-31\\')]\\n        original_row=result[result[\\'product_id\\']==i]\\n\\n        if len(row)==len(original_row):\\n            product_id.append(row[\\'product_id\\'])\\n            product_name.append(row[\\'product_name\\'])\\n\\n    return pd.DataFrame({\\'product_id\\':product_id,\\'product_name\\':product_name}).`"
                    },
                    {
                        "username": "manweiho2001",
                        "content": "Hi, can somebody tell me what is wrong with this solution: \\nSELECT Product.product_id, product_name FROM Product INNER JOIN Sales ON Product.product_id = Sales.product_id WHERE Sales.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' GROUP BY Sales.product_id;"
                    },
                    {
                        "username": "feelingfine",
                        "content": "Use except to filter out common values"
                    },
                    {
                        "username": "Hemanth43744",
                        "content": "select p.product_id,p.product_name from product p\njoin sales s on p.product_id = s.product_id \nwhere s.sale_date between '2019-01-01' and '2019-31' "
                    },
                    {
                        "username": "KAMISETTY_NAVITHASRI",
                        "content": "SELECT S.product_id,P.product_name\\nFROM Sales AS S\\njoin Product as P\\non P.product_id=S.product_id\\nGROUP BY S.product_id\\nHAVING MIN(S.sale_date) >= \\'2019-01-01\\' AND MAX(S.sale_date) <= \\'2019-03-31\\';\\n"
                    },
                    {
                        "username": "stellasuhy",
                        "content": "Why doesn\\'t this return any record?\\n\\nSELECT product_id, product_name FROM Product \\nWHERE product_id IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date BETWEEN 2019-01-01 AND 2019-03-31\\n)\\nAND product_id NOT IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date > 2019-03-31 OR sale_date < 2019-01-01\\n);"
                    },
                    {
                        "username": "srik_3",
                        "content": "can someone help identifying with whats wrong with this query -TIA\n\n\n\nwith cte as\n(select product_id ,sale_date  from Sales\nwhere product_id not in \n(select product_id from Sales where\nsale_date > '2019-03-31' or sale_date < '2019-01-01'))\n\n\nselect A.product_id , B.product_name from cte A join Product B\non A.product_id =B.product_id"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT\\nA.product_id,\\nB.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n\\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    }
                ]
            },
            {
                "id": 1926100,
                "content": [
                    {
                        "username": "bbwxnl",
                        "content": "WITH C AS (SELECT a.product_id,product_name,sale_date\\nfrom Product as a \\njoin Sales as b\\nusing(product_id))\\n\\nSELECT distinct product_id,product_name\\nfrom c\\nwhere sale_date between \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND product_id NOT IN \\n(SELECT product_id\\nFROM c\\nWHERE sale_date  not between \\'2019-01-01\\' AND \\'2019-03-31\\' )\\n"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "Not pasing the second test case. I am suffering the same with my almost correct solution!\\n\\n\"select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')\""
                    },
                    {
                        "username": "ketulshukla",
                        "content": "Not sure why the following query is incorrect? \\nselect distinct(s.product_id), p.product_name \\n\\nfrom Sales s \\n\\nleft join Product p\\n\\non s.product_id= p.product_id\\n\\nwhere s.sale_date>=\\'2019-01-01\\' and s.sale_date<=\\'2019-03-31\\'"
                    },
                    {
                        "username": "abhishek_nitk",
                        "content": "**\\nselect product_id,product_name\\nfrom Product\\nwhere product_id not in (select product_id from Sales where EXTRACT(MONTH FROM sale_date)>3)**"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer on last test case"
                    },
                    {
                        "username": "vizzy205",
                        "content": "can anyone tell why my code doesn\\'t work?\\n `result=product.merge(sales,how=\\'inner\\',on=\\'product_id\\') \\n    id=list(result[\\'product_id\\'].unique())\\n\\n    product_id=[]\\n    product_name=[]\\n\\n    for i in id:\\n        row=result[(result[\\'product_id\\']==i) & (\\'2019-01-01\\'<=result[\\'sale_date\\']) & (result[\\'sale_date\\']<=\\'2019-03-31\\')]\\n        original_row=result[result[\\'product_id\\']==i]\\n\\n        if len(row)==len(original_row):\\n            product_id.append(row[\\'product_id\\'])\\n            product_name.append(row[\\'product_name\\'])\\n\\n    return pd.DataFrame({\\'product_id\\':product_id,\\'product_name\\':product_name}).`"
                    },
                    {
                        "username": "manweiho2001",
                        "content": "Hi, can somebody tell me what is wrong with this solution: \\nSELECT Product.product_id, product_name FROM Product INNER JOIN Sales ON Product.product_id = Sales.product_id WHERE Sales.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' GROUP BY Sales.product_id;"
                    },
                    {
                        "username": "feelingfine",
                        "content": "Use except to filter out common values"
                    },
                    {
                        "username": "Hemanth43744",
                        "content": "select p.product_id,p.product_name from product p\njoin sales s on p.product_id = s.product_id \nwhere s.sale_date between '2019-01-01' and '2019-31' "
                    },
                    {
                        "username": "KAMISETTY_NAVITHASRI",
                        "content": "SELECT S.product_id,P.product_name\\nFROM Sales AS S\\njoin Product as P\\non P.product_id=S.product_id\\nGROUP BY S.product_id\\nHAVING MIN(S.sale_date) >= \\'2019-01-01\\' AND MAX(S.sale_date) <= \\'2019-03-31\\';\\n"
                    },
                    {
                        "username": "stellasuhy",
                        "content": "Why doesn\\'t this return any record?\\n\\nSELECT product_id, product_name FROM Product \\nWHERE product_id IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date BETWEEN 2019-01-01 AND 2019-03-31\\n)\\nAND product_id NOT IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date > 2019-03-31 OR sale_date < 2019-01-01\\n);"
                    },
                    {
                        "username": "srik_3",
                        "content": "can someone help identifying with whats wrong with this query -TIA\n\n\n\nwith cte as\n(select product_id ,sale_date  from Sales\nwhere product_id not in \n(select product_id from Sales where\nsale_date > '2019-03-31' or sale_date < '2019-01-01'))\n\n\nselect A.product_id , B.product_name from cte A join Product B\non A.product_id =B.product_id"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT\\nA.product_id,\\nB.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n\\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    }
                ]
            },
            {
                "id": 1925806,
                "content": [
                    {
                        "username": "bbwxnl",
                        "content": "WITH C AS (SELECT a.product_id,product_name,sale_date\\nfrom Product as a \\njoin Sales as b\\nusing(product_id))\\n\\nSELECT distinct product_id,product_name\\nfrom c\\nwhere sale_date between \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND product_id NOT IN \\n(SELECT product_id\\nFROM c\\nWHERE sale_date  not between \\'2019-01-01\\' AND \\'2019-03-31\\' )\\n"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "Not pasing the second test case. I am suffering the same with my almost correct solution!\\n\\n\"select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')\""
                    },
                    {
                        "username": "ketulshukla",
                        "content": "Not sure why the following query is incorrect? \\nselect distinct(s.product_id), p.product_name \\n\\nfrom Sales s \\n\\nleft join Product p\\n\\non s.product_id= p.product_id\\n\\nwhere s.sale_date>=\\'2019-01-01\\' and s.sale_date<=\\'2019-03-31\\'"
                    },
                    {
                        "username": "abhishek_nitk",
                        "content": "**\\nselect product_id,product_name\\nfrom Product\\nwhere product_id not in (select product_id from Sales where EXTRACT(MONTH FROM sale_date)>3)**"
                    },
                    {
                        "username": "Haidram",
                        "content": "wrong answer on last test case"
                    },
                    {
                        "username": "vizzy205",
                        "content": "can anyone tell why my code doesn\\'t work?\\n `result=product.merge(sales,how=\\'inner\\',on=\\'product_id\\') \\n    id=list(result[\\'product_id\\'].unique())\\n\\n    product_id=[]\\n    product_name=[]\\n\\n    for i in id:\\n        row=result[(result[\\'product_id\\']==i) & (\\'2019-01-01\\'<=result[\\'sale_date\\']) & (result[\\'sale_date\\']<=\\'2019-03-31\\')]\\n        original_row=result[result[\\'product_id\\']==i]\\n\\n        if len(row)==len(original_row):\\n            product_id.append(row[\\'product_id\\'])\\n            product_name.append(row[\\'product_name\\'])\\n\\n    return pd.DataFrame({\\'product_id\\':product_id,\\'product_name\\':product_name}).`"
                    },
                    {
                        "username": "manweiho2001",
                        "content": "Hi, can somebody tell me what is wrong with this solution: \\nSELECT Product.product_id, product_name FROM Product INNER JOIN Sales ON Product.product_id = Sales.product_id WHERE Sales.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' GROUP BY Sales.product_id;"
                    },
                    {
                        "username": "feelingfine",
                        "content": "Use except to filter out common values"
                    },
                    {
                        "username": "Hemanth43744",
                        "content": "select p.product_id,p.product_name from product p\njoin sales s on p.product_id = s.product_id \nwhere s.sale_date between '2019-01-01' and '2019-31' "
                    },
                    {
                        "username": "KAMISETTY_NAVITHASRI",
                        "content": "SELECT S.product_id,P.product_name\\nFROM Sales AS S\\njoin Product as P\\non P.product_id=S.product_id\\nGROUP BY S.product_id\\nHAVING MIN(S.sale_date) >= \\'2019-01-01\\' AND MAX(S.sale_date) <= \\'2019-03-31\\';\\n"
                    },
                    {
                        "username": "stellasuhy",
                        "content": "Why doesn\\'t this return any record?\\n\\nSELECT product_id, product_name FROM Product \\nWHERE product_id IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date BETWEEN 2019-01-01 AND 2019-03-31\\n)\\nAND product_id NOT IN (\\n  SELECT product_id FROM Sales \\n  WHERE sale_date > 2019-03-31 OR sale_date < 2019-01-01\\n);"
                    },
                    {
                        "username": "srik_3",
                        "content": "can someone help identifying with whats wrong with this query -TIA\n\n\n\nwith cte as\n(select product_id ,sale_date  from Sales\nwhere product_id not in \n(select product_id from Sales where\nsale_date > '2019-03-31' or sale_date < '2019-01-01'))\n\n\nselect A.product_id , B.product_name from cte A join Product B\non A.product_id =B.product_id"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT\\nA.product_id,\\nB.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n\\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    }
                ]
            },
            {
                "id": 1893883,
                "content": [
                    {
                        "username": "testpan0115",
                        "content": "Can someone pls explain why this is not work?\nps : in testacse 10/13 it didn't contain product_id= 34 product_name= v in my output\n\nselect p.product_id ,p.product_name\nfrom Product p\nleft join Sales s\non p.product_id = s.product_id\ngroup by p.product_name\nhaving count(s.product_id) = \n            count(if(s.sale_date >= '2019-01-01' and s.sale_date <='2019-03-31',s.sale_date, null))"
                    },
                    {
                        "username": "sidde_95",
                        "content": "Why is this query not supported because it only says to output product_id and product_name  between date range 2019-01-01 and 2019-03-31\\n\\nselect a.product_id, a.product_name\\nfrom product a \\njoin sales b\\n    on a.product_id = b.product_id \\nwhere b.sale_date >= \\'2019-01-01\\' and b.sale_date <=\\'2019-03-31\\';"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT \\n      A.product_id,\\n      B.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n \\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    },
                    {
                        "username": "Effy_Sama",
                        "content": "Why is this wrong :c \n\nselect product_id,\np.product_name\nfrom product p\nleft join sales s using(product_id)\nwhere product_id not in\n(select product_id\nfrom sales\nwhere month(sale_date) between 4 and 12)\nand month(s.sale_date) between 1 and 3"
                    },
                    {
                        "username": "lucasea777",
                        "content": "Instead of `<=`, you can use `MONTH(date) <= 3` \\uD83D\\uDE0E"
                    },
                    {
                        "username": "Z_N",
                        "content": "SELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nGROUP BY p.product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND\\nMAX(sale_date) <=  \\'2019-03-31\\' "
                    },
                    {
                        "username": "arthireddy",
                        "content": "why is the below code not working\\nSELECT P.product_id, P.product_name from Product P RIGHT OUTER JOIN Sales S on P.product_id=S.product_id WHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\' and (p.product_id <> (SELECT p.product_id WHERE sale_date BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\');"
                    },
                    {
                        "username": "markov_r",
                        "content": "The query below passes the initial test case, but fails on TC 4, which is unfortunately way too long.\\nI don\\'t see any reason for failing, it\\'s quite simple:\\n- remove the intersection of  first quarter and non-first quarter sales, so keeping only the \"clean\" first quarter sales.\\n\\n```\\nselect p.product_id, p.product_name\\nfrom Product p\\njoin Sales s\\non p.product_id = s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (\\n    select p2.product_id \\n    from Product p2\\n    join Sales s2\\n    on p2.product_id = s2.product_id\\n    where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "7 / 13 testcases passed \\nLeetCode are you serious?))"
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "select p.product_id,p.product_name from product p \\nleft join sales s \\non p.product_id=s.product_id where s.sale_date between 2019-01-01 and 2019-03-31\\n\\nWhat is wrong in my code"
                    },
                    {
                        "username": "vishweshhampali",
                        "content": "ONLY sold in 1st quarter .... this part you have missed"
                    },
                    {
                        "username": "yorkltesting",
                        "content": "Why my code is wrong? Can anyone help check for me?\\nSELECT DISTINCT p.product_id, p.product_name\\nFROM product p\\nLEFT JOIN Sales s1 ON p.product_id = s1.product_id AND s1.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nLEFT JOIN Sales s2 ON p.product_id = s2.product_id AND s2.sale_date > \\'2019-03-31\\'\\nWHERE s1.sale_date IS NOT NULL AND s2.sale_date IS NULL"
                    }
                ]
            },
            {
                "id": 1879590,
                "content": [
                    {
                        "username": "testpan0115",
                        "content": "Can someone pls explain why this is not work?\nps : in testacse 10/13 it didn't contain product_id= 34 product_name= v in my output\n\nselect p.product_id ,p.product_name\nfrom Product p\nleft join Sales s\non p.product_id = s.product_id\ngroup by p.product_name\nhaving count(s.product_id) = \n            count(if(s.sale_date >= '2019-01-01' and s.sale_date <='2019-03-31',s.sale_date, null))"
                    },
                    {
                        "username": "sidde_95",
                        "content": "Why is this query not supported because it only says to output product_id and product_name  between date range 2019-01-01 and 2019-03-31\\n\\nselect a.product_id, a.product_name\\nfrom product a \\njoin sales b\\n    on a.product_id = b.product_id \\nwhere b.sale_date >= \\'2019-01-01\\' and b.sale_date <=\\'2019-03-31\\';"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT \\n      A.product_id,\\n      B.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n \\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    },
                    {
                        "username": "Effy_Sama",
                        "content": "Why is this wrong :c \n\nselect product_id,\np.product_name\nfrom product p\nleft join sales s using(product_id)\nwhere product_id not in\n(select product_id\nfrom sales\nwhere month(sale_date) between 4 and 12)\nand month(s.sale_date) between 1 and 3"
                    },
                    {
                        "username": "lucasea777",
                        "content": "Instead of `<=`, you can use `MONTH(date) <= 3` \\uD83D\\uDE0E"
                    },
                    {
                        "username": "Z_N",
                        "content": "SELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nGROUP BY p.product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND\\nMAX(sale_date) <=  \\'2019-03-31\\' "
                    },
                    {
                        "username": "arthireddy",
                        "content": "why is the below code not working\\nSELECT P.product_id, P.product_name from Product P RIGHT OUTER JOIN Sales S on P.product_id=S.product_id WHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\' and (p.product_id <> (SELECT p.product_id WHERE sale_date BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\');"
                    },
                    {
                        "username": "markov_r",
                        "content": "The query below passes the initial test case, but fails on TC 4, which is unfortunately way too long.\\nI don\\'t see any reason for failing, it\\'s quite simple:\\n- remove the intersection of  first quarter and non-first quarter sales, so keeping only the \"clean\" first quarter sales.\\n\\n```\\nselect p.product_id, p.product_name\\nfrom Product p\\njoin Sales s\\non p.product_id = s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (\\n    select p2.product_id \\n    from Product p2\\n    join Sales s2\\n    on p2.product_id = s2.product_id\\n    where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "7 / 13 testcases passed \\nLeetCode are you serious?))"
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "select p.product_id,p.product_name from product p \\nleft join sales s \\non p.product_id=s.product_id where s.sale_date between 2019-01-01 and 2019-03-31\\n\\nWhat is wrong in my code"
                    },
                    {
                        "username": "vishweshhampali",
                        "content": "ONLY sold in 1st quarter .... this part you have missed"
                    },
                    {
                        "username": "yorkltesting",
                        "content": "Why my code is wrong? Can anyone help check for me?\\nSELECT DISTINCT p.product_id, p.product_name\\nFROM product p\\nLEFT JOIN Sales s1 ON p.product_id = s1.product_id AND s1.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nLEFT JOIN Sales s2 ON p.product_id = s2.product_id AND s2.sale_date > \\'2019-03-31\\'\\nWHERE s1.sale_date IS NOT NULL AND s2.sale_date IS NULL"
                    }
                ]
            },
            {
                "id": 1831052,
                "content": [
                    {
                        "username": "testpan0115",
                        "content": "Can someone pls explain why this is not work?\nps : in testacse 10/13 it didn't contain product_id= 34 product_name= v in my output\n\nselect p.product_id ,p.product_name\nfrom Product p\nleft join Sales s\non p.product_id = s.product_id\ngroup by p.product_name\nhaving count(s.product_id) = \n            count(if(s.sale_date >= '2019-01-01' and s.sale_date <='2019-03-31',s.sale_date, null))"
                    },
                    {
                        "username": "sidde_95",
                        "content": "Why is this query not supported because it only says to output product_id and product_name  between date range 2019-01-01 and 2019-03-31\\n\\nselect a.product_id, a.product_name\\nfrom product a \\njoin sales b\\n    on a.product_id = b.product_id \\nwhere b.sale_date >= \\'2019-01-01\\' and b.sale_date <=\\'2019-03-31\\';"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT \\n      A.product_id,\\n      B.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n \\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    },
                    {
                        "username": "Effy_Sama",
                        "content": "Why is this wrong :c \n\nselect product_id,\np.product_name\nfrom product p\nleft join sales s using(product_id)\nwhere product_id not in\n(select product_id\nfrom sales\nwhere month(sale_date) between 4 and 12)\nand month(s.sale_date) between 1 and 3"
                    },
                    {
                        "username": "lucasea777",
                        "content": "Instead of `<=`, you can use `MONTH(date) <= 3` \\uD83D\\uDE0E"
                    },
                    {
                        "username": "Z_N",
                        "content": "SELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nGROUP BY p.product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND\\nMAX(sale_date) <=  \\'2019-03-31\\' "
                    },
                    {
                        "username": "arthireddy",
                        "content": "why is the below code not working\\nSELECT P.product_id, P.product_name from Product P RIGHT OUTER JOIN Sales S on P.product_id=S.product_id WHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\' and (p.product_id <> (SELECT p.product_id WHERE sale_date BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\');"
                    },
                    {
                        "username": "markov_r",
                        "content": "The query below passes the initial test case, but fails on TC 4, which is unfortunately way too long.\\nI don\\'t see any reason for failing, it\\'s quite simple:\\n- remove the intersection of  first quarter and non-first quarter sales, so keeping only the \"clean\" first quarter sales.\\n\\n```\\nselect p.product_id, p.product_name\\nfrom Product p\\njoin Sales s\\non p.product_id = s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (\\n    select p2.product_id \\n    from Product p2\\n    join Sales s2\\n    on p2.product_id = s2.product_id\\n    where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "7 / 13 testcases passed \\nLeetCode are you serious?))"
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "select p.product_id,p.product_name from product p \\nleft join sales s \\non p.product_id=s.product_id where s.sale_date between 2019-01-01 and 2019-03-31\\n\\nWhat is wrong in my code"
                    },
                    {
                        "username": "vishweshhampali",
                        "content": "ONLY sold in 1st quarter .... this part you have missed"
                    },
                    {
                        "username": "yorkltesting",
                        "content": "Why my code is wrong? Can anyone help check for me?\\nSELECT DISTINCT p.product_id, p.product_name\\nFROM product p\\nLEFT JOIN Sales s1 ON p.product_id = s1.product_id AND s1.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nLEFT JOIN Sales s2 ON p.product_id = s2.product_id AND s2.sale_date > \\'2019-03-31\\'\\nWHERE s1.sale_date IS NOT NULL AND s2.sale_date IS NULL"
                    }
                ]
            },
            {
                "id": 1830781,
                "content": [
                    {
                        "username": "testpan0115",
                        "content": "Can someone pls explain why this is not work?\nps : in testacse 10/13 it didn't contain product_id= 34 product_name= v in my output\n\nselect p.product_id ,p.product_name\nfrom Product p\nleft join Sales s\non p.product_id = s.product_id\ngroup by p.product_name\nhaving count(s.product_id) = \n            count(if(s.sale_date >= '2019-01-01' and s.sale_date <='2019-03-31',s.sale_date, null))"
                    },
                    {
                        "username": "sidde_95",
                        "content": "Why is this query not supported because it only says to output product_id and product_name  between date range 2019-01-01 and 2019-03-31\\n\\nselect a.product_id, a.product_name\\nfrom product a \\njoin sales b\\n    on a.product_id = b.product_id \\nwhere b.sale_date >= \\'2019-01-01\\' and b.sale_date <=\\'2019-03-31\\';"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT \\n      A.product_id,\\n      B.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n \\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    },
                    {
                        "username": "Effy_Sama",
                        "content": "Why is this wrong :c \n\nselect product_id,\np.product_name\nfrom product p\nleft join sales s using(product_id)\nwhere product_id not in\n(select product_id\nfrom sales\nwhere month(sale_date) between 4 and 12)\nand month(s.sale_date) between 1 and 3"
                    },
                    {
                        "username": "lucasea777",
                        "content": "Instead of `<=`, you can use `MONTH(date) <= 3` \\uD83D\\uDE0E"
                    },
                    {
                        "username": "Z_N",
                        "content": "SELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nGROUP BY p.product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND\\nMAX(sale_date) <=  \\'2019-03-31\\' "
                    },
                    {
                        "username": "arthireddy",
                        "content": "why is the below code not working\\nSELECT P.product_id, P.product_name from Product P RIGHT OUTER JOIN Sales S on P.product_id=S.product_id WHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\' and (p.product_id <> (SELECT p.product_id WHERE sale_date BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\');"
                    },
                    {
                        "username": "markov_r",
                        "content": "The query below passes the initial test case, but fails on TC 4, which is unfortunately way too long.\\nI don\\'t see any reason for failing, it\\'s quite simple:\\n- remove the intersection of  first quarter and non-first quarter sales, so keeping only the \"clean\" first quarter sales.\\n\\n```\\nselect p.product_id, p.product_name\\nfrom Product p\\njoin Sales s\\non p.product_id = s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (\\n    select p2.product_id \\n    from Product p2\\n    join Sales s2\\n    on p2.product_id = s2.product_id\\n    where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "7 / 13 testcases passed \\nLeetCode are you serious?))"
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "select p.product_id,p.product_name from product p \\nleft join sales s \\non p.product_id=s.product_id where s.sale_date between 2019-01-01 and 2019-03-31\\n\\nWhat is wrong in my code"
                    },
                    {
                        "username": "vishweshhampali",
                        "content": "ONLY sold in 1st quarter .... this part you have missed"
                    },
                    {
                        "username": "yorkltesting",
                        "content": "Why my code is wrong? Can anyone help check for me?\\nSELECT DISTINCT p.product_id, p.product_name\\nFROM product p\\nLEFT JOIN Sales s1 ON p.product_id = s1.product_id AND s1.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nLEFT JOIN Sales s2 ON p.product_id = s2.product_id AND s2.sale_date > \\'2019-03-31\\'\\nWHERE s1.sale_date IS NOT NULL AND s2.sale_date IS NULL"
                    }
                ]
            },
            {
                "id": 1828058,
                "content": [
                    {
                        "username": "testpan0115",
                        "content": "Can someone pls explain why this is not work?\nps : in testacse 10/13 it didn't contain product_id= 34 product_name= v in my output\n\nselect p.product_id ,p.product_name\nfrom Product p\nleft join Sales s\non p.product_id = s.product_id\ngroup by p.product_name\nhaving count(s.product_id) = \n            count(if(s.sale_date >= '2019-01-01' and s.sale_date <='2019-03-31',s.sale_date, null))"
                    },
                    {
                        "username": "sidde_95",
                        "content": "Why is this query not supported because it only says to output product_id and product_name  between date range 2019-01-01 and 2019-03-31\\n\\nselect a.product_id, a.product_name\\nfrom product a \\njoin sales b\\n    on a.product_id = b.product_id \\nwhere b.sale_date >= \\'2019-01-01\\' and b.sale_date <=\\'2019-03-31\\';"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT \\n      A.product_id,\\n      B.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n \\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    },
                    {
                        "username": "Effy_Sama",
                        "content": "Why is this wrong :c \n\nselect product_id,\np.product_name\nfrom product p\nleft join sales s using(product_id)\nwhere product_id not in\n(select product_id\nfrom sales\nwhere month(sale_date) between 4 and 12)\nand month(s.sale_date) between 1 and 3"
                    },
                    {
                        "username": "lucasea777",
                        "content": "Instead of `<=`, you can use `MONTH(date) <= 3` \\uD83D\\uDE0E"
                    },
                    {
                        "username": "Z_N",
                        "content": "SELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nGROUP BY p.product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND\\nMAX(sale_date) <=  \\'2019-03-31\\' "
                    },
                    {
                        "username": "arthireddy",
                        "content": "why is the below code not working\\nSELECT P.product_id, P.product_name from Product P RIGHT OUTER JOIN Sales S on P.product_id=S.product_id WHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\' and (p.product_id <> (SELECT p.product_id WHERE sale_date BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\');"
                    },
                    {
                        "username": "markov_r",
                        "content": "The query below passes the initial test case, but fails on TC 4, which is unfortunately way too long.\\nI don\\'t see any reason for failing, it\\'s quite simple:\\n- remove the intersection of  first quarter and non-first quarter sales, so keeping only the \"clean\" first quarter sales.\\n\\n```\\nselect p.product_id, p.product_name\\nfrom Product p\\njoin Sales s\\non p.product_id = s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (\\n    select p2.product_id \\n    from Product p2\\n    join Sales s2\\n    on p2.product_id = s2.product_id\\n    where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "7 / 13 testcases passed \\nLeetCode are you serious?))"
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "select p.product_id,p.product_name from product p \\nleft join sales s \\non p.product_id=s.product_id where s.sale_date between 2019-01-01 and 2019-03-31\\n\\nWhat is wrong in my code"
                    },
                    {
                        "username": "vishweshhampali",
                        "content": "ONLY sold in 1st quarter .... this part you have missed"
                    },
                    {
                        "username": "yorkltesting",
                        "content": "Why my code is wrong? Can anyone help check for me?\\nSELECT DISTINCT p.product_id, p.product_name\\nFROM product p\\nLEFT JOIN Sales s1 ON p.product_id = s1.product_id AND s1.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nLEFT JOIN Sales s2 ON p.product_id = s2.product_id AND s2.sale_date > \\'2019-03-31\\'\\nWHERE s1.sale_date IS NOT NULL AND s2.sale_date IS NULL"
                    }
                ]
            },
            {
                "id": 1809016,
                "content": [
                    {
                        "username": "testpan0115",
                        "content": "Can someone pls explain why this is not work?\nps : in testacse 10/13 it didn't contain product_id= 34 product_name= v in my output\n\nselect p.product_id ,p.product_name\nfrom Product p\nleft join Sales s\non p.product_id = s.product_id\ngroup by p.product_name\nhaving count(s.product_id) = \n            count(if(s.sale_date >= '2019-01-01' and s.sale_date <='2019-03-31',s.sale_date, null))"
                    },
                    {
                        "username": "sidde_95",
                        "content": "Why is this query not supported because it only says to output product_id and product_name  between date range 2019-01-01 and 2019-03-31\\n\\nselect a.product_id, a.product_name\\nfrom product a \\njoin sales b\\n    on a.product_id = b.product_id \\nwhere b.sale_date >= \\'2019-01-01\\' and b.sale_date <=\\'2019-03-31\\';"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT \\n      A.product_id,\\n      B.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n \\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    },
                    {
                        "username": "Effy_Sama",
                        "content": "Why is this wrong :c \n\nselect product_id,\np.product_name\nfrom product p\nleft join sales s using(product_id)\nwhere product_id not in\n(select product_id\nfrom sales\nwhere month(sale_date) between 4 and 12)\nand month(s.sale_date) between 1 and 3"
                    },
                    {
                        "username": "lucasea777",
                        "content": "Instead of `<=`, you can use `MONTH(date) <= 3` \\uD83D\\uDE0E"
                    },
                    {
                        "username": "Z_N",
                        "content": "SELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nGROUP BY p.product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND\\nMAX(sale_date) <=  \\'2019-03-31\\' "
                    },
                    {
                        "username": "arthireddy",
                        "content": "why is the below code not working\\nSELECT P.product_id, P.product_name from Product P RIGHT OUTER JOIN Sales S on P.product_id=S.product_id WHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\' and (p.product_id <> (SELECT p.product_id WHERE sale_date BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\');"
                    },
                    {
                        "username": "markov_r",
                        "content": "The query below passes the initial test case, but fails on TC 4, which is unfortunately way too long.\\nI don\\'t see any reason for failing, it\\'s quite simple:\\n- remove the intersection of  first quarter and non-first quarter sales, so keeping only the \"clean\" first quarter sales.\\n\\n```\\nselect p.product_id, p.product_name\\nfrom Product p\\njoin Sales s\\non p.product_id = s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (\\n    select p2.product_id \\n    from Product p2\\n    join Sales s2\\n    on p2.product_id = s2.product_id\\n    where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "7 / 13 testcases passed \\nLeetCode are you serious?))"
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "select p.product_id,p.product_name from product p \\nleft join sales s \\non p.product_id=s.product_id where s.sale_date between 2019-01-01 and 2019-03-31\\n\\nWhat is wrong in my code"
                    },
                    {
                        "username": "vishweshhampali",
                        "content": "ONLY sold in 1st quarter .... this part you have missed"
                    },
                    {
                        "username": "yorkltesting",
                        "content": "Why my code is wrong? Can anyone help check for me?\\nSELECT DISTINCT p.product_id, p.product_name\\nFROM product p\\nLEFT JOIN Sales s1 ON p.product_id = s1.product_id AND s1.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nLEFT JOIN Sales s2 ON p.product_id = s2.product_id AND s2.sale_date > \\'2019-03-31\\'\\nWHERE s1.sale_date IS NOT NULL AND s2.sale_date IS NULL"
                    }
                ]
            },
            {
                "id": 1808095,
                "content": [
                    {
                        "username": "testpan0115",
                        "content": "Can someone pls explain why this is not work?\nps : in testacse 10/13 it didn't contain product_id= 34 product_name= v in my output\n\nselect p.product_id ,p.product_name\nfrom Product p\nleft join Sales s\non p.product_id = s.product_id\ngroup by p.product_name\nhaving count(s.product_id) = \n            count(if(s.sale_date >= '2019-01-01' and s.sale_date <='2019-03-31',s.sale_date, null))"
                    },
                    {
                        "username": "sidde_95",
                        "content": "Why is this query not supported because it only says to output product_id and product_name  between date range 2019-01-01 and 2019-03-31\\n\\nselect a.product_id, a.product_name\\nfrom product a \\njoin sales b\\n    on a.product_id = b.product_id \\nwhere b.sale_date >= \\'2019-01-01\\' and b.sale_date <=\\'2019-03-31\\';"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT \\n      A.product_id,\\n      B.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n \\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    },
                    {
                        "username": "Effy_Sama",
                        "content": "Why is this wrong :c \n\nselect product_id,\np.product_name\nfrom product p\nleft join sales s using(product_id)\nwhere product_id not in\n(select product_id\nfrom sales\nwhere month(sale_date) between 4 and 12)\nand month(s.sale_date) between 1 and 3"
                    },
                    {
                        "username": "lucasea777",
                        "content": "Instead of `<=`, you can use `MONTH(date) <= 3` \\uD83D\\uDE0E"
                    },
                    {
                        "username": "Z_N",
                        "content": "SELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nGROUP BY p.product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND\\nMAX(sale_date) <=  \\'2019-03-31\\' "
                    },
                    {
                        "username": "arthireddy",
                        "content": "why is the below code not working\\nSELECT P.product_id, P.product_name from Product P RIGHT OUTER JOIN Sales S on P.product_id=S.product_id WHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\' and (p.product_id <> (SELECT p.product_id WHERE sale_date BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\');"
                    },
                    {
                        "username": "markov_r",
                        "content": "The query below passes the initial test case, but fails on TC 4, which is unfortunately way too long.\\nI don\\'t see any reason for failing, it\\'s quite simple:\\n- remove the intersection of  first quarter and non-first quarter sales, so keeping only the \"clean\" first quarter sales.\\n\\n```\\nselect p.product_id, p.product_name\\nfrom Product p\\njoin Sales s\\non p.product_id = s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (\\n    select p2.product_id \\n    from Product p2\\n    join Sales s2\\n    on p2.product_id = s2.product_id\\n    where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "7 / 13 testcases passed \\nLeetCode are you serious?))"
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "select p.product_id,p.product_name from product p \\nleft join sales s \\non p.product_id=s.product_id where s.sale_date between 2019-01-01 and 2019-03-31\\n\\nWhat is wrong in my code"
                    },
                    {
                        "username": "vishweshhampali",
                        "content": "ONLY sold in 1st quarter .... this part you have missed"
                    },
                    {
                        "username": "yorkltesting",
                        "content": "Why my code is wrong? Can anyone help check for me?\\nSELECT DISTINCT p.product_id, p.product_name\\nFROM product p\\nLEFT JOIN Sales s1 ON p.product_id = s1.product_id AND s1.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nLEFT JOIN Sales s2 ON p.product_id = s2.product_id AND s2.sale_date > \\'2019-03-31\\'\\nWHERE s1.sale_date IS NOT NULL AND s2.sale_date IS NULL"
                    }
                ]
            },
            {
                "id": 1804339,
                "content": [
                    {
                        "username": "testpan0115",
                        "content": "Can someone pls explain why this is not work?\nps : in testacse 10/13 it didn't contain product_id= 34 product_name= v in my output\n\nselect p.product_id ,p.product_name\nfrom Product p\nleft join Sales s\non p.product_id = s.product_id\ngroup by p.product_name\nhaving count(s.product_id) = \n            count(if(s.sale_date >= '2019-01-01' and s.sale_date <='2019-03-31',s.sale_date, null))"
                    },
                    {
                        "username": "sidde_95",
                        "content": "Why is this query not supported because it only says to output product_id and product_name  between date range 2019-01-01 and 2019-03-31\\n\\nselect a.product_id, a.product_name\\nfrom product a \\njoin sales b\\n    on a.product_id = b.product_id \\nwhere b.sale_date >= \\'2019-01-01\\' and b.sale_date <=\\'2019-03-31\\';"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT \\n      A.product_id,\\n      B.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n \\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    },
                    {
                        "username": "Effy_Sama",
                        "content": "Why is this wrong :c \n\nselect product_id,\np.product_name\nfrom product p\nleft join sales s using(product_id)\nwhere product_id not in\n(select product_id\nfrom sales\nwhere month(sale_date) between 4 and 12)\nand month(s.sale_date) between 1 and 3"
                    },
                    {
                        "username": "lucasea777",
                        "content": "Instead of `<=`, you can use `MONTH(date) <= 3` \\uD83D\\uDE0E"
                    },
                    {
                        "username": "Z_N",
                        "content": "SELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nGROUP BY p.product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND\\nMAX(sale_date) <=  \\'2019-03-31\\' "
                    },
                    {
                        "username": "arthireddy",
                        "content": "why is the below code not working\\nSELECT P.product_id, P.product_name from Product P RIGHT OUTER JOIN Sales S on P.product_id=S.product_id WHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\' and (p.product_id <> (SELECT p.product_id WHERE sale_date BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\');"
                    },
                    {
                        "username": "markov_r",
                        "content": "The query below passes the initial test case, but fails on TC 4, which is unfortunately way too long.\\nI don\\'t see any reason for failing, it\\'s quite simple:\\n- remove the intersection of  first quarter and non-first quarter sales, so keeping only the \"clean\" first quarter sales.\\n\\n```\\nselect p.product_id, p.product_name\\nfrom Product p\\njoin Sales s\\non p.product_id = s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (\\n    select p2.product_id \\n    from Product p2\\n    join Sales s2\\n    on p2.product_id = s2.product_id\\n    where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "7 / 13 testcases passed \\nLeetCode are you serious?))"
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "select p.product_id,p.product_name from product p \\nleft join sales s \\non p.product_id=s.product_id where s.sale_date between 2019-01-01 and 2019-03-31\\n\\nWhat is wrong in my code"
                    },
                    {
                        "username": "vishweshhampali",
                        "content": "ONLY sold in 1st quarter .... this part you have missed"
                    },
                    {
                        "username": "yorkltesting",
                        "content": "Why my code is wrong? Can anyone help check for me?\\nSELECT DISTINCT p.product_id, p.product_name\\nFROM product p\\nLEFT JOIN Sales s1 ON p.product_id = s1.product_id AND s1.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nLEFT JOIN Sales s2 ON p.product_id = s2.product_id AND s2.sale_date > \\'2019-03-31\\'\\nWHERE s1.sale_date IS NOT NULL AND s2.sale_date IS NULL"
                    }
                ]
            },
            {
                "id": 1803052,
                "content": [
                    {
                        "username": "testpan0115",
                        "content": "Can someone pls explain why this is not work?\nps : in testacse 10/13 it didn't contain product_id= 34 product_name= v in my output\n\nselect p.product_id ,p.product_name\nfrom Product p\nleft join Sales s\non p.product_id = s.product_id\ngroup by p.product_name\nhaving count(s.product_id) = \n            count(if(s.sale_date >= '2019-01-01' and s.sale_date <='2019-03-31',s.sale_date, null))"
                    },
                    {
                        "username": "sidde_95",
                        "content": "Why is this query not supported because it only says to output product_id and product_name  between date range 2019-01-01 and 2019-03-31\\n\\nselect a.product_id, a.product_name\\nfrom product a \\njoin sales b\\n    on a.product_id = b.product_id \\nwhere b.sale_date >= \\'2019-01-01\\' and b.sale_date <=\\'2019-03-31\\';"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT \\n      A.product_id,\\n      B.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n \\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    },
                    {
                        "username": "Effy_Sama",
                        "content": "Why is this wrong :c \n\nselect product_id,\np.product_name\nfrom product p\nleft join sales s using(product_id)\nwhere product_id not in\n(select product_id\nfrom sales\nwhere month(sale_date) between 4 and 12)\nand month(s.sale_date) between 1 and 3"
                    },
                    {
                        "username": "lucasea777",
                        "content": "Instead of `<=`, you can use `MONTH(date) <= 3` \\uD83D\\uDE0E"
                    },
                    {
                        "username": "Z_N",
                        "content": "SELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nGROUP BY p.product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND\\nMAX(sale_date) <=  \\'2019-03-31\\' "
                    },
                    {
                        "username": "arthireddy",
                        "content": "why is the below code not working\\nSELECT P.product_id, P.product_name from Product P RIGHT OUTER JOIN Sales S on P.product_id=S.product_id WHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\' and (p.product_id <> (SELECT p.product_id WHERE sale_date BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\');"
                    },
                    {
                        "username": "markov_r",
                        "content": "The query below passes the initial test case, but fails on TC 4, which is unfortunately way too long.\\nI don\\'t see any reason for failing, it\\'s quite simple:\\n- remove the intersection of  first quarter and non-first quarter sales, so keeping only the \"clean\" first quarter sales.\\n\\n```\\nselect p.product_id, p.product_name\\nfrom Product p\\njoin Sales s\\non p.product_id = s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (\\n    select p2.product_id \\n    from Product p2\\n    join Sales s2\\n    on p2.product_id = s2.product_id\\n    where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "7 / 13 testcases passed \\nLeetCode are you serious?))"
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "select p.product_id,p.product_name from product p \\nleft join sales s \\non p.product_id=s.product_id where s.sale_date between 2019-01-01 and 2019-03-31\\n\\nWhat is wrong in my code"
                    },
                    {
                        "username": "vishweshhampali",
                        "content": "ONLY sold in 1st quarter .... this part you have missed"
                    },
                    {
                        "username": "yorkltesting",
                        "content": "Why my code is wrong? Can anyone help check for me?\\nSELECT DISTINCT p.product_id, p.product_name\\nFROM product p\\nLEFT JOIN Sales s1 ON p.product_id = s1.product_id AND s1.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nLEFT JOIN Sales s2 ON p.product_id = s2.product_id AND s2.sale_date > \\'2019-03-31\\'\\nWHERE s1.sale_date IS NOT NULL AND s2.sale_date IS NULL"
                    }
                ]
            },
            {
                "id": 1793175,
                "content": [
                    {
                        "username": "testpan0115",
                        "content": "Can someone pls explain why this is not work?\nps : in testacse 10/13 it didn't contain product_id= 34 product_name= v in my output\n\nselect p.product_id ,p.product_name\nfrom Product p\nleft join Sales s\non p.product_id = s.product_id\ngroup by p.product_name\nhaving count(s.product_id) = \n            count(if(s.sale_date >= '2019-01-01' and s.sale_date <='2019-03-31',s.sale_date, null))"
                    },
                    {
                        "username": "sidde_95",
                        "content": "Why is this query not supported because it only says to output product_id and product_name  between date range 2019-01-01 and 2019-03-31\\n\\nselect a.product_id, a.product_name\\nfrom product a \\njoin sales b\\n    on a.product_id = b.product_id \\nwhere b.sale_date >= \\'2019-01-01\\' and b.sale_date <=\\'2019-03-31\\';"
                    },
                    {
                        "username": "arabas2697",
                        "content": "SELECT \\n      A.product_id,\\n      B.product_name\\nfrom Sales A left join Product B\\non A.product_id = B.product_id\\nGROUP BY A.product_id, B.product_name\\nHAVING min(A.[sale_date]) >= datefromparts(2019,01,01) and max(A.[sale_date]) <= datefromparts(2019,03,31)\\n \\nTry this, the reason being G4 has 2 sale_dates and second sale_date is in 2nd qtr, question only specifies 1qtr. So better to agg the dates and use having criterion."
                    },
                    {
                        "username": "Effy_Sama",
                        "content": "Why is this wrong :c \n\nselect product_id,\np.product_name\nfrom product p\nleft join sales s using(product_id)\nwhere product_id not in\n(select product_id\nfrom sales\nwhere month(sale_date) between 4 and 12)\nand month(s.sale_date) between 1 and 3"
                    },
                    {
                        "username": "lucasea777",
                        "content": "Instead of `<=`, you can use `MONTH(date) <= 3` \\uD83D\\uDE0E"
                    },
                    {
                        "username": "Z_N",
                        "content": "SELECT p.product_id, p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nGROUP BY p.product_id\\nHAVING MIN(sale_date) >= \\'2019-01-01\\' AND\\nMAX(sale_date) <=  \\'2019-03-31\\' "
                    },
                    {
                        "username": "arthireddy",
                        "content": "why is the below code not working\\nSELECT P.product_id, P.product_name from Product P RIGHT OUTER JOIN Sales S on P.product_id=S.product_id WHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\' and (p.product_id <> (SELECT p.product_id WHERE sale_date BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\');"
                    },
                    {
                        "username": "markov_r",
                        "content": "The query below passes the initial test case, but fails on TC 4, which is unfortunately way too long.\\nI don\\'t see any reason for failing, it\\'s quite simple:\\n- remove the intersection of  first quarter and non-first quarter sales, so keeping only the \"clean\" first quarter sales.\\n\\n```\\nselect p.product_id, p.product_name\\nfrom Product p\\njoin Sales s\\non p.product_id = s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand p.product_id not in (\\n    select p2.product_id \\n    from Product p2\\n    join Sales s2\\n    on p2.product_id = s2.product_id\\n    where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "7 / 13 testcases passed \\nLeetCode are you serious?))"
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "select p.product_id,p.product_name from product p \\nleft join sales s \\non p.product_id=s.product_id where s.sale_date between 2019-01-01 and 2019-03-31\\n\\nWhat is wrong in my code"
                    },
                    {
                        "username": "vishweshhampali",
                        "content": "ONLY sold in 1st quarter .... this part you have missed"
                    },
                    {
                        "username": "yorkltesting",
                        "content": "Why my code is wrong? Can anyone help check for me?\\nSELECT DISTINCT p.product_id, p.product_name\\nFROM product p\\nLEFT JOIN Sales s1 ON p.product_id = s1.product_id AND s1.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nLEFT JOIN Sales s2 ON p.product_id = s2.product_id AND s2.sale_date > \\'2019-03-31\\'\\nWHERE s1.sale_date IS NOT NULL AND s2.sale_date IS NULL"
                    }
                ]
            },
            {
                "id": 1793156,
                "content": [
                    {
                        "username": "adityachatterjee",
                        "content": "Why would the below query not work? Not considering the performance here. Only from solution correctness standpoint.\n\nSELECT P.product_id,P.product_name\nFROM\nSALES S\nLEFT JOIN\n(SELECT DISTINCT * FROM PRODUCT) P\nON\nS.PRODUCT_ID=P.PRODUCT_ID\nWHERE YEAR(SALE_DATE)=2019 AND MONTH(SALE_DATE)<=3 AND P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE YEAR(SALE_DATE)=2019 AND MONTH (SALE_DATE)>3) \n##SALE_DATE>=2019-01-01 AND SALE_DATE<=2019-03-31\nGROUP BY 1,2 ORDER BY PRODUCT_ID"
                    },
                    {
                        "username": "akashdubey2047",
                        "content": "SELECT p.product_id, product_name \\nFROM Product P INNER JOIN Sales S ON p.product_id=s.product_id \\nWHERE p.product_id NOT IN (SELECT product_id FROM Sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\') \\nGROUP BY p.product_id,product_name;"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Product_id,Product_name from Product where Product_id in (select Product_id from Sales Group by product_id having Min(sale_date)>=\\'2019-01-01\\' and Max(Sale_date)<=\\'2019-03-31\\');"
                    },
                    {
                        "username": "ShubhayanS",
                        "content": "\\n`select product_id, product_name from Product \\nwhere product_id in\\n(select product_id  from Sales\\ngroup by 1\\nhaving max(year(sale_date)) = 2019 and max(month(sale_date)) <=3)`[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH SPRING_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\n), OTHER_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\' \\n)\\nSELECT \\n    DISTINCT P.PRODUCT_ID AS product_id, \\n    P.PRODUCT_NAME AS product_name \\nFROM \\n    PRODUCT P JOIN SPRING_SALES S \\nON \\n    P.PRODUCT_ID = S.PRODUCT_ID\\nAND \\n    P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM OTHER_SALES);\\n\\n\\n-- Why this is not working?"
                    },
                    {
                        "username": "mahapatraabhishek04",
                        "content": "I am not able to figure out why the below query is giving wrong output on submitting even though it worked when I clicked Run. Can anyone please help.\\nI am using MS SQL Server to run the below code.\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date between cast(\\'2019-01-01\\' as date) and cast(\\'2019-03-31\\' as date)\\nexcept\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date > cast(\\'2019-03-31\\' as date)"
                    },
                    {
                        "username": "user2708Pa",
                        "content": "I am at lost here. When I run my code, I get the correct answer, but then when I click submit, I get a different output and it\\'s marked as wrong. \\nAny idea what\\'s happening?"
                    },
                    {
                        "username": "vamsivankuri",
                        "content": ";with cte as\\n(\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) >cast(\\'2019-03-31\\' as date)\\nunion\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) <cast(\\'2019-01-01\\' as date)\\n), cte1 as\\n(\\nselect p.product_id, p.product_name\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere p.product_id not in (select product_id from cte)\\n)\\nselect * from cte1"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "I am including all criteria and still this won\\'t run on test case second - \\n`select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')`"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT product.product_id, product_name \\n FROM Product INNER JOIN Sales\\n ON Product.product_id=Sales.product_id\\n WHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nWhy  it is not showing the correct output?\\n "
                    },
                    {
                        "username": "tianxuzang",
                        "content": "Sale table has no primary key, it can have repeated rows.\\nthat is why need to use group by to avoid the duplicate row issue "
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "It does not take into account products that were sold both within the date range and outside the date range."
                    }
                ]
            },
            {
                "id": 1786009,
                "content": [
                    {
                        "username": "adityachatterjee",
                        "content": "Why would the below query not work? Not considering the performance here. Only from solution correctness standpoint.\n\nSELECT P.product_id,P.product_name\nFROM\nSALES S\nLEFT JOIN\n(SELECT DISTINCT * FROM PRODUCT) P\nON\nS.PRODUCT_ID=P.PRODUCT_ID\nWHERE YEAR(SALE_DATE)=2019 AND MONTH(SALE_DATE)<=3 AND P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE YEAR(SALE_DATE)=2019 AND MONTH (SALE_DATE)>3) \n##SALE_DATE>=2019-01-01 AND SALE_DATE<=2019-03-31\nGROUP BY 1,2 ORDER BY PRODUCT_ID"
                    },
                    {
                        "username": "akashdubey2047",
                        "content": "SELECT p.product_id, product_name \\nFROM Product P INNER JOIN Sales S ON p.product_id=s.product_id \\nWHERE p.product_id NOT IN (SELECT product_id FROM Sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\') \\nGROUP BY p.product_id,product_name;"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Product_id,Product_name from Product where Product_id in (select Product_id from Sales Group by product_id having Min(sale_date)>=\\'2019-01-01\\' and Max(Sale_date)<=\\'2019-03-31\\');"
                    },
                    {
                        "username": "ShubhayanS",
                        "content": "\\n`select product_id, product_name from Product \\nwhere product_id in\\n(select product_id  from Sales\\ngroup by 1\\nhaving max(year(sale_date)) = 2019 and max(month(sale_date)) <=3)`[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH SPRING_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\n), OTHER_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\' \\n)\\nSELECT \\n    DISTINCT P.PRODUCT_ID AS product_id, \\n    P.PRODUCT_NAME AS product_name \\nFROM \\n    PRODUCT P JOIN SPRING_SALES S \\nON \\n    P.PRODUCT_ID = S.PRODUCT_ID\\nAND \\n    P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM OTHER_SALES);\\n\\n\\n-- Why this is not working?"
                    },
                    {
                        "username": "mahapatraabhishek04",
                        "content": "I am not able to figure out why the below query is giving wrong output on submitting even though it worked when I clicked Run. Can anyone please help.\\nI am using MS SQL Server to run the below code.\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date between cast(\\'2019-01-01\\' as date) and cast(\\'2019-03-31\\' as date)\\nexcept\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date > cast(\\'2019-03-31\\' as date)"
                    },
                    {
                        "username": "user2708Pa",
                        "content": "I am at lost here. When I run my code, I get the correct answer, but then when I click submit, I get a different output and it\\'s marked as wrong. \\nAny idea what\\'s happening?"
                    },
                    {
                        "username": "vamsivankuri",
                        "content": ";with cte as\\n(\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) >cast(\\'2019-03-31\\' as date)\\nunion\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) <cast(\\'2019-01-01\\' as date)\\n), cte1 as\\n(\\nselect p.product_id, p.product_name\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere p.product_id not in (select product_id from cte)\\n)\\nselect * from cte1"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "I am including all criteria and still this won\\'t run on test case second - \\n`select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')`"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT product.product_id, product_name \\n FROM Product INNER JOIN Sales\\n ON Product.product_id=Sales.product_id\\n WHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nWhy  it is not showing the correct output?\\n "
                    },
                    {
                        "username": "tianxuzang",
                        "content": "Sale table has no primary key, it can have repeated rows.\\nthat is why need to use group by to avoid the duplicate row issue "
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "It does not take into account products that were sold both within the date range and outside the date range."
                    }
                ]
            },
            {
                "id": 1783923,
                "content": [
                    {
                        "username": "adityachatterjee",
                        "content": "Why would the below query not work? Not considering the performance here. Only from solution correctness standpoint.\n\nSELECT P.product_id,P.product_name\nFROM\nSALES S\nLEFT JOIN\n(SELECT DISTINCT * FROM PRODUCT) P\nON\nS.PRODUCT_ID=P.PRODUCT_ID\nWHERE YEAR(SALE_DATE)=2019 AND MONTH(SALE_DATE)<=3 AND P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE YEAR(SALE_DATE)=2019 AND MONTH (SALE_DATE)>3) \n##SALE_DATE>=2019-01-01 AND SALE_DATE<=2019-03-31\nGROUP BY 1,2 ORDER BY PRODUCT_ID"
                    },
                    {
                        "username": "akashdubey2047",
                        "content": "SELECT p.product_id, product_name \\nFROM Product P INNER JOIN Sales S ON p.product_id=s.product_id \\nWHERE p.product_id NOT IN (SELECT product_id FROM Sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\') \\nGROUP BY p.product_id,product_name;"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Product_id,Product_name from Product where Product_id in (select Product_id from Sales Group by product_id having Min(sale_date)>=\\'2019-01-01\\' and Max(Sale_date)<=\\'2019-03-31\\');"
                    },
                    {
                        "username": "ShubhayanS",
                        "content": "\\n`select product_id, product_name from Product \\nwhere product_id in\\n(select product_id  from Sales\\ngroup by 1\\nhaving max(year(sale_date)) = 2019 and max(month(sale_date)) <=3)`[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH SPRING_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\n), OTHER_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\' \\n)\\nSELECT \\n    DISTINCT P.PRODUCT_ID AS product_id, \\n    P.PRODUCT_NAME AS product_name \\nFROM \\n    PRODUCT P JOIN SPRING_SALES S \\nON \\n    P.PRODUCT_ID = S.PRODUCT_ID\\nAND \\n    P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM OTHER_SALES);\\n\\n\\n-- Why this is not working?"
                    },
                    {
                        "username": "mahapatraabhishek04",
                        "content": "I am not able to figure out why the below query is giving wrong output on submitting even though it worked when I clicked Run. Can anyone please help.\\nI am using MS SQL Server to run the below code.\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date between cast(\\'2019-01-01\\' as date) and cast(\\'2019-03-31\\' as date)\\nexcept\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date > cast(\\'2019-03-31\\' as date)"
                    },
                    {
                        "username": "user2708Pa",
                        "content": "I am at lost here. When I run my code, I get the correct answer, but then when I click submit, I get a different output and it\\'s marked as wrong. \\nAny idea what\\'s happening?"
                    },
                    {
                        "username": "vamsivankuri",
                        "content": ";with cte as\\n(\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) >cast(\\'2019-03-31\\' as date)\\nunion\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) <cast(\\'2019-01-01\\' as date)\\n), cte1 as\\n(\\nselect p.product_id, p.product_name\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere p.product_id not in (select product_id from cte)\\n)\\nselect * from cte1"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "I am including all criteria and still this won\\'t run on test case second - \\n`select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')`"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT product.product_id, product_name \\n FROM Product INNER JOIN Sales\\n ON Product.product_id=Sales.product_id\\n WHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nWhy  it is not showing the correct output?\\n "
                    },
                    {
                        "username": "tianxuzang",
                        "content": "Sale table has no primary key, it can have repeated rows.\\nthat is why need to use group by to avoid the duplicate row issue "
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "It does not take into account products that were sold both within the date range and outside the date range."
                    }
                ]
            },
            {
                "id": 1775651,
                "content": [
                    {
                        "username": "adityachatterjee",
                        "content": "Why would the below query not work? Not considering the performance here. Only from solution correctness standpoint.\n\nSELECT P.product_id,P.product_name\nFROM\nSALES S\nLEFT JOIN\n(SELECT DISTINCT * FROM PRODUCT) P\nON\nS.PRODUCT_ID=P.PRODUCT_ID\nWHERE YEAR(SALE_DATE)=2019 AND MONTH(SALE_DATE)<=3 AND P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE YEAR(SALE_DATE)=2019 AND MONTH (SALE_DATE)>3) \n##SALE_DATE>=2019-01-01 AND SALE_DATE<=2019-03-31\nGROUP BY 1,2 ORDER BY PRODUCT_ID"
                    },
                    {
                        "username": "akashdubey2047",
                        "content": "SELECT p.product_id, product_name \\nFROM Product P INNER JOIN Sales S ON p.product_id=s.product_id \\nWHERE p.product_id NOT IN (SELECT product_id FROM Sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\') \\nGROUP BY p.product_id,product_name;"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Product_id,Product_name from Product where Product_id in (select Product_id from Sales Group by product_id having Min(sale_date)>=\\'2019-01-01\\' and Max(Sale_date)<=\\'2019-03-31\\');"
                    },
                    {
                        "username": "ShubhayanS",
                        "content": "\\n`select product_id, product_name from Product \\nwhere product_id in\\n(select product_id  from Sales\\ngroup by 1\\nhaving max(year(sale_date)) = 2019 and max(month(sale_date)) <=3)`[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH SPRING_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\n), OTHER_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\' \\n)\\nSELECT \\n    DISTINCT P.PRODUCT_ID AS product_id, \\n    P.PRODUCT_NAME AS product_name \\nFROM \\n    PRODUCT P JOIN SPRING_SALES S \\nON \\n    P.PRODUCT_ID = S.PRODUCT_ID\\nAND \\n    P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM OTHER_SALES);\\n\\n\\n-- Why this is not working?"
                    },
                    {
                        "username": "mahapatraabhishek04",
                        "content": "I am not able to figure out why the below query is giving wrong output on submitting even though it worked when I clicked Run. Can anyone please help.\\nI am using MS SQL Server to run the below code.\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date between cast(\\'2019-01-01\\' as date) and cast(\\'2019-03-31\\' as date)\\nexcept\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date > cast(\\'2019-03-31\\' as date)"
                    },
                    {
                        "username": "user2708Pa",
                        "content": "I am at lost here. When I run my code, I get the correct answer, but then when I click submit, I get a different output and it\\'s marked as wrong. \\nAny idea what\\'s happening?"
                    },
                    {
                        "username": "vamsivankuri",
                        "content": ";with cte as\\n(\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) >cast(\\'2019-03-31\\' as date)\\nunion\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) <cast(\\'2019-01-01\\' as date)\\n), cte1 as\\n(\\nselect p.product_id, p.product_name\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere p.product_id not in (select product_id from cte)\\n)\\nselect * from cte1"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "I am including all criteria and still this won\\'t run on test case second - \\n`select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')`"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT product.product_id, product_name \\n FROM Product INNER JOIN Sales\\n ON Product.product_id=Sales.product_id\\n WHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nWhy  it is not showing the correct output?\\n "
                    },
                    {
                        "username": "tianxuzang",
                        "content": "Sale table has no primary key, it can have repeated rows.\\nthat is why need to use group by to avoid the duplicate row issue "
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "It does not take into account products that were sold both within the date range and outside the date range."
                    }
                ]
            },
            {
                "id": 1775068,
                "content": [
                    {
                        "username": "adityachatterjee",
                        "content": "Why would the below query not work? Not considering the performance here. Only from solution correctness standpoint.\n\nSELECT P.product_id,P.product_name\nFROM\nSALES S\nLEFT JOIN\n(SELECT DISTINCT * FROM PRODUCT) P\nON\nS.PRODUCT_ID=P.PRODUCT_ID\nWHERE YEAR(SALE_DATE)=2019 AND MONTH(SALE_DATE)<=3 AND P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE YEAR(SALE_DATE)=2019 AND MONTH (SALE_DATE)>3) \n##SALE_DATE>=2019-01-01 AND SALE_DATE<=2019-03-31\nGROUP BY 1,2 ORDER BY PRODUCT_ID"
                    },
                    {
                        "username": "akashdubey2047",
                        "content": "SELECT p.product_id, product_name \\nFROM Product P INNER JOIN Sales S ON p.product_id=s.product_id \\nWHERE p.product_id NOT IN (SELECT product_id FROM Sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\') \\nGROUP BY p.product_id,product_name;"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Product_id,Product_name from Product where Product_id in (select Product_id from Sales Group by product_id having Min(sale_date)>=\\'2019-01-01\\' and Max(Sale_date)<=\\'2019-03-31\\');"
                    },
                    {
                        "username": "ShubhayanS",
                        "content": "\\n`select product_id, product_name from Product \\nwhere product_id in\\n(select product_id  from Sales\\ngroup by 1\\nhaving max(year(sale_date)) = 2019 and max(month(sale_date)) <=3)`[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH SPRING_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\n), OTHER_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\' \\n)\\nSELECT \\n    DISTINCT P.PRODUCT_ID AS product_id, \\n    P.PRODUCT_NAME AS product_name \\nFROM \\n    PRODUCT P JOIN SPRING_SALES S \\nON \\n    P.PRODUCT_ID = S.PRODUCT_ID\\nAND \\n    P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM OTHER_SALES);\\n\\n\\n-- Why this is not working?"
                    },
                    {
                        "username": "mahapatraabhishek04",
                        "content": "I am not able to figure out why the below query is giving wrong output on submitting even though it worked when I clicked Run. Can anyone please help.\\nI am using MS SQL Server to run the below code.\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date between cast(\\'2019-01-01\\' as date) and cast(\\'2019-03-31\\' as date)\\nexcept\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date > cast(\\'2019-03-31\\' as date)"
                    },
                    {
                        "username": "user2708Pa",
                        "content": "I am at lost here. When I run my code, I get the correct answer, but then when I click submit, I get a different output and it\\'s marked as wrong. \\nAny idea what\\'s happening?"
                    },
                    {
                        "username": "vamsivankuri",
                        "content": ";with cte as\\n(\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) >cast(\\'2019-03-31\\' as date)\\nunion\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) <cast(\\'2019-01-01\\' as date)\\n), cte1 as\\n(\\nselect p.product_id, p.product_name\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere p.product_id not in (select product_id from cte)\\n)\\nselect * from cte1"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "I am including all criteria and still this won\\'t run on test case second - \\n`select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')`"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT product.product_id, product_name \\n FROM Product INNER JOIN Sales\\n ON Product.product_id=Sales.product_id\\n WHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nWhy  it is not showing the correct output?\\n "
                    },
                    {
                        "username": "tianxuzang",
                        "content": "Sale table has no primary key, it can have repeated rows.\\nthat is why need to use group by to avoid the duplicate row issue "
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "It does not take into account products that were sold both within the date range and outside the date range."
                    }
                ]
            },
            {
                "id": 1771657,
                "content": [
                    {
                        "username": "adityachatterjee",
                        "content": "Why would the below query not work? Not considering the performance here. Only from solution correctness standpoint.\n\nSELECT P.product_id,P.product_name\nFROM\nSALES S\nLEFT JOIN\n(SELECT DISTINCT * FROM PRODUCT) P\nON\nS.PRODUCT_ID=P.PRODUCT_ID\nWHERE YEAR(SALE_DATE)=2019 AND MONTH(SALE_DATE)<=3 AND P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE YEAR(SALE_DATE)=2019 AND MONTH (SALE_DATE)>3) \n##SALE_DATE>=2019-01-01 AND SALE_DATE<=2019-03-31\nGROUP BY 1,2 ORDER BY PRODUCT_ID"
                    },
                    {
                        "username": "akashdubey2047",
                        "content": "SELECT p.product_id, product_name \\nFROM Product P INNER JOIN Sales S ON p.product_id=s.product_id \\nWHERE p.product_id NOT IN (SELECT product_id FROM Sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\') \\nGROUP BY p.product_id,product_name;"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Product_id,Product_name from Product where Product_id in (select Product_id from Sales Group by product_id having Min(sale_date)>=\\'2019-01-01\\' and Max(Sale_date)<=\\'2019-03-31\\');"
                    },
                    {
                        "username": "ShubhayanS",
                        "content": "\\n`select product_id, product_name from Product \\nwhere product_id in\\n(select product_id  from Sales\\ngroup by 1\\nhaving max(year(sale_date)) = 2019 and max(month(sale_date)) <=3)`[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH SPRING_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\n), OTHER_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\' \\n)\\nSELECT \\n    DISTINCT P.PRODUCT_ID AS product_id, \\n    P.PRODUCT_NAME AS product_name \\nFROM \\n    PRODUCT P JOIN SPRING_SALES S \\nON \\n    P.PRODUCT_ID = S.PRODUCT_ID\\nAND \\n    P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM OTHER_SALES);\\n\\n\\n-- Why this is not working?"
                    },
                    {
                        "username": "mahapatraabhishek04",
                        "content": "I am not able to figure out why the below query is giving wrong output on submitting even though it worked when I clicked Run. Can anyone please help.\\nI am using MS SQL Server to run the below code.\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date between cast(\\'2019-01-01\\' as date) and cast(\\'2019-03-31\\' as date)\\nexcept\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date > cast(\\'2019-03-31\\' as date)"
                    },
                    {
                        "username": "user2708Pa",
                        "content": "I am at lost here. When I run my code, I get the correct answer, but then when I click submit, I get a different output and it\\'s marked as wrong. \\nAny idea what\\'s happening?"
                    },
                    {
                        "username": "vamsivankuri",
                        "content": ";with cte as\\n(\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) >cast(\\'2019-03-31\\' as date)\\nunion\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) <cast(\\'2019-01-01\\' as date)\\n), cte1 as\\n(\\nselect p.product_id, p.product_name\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere p.product_id not in (select product_id from cte)\\n)\\nselect * from cte1"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "I am including all criteria and still this won\\'t run on test case second - \\n`select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')`"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT product.product_id, product_name \\n FROM Product INNER JOIN Sales\\n ON Product.product_id=Sales.product_id\\n WHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nWhy  it is not showing the correct output?\\n "
                    },
                    {
                        "username": "tianxuzang",
                        "content": "Sale table has no primary key, it can have repeated rows.\\nthat is why need to use group by to avoid the duplicate row issue "
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "It does not take into account products that were sold both within the date range and outside the date range."
                    }
                ]
            },
            {
                "id": 1766966,
                "content": [
                    {
                        "username": "adityachatterjee",
                        "content": "Why would the below query not work? Not considering the performance here. Only from solution correctness standpoint.\n\nSELECT P.product_id,P.product_name\nFROM\nSALES S\nLEFT JOIN\n(SELECT DISTINCT * FROM PRODUCT) P\nON\nS.PRODUCT_ID=P.PRODUCT_ID\nWHERE YEAR(SALE_DATE)=2019 AND MONTH(SALE_DATE)<=3 AND P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE YEAR(SALE_DATE)=2019 AND MONTH (SALE_DATE)>3) \n##SALE_DATE>=2019-01-01 AND SALE_DATE<=2019-03-31\nGROUP BY 1,2 ORDER BY PRODUCT_ID"
                    },
                    {
                        "username": "akashdubey2047",
                        "content": "SELECT p.product_id, product_name \\nFROM Product P INNER JOIN Sales S ON p.product_id=s.product_id \\nWHERE p.product_id NOT IN (SELECT product_id FROM Sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\') \\nGROUP BY p.product_id,product_name;"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Product_id,Product_name from Product where Product_id in (select Product_id from Sales Group by product_id having Min(sale_date)>=\\'2019-01-01\\' and Max(Sale_date)<=\\'2019-03-31\\');"
                    },
                    {
                        "username": "ShubhayanS",
                        "content": "\\n`select product_id, product_name from Product \\nwhere product_id in\\n(select product_id  from Sales\\ngroup by 1\\nhaving max(year(sale_date)) = 2019 and max(month(sale_date)) <=3)`[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH SPRING_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\n), OTHER_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\' \\n)\\nSELECT \\n    DISTINCT P.PRODUCT_ID AS product_id, \\n    P.PRODUCT_NAME AS product_name \\nFROM \\n    PRODUCT P JOIN SPRING_SALES S \\nON \\n    P.PRODUCT_ID = S.PRODUCT_ID\\nAND \\n    P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM OTHER_SALES);\\n\\n\\n-- Why this is not working?"
                    },
                    {
                        "username": "mahapatraabhishek04",
                        "content": "I am not able to figure out why the below query is giving wrong output on submitting even though it worked when I clicked Run. Can anyone please help.\\nI am using MS SQL Server to run the below code.\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date between cast(\\'2019-01-01\\' as date) and cast(\\'2019-03-31\\' as date)\\nexcept\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date > cast(\\'2019-03-31\\' as date)"
                    },
                    {
                        "username": "user2708Pa",
                        "content": "I am at lost here. When I run my code, I get the correct answer, but then when I click submit, I get a different output and it\\'s marked as wrong. \\nAny idea what\\'s happening?"
                    },
                    {
                        "username": "vamsivankuri",
                        "content": ";with cte as\\n(\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) >cast(\\'2019-03-31\\' as date)\\nunion\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) <cast(\\'2019-01-01\\' as date)\\n), cte1 as\\n(\\nselect p.product_id, p.product_name\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere p.product_id not in (select product_id from cte)\\n)\\nselect * from cte1"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "I am including all criteria and still this won\\'t run on test case second - \\n`select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')`"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT product.product_id, product_name \\n FROM Product INNER JOIN Sales\\n ON Product.product_id=Sales.product_id\\n WHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nWhy  it is not showing the correct output?\\n "
                    },
                    {
                        "username": "tianxuzang",
                        "content": "Sale table has no primary key, it can have repeated rows.\\nthat is why need to use group by to avoid the duplicate row issue "
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "It does not take into account products that were sold both within the date range and outside the date range."
                    }
                ]
            },
            {
                "id": 1760202,
                "content": [
                    {
                        "username": "adityachatterjee",
                        "content": "Why would the below query not work? Not considering the performance here. Only from solution correctness standpoint.\n\nSELECT P.product_id,P.product_name\nFROM\nSALES S\nLEFT JOIN\n(SELECT DISTINCT * FROM PRODUCT) P\nON\nS.PRODUCT_ID=P.PRODUCT_ID\nWHERE YEAR(SALE_DATE)=2019 AND MONTH(SALE_DATE)<=3 AND P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE YEAR(SALE_DATE)=2019 AND MONTH (SALE_DATE)>3) \n##SALE_DATE>=2019-01-01 AND SALE_DATE<=2019-03-31\nGROUP BY 1,2 ORDER BY PRODUCT_ID"
                    },
                    {
                        "username": "akashdubey2047",
                        "content": "SELECT p.product_id, product_name \\nFROM Product P INNER JOIN Sales S ON p.product_id=s.product_id \\nWHERE p.product_id NOT IN (SELECT product_id FROM Sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\') \\nGROUP BY p.product_id,product_name;"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Product_id,Product_name from Product where Product_id in (select Product_id from Sales Group by product_id having Min(sale_date)>=\\'2019-01-01\\' and Max(Sale_date)<=\\'2019-03-31\\');"
                    },
                    {
                        "username": "ShubhayanS",
                        "content": "\\n`select product_id, product_name from Product \\nwhere product_id in\\n(select product_id  from Sales\\ngroup by 1\\nhaving max(year(sale_date)) = 2019 and max(month(sale_date)) <=3)`[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH SPRING_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\n), OTHER_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\' \\n)\\nSELECT \\n    DISTINCT P.PRODUCT_ID AS product_id, \\n    P.PRODUCT_NAME AS product_name \\nFROM \\n    PRODUCT P JOIN SPRING_SALES S \\nON \\n    P.PRODUCT_ID = S.PRODUCT_ID\\nAND \\n    P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM OTHER_SALES);\\n\\n\\n-- Why this is not working?"
                    },
                    {
                        "username": "mahapatraabhishek04",
                        "content": "I am not able to figure out why the below query is giving wrong output on submitting even though it worked when I clicked Run. Can anyone please help.\\nI am using MS SQL Server to run the below code.\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date between cast(\\'2019-01-01\\' as date) and cast(\\'2019-03-31\\' as date)\\nexcept\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date > cast(\\'2019-03-31\\' as date)"
                    },
                    {
                        "username": "user2708Pa",
                        "content": "I am at lost here. When I run my code, I get the correct answer, but then when I click submit, I get a different output and it\\'s marked as wrong. \\nAny idea what\\'s happening?"
                    },
                    {
                        "username": "vamsivankuri",
                        "content": ";with cte as\\n(\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) >cast(\\'2019-03-31\\' as date)\\nunion\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) <cast(\\'2019-01-01\\' as date)\\n), cte1 as\\n(\\nselect p.product_id, p.product_name\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere p.product_id not in (select product_id from cte)\\n)\\nselect * from cte1"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "I am including all criteria and still this won\\'t run on test case second - \\n`select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')`"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT product.product_id, product_name \\n FROM Product INNER JOIN Sales\\n ON Product.product_id=Sales.product_id\\n WHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nWhy  it is not showing the correct output?\\n "
                    },
                    {
                        "username": "tianxuzang",
                        "content": "Sale table has no primary key, it can have repeated rows.\\nthat is why need to use group by to avoid the duplicate row issue "
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "It does not take into account products that were sold both within the date range and outside the date range."
                    }
                ]
            },
            {
                "id": 1755772,
                "content": [
                    {
                        "username": "adityachatterjee",
                        "content": "Why would the below query not work? Not considering the performance here. Only from solution correctness standpoint.\n\nSELECT P.product_id,P.product_name\nFROM\nSALES S\nLEFT JOIN\n(SELECT DISTINCT * FROM PRODUCT) P\nON\nS.PRODUCT_ID=P.PRODUCT_ID\nWHERE YEAR(SALE_DATE)=2019 AND MONTH(SALE_DATE)<=3 AND P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE YEAR(SALE_DATE)=2019 AND MONTH (SALE_DATE)>3) \n##SALE_DATE>=2019-01-01 AND SALE_DATE<=2019-03-31\nGROUP BY 1,2 ORDER BY PRODUCT_ID"
                    },
                    {
                        "username": "akashdubey2047",
                        "content": "SELECT p.product_id, product_name \\nFROM Product P INNER JOIN Sales S ON p.product_id=s.product_id \\nWHERE p.product_id NOT IN (SELECT product_id FROM Sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\') \\nGROUP BY p.product_id,product_name;"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Product_id,Product_name from Product where Product_id in (select Product_id from Sales Group by product_id having Min(sale_date)>=\\'2019-01-01\\' and Max(Sale_date)<=\\'2019-03-31\\');"
                    },
                    {
                        "username": "ShubhayanS",
                        "content": "\\n`select product_id, product_name from Product \\nwhere product_id in\\n(select product_id  from Sales\\ngroup by 1\\nhaving max(year(sale_date)) = 2019 and max(month(sale_date)) <=3)`[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH SPRING_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\n), OTHER_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\' \\n)\\nSELECT \\n    DISTINCT P.PRODUCT_ID AS product_id, \\n    P.PRODUCT_NAME AS product_name \\nFROM \\n    PRODUCT P JOIN SPRING_SALES S \\nON \\n    P.PRODUCT_ID = S.PRODUCT_ID\\nAND \\n    P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM OTHER_SALES);\\n\\n\\n-- Why this is not working?"
                    },
                    {
                        "username": "mahapatraabhishek04",
                        "content": "I am not able to figure out why the below query is giving wrong output on submitting even though it worked when I clicked Run. Can anyone please help.\\nI am using MS SQL Server to run the below code.\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date between cast(\\'2019-01-01\\' as date) and cast(\\'2019-03-31\\' as date)\\nexcept\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date > cast(\\'2019-03-31\\' as date)"
                    },
                    {
                        "username": "user2708Pa",
                        "content": "I am at lost here. When I run my code, I get the correct answer, but then when I click submit, I get a different output and it\\'s marked as wrong. \\nAny idea what\\'s happening?"
                    },
                    {
                        "username": "vamsivankuri",
                        "content": ";with cte as\\n(\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) >cast(\\'2019-03-31\\' as date)\\nunion\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) <cast(\\'2019-01-01\\' as date)\\n), cte1 as\\n(\\nselect p.product_id, p.product_name\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere p.product_id not in (select product_id from cte)\\n)\\nselect * from cte1"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "I am including all criteria and still this won\\'t run on test case second - \\n`select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')`"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT product.product_id, product_name \\n FROM Product INNER JOIN Sales\\n ON Product.product_id=Sales.product_id\\n WHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nWhy  it is not showing the correct output?\\n "
                    },
                    {
                        "username": "tianxuzang",
                        "content": "Sale table has no primary key, it can have repeated rows.\\nthat is why need to use group by to avoid the duplicate row issue "
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "It does not take into account products that were sold both within the date range and outside the date range."
                    }
                ]
            },
            {
                "id": 1752891,
                "content": [
                    {
                        "username": "adityachatterjee",
                        "content": "Why would the below query not work? Not considering the performance here. Only from solution correctness standpoint.\n\nSELECT P.product_id,P.product_name\nFROM\nSALES S\nLEFT JOIN\n(SELECT DISTINCT * FROM PRODUCT) P\nON\nS.PRODUCT_ID=P.PRODUCT_ID\nWHERE YEAR(SALE_DATE)=2019 AND MONTH(SALE_DATE)<=3 AND P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE YEAR(SALE_DATE)=2019 AND MONTH (SALE_DATE)>3) \n##SALE_DATE>=2019-01-01 AND SALE_DATE<=2019-03-31\nGROUP BY 1,2 ORDER BY PRODUCT_ID"
                    },
                    {
                        "username": "akashdubey2047",
                        "content": "SELECT p.product_id, product_name \\nFROM Product P INNER JOIN Sales S ON p.product_id=s.product_id \\nWHERE p.product_id NOT IN (SELECT product_id FROM Sales WHERE sale_date NOT BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\') \\nGROUP BY p.product_id,product_name;"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "Select Product_id,Product_name from Product where Product_id in (select Product_id from Sales Group by product_id having Min(sale_date)>=\\'2019-01-01\\' and Max(Sale_date)<=\\'2019-03-31\\');"
                    },
                    {
                        "username": "ShubhayanS",
                        "content": "\\n`select product_id, product_name from Product \\nwhere product_id in\\n(select product_id  from Sales\\ngroup by 1\\nhaving max(year(sale_date)) = 2019 and max(month(sale_date)) <=3)`[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "WITH SPRING_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\' \\n), OTHER_SALES AS (\\n    SELECT * FROM SALES WHERE SALE_DATE BETWEEN \\'2019-04-01\\' AND \\'2019-12-31\\' \\n)\\nSELECT \\n    DISTINCT P.PRODUCT_ID AS product_id, \\n    P.PRODUCT_NAME AS product_name \\nFROM \\n    PRODUCT P JOIN SPRING_SALES S \\nON \\n    P.PRODUCT_ID = S.PRODUCT_ID\\nAND \\n    P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM OTHER_SALES);\\n\\n\\n-- Why this is not working?"
                    },
                    {
                        "username": "mahapatraabhishek04",
                        "content": "I am not able to figure out why the below query is giving wrong output on submitting even though it worked when I clicked Run. Can anyone please help.\\nI am using MS SQL Server to run the below code.\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date between cast(\\'2019-01-01\\' as date) and cast(\\'2019-03-31\\' as date)\\nexcept\\nselect product.product_id , product.product_name\\nfrom Product\\ninner join Sales\\non Product.product_id = Sales.product_id\\nwhere sale_date > cast(\\'2019-03-31\\' as date)"
                    },
                    {
                        "username": "user2708Pa",
                        "content": "I am at lost here. When I run my code, I get the correct answer, but then when I click submit, I get a different output and it\\'s marked as wrong. \\nAny idea what\\'s happening?"
                    },
                    {
                        "username": "vamsivankuri",
                        "content": ";with cte as\\n(\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) >cast(\\'2019-03-31\\' as date)\\nunion\\nselect p.product_id, p.product_name, sale_date\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere cast(sale_date as date) <cast(\\'2019-01-01\\' as date)\\n), cte1 as\\n(\\nselect p.product_id, p.product_name\\nfrom Product p \\njoin Sales s on p.product_id=s.product_id\\nwhere p.product_id not in (select product_id from cte)\\n)\\nselect * from cte1"
                    },
                    {
                        "username": "Hanisha_DUa",
                        "content": "I am including all criteria and still this won\\'t run on test case second - \\n`select s.product_id , p.product_name\\nfrom sales s\\njoin product p\\non p.product_id=s.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' and \\ns.product_id not in \\n(select product_id from sales\\nwhere sale_date between \\'2019-04-01\\' and \\'2019-12-31\\')`"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT product.product_id, product_name \\n FROM Product INNER JOIN Sales\\n ON Product.product_id=Sales.product_id\\n WHERE sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nWhy  it is not showing the correct output?\\n "
                    },
                    {
                        "username": "tianxuzang",
                        "content": "Sale table has no primary key, it can have repeated rows.\\nthat is why need to use group by to avoid the duplicate row issue "
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "It does not take into account products that were sold both within the date range and outside the date range."
                    }
                ]
            },
            {
                "id": 1746950,
                "content": [
                    {
                        "username": "anuradhanda4498",
                        "content": "What is wrong in this ?\\nSELECT p.product_id , p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND\\np.product_id NOT IN(\\n    SELECT DISTINCT product_id \\n    FROM Sales\\n    WHERE sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\')"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "use SELECT DISTINCT p.product_id , p.product_name ..."
                    },
                    {
                        "username": "weebhav",
                        "content": "Can someone please explain me why is this not the right solution?\\n\\nselect product_id , product_name from product where product_id not in\\n(select product_id from sales where sale_date  between (2019-04-01) and (2019-12-31));"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "Too many mistakes...\\nWrong date range, wrong date literals, etc...\\nAdded additional condition and fix errors:\\n```sql\\nselect product_id , product_name from product \\nwhere product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\nand product_id in (select product_id from sales where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "Rahmatul_Akbar",
                        "content": "MySQL\\nselect sub.product_id,sub.product_name\\nfrom\\n(select p.product_id,p.product_name,s.sale_date\\nfrom product p\\njoin sales s\\non p.product_id=s.product_id\\ngroup by 1) sub\\nwhere sub.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\nand sub.product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\' )"
                    },
                    {
                        "username": "yunjinchoidev",
                        "content": "select \\ns.product_id, \\np.product_name\\nfrom Product as p\\ninner join Sales as s on s.product_id = p.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand (select max(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) <= \\'2019-03-31\\'\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\ngroup by s.product_id, p.product_id, p.product_name\\n\\n\\n\\ni think below where query is too Of course.\\nbecause this table is 2019 data. \\nam i wrong ? \\n\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\n"
                    },
                    {
                        "username": "surbhisinggh",
                        "content": "why this query satement is wrong \\n\\nSelect Product.product_id, product_name, sale_date from Product left join Sales On Sales.product_id = Product.product_id where year(sale_date)=2019 And Month(sale_date) IN (1,2,3) ;"
                    },
                    {
                        "username": "aleliszt",
                        "content": "This query doesn\\'t exclude the product_ids that were also sold outside of the first quarter. For example  the product_name = G4  was sold in Q1 ( 2019-02-17) but  sold in 2019-06-02 too, then G4 shouldn\\'t be in the final output"
                    },
                    {
                        "username": "Yi-LingT",
                        "content": "SELECT product_id ,product_name\\nFROM Product \\nWHERE  product_id IN \\n(SELECT   product_id\\nFROM Sales\\nWHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\'\\n) WHY THIS IS WRONG?\\uD83D\\uDE2B\\n\\n\\nWHEN I CHANGE TO \\nWHERE sale_date > \\'2019-03-31\\' OR  sale_date < \\'2019-01-01\\' )\\nTHEN IT IS CORRECT?"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": "\"MOST USEFULL\"\n `select product_id,product_name from product p1\nwhere (select count(*) from Sales s1 where sale_date between \"2019-01-01\" and \"2019-03-31\" and s1.product_id=p1.product_id) = (select count(*) from Sales s3 where s3.product_id=p1.product_id) and product_id in (select product_id from Sales)\n`"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select product_id , product_name \\nfrom Product \\nwhere product_id in (select product_id \\n                     from Sales \\n                     where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\n                     And product_id not in (select product_id \\n                                            from Sales \\n                                            where sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\'))"
                    },
                    {
                        "username": "Vandana_KH",
                        "content": "I think the product G4 should be there in the output, I am not understanding why it is not included? Can anyone help me in this. Thanks  "
                    },
                    {
                        "username": "iamhassaan",
                        "content": "Any idea why I am getting this error ?\\n\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'abc\\n#  select product_id from Sales where month(sale_date) not in (1,2,3) \\n# s\\' at line 6\\n\\n\\n`\\n# Write your MySQL query statement below\\n\\nselect s.product_id , p.product_name from Sales s\\njoin product p on p.product_id = s.product_id \\nwhere sale_date between (\\'2019-01-01\\' and \\'2019-03-31\\')\\nand s.product_id not in (select abc.product_id from Sales where month(sale_date) not in (1,2,3)) abc\\n\\n`"
                    }
                ]
            },
            {
                "id": 1746913,
                "content": [
                    {
                        "username": "anuradhanda4498",
                        "content": "What is wrong in this ?\\nSELECT p.product_id , p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND\\np.product_id NOT IN(\\n    SELECT DISTINCT product_id \\n    FROM Sales\\n    WHERE sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\')"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "use SELECT DISTINCT p.product_id , p.product_name ..."
                    },
                    {
                        "username": "weebhav",
                        "content": "Can someone please explain me why is this not the right solution?\\n\\nselect product_id , product_name from product where product_id not in\\n(select product_id from sales where sale_date  between (2019-04-01) and (2019-12-31));"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "Too many mistakes...\\nWrong date range, wrong date literals, etc...\\nAdded additional condition and fix errors:\\n```sql\\nselect product_id , product_name from product \\nwhere product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\nand product_id in (select product_id from sales where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "Rahmatul_Akbar",
                        "content": "MySQL\\nselect sub.product_id,sub.product_name\\nfrom\\n(select p.product_id,p.product_name,s.sale_date\\nfrom product p\\njoin sales s\\non p.product_id=s.product_id\\ngroup by 1) sub\\nwhere sub.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\nand sub.product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\' )"
                    },
                    {
                        "username": "yunjinchoidev",
                        "content": "select \\ns.product_id, \\np.product_name\\nfrom Product as p\\ninner join Sales as s on s.product_id = p.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand (select max(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) <= \\'2019-03-31\\'\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\ngroup by s.product_id, p.product_id, p.product_name\\n\\n\\n\\ni think below where query is too Of course.\\nbecause this table is 2019 data. \\nam i wrong ? \\n\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\n"
                    },
                    {
                        "username": "surbhisinggh",
                        "content": "why this query satement is wrong \\n\\nSelect Product.product_id, product_name, sale_date from Product left join Sales On Sales.product_id = Product.product_id where year(sale_date)=2019 And Month(sale_date) IN (1,2,3) ;"
                    },
                    {
                        "username": "aleliszt",
                        "content": "This query doesn\\'t exclude the product_ids that were also sold outside of the first quarter. For example  the product_name = G4  was sold in Q1 ( 2019-02-17) but  sold in 2019-06-02 too, then G4 shouldn\\'t be in the final output"
                    },
                    {
                        "username": "Yi-LingT",
                        "content": "SELECT product_id ,product_name\\nFROM Product \\nWHERE  product_id IN \\n(SELECT   product_id\\nFROM Sales\\nWHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\'\\n) WHY THIS IS WRONG?\\uD83D\\uDE2B\\n\\n\\nWHEN I CHANGE TO \\nWHERE sale_date > \\'2019-03-31\\' OR  sale_date < \\'2019-01-01\\' )\\nTHEN IT IS CORRECT?"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": "\"MOST USEFULL\"\n `select product_id,product_name from product p1\nwhere (select count(*) from Sales s1 where sale_date between \"2019-01-01\" and \"2019-03-31\" and s1.product_id=p1.product_id) = (select count(*) from Sales s3 where s3.product_id=p1.product_id) and product_id in (select product_id from Sales)\n`"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select product_id , product_name \\nfrom Product \\nwhere product_id in (select product_id \\n                     from Sales \\n                     where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\n                     And product_id not in (select product_id \\n                                            from Sales \\n                                            where sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\'))"
                    },
                    {
                        "username": "Vandana_KH",
                        "content": "I think the product G4 should be there in the output, I am not understanding why it is not included? Can anyone help me in this. Thanks  "
                    },
                    {
                        "username": "iamhassaan",
                        "content": "Any idea why I am getting this error ?\\n\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'abc\\n#  select product_id from Sales where month(sale_date) not in (1,2,3) \\n# s\\' at line 6\\n\\n\\n`\\n# Write your MySQL query statement below\\n\\nselect s.product_id , p.product_name from Sales s\\njoin product p on p.product_id = s.product_id \\nwhere sale_date between (\\'2019-01-01\\' and \\'2019-03-31\\')\\nand s.product_id not in (select abc.product_id from Sales where month(sale_date) not in (1,2,3)) abc\\n\\n`"
                    }
                ]
            },
            {
                "id": 1738334,
                "content": [
                    {
                        "username": "anuradhanda4498",
                        "content": "What is wrong in this ?\\nSELECT p.product_id , p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND\\np.product_id NOT IN(\\n    SELECT DISTINCT product_id \\n    FROM Sales\\n    WHERE sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\')"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "use SELECT DISTINCT p.product_id , p.product_name ..."
                    },
                    {
                        "username": "weebhav",
                        "content": "Can someone please explain me why is this not the right solution?\\n\\nselect product_id , product_name from product where product_id not in\\n(select product_id from sales where sale_date  between (2019-04-01) and (2019-12-31));"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "Too many mistakes...\\nWrong date range, wrong date literals, etc...\\nAdded additional condition and fix errors:\\n```sql\\nselect product_id , product_name from product \\nwhere product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\nand product_id in (select product_id from sales where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "Rahmatul_Akbar",
                        "content": "MySQL\\nselect sub.product_id,sub.product_name\\nfrom\\n(select p.product_id,p.product_name,s.sale_date\\nfrom product p\\njoin sales s\\non p.product_id=s.product_id\\ngroup by 1) sub\\nwhere sub.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\nand sub.product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\' )"
                    },
                    {
                        "username": "yunjinchoidev",
                        "content": "select \\ns.product_id, \\np.product_name\\nfrom Product as p\\ninner join Sales as s on s.product_id = p.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand (select max(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) <= \\'2019-03-31\\'\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\ngroup by s.product_id, p.product_id, p.product_name\\n\\n\\n\\ni think below where query is too Of course.\\nbecause this table is 2019 data. \\nam i wrong ? \\n\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\n"
                    },
                    {
                        "username": "surbhisinggh",
                        "content": "why this query satement is wrong \\n\\nSelect Product.product_id, product_name, sale_date from Product left join Sales On Sales.product_id = Product.product_id where year(sale_date)=2019 And Month(sale_date) IN (1,2,3) ;"
                    },
                    {
                        "username": "aleliszt",
                        "content": "This query doesn\\'t exclude the product_ids that were also sold outside of the first quarter. For example  the product_name = G4  was sold in Q1 ( 2019-02-17) but  sold in 2019-06-02 too, then G4 shouldn\\'t be in the final output"
                    },
                    {
                        "username": "Yi-LingT",
                        "content": "SELECT product_id ,product_name\\nFROM Product \\nWHERE  product_id IN \\n(SELECT   product_id\\nFROM Sales\\nWHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\'\\n) WHY THIS IS WRONG?\\uD83D\\uDE2B\\n\\n\\nWHEN I CHANGE TO \\nWHERE sale_date > \\'2019-03-31\\' OR  sale_date < \\'2019-01-01\\' )\\nTHEN IT IS CORRECT?"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": "\"MOST USEFULL\"\n `select product_id,product_name from product p1\nwhere (select count(*) from Sales s1 where sale_date between \"2019-01-01\" and \"2019-03-31\" and s1.product_id=p1.product_id) = (select count(*) from Sales s3 where s3.product_id=p1.product_id) and product_id in (select product_id from Sales)\n`"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select product_id , product_name \\nfrom Product \\nwhere product_id in (select product_id \\n                     from Sales \\n                     where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\n                     And product_id not in (select product_id \\n                                            from Sales \\n                                            where sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\'))"
                    },
                    {
                        "username": "Vandana_KH",
                        "content": "I think the product G4 should be there in the output, I am not understanding why it is not included? Can anyone help me in this. Thanks  "
                    },
                    {
                        "username": "iamhassaan",
                        "content": "Any idea why I am getting this error ?\\n\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'abc\\n#  select product_id from Sales where month(sale_date) not in (1,2,3) \\n# s\\' at line 6\\n\\n\\n`\\n# Write your MySQL query statement below\\n\\nselect s.product_id , p.product_name from Sales s\\njoin product p on p.product_id = s.product_id \\nwhere sale_date between (\\'2019-01-01\\' and \\'2019-03-31\\')\\nand s.product_id not in (select abc.product_id from Sales where month(sale_date) not in (1,2,3)) abc\\n\\n`"
                    }
                ]
            },
            {
                "id": 1733027,
                "content": [
                    {
                        "username": "anuradhanda4498",
                        "content": "What is wrong in this ?\\nSELECT p.product_id , p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND\\np.product_id NOT IN(\\n    SELECT DISTINCT product_id \\n    FROM Sales\\n    WHERE sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\')"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "use SELECT DISTINCT p.product_id , p.product_name ..."
                    },
                    {
                        "username": "weebhav",
                        "content": "Can someone please explain me why is this not the right solution?\\n\\nselect product_id , product_name from product where product_id not in\\n(select product_id from sales where sale_date  between (2019-04-01) and (2019-12-31));"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "Too many mistakes...\\nWrong date range, wrong date literals, etc...\\nAdded additional condition and fix errors:\\n```sql\\nselect product_id , product_name from product \\nwhere product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\nand product_id in (select product_id from sales where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "Rahmatul_Akbar",
                        "content": "MySQL\\nselect sub.product_id,sub.product_name\\nfrom\\n(select p.product_id,p.product_name,s.sale_date\\nfrom product p\\njoin sales s\\non p.product_id=s.product_id\\ngroup by 1) sub\\nwhere sub.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\nand sub.product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\' )"
                    },
                    {
                        "username": "yunjinchoidev",
                        "content": "select \\ns.product_id, \\np.product_name\\nfrom Product as p\\ninner join Sales as s on s.product_id = p.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand (select max(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) <= \\'2019-03-31\\'\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\ngroup by s.product_id, p.product_id, p.product_name\\n\\n\\n\\ni think below where query is too Of course.\\nbecause this table is 2019 data. \\nam i wrong ? \\n\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\n"
                    },
                    {
                        "username": "surbhisinggh",
                        "content": "why this query satement is wrong \\n\\nSelect Product.product_id, product_name, sale_date from Product left join Sales On Sales.product_id = Product.product_id where year(sale_date)=2019 And Month(sale_date) IN (1,2,3) ;"
                    },
                    {
                        "username": "aleliszt",
                        "content": "This query doesn\\'t exclude the product_ids that were also sold outside of the first quarter. For example  the product_name = G4  was sold in Q1 ( 2019-02-17) but  sold in 2019-06-02 too, then G4 shouldn\\'t be in the final output"
                    },
                    {
                        "username": "Yi-LingT",
                        "content": "SELECT product_id ,product_name\\nFROM Product \\nWHERE  product_id IN \\n(SELECT   product_id\\nFROM Sales\\nWHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\'\\n) WHY THIS IS WRONG?\\uD83D\\uDE2B\\n\\n\\nWHEN I CHANGE TO \\nWHERE sale_date > \\'2019-03-31\\' OR  sale_date < \\'2019-01-01\\' )\\nTHEN IT IS CORRECT?"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": "\"MOST USEFULL\"\n `select product_id,product_name from product p1\nwhere (select count(*) from Sales s1 where sale_date between \"2019-01-01\" and \"2019-03-31\" and s1.product_id=p1.product_id) = (select count(*) from Sales s3 where s3.product_id=p1.product_id) and product_id in (select product_id from Sales)\n`"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select product_id , product_name \\nfrom Product \\nwhere product_id in (select product_id \\n                     from Sales \\n                     where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\n                     And product_id not in (select product_id \\n                                            from Sales \\n                                            where sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\'))"
                    },
                    {
                        "username": "Vandana_KH",
                        "content": "I think the product G4 should be there in the output, I am not understanding why it is not included? Can anyone help me in this. Thanks  "
                    },
                    {
                        "username": "iamhassaan",
                        "content": "Any idea why I am getting this error ?\\n\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'abc\\n#  select product_id from Sales where month(sale_date) not in (1,2,3) \\n# s\\' at line 6\\n\\n\\n`\\n# Write your MySQL query statement below\\n\\nselect s.product_id , p.product_name from Sales s\\njoin product p on p.product_id = s.product_id \\nwhere sale_date between (\\'2019-01-01\\' and \\'2019-03-31\\')\\nand s.product_id not in (select abc.product_id from Sales where month(sale_date) not in (1,2,3)) abc\\n\\n`"
                    }
                ]
            },
            {
                "id": 1709750,
                "content": [
                    {
                        "username": "anuradhanda4498",
                        "content": "What is wrong in this ?\\nSELECT p.product_id , p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND\\np.product_id NOT IN(\\n    SELECT DISTINCT product_id \\n    FROM Sales\\n    WHERE sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\')"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "use SELECT DISTINCT p.product_id , p.product_name ..."
                    },
                    {
                        "username": "weebhav",
                        "content": "Can someone please explain me why is this not the right solution?\\n\\nselect product_id , product_name from product where product_id not in\\n(select product_id from sales where sale_date  between (2019-04-01) and (2019-12-31));"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "Too many mistakes...\\nWrong date range, wrong date literals, etc...\\nAdded additional condition and fix errors:\\n```sql\\nselect product_id , product_name from product \\nwhere product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\nand product_id in (select product_id from sales where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "Rahmatul_Akbar",
                        "content": "MySQL\\nselect sub.product_id,sub.product_name\\nfrom\\n(select p.product_id,p.product_name,s.sale_date\\nfrom product p\\njoin sales s\\non p.product_id=s.product_id\\ngroup by 1) sub\\nwhere sub.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\nand sub.product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\' )"
                    },
                    {
                        "username": "yunjinchoidev",
                        "content": "select \\ns.product_id, \\np.product_name\\nfrom Product as p\\ninner join Sales as s on s.product_id = p.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand (select max(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) <= \\'2019-03-31\\'\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\ngroup by s.product_id, p.product_id, p.product_name\\n\\n\\n\\ni think below where query is too Of course.\\nbecause this table is 2019 data. \\nam i wrong ? \\n\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\n"
                    },
                    {
                        "username": "surbhisinggh",
                        "content": "why this query satement is wrong \\n\\nSelect Product.product_id, product_name, sale_date from Product left join Sales On Sales.product_id = Product.product_id where year(sale_date)=2019 And Month(sale_date) IN (1,2,3) ;"
                    },
                    {
                        "username": "aleliszt",
                        "content": "This query doesn\\'t exclude the product_ids that were also sold outside of the first quarter. For example  the product_name = G4  was sold in Q1 ( 2019-02-17) but  sold in 2019-06-02 too, then G4 shouldn\\'t be in the final output"
                    },
                    {
                        "username": "Yi-LingT",
                        "content": "SELECT product_id ,product_name\\nFROM Product \\nWHERE  product_id IN \\n(SELECT   product_id\\nFROM Sales\\nWHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\'\\n) WHY THIS IS WRONG?\\uD83D\\uDE2B\\n\\n\\nWHEN I CHANGE TO \\nWHERE sale_date > \\'2019-03-31\\' OR  sale_date < \\'2019-01-01\\' )\\nTHEN IT IS CORRECT?"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": "\"MOST USEFULL\"\n `select product_id,product_name from product p1\nwhere (select count(*) from Sales s1 where sale_date between \"2019-01-01\" and \"2019-03-31\" and s1.product_id=p1.product_id) = (select count(*) from Sales s3 where s3.product_id=p1.product_id) and product_id in (select product_id from Sales)\n`"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select product_id , product_name \\nfrom Product \\nwhere product_id in (select product_id \\n                     from Sales \\n                     where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\n                     And product_id not in (select product_id \\n                                            from Sales \\n                                            where sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\'))"
                    },
                    {
                        "username": "Vandana_KH",
                        "content": "I think the product G4 should be there in the output, I am not understanding why it is not included? Can anyone help me in this. Thanks  "
                    },
                    {
                        "username": "iamhassaan",
                        "content": "Any idea why I am getting this error ?\\n\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'abc\\n#  select product_id from Sales where month(sale_date) not in (1,2,3) \\n# s\\' at line 6\\n\\n\\n`\\n# Write your MySQL query statement below\\n\\nselect s.product_id , p.product_name from Sales s\\njoin product p on p.product_id = s.product_id \\nwhere sale_date between (\\'2019-01-01\\' and \\'2019-03-31\\')\\nand s.product_id not in (select abc.product_id from Sales where month(sale_date) not in (1,2,3)) abc\\n\\n`"
                    }
                ]
            },
            {
                "id": 1708776,
                "content": [
                    {
                        "username": "anuradhanda4498",
                        "content": "What is wrong in this ?\\nSELECT p.product_id , p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND\\np.product_id NOT IN(\\n    SELECT DISTINCT product_id \\n    FROM Sales\\n    WHERE sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\')"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "use SELECT DISTINCT p.product_id , p.product_name ..."
                    },
                    {
                        "username": "weebhav",
                        "content": "Can someone please explain me why is this not the right solution?\\n\\nselect product_id , product_name from product where product_id not in\\n(select product_id from sales where sale_date  between (2019-04-01) and (2019-12-31));"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "Too many mistakes...\\nWrong date range, wrong date literals, etc...\\nAdded additional condition and fix errors:\\n```sql\\nselect product_id , product_name from product \\nwhere product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\nand product_id in (select product_id from sales where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "Rahmatul_Akbar",
                        "content": "MySQL\\nselect sub.product_id,sub.product_name\\nfrom\\n(select p.product_id,p.product_name,s.sale_date\\nfrom product p\\njoin sales s\\non p.product_id=s.product_id\\ngroup by 1) sub\\nwhere sub.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\nand sub.product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\' )"
                    },
                    {
                        "username": "yunjinchoidev",
                        "content": "select \\ns.product_id, \\np.product_name\\nfrom Product as p\\ninner join Sales as s on s.product_id = p.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand (select max(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) <= \\'2019-03-31\\'\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\ngroup by s.product_id, p.product_id, p.product_name\\n\\n\\n\\ni think below where query is too Of course.\\nbecause this table is 2019 data. \\nam i wrong ? \\n\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\n"
                    },
                    {
                        "username": "surbhisinggh",
                        "content": "why this query satement is wrong \\n\\nSelect Product.product_id, product_name, sale_date from Product left join Sales On Sales.product_id = Product.product_id where year(sale_date)=2019 And Month(sale_date) IN (1,2,3) ;"
                    },
                    {
                        "username": "aleliszt",
                        "content": "This query doesn\\'t exclude the product_ids that were also sold outside of the first quarter. For example  the product_name = G4  was sold in Q1 ( 2019-02-17) but  sold in 2019-06-02 too, then G4 shouldn\\'t be in the final output"
                    },
                    {
                        "username": "Yi-LingT",
                        "content": "SELECT product_id ,product_name\\nFROM Product \\nWHERE  product_id IN \\n(SELECT   product_id\\nFROM Sales\\nWHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\'\\n) WHY THIS IS WRONG?\\uD83D\\uDE2B\\n\\n\\nWHEN I CHANGE TO \\nWHERE sale_date > \\'2019-03-31\\' OR  sale_date < \\'2019-01-01\\' )\\nTHEN IT IS CORRECT?"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": "\"MOST USEFULL\"\n `select product_id,product_name from product p1\nwhere (select count(*) from Sales s1 where sale_date between \"2019-01-01\" and \"2019-03-31\" and s1.product_id=p1.product_id) = (select count(*) from Sales s3 where s3.product_id=p1.product_id) and product_id in (select product_id from Sales)\n`"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select product_id , product_name \\nfrom Product \\nwhere product_id in (select product_id \\n                     from Sales \\n                     where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\n                     And product_id not in (select product_id \\n                                            from Sales \\n                                            where sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\'))"
                    },
                    {
                        "username": "Vandana_KH",
                        "content": "I think the product G4 should be there in the output, I am not understanding why it is not included? Can anyone help me in this. Thanks  "
                    },
                    {
                        "username": "iamhassaan",
                        "content": "Any idea why I am getting this error ?\\n\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'abc\\n#  select product_id from Sales where month(sale_date) not in (1,2,3) \\n# s\\' at line 6\\n\\n\\n`\\n# Write your MySQL query statement below\\n\\nselect s.product_id , p.product_name from Sales s\\njoin product p on p.product_id = s.product_id \\nwhere sale_date between (\\'2019-01-01\\' and \\'2019-03-31\\')\\nand s.product_id not in (select abc.product_id from Sales where month(sale_date) not in (1,2,3)) abc\\n\\n`"
                    }
                ]
            },
            {
                "id": 1708438,
                "content": [
                    {
                        "username": "anuradhanda4498",
                        "content": "What is wrong in this ?\\nSELECT p.product_id , p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND\\np.product_id NOT IN(\\n    SELECT DISTINCT product_id \\n    FROM Sales\\n    WHERE sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\')"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "use SELECT DISTINCT p.product_id , p.product_name ..."
                    },
                    {
                        "username": "weebhav",
                        "content": "Can someone please explain me why is this not the right solution?\\n\\nselect product_id , product_name from product where product_id not in\\n(select product_id from sales where sale_date  between (2019-04-01) and (2019-12-31));"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "Too many mistakes...\\nWrong date range, wrong date literals, etc...\\nAdded additional condition and fix errors:\\n```sql\\nselect product_id , product_name from product \\nwhere product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\nand product_id in (select product_id from sales where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "Rahmatul_Akbar",
                        "content": "MySQL\\nselect sub.product_id,sub.product_name\\nfrom\\n(select p.product_id,p.product_name,s.sale_date\\nfrom product p\\njoin sales s\\non p.product_id=s.product_id\\ngroup by 1) sub\\nwhere sub.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\nand sub.product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\' )"
                    },
                    {
                        "username": "yunjinchoidev",
                        "content": "select \\ns.product_id, \\np.product_name\\nfrom Product as p\\ninner join Sales as s on s.product_id = p.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand (select max(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) <= \\'2019-03-31\\'\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\ngroup by s.product_id, p.product_id, p.product_name\\n\\n\\n\\ni think below where query is too Of course.\\nbecause this table is 2019 data. \\nam i wrong ? \\n\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\n"
                    },
                    {
                        "username": "surbhisinggh",
                        "content": "why this query satement is wrong \\n\\nSelect Product.product_id, product_name, sale_date from Product left join Sales On Sales.product_id = Product.product_id where year(sale_date)=2019 And Month(sale_date) IN (1,2,3) ;"
                    },
                    {
                        "username": "aleliszt",
                        "content": "This query doesn\\'t exclude the product_ids that were also sold outside of the first quarter. For example  the product_name = G4  was sold in Q1 ( 2019-02-17) but  sold in 2019-06-02 too, then G4 shouldn\\'t be in the final output"
                    },
                    {
                        "username": "Yi-LingT",
                        "content": "SELECT product_id ,product_name\\nFROM Product \\nWHERE  product_id IN \\n(SELECT   product_id\\nFROM Sales\\nWHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\'\\n) WHY THIS IS WRONG?\\uD83D\\uDE2B\\n\\n\\nWHEN I CHANGE TO \\nWHERE sale_date > \\'2019-03-31\\' OR  sale_date < \\'2019-01-01\\' )\\nTHEN IT IS CORRECT?"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": "\"MOST USEFULL\"\n `select product_id,product_name from product p1\nwhere (select count(*) from Sales s1 where sale_date between \"2019-01-01\" and \"2019-03-31\" and s1.product_id=p1.product_id) = (select count(*) from Sales s3 where s3.product_id=p1.product_id) and product_id in (select product_id from Sales)\n`"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select product_id , product_name \\nfrom Product \\nwhere product_id in (select product_id \\n                     from Sales \\n                     where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\n                     And product_id not in (select product_id \\n                                            from Sales \\n                                            where sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\'))"
                    },
                    {
                        "username": "Vandana_KH",
                        "content": "I think the product G4 should be there in the output, I am not understanding why it is not included? Can anyone help me in this. Thanks  "
                    },
                    {
                        "username": "iamhassaan",
                        "content": "Any idea why I am getting this error ?\\n\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'abc\\n#  select product_id from Sales where month(sale_date) not in (1,2,3) \\n# s\\' at line 6\\n\\n\\n`\\n# Write your MySQL query statement below\\n\\nselect s.product_id , p.product_name from Sales s\\njoin product p on p.product_id = s.product_id \\nwhere sale_date between (\\'2019-01-01\\' and \\'2019-03-31\\')\\nand s.product_id not in (select abc.product_id from Sales where month(sale_date) not in (1,2,3)) abc\\n\\n`"
                    }
                ]
            },
            {
                "id": 1707456,
                "content": [
                    {
                        "username": "anuradhanda4498",
                        "content": "What is wrong in this ?\\nSELECT p.product_id , p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND\\np.product_id NOT IN(\\n    SELECT DISTINCT product_id \\n    FROM Sales\\n    WHERE sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\')"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "use SELECT DISTINCT p.product_id , p.product_name ..."
                    },
                    {
                        "username": "weebhav",
                        "content": "Can someone please explain me why is this not the right solution?\\n\\nselect product_id , product_name from product where product_id not in\\n(select product_id from sales where sale_date  between (2019-04-01) and (2019-12-31));"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "Too many mistakes...\\nWrong date range, wrong date literals, etc...\\nAdded additional condition and fix errors:\\n```sql\\nselect product_id , product_name from product \\nwhere product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\nand product_id in (select product_id from sales where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "Rahmatul_Akbar",
                        "content": "MySQL\\nselect sub.product_id,sub.product_name\\nfrom\\n(select p.product_id,p.product_name,s.sale_date\\nfrom product p\\njoin sales s\\non p.product_id=s.product_id\\ngroup by 1) sub\\nwhere sub.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\nand sub.product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\' )"
                    },
                    {
                        "username": "yunjinchoidev",
                        "content": "select \\ns.product_id, \\np.product_name\\nfrom Product as p\\ninner join Sales as s on s.product_id = p.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand (select max(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) <= \\'2019-03-31\\'\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\ngroup by s.product_id, p.product_id, p.product_name\\n\\n\\n\\ni think below where query is too Of course.\\nbecause this table is 2019 data. \\nam i wrong ? \\n\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\n"
                    },
                    {
                        "username": "surbhisinggh",
                        "content": "why this query satement is wrong \\n\\nSelect Product.product_id, product_name, sale_date from Product left join Sales On Sales.product_id = Product.product_id where year(sale_date)=2019 And Month(sale_date) IN (1,2,3) ;"
                    },
                    {
                        "username": "aleliszt",
                        "content": "This query doesn\\'t exclude the product_ids that were also sold outside of the first quarter. For example  the product_name = G4  was sold in Q1 ( 2019-02-17) but  sold in 2019-06-02 too, then G4 shouldn\\'t be in the final output"
                    },
                    {
                        "username": "Yi-LingT",
                        "content": "SELECT product_id ,product_name\\nFROM Product \\nWHERE  product_id IN \\n(SELECT   product_id\\nFROM Sales\\nWHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\'\\n) WHY THIS IS WRONG?\\uD83D\\uDE2B\\n\\n\\nWHEN I CHANGE TO \\nWHERE sale_date > \\'2019-03-31\\' OR  sale_date < \\'2019-01-01\\' )\\nTHEN IT IS CORRECT?"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": "\"MOST USEFULL\"\n `select product_id,product_name from product p1\nwhere (select count(*) from Sales s1 where sale_date between \"2019-01-01\" and \"2019-03-31\" and s1.product_id=p1.product_id) = (select count(*) from Sales s3 where s3.product_id=p1.product_id) and product_id in (select product_id from Sales)\n`"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select product_id , product_name \\nfrom Product \\nwhere product_id in (select product_id \\n                     from Sales \\n                     where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\n                     And product_id not in (select product_id \\n                                            from Sales \\n                                            where sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\'))"
                    },
                    {
                        "username": "Vandana_KH",
                        "content": "I think the product G4 should be there in the output, I am not understanding why it is not included? Can anyone help me in this. Thanks  "
                    },
                    {
                        "username": "iamhassaan",
                        "content": "Any idea why I am getting this error ?\\n\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'abc\\n#  select product_id from Sales where month(sale_date) not in (1,2,3) \\n# s\\' at line 6\\n\\n\\n`\\n# Write your MySQL query statement below\\n\\nselect s.product_id , p.product_name from Sales s\\njoin product p on p.product_id = s.product_id \\nwhere sale_date between (\\'2019-01-01\\' and \\'2019-03-31\\')\\nand s.product_id not in (select abc.product_id from Sales where month(sale_date) not in (1,2,3)) abc\\n\\n`"
                    }
                ]
            },
            {
                "id": 1699876,
                "content": [
                    {
                        "username": "anuradhanda4498",
                        "content": "What is wrong in this ?\\nSELECT p.product_id , p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND\\np.product_id NOT IN(\\n    SELECT DISTINCT product_id \\n    FROM Sales\\n    WHERE sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\')"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "use SELECT DISTINCT p.product_id , p.product_name ..."
                    },
                    {
                        "username": "weebhav",
                        "content": "Can someone please explain me why is this not the right solution?\\n\\nselect product_id , product_name from product where product_id not in\\n(select product_id from sales where sale_date  between (2019-04-01) and (2019-12-31));"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "Too many mistakes...\\nWrong date range, wrong date literals, etc...\\nAdded additional condition and fix errors:\\n```sql\\nselect product_id , product_name from product \\nwhere product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\nand product_id in (select product_id from sales where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "Rahmatul_Akbar",
                        "content": "MySQL\\nselect sub.product_id,sub.product_name\\nfrom\\n(select p.product_id,p.product_name,s.sale_date\\nfrom product p\\njoin sales s\\non p.product_id=s.product_id\\ngroup by 1) sub\\nwhere sub.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\nand sub.product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\' )"
                    },
                    {
                        "username": "yunjinchoidev",
                        "content": "select \\ns.product_id, \\np.product_name\\nfrom Product as p\\ninner join Sales as s on s.product_id = p.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand (select max(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) <= \\'2019-03-31\\'\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\ngroup by s.product_id, p.product_id, p.product_name\\n\\n\\n\\ni think below where query is too Of course.\\nbecause this table is 2019 data. \\nam i wrong ? \\n\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\n"
                    },
                    {
                        "username": "surbhisinggh",
                        "content": "why this query satement is wrong \\n\\nSelect Product.product_id, product_name, sale_date from Product left join Sales On Sales.product_id = Product.product_id where year(sale_date)=2019 And Month(sale_date) IN (1,2,3) ;"
                    },
                    {
                        "username": "aleliszt",
                        "content": "This query doesn\\'t exclude the product_ids that were also sold outside of the first quarter. For example  the product_name = G4  was sold in Q1 ( 2019-02-17) but  sold in 2019-06-02 too, then G4 shouldn\\'t be in the final output"
                    },
                    {
                        "username": "Yi-LingT",
                        "content": "SELECT product_id ,product_name\\nFROM Product \\nWHERE  product_id IN \\n(SELECT   product_id\\nFROM Sales\\nWHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\'\\n) WHY THIS IS WRONG?\\uD83D\\uDE2B\\n\\n\\nWHEN I CHANGE TO \\nWHERE sale_date > \\'2019-03-31\\' OR  sale_date < \\'2019-01-01\\' )\\nTHEN IT IS CORRECT?"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": "\"MOST USEFULL\"\n `select product_id,product_name from product p1\nwhere (select count(*) from Sales s1 where sale_date between \"2019-01-01\" and \"2019-03-31\" and s1.product_id=p1.product_id) = (select count(*) from Sales s3 where s3.product_id=p1.product_id) and product_id in (select product_id from Sales)\n`"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select product_id , product_name \\nfrom Product \\nwhere product_id in (select product_id \\n                     from Sales \\n                     where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\n                     And product_id not in (select product_id \\n                                            from Sales \\n                                            where sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\'))"
                    },
                    {
                        "username": "Vandana_KH",
                        "content": "I think the product G4 should be there in the output, I am not understanding why it is not included? Can anyone help me in this. Thanks  "
                    },
                    {
                        "username": "iamhassaan",
                        "content": "Any idea why I am getting this error ?\\n\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'abc\\n#  select product_id from Sales where month(sale_date) not in (1,2,3) \\n# s\\' at line 6\\n\\n\\n`\\n# Write your MySQL query statement below\\n\\nselect s.product_id , p.product_name from Sales s\\njoin product p on p.product_id = s.product_id \\nwhere sale_date between (\\'2019-01-01\\' and \\'2019-03-31\\')\\nand s.product_id not in (select abc.product_id from Sales where month(sale_date) not in (1,2,3)) abc\\n\\n`"
                    }
                ]
            },
            {
                "id": 1692324,
                "content": [
                    {
                        "username": "anuradhanda4498",
                        "content": "What is wrong in this ?\\nSELECT p.product_id , p.product_name\\nFROM Product p\\nLEFT JOIN Sales s\\nON p.product_id = s.product_id\\nWHERE s.sale_date BETWEEN \\'2019-01-01\\' AND \\'2019-03-31\\'\\nAND\\np.product_id NOT IN(\\n    SELECT DISTINCT product_id \\n    FROM Sales\\n    WHERE sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\')"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "use SELECT DISTINCT p.product_id , p.product_name ..."
                    },
                    {
                        "username": "weebhav",
                        "content": "Can someone please explain me why is this not the right solution?\\n\\nselect product_id , product_name from product where product_id not in\\n(select product_id from sales where sale_date  between (2019-04-01) and (2019-12-31));"
                    },
                    {
                        "username": "Vlad_Ku",
                        "content": "Too many mistakes...\\nWrong date range, wrong date literals, etc...\\nAdded additional condition and fix errors:\\n```sql\\nselect product_id , product_name from product \\nwhere product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\')\\nand product_id in (select product_id from sales where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\')\\n```"
                    },
                    {
                        "username": "Rahmatul_Akbar",
                        "content": "MySQL\\nselect sub.product_id,sub.product_name\\nfrom\\n(select p.product_id,p.product_name,s.sale_date\\nfrom product p\\njoin sales s\\non p.product_id=s.product_id\\ngroup by 1) sub\\nwhere sub.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\nand sub.product_id not in (select product_id from sales where sale_date not between \\'2019-01-01\\' and \\'2019-03-31\\' )"
                    },
                    {
                        "username": "yunjinchoidev",
                        "content": "select \\ns.product_id, \\np.product_name\\nfrom Product as p\\ninner join Sales as s on s.product_id = p.product_id\\nwhere s.sale_date between \\'2019-01-01\\' and \\'2019-03-31\\'\\nand (select max(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) <= \\'2019-03-31\\'\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\ngroup by s.product_id, p.product_id, p.product_name\\n\\n\\n\\ni think below where query is too Of course.\\nbecause this table is 2019 data. \\nam i wrong ? \\n\\nand (select min(s2.sale_date) from Sales as s2 where s2.product_id = p.product_id) >= \\'2019-01-01\\'\\n"
                    },
                    {
                        "username": "surbhisinggh",
                        "content": "why this query satement is wrong \\n\\nSelect Product.product_id, product_name, sale_date from Product left join Sales On Sales.product_id = Product.product_id where year(sale_date)=2019 And Month(sale_date) IN (1,2,3) ;"
                    },
                    {
                        "username": "aleliszt",
                        "content": "This query doesn\\'t exclude the product_ids that were also sold outside of the first quarter. For example  the product_name = G4  was sold in Q1 ( 2019-02-17) but  sold in 2019-06-02 too, then G4 shouldn\\'t be in the final output"
                    },
                    {
                        "username": "Yi-LingT",
                        "content": "SELECT product_id ,product_name\\nFROM Product \\nWHERE  product_id IN \\n(SELECT   product_id\\nFROM Sales\\nWHERE sale_date BETWEEN \\'2019-01-01\\' and \\'2019-03-31\\'\\n) WHY THIS IS WRONG?\\uD83D\\uDE2B\\n\\n\\nWHEN I CHANGE TO \\nWHERE sale_date > \\'2019-03-31\\' OR  sale_date < \\'2019-01-01\\' )\\nTHEN IT IS CORRECT?"
                    },
                    {
                        "username": "AABBCCDDEEFF",
                        "content": "\"MOST USEFULL\"\n `select product_id,product_name from product p1\nwhere (select count(*) from Sales s1 where sale_date between \"2019-01-01\" and \"2019-03-31\" and s1.product_id=p1.product_id) = (select count(*) from Sales s3 where s3.product_id=p1.product_id) and product_id in (select product_id from Sales)\n`"
                    },
                    {
                        "username": "Sultan_Aslam",
                        "content": "select product_id , product_name \\nfrom Product \\nwhere product_id in (select product_id \\n                     from Sales \\n                     where sale_date between \\'2019-01-01\\' and \\'2019-03-31\\' \\n                     And product_id not in (select product_id \\n                                            from Sales \\n                                            where sale_date > \\'2019-03-31\\' or sale_date < \\'2019-01-01\\'))"
                    },
                    {
                        "username": "Vandana_KH",
                        "content": "I think the product G4 should be there in the output, I am not understanding why it is not included? Can anyone help me in this. Thanks  "
                    },
                    {
                        "username": "iamhassaan",
                        "content": "Any idea why I am getting this error ?\\n\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'abc\\n#  select product_id from Sales where month(sale_date) not in (1,2,3) \\n# s\\' at line 6\\n\\n\\n`\\n# Write your MySQL query statement below\\n\\nselect s.product_id , p.product_name from Sales s\\njoin product p on p.product_id = s.product_id \\nwhere sale_date between (\\'2019-01-01\\' and \\'2019-03-31\\')\\nand s.product_id not in (select abc.product_id from Sales where month(sale_date) not in (1,2,3)) abc\\n\\n`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Stone Game V",
        "question_content": "<p>There are several stones <strong>arranged in a row</strong>, and each stone has an associated value which is an integer given in the array <code>stoneValue</code>.</p>\n\n<p>In each round of the game, Alice divides the row into <strong>two non-empty rows</strong> (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice&#39;s score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.</p>\n\n<p>The game ends when there is only <strong>one stone remaining</strong>. Alice&#39;s is initially <strong>zero</strong>.</p>\n\n<p>Return <i>the maximum score that Alice can obtain</i>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> stoneValue = [6,2,3,4,5,5]\n<strong>Output:</strong> 18\n<strong>Explanation:</strong> In the first round, Alice divides the row to [6,2,3], [4,5,5]. The left row has the value 11 and the right row has value 14. Bob throws away the right row and Alice&#39;s score is now 11.\nIn the second round Alice divides the row to [6], [2,3]. This time Bob throws away the left row and Alice&#39;s score becomes 16 (11 + 5).\nThe last round Alice has only one choice to divide the row which is [2], [3]. Bob throws away the right row and Alice&#39;s score is now 18 (16 + 2). The game ends because only one stone is remaining in the row.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> stoneValue = [7,7,7,7,7,7,7]\n<strong>Output:</strong> 28\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> stoneValue = [4]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= stoneValue.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= stoneValue[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 911676,
                "title": "java-o-n-3-o-n-2-log-n-and-o-n-2-with-explanation",
                "content": "**O(n^3)**\\n\\n**Basic approach**\\ndp[i][j]: max score you can obtain from stones[i..j]\\nsum[i][j]: sum of stoneValues[i..j]\\nTry all possible k i.e. k goes from i to j-1:\\nwe have 2 choices for score: **sum[i][k] + dp[i][k]** and **sum[k+1][j] + dp[k+1][j]**\\nbut we can only pick the side where sum is smaller or either of them when both sides are equal.\\nTake the maximum score from all of these choices and we have computed dp[i][j].\\nIn all my codes, I am building the dp table bottom-up i.e. dp[0][1], dp[1][2] gets calculated before dp[0][2].\\n\\n```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] pre = new int[n+1];\\n        for(int i = 1; i <= n; i++) {\\n            pre[i] = pre[i-1] + stoneValue[i-1];\\n        }\\n        int[][] dp = new int[n][n];\\n        for(int l = 1; l < n; l++) {\\n            for(int i = 0; i < n-l; i++) {\\n                int j = i+l, res = 0;\\n                for(int k = i; k < j; k++) {\\n                    int left = pre[k+1] - pre[i], right = pre[j+1] - pre[k+1];\\n                    if(left < right) {\\n                        res = Math.max(res, left + dp[i][k]);\\n                    } else if(left > right) {\\n                        res = Math.max(res, right + dp[k+1][j]);\\n                    } else {\\n                        res = Math.max(res, left + dp[i][k]);\\n                        res = Math.max(res, right + dp[k+1][j]);\\n                    }\\n                }\\n                dp[i][j] = res;\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n}\\n```\\n\\n**O(n^2 log n)**\\n\\n**Optimization**\\nAs k goes from i to j in stones[i..j], sum of left part sum[i][k] increases continuously and it remains a valid subarray for our consideration for calculating dp[i][j] until the point when it becomes greater than right half. From that point onwards, all the right ones are valid subarrays for consideration. We can find this critical k (= **k\\'**) using binary search. Forget about boundary cases and equal halves etc for now, just try to understand the general idea.\\n\\ndp[i][j] = max( max(sum[i][k] + dp[i][k]) for k: i to **k\\'**, max(sum[k][j] + dp[k][j]) for k: **k\\'**+1 to j )\\n(refer to the code for exact condition for all cases)\\n\\nIf we have to calculate first and second terms in above by iterating from k: i to **k\\'** or k: **k\\'**+1 to j, then it\\'d take O(n) time and we are back to first solution. What we can instead do is maintain 2 more arrays defined as:\\nleft[i][j] = max( sum[i][k] + dp[i][k] for k: i to j )\\nright[i][j] = max( sum[k][j] + dp[k][j] for k: i to j )\\n\\nand use them to redefine dp[i][j] = max( left[i][**k\\'**], right[**k\\'**+1][j] )\\n\\nNote that left and right arrays can also be calculated along with dp table so they don\\'t increase our worst case time complexity.\\n\\nleft[i][j] = max( left[i][j-1],  sum[i][j] + dp[i][j] )\\nright[i][j] = max( right[i+1][j],  sum[i][j] + dp[i][j] )\\n\\nWith these ideas in mind and taking care of boundary cases like **k\\'** == i or **k\\'** == j and equal halves etc, we have our solution ready.\\n\\n```\\nclass Solution {\\n    // returns first index where sum of left half >= sum of right half\\n    private int search(int[] pre, int l, int r) {\\n        int sum = pre[r+1] - pre[l], L = l;\\n        while(l < r) {\\n            int m = l + ((r - l) >> 1);\\n            if(((pre[m+1] - pre[L]) << 1) >= sum) {\\n                r = m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return l;\\n    }\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] pre = new int[n+1];\\n        for(int i = 1; i <= n; i++) {\\n            pre[i] = pre[i-1] + stoneValue[i-1];\\n        }\\n        int[][] dp = new int[n][n], left = new int[n][n], right = new int[n][n];\\n        for(int i = 0; i < n; i++) {\\n            left[i][i] = right[i][i] = stoneValue[i];\\n        }\\n        for(int l = 1; l < n; l++) {\\n            for(int i = 0; i < n-l; i++) {\\n                int j = i+l, k = search(pre, i, j);\\n                int sum = pre[j+1] - pre[i], leftHalf = pre[k+1] - pre[i];\\n                if((leftHalf << 1) == sum) {    // equal parts\\n                    dp[i][j] = Math.max(left[i][k], right[k+1][j]);\\n                } else {    // left half > right half\\n                    dp[i][j] = Math.max(k == i ? 0 : left[i][k-1], k == j ? 0 : right[k+1][j]);\\n                }\\n                left[i][j] = Math.max(left[i][j-1], sum + dp[i][j]);\\n                right[i][j] = Math.max(right[i+1][j], sum + dp[i][j]);\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n}\\n```\\n\\n**O(n^2)**\\n\\n**Optimization**\\nWe can optimize the previous solution even further by getting rid of the binary search step needed to find the critical k (= **k\\'**) of stones[i..j].\\nBinary search is great when we need the answer for arbitrary i and j but why not calculate dp[i][j] in such an order where we could leverage the **k\\'** information from previous i and j.\\n\\nSuppose we know the **k\\'** for stones[i..j], what do we know about **k\\'** for stones[i..j+1]? It is either the same or it got shifted a few places to the right.\\nAnd so if we calculate dp values in the order: dp[i][i], dp[i][i+1], dp[i][i+2], ..., dp[i][j], we can essentially keep track of **k\\'** as we go within that same linear time bound.\\n\\nUsing this idea, we implement the final solution. Couple of pointers about my code:\\n* mid: represents **k\\'** or first index such that left half >= right half\\n* with i < j, max[i][j] represents left[i][j] of previous solution i.e. max(dp[i][i], dp[i][i+1], dp[i][i+2] .. dp[i][j]) and max[j][i] represents right[i][j] of previous solution i.e. max(dp[i][j], dp[i+1][j], dp[i+2][j] .. dp[j][j]). We could have used two different arrays left and right just like previous solution but this trick saves space.\\n* I am traversing in the order: dp[j][j], dp[j-1,j], dp[j-2, j], .., dp[i][j] instead of the above mentioned order but the idea remains same.\\n\\n```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[][] dp = new int[n][n], max = new int[n][n];\\n        for(int i = 0; i < n; i++) {\\n            max[i][i] = stoneValue[i];\\n        }\\n        for(int j = 1; j < n; j++) {\\n            int mid = j, sum = stoneValue[j], rightHalf = 0;\\n            for(int i = j-1; i >= 0; i--) {\\n                sum += stoneValue[i];\\n                while((rightHalf + stoneValue[mid]) * 2 <= sum) {\\n                    rightHalf += stoneValue[mid--];\\n                }\\n                dp[i][j] = rightHalf * 2 == sum ? max[i][mid] : (mid == i ? 0 : max[i][mid - 1]);\\n                dp[i][j] = Math.max(dp[i][j], mid == j ? 0 : max[j][mid + 1]);\\n                max[i][j] = Math.max(max[i][j - 1], dp[i][j] + sum);\\n                max[j][i] = Math.max(max[j][i + 1], dp[i][j] + sum);\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] pre = new int[n+1];\\n        for(int i = 1; i <= n; i++) {\\n            pre[i] = pre[i-1] + stoneValue[i-1];\\n        }\\n        int[][] dp = new int[n][n];\\n        for(int l = 1; l < n; l++) {\\n            for(int i = 0; i < n-l; i++) {\\n                int j = i+l, res = 0;\\n                for(int k = i; k < j; k++) {\\n                    int left = pre[k+1] - pre[i], right = pre[j+1] - pre[k+1];\\n                    if(left < right) {\\n                        res = Math.max(res, left + dp[i][k]);\\n                    } else if(left > right) {\\n                        res = Math.max(res, right + dp[k+1][j]);\\n                    } else {\\n                        res = Math.max(res, left + dp[i][k]);\\n                        res = Math.max(res, right + dp[k+1][j]);\\n                    }\\n                }\\n                dp[i][j] = res;\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    // returns first index where sum of left half >= sum of right half\\n    private int search(int[] pre, int l, int r) {\\n        int sum = pre[r+1] - pre[l], L = l;\\n        while(l < r) {\\n            int m = l + ((r - l) >> 1);\\n            if(((pre[m+1] - pre[L]) << 1) >= sum) {\\n                r = m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return l;\\n    }\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] pre = new int[n+1];\\n        for(int i = 1; i <= n; i++) {\\n            pre[i] = pre[i-1] + stoneValue[i-1];\\n        }\\n        int[][] dp = new int[n][n], left = new int[n][n], right = new int[n][n];\\n        for(int i = 0; i < n; i++) {\\n            left[i][i] = right[i][i] = stoneValue[i];\\n        }\\n        for(int l = 1; l < n; l++) {\\n            for(int i = 0; i < n-l; i++) {\\n                int j = i+l, k = search(pre, i, j);\\n                int sum = pre[j+1] - pre[i], leftHalf = pre[k+1] - pre[i];\\n                if((leftHalf << 1) == sum) {    // equal parts\\n                    dp[i][j] = Math.max(left[i][k], right[k+1][j]);\\n                } else {    // left half > right half\\n                    dp[i][j] = Math.max(k == i ? 0 : left[i][k-1], k == j ? 0 : right[k+1][j]);\\n                }\\n                left[i][j] = Math.max(left[i][j-1], sum + dp[i][j]);\\n                right[i][j] = Math.max(right[i+1][j], sum + dp[i][j]);\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[][] dp = new int[n][n], max = new int[n][n];\\n        for(int i = 0; i < n; i++) {\\n            max[i][i] = stoneValue[i];\\n        }\\n        for(int j = 1; j < n; j++) {\\n            int mid = j, sum = stoneValue[j], rightHalf = 0;\\n            for(int i = j-1; i >= 0; i--) {\\n                sum += stoneValue[i];\\n                while((rightHalf + stoneValue[mid]) * 2 <= sum) {\\n                    rightHalf += stoneValue[mid--];\\n                }\\n                dp[i][j] = rightHalf * 2 == sum ? max[i][mid] : (mid == i ? 0 : max[i][mid - 1]);\\n                dp[i][j] = Math.max(dp[i][j], mid == j ? 0 : max[j][mid + 1]);\\n                max[i][j] = Math.max(max[i][j - 1], dp[i][j] + sum);\\n                max[j][i] = Math.max(max[j][i + 1], dp[i][j] + sum);\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806723,
                "title": "c-prefix-sum-dp-memoization",
                "content": "**[UPDATE]** \\nNew test cases added, forcing the solution to be `O(n^2)`. Please consider looking at other solutions, I\\'ll update this post once I find time to do so.\\n**Observation**\\n1. We can simply do what\\'s stated in the question and try all the possible partitions.\\n1. If the sum of left row is less recur on the left row.\\n1. If the sum of right row is less recur on the right row.\\n1. If the sum of both rows are equal we try recuring on both the partitions and chose the one with maximum result.\\n1. Now simply repeat the steps for the new row\\n1. Do this until there is only 1 stone left.\\n1. We can see that there are recalculations of selected row when we perform the previous 3 steps. Thus we memoize on the row represented by `i,j` i.e row start and row end.\\n\\n**Solution**\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> prefixSum;\\t\\t\\t//Stores prefixSums\\n    vector<vector<int>> memo;\\n    int dp(vector<int>& stoneValue,int i,int j)\\n    {\\n        if(i==j)\\n            return 0;\\n        if(memo[i][j]!=-1)\\n            return memo[i][j];\\n        memo[i][j]=0;\\n        for(int p=i+1;p<=j;p++)\\t\\t//Try each partition.\\n        {\\n\\t\\t\\tint l=prefixSum[p]-prefixSum[i],r=prefixSum[j+1]-prefixSum[p];\\n\\t\\t\\tif(l<r)\\t\\t//Left part is smaller\\n                memo[i][j]=max(memo[i][j],l+dp(stoneValue,i,p-1));\\n            else if(l>r)\\t//Right part is smaller\\n                memo[i][j]=max(memo[i][j],r+dp(stoneValue,p,j));\\n            else\\t//Both parts are equal\\n                memo[i][j]=max(memo[i][j],l+max(dp(stoneValue,p,j),dp(stoneValue,i,p-1)));\\n        }\\n        return memo[i][j];\\n    }\\n    int stoneGameV(vector<int>& stoneValue)\\n    {\\n        memo.resize(stoneValue.size(),vector<int>(stoneValue.size(),-1));\\n        prefixSum.resize(stoneValue.size()+1,0);\\n        for(int i=0;i<stoneValue.size();i++)\\t\\t//Create prefix Sums\\n            prefixSum[i+1]=prefixSum[i]+stoneValue[i];\\n        return dp(stoneValue,0,stoneValue.size()-1);\\n    }\\n};\\n```\\n\\n**Complexity**\\nTime: `O(n^3)`\\nSpace: `O(n^2)`",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> prefixSum;\\t\\t\\t//Stores prefixSums\\n    vector<vector<int>> memo;\\n    int dp(vector<int>& stoneValue,int i,int j)\\n    {\\n        if(i==j)\\n            return 0;\\n        if(memo[i][j]!=-1)\\n            return memo[i][j];\\n        memo[i][j]=0;\\n        for(int p=i+1;p<=j;p++)\\t\\t//Try each partition.\\n        {\\n\\t\\t\\tint l=prefixSum[p]-prefixSum[i],r=prefixSum[j+1]-prefixSum[p];\\n\\t\\t\\tif(l<r)\\t\\t//Left part is smaller\\n                memo[i][j]=max(memo[i][j],l+dp(stoneValue,i,p-1));\\n            else if(l>r)\\t//Right part is smaller\\n                memo[i][j]=max(memo[i][j],r+dp(stoneValue,p,j));\\n            else\\t//Both parts are equal\\n                memo[i][j]=max(memo[i][j],l+max(dp(stoneValue,p,j),dp(stoneValue,i,p-1)));\\n        }\\n        return memo[i][j];\\n    }\\n    int stoneGameV(vector<int>& stoneValue)\\n    {\\n        memo.resize(stoneValue.size(),vector<int>(stoneValue.size(),-1));\\n        prefixSum.resize(stoneValue.size()+1,0);\\n        for(int i=0;i<stoneValue.size();i++)\\t\\t//Create prefix Sums\\n            prefixSum[i+1]=prefixSum[i]+stoneValue[i];\\n        return dp(stoneValue,0,stoneValue.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806717,
                "title": "java-detailed-explanation-easy-understand-dfs-memo-top-down-dp",
                "content": "**Key Notes:**\\n- Classic DP problem\\n- Top-Down (DFS + Memo) is **easy to understand**\\n- Try split array at every possible point:\\n\\t- get left sum and right sum, choose the smaller one and keep searching\\n\\t- to save some time, we can pre-compute a **prefix array** to quick calculate sum\\n\\t- if left == right: try both ways\\n\\t- stop searching when only one element left, which means **pointer l == r**\\n- Cache searched result in dp by using state: pointer l and r\\n\\n```java\\npublic int stoneGameV(int[] stoneValue) {\\n        \\n\\tint N = stoneValue.length;\\n\\n\\t// cache prefix\\n\\tint[] prefix = new int[N + 1];\\n\\tfor (int i = 0; i < N; ++i) {\\n\\t\\tprefix[i + 1] = prefix[i] + stoneValue[i];\\n\\t}\\n\\n\\treturn helper(stoneValue, 0, N - 1, prefix, new Integer[N][N]);\\n}\\n\\nprivate int helper(int[] stoneValue, int l, int r, int[] prefix, Integer[][] dp) {\\n\\n\\tif (l == r) return 0;\\n\\tif (l + 1 == r) return Math.min(stoneValue[l], stoneValue[r]);\\n\\n\\tif (dp[l][r] != null) return dp[l][r];\\n\\n\\tint res = 0;\\n\\n\\t// left: [l, i], right: [i + 1, r]\\n\\tfor (int i = l; i < r; ++i) {\\n\\n\\t\\tint left = prefix[i + 1] - prefix[l];\\n\\t\\tint right = prefix[r + 1] - prefix[i + 1];\\n\\n\\t\\tif (left > right) {  // go right\\n\\t\\t\\tres = Math.max(res, right + helper(stoneValue, i + 1, r, prefix, dp));\\n\\t\\t} else if (left < right) {  // go left\\n\\t\\t\\tres = Math.max(res, left + helper(stoneValue, l, i, prefix, dp));\\n\\t\\t} else {  // left == right: go whatever max\\n\\t\\t\\tres = Math.max(res, Math.max(helper(stoneValue, l, i, prefix, dp),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t helper(stoneValue, i + 1, r, prefix, dp)) \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t + left);\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn dp[l][r] = res;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```java\\npublic int stoneGameV(int[] stoneValue) {\\n        \\n\\tint N = stoneValue.length;\\n\\n\\t// cache prefix\\n\\tint[] prefix = new int[N + 1];\\n\\tfor (int i = 0; i < N; ++i) {\\n\\t\\tprefix[i + 1] = prefix[i] + stoneValue[i];\\n\\t}\\n\\n\\treturn helper(stoneValue, 0, N - 1, prefix, new Integer[N][N]);\\n}\\n\\nprivate int helper(int[] stoneValue, int l, int r, int[] prefix, Integer[][] dp) {\\n\\n\\tif (l == r) return 0;\\n\\tif (l + 1 == r) return Math.min(stoneValue[l], stoneValue[r]);\\n\\n\\tif (dp[l][r] != null) return dp[l][r];\\n\\n\\tint res = 0;\\n\\n\\t// left: [l, i], right: [i + 1, r]\\n\\tfor (int i = l; i < r; ++i) {\\n\\n\\t\\tint left = prefix[i + 1] - prefix[l];\\n\\t\\tint right = prefix[r + 1] - prefix[i + 1];\\n\\n\\t\\tif (left > right) {  // go right\\n\\t\\t\\tres = Math.max(res, right + helper(stoneValue, i + 1, r, prefix, dp));\\n\\t\\t} else if (left < right) {  // go left\\n\\t\\t\\tres = Math.max(res, left + helper(stoneValue, l, i, prefix, dp));\\n\\t\\t} else {  // left == right: go whatever max\\n\\t\\t\\tres = Math.max(res, Math.max(helper(stoneValue, l, i, prefix, dp),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t helper(stoneValue, i + 1, r, prefix, dp)) \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t + left);\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn dp[l][r] = res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 806761,
                "title": "python-dp",
                "content": "**Update 2020/09/01:**\\nSeems new test cases added and enforce it to be O(N^2).\\nThis solution is TLE now.\\n\\n## **Intuition**\\nWe have done stone games many times.\\nJust dp it.\\n<br>\\n\\n## **Complexity**\\nTime `O(N^3)`\\nSpace `O(N^2)`\\n<br>\\n\\n\\n**Python:**\\n```py\\n    def stoneGameV(self, A):\\n        n = len(A)\\n        prefix = [0] * (n + 1)\\n        for i, a in enumerate(A):\\n            prefix[i + 1] = prefix[i] + A[i]\\n\\n        @functools.lru_cache(None)\\n        def dp(i, j):\\n            if i == j: return 0\\n            res = 0\\n            for m in range(i, j):\\n                left = prefix[m + 1] - prefix[i]\\n                right = prefix[j + 1] - prefix[m + 1]\\n                if left <= right:\\n                    res = max(res, dp(i, m) + left)\\n                if left >= right:\\n                    res = max(res, dp(m + 1, j) + right)\\n            return res\\n        return dp(0, n - 1)\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def stoneGameV(self, A):\\n        n = len(A)\\n        prefix = [0] * (n + 1)\\n        for i, a in enumerate(A):\\n            prefix[i + 1] = prefix[i] + A[i]\\n\\n        @functools.lru_cache(None)\\n        def dp(i, j):\\n            if i == j: return 0\\n            res = 0\\n            for m in range(i, j):\\n                left = prefix[m + 1] - prefix[i]\\n                right = prefix[j + 1] - prefix[m + 1]\\n                if left <= right:\\n                    res = max(res, dp(i, m) + left)\\n                if left >= right:\\n                    res = max(res, dp(m + 1, j) + right)\\n            return res\\n        return dp(0, n - 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 807330,
                "title": "c-o-n-2-dp",
                "content": "In the intuitive O(N^3) DP,  to calculate the maximum score h[i][j],  we need to iterate through any k that i <= k < j.  But if we examine the relationship among h[i][j], h[i][j+1] and h[i-1][j], it\\'s possible to derive an optimized O(N^2) solution.\\n\\nLet\\'s split the candidates of h[i][j] into 2 groups, depending on whether picking the left or right row:\\n1) picking the left row [i,k], score = sum(stoneValue[i], ..., stoneValue[k]) + h[i][k], iff sum(stoneValue[i], ..., stoneValue[k]) <= sum(stoneValue[k+1],..., stoneValue[j])\\n2) picking the right row [k+1,j],  score = sum(stoneValue[k+1],..., stoneValue[j]) + h[k+1][j], iff sum(stoneValue[k+1],..., stoneValue[j]) <= sum(stoneValue[i],..., stoneValue[k])\\n\\nNow, what if we need to calculate h[i][j+1]? The left row candidates for h[i][j] are also candidates for h[i][j+1], since sum(stoneValue[i], ..., stoneValue[k]) <= sum(stoneValue[k+1],..., stoneValue[j]) and stoneValue[j+1] > 0. \\n\\nSo when we calculate all of h[i][i], h[i][i+1],...h[i][n],  each left row candidate with score = sum(stoneValue[i], ..., stoneValue[k]) + h[i][k] (i <= k < n) only needs to calculate once.  \\n\\nThe same trick also holds when we need to calculate h[i-1][j]. The right row candidates for h[i][j] are also candidates for h[i-1][j].\\n\\nSo when we calculate all of h[j][j], h[j-1][j], ... h[1][j],  each right row candidate with score = sum(stoneValue[k+1],..., stoneValue[j]) + h[k+1][j] (1 <= k < j) only needs to calculate once. \\n\\nTo keep the calculation of both left row and right row candidates in order respectively,  the first loop should iterate through the row length from 1 to n, then the second loop simply enumates all possible rows with that length.\\n\\nTime: O(N^2)\\nSpace: O(N^2)\\n\\nclass Solution {\\npublic:\\n    int f[502], g[502], h[502][502];\\n    int x[502], y[502];\\n    int s[502];\\n    \\n    int stoneGameV(vector<int>& stoneValue) {\\n        vector<int>& a = stoneValue;\\n        int n = a.size();\\n        s[0] = 0;\\n        for (int i=0; i<n; i++) s[i+1] = s[i] + a[i];\\n        \\n        for (int i=1; i<=n; i++) {\\n            f[i] = g[i] = 0;\\n            x[i] = i;\\n            y[i] = i-1;\\n        }\\n        \\n        for (int len=2; len<=n; len++) {\\n            for (int i=1, j; (j = i+len-1) <= n; i++) {\\n                int half = (s[j] - s[i-1]) >> 1;\\n\\n                int& k = x[i];\\n                int& t = f[i]; \\n                int delta;\\n                while (k < j && (delta = s[k] - s[i-1]) <= half) {\\n                    t = max(t, delta + h[i][k++]);\\n                }\\n                \\n                int& k2 = y[j];\\n                int& t2 = g[j];\\n                while (k2 >= i && (delta = (s[j] - s[k2])) <= half) {\\n                    t2 = max(t2, delta + h[k2+1][j]);\\n                    k2--;\\n                }\\n                \\n                h[i][j] = max(t, t2);\\n            }\\n        }\\n        \\n        return h[1][n];\\n    }    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int f[502], g[502], h[502][502];\\n    int x[502], y[502];\\n    int s[502];\\n    \\n    int stoneGameV(vector<int>& stoneValue) {\\n        vector<int>& a = stoneValue;\\n        int n = a.size();\\n        s[0] = 0;\\n        for (int i=0; i<n; i++) s[i+1] = s[i] + a[i];\\n        \\n        for (int i=1; i<=n; i++) {\\n            f[i] = g[i] = 0;\\n            x[i] = i;\\n            y[i] = i-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 806879,
                "title": "c-o-n-2log-n-solution-and-why-top-down-approach-is-faster",
                "content": "I get my O(n^3) solution TLE in the contest and I passed my O(n^2log(n)) solution at 1:32 (so sad....). I managed to make my O(n^3) solution accepted at last :)\\n\\nConsider the initialized state of this problem and we have an interval [1, N] to solve. For all the possible ways to split this interval, we will always ignore the sub interval with bigger sum. it means we pruning these state and will never touch them again. As the time limit is tight for O(n^3) solution, it makes huge difference for the result..... Don\\'t like it. :(\\n\\nO(n^2log(n)) solution\\nExplanation:\\nDefinitions:\\n* f[i][j]: the maximum score we can get from interval [i, j]\\n* sum[i][j]: the sum of stoneValue[i] to stoneValue[j]\\n* lf[m][n]: the maximum value for all  f[i][j] + sum[i][j] where i == m and j in range [m, n]\\n* rf[m][n]: the maximum value for all  f[i][j] + sum[i][j] where j == n and i in range [m, n]\\n\\nConsider the following DP equation:\\n* f[i][j] = max(sum[i][m] + f[i][m]) if sum[i][m] < sum[m+1][j] for all m from i to j - 1 \\n* f[i][j] = max(sum[m+1][j] + f[m+1][j]) if sum[i][m] > sum[m+1][j]  for all m from i to j - 1 \\n* f[i][j] = max(sum[i][m] + f[i][m], sum[m+1][j] + f[m+1][j]) if sum[i][m] < sum[m+1][j]  for all m from i to j - 1\\n\\nWe can find the maximum m from i to j - 1 using binary search with O(log(n)) which keeps sum[i][m - 1] <= sum[m+1][j], then we get:\\n* For f[i][j]\\n  * if sum[i][m] == sum[m+1][j]:  f[i][j] = max(lf[i][m], rf[m+1][j])\\n  * if sum[i][m] < sum[m+1][j]: f[i][j] = max(lf[i][m], rf[m+2][j])\\n* lf[i][j] = max(lf[i][j-1], f[i][j] + sum[i][j])\\n* rf[i][j] = max(rf[i+1][j], f[i][j] + sum[i][j])\\n\\n```\\nclass Solution {\\n public:\\n  int getsum(vector<int>& sum, int l, int r) {\\n    if (l > r) return 0;\\n    if (l == 0) return sum[r];\\n    return sum[r] - sum[l - 1];\\n  }\\n  int stoneGameV(vector<int>& stoneValue) {\\n    int n = stoneValue.size();\\n    vector<int> sum(n, 0);\\n    for (int i = 0; i < n; ++i) {\\n      if (i > 0) sum[i] += sum[i - 1];\\n      sum[i] += stoneValue[i];\\n    }\\n    vector<vector<int>> f = vector<vector<int>>(n, vector<int>(n, 0));\\n    vector<vector<int>> lf = vector<vector<int>>(n, vector<int>(n, 0));\\n    vector<vector<int>> rf = vector<vector<int>>(n, vector<int>(n, 0));\\n\\n    for (int i = 0; i < n; ++i) {\\n      lf[i][i] = rf[i][i] = stoneValue[i];\\n    }\\n\\n    for (int i = n - 1; i >= 0; --i) {\\n      for (int j = i + 1; j < n; ++j) {\\n        int segsum = getsum(sum, i, j);\\n        int l = i - 1, r = j;\\n        while (l < r - 1) {\\n          int mid = (l + r) / 2;\\n          int left = getsum(sum, i, mid);\\n          if (left * 2 <= segsum) {\\n            l = mid;\\n          } else {\\n            r = mid;\\n          }\\n        }\\n        if (l >= i) f[i][j] = max(f[i][j], lf[i][l]);\\n        int rst = l;\\n        if (getsum(sum, i, l) * 2 < segsum) {\\n            rst += 2;\\n        } else {\\n            rst += 1;\\n        }\\n        if (rst <= j)\\n          f[i][j] = max(f[i][j], rf[rst][j]);\\n        lf[i][j] = max(lf[i][max(i, j - 1)], f[i][j] + segsum);\\n        rf[i][j] = max(rf[max(0, i + 1)][j], f[i][j] + segsum);\\n      }\\n    }\\n    return f[0][n - 1];\\n  }\\n};\\n\\n```\\n\\nO(n^3) accepted solution\\n```\\nclass Solution {\\npublic:\\n    int f[550][550];\\n    int sum[550];\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size();\\n        for (int i = 0; i < n; ++i) {\\n            sum[i + 1] = sum[i] + stoneValue[i];\\n        }\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            f[i][i] = 0;\\n        }\\n        for (int i = n; i > 0; --i) {\\n            for (int j = i + 1; j <= n; ++j) {\\n                for (int m = i; m < j; ++m) {\\n                    int left = sum[m] - sum[i - 1];\\n                    int right = sum[j] - sum[m];\\n                    if (left > right) {\\n                        f[i][j] = max(f[i][j], right + f[m + 1][j]);\\n                    } else if (left < right) {\\n                        f[i][j] = max(f[i][j], left + f[i][m]);\\n                    } else {\\n                        f[i][j] = max(f[i][j], right + f[m + 1][j]);\\n                        f[i][j] = max(f[i][j], left + f[i][m]);\\n                    }\\n                }\\n            }\\n        }\\n        return f[1][n];\\n    }\\n};\\n```\\n\\nO(n^3) TLE solution\\n```\\nclass Solution {\\npublic:\\n    int getsum(vector<int> &sum, int l, int r) {\\n        if (l == 0) return sum[r];\\n        return sum[r] - sum[l - 1];\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size();\\n        vector<int> sum(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            if (i > 0) sum[i] += sum[i - 1];\\n            sum[i] += stoneValue[i];\\n        }\\n        vector<vector<int>> f = vector<vector<int>>(n, vector<int>(n, 0));\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                for (int m = i; m < j; ++m) {\\n                    int left = getsum(sum, i, m);\\n                    int right = getsum(sum, m + 1, j);\\n                    if (left > right) {\\n                        f[i][j] = max(f[i][j], right + f[m + 1][j]);\\n                    } else if (left < right) {\\n                        f[i][j] = max(f[i][j], left + f[i][m]);\\n                    } else {\\n                        f[i][j] = max(f[i][j], right + f[m + 1][j]);\\n                        f[i][j] = max(f[i][j], left + f[i][m]);\\n                    }\\n                }\\n            }\\n        }\\n        return f[0][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  int getsum(vector<int>& sum, int l, int r) {\\n    if (l > r) return 0;\\n    if (l == 0) return sum[r];\\n    return sum[r] - sum[l - 1];\\n  }\\n  int stoneGameV(vector<int>& stoneValue) {\\n    int n = stoneValue.size();\\n    vector<int> sum(n, 0);\\n    for (int i = 0; i < n; ++i) {\\n      if (i > 0) sum[i] += sum[i - 1];\\n      sum[i] += stoneValue[i];\\n    }\\n    vector<vector<int>> f = vector<vector<int>>(n, vector<int>(n, 0));\\n    vector<vector<int>> lf = vector<vector<int>>(n, vector<int>(n, 0));\\n    vector<vector<int>> rf = vector<vector<int>>(n, vector<int>(n, 0));\\n\\n    for (int i = 0; i < n; ++i) {\\n      lf[i][i] = rf[i][i] = stoneValue[i];\\n    }\\n\\n    for (int i = n - 1; i >= 0; --i) {\\n      for (int j = i + 1; j < n; ++j) {\\n        int segsum = getsum(sum, i, j);\\n        int l = i - 1, r = j;\\n        while (l < r - 1) {\\n          int mid = (l + r) / 2;\\n          int left = getsum(sum, i, mid);\\n          if (left * 2 <= segsum) {\\n            l = mid;\\n          } else {\\n            r = mid;\\n          }\\n        }\\n        if (l >= i) f[i][j] = max(f[i][j], lf[i][l]);\\n        int rst = l;\\n        if (getsum(sum, i, l) * 2 < segsum) {\\n            rst += 2;\\n        } else {\\n            rst += 1;\\n        }\\n        if (rst <= j)\\n          f[i][j] = max(f[i][j], rf[rst][j]);\\n        lf[i][j] = max(lf[i][max(i, j - 1)], f[i][j] + segsum);\\n        rf[i][j] = max(rf[max(0, i + 1)][j], f[i][j] + segsum);\\n      }\\n    }\\n    return f[0][n - 1];\\n  }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int f[550][550];\\n    int sum[550];\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size();\\n        for (int i = 0; i < n; ++i) {\\n            sum[i + 1] = sum[i] + stoneValue[i];\\n        }\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            f[i][i] = 0;\\n        }\\n        for (int i = n; i > 0; --i) {\\n            for (int j = i + 1; j <= n; ++j) {\\n                for (int m = i; m < j; ++m) {\\n                    int left = sum[m] - sum[i - 1];\\n                    int right = sum[j] - sum[m];\\n                    if (left > right) {\\n                        f[i][j] = max(f[i][j], right + f[m + 1][j]);\\n                    } else if (left < right) {\\n                        f[i][j] = max(f[i][j], left + f[i][m]);\\n                    } else {\\n                        f[i][j] = max(f[i][j], right + f[m + 1][j]);\\n                        f[i][j] = max(f[i][j], left + f[i][m]);\\n                    }\\n                }\\n            }\\n        }\\n        return f[1][n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getsum(vector<int> &sum, int l, int r) {\\n        if (l == 0) return sum[r];\\n        return sum[r] - sum[l - 1];\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size();\\n        vector<int> sum(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            if (i > 0) sum[i] += sum[i - 1];\\n            sum[i] += stoneValue[i];\\n        }\\n        vector<vector<int>> f = vector<vector<int>>(n, vector<int>(n, 0));\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                for (int m = i; m < j; ++m) {\\n                    int left = getsum(sum, i, m);\\n                    int right = getsum(sum, m + 1, j);\\n                    if (left > right) {\\n                        f[i][j] = max(f[i][j], right + f[m + 1][j]);\\n                    } else if (left < right) {\\n                        f[i][j] = max(f[i][j], left + f[i][m]);\\n                    } else {\\n                        f[i][j] = max(f[i][j], right + f[m + 1][j]);\\n                        f[i][j] = max(f[i][j], left + f[i][m]);\\n                    }\\n                }\\n            }\\n        }\\n        return f[0][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806795,
                "title": "why-my-c-o-n-3-solution-will-tle",
                "content": "Code as follows:\\n\\n```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& s) {\\n        int n = s.size();\\n        vector<int> prefix(n);\\n        prefix[0] = s[0];\\n        \\n        for (int i = 1; i < n; i++)\\n            prefix[i] = prefix[i - 1] + s[i];\\n        \\n        vector<vector<int>> dp(n, vector<int>(n));\\n        \\n        for (int i = 0; i < n - 1; i++)\\n            dp[i][i + 1] = min(s[i], s[i + 1]);        \\n        \\n        for (int len = 3; len <= n; len++)\\n            for (int i = 0; i <= n - len; i++){\\n                int j = i + len - 1;\\n                \\n                for (int k = i; k < j; k++){\\n                    // s[i ~ k] and s[k + 1 ~ j]\\n                    int s1 = i == 0 ? prefix[k] : prefix[k] - prefix[i - 1];\\n                    int s2 = prefix[j] - prefix[k];\\n                    if (s1 == s2)\\n                        dp[i][j] = max(dp[i][j], s1 + max(dp[i][k], dp[k + 1][j]));\\n                    else if (s1 < s2)\\n                        dp[i][j] = max(dp[i][j], s1 + dp[i][k]);\\n                    else\\n                        dp[i][j] = max(dp[i][j], s2 + dp[k + 1][j]);\\n                }\\n            }\\n        \\n        return dp[0][n - 1];\\n    }\\n};\\n```\\nUpdate: Even after changing\\n```\\nvector<vector<int>> dp(n, vector<int>(n));\\n```\\nto \\n```\\nint dp[505][505];\\n```\\ncode still TLE. This is a really funny contest...",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& s) {\\n        int n = s.size();\\n        vector<int> prefix(n);\\n        prefix[0] = s[0];\\n        \\n        for (int i = 1; i < n; i++)\\n            prefix[i] = prefix[i - 1] + s[i];\\n        \\n        vector<vector<int>> dp(n, vector<int>(n));\\n        \\n        for (int i = 0; i < n - 1; i++)\\n            dp[i][i + 1] = min(s[i], s[i + 1]);        \\n        \\n        for (int len = 3; len <= n; len++)\\n            for (int i = 0; i <= n - len; i++){\\n                int j = i + len - 1;\\n                \\n                for (int k = i; k < j; k++){\\n                    // s[i ~ k] and s[k + 1 ~ j]\\n                    int s1 = i == 0 ? prefix[k] : prefix[k] - prefix[i - 1];\\n                    int s2 = prefix[j] - prefix[k];\\n                    if (s1 == s2)\\n                        dp[i][j] = max(dp[i][j], s1 + max(dp[i][k], dp[k + 1][j]));\\n                    else if (s1 < s2)\\n                        dp[i][j] = max(dp[i][j], s1 + dp[i][k]);\\n                    else\\n                        dp[i][j] = max(dp[i][j], s2 + dp[k + 1][j]);\\n                }\\n            }\\n        \\n        return dp[0][n - 1];\\n    }\\n};\\n```\n```\\nvector<vector<int>> dp(n, vector<int>(n));\\n```\n```\\nint dp[505][505];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806745,
                "title": "java-top-down-dp",
                "content": "dp[fr][to] is the max points that you can gain if you pick sub array from fr to to;\\nCache the result to avoid duplicate calculation\\n\\n```\\nclass Solution {\\n    int[][] dp;\\n    int[] acc;\\n    public int stoneGameV(int[] ss) {\\n        int m = ss.length;\\n        dp = new int[m][m];\\n        acc = new int[m + 1];\\n        for (int i = 0; i < m; i++) acc[i + 1] = acc[i] + ss[i];\\n        return dfs(0, m - 1);\\n    }\\n    \\n    private int dfs(int fr, int to) {\\n        if (fr == to) return 0;\\n        if (dp[fr][to] > 0) return dp[fr][to];\\n        for (int d = fr + 1; d <= to; d++) {\\n            int first = acc[d] - acc[fr], second = acc[to + 1] - acc[d];\\n            if (first == second) dp[fr][to] = Math.max(dp[fr][to], first + Math.max(dfs(fr, d - 1), dfs(d, to)));\\n            else if (first > second) dp[fr][to] = Math.max(dp[fr][to], second + dfs(d, to));\\n            else dp[fr][to] = Math.max(dp[fr][to], first + dfs(fr, d - 1));\\n        }\\n        return dp[fr][to];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dp;\\n    int[] acc;\\n    public int stoneGameV(int[] ss) {\\n        int m = ss.length;\\n        dp = new int[m][m];\\n        acc = new int[m + 1];\\n        for (int i = 0; i < m; i++) acc[i + 1] = acc[i] + ss[i];\\n        return dfs(0, m - 1);\\n    }\\n    \\n    private int dfs(int fr, int to) {\\n        if (fr == to) return 0;\\n        if (dp[fr][to] > 0) return dp[fr][to];\\n        for (int d = fr + 1; d <= to; d++) {\\n            int first = acc[d] - acc[fr], second = acc[to + 1] - acc[d];\\n            if (first == second) dp[fr][to] = Math.max(dp[fr][to], first + Math.max(dfs(fr, d - 1), dfs(d, to)));\\n            else if (first > second) dp[fr][to] = Math.max(dp[fr][to], second + dfs(d, to));\\n            else dp[fr][to] = Math.max(dp[fr][to], first + dfs(fr, d - 1));\\n        }\\n        return dp[fr][to];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889244,
                "title": "please-do-not-assume-monotonicity-like-stonegamev-a-stonegamev-a-1",
                "content": "I read a few posts and some of the \"fast\" DP solutions implicitly assumed that the result is non-decreasing as the list goes longer and longer. This is not true. The simpliest counter example being `[1,3,2,2,1]`, we have:\\n\\n`stoneGameV([1,3,2,2]) = 6` and `stoneGameV([1,3,2,2,1]) = 5`.\\n\\n(To achieve the max for `[1,3,2,2]` cut in the middle and proceed with the right half, adding a `1` to the right simply breaks that.) \\n\\nAs a result, do not assume cutting to make the left and right sum as equal as possible is the optimal play. Some of the best solutions are simply wrong for this reason. Take the fastest Python3 solution for example, here\\'s the code:\\n\\n```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        presum = [0] + list(accumulate(stoneValue))\\n\\n        def subsum(start, end):\\n            return presum[end] - presum[start]\\n        \\n        def med(start, end):\\n            # max_k {subsum(start, k) <= subsum(k, end)}\\n            return bisect.bisect(presum, (presum[start] + presum[end]) // 2) - 1\\n\\n        @lru_cache(None)\\n        def DP(start, end):\\n            if start + 1 == end:\\n                return 0\\n            elif start + 2 == end:\\n                return min(stoneValue[start], stoneValue[start + 1])\\n\\n            Lmed, Rmed = med(start, end - 1), med(start + 1, end) + 1\\n            ret = 0\\n            for i in range(\\n                max(start + 1, Lmed),\\n                min(end, Rmed + 1),\\n            ):\\n                # split to [start, i), [i, end)\\n                Lsum, Rsum = subsum(start, i), subsum(i, end)\\n                if Lsum < Rsum:\\n                    newval = Lsum + DP(start, i)\\n                elif Lsum > Rsum:\\n                    newval = Rsum + DP(i, end)\\n                else:\\n                    newval = Lsum + max(DP(start, i), DP(i, end))\\n\\n                ret = max(newval, ret)\\n            return ret\\n\\n        return DP(0, len(stoneValue))\\n```\\n\\nA simple counter example for it would be `[1,99,1,99,50,50,50,50,1,401,1]`. The best cut is actually at `[1,99,1,99,50,50,50,50]` but it only checks `[1,99,1,99,50,50,50,50,1]` and cuts to its right. As a result it got 702 while the correct answer is 750. Unfortunately this solution passes all 131 test case.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        presum = [0] + list(accumulate(stoneValue))\\n\\n        def subsum(start, end):\\n            return presum[end] - presum[start]\\n        \\n        def med(start, end):\\n            # max_k {subsum(start, k) <= subsum(k, end)}\\n            return bisect.bisect(presum, (presum[start] + presum[end]) // 2) - 1\\n\\n        @lru_cache(None)\\n        def DP(start, end):\\n            if start + 1 == end:\\n                return 0\\n            elif start + 2 == end:\\n                return min(stoneValue[start], stoneValue[start + 1])\\n\\n            Lmed, Rmed = med(start, end - 1), med(start + 1, end) + 1\\n            ret = 0\\n            for i in range(\\n                max(start + 1, Lmed),\\n                min(end, Rmed + 1),\\n            ):\\n                # split to [start, i), [i, end)\\n                Lsum, Rsum = subsum(start, i), subsum(i, end)\\n                if Lsum < Rsum:\\n                    newval = Lsum + DP(start, i)\\n                elif Lsum > Rsum:\\n                    newval = Rsum + DP(i, end)\\n                else:\\n                    newval = Lsum + max(DP(start, i), DP(i, end))\\n\\n                ret = max(newval, ret)\\n            return ret\\n\\n        return DP(0, len(stoneValue))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807860,
                "title": "c-o-n-2-time-dp-solution-no-binary-search-needed",
                "content": "Let *a[1..n]* denote the values of stones, *s(i, j)* denote the sum *a[i]+a[i+1]+...+a[j]*, and *D(i, j)* denote the maximum score of *a[i..j]*. We first calculate *D(1, 1), D(2, 2), ..., D(n, n)*, then calculate *D(1, 2), D(2, 3), ..., D(n-1, n)*, then calculate *D(1, 3), D(2, 4), ..., D(n-2, n)*, and so on. Note that the answer is given by *D(1, n)*.\\n\\nWe introduce *K(i, j)* for all *1 \\u2264 i \\u2264 j \\u2264 n*, defined by the smallest index *k* such that *2s(i, k) \\u2265 s(i, j)*. The recursive relation of *D* is thereby given by\\n\\n*D(i, j) =*\\n* *max{ max{ s(i, k)+D(i, k): i \\u2264 k \\u2264 K(i, j) }, max{ s(k+1, j)+D(k+1, j): K(i, j) \\u2264 k \\u2264 j-1 } }*, if *2s(i, K(i, j)) = s(i, j)*,\\n* *max{ max{ s(i, k)+D(i, k): i \\u2264 k \\u2264 K(i, j)-1 }, max{ s(k+1, j)+D(k+1, j): K(i, j) \\u2264 k \\u2264 j-1 } }*, if *2s(i, K(i, j)) > s(i, j)*.\\n\\nIf we have found all *K(i, j)*\\'s, the answer *D(1, n)* can be figured out within *O(n\\xB2)*-time, since all we need is the auxiliary *Q(i, j) := max{ s(i, k)+D(i, k): min{i, j} \\u2264 k \\u2264 max{i, j} }*, which can be calculated together with *D*. As *a[i] > 0*, one can obtain an *O(n\\xB2* log *n)*-time algorithm with binary search.\\n\\nBut observe that *K(i, j) \\u2264 K(i, j+1) \\u2264 K(i+1, j+1)* and that *K(i, i) = i*. If we\\'ve found *K(1, i), K(2, i+1), ..., K(n-i+1, n)*, then *K(1, i+1), K(2, i+2), ..., K(n-i, n)* can be figured out in *O(n)*-time with a simple linear-time search since\\n\\n*1 \\u2264 K(1, i) \\u2264 K(1, i+1) \\u2264 K(2, i+1) \\u2264 K(2, i+2) \\u2264 K(3, i+2) \\u2264 ... \\u2264 K(n-i, n-1) \\u2264 K(n-i, n) \\u2264 K(n-i+1, n) \\u2264 n.*\\n\\nTherefore, all *K(i, j)*\\'s can be found in *O(n\\xB2)*, and thus the total time complexity is also *O(n\\xB2)*.\\n\\nThe following shows my C++ AC code. *D, K, Q* are replaced by `dp`, `mid`, and `rmq`.\\n\\n```\\nclass Solution{\\npublic:\\n    int stoneGameV(vector<int> const &stoneValue) const{\\n        int n = stoneValue.size();\\n        vector<int> s(n+1);\\n        partial_sum(stoneValue.cbegin(), stoneValue.cend(), s.begin()+1);\\n        auto idx = [n](int i, int j){\\n            return (i-1)*n+(j-1);\\n        };\\n        vector<int> dp(n*n), rmq(n*n), mid(n*n);\\n        for(int i=1; i<=n; ++i){\\n            dp[idx(i, i)] = 0;\\n            rmq[idx(i, i)] = s[i]-s[i-1];\\n            mid[idx(i, i)] = i;\\n        }\\n        for(int i=1; i<=n-1; ++i){\\n            for(int j=1; j+i<=n; ++j){\\n                int &k = mid[idx(j, j+i)];\\n                k = mid[idx(j, j+i-1)];\\n                while(2*(s[k]-s[j-1]) < s[j+i]-s[j-1]){\\n                    ++k;\\n                }\\n                int &x = dp[idx(j, j+i)];\\n                if(k < j+i){\\n                    x = max(x, rmq[idx(j+i, k+1)]);\\n                }\\n                if(2*(s[k]-s[j-1]) == s[j+i]-s[j-1]){\\n                    x = max(x, rmq[idx(j, k)]);\\n                }else if(k > j){\\n                    x = max(x, rmq[idx(j, k-1)]);\\n                }\\n                rmq[idx(j, j+i)] = max(rmq[idx(j, j+i-1)], s[j+i]-s[j-1]+x);\\n                rmq[idx(j+i, j)] = max(rmq[idx(j+i, j+1)], s[j+i]-s[j-1]+x);\\n            }\\n        }\\n        return dp[idx(1, n)];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\npublic:\\n    int stoneGameV(vector<int> const &stoneValue) const{\\n        int n = stoneValue.size();\\n        vector<int> s(n+1);\\n        partial_sum(stoneValue.cbegin(), stoneValue.cend(), s.begin()+1);\\n        auto idx = [n](int i, int j){\\n            return (i-1)*n+(j-1);\\n        };\\n        vector<int> dp(n*n), rmq(n*n), mid(n*n);\\n        for(int i=1; i<=n; ++i){\\n            dp[idx(i, i)] = 0;\\n            rmq[idx(i, i)] = s[i]-s[i-1];\\n            mid[idx(i, i)] = i;\\n        }\\n        for(int i=1; i<=n-1; ++i){\\n            for(int j=1; j+i<=n; ++j){\\n                int &k = mid[idx(j, j+i)];\\n                k = mid[idx(j, j+i-1)];\\n                while(2*(s[k]-s[j-1]) < s[j+i]-s[j-1]){\\n                    ++k;\\n                }\\n                int &x = dp[idx(j, j+i)];\\n                if(k < j+i){\\n                    x = max(x, rmq[idx(j+i, k+1)]);\\n                }\\n                if(2*(s[k]-s[j-1]) == s[j+i]-s[j-1]){\\n                    x = max(x, rmq[idx(j, k)]);\\n                }else if(k > j){\\n                    x = max(x, rmq[idx(j, k-1)]);\\n                }\\n                rmq[idx(j, j+i)] = max(rmq[idx(j, j+i-1)], s[j+i]-s[j-1]+x);\\n                rmq[idx(j+i, j)] = max(rmq[idx(j+i, j+1)], s[j+i]-s[j-1]+x);\\n            }\\n        }\\n        return dp[idx(1, n)];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807331,
                "title": "some-test-cases-that-refuse-plausible-assumptions",
                "content": "Some may wonder if we can turn typical O(n^3) dynamic programming algorithm (can be seen in many other posts) into O(n^2), by some strong assumptions. Here are some assumptions seeming to be correct but in fact wrong:\\n\\n1. If array **A** is a subarray of **B**, then Alice\\'s score over **B** can\\'t be lower than that over **A**\\n\\n\\tcounterexample:\\n\\t\\n\\tA=[2,10,2,4,4,5], result is 18\\n\\tB=[2,10,2,4,4,5,4], result is 17\\n\\tThis fact tells us shorter array may not have lower score.\\n2. We only need to consider splits that cut an array as balanced as possible, that is, if we can find an index **k**, such that ```sum(A[0]...A[k]) <= sum(A[k+1]...A[n-1])``` and ```sum(A[0]...A[k+1]) >= sum(A[k+2]...A[n-1])```, the optimal split must be either **k** or **k+1**\\n\\n\\tcounterexample:\\n\\t\\n\\t[98, 77, 24, 49, 6, 12, 2, 44, 51, 96]\\n\\tThe most balanced split is \\n\\t[98, 77, 24][49, 6, 12, 2, 44, 51, 96], left part sum 199, right part sum 260\\n\\t[98, 77, 24, 49][6, 12, 2, 44, 51, 96], left part sum 248, right part sum 211\\n\\tHowever, the optimal result of this example is\\n\\t[98, 77, 24, 49, 6, 12, 2, 44, 51, 96]->[98, 77, 24, 49, 6, 12, 2][44, 51, 96] -> [44, 51, 96]->[44, 51][96] -> [44, 51] -> [44][51] ->[44], get 191+95+44=330 score, which doesn\\'t cut the array in the most balanced way",
                "solutionTags": [],
                "code": "```sum(A[0]...A[k]) <= sum(A[k+1]...A[n-1])```\n```sum(A[0]...A[k+1]) >= sum(A[k+2]...A[n-1])```",
                "codeTag": "Unknown"
            },
            {
                "id": 806741,
                "title": "c-python-partial-sum-dfs",
                "content": "This is similar to other DP problems when you find the best split point `k` for a range `[i, j]`. To avoid recomputation, we memoise the best answer in `dp[i][j]`.\\n\\nTo speed things up, we first convert our array into a prefix sum array, so that we can easily get the sum of interval `[i, j]` as `v[j] - v[i - 1]`. \\n\\n**C++**\\n```cpp\\nint dp[501][501] = {};\\nint dfs(vector<int>& v, int i, int j) {\\n    if (!dp[i][j])       \\n        for (int k = i; k < j; ++k) {\\n            int left = v[k] - (i > 0 ? v[i - 1] : 0), right = v[j] - v[k];\\n            if (left <= right)\\n                dp[i][j] = max(dp[i][j], left + dfs(v, i, k));\\n            if (left >= right)\\n                dp[i][j] = max(dp[i][j], right + dfs(v, k + 1, j));\\n        }\\n    return dp[i][j];       \\n}\\nint stoneGameV(vector<int>& v) {\\n    partial_sum(begin(v), end(v), begin(v));\\n    return dfs(v, 0, v.size() - 1);\\n}\\n```\\n**Python**\\nWe add a sentinel value to the prefix sum array to avoid `i > 0` check.\\n\\n```python\\ndef stoneGameV(self, v: List[int]) -> int:\\n\\t@lru_cache(None)\\n\\tdef dfs(i: int, j: int) -> int:\\n\\t\\tres = 0\\n\\t\\tfor k in range(i, j):\\n\\t\\t\\tif v[k] - v[i - 1] <= v[j] - v[k]:\\n\\t\\t\\t\\tres = max(res, v[k] - v[i - 1] + dfs(i, k))\\n\\t\\t\\tif v[k] - v[i - 1] >= v[j] - v[k]:\\n\\t\\t\\t\\tres = max(res, v[j] - v[k] + dfs(k + 1, j))\\n\\t\\treturn res\\n\\tv = [0] + list(itertools.accumulate(v))\\n\\treturn dfs(1, len(v) - 1) \\n```\\n**Complexity Analysis**\\n- Time: O(n ^ 3). For each combination of `i` and `j`, we perform `j - i` operations.\\n- Memory: O(n ^ 2) for the memoisation.",
                "solutionTags": [],
                "code": "```cpp\\nint dp[501][501] = {};\\nint dfs(vector<int>& v, int i, int j) {\\n    if (!dp[i][j])       \\n        for (int k = i; k < j; ++k) {\\n            int left = v[k] - (i > 0 ? v[i - 1] : 0), right = v[j] - v[k];\\n            if (left <= right)\\n                dp[i][j] = max(dp[i][j], left + dfs(v, i, k));\\n            if (left >= right)\\n                dp[i][j] = max(dp[i][j], right + dfs(v, k + 1, j));\\n        }\\n    return dp[i][j];       \\n}\\nint stoneGameV(vector<int>& v) {\\n    partial_sum(begin(v), end(v), begin(v));\\n    return dfs(v, 0, v.size() - 1);\\n}\\n```\n```python\\ndef stoneGameV(self, v: List[int]) -> int:\\n\\t@lru_cache(None)\\n\\tdef dfs(i: int, j: int) -> int:\\n\\t\\tres = 0\\n\\t\\tfor k in range(i, j):\\n\\t\\t\\tif v[k] - v[i - 1] <= v[j] - v[k]:\\n\\t\\t\\t\\tres = max(res, v[k] - v[i - 1] + dfs(i, k))\\n\\t\\t\\tif v[k] - v[i - 1] >= v[j] - v[k]:\\n\\t\\t\\t\\tres = max(res, v[j] - v[k] + dfs(k + 1, j))\\n\\t\\treturn res\\n\\tv = [0] + list(itertools.accumulate(v))\\n\\treturn dfs(1, len(v) - 1) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 806736,
                "title": "python-golang-simple-dp-solution-with-a-trick-for-python",
                "content": "**Idea**\\nThe idea is straight forward. we just try out all the possibilities to find the answer. Naive brute force solution will lead to O(n!) complexity, so we need to store the interim results to improve the complexity to O(n^3).\\n\\n**A trick for slower languages**\\nSince I got TLE for the O(n^3) solution in Python. I add a shortcut for a special case when all the elements within a specific range are the same. In this special case, we can get the results in O(logn) complexity.\\n\\n**Complexity**\\nTime: O(n^3)\\nSpace: O(n^2)\\n\\nPlease do not downvote unless you find it necessary. Please bro.\\n\\n**Python**\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        presum = [0]\\n        for s in stoneValue:\\n            presum += presum[-1] + s,\\n            \\n        def sm(i, j):\\n            return presum[j + 1] - presum[i]\\n        \\n        @lru_cache(None)\\n        def helper(i, j):\\n            if i == j: return 0\\n            \\n            if all(stoneValue[k] == stoneValue[j] for k in range(i, j)):\\n                cnt = 0\\n                l = j - i + 1\\n                while l > 1:\\n                    l //= 2\\n                    cnt += l\\n                return cnt * stoneValue[j]                    \\n            \\n            res = 0\\n            for k in range(i, j):\\n                if sm(i, k) < sm(k + 1, j):\\n                    score = helper(i, k) + sm(i, k)\\n                elif sm(i, k) > sm(k + 1, j):\\n                    score = sm(k + 1, j) + helper(k + 1, j)\\n                else:                    \\n                    score = max(helper(i, k) + sm(i, k), sm(k + 1, j) + helper(k + 1, j))\\n                res = max(res, score)\\n            return res                \\n        \\n        return helper(0, len(stoneValue) - 1)\\n```\\n\\n\\n**Golang**\\n```\\nfunc stoneGameV(stoneValue []int) int {\\n    n := len(stoneValue)\\n    memo := make([][]int, n)\\n    for i := range memo {\\n        memo[i] = make([]int, n)\\n    }\\n    presum := make([]int, n + 1)\\n    for i := 1; i <= n; i++ {\\n        presum[i] = presum[i - 1] + stoneValue[i - 1]\\n    }\\n    sum := func(i, j int) int {return presum[j + 1] - presum[i]}\\n    \\n    \\n    for l := 2; l <= n; l++ { // l mean length\\n        for i := 0; i < n - l + 1; i++ {\\n            j := i + l - 1\\n            score := 0\\n            for k := i; k < j; k++ {\\n                switch {\\n                case sum(i, k) > sum(k + 1, j):\\n                    score = max(score, memo[k + 1][j] + sum(k + 1, j))\\n                case sum(i, k) < sum(k + 1, j):\\n                    score = max(score, memo[i][k] + sum(i, k))\\n                default:\\n                    tmp := max(memo[i][k] + sum(i, k), memo[k + 1][j] + sum(k + 1, j))\\n                    score = max(score, tmp)\\n                }\\n            }\\n            memo[i][j] = score\\n        }\\n    }\\n    return memo[0][n - 1]\\n}\\n\\nfunc max(i, j int) int {\\n    if i < j {\\n        return j\\n    }\\n    return i\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "Go"
                ],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        presum = [0]\\n        for s in stoneValue:\\n            presum += presum[-1] + s,\\n            \\n        def sm(i, j):\\n            return presum[j + 1] - presum[i]\\n        \\n        @lru_cache(None)\\n        def helper(i, j):\\n            if i == j: return 0\\n            \\n            if all(stoneValue[k] == stoneValue[j] for k in range(i, j)):\\n                cnt = 0\\n                l = j - i + 1\\n                while l > 1:\\n                    l //= 2\\n                    cnt += l\\n                return cnt * stoneValue[j]                    \\n            \\n            res = 0\\n            for k in range(i, j):\\n                if sm(i, k) < sm(k + 1, j):\\n                    score = helper(i, k) + sm(i, k)\\n                elif sm(i, k) > sm(k + 1, j):\\n                    score = sm(k + 1, j) + helper(k + 1, j)\\n                else:                    \\n                    score = max(helper(i, k) + sm(i, k), sm(k + 1, j) + helper(k + 1, j))\\n                res = max(res, score)\\n            return res                \\n        \\n        return helper(0, len(stoneValue) - 1)\\n```\n```\\nfunc stoneGameV(stoneValue []int) int {\\n    n := len(stoneValue)\\n    memo := make([][]int, n)\\n    for i := range memo {\\n        memo[i] = make([]int, n)\\n    }\\n    presum := make([]int, n + 1)\\n    for i := 1; i <= n; i++ {\\n        presum[i] = presum[i - 1] + stoneValue[i - 1]\\n    }\\n    sum := func(i, j int) int {return presum[j + 1] - presum[i]}\\n    \\n    \\n    for l := 2; l <= n; l++ { // l mean length\\n        for i := 0; i < n - l + 1; i++ {\\n            j := i + l - 1\\n            score := 0\\n            for k := i; k < j; k++ {\\n                switch {\\n                case sum(i, k) > sum(k + 1, j):\\n                    score = max(score, memo[k + 1][j] + sum(k + 1, j))\\n                case sum(i, k) < sum(k + 1, j):\\n                    score = max(score, memo[i][k] + sum(i, k))\\n                default:\\n                    tmp := max(memo[i][k] + sum(i, k), memo[k + 1][j] + sum(k + 1, j))\\n                    score = max(score, tmp)\\n                }\\n            }\\n            memo[i][j] = score\\n        }\\n    }\\n    return memo[0][n - 1]\\n}\\n\\nfunc max(i, j int) int {\\n    if i < j {\\n        return j\\n    }\\n    return i\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855827,
                "title": "optimal-strategy-for-stone-game-maximizing-alice-s-score-with-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can use dynamic programming. We can create a memoization table to keep track of the maximum scores Alice can obtain for each subproblem. The subproblem can be defined as the range of stones from index i to j.\\n\\nThe approach can be summarized as follows:\\n\\n1. Initialize a memoization table to store the maximum score Alice can obtain for each subproblem.\\n2. Create a helper function that calculates the maximum score Alice can obtain for a given range of stones (i.e., from index i to j).\\n3. In the helper function, check the base case when there\\'s only one stone left in the range (i.e., i == j), and return its value as the score.\\n4. If there are more than one stone, calculate the score for each possible division of the current range into two non-empty rows (i.e., left row and right row). To do this, iterate through all possible split points from i to j-1 and recursively calculate the maximum scores for the resulting left and right ranges.\\n5. For each split point, update the maximum score Alice can obtain by comparing the scores of the two rows and taking the maximum.\\n6. Return the maximum score for the current range.\\n\\nBy following the above approach, we can efficiently calculate the maximum score Alice can obtain by dividing the problem into smaller subproblems and reusing the already calculated results using memoization.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given code implements a solution to the problem using dynamic programming and memoization. The main function `stoneGameV` takes an array `a` representing the values of the stones. It calculates the prefix sum of the array to facilitate quick range sum queries. It then initializes a memoization table `memo` and calls the `stoneGameHelper` function to find the maximum score Alice can obtain.\\n\\nThe `stoneGameHelper` function is a recursive helper function that calculates the maximum score for a given range of stones defined by the `left` and `right` indices. It uses the memoization table to store and reuse the results of subproblems to avoid redundant calculations.\\n\\nIn the `stoneGameHelper` function, it first checks the base case when there\\'s only one stone in the range, and in that case, it returns 0. If the result for the current range is already present in the memoization table, it returns the stored value directly.\\n\\nOtherwise, it iterates through all possible split points from `left` to `right-1`, and for each split point `i`, it calculates the scores of the left and right rows based on the prefix sum array. Then, it compares the scores and updates the result with the maximum value considering the two rows.\\n\\nIf the left and right rows have equal scores, it considers both divisions and takes the maximum score among them.\\n\\nFinally, the calculated result is stored in the memoization table, and the function returns the result.\\n\\nOverall, this solution effectively solves the problem by breaking it into smaller subproblems and using memoization to avoid redundant calculations, making it efficient for larger input sizes.# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& a) {\\n        int n = a.size();\\n        if (n == 1)\\n            return 0;\\n        \\n        // Calculate the prefix sum of the array for quick range sum queries.\\n        vector<int> prefixSum(n + 1, 0);\\n        for (int i = 0; i < n; ++i) {\\n            prefixSum[i + 1] = prefixSum[i] + a[i];\\n        }\\n        \\n        // Initialize the memoization table to store the results of subproblems.\\n        vector<vector<int>> memo(n, vector<int>(n, -1));\\n        \\n        return stoneGameHelper(a, prefixSum, memo, 0, n - 1);\\n    }\\n    \\n    int stoneGameHelper(vector<int>& a, vector<int>& prefixSum, vector<vector<int>>& memo, int left, int right) {\\n        if (left == right)\\n            return 0;\\n        \\n        if (memo[left][right] != -1)\\n            return memo[left][right];\\n        \\n        int result = 0;\\n        for (int i = left; i < right; ++i) {\\n            int leftSum = prefixSum[i + 1] - prefixSum[left];\\n            int rightSum = prefixSum[right + 1] - prefixSum[i + 1];\\n            \\n            if (leftSum < rightSum) {\\n                result = max(result, leftSum + stoneGameHelper(a, prefixSum, memo, left, i));\\n            } else if (leftSum > rightSum) {\\n                result = max(result, rightSum + stoneGameHelper(a, prefixSum, memo, i + 1, right));\\n            } else {\\n                // If leftSum and rightSum are equal, consider both divisions.\\n                result = max(result, leftSum + max(\\n                    stoneGameHelper(a, prefixSum, memo, left, i),\\n                    stoneGameHelper(a, prefixSum, memo, i + 1, right)\\n                ));\\n            }\\n        }\\n        \\n        memo[left][right] = result;\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& a) {\\n        int n = a.size();\\n        if (n == 1)\\n            return 0;\\n        \\n        // Calculate the prefix sum of the array for quick range sum queries.\\n        vector<int> prefixSum(n + 1, 0);\\n        for (int i = 0; i < n; ++i) {\\n            prefixSum[i + 1] = prefixSum[i] + a[i];\\n        }\\n        \\n        // Initialize the memoization table to store the results of subproblems.\\n        vector<vector<int>> memo(n, vector<int>(n, -1));\\n        \\n        return stoneGameHelper(a, prefixSum, memo, 0, n - 1);\\n    }\\n    \\n    int stoneGameHelper(vector<int>& a, vector<int>& prefixSum, vector<vector<int>>& memo, int left, int right) {\\n        if (left == right)\\n            return 0;\\n        \\n        if (memo[left][right] != -1)\\n            return memo[left][right];\\n        \\n        int result = 0;\\n        for (int i = left; i < right; ++i) {\\n            int leftSum = prefixSum[i + 1] - prefixSum[left];\\n            int rightSum = prefixSum[right + 1] - prefixSum[i + 1];\\n            \\n            if (leftSum < rightSum) {\\n                result = max(result, leftSum + stoneGameHelper(a, prefixSum, memo, left, i));\\n            } else if (leftSum > rightSum) {\\n                result = max(result, rightSum + stoneGameHelper(a, prefixSum, memo, i + 1, right));\\n            } else {\\n                // If leftSum and rightSum are equal, consider both divisions.\\n                result = max(result, leftSum + max(\\n                    stoneGameHelper(a, prefixSum, memo, left, i),\\n                    stoneGameHelper(a, prefixSum, memo, i + 1, right)\\n                ));\\n            }\\n        }\\n        \\n        memo[left][right] = result;\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245953,
                "title": "java-topdown-dp-prefix-sum-optimized-pruning-recursion-using-sum-of-geometric-sequence",
                "content": "Look for this key pruning idea to speed up recursion: if(2 x Math.min(l,r)<max) continue;  (the DP works without it but is much slower).\\nNo need to consider any branches with the sum smaller than the max score known so far, as for a given subset of stones with sum of values equal a, the total score cannot be bigger than 2a, by the rules of the game: in each turn the sum of stone values gets reduced by half or more. The total score\\'s upper bound can be calculated as a sum of the geometric sequence:\\nscore = a + a/2 + a/4 + a/8 + a/16 + ... = a x (1 + 1/2 + 1/4 + 1/8 + 1/16 + ...) = 2 x a\\n\\n\\n```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n= stoneValue.length;\\n        int[] ps= new int[n];\\n        ps[0]= stoneValue[0];\\n        for(int i=1; i<n; i++) ps[i]= ps[i-1]+stoneValue[i];\\n        return gameDP(ps, 0, n-1, new Integer[n][n]);\\n    }\\n\\n    private int gameDP(int[] ps, int i, int j, Integer[][] dp){\\n        if(i==j) return 0;\\n        if(dp[i][j]!=null) return dp[i][j];\\n        int max= 0;\\n        // k is the first stone in the right part\\n        for(int k= i+1; k<=j; k++){\\n            int l= ps[k-1]-(i==0?0:ps[i-1]);\\n            int r= ps[j]-ps[k-1];\\n            // key branch pruning idea to speed up recursion\\n            if(2*Math.min(l,r)<max) continue;\\n            if(l<=r) max= Math.max(max, l + gameDP(ps, i, k-1, dp));\\n            if(l>=r) max= Math.max(max, r + gameDP(ps, k, j, dp));\\n        }\\n        return dp[i][j]= max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n= stoneValue.length;\\n        int[] ps= new int[n];\\n        ps[0]= stoneValue[0];\\n        for(int i=1; i<n; i++) ps[i]= ps[i-1]+stoneValue[i];\\n        return gameDP(ps, 0, n-1, new Integer[n][n]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1504994,
                "title": "python-o-n-2-optimized-solution-o-n-3-cannot-pass",
                "content": "Python is slow sometimes!\\n\\nTraditional DP: \\n```\\nfor i in (0, length): \\n\\tfor j in (0, length): \\n\\t\\tfor k in (i, j): \\n\\t\\t\\tdp[i][j] = dp[i][k] + s[i][k]] or dp[k+1][j] + s[k+1][j]\\n```\\n\\nThe hardest thing for us to optimize the O(n^3) is finding a way to reduce the innest loop for k in (i, j), but it\\'s not sorted and no way to find which one is best, totaly irregular?\\n**However**, the lowest bound and hight bound of the cut index in (i, j) comes from the best cut in (i+1, j) and (i, j-1), **BECAUSE**\\n\\n**`best_cut[i][j-1] - 1 <= best_cut[i][j] <= best_cut[i+1][j] + 1`** \\n\\nYou can prove it by yourself.\\n\\nAdd a best cut array to optimize the O(n^3) solution, to make it **ALMOST O(n^2)**, the number of k from bestcut[i][j-1] to bestcut[i+1][j] is  ***almost a constant value averagly*** (depends on the values in list).\\n\\n\\n```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        length = len(stoneValue)\\n        if length == 1:\\n            return 0\\n        \\n\\t\\t# Calculate sum\\n        s = [0 for _ in range(length)]\\n        s[0] = stoneValue[0]\\n        for i in range(1, length):\\n            s[i] = s[i-1] + stoneValue[i]\\n\\t\\t\\n\\t\\t# dp for best value, best_cut for where is the cut in (i, j), i, j inclusive\\n        dp = [[0 for _ in range(length)] for _ in range(length)]\\n        best_cut = [[0 for _ in range(length)] for _ in range(length)]\\n        \\n        for i in range(0, length-1):\\n            dp[i][i+1] = min(stoneValue[i], stoneValue[i+1])\\n            best_cut[i][i+1] = i\\n            \\n        for t in range(2, length):\\n            for i in range(0, length-t):\\n                tmp_dp = 0\\n                tmp_cut = 0\\n                left_bound = best_cut[i][i+t-1]\\n                if left_bound > i:\\n                    left_bound -= 1\\n                right_bound = best_cut[i+1][i+t]\\n                if right_bound < i+t-1:\\n                    right_bound += 1\\n                    \\n                for k in range(left_bound, 1+right_bound):\\n                    s1 = s[k] - s[i-1] if i > 0 else s[k]\\n                    s2 = s[i+t] - s[k]\\n                    if s1 < s2:\\n                        tmp = s1 + dp[i][k]\\n                        if tmp > tmp_dp:\\n                            tmp_dp = tmp\\n                            tmp_cut = k\\n                    elif s1 > s2:\\n                        tmp = s2 + dp[k+1][i+t]\\n                        if tmp > tmp_dp:\\n                            tmp_dp = tmp\\n                            tmp_cut = k\\n                    else:\\n                        tmp1 = s1 + dp[i][k]\\n                        tmp2 = s2 + dp[k+1][i+t]\\n                        if tmp1 > tmp_dp:\\n                            tmp_dp = tmp1\\n                            tmp_cut = k\\n                        if tmp2 > tmp_dp:\\n                            tmp_dp = tmp2\\n                            tmp_cut = k\\n        \\n                dp[i][i+t] = tmp_dp\\n                best_cut[i][i+t] = tmp_cut\\n                \\n        return dp[0][length-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nfor i in (0, length): \\n\\tfor j in (0, length): \\n\\t\\tfor k in (i, j): \\n\\t\\t\\tdp[i][j] = dp[i][k] + s[i][k]] or dp[k+1][j] + s[k+1][j]\\n```\n```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        length = len(stoneValue)\\n        if length == 1:\\n            return 0\\n        \\n\\t\\t# Calculate sum\\n        s = [0 for _ in range(length)]\\n        s[0] = stoneValue[0]\\n        for i in range(1, length):\\n            s[i] = s[i-1] + stoneValue[i]\\n\\t\\t\\n\\t\\t# dp for best value, best_cut for where is the cut in (i, j), i, j inclusive\\n        dp = [[0 for _ in range(length)] for _ in range(length)]\\n        best_cut = [[0 for _ in range(length)] for _ in range(length)]\\n        \\n        for i in range(0, length-1):\\n            dp[i][i+1] = min(stoneValue[i], stoneValue[i+1])\\n            best_cut[i][i+1] = i\\n            \\n        for t in range(2, length):\\n            for i in range(0, length-t):\\n                tmp_dp = 0\\n                tmp_cut = 0\\n                left_bound = best_cut[i][i+t-1]\\n                if left_bound > i:\\n                    left_bound -= 1\\n                right_bound = best_cut[i+1][i+t]\\n                if right_bound < i+t-1:\\n                    right_bound += 1\\n                    \\n                for k in range(left_bound, 1+right_bound):\\n                    s1 = s[k] - s[i-1] if i > 0 else s[k]\\n                    s2 = s[i+t] - s[k]\\n                    if s1 < s2:\\n                        tmp = s1 + dp[i][k]\\n                        if tmp > tmp_dp:\\n                            tmp_dp = tmp\\n                            tmp_cut = k\\n                    elif s1 > s2:\\n                        tmp = s2 + dp[k+1][i+t]\\n                        if tmp > tmp_dp:\\n                            tmp_dp = tmp\\n                            tmp_cut = k\\n                    else:\\n                        tmp1 = s1 + dp[i][k]\\n                        tmp2 = s2 + dp[k+1][i+t]\\n                        if tmp1 > tmp_dp:\\n                            tmp_dp = tmp1\\n                            tmp_cut = k\\n                        if tmp2 > tmp_dp:\\n                            tmp_dp = tmp2\\n                            tmp_cut = k\\n        \\n                dp[i][i+t] = tmp_dp\\n                best_cut[i][i+t] = tmp_cut\\n                \\n        return dp[0][length-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217264,
                "title": "is-this-question-not-meant-for-python",
                "content": "```\\nI have submitted most optimized code but even that one gives TLE in python.\\n```",
                "solutionTags": [],
                "code": "```\\nI have submitted most optimized code but even that one gives TLE in python.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1134074,
                "title": "java-solution-using-mcm-matrix-chain-multiplication-and-prefix-sum",
                "content": "\\'\\'\\' \\nclass Solution {\\n    public int stoneGameV(int[] s) {\\n        \\n        int pre[]=new int[s.length];\\n        pre[0]=s[0];\\n\\t\\t// calculate prefix sum\\n        for(int i=1;i<s.length;i++)\\n        {\\n            pre[i]=pre[i-1]+s[i];\\n        }\\n        \\n        int dp[][]=new int[501][501];\\n        for(int i=0;i<dp.length;i++)\\n            Arrays.fill(dp[i],-1);\\n        \\n        return solve(s,pre,0,s.length-1,dp);\\n        \\n        \\n    }\\n    \\n    public int solve(int a[],int pre[],int i,int j,int dp[][])\\n    {\\n        // if only one element left, we dont have any options\\n        if(i>=j)\\n            return 0;\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n\\t\\t\\n        int ans=0;  // global ans\\n        for(int k=i;k<j;k++)\\n        {\\n            int op1=0,op2=0;\\n            // i-k  , k+1,j\\n            int temp=0;\\n            \\n            op1= i==0?pre[k]: pre[k]-pre[i-1]; \\n            op2= pre[j]-pre[k];\\n            \\n            if(op1<op2) // take minimum of two options\\n            {\\n                temp=op1+solve(a,pre,i,k,dp);\\n            }\\n            else if(op2<op1)\\n            {\\n                temp=op2+solve(a,pre,k+1,j,dp);\\n            }\\n            else\\n            {\\n\\t\\t\\t   // if both are equal then explore both options and choose best one\\n                temp=Math.max(op1+solve(a,pre,i,k,dp),op2+solve(a,pre,k+1,j,dp)); \\n            }\\n            \\n\\t\\t\\t// update global ans\\n            ans=Math.max(ans,temp);\\n        }\\n        \\n        return dp[i][j]=ans;\\n        \\n        \\n    }\\n    \\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int stoneGameV(int[] s) {\\n        \\n        int pre[]=new int[s.length];\\n        pre[0]=s[0];\\n\\t\\t// calculate prefix sum\\n        for(int i=1;i<s.length;i++)\\n        {\\n            pre[i]=pre[i-1]+s[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 910774,
                "title": "c-recursion-to-dp-intitutive-way",
                "content": "```\\nclass Solution {\\npublic:\\n    //map<pair<int,int>,int>mp;\\n    //I got tle using map\\n    \\n    int memo[501][501];\\n    int score(vector<int>&nums,int st,int end)\\n    {\\n        if(st>=end)return 0;\\n        int ans=0;\\n        //if(mp.find({st,end})!=mp.end())return mp[{st,end}];\\n        if(memo[st][end]!=-1)return memo[st][end];\\n        for(int i=st;i<end;i++)\\n        {\\n            // Breek it in [st,i] and [i+1,end]  ...both should be non -empty\\n            int lSum,rSum;\\n            if(st==0)\\n            {\\n                lSum=nums[i];\\n            }\\n            else\\n            lSum=nums[i]-nums[st-1];  // st to i\\n            rSum=nums[end]-nums[i];  // i+1 to end\\n            \\n            if(lSum>rSum)\\n            {\\n                ans=max(ans,rSum+score(nums,i+1,end));\\n            }\\n            else if(lSum==rSum)\\n            {\\n                ans=max(ans,max(lSum+score(nums,st,i),rSum+score(nums,i+1,end)));\\n            }\\n            else\\n            {\\n                ans=max(ans,lSum+score(nums,st,i));\\n            }\\n        }\\n       // return mp[{st,end}]= ans;\\n        return memo[st][end]=ans;\\n    }\\n    \\n    //?????????? Recursive Code ?????????\\n    \\n//     int score(vector<int>&nums,int st,int end)\\n//     {\\n//         if(st>=end)return 0;\\n//         int ans=0;\\n//         for(int i=st;i<end;i++)\\n//         {\\n//             int lSum,rSum;\\n//             if(st==0)\\n//             {\\n//                 lSum=nums[i];\\n//             }\\n//             else\\n//             lSum=nums[i]-nums[st-1];  // st to i\\n//             rSum=nums[end]-nums[i];  // i+1 to end\\n            \\n//             if(lSum>rSum)\\n//             {\\n//                 ans=max(ans,rSum+score(nums,i+1,end));\\n//             }\\n//             else if(lSum==rSum)\\n//             {\\n//                 ans=max(ans,max(lSum+score(nums,st,i),rSum+score(nums,i+1,end)));\\n//             }\\n//             else\\n//             {\\n//                 ans=max(ans,lSum+score(nums,st,i));\\n//             }\\n//         }\\n//         return ans;\\n//     }\\n    \\n    \\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n=stoneValue.size();\\n        vector<int>freq(n,0);\\n        freq[0]=stoneValue[0];\\n        memset(memo,-1,sizeof(memo));\\n        for(int i=1;i<n;i++)\\n        {\\n            freq[i]+=stoneValue[i]+freq[i-1];  // It\\'s good to have prefix array to calculate rangeSum in o(1)after one time implementation ,will use in recursive function\\n        }\\n        return score(freq,0,n-1);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    //map<pair<int,int>,int>mp;\\n    //I got tle using map\\n    \\n    int memo[501][501];\\n    int score(vector<int>&nums,int st,int end)\\n    {\\n        if(st>=end)return 0;\\n        int ans=0;\\n        //if(mp.find({st,end}",
                "codeTag": "Java"
            },
            {
                "id": 3564487,
                "title": "cpp-dynamic-programming-memoisation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs problem gives us option to choose which part to throw , this gives the intuition that we try all the possibilities and hence dp can be used to memoise those states. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) first calculate the prefix sum of the given vector (stoneValue) .\\n2) then divide the stoneValue vector at each index i , such that\\n   the left part is from   start ..... i  \\n   the right part is from  i+1 ...... end \\n    \\n  ```\\n  for(int i=start;i<=end;i++)\\n{ \\n   leftSum = pref[i]-pref[start-1]  (when start>0)\\n            pref[i]          (when start==0)\\n \\n   rightSum=pref[end]-pref[i]\\n\\n   //next function calls depending upon leftSum and rightSum\\n}\\n  \\n```\\n\\n3) if leftSum is greater then we add remaining part (rightSum) to  the  score and make next call with start=i+1 and end=end\\n4) if rightSum is greater then we add remaining part (leftSum) to the score and make next call with start=start and end=i\\n5) if leftSum is equal to rightSum then add this value(rightSum or leftSum as both are equal ) to score and make two calls \\n   i) first one  with start=start and end=i\\n   ii) second one with start=i+1 and end =end \\n6) base case is when single element is remaining .\\n\\n \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n   int dp[501][501];\\n\\n    int solve(int start,int end,vector<int>&stoneValue,vector<int>&pref)\\n    {\\n          if(end==start) return 0;\\n          if(end<start)return 0;\\n        \\n        if(dp[start][end]!=-1)return dp[start][end];\\n\\n          int score=0;  \\n           for(int i=start;i<=end;i++)\\n           {\\n               int lf=(start==0)?pref[i]:pref[i]-pref[start-1]; //leftSum\\n               int rf=pref[end]-pref[i];   //rightSum\\n  \\n             \\n               if(lf>rf)\\n               {\\n                   int val=rf+solve(i+1,end,stoneValue,pref);\\n                   score=max(score,val);\\n               }\\n               else if(rf>lf)\\n               {\\n                   int val=lf+solve(start,i,stoneValue,pref);\\n                   score=max(score,val);\\n               }\\n               else{\\n                     int val1=lf+solve(start,i,stoneValue,pref);\\n                     int val2=rf+solve(i+1,end,stoneValue,pref);\\n                     int mx=max(val1,val2);\\n                     score=max(score,mx);\\n               }\\n           }\\n\\n           return dp[start][end]=score;\\n    }\\n\\n    int stoneGameV(vector<int>& stoneValue) {\\n         \\n         memset(dp,-1,sizeof(dp));\\n\\n         vector<int>pref(stoneValue.size()+1,0);\\n         pref[0]=stoneValue[0];\\n\\n         for(int i=1;i<stoneValue.size();i++)\\n         {\\n                pref[i]=pref[i-1]+stoneValue[i];\\n         }\\n\\n         return solve(0,(int)stoneValue.size()-1,stoneValue,pref);\\n           \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n  for(int i=start;i<=end;i++)\\n{ \\n   leftSum = pref[i]-pref[start-1]  (when start>0)\\n            pref[i]          (when start==0)\\n \\n   rightSum=pref[end]-pref[i]\\n\\n   //next function calls depending upon leftSum and rightSum\\n}\\n  \\n```\n```\\nclass Solution {\\npublic:\\n\\n   int dp[501][501];\\n\\n    int solve(int start,int end,vector<int>&stoneValue,vector<int>&pref)\\n    {\\n          if(end==start) return 0;\\n          if(end<start)return 0;\\n        \\n        if(dp[start][end]!=-1)return dp[start][end];\\n\\n          int score=0;  \\n           for(int i=start;i<=end;i++)\\n           {\\n               int lf=(start==0)?pref[i]:pref[i]-pref[start-1]; //leftSum\\n               int rf=pref[end]-pref[i];   //rightSum\\n  \\n             \\n               if(lf>rf)\\n               {\\n                   int val=rf+solve(i+1,end,stoneValue,pref);\\n                   score=max(score,val);\\n               }\\n               else if(rf>lf)\\n               {\\n                   int val=lf+solve(start,i,stoneValue,pref);\\n                   score=max(score,val);\\n               }\\n               else{\\n                     int val1=lf+solve(start,i,stoneValue,pref);\\n                     int val2=rf+solve(i+1,end,stoneValue,pref);\\n                     int mx=max(val1,val2);\\n                     score=max(score,mx);\\n               }\\n           }\\n\\n           return dp[start][end]=score;\\n    }\\n\\n    int stoneGameV(vector<int>& stoneValue) {\\n         \\n         memset(dp,-1,sizeof(dp));\\n\\n         vector<int>pref(stoneValue.size()+1,0);\\n         pref[0]=stoneValue[0];\\n\\n         for(int i=1;i<stoneValue.size();i++)\\n         {\\n                pref[i]=pref[i-1]+stoneValue[i];\\n         }\\n\\n         return solve(0,(int)stoneValue.size()-1,stoneValue,pref);\\n           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1754938,
                "title": "o-n-2-a-hopefully-confusion-free-intuitive-explanation",
                "content": "### Intuitive brute force\\nIt is quite simple to com up with O(N^3) solution. Say we have input array size 8, `[1,7,3,5,2,9,4,7]`, we can just try to \"cut\" the line at all the possible places\\n\\n```\\n[1, | 7,3,5,2,9,4,7]\\n[1,7, | 3,5,2,9,4,7]\\n[1,7,3, | 5,2,9,4,7]\\n...\\n```\\nFor each cut, we calculate which half is bigger, and we dump the bigger one and keep the smaller one. If equal, we need to continue on both half. This tells us we need **prefix sum** to easily get which half is bigger.\\n\\nAlso since for each cut we will divide the problem into smaller question (for example for our case, after we, say, cut between 3rd and 4th number, we will need to check how many scores can `[1,7,3]` gives us). This **natually lead us to DP**.\\n\\nSay we have a N x N array `resTable` (this will be our \"DP\" table), where N is the size of input array. \\n\\nThe meaning of `resTable` is `resTable[i][j] = if the input array is only from ith element to jth element, what max score can Alice get from it`. Note that the final answer we want is `resTable[0][inputarray.size() - 1]`\\n\\nLet\\'s say we cut the line at the right side of `k`th element. \\n\\n```\\n[1,2,5,7  | (cut)  8,9,4]\\n7 is the kth element\\n```\\n\\nAlso, I will use `sum[i to j]` to represent the sum of input array from ith element to jth element (`sum[i to j] = inputarray[i] + inputarray[i + 1] + ... + inputarray[j]`)\\n\\nthen \\n```\\nfor each k between i and j\\n\\tif (leftHalf is smaller) resTable[i][j] = sum[i to k] + resTable[i][k] (recall `k` is where we cut the line)\\n\\telse if (rightHalf is smaller) resTable[i][j] = sum[k + 1 to j] + resTable[k + 1][j]\\n```\\n\\nWe have a N x N `resTable` (aka the DP table) and for each element in `resTable[i][j]`, we need to iterate through `i` and `j` to that find THE `k`th element so it gives us the best score. So the time complexity is `O(N x N) x O(N) =  O(N^3)`\\n\\n### Optimize to O(N^2)\\nWhile hand writing some examples, it occurs to me that if I cut the line from left to right, at some point, left half will always be bigger than right half as we move our cut to right.\\n\\nFor example\\n`[1,2,3,4,5,6,7]`, after I cut at the right side of 5 `[1, 2, 3, 4, 5  |  6, 7]`, left half will always be bigger than right side. What this tells us is that once we find this \"flip point\", all the cuts we made on the left side of this flip point will result in right half being dumped, while all the cuts we made on the right side of this flip point will result in left half being dumped. \\n\\nFurther, I think we can give this \"flip point\" a more intuitive name: **\"bad luck number\"**\\n\\nWhy? Because if the left half includes this bad luck number, then left half will be dumped (because left half now is bigger than right half). Similarly, if right half includes this bad luck number, then right half will be dumped (because this time, right half is bigger than left half). Whicever half includes this number will be dumped, this number brings bad luck to us. (There is one exception though. When left half and right half are equal, it is \"ok\" for left half to include this bad luck number, but still, i think this name can help you understand the main idea of this method).\\n\\n`[3, 6, 5, 2]` -> 6 is the bad luck number, if left half keeps it, then left half becomes 9 (3 + 6) which is bigger than right half (5 + 2), left half got dumped. On the other hand, if right half keeps 6, then left half is 3, right half is 6 + 5 + 2, right half is bigger, dumped\\n`[10,1,2,3]` -> 10 is the bad luck number, if left half keeps it, left half will be 10 and right half will be 6, and left half will be dumped. But of course in this case, left half has to keep 10 becasue Alice cannot cut an empty row out.\\n`\\'[3,6,5,4]` -> 6 is the bad luck number now, but since left half and right half are equal, so it is ok for left half to include this bad luck number. If you feel bad luck number is hard to understand for \"left == right\" case, don\\'t think about it too hard, we will cover this \"edge case\" later.\\n\\nWith this idea, I was wondering if finding all back luck number (or bad luck index, to be more precise) for each `i to j` subarray can be helpful?\\n\\nWhat this bad luck number tells us is that \\n- if you make a cut left to this bad luck number, it is guaranteed the best score comes from left half (and safe to dump right half)\\n- if you make a cut right to this bad luck number, it is guaranteed the best score comes from right half (and safe to dump left half)\\n\\nOr more intuitively:\\n\\n```\\nresTable[i][j] = max(\\n\\tthe best score Alice can get if she made a cut LEFT to bad luck number,\\n\\tthe best score Alice can get if she made a cut RIGHT to bad luck number,\\n);\\n(let\\'s not consider lefthalf == righthalf case just yet)\\n```\\n\\nYou might think: even though Alice can make a cut LEFT to bad luck number, she still needs to cut the line on the left at all possible positions, this is still O(N^3) right?\\n\\nWell, you are right, she still needs to try all possible positions to the left of bad luck number, BUT can we have an extra data strcture so that it can give us `the best score Alice can get if she made a cut LEFT to bad luck number` in constant time??\\n\\nBasically we want a `leftBest` and `rightBest`, so that\\n\\n`leftBest[i][j] = the best score Alice can get if she made a cut in range of [i, j] and only keep the LEFT half and dump the RIGHT half`\\n`rightBest[i][j] = the best score Alice can get if she made a cut in range of [i, j] and only keep the RIGHT half, dump the LEFT half`\\n\\nThen suddenly our `resTable[i][j]` becomes\\n```\\nresTable[i][j] = max(\\n\\tleftBest[i][bad luck number index - 1],\\n\\trightBest[bad luck number index + 1][j],\\n)\\n```\\n\\nAt here, if `leftHalf == rightHalf`, then we only have a slightly different equation:\\n\\n```\\nresTable[i][j] = max(\\n\\tleftBest[i][bad luck number index], // because including bad luck number only makes left half and right half equal, no one gets dumped yet, so we still include it in left half.\\n\\trightBest[bad luck number index + 1][j], // yes, rightBest equation remains the same\\n)\\n```\\n\\nNote that thanks to bad luck number, if we cut on left side of bad luck number, it is always safe to assume we can dump right half and keep the left half! And similarly, if we cut on the right side of bad luck number, it is also safe to dump the left half and keep the right half!\\n\\nSo we only have one question now, how do we update `leftBest` and `rightBest`? Well it is actually simple:\\n\\n```\\nleftBest[i][j] = max(\\n\\tleftBest[i][j - 1], // the best score we can get from i to j - 1\\n\\tsum[i to j] + resTable[i][j] // or maybe after including the jth element, we can have a higher score?\\n)\\n```\\n\\nIf you are wondering why we are not adding `leftBest[i + 1][j]` to the comparison... This is because what `leftBest[i + 1][j]` means is if we cut between `i + 1 to j`, what best score can we get. Let\\'s say we cut at k, then `i + 1 to k` will be kept and the right half will be dumped. `i + 1 to k` DOES NOT INCLUDE `i`, while you are calculating `leftBest[i][j]` here - you have to include `i`, so `leftBest[i + 1][j]` should not be considered.\\n\\n`rightBest` will be similar.\\n\\n```\\nrightBest[i][j] = max(\\n\\trightBest[i + 1][j], // the best score we can get from i + 1 to j\\n\\tsum[i to j] + resTable[i][j] // or maybe after including the ith element, we can have a higher score?\\n)\\n```\\n\\nNow we have everything we need to get to this O(N^2) answer\\n1. for all `i` and `j` where `0 <= i <= j <= input array size - 1`, find its bad luck number (O(N^2))\\n2. convert input array to prefix sum format so it is easier for us to calculate `sum[i to j]` (linear)\\n3. initialize `resTable[i][i]`, initialize `leftBest and rightBest` (linear)\\n4. traverse `resTable` **bottom up**, row by row (O(N^2))\\n\\nCode in C++:\\n```\\nclass Solution {\\npublic:\\n    struct BadLuck {\\n        int index;\\n        bool halfEqual;\\n    };\\n    int stoneGameV(vector<int>& stoneValue) {\\n        if (stoneValue.size() == 1) return 0;\\n        \\n        vector<vector<int>> resTable(stoneValue.size(), vector<int>(stoneValue.size()));\\n        // initailize res table (DP table)\\n        for (int row = 0; row < stoneValue.size(); ++row) {\\n            resTable[row][row] = stoneValue[row];\\n            if (row + 1 < stoneValue.size()) resTable[row][row + 1] = min(stoneValue[row], stoneValue[row + 1]);\\n        }\\n        \\n        // find all subarray\\'s badluck\\n        vector<vector<BadLuck>> badlucks(stoneValue.size(), vector<BadLuck>(stoneValue.size()));\\n        for (int row = 0; row < stoneValue.size() - 2; ++row) {\\n            int left = row; // points to the first num so that leftSum >= rightSum\\n            \\n            int leftSum = stoneValue[left];\\n            int rightSum = 0;\\n            \\n            if (stoneValue[left] < stoneValue[left + 1]) {\\n                ++left;\\n                leftSum += stoneValue[left];\\n            } else {\\n                rightSum = stoneValue[left + 1];\\n            }\\n            \\n            badlucks[row][row + 1] = {left, stoneValue[left] == stoneValue[left + 1]};\\n            \\n            for (int right = row + 2; right < stoneValue.size(); ++right) {\\n                rightSum += stoneValue[right];\\n                if (leftSum > rightSum) {\\n                    badlucks[row][right] = {left, false};\\n                } else if (leftSum == rightSum) {\\n                    badlucks[row][right] = {left, true};\\n                } else {\\n                    while (left <= right and leftSum < rightSum) {\\n                        ++left;\\n                        leftSum += stoneValue[left];\\n                        rightSum -= stoneValue[left];\\n                    }\\n                    badlucks[row][right] = {left, leftSum == rightSum};\\n                }\\n            }\\n        }\\n        \\n        // initialize leftBest and rightBest\\n        vector<vector<int>> leftBest(stoneValue.size(), vector<int>(stoneValue.size()));\\n        vector<vector<int>> rightBest(stoneValue.size(), vector<int>(stoneValue.size()));\\n\\n        for (int row = 0; row < stoneValue.size(); ++row) {\\n            leftBest[row][row] = stoneValue[row];\\n            rightBest[row][row] = stoneValue[row];\\n            if (row + 1 < stoneValue.size()) {\\n                leftBest[row][row + 1] = stoneValue[row] + stoneValue[row + 1] + resTable[row][row + 1];\\n                rightBest[row][row + 1] = leftBest[row][row + 1];\\n            }\\n        }\\n        \\n        // convert stoneValue to prefix sum\\n        for (int i = 1; i < stoneValue.size(); ++i) {\\n            stoneValue[i] += stoneValue[i - 1];\\n        }\\n        \\n        // fill resTable and leftBest and rightBest\\n        for (int row = stoneValue.size() - 3; row >= 0; --row) {\\n            for (int col = row + 2; col < stoneValue.size(); ++col) {\\n                auto badluck = badlucks[row][col];\\n                int badluckIndex = badluck.index;\\n                \\n                // if left half remians, what is the best score we can get from it if we cut a line in it\\n                int leftBestScore = 0;\\n                if (badluck.halfEqual) leftBestScore = leftBest[row][badluckIndex];\\n                else if (badluckIndex > 0) leftBestScore = leftBest[row][badluckIndex - 1];\\n                \\n                // if right half remians, what is the best score we can get from it if we cut a line in it\\n                int rightBestScore = 0;\\n                if (badluckIndex + 1 < stoneValue.size()) rightBestScore = rightBest[badluckIndex + 1][col];\\n                \\n                resTable[row][col] = max(leftBestScore, rightBestScore);\\n                \\n                leftBest[row][col] = max(\\n                    leftBest[row][col - 1], \\n                    (stoneValue[col] - (row > 0 ? stoneValue[row - 1] : 0)) + resTable[row][col]\\n                );\\n                rightBest[row][col] = max(\\n                    rightBest[row + 1][col], \\n                    (stoneValue[col] - (row > 0 ? stoneValue[row - 1] : 0)) + resTable[row][col]\\n                );\\n            }\\n        }\\n        \\n        return resTable[0][stoneValue.size() - 1];\\n    }\\n};\\n```\\n\\nHope this helps\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n[1, | 7,3,5,2,9,4,7]\\n[1,7, | 3,5,2,9,4,7]\\n[1,7,3, | 5,2,9,4,7]\\n...\\n```\n```\\n[1,2,5,7  | (cut)  8,9,4]\\n7 is the kth element\\n```\n```\\nfor each k between i and j\\n\\tif (leftHalf is smaller) resTable[i][j] = sum[i to k] + resTable[i][k] (recall `k` is where we cut the line)\\n\\telse if (rightHalf is smaller) resTable[i][j] = sum[k + 1 to j] + resTable[k + 1][j]\\n```\n```\\nresTable[i][j] = max(\\n\\tthe best score Alice can get if she made a cut LEFT to bad luck number,\\n\\tthe best score Alice can get if she made a cut RIGHT to bad luck number,\\n);\\n(let\\'s not consider lefthalf == righthalf case just yet)\\n```\n```\\nresTable[i][j] = max(\\n\\tleftBest[i][bad luck number index - 1],\\n\\trightBest[bad luck number index + 1][j],\\n)\\n```\n```\\nresTable[i][j] = max(\\n\\tleftBest[i][bad luck number index], // because including bad luck number only makes left half and right half equal, no one gets dumped yet, so we still include it in left half.\\n\\trightBest[bad luck number index + 1][j], // yes, rightBest equation remains the same\\n)\\n```\n```\\nleftBest[i][j] = max(\\n\\tleftBest[i][j - 1], // the best score we can get from i to j - 1\\n\\tsum[i to j] + resTable[i][j] // or maybe after including the jth element, we can have a higher score?\\n)\\n```\n```\\nrightBest[i][j] = max(\\n\\trightBest[i + 1][j], // the best score we can get from i + 1 to j\\n\\tsum[i to j] + resTable[i][j] // or maybe after including the ith element, we can have a higher score?\\n)\\n```\n```\\nclass Solution {\\npublic:\\n    struct BadLuck {\\n        int index;\\n        bool halfEqual;\\n    };\\n    int stoneGameV(vector<int>& stoneValue) {\\n        if (stoneValue.size() == 1) return 0;\\n        \\n        vector<vector<int>> resTable(stoneValue.size(), vector<int>(stoneValue.size()));\\n        // initailize res table (DP table)\\n        for (int row = 0; row < stoneValue.size(); ++row) {\\n            resTable[row][row] = stoneValue[row];\\n            if (row + 1 < stoneValue.size()) resTable[row][row + 1] = min(stoneValue[row], stoneValue[row + 1]);\\n        }\\n        \\n        // find all subarray\\'s badluck\\n        vector<vector<BadLuck>> badlucks(stoneValue.size(), vector<BadLuck>(stoneValue.size()));\\n        for (int row = 0; row < stoneValue.size() - 2; ++row) {\\n            int left = row; // points to the first num so that leftSum >= rightSum\\n            \\n            int leftSum = stoneValue[left];\\n            int rightSum = 0;\\n            \\n            if (stoneValue[left] < stoneValue[left + 1]) {\\n                ++left;\\n                leftSum += stoneValue[left];\\n            } else {\\n                rightSum = stoneValue[left + 1];\\n            }\\n            \\n            badlucks[row][row + 1] = {left, stoneValue[left] == stoneValue[left + 1]};\\n            \\n            for (int right = row + 2; right < stoneValue.size(); ++right) {\\n                rightSum += stoneValue[right];\\n                if (leftSum > rightSum) {\\n                    badlucks[row][right] = {left, false};\\n                } else if (leftSum == rightSum) {\\n                    badlucks[row][right] = {left, true};\\n                } else {\\n                    while (left <= right and leftSum < rightSum) {\\n                        ++left;\\n                        leftSum += stoneValue[left];\\n                        rightSum -= stoneValue[left];\\n                    }\\n                    badlucks[row][right] = {left, leftSum == rightSum};\\n                }\\n            }\\n        }\\n        \\n        // initialize leftBest and rightBest\\n        vector<vector<int>> leftBest(stoneValue.size(), vector<int>(stoneValue.size()));\\n        vector<vector<int>> rightBest(stoneValue.size(), vector<int>(stoneValue.size()));\\n\\n        for (int row = 0; row < stoneValue.size(); ++row) {\\n            leftBest[row][row] = stoneValue[row];\\n            rightBest[row][row] = stoneValue[row];\\n            if (row + 1 < stoneValue.size()) {\\n                leftBest[row][row + 1] = stoneValue[row] + stoneValue[row + 1] + resTable[row][row + 1];\\n                rightBest[row][row + 1] = leftBest[row][row + 1];\\n            }\\n        }\\n        \\n        // convert stoneValue to prefix sum\\n        for (int i = 1; i < stoneValue.size(); ++i) {\\n            stoneValue[i] += stoneValue[i - 1];\\n        }\\n        \\n        // fill resTable and leftBest and rightBest\\n        for (int row = stoneValue.size() - 3; row >= 0; --row) {\\n            for (int col = row + 2; col < stoneValue.size(); ++col) {\\n                auto badluck = badlucks[row][col];\\n                int badluckIndex = badluck.index;\\n                \\n                // if left half remians, what is the best score we can get from it if we cut a line in it\\n                int leftBestScore = 0;\\n                if (badluck.halfEqual) leftBestScore = leftBest[row][badluckIndex];\\n                else if (badluckIndex > 0) leftBestScore = leftBest[row][badluckIndex - 1];\\n                \\n                // if right half remians, what is the best score we can get from it if we cut a line in it\\n                int rightBestScore = 0;\\n                if (badluckIndex + 1 < stoneValue.size()) rightBestScore = rightBest[badluckIndex + 1][col];\\n                \\n                resTable[row][col] = max(leftBestScore, rightBestScore);\\n                \\n                leftBest[row][col] = max(\\n                    leftBest[row][col - 1], \\n                    (stoneValue[col] - (row > 0 ? stoneValue[row - 1] : 0)) + resTable[row][col]\\n                );\\n                rightBest[row][col] = max(\\n                    rightBest[row + 1][col], \\n                    (stoneValue[col] - (row > 0 ? stoneValue[row - 1] : 0)) + resTable[row][col]\\n                );\\n            }\\n        }\\n        \\n        return resTable[0][stoneValue.size() - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023888,
                "title": "python-top-down-dp-with-thinking-process",
                "content": "The first time Alice is picking, she needs to decide a cut point s.t. she get max score. The first intuision is we go through each potential cut point and find the most optimized score. The following is the code. \\n```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        def dfs(start, end):\\n            if start >= end:\\n                return 0\\n            max_score = 0\\n            # divides the array into [start,cut] and \\n            # [cur+1, end]\\n            for cut in range(start, end):\\n                sum1 = partial_sum[start][cut]\\n                sum2 = partial_sum[cut+1][end]\\n                # remaing part is [cut+1, end]\\n                if sum1 > sum2:\\n                    score = sum2+dfs(cut+1, end)\\n                # remaining part is [start, cut]\\n                elif sum1 < sum2:\\n                    score = sum1+dfs(start, cut)\\n                # two rows are equal\\n                else:\\n                    score = sum1+max(dfs(start, cut), dfs(cut+1, end))\\n                max_score = max(score, max_score)\\n            return max_score\\n                \\n        \\n        def getPartialSum():\\n            for i in range(n):\\n                partial_sum[i][i] = stoneValue[i]\\n            for i in range(n):\\n                for j in range(i+1, n):\\n                    partial_sum[i][j] = partial_sum[i][j-1]+stoneValue[j]\\n                               \\n            \\n        n = len(stoneValue)\\n        partial_sum = [[0]*n for _ in range(n)]\\n        getPartialSum()\\n        return dfs(0, n-1)\\n\\n```\\nGot TLE (Maybe it\\'s python. I found lots of similar solution by C++ or Java get passed). Need some optimization. The bottleneck is in the traverse of all the possible cut points, which cause the time complexity to be O(n^3). We need to do something about that. During thinking, I recall a similar speedup process in a question of throwing an egg from a building and to find the highest level that the egg won\\'t be broken (lc 887). In a word, the big direction is to apply binary search or linear search to find the cut point. However, this is exactly where I was stuck since there is no sorted property for the scores Alice can get for all the cut points. Which means, if Alice pick k or k+1, the relationship between scores(k) and scores(k+1) is not certain. \\nThen I looked for help in the discussion section. And this one is perfect: https://leetcode.com/problems/stone-game-v/discuss/911676/Java-O(n3)-O(n2-log-n)-and-O(n2)-with-explanation. It shows that my intuition is right, but I really need some further thinking. \\nThere is one missing sorted array, which is the array of previous sum of the scores (score represents number of stones, which is non-negative). And this is the place where we should apply binary search or linear search. However, how this relates to finding the optimized cut point? It turns out we need two extra arrays (left and right), recording calculated max scores of left part and right part. For example, left[i][j] records max scores of left part with cut points in the range of [i, j]. So if we use dfs(i, j) to represents the max scores Alice can get from i to j. left[i][j] = max(dfs(i, cut), i<=cut<j) and similarly, right[i][j]=max(dfs(cut, j) i<=cut<j). With the two arrays, we are ready to calculate dfs(i, j):\\n1. We first find smallest point c s.t. sum from i to c (sum1) is larger than or equal to sum from c+1 to end (sum2).\\n2.  We may have three situations: \\n\\t* \\tsum1 < sum2. That is to say, no matter how we cut, the remaining will always be the left part of the cut. So dfs(i,j)=left(i,j-1) (we need at least one pile of stones allocated to the right part)\\n\\t* \\tsum1 = sum2. If we cut before c, remaining will be the left part. If we cut after c, it will be the right part. If we cut at c, both parts can be the remaining. Thus, dfs(i,j) = max(left(i, c), right(c+1, j))\\n\\t* \\tsum1 > sum2. If we cut after c, remaining will be the right part. And since c is the first idx s.t. sum1>sum2, if we cut before c, remaining will be left part. Thus dfs(i,j) = max(left(i, c-1), right(c+1,j)). \\n\\nThe code is in below (only O(n) solution is presented)\\n```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        def getPartialSum():\\n            for i in range(n):\\n                partial_sum[i][i] = stoneValue[i]\\n            for i in range(n):\\n                for j in range(i+1, n):\\n                    partial_sum[i][j] = partial_sum[i][j-1]+stoneValue[j]\\n                               \\n        # (O(n) search)    \\n        def preCalCutIdx():\\n            # based on the fact that cut index is increasing with k for \\n            # partial_sum[start][k]\\n            for i in range(n-1):\\n                cp = i\\n                cut_index[i][i+1] = i\\n                for j in range(i+2, n):\\n                    while cp < j-1 and partial_sum[i][cp] < partial_sum[cp+1][j]:\\n                        cp += 1  \\n                    cut_index[i][j] = cp\\n\\t\\t\\n\\t\\t\\t\\n        @lru_cache(None)\\n        def dfs(start, end):\\n            if start >= end:\\n                return 0\\n            max_score = 0\\n            # find first cut s.t. left sum >= right sum \\n            cut = cut_index[start][end]\\n            # we can\\'t find cut s.t. left sum >= right sum\\n            if cut == -1:\\n                cut = end-1\\n            sum1 = partial_sum[start][cut]\\n            sum2 = partial_sum[cut+1][end]\\n            if sum1 < sum2:\\n                # calcuate left[start][cut] if not yet\\n                dfs(start, cut)\\n                # the remaining will be the left part for sure, no \\n                # matter where the cut is. \\n                max_score = left[start][cut]\\n            elif sum1 == sum2:\\n                dfs(start, cut)\\n                dfs(cut+1, end)\\n                # if real cut in the range of [cut+1, end], remaining will be the right part\\n                # if real cut in the range of [0, cut], remaing will be the left part\\n                # if real cut is cut, either can be the remaining. \\n                max_score = max(left[start][cut], right[cut+1][end])\\n            else:\\n                dfs(cut+1, end)\\n                # we are selecting the cut in the range of [cut, end] having \\n                # the max score. For cut in that range, the remaining is \\n                # the right part of the cut for sure. \\n                max_score = right[cut+1][end]\\n                if cut > start:\\n                    dfs(start, cut-1)\\n                    # we are selecting the cut in the range of [0, cut] having \\n                    # the max score. The remaining is the left part for sure. \\n                    max_score = max(max_score, left[start][cut-1])\\n            dfs(start, end-1)\\n            dfs(start+1, end)\\n            # updating left and right arrays. \\n            left[start][end] = max(left[start][end-1], partial_sum[start][end]+max_score)\\n            right[start][end] = max(right[start+1][end], partial_sum[start][end]+max_score)\\n            return max_score\\n            \\n        n = len(stoneValue)\\n        partial_sum = [[0]*n for _ in range(n)]\\n        cut_index = [[-1]*n for _ in range(n)]\\n        # left[i][j]: cut in the range of [i, j], max score of left part\\n        # right[i][j]: cut in the range of [i, j], max score of right part\\n        left = [[0]*n for _ in range(n)]\\n        right = [[0]*n for _ in range(n)]\\n        for i in range(n):\\n            left[i][i] = stoneValue[i]\\n            right[i][i] = stoneValue[i]\\n        getPartialSum()\\n        # for partial_sum[i][j], find cut index between i and j \\n        # s.t partial_sum[i][cut_index] >= partial_sum[cut_index+1][j] or \\n        # cut_index = j-1 if not exist. \\n        preCalCutIdx()\\n        return dfs(0, n-1)\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        def dfs(start, end):\\n            if start >= end:\\n                return 0\\n            max_score = 0\\n            # divides the array into [start,cut] and \\n            # [cur+1, end]\\n            for cut in range(start, end):\\n                sum1 = partial_sum[start][cut]\\n                sum2 = partial_sum[cut+1][end]\\n                # remaing part is [cut+1, end]\\n                if sum1 > sum2:\\n                    score = sum2+dfs(cut+1, end)\\n                # remaining part is [start, cut]\\n                elif sum1 < sum2:\\n                    score = sum1+dfs(start, cut)\\n                # two rows are equal\\n                else:\\n                    score = sum1+max(dfs(start, cut), dfs(cut+1, end))\\n                max_score = max(score, max_score)\\n            return max_score\\n                \\n        \\n        def getPartialSum():\\n            for i in range(n):\\n                partial_sum[i][i] = stoneValue[i]\\n            for i in range(n):\\n                for j in range(i+1, n):\\n                    partial_sum[i][j] = partial_sum[i][j-1]+stoneValue[j]\\n                               \\n            \\n        n = len(stoneValue)\\n        partial_sum = [[0]*n for _ in range(n)]\\n        getPartialSum()\\n        return dfs(0, n-1)\\n\\n```\n```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        def getPartialSum():\\n            for i in range(n):\\n                partial_sum[i][i] = stoneValue[i]\\n            for i in range(n):\\n                for j in range(i+1, n):\\n                    partial_sum[i][j] = partial_sum[i][j-1]+stoneValue[j]\\n                               \\n        # (O(n) search)    \\n        def preCalCutIdx():\\n            # based on the fact that cut index is increasing with k for \\n            # partial_sum[start][k]\\n            for i in range(n-1):\\n                cp = i\\n                cut_index[i][i+1] = i\\n                for j in range(i+2, n):\\n                    while cp < j-1 and partial_sum[i][cp] < partial_sum[cp+1][j]:\\n                        cp += 1  \\n                    cut_index[i][j] = cp\\n\\t\\t\\n\\t\\t\\t\\n        @lru_cache(None)\\n        def dfs(start, end):\\n            if start >= end:\\n                return 0\\n            max_score = 0\\n            # find first cut s.t. left sum >= right sum \\n            cut = cut_index[start][end]\\n            # we can\\'t find cut s.t. left sum >= right sum\\n            if cut == -1:\\n                cut = end-1\\n            sum1 = partial_sum[start][cut]\\n            sum2 = partial_sum[cut+1][end]\\n            if sum1 < sum2:\\n                # calcuate left[start][cut] if not yet\\n                dfs(start, cut)\\n                # the remaining will be the left part for sure, no \\n                # matter where the cut is. \\n                max_score = left[start][cut]\\n            elif sum1 == sum2:\\n                dfs(start, cut)\\n                dfs(cut+1, end)\\n                # if real cut in the range of [cut+1, end], remaining will be the right part\\n                # if real cut in the range of [0, cut], remaing will be the left part\\n                # if real cut is cut, either can be the remaining. \\n                max_score = max(left[start][cut], right[cut+1][end])\\n            else:\\n                dfs(cut+1, end)\\n                # we are selecting the cut in the range of [cut, end] having \\n                # the max score. For cut in that range, the remaining is \\n                # the right part of the cut for sure. \\n                max_score = right[cut+1][end]\\n                if cut > start:\\n                    dfs(start, cut-1)\\n                    # we are selecting the cut in the range of [0, cut] having \\n                    # the max score. The remaining is the left part for sure. \\n                    max_score = max(max_score, left[start][cut-1])\\n            dfs(start, end-1)\\n            dfs(start+1, end)\\n            # updating left and right arrays. \\n            left[start][end] = max(left[start][end-1], partial_sum[start][end]+max_score)\\n            right[start][end] = max(right[start+1][end], partial_sum[start][end]+max_score)\\n            return max_score\\n            \\n        n = len(stoneValue)\\n        partial_sum = [[0]*n for _ in range(n)]\\n        cut_index = [[-1]*n for _ in range(n)]\\n        # left[i][j]: cut in the range of [i, j], max score of left part\\n        # right[i][j]: cut in the range of [i, j], max score of right part\\n        left = [[0]*n for _ in range(n)]\\n        right = [[0]*n for _ in range(n)]\\n        for i in range(n):\\n            left[i][i] = stoneValue[i]\\n            right[i][i] = stoneValue[i]\\n        getPartialSum()\\n        # for partial_sum[i][j], find cut index between i and j \\n        # s.t partial_sum[i][cut_index] >= partial_sum[cut_index+1][j] or \\n        # cut_index = j-1 if not exist. \\n        preCalCutIdx()\\n        return dfs(0, n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812671,
                "title": "python3-o-n-2-beats-98",
                "content": "idx is the first point in [l, r]\\nwhere sum([l, idx]) > sum([idx + 1, r])\\n\\n\\tfrom functools import lru_cache\\n\\timport itertools\\n\\n\\n\\tclass Solution:\\n\\t\\tdef stoneGameV(self, A) -> int:\\n\\n\\t\\t\\tpre = [0] + list(itertools.accumulate(A))\\n\\n\\t\\t\\tn = len(A)\\n\\t\\t\\tidx = [[0] * n for _ in range(n)]\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tidx[i][i] = i\\n\\t\\t\\t\\tif i < n - 1:\\n\\t\\t\\t\\t\\tidx[i][i + 1] = i\\n\\t\\t\\tfor i in range(n - 2):\\n\\t\\t\\t\\tfor j in range(i + 2, n):\\n\\t\\t\\t\\t\\ttmp = idx[i][j - 1]\\n\\t\\t\\t\\t\\twhile pre[tmp + 1] - pre[i] < pre[j + 1] - pre[tmp + 1]:\\n\\t\\t\\t\\t\\t\\ttmp += 1\\n\\t\\t\\t\\t\\tidx[i][j] = tmp\\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef maxL(i, j):\\n\\t\\t\\t\\tif i == j: return A[i]\\n\\t\\t\\t\\treturn max(maxL(i, j - 1), pre[j + 1] - pre[i] + dp(i, j))\\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef maxR(i, j):\\n\\t\\t\\t\\tif i == j: return A[i]\\n\\t\\t\\t\\treturn max(maxR(i + 1, j), pre[j + 1] - pre[i] + dp(i, j))\\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef dp(i, j):\\n\\t\\t\\t\\tif i + 1 == j: return min(A[i], A[j])\\n\\t\\t\\t\\tmid = idx[i][j]\\n\\t\\t\\t\\tres = 0\\n\\t\\t\\t\\tif mid > i: res = max(res, maxL(i, mid - 1))\\n\\t\\t\\t\\tif mid < j: res = max(res, maxR(mid + 1, j))\\n\\t\\t\\t\\tif pre[j + 1] - pre[mid + 1] == pre[mid + 1] - pre[i]:\\n\\t\\t\\t\\t\\tres = max(res, maxL(i, mid), maxR(mid + 1, j))\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\treturn dp(0, n - 1)",
                "solutionTags": [],
                "code": "idx is the first point in [l, r]\\nwhere sum([l, idx]) > sum([idx + 1, r])\\n\\n\\tfrom functools import lru_cache\\n\\timport itertools\\n\\n\\n\\tclass Solution:\\n\\t\\tdef stoneGameV(self, A) -> int:\\n\\n\\t\\t\\tpre = [0] + list(itertools.accumulate(A))\\n\\n\\t\\t\\tn = len(A)\\n\\t\\t\\tidx = [[0] * n for _ in range(n)]\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tidx[i][i] = i\\n\\t\\t\\t\\tif i < n - 1:\\n\\t\\t\\t\\t\\tidx[i][i + 1] = i\\n\\t\\t\\tfor i in range(n - 2):\\n\\t\\t\\t\\tfor j in range(i + 2, n):\\n\\t\\t\\t\\t\\ttmp = idx[i][j - 1]\\n\\t\\t\\t\\t\\twhile pre[tmp + 1] - pre[i] < pre[j + 1] - pre[tmp + 1]:\\n\\t\\t\\t\\t\\t\\ttmp += 1\\n\\t\\t\\t\\t\\tidx[i][j] = tmp\\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef maxL(i, j):\\n\\t\\t\\t\\tif i == j: return A[i]\\n\\t\\t\\t\\treturn max(maxL(i, j - 1), pre[j + 1] - pre[i] + dp(i, j))\\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef maxR(i, j):\\n\\t\\t\\t\\tif i == j: return A[i]\\n\\t\\t\\t\\treturn max(maxR(i + 1, j), pre[j + 1] - pre[i] + dp(i, j))\\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef dp(i, j):\\n\\t\\t\\t\\tif i + 1 == j: return min(A[i], A[j])\\n\\t\\t\\t\\tmid = idx[i][j]\\n\\t\\t\\t\\tres = 0\\n\\t\\t\\t\\tif mid > i: res = max(res, maxL(i, mid - 1))\\n\\t\\t\\t\\tif mid < j: res = max(res, maxR(mid + 1, j))\\n\\t\\t\\t\\tif pre[j + 1] - pre[mid + 1] == pre[mid + 1] - pre[i]:\\n\\t\\t\\t\\t\\tres = max(res, maxL(i, mid), maxR(mid + 1, j))\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\treturn dp(0, n - 1)",
                "codeTag": "Java"
            },
            {
                "id": 806898,
                "title": "simple-dp-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int StoneGameV(int[] stoneValue)\\n    {\\n        int[] presum = new int[stoneValue.Length + 1];\\n        for (int i = 0; i < stoneValue.Length; i++)\\n        {\\n            presum[i + 1] = presum[i] + stoneValue[i];\\n        }\\n        return DFS(presum, 0, stoneValue.Length, new int[presum.Length, presum.Length]);\\n    }\\n\\n    private int DFS(int[] presum, int start, int end, int[,] memo)\\n    {\\n        if (start == end)\\n            return 0;\\n        if (memo[start, end] > 0)\\n            return memo[start, end];\\n        int max = 0;\\n        int cur = 0;\\n        for (int mid = start + 1; mid < end; mid++)\\n        {\\n            int left = presum[mid] - presum[start];\\n            int right = presum[end] - presum[mid];\\n            if (right > left)\\n                cur = left + DFS(presum, start, mid, memo);\\n            else if (right < left)\\n                cur = right + DFS(presum, mid, end, memo);\\n            else\\n                cur = Math.Max(right + DFS(presum, mid, end, memo), left + DFS(presum, start, mid, memo));\\n            max = Math.Max(max, cur);\\n        }\\n        memo[start, end] = max;\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int StoneGameV(int[] stoneValue)\\n    {\\n        int[] presum = new int[stoneValue.Length + 1];\\n        for (int i = 0; i < stoneValue.Length; i++)\\n        {\\n            presum[i + 1] = presum[i] + stoneValue[i];\\n        }\\n        return DFS(presum, 0, stoneValue.Length, new int[presum.Length, presum.Length]);\\n    }\\n\\n    private int DFS(int[] presum, int start, int end, int[,] memo)\\n    {\\n        if (start == end)\\n            return 0;\\n        if (memo[start, end] > 0)\\n            return memo[start, end];\\n        int max = 0;\\n        int cur = 0;\\n        for (int mid = start + 1; mid < end; mid++)\\n        {\\n            int left = presum[mid] - presum[start];\\n            int right = presum[end] - presum[mid];\\n            if (right > left)\\n                cur = left + DFS(presum, start, mid, memo);\\n            else if (right < left)\\n                cur = right + DFS(presum, mid, end, memo);\\n            else\\n                cur = Math.Max(right + DFS(presum, mid, end, memo), left + DFS(presum, start, mid, memo));\\n            max = Math.Max(max, cur);\\n        }\\n        memo[start, end] = max;\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806872,
                "title": "why-tle-on-o-n-3-dp-merging-intervals-c",
                "content": "Time Limit Exceeded on 131th  test case. During  contest I was hitting TLE continuously.\\nBut copying and pasting the larger test cases in custom input was working fine.\\n```\\nWhy there was no TLE when I was running the same test case using custom input? \\n```\\n\\n```\\nIn the discussion everyone\\'s solution is O(n^3) time comlexity, but why my O(n^3) is TLE? \\nIs this not O(n^3) or is there anything I am missing?\\n```\\nThanks for your help in advance :)\\n\\nHere is my C++ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    Solution()\\n    { ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0); }\\n    \\n    int stoneGameV(vector<int>& a) {\\n        \\n        int n=a.size(); if(n<=1) return 0;\\n        vector<int> pre(n,0); pre[0]=a[0];\\n        for(int i=1;i<n;i++) pre[i]=pre[i-1]+a[i];\\n        \\n        vector<vector<int> > dp(n, vector<int> (n,0));\\n        for(int j=1;j<n;j++)\\n        {\\n            for(int i=j-1;i>=0;i--)\\n            {\\n                int temp=0;\\n                for(int k=i;k<j;k++)\\n                {\\n                    int a1=pre[k]-(i-1>=0?pre[i-1]:0);\\n                    int a2=pre[j]-pre[k];\\n    \\n                    if(a1>a2)  temp=max(temp,a2+dp[k+1][j]);\\n                    if(a1<a2)  temp=max(temp,a1+dp[i][k]);\\n                    if(a1==a2) temp=max({temp,a1+dp[i][k],a2+dp[k+1][j] });\\n                }\\n                dp[i][j]=temp;\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nWhy there was no TLE when I was running the same test case using custom input? \\n```\n```\\nIn the discussion everyone\\'s solution is O(n^3) time comlexity, but why my O(n^3) is TLE? \\nIs this not O(n^3) or is there anything I am missing?\\n```\n```\\nclass Solution {\\npublic:\\n    Solution()\\n    { ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0); }\\n    \\n    int stoneGameV(vector<int>& a) {\\n        \\n        int n=a.size(); if(n<=1) return 0;\\n        vector<int> pre(n,0); pre[0]=a[0];\\n        for(int i=1;i<n;i++) pre[i]=pre[i-1]+a[i];\\n        \\n        vector<vector<int> > dp(n, vector<int> (n,0));\\n        for(int j=1;j<n;j++)\\n        {\\n            for(int i=j-1;i>=0;i--)\\n            {\\n                int temp=0;\\n                for(int k=i;k<j;k++)\\n                {\\n                    int a1=pre[k]-(i-1>=0?pre[i-1]:0);\\n                    int a2=pre[j]-pre[k];\\n    \\n                    if(a1>a2)  temp=max(temp,a2+dp[k+1][j]);\\n                    if(a1<a2)  temp=max(temp,a1+dp[i][k]);\\n                    if(a1==a2) temp=max({temp,a1+dp[i][k],a2+dp[k+1][j] });\\n                }\\n                dp[i][j]=temp;\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2350689,
                "title": "c-memoization",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    \\n    int fn(vector<int> &nums, int l, int r, int total, vector<vector<int>> &dp)\\n    {\\n        if(l>=r)            // Game ends here.\\n            return 0;\\n        if(dp[l][r]!=-1)    // This state was already precomputed.\\n            return dp[l][r];\\n        \\n        int sum = 0, ans = INT_MIN;\\n        for(int i=l;i<=r;i++)\\n        {\\n            sum+=nums[i];\\n            int leftsum = total - sum;\\n            \\n            if(sum < leftsum)   // left half sum  < right half sum\\n                ans = max(ans,sum + fn(nums,l,i,sum,dp));\\n            else if(sum > leftsum)  // right half sum < left half sum\\n                ans = max(ans,leftsum + fn(nums,i+1,r,leftsum,dp));\\n            else                // both sums are equal, so we can break them in any direction possible\\n                ans = max({ans, sum + fn(nums,l,i,sum,dp) , leftsum + fn(nums,i+1,r,leftsum,dp)});\\n        }\\n        return dp[l][r] = ans;\\n    }\\n    \\n    int stoneGameV(vector<int>& stoneValue) \\n    {\\n        int l = 0, r = stoneValue.size()-1, total = 0;\\n        vector<vector<int>> dp(stoneValue.size(), vector<int>(stoneValue.size(),-1));\\n        for(auto &e: stoneValue)\\n            total+=e;\\n        return fn(stoneValue, l, r, total,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    \\n    int fn(vector<int> &nums, int l, int r, int total, vector<vector<int>> &dp)\\n    {\\n        if(l>=r)            // Game ends here.\\n            return 0;\\n        if(dp[l][r]!=-1)    // This state was already precomputed.\\n            return dp[l][r];\\n        \\n        int sum = 0, ans = INT_MIN;\\n        for(int i=l;i<=r;i++)\\n        {\\n            sum+=nums[i];\\n            int leftsum = total - sum;\\n            \\n            if(sum < leftsum)   // left half sum  < right half sum\\n                ans = max(ans,sum + fn(nums,l,i,sum,dp));\\n            else if(sum > leftsum)  // right half sum < left half sum\\n                ans = max(ans,leftsum + fn(nums,i+1,r,leftsum,dp));\\n            else                // both sums are equal, so we can break them in any direction possible\\n                ans = max({ans, sum + fn(nums,l,i,sum,dp) , leftsum + fn(nums,i+1,r,leftsum,dp)});\\n        }\\n        return dp[l][r] = ans;\\n    }\\n    \\n    int stoneGameV(vector<int>& stoneValue) \\n    {\\n        int l = 0, r = stoneValue.size()-1, total = 0;\\n        vector<vector<int>> dp(stoneValue.size(), vector<int>(stoneValue.size(),-1));\\n        for(auto &e: stoneValue)\\n            total+=e;\\n        return fn(stoneValue, l, r, total,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940614,
                "title": "c-easy-to-understand-memoization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int> &v,int l,int r,vector<vector<int> > &dp)\\n    {\\n        if(dp[l][r]!=-1)\\n        return dp[l][r];\\n        int total=accumulate(v.begin()+l,v.begin()+r+1,0);\\n        int sum=0,res=0;  \\n        if(l>=r)\\n        return 0;\\n        for(int i=l;i<r;i++)\\n        {\\n            sum+=v[i];\\n            total-=v[i];\\n            if(sum<total)\\n            {\\n                res=max(res,sum+fun(v,l,i,dp));      \\n            }\\n            else if(sum>total)\\n            {\\n                res=max(res,total+fun(v,i+1,r,dp));\\n            }\\n            else\\n            {\\n                res=max(res,sum+max(fun(v,l,i,dp),fun(v,i+1,r,dp)));\\n            }\\n        }\\n        return dp[l][r]=res;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {       \\n        int n=stoneValue.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return fun(stoneValue,0,n-1,dp);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int> &v,int l,int r,vector<vector<int> > &dp)\\n    {\\n        if(dp[l][r]!=-1)\\n        return dp[l][r];\\n        int total=accumulate(v.begin()+l,v.begin()+r+1,0);\\n        int sum=0,res=0;  \\n        if(l>=r)\\n        return 0;\\n        for(int i=l;i<r;i++)\\n        {\\n            sum+=v[i];\\n            total-=v[i];\\n            if(sum<total)\\n            {\\n                res=max(res,sum+fun(v,l,i,dp));      \\n            }\\n            else if(sum>total)\\n            {\\n                res=max(res,total+fun(v,i+1,r,dp));\\n            }\\n            else\\n            {\\n                res=max(res,sum+max(fun(v,l,i,dp),fun(v,i+1,r,dp)));\\n            }\\n        }\\n        return dp[l][r]=res;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {       \\n        int n=stoneValue.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return fun(stoneValue,0,n-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280210,
                "title": "java-simple-and-easy-dp-memoization-solution-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    Integer[][] cache;\\n    \\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        \\n        cache = new Integer[n + 1][n + 1];\\n        \\n        //cumlative sum of stone values\\n        int[] prefixSum = new int[n + 1];\\n        for(int i = 0; i < n; i++){\\n            prefixSum[i + 1] = prefixSum[i] + stoneValue[i];\\n        }\\n\\n        return getAliceStore(prefixSum, 1, n);\\n    }\\n    \\n    private int getAliceStore(int[] prefixSum , int l, int r){\\n        if(l == r) return 0;\\n        \\n        //reterive from cache \\n        if(cache[l][r] != null) return cache[l][r];\\n        \\n        int maxScore = Integer.MIN_VALUE;\\n        for(int i = l; i <= r - 1; i++){\\n            int left  = prefixSum[i] - prefixSum[l - 1];\\n            int right = prefixSum[r] - prefixSum[i];\\n            \\n            if(left > right){\\n                //As right is smaller than left, Bob will select smaller sub row\\n                maxScore = Math.max(maxScore, right + getAliceStore(prefixSum, i + 1, r));\\n                \\n            }else if(left < right){\\n                //As left is smaller than right, Bob will select smaller sub row\\n                maxScore = Math.max(maxScore, left + getAliceStore(prefixSum, l, i));\\n                \\n            }else if(left == right){\\n                //lets Alice decide which row will be thrown away. \\n                maxScore = Math.max(maxScore, left + getAliceStore(prefixSum, l, i));\\n                maxScore = Math.max(maxScore, right + getAliceStore(prefixSum, i + 1, r));\\n            }\\n        }\\n        \\n        //save in cache  \\n        return cache[l][r]  = maxScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer[][] cache;\\n    \\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        \\n        cache = new Integer[n + 1][n + 1];\\n        \\n        //cumlative sum of stone values\\n        int[] prefixSum = new int[n + 1];\\n        for(int i = 0; i < n; i++){\\n            prefixSum[i + 1] = prefixSum[i] + stoneValue[i];\\n        }\\n\\n        return getAliceStore(prefixSum, 1, n);\\n    }\\n    \\n    private int getAliceStore(int[] prefixSum , int l, int r){\\n        if(l == r) return 0;\\n        \\n        //reterive from cache \\n        if(cache[l][r] != null) return cache[l][r];\\n        \\n        int maxScore = Integer.MIN_VALUE;\\n        for(int i = l; i <= r - 1; i++){\\n            int left  = prefixSum[i] - prefixSum[l - 1];\\n            int right = prefixSum[r] - prefixSum[i];\\n            \\n            if(left > right){\\n                //As right is smaller than left, Bob will select smaller sub row\\n                maxScore = Math.max(maxScore, right + getAliceStore(prefixSum, i + 1, r));\\n                \\n            }else if(left < right){\\n                //As left is smaller than right, Bob will select smaller sub row\\n                maxScore = Math.max(maxScore, left + getAliceStore(prefixSum, l, i));\\n                \\n            }else if(left == right){\\n                //lets Alice decide which row will be thrown away. \\n                maxScore = Math.max(maxScore, left + getAliceStore(prefixSum, l, i));\\n                maxScore = Math.max(maxScore, right + getAliceStore(prefixSum, i + 1, r));\\n            }\\n        }\\n        \\n        //save in cache  \\n        return cache[l][r]  = maxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134204,
                "title": "c-mcm-solution-easy-to-understand",
                "content": "```\\n\\t class Solution {\\npublic:\\n    vector<int> pre;\\n    vector<vector<int>> dp;\\n    int helper(vector<int>&arr,int i,int j){\\n        if(i>=j){ // base case , element should be atleat one to divide the array.\\n            return 0;\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int ans = INT_MIN/2;\\n        for(int k=i;k<j;k++){ // running loop to divide the array at each each position.\\n            int t1 = 0;\\n            int t2 = 0;\\n            int sum1 = (pre[j]-pre[k+1]+arr[k+1]); // sum of elements of  second partition array.\\n            int sum2 = (pre[k]-pre[i]+arr[i]); // sum of elements of first partition array.\\n            if(sum1>=sum2){  // According to question, we will throw the greater sum array and keep score of less sum array.\\n                t1 = helper(arr,i,k);\\n                ans = max(ans,sum2+t1);\\n            }\\n            if(sum1<=sum2){ // same here above.\\n                t2 = helper(arr,k+1,j);\\n                ans = max(ans,sum1+t2);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int stoneGameV(vector<int>& arr) {\\n        int n = arr.size();\\n        dp.assign(n,vector<int>(n,-1));\\n        pre.assign(n,0);\\n        pre[0] = arr[0];\\n        for(int i=1;i<n;i++){\\n            pre[i] = pre[i-1]+arr[i];\\n        }\\n        return helper(arr,0,n-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t class Solution {\\npublic:\\n    vector<int> pre;\\n    vector<vector<int>> dp;\\n    int helper(vector<int>&arr,int i,int j){\\n        if(i>=j){ // base case , element should be atleat one to divide the array.\\n            return 0;\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int ans = INT_MIN/2;\\n        for(int k=i;k<j;k++){ // running loop to divide the array at each each position.\\n            int t1 = 0;\\n            int t2 = 0;\\n            int sum1 = (pre[j]-pre[k+1]+arr[k+1]); // sum of elements of  second partition array.\\n            int sum2 = (pre[k]-pre[i]+arr[i]); // sum of elements of first partition array.\\n            if(sum1>=sum2){  // According to question, we will throw the greater sum array and keep score of less sum array.\\n                t1 = helper(arr,i,k);\\n                ans = max(ans,sum2+t1);\\n            }\\n            if(sum1<=sum2){ // same here above.\\n                t2 = helper(arr,k+1,j);\\n                ans = max(ans,sum1+t2);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int stoneGameV(vector<int>& arr) {\\n        int n = arr.size();\\n        dp.assign(n,vector<int>(n,-1));\\n        pre.assign(n,0);\\n        pre[0] = arr[0];\\n        for(int i=1;i<n;i++){\\n            pre[i] = pre[i-1]+arr[i];\\n        }\\n        return helper(arr,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925589,
                "title": "c-simple-dp-recursion-o-n-3-straightforward-easy-to-understand",
                "content": "<strong> pref </strong> is used to store prefix sum of the array.\\n<strong> dp[i][j]</strong> is used to store answer for subarray {i, i+1, i+2,....., j-1, j}\\n\\n```\\nclass Solution {\\npublic:\\n    vector< vector<long> > dp;\\n    vector< long> pref;\\n    \\n    int helper(int i, int j, vector<int> &val) {\\n        if(i>j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        long l=0, r= pref[j+1]-pref[i];\\n        long ans=0;\\n        for(int s=i; s<j; ++s){\\n            l+=val[s];\\n            r-=val[s];\\n            \\n            if(l==r) ans = max( ans, l+ max(helper(i, s, val), helper(s+1, j, val)));\\n            else if(l<r) ans= max(ans, l+ helper(i,s, val));\\n            else ans= max(ans, r+ helper(s+1, j, val));\\n        }\\n        \\n        return dp[i][j]=ans;\\n    }\\n    int stoneGameV(vector<int>& val) {\\n        int n=val.size();\\n        dp.assign(501, vector<long > (501, -1));\\n        pref.assign(501,0);\\n        \\n        for(int i=0; i<n; ++i) pref[i+1]= pref[i]+ val[i];\\n        return helper(0, n-1, val);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector< vector<long> > dp;\\n    vector< long> pref;\\n    \\n    int helper(int i, int j, vector<int> &val) {\\n        if(i>j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        long l=0, r= pref[j+1]-pref[i];\\n        long ans=0;\\n        for(int s=i; s<j; ++s){\\n            l+=val[s];\\n            r-=val[s];\\n            \\n            if(l==r) ans = max( ans, l+ max(helper(i, s, val), helper(s+1, j, val)));\\n            else if(l<r) ans= max(ans, l+ helper(i,s, val));\\n            else ans= max(ans, r+ helper(s+1, j, val));\\n        }\\n        \\n        return dp[i][j]=ans;\\n    }\\n    int stoneGameV(vector<int>& val) {\\n        int n=val.size();\\n        dp.assign(501, vector<long > (501, -1));\\n        pref.assign(501,0);\\n        \\n        for(int i=0; i<n; ++i) pref[i+1]= pref[i]+ val[i];\\n        return helper(0, n-1, val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807020,
                "title": "memoization-c-solutions",
                "content": "```\\n \\n    int solve(vector<int>& a,int s,int e, vector<vector<int>>&dp)\\n    {\\n        if(s>e)\\n        {\\n            return 0; \\n        }\\n        \\n        if(dp[s][e]!=-1)\\n        {\\n            return dp[s][e]; \\n        }\\n         \\n        int i,j,k,l; \\n        int sum=0;\\n        int ans=0;  \\n         \\n        for(i=s;i<=e;i++)\\n        {\\n            sum+=a[i]; \\n        }\\n        \\n        k=0;  \\n        \\n        for(j=s;j<=e;j++)\\n        {\\n            k+=a[j]; \\n            l=sum-k; \\n            if(k>l)\\n            {\\n                ans=max(ans,l+solve(a,j+1,e,dp));\\n            }\\n            else if(k<l)\\n            {\\n                ans=max(ans,k+solve(a,s,j,dp));\\n            }\\n            else\\n            {\\n                \\n                ans=max(ans,k+solve(a,s,j,dp));\\n                ans=max(ans,l+solve(a,j+1,e,dp));\\n            }\\n        } \\n        \\n        dp[s][e]=ans;  \\n        \\n        return ans; \\n    }\\n    int stoneGameV(vector<int>& s) {\\n      \\n       if(s.size()<=1)\\n       {\\n           return 0;\\n       }\\n       \\n       int n=s.size(); \\n       vector<vector<int>>dp(n+1,vector<int>(n+1,-1));  \\n        \\n       int  ans=solve(s,0,s.size()-1,dp); \\n       return ans;    \\n        \\n    }\\n\\t```\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n \\n    int solve(vector<int>& a,int s,int e, vector<vector<int>>&dp)\\n    {\\n        if(s>e)\\n        {\\n            return 0; \\n        }\\n        \\n        if(dp[s][e]!=-1)\\n        {\\n            return dp[s][e]; \\n        }\\n         \\n        int i,j,k,l; \\n        int sum=0;\\n        int ans=0;  \\n         \\n        for(i=s;i<=e;i++)\\n        {\\n            sum+=a[i]; \\n        }\\n        \\n        k=0;  \\n        \\n        for(j=s;j<=e;j++)\\n        {\\n            k+=a[j]; \\n            l=sum-k; \\n            if(k>l)\\n            {\\n                ans=max(ans,l+solve(a,j+1,e,dp));\\n            }\\n            else if(k<l)\\n            {\\n                ans=max(ans,k+solve(a,s,j,dp));\\n            }\\n            else\\n            {\\n                \\n                ans=max(ans,k+solve(a,s,j,dp));\\n                ans=max(ans,l+solve(a,j+1,e,dp));\\n            }\\n        } \\n        \\n        dp[s][e]=ans;  \\n        \\n        return ans; \\n    }\\n    int stoneGameV(vector<int>& s) {\\n      \\n       if(s.size()<=1)\\n       {\\n           return 0;\\n       }\\n       \\n       int n=s.size(); \\n       vector<vector<int>>dp(n+1,vector<int>(n+1,-1));  \\n        \\n       int  ans=solve(s,0,s.size()-1,dp); \\n       return ans;    \\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 806860,
                "title": "java-dfs-dp-memo",
                "content": "```\\nclass Solution {\\n    public int stoneGameV(int[] sv) {\\n        int n = sv.length;\\n        int[][] dp = new int[n + 1][n + 1];\\n        int[] sum = new int[n + 1];\\n        for(int i = 1; i <= n; i++) {\\n            sum[i] = sv[i - 1] + sum[i - 1];\\n        }        \\n        return dfs(sv, 1, n, dp, sum);\\n    }\\n    \\n    private int dfs(int[] sv, int i, int j, int[][] dp, int[] sum) {\\n        if(dp[i][j] != 0) return dp[i][j];\\n        if(i == j) return 0;\\n        if(j - i == 1) return Math.min(sv[i - 1], sv[j - 1]);\\n        int res = 0;\\n        for(int k = i; k < j; k++) {\\n            int ans = 0;\\n            int sum_l = sum[k] - sum[i - 1]; // i-th ... k-th\\n            int sum_r = sum[j] - sum[k]; // (k+1)-th ... j-th\\n            if(sum_l > sum_r) {\\n                ans = sum_r + dfs(sv, k + 1, j, dp, sum);\\n            } else if(sum_l < sum_r) {\\n                ans = sum_l + dfs(sv, i, k, dp, sum);\\n            } else {\\n                ans = Math.max(sum_r + dfs(sv, k + 1, j, dp, sum),\\n                              sum_l + dfs(sv, i, k, dp, sum));\\n            }\\n            res = Math.max(res, ans);\\n        }\\n        dp[i][j] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int stoneGameV(int[] sv) {\\n        int n = sv.length;\\n        int[][] dp = new int[n + 1][n + 1];\\n        int[] sum = new int[n + 1];\\n        for(int i = 1; i <= n; i++) {\\n            sum[i] = sv[i - 1] + sum[i - 1];\\n        }        \\n        return dfs(sv, 1, n, dp, sum);\\n    }\\n    \\n    private int dfs(int[] sv, int i, int j, int[][] dp, int[] sum) {\\n        if(dp[i][j] != 0) return dp[i][j];\\n        if(i == j) return 0;\\n        if(j - i == 1) return Math.min(sv[i - 1], sv[j - 1]);\\n        int res = 0;\\n        for(int k = i; k < j; k++) {\\n            int ans = 0;\\n            int sum_l = sum[k] - sum[i - 1]; // i-th ... k-th\\n            int sum_r = sum[j] - sum[k]; // (k+1)-th ... j-th\\n            if(sum_l > sum_r) {\\n                ans = sum_r + dfs(sv, k + 1, j, dp, sum);\\n            } else if(sum_l < sum_r) {\\n                ans = sum_l + dfs(sv, i, k, dp, sum);\\n            } else {\\n                ans = Math.max(sum_r + dfs(sv, k + 1, j, dp, sum),\\n                              sum_l + dfs(sv, i, k, dp, sum));\\n            }\\n            res = Math.max(res, ans);\\n        }\\n        dp[i][j] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806821,
                "title": "c-top-down-dp-prefix-sum-solution",
                "content": "\\ndp[i][j] represent the maximum value from i to j. We try to spilt the array to two part `left` and `right`, There are 3 situation we need to cosider:  \\n1. if the sum of `left` is less than `right` part, then we do dfs(l, i);  \\n2. if the sum of `left` is greater than `right` part, then we do dfs(l, i + 1, r);  \\n3. if the sum of `left` is equal `right` part, then we do both of `1` and `2`  \\nwe can get the sum of the left and right part in O(1) by using prefix sum.  \\nWhen we do this calculation, we keep th maximum result and store it into dp at the end.  \\n```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int dfs(vector<int>& sv, int l, int r) {\\n        if(l >= r) return 0;\\n        if(dp[l][r] >= 0) return dp[l][r];\\n        int res = 0;\\n        for(int i = l; i <r ; ++i) {\\n            int lv = sv[i] - (l > 0 ? sv[l - 1] : 0);\\n            int rv = sv[r] - sv[i];\\n            if(lv > rv) res = max(res, dfs(sv, i + 1, r) + rv);\\n            else if(lv < rv) res = max(res, dfs(sv, l, i) + lv);\\n            else {\\n                res = max({res, dfs(sv, i + 1, r) + rv,  dfs(sv, l, i) + lv});\\n            }\\n            \\n        }\\n        return dp[l][r] = res;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        memset(dp, -1, sizeof(dp));\\n        if(stoneValue.size() == 1) return 0;\\n        for(int i = 1; i < stoneValue.size(); ++i) stoneValue[i] += stoneValue[i - 1];\\n        return dfs(stoneValue, 0, stoneValue.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int dfs(vector<int>& sv, int l, int r) {\\n        if(l >= r) return 0;\\n        if(dp[l][r] >= 0) return dp[l][r];\\n        int res = 0;\\n        for(int i = l; i <r ; ++i) {\\n            int lv = sv[i] - (l > 0 ? sv[l - 1] : 0);\\n            int rv = sv[r] - sv[i];\\n            if(lv > rv) res = max(res, dfs(sv, i + 1, r) + rv);\\n            else if(lv < rv) res = max(res, dfs(sv, l, i) + lv);\\n            else {\\n                res = max({res, dfs(sv, i + 1, r) + rv,  dfs(sv, l, i) + lv});\\n            }\\n            \\n        }\\n        return dp[l][r] = res;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        memset(dp, -1, sizeof(dp));\\n        if(stoneValue.size() == 1) return 0;\\n        for(int i = 1; i < stoneValue.size(); ++i) stoneValue[i] += stoneValue[i - 1];\\n        return dfs(stoneValue, 0, stoneValue.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806764,
                "title": "python-elegant-memoization",
                "content": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        prefix = [0]\\n        for i in range(len(stoneValue)):\\n            prefix += [prefix[-1] + stoneValue[i]]\\n        print(prefix)\\n        \\n        @lru_cache(None)\\n        def dfs(left=0, right=len(prefix)-1):\\n            if right - left == 1: return 0\\n            \\n            maxval = -1\\n            for i in range(left+1, right):\\n                leftsum = prefix[i] - prefix[left]\\n                rightsum = prefix[right] - prefix[i]\\n                \\n                if leftsum > rightsum:\\n                    maxval = max(maxval, rightsum + dfs(i, right))\\n                elif rightsum > leftsum:\\n                    maxval = max(maxval, leftsum + dfs(left, i))\\n                else:\\n                    maxval = leftsum + max(dfs(left, i), dfs(i, right))\\n            \\n            return maxval\\n           \\n        return dfs()\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        prefix = [0]\\n        for i in range(len(stoneValue)):\\n            prefix += [prefix[-1] + stoneValue[i]]\\n        print(prefix)\\n        \\n        @lru_cache(None)\\n        def dfs(left=0, right=len(prefix)-1):\\n            if right - left == 1: return 0\\n            \\n            maxval = -1\\n            for i in range(left+1, right):\\n                leftsum = prefix[i] - prefix[left]\\n                rightsum = prefix[right] - prefix[i]\\n                \\n                if leftsum > rightsum:\\n                    maxval = max(maxval, rightsum + dfs(i, right))\\n                elif rightsum > leftsum:\\n                    maxval = max(maxval, leftsum + dfs(left, i))\\n                else:\\n                    maxval = leftsum + max(dfs(left, i), dfs(i, right))\\n            \\n            return maxval\\n           \\n        return dfs()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806758,
                "title": "python-dfs-memo",
                "content": "```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        n = len(stoneValue)\\n        pre = [0]\\n        for i in range(n):\\n            pre.append(stoneValue[i] + pre[-1])\\n        @lru_cache(None)\\n        def dfs(l, r):\\n            if r <= l:\\n                return 0\\n            res = 0\\n            for i in range(l, r):\\n                # [l, i] [i + 1, r]\\n                left = pre[i + 1] - pre[l]\\n                right = pre[r + 1] - pre[i + 1]\\n                if right > left:\\n                    res = max(res, dfs(l, i) + left)\\n                elif left > right:\\n                    res = max(res, dfs(i + 1, r) + right)\\n                else:\\n                    res = max(res, dfs(l, i) + left)\\n                    res = max(res, dfs(i + 1, r) + right)\\n            return res\\n        return dfs(0, n - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        n = len(stoneValue)\\n        pre = [0]\\n        for i in range(n):\\n            pre.append(stoneValue[i] + pre[-1])\\n        @lru_cache(None)\\n        def dfs(l, r):\\n            if r <= l:\\n                return 0\\n            res = 0\\n            for i in range(l, r):\\n                # [l, i] [i + 1, r]\\n                left = pre[i + 1] - pre[l]\\n                right = pre[r + 1] - pre[i + 1]\\n                if right > left:\\n                    res = max(res, dfs(l, i) + left)\\n                elif left > right:\\n                    res = max(res, dfs(i + 1, r) + right)\\n                else:\\n                    res = max(res, dfs(l, i) + left)\\n                    res = max(res, dfs(i + 1, r) + right)\\n            return res\\n        return dfs(0, n - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052589,
                "title": "basic-java-solution-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findSum(int[] stoneValue)\\n    {\\n        int sum=0;\\n        for(int n:stoneValue) sum+=n;\\n        return sum; //  returns the sum of the stoneValue Array.\\n    }\\n    public int findMin(int[] stoneValue,int start,int end,int preSum,int sum,int[][] dp)\\n    {\\n        if(start==end) return 0; // returns 0 whenever the length of the array equals 1.\\n\\n        if(dp[start][end]!=-1) return dp[start][end]; // returns the stored value of the sub problem when the specific values of start and end already solved before.\\n\\n        int ans=Integer.MIN_VALUE; // Initializing the required maximum score of alice with the minimum possible integer.\\n\\n        for(int i=start;i<end;i++) // Iterating a for loop from the starting index to the ending index to check with all the possible partitions.\\n        {\\n            preSum=preSum+stoneValue[i]; //Increment the preSum with value of stoneValue at current index where we are going to make partition.\\n\\n            if(preSum < sum-preSum)\\n            {\\n                ans=Math.max(ans,preSum+findMin(stoneValue,start,i,0,preSum,dp)); \\n                //if the preSum(the sum of the array from start index to current index) is less than the remaining part of the array,\\n                //Then Bob throws away the right array i.e the array with the largest sum,\\n                //Alice score is increased by preSum(sum of the left array) and parameters of the left array are sent to the recursion.\\n            }\\n            else if(preSum>sum-preSum)\\n            {\\n                ans=Math.max(ans,sum-preSum+findMin(stoneValue,i+1,end,0,sum-preSum,dp));\\n                //if the preSum(the sum of the array from start index to current index) is more than the remaining part of the array,\\n                //Then Bob throws away the left array i.e the array with the largest sum,\\n                //Alice score is increased by sum-preSum(sum of the right array) and parameters of the right array are sent to the recursion.\\n            }\\n            else{\\n                ans=Math.max(ans,Math.max(preSum+findMin(stoneValue,start,i,0,preSum,dp),sum-preSum+findMin(stoneValue,i+1,end,0,sum-preSum,dp)));\\n                // if the preSum(the sum of left array) and sum-preSum(the sum of the right array) are equal,\\n                // Then, Bob gives Alice a chance to remove either the left array or the right array,\\n                // So alice has a chance to get maximum score from either of the arrays,\\n                // So Alice take the the Max value from both the recursions(recursion calls of both left array and right array).\\n            }\\n        }\\n        return dp[start][end]=ans; // store the value of the partition for specific start and end values in the dp array.\\n    }\\n    public int stoneGameV(int[] stoneValue) {\\n        int sum = findSum(stoneValue); // To find Sum of the stoneValue array.\\n\\n        int[][] dp = new int[stoneValue.length][stoneValue.length]; // A 2D array for memorization.\\n\\n        for(int i=0;i<stoneValue.length;i++)\\n        {\\n            Arrays.fill(dp[i],-1); // Initializing all the values of the 2D array dp with -1.\\n        }\\n        return findMin(stoneValue,0,stoneValue.length-1,0,sum,dp); // function to find Maximum score of alice.\\n    }\\n}\\n```\\n**Thank You : )**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int findSum(int[] stoneValue)\\n    {\\n        int sum=0;\\n        for(int n:stoneValue) sum+=n;\\n        return sum; //  returns the sum of the stoneValue Array.\\n    }\\n    public int findMin(int[] stoneValue,int start,int end,int preSum,int sum,int[][] dp)\\n    {\\n        if(start==end) return 0; // returns 0 whenever the length of the array equals 1.\\n\\n        if(dp[start][end]!=-1) return dp[start][end]; // returns the stored value of the sub problem when the specific values of start and end already solved before.\\n\\n        int ans=Integer.MIN_VALUE; // Initializing the required maximum score of alice with the minimum possible integer.\\n\\n        for(int i=start;i<end;i++) // Iterating a for loop from the starting index to the ending index to check with all the possible partitions.\\n        {\\n            preSum=preSum+stoneValue[i]; //Increment the preSum with value of stoneValue at current index where we are going to make partition.\\n\\n            if(preSum < sum-preSum)\\n            {\\n                ans=Math.max(ans,preSum+findMin(stoneValue,start,i,0,preSum,dp)); \\n                //if the preSum(the sum of the array from start index to current index) is less than the remaining part of the array,\\n                //Then Bob throws away the right array i.e the array with the largest sum,\\n                //Alice score is increased by preSum(sum of the left array) and parameters of the left array are sent to the recursion.\\n            }\\n            else if(preSum>sum-preSum)\\n            {\\n                ans=Math.max(ans,sum-preSum+findMin(stoneValue,i+1,end,0,sum-preSum,dp));\\n                //if the preSum(the sum of the array from start index to current index) is more than the remaining part of the array,\\n                //Then Bob throws away the left array i.e the array with the largest sum,\\n                //Alice score is increased by sum-preSum(sum of the right array) and parameters of the right array are sent to the recursion.\\n            }\\n            else{\\n                ans=Math.max(ans,Math.max(preSum+findMin(stoneValue,start,i,0,preSum,dp),sum-preSum+findMin(stoneValue,i+1,end,0,sum-preSum,dp)));\\n                // if the preSum(the sum of left array) and sum-preSum(the sum of the right array) are equal,\\n                // Then, Bob gives Alice a chance to remove either the left array or the right array,\\n                // So alice has a chance to get maximum score from either of the arrays,\\n                // So Alice take the the Max value from both the recursions(recursion calls of both left array and right array).\\n            }\\n        }\\n        return dp[start][end]=ans; // store the value of the partition for specific start and end values in the dp array.\\n    }\\n    public int stoneGameV(int[] stoneValue) {\\n        int sum = findSum(stoneValue); // To find Sum of the stoneValue array.\\n\\n        int[][] dp = new int[stoneValue.length][stoneValue.length]; // A 2D array for memorization.\\n\\n        for(int i=0;i<stoneValue.length;i++)\\n        {\\n            Arrays.fill(dp[i],-1); // Initializing all the values of the 2D array dp with -1.\\n        }\\n        return findMin(stoneValue,0,stoneValue.length-1,0,sum,dp); // function to find Maximum score of alice.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767882,
                "title": "java-memoization-dp-beats-80",
                "content": "``` java\\nclass Solution {\\n    Integer[][] dp;\\n    public int stoneGameV(int[] stoneValue) {\\n        dp = new Integer[stoneValue.length][stoneValue.length];\\n        int total = 0;\\n        for(int x:stoneValue){\\n            total+=x;\\n        }\\n        return solve(stoneValue,0,stoneValue.length-1,total);\\n    }\\n\\n    private int solve(int[] stones,int i,int j,int total){\\n        if(i>=j){\\n            return 0;\\n        }\\n        if(dp[i][j]!=null){\\n            return dp[i][j];\\n        }\\n        int sum=0, result=0;\\n        for(int k=i;k<=j;k++){\\n            sum+=stones[k];\\n            int max = 0;\\n            if(2*sum<total){\\n                max = sum+solve(stones,i,k,sum);\\n            }\\n            else if(2*sum>total){\\n                max = total-sum + solve(stones,k+1,j,total-sum);\\n            }\\n            else{\\n                max = Math.max(sum+solve(stones,i,k,sum), total-sum+solve(stones,k+1,j,total-sum));\\n            }\\n            result = Math.max(max,result);\\n        }\\n        return dp[i][j] = result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "``` java\\nclass Solution {\\n    Integer[][] dp;\\n    public int stoneGameV(int[] stoneValue) {\\n        dp = new Integer[stoneValue.length][stoneValue.length];\\n        int total = 0;\\n        for(int x:stoneValue){\\n            total+=x;\\n        }\\n        return solve(stoneValue,0,stoneValue.length-1,total);\\n    }\\n\\n    private int solve(int[] stones,int i,int j,int total){\\n        if(i>=j){\\n            return 0;\\n        }\\n        if(dp[i][j]!=null){\\n            return dp[i][j];\\n        }\\n        int sum=0, result=0;\\n        for(int k=i;k<=j;k++){\\n            sum+=stones[k];\\n            int max = 0;\\n            if(2*sum<total){\\n                max = sum+solve(stones,i,k,sum);\\n            }\\n            else if(2*sum>total){\\n                max = total-sum + solve(stones,k+1,j,total-sum);\\n            }\\n            else{\\n                max = Math.max(sum+solve(stones,i,k,sum), total-sum+solve(stones,k+1,j,total-sum));\\n            }\\n            result = Math.max(max,result);\\n        }\\n        return dp[i][j] = result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923187,
                "title": "python-350ms-beats-98",
                "content": "# Intuition\\nMemoized solution can take advantage of some constraints to shrink search space. \\n\\n# Approach\\nWhen considering a subproblem (solution for contiguos sublist of the original list) there is no need to check all possible divisions of the sublist, since there is an upper bound on the value of the solution. Specifically the solution cannot exceed sum of values of stones in the sublist minus 1 (think sum of geometric progression with ratio 1/2). Based on this, if the sublist is divided into two parts with boundary too far from the median (such that the bound mentioned above implies that solution for this divison cannot beat the best solution discovered so far), then search can be safely stopped. We start search by dividing in two parts with equal sums (or the closest possible) and expand search by moving index of the boundary between left and right part of the sublist, first - the one to the left and then - the one to the right until we are stopped by the constraint mentioned above.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom itertools import accumulate\\nfrom bisect import bisect_left\\nfrom functools import cache\\n\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n\\n        sv = [0, *accumulate(stoneValue)]\\n\\n        @cache\\n        def helper(fro, to):\\n            if to - fro == 1:\\n                return 0\\n\\n            mid = bisect_left(sv, (sv[to] + sv[fro]) // 2)\\n\\n            dist = res = 0\\n            explore_more = True\\n            while explore_more:\\n                explore_more = False\\n                for i in  [mid - dist, mid + dist]: \\n                    if fro < i <= to:\\n                        left, right = sv[i] - sv[fro], sv[to] - sv[i]\\n                        if res // 2 <= left <= right:\\n                            res = max(res, left + helper(fro, i))\\n                            explore_more = True\\n                        if left >= right >= res // 2:\\n                            res = max(res, right + helper(i, to))\\n                            explore_more = True\\n                dist += 1\\n            return res\\n\\n        return helper(0, len(stoneValue))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import accumulate\\nfrom bisect import bisect_left\\nfrom functools import cache\\n\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n\\n        sv = [0, *accumulate(stoneValue)]\\n\\n        @cache\\n        def helper(fro, to):\\n            if to - fro == 1:\\n                return 0\\n\\n            mid = bisect_left(sv, (sv[to] + sv[fro]) // 2)\\n\\n            dist = res = 0\\n            explore_more = True\\n            while explore_more:\\n                explore_more = False\\n                for i in  [mid - dist, mid + dist]: \\n                    if fro < i <= to:\\n                        left, right = sv[i] - sv[fro], sv[to] - sv[i]\\n                        if res // 2 <= left <= right:\\n                            res = max(res, left + helper(fro, i))\\n                            explore_more = True\\n                        if left >= right >= res // 2:\\n                            res = max(res, right + helper(i, to))\\n                            explore_more = True\\n                dist += 1\\n            return res\\n\\n        return helper(0, len(stoneValue))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549648,
                "title": "simple-partition-dp-recursive-memoization",
                "content": "We need to try out all possible partition for every subproblem hence **partition dp**.\\n\\t**Base Case:** When there is only one element left in subarray (i.e i == j) we return 0 because alice    cannot score anything from that.\\n```\\nint f(int i,int j,vector<int> &stoneValue,vector<vector<int>> &dp){\\n        if(i == j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int totSum = 0;\\n        for(int k = i ; k <= j ; k++) totSum += stoneValue[k];\\n        int leftSum = 0;\\n        int res = INT_MIN;\\n        for(int k = i ; k < j ; k++){\\n            leftSum += stoneValue[k];\\n            int rightSum = totSum - leftSum;\\n            if(leftSum == rightSum){\\n                int dropLeft = rightSum + f(k+1,j,stoneValue,dp);\\n                int dropRight = leftSum + f(i,k,stoneValue,dp);\\n                res = max(res,max(dropLeft,dropRight));\\n            }\\n            else if(leftSum < rightSum) res = max(res,leftSum + f(i,k,stoneValue,dp));\\n            else res = max(res,rightSum + f(k+1,j,stoneValue,dp));\\n        }\\n        return dp[i][j] = res;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        return f(0,n-1,stoneValue,dp);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint f(int i,int j,vector<int> &stoneValue,vector<vector<int>> &dp){\\n        if(i == j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int totSum = 0;\\n        for(int k = i ; k <= j ; k++) totSum += stoneValue[k];\\n        int leftSum = 0;\\n        int res = INT_MIN;\\n        for(int k = i ; k < j ; k++){\\n            leftSum += stoneValue[k];\\n            int rightSum = totSum - leftSum;\\n            if(leftSum == rightSum){\\n                int dropLeft = rightSum + f(k+1,j,stoneValue,dp);\\n                int dropRight = leftSum + f(i,k,stoneValue,dp);\\n                res = max(res,max(dropLeft,dropRight));\\n            }\\n            else if(leftSum < rightSum) res = max(res,leftSum + f(i,k,stoneValue,dp));\\n            else res = max(res,rightSum + f(k+1,j,stoneValue,dp));\\n        }\\n        return dp[i][j] = res;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        return f(0,n-1,stoneValue,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2491571,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    \\n    int dp[501][501];\\n    \\n    int help(vector<int>& v, int start, int end)\\n    {\\n        if(start > end)     \\n        {\\n            return 0;\\n        }\\n        \\n        int sum = 0, left_sum = 0, right_sum =0,ans = 0;\\n        \\n        if(dp[start][end] != -1)\\n        {\\n            return dp[start][end];\\n        }\\n        \\n        for(int i=start; i<=end; i++)\\n        {\\n            sum += v[i];\\n        }\\n        \\n        for(int j=start; j<=end; j++)\\n        {\\n            left_sum += v[j];\\n            \\n            right_sum = sum - left_sum;\\n            \\n            if(left_sum < right_sum)\\n            {\\n                ans = max(ans,left_sum + help(v,start,j));\\n            }\\n            else if(left_sum > right_sum)\\n            {\\n                ans = max(ans, right_sum + help(v,j+1,end));\\n            }\\n            else\\n            {\\n                ans = max(ans,left_sum + help(v,start,j));\\n                ans = max(ans, right_sum + help(v,j+1,end));\\n                  \\n            }\\n            \\n        }\\n        \\n        return dp[start][end] = ans;\\n    }\\n    \\n    int stoneGameV(vector<int>& stoneValue) \\n    {\\n        \\n      memset(dp,-1,sizeof(dp));\\n        \\n      return  help(stoneValue, 0, stoneValue.size()-1);\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int dp[501][501];\\n    \\n    int help(vector<int>& v, int start, int end)\\n    {\\n        if(start > end)     \\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2277107,
                "title": "c-dp-check-every-possible-partition",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501][501] ;\\n    int solve(vector<int>&nums , int s , int e){\\n        if(s == e) return 0 ; \\n        if(dp[s][e] != -1) return dp[s][e] ;\\n        \\n        int sum = 0 , left = 0 , right = 0 ;\\n        for(int i = s ; i <= e ; ++i) sum += nums[i] ;\\n        \\n        int op1 = 0 , op2 = 0 ;\\n        for(int i = s ; i < e ; ++i ){\\n            left += nums[i] , right = sum - left ;\\n            if(left <= right) op1 = max(op1,left + solve(nums,s,i)) ;\\n            if(left >= right) op2 = max(op2,right + solve(nums,i+1,e)) ;\\n        }\\n        \\n        return dp[s][e] = max(op1,op2) ;\\n    }\\n    int stoneGameV(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp)) ;\\n        return solve(nums,0,nums.size() - 1) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501] ;\\n    int solve(vector<int>&nums , int s , int e){\\n        if(s == e) return 0 ; \\n        if(dp[s][e] != -1) return dp[s][e] ;\\n        \\n        int sum = 0 , left = 0 , right = 0 ;\\n        for(int i = s ; i <= e ; ++i) sum += nums[i] ;\\n        \\n        int op1 = 0 , op2 = 0 ;\\n        for(int i = s ; i < e ; ++i ){\\n            left += nums[i] , right = sum - left ;\\n            if(left <= right) op1 = max(op1,left + solve(nums,s,i)) ;\\n            if(left >= right) op2 = max(op2,right + solve(nums,i+1,e)) ;\\n        }\\n        \\n        return dp[s][e] = max(op1,op2) ;\\n    }\\n    int stoneGameV(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp)) ;\\n        return solve(nums,0,nums.size() - 1) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232037,
                "title": "worst-case-time-complexity-when-using-recursion-without-dp",
                "content": "I was able to solve this problem using DP in O(n^2) time + top down approach.\\n\\nBut wasnt able to do satisfactory time complexity analysis when only using recursion without using any DP?\\n\\nHas anyone done time complexity analysis when only using recusrsion without any DP ?",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "I was able to solve this problem using DP in O(n^2) time + top down approach.\\n\\nBut wasnt able to do satisfactory time complexity analysis when only using recursion without using any DP?\\n\\nHas anyone done time complexity analysis when only using recusrsion without any DP ?",
                "codeTag": "Unknown"
            },
            {
                "id": 2120507,
                "title": "c-solution-recursion-memoization",
                "content": "```\\n#define ll long long\\n#define vb vector<bool>\\n#define vi vector<int>\\n#define vl vector<long long>\\n#define vvb vector<vector<bool>>\\n#define vvi vector<vector<int>>\\n#define vvl vector<vector<long long>>\\n#define pii pair<int,int>\\n#define all(i) i.begin(),i.end()\\n#define f(i,s,e) for(int i = s; i < e; i++)\\n#define b(i,s,e) for(int i = s; i >= e; i--)\\ninline int getMid(int i,int j) { return i+(j-i)/2; }\\n\\nclass Solution {\\npublic:\\n    vi prefixSum;\\n\\n    int maxScore(int i, int j, vvi& memo) {\\n        if(i == j) return 0;\\n        if(memo[i][j] != -1) return memo[i][j];\\n\\n        int ans = 0;\\n        f(k,i,j) {\\n            int left = prefixSum[k+1]-prefixSum[i], right = prefixSum[j+1]-prefixSum[k+1];\\n            if(left > right) ans = max(ans,right+maxScore(k+1,j,memo));\\n            else if(left < right) ans = max(ans,left+maxScore(i,k,memo));\\n            else ans = max({ans,left+maxScore(i,k,memo),right+maxScore(k+1,j,memo)});\\n        }\\n        return memo[i][j] = ans; \\n    }\\n\\n    int stoneGameV(vi& stoneValue) {\\n        int n = stoneValue.size();\\n        this->prefixSum = vi(n+1);\\n        prefixSum[0] = stoneValue[0];\\n        f(i,1,n+1) prefixSum[i] = prefixSum[i-1]+stoneValue[i-1];\\n        vvi memo(n,vi(n,-1));\\n        return maxScore(0,n-1,memo);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n#define vb vector<bool>\\n#define vi vector<int>\\n#define vl vector<long long>\\n#define vvb vector<vector<bool>>\\n#define vvi vector<vector<int>>\\n#define vvl vector<vector<long long>>\\n#define pii pair<int,int>\\n#define all(i) i.begin(),i.end()\\n#define f(i,s,e) for(int i = s; i < e; i++)\\n#define b(i,s,e) for(int i = s; i >= e; i--)\\ninline int getMid(int i,int j) { return i+(j-i)/2; }\\n\\nclass Solution {\\npublic:\\n    vi prefixSum;\\n\\n    int maxScore(int i, int j, vvi& memo) {\\n        if(i == j) return 0;\\n        if(memo[i][j] != -1) return memo[i][j];\\n\\n        int ans = 0;\\n        f(k,i,j) {\\n            int left = prefixSum[k+1]-prefixSum[i], right = prefixSum[j+1]-prefixSum[k+1];\\n            if(left > right) ans = max(ans,right+maxScore(k+1,j,memo));\\n            else if(left < right) ans = max(ans,left+maxScore(i,k,memo));\\n            else ans = max({ans,left+maxScore(i,k,memo),right+maxScore(k+1,j,memo)});\\n        }\\n        return memo[i][j] = ans; \\n    }\\n\\n    int stoneGameV(vi& stoneValue) {\\n        int n = stoneValue.size();\\n        this->prefixSum = vi(n+1);\\n        prefixSum[0] = stoneValue[0];\\n        f(i,1,n+1) prefixSum[i] = prefixSum[i-1]+stoneValue[i-1];\\n        vvi memo(n,vi(n,-1));\\n        return maxScore(0,n-1,memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967933,
                "title": "only-go-solution-dp-only-using-indices",
                "content": "```\\nfunc stoneGameV(stoneValue []int) int {\\n    type Key struct {\\n        r int\\n        l int\\n    }\\n    prefix := []int{0}\\n    curr := 0\\n    for _, s := range stoneValue {\\n        curr += s\\n        prefix = append(prefix, curr)\\n    }\\n    memo := make(map[Key]int)\\n    var dp func(lb int, rb int) int\\n    dp = func(lb int, rb int) int {\\n        if rb == lb {\\n            return 0\\n        }\\n        currKey := Key{lb, rb}\\n        val, exists := memo[currKey]\\n        if exists {\\n            return val\\n        }\\n        var res, curr, sl, sr int\\n        res = 0\\n        for i := lb; i < rb; i++ {\\n            sl = prefix[i]-prefix[lb-1]\\n            sr = prefix[rb]-prefix[i]\\n            if sl < sr {\\n                curr = sl+dp(lb, i)\\n            } else if sl > sr {\\n                curr = sr+dp(i+1, rb)\\n            } else {\\n                curr = Max2(sl+dp(lb, i), sr+dp(i+1, rb))\\n            }\\n            res = Max2(res, curr)\\n        }\\n        memo[currKey] = res\\n        return res\\n    }\\n    return dp(1, len(prefix)-1)\\n}\\n\\nfunc Max2(c1 int, c2 int) int {\\n    if c2 > c1 {\\n        return c2\\n    } else {\\n        return c1\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nfunc stoneGameV(stoneValue []int) int {\\n    type Key struct {\\n        r int\\n        l int\\n    }\\n    prefix := []int{0}\\n    curr := 0\\n    for _, s := range stoneValue {\\n        curr += s\\n        prefix = append(prefix, curr)\\n    }\\n    memo := make(map[Key]int)\\n    var dp func(lb int, rb int) int\\n    dp = func(lb int, rb int) int {\\n        if rb == lb {\\n            return 0\\n        }\\n        currKey := Key{lb, rb}\\n        val, exists := memo[currKey]\\n        if exists {\\n            return val\\n        }\\n        var res, curr, sl, sr int\\n        res = 0\\n        for i := lb; i < rb; i++ {\\n            sl = prefix[i]-prefix[lb-1]\\n            sr = prefix[rb]-prefix[i]\\n            if sl < sr {\\n                curr = sl+dp(lb, i)\\n            } else if sl > sr {\\n                curr = sr+dp(i+1, rb)\\n            } else {\\n                curr = Max2(sl+dp(lb, i), sr+dp(i+1, rb))\\n            }\\n            res = Max2(res, curr)\\n        }\\n        memo[currKey] = res\\n        return res\\n    }\\n    return dp(1, len(prefix)-1)\\n}\\n\\nfunc Max2(c1 int, c2 int) int {\\n    if c2 > c1 {\\n        return c2\\n    } else {\\n        return c1\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1849142,
                "title": "cpp-game-theory-highly-commented-step-by-step-easy-approach-n2",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    \\n//     Time Complexity : O(N2)\\n//     Idea is to check \\n//     from i ...... j\\n//     parition the array[i...j] from k = [i to (j-1)]\\n//     forming two parts arr[i...k] and arr[k+1 .... j]\\n//     check whichever is greater, discard and recur for smaller part\\n    \\n    vector<int> pre;\\n    int solve(int i,int j,vector<int>&v )\\n    {\\n        if(i==j)return 0;\\n        \\n        int &x  = dp[i][j];\\n        if(x != -1)return x;\\n        \\n        // just to calculate the total sum of array [i....j]\\n        int total = pre[j+1]-pre[i];\\n        \\n        int leftPartSum = 0; // to ccalculate the array sum [i...k]\\n        int rightPartSum;\\n        int ans = 0;// final ans to be returned\\n        for(int k=i;k<j;k++){\\n            leftPartSum += v[k];// adding the kth el\\n            rightPartSum = total - leftPartSum;\\n            if(leftPartSum > rightPartSum){ // if left part is greater, dicard left and recur for right part\\n                ans = max(ans,rightPartSum + solve(k+1,j,v) );\\n            }else if(leftPartSum < rightPartSum){// if right part is greater, discard right part and recur for left part\\n                ans = max(ans,leftPartSum + solve(i,k,v));\\n            }else{\\n                // both part have equal sum\\n                ans = max(ans, leftPartSum + solve(i,k,v));// recur for left\\n                ans = max(ans, rightPartSum + solve(k+1,j,v));// recur for right\\n            }\\n        }\\n        return x = ans;\\n        \\n    }\\n    \\n    \\n    int stoneGameV(vector<int>& v) {\\n        memset(dp,-1,sizeof(dp));\\n        int sum = 0;\\n        pre.push_back(0);\\n        for(int i=0;i<v.size();i++){\\n            sum += v[i];\\n            pre.push_back(sum);\\n            // cout << pre[i] << \" \";\\n        }\\n        \\n        int ans = solve(0,v.size()-1,v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    \\n//     Time Complexity : O(N2)\\n//     Idea is to check \\n//     from i ...... j\\n//     parition the array[i...j] from k = [i to (j-1)]\\n//     forming two parts arr[i...k] and arr[k+1 .... j]\\n//     check whichever is greater, discard and recur for smaller part\\n    \\n    vector<int> pre;\\n    int solve(int i,int j,vector<int>&v )\\n    {\\n        if(i==j)return 0;\\n        \\n        int &x  = dp[i][j];\\n        if(x != -1)return x;\\n        \\n        // just to calculate the total sum of array [i....j]\\n        int total = pre[j+1]-pre[i];\\n        \\n        int leftPartSum = 0; // to ccalculate the array sum [i...k]\\n        int rightPartSum;\\n        int ans = 0;// final ans to be returned\\n        for(int k=i;k<j;k++){\\n            leftPartSum += v[k];// adding the kth el\\n            rightPartSum = total - leftPartSum;\\n            if(leftPartSum > rightPartSum){ // if left part is greater, dicard left and recur for right part\\n                ans = max(ans,rightPartSum + solve(k+1,j,v) );\\n            }else if(leftPartSum < rightPartSum){// if right part is greater, discard right part and recur for left part\\n                ans = max(ans,leftPartSum + solve(i,k,v));\\n            }else{\\n                // both part have equal sum\\n                ans = max(ans, leftPartSum + solve(i,k,v));// recur for left\\n                ans = max(ans, rightPartSum + solve(k+1,j,v));// recur for right\\n            }\\n        }\\n        return x = ans;\\n        \\n    }\\n    \\n    \\n    int stoneGameV(vector<int>& v) {\\n        memset(dp,-1,sizeof(dp));\\n        int sum = 0;\\n        pre.push_back(0);\\n        for(int i=0;i<v.size();i++){\\n            sum += v[i];\\n            pre.push_back(sum);\\n            // cout << pre[i] << \" \";\\n        }\\n        \\n        int ans = solve(0,v.size()-1,v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1825210,
                "title": "do-only-what-is-stated-in-the-question-noob-solution-game-strategy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int fun(int i,int j,vector<int> &arr,vector<int> &pre){\\n        //Base Case \\n        if(i == j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int score = INT_MIN;\\n        for(int part = i+1;part <= j;part++){\\n            int left = pre[part-1] - (i == 0 ? 0 : pre[i-1]);\\n            int right = pre[j] - pre[part-1];\\n            if(left > right){\\n                score = max(score,right + fun(part,j,arr,pre));                \\n            }else if(left < right){\\n                score = max(score,left + fun(i,part-1,arr,pre));\\n            }else{\\n                score = max(score,left + fun(i,part-1,arr,pre));   \\n                score = max(score,right + fun(part,j,arr,pre));      \\n            }\\n        }\\n        return dp[i][j] = score;\\n        \\n    }\\n    \\n    int stoneGameV(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        vector<int> pre(n);\\n        pre[0] = arr[0];\\n        for(int i=1;i<n;i++) pre[i] = pre[i-1] + arr[i];\\n        dp = vector<vector<int>> (n,vector<int> (n,-1));\\n        return fun(0,n-1,arr,pre);\\n    }\\n};",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int fun(int i,int j,vector<int> &arr,vector<int> &pre){\\n        //Base Case \\n        if(i == j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int score = INT_MIN;\\n        for(int part = i+1;part <= j;part++){\\n            int left = pre[part-1] - (i == 0 ? 0 : pre[i-1]);\\n            int right = pre[j] - pre[part-1];\\n            if(left > right){\\n                score = max(score,right + fun(part,j,arr,pre));                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1411203,
                "title": "c-dp-and-memorization-172-ms-94-32-10-6-mb-75-68-o-n-2",
                "content": "The following algorithm is an 1-index solution.\\nFirst a DP table is defined as\\ndp[i][j] := the maximum score with the initial states: stones in the range from i to j (i and j are included).\\nThen, there are (j - i) stones in this state. It means there are (j - i - 1) separators.\\nIt is clear that the value dp[i][j] is found if all ways of setting a separator is investigated.\\nTo accelerate computation, each derived value should be memorized.\\n\\n```\\nclass Solution {\\npublic:\\n    #define MAX 500\\n    int memo[MAX+2][MAX+2]; // 1-index\\n    int sum[MAX+2];\\n    int dp(int i, int j){\\n        if(i == j)\\n            return 0;\\n        if(memo[i][j] > 0)\\n            return memo[i][j];\\n        int ans=0;\\n        for(int n=i;n<j;n++){\\n            int left = sum[n] - sum[i-1];\\n            int right = sum[j] - sum[n];\\n            int tmp;\\n            if(left < right){\\n                tmp = dp(i,n) + left;\\n            }else if(right < left){\\n                tmp = dp(n+1, j)+right;\\n            }else{\\n                int lnum = dp(i,n);\\n                int rnum = dp(n+1,j);\\n                tmp = max(lnum, rnum) + right;\\n            }\\n            if(ans < tmp)\\n                ans = tmp;\\n        }\\n        memo[i][j] = ans;\\n        return ans;\\n    }\\n    \\n    int stoneGameV(vector<int>& stoneValue) {\\n        int N = stoneValue.size();\\n        int amt= 0;\\n        for(int i=0;i<N;i++){\\n            amt += stoneValue[i];\\n            sum[i+1] = amt;\\n        }\\n        for(int i=0;i<N-1;i++){\\n            memo[i+1][i+2] = min(stoneValue[i], stoneValue[i+1]);\\n        }\\n        return dp(1,N);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define MAX 500\\n    int memo[MAX+2][MAX+2]; // 1-index\\n    int sum[MAX+2];\\n    int dp(int i, int j){\\n        if(i == j)\\n            return 0;\\n        if(memo[i][j] > 0)\\n            return memo[i][j];\\n        int ans=0;\\n        for(int n=i;n<j;n++){\\n            int left = sum[n] - sum[i-1];\\n            int right = sum[j] - sum[n];\\n            int tmp;\\n            if(left < right){\\n                tmp = dp(i,n) + left;\\n            }else if(right < left){\\n                tmp = dp(n+1, j)+right;\\n            }else{\\n                int lnum = dp(i,n);\\n                int rnum = dp(n+1,j);\\n                tmp = max(lnum, rnum) + right;\\n            }\\n            if(ans < tmp)\\n                ans = tmp;\\n        }\\n        memo[i][j] = ans;\\n        return ans;\\n    }\\n    \\n    int stoneGameV(vector<int>& stoneValue) {\\n        int N = stoneValue.size();\\n        int amt= 0;\\n        for(int i=0;i<N;i++){\\n            amt += stoneValue[i];\\n            sum[i+1] = amt;\\n        }\\n        for(int i=0;i<N-1;i++){\\n            memo[i+1][i+2] = min(stoneValue[i], stoneValue[i+1]);\\n        }\\n        return dp(1,N);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351145,
                "title": "simple-c-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[505][505];\\n    \\n    int fun(vector<int>& stoneValue, int i, int j){\\n        \\n        if(i == j){\\n            return 0;\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        int sum = 0, curr = 0, ans = 0;\\n        \\n        for(int k = i; k <= j; k++){\\n            sum += stoneValue[k];\\n        }\\n        \\n        for(int k = i; k < j; k++){\\n            \\n            curr += stoneValue[k];\\n            \\n            if(curr < (sum - curr)){\\n                ans = max(ans,fun(stoneValue,i,k) + curr);\\n            }\\n            else if(curr > (sum - curr)){\\n                ans = max(ans,fun(stoneValue,k+1,j) + (sum - curr));\\n            }\\n            else{\\n                ans = max(ans, curr + max(fun(stoneValue,i,k),fun(stoneValue,k+1,j)));\\n            }\\n            \\n        }\\n        \\n        dp[i][j] = ans;\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int stoneGameV(vector<int>& stoneValue) {\\n        \\n        int size = stoneValue.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return fun(stoneValue,0,size-1);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[505][505];\\n    \\n    int fun(vector<int>& stoneValue, int i, int j){\\n        \\n        if(i == j){\\n            return 0;\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        int sum = 0, curr = 0, ans = 0;\\n        \\n        for(int k = i; k <= j; k++){\\n            sum += stoneValue[k];\\n        }\\n        \\n        for(int k = i; k < j; k++){\\n            \\n            curr += stoneValue[k];\\n            \\n            if(curr < (sum - curr)){\\n                ans = max(ans,fun(stoneValue,i,k) + curr);\\n            }\\n            else if(curr > (sum - curr)){\\n                ans = max(ans,fun(stoneValue,k+1,j) + (sum - curr));\\n            }\\n            else{\\n                ans = max(ans, curr + max(fun(stoneValue,i,k),fun(stoneValue,k+1,j)));\\n            }\\n            \\n        }\\n        \\n        dp[i][j] = ans;\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int stoneGameV(vector<int>& stoneValue) {\\n        \\n        int size = stoneValue.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return fun(stoneValue,0,size-1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265610,
                "title": "top-down-dp-commented",
                "content": "```\\nclass Solution {\\n    public int stoneGameV(int[] s) {\\n        int n = s.length;\\n\\t\\t//prefix array so that difference between left and right can be calculated in O(1)\\n        int[] prefix = new int[n];\\n\\t\\t//2D DP array for each cut (length) vs. elements containing the actual sum\\n        int[][] dp = new int[n][n];\\n        prefix[0] = s[0];\\n        for(int i=1; i<n; i++) {\\n            prefix[i] = prefix[i-1] + s[i];\\n        }\\n        \\n        return minimax5(s, prefix, 0, n-1, dp);\\n    }\\n\\n    private int minimax5(int[] stones, int[] pre, int s, int e, int[][] dp) {\\n\\t\\t//base case: no profit as game ends when there\\'s only one stone left\\n        if(s==e) {\\n            return 0;\\n        }\\n\\t\\t//return the memoized solution\\n        if(dp[s][e]!=0) return dp[s][e];\\n        int sum = 0, ans = Integer.MIN_VALUE;\\n\\t\\t//make a cut at each length and find the one with maximum profit\\n        for(int i=s; i<e; i++) {\\n            int left = s == 0? 0 : pre[s-1];\\n\\t\\t\\t//calculate left and right sum at the cut using prefix array built earlier\\n            int pl = pre[i] - left; int pr = pre[e] - pre[i];\\n            sum = Math.min(pl, pr);\\n            \\n\\t\\t\\t//pick the one with lower value as the larger one will be thrown\\n\\t\\t\\t//in case of equal partition, we need to look both ways and find the one that returns maximum value\\n            if(pl>pr) {\\n                sum += minimax5(stones, pre, i+1, e, dp);\\n            }else if(pl<pr) {\\n                sum += minimax5(stones, pre, s, i, dp);\\n            }else{\\n                sum += \\n                    Math.max(minimax5(stones, pre, i+1, e, dp), minimax5(stones, pre, s, i, dp));\\n            }\\n            //save the overall maximum\\n            ans = Math.max(ans, sum);\\n        }\\n        //memoize the answer and return\\n        return dp[s][e]=ans;\\n    }\\n}\\n```\\n\\nHowever, I am not sure what would be it\\'s time complexity (seems O(n^3) but not sure). If anyone can explain, that\\'d be very helpful.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int stoneGameV(int[] s) {\\n        int n = s.length;\\n\\t\\t//prefix array so that difference between left and right can be calculated in O(1)\\n        int[] prefix = new int[n];\\n\\t\\t//2D DP array for each cut (length) vs. elements containing the actual sum\\n        int[][] dp = new int[n][n];\\n        prefix[0] = s[0];\\n        for(int i=1; i<n; i++) {\\n            prefix[i] = prefix[i-1] + s[i];\\n        }\\n        \\n        return minimax5(s, prefix, 0, n-1, dp);\\n    }\\n\\n    private int minimax5(int[] stones, int[] pre, int s, int e, int[][] dp) {\\n\\t\\t//base case: no profit as game ends when there\\'s only one stone left\\n        if(s==e) {\\n            return 0;\\n        }\\n\\t\\t//return the memoized solution\\n        if(dp[s][e]!=0) return dp[s][e];\\n        int sum = 0, ans = Integer.MIN_VALUE;\\n\\t\\t//make a cut at each length and find the one with maximum profit\\n        for(int i=s; i<e; i++) {\\n            int left = s == 0? 0 : pre[s-1];\\n\\t\\t\\t//calculate left and right sum at the cut using prefix array built earlier\\n            int pl = pre[i] - left; int pr = pre[e] - pre[i];\\n            sum = Math.min(pl, pr);\\n            \\n\\t\\t\\t//pick the one with lower value as the larger one will be thrown\\n\\t\\t\\t//in case of equal partition, we need to look both ways and find the one that returns maximum value\\n            if(pl>pr) {\\n                sum += minimax5(stones, pre, i+1, e, dp);\\n            }else if(pl<pr) {\\n                sum += minimax5(stones, pre, s, i, dp);\\n            }else{\\n                sum += \\n                    Math.max(minimax5(stones, pre, i+1, e, dp), minimax5(stones, pre, s, i, dp));\\n            }\\n            //save the overall maximum\\n            ans = Math.max(ans, sum);\\n        }\\n        //memoize the answer and return\\n        return dp[s][e]=ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202868,
                "title": "recursion-dp",
                "content": "**TLE Error Recursion Code**\\n```\\n public int solve(int si , int ei , int[]arr){\\n        \\n        if(si>ei){\\n            return 0;\\n        }\\n        \\n        int rightPart =0 , leftPart=0 , result=0;\\n       \\n        for(int i=si;i<=ei;i++){\\n            rightPart+=arr[i];\\n        }\\n        \\n        for(int i=si;i<ei;i++){\\n            leftPart+=arr[i];\\n            rightPart-=arr[i];\\n            \\n            \\n            // bob will throw maximum one so we need to add the leftpart in our result\\n            if(leftPart<rightPart)result = Math.max(result , leftPart+solve(si , i , arr));\\n            // bob will throw maximum one so we need to add the rightpart in our result\\n            if(leftPart>rightPart)result = Math.max(result , rightPart+solve(i+1, ei , arr)); \\n            //if both are equal then alice will decide which need to be thrown \\n            if(leftPart==rightPart) result = Math.max(result , leftPart + Math.max(solve(si , i , arr) , solve(i+1 , ei , arr)));\\n            \\n            \\n            \\n        }\\n        \\n        return result;\\n    }\\n```\\n\\n\\n**Dp Top down **\\n\\n\\n```\\n  public int solve(int si , int ei , int[]arr , int[][] strg){\\n        \\n        if(si>ei){\\n            return 0;\\n        }\\n        if(strg[si][ei]!=-1){\\n            return strg[si][ei];\\n        }\\n        int rightPart =0 , leftPart=0 , result=0;\\n       \\n        for(int i=si;i<=ei;i++){\\n            rightPart+=arr[i];\\n        }\\n        \\n        for(int i=si;i<ei;i++){\\n            leftPart+=arr[i];\\n            rightPart-=arr[i];\\n            \\n            \\n            // bob will throw maximum one so we need to add the leftpart in our result\\n            if(leftPart<rightPart)result = Math.max(result , leftPart+solve(si , i , arr , strg));\\n            // bob will throw maximum one so we need to add the rightpart in our result\\n            if(leftPart>rightPart)result = Math.max(result , rightPart+solve(i+1, ei , arr , strg)); \\n            //if both are equal then alice will decide which need to be thrown \\n            if(leftPart==rightPart) result = Math.max(result , leftPart + Math.max(solve(si , i , arr , strg) , solve(i+1 , ei , arr , strg)));\\n            \\n            \\n            \\n        }\\n        strg[si][ei]=result;\\n        return result;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n public int solve(int si , int ei , int[]arr){\\n        \\n        if(si>ei){\\n            return 0;\\n        }\\n        \\n        int rightPart =0 , leftPart=0 , result=0;\\n       \\n        for(int i=si;i<=ei;i++){\\n            rightPart+=arr[i];\\n        }\\n        \\n        for(int i=si;i<ei;i++){\\n            leftPart+=arr[i];\\n            rightPart-=arr[i];\\n            \\n            \\n            // bob will throw maximum one so we need to add the leftpart in our result\\n            if(leftPart<rightPart)result = Math.max(result , leftPart+solve(si , i , arr));\\n            // bob will throw maximum one so we need to add the rightpart in our result\\n            if(leftPart>rightPart)result = Math.max(result , rightPart+solve(i+1, ei , arr)); \\n            //if both are equal then alice will decide which need to be thrown \\n            if(leftPart==rightPart) result = Math.max(result , leftPart + Math.max(solve(si , i , arr) , solve(i+1 , ei , arr)));\\n            \\n            \\n            \\n        }\\n        \\n        return result;\\n    }\\n```\n```\\n  public int solve(int si , int ei , int[]arr , int[][] strg){\\n        \\n        if(si>ei){\\n            return 0;\\n        }\\n        if(strg[si][ei]!=-1){\\n            return strg[si][ei];\\n        }\\n        int rightPart =0 , leftPart=0 , result=0;\\n       \\n        for(int i=si;i<=ei;i++){\\n            rightPart+=arr[i];\\n        }\\n        \\n        for(int i=si;i<ei;i++){\\n            leftPart+=arr[i];\\n            rightPart-=arr[i];\\n            \\n            \\n            // bob will throw maximum one so we need to add the leftpart in our result\\n            if(leftPart<rightPart)result = Math.max(result , leftPart+solve(si , i , arr , strg));\\n            // bob will throw maximum one so we need to add the rightpart in our result\\n            if(leftPart>rightPart)result = Math.max(result , rightPart+solve(i+1, ei , arr , strg)); \\n            //if both are equal then alice will decide which need to be thrown \\n            if(leftPart==rightPart) result = Math.max(result , leftPart + Math.max(solve(si , i , arr , strg) , solve(i+1 , ei , arr , strg)));\\n            \\n            \\n            \\n        }\\n        strg[si][ei]=result;\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1197543,
                "title": "c-solution-using-memoization-and-prefix-sum",
                "content": "```\\npublic class Solution {\\n    int[,] dp;\\n    int[] prefix;\\n    public int Solve(int[] arr, int i, int j)\\n    {\\n        if(i>=j) return 0;\\n        if(dp[i,j]!=0) return dp[i,j];\\n        int res = 0;\\n        for(int k=i;k<=j;k++)\\n        {\\n            int left = prefix[k+1] - prefix[i];\\n            int right = prefix[j+1] - prefix[k+1];\\n            if(left>right)\\n            {\\n                res = Math.Max(res, right + Solve(arr,k+1,j));\\n            }\\n            else if(left<right)\\n            {\\n                res = Math.Max(res, left + Solve(arr,i,k));\\n            }\\n            else\\n            {\\n                res = Math.Max(res, right + Math.Max(Solve(arr,i,k),Solve(arr,k+1,j)));\\n            }\\n            \\n        }\\n        \\n        dp[i,j] = res;\\n        return res;\\n        \\n    }\\n    public int StoneGameV(int[] stoneValue) {\\n        int n = stoneValue.Count();\\n        dp = new int[n,n];\\n        prefix = new int[n+1];\\n        prefix[0] = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            prefix[i+1] = prefix[i] + stoneValue[i];\\n        }\\n        return Solve(stoneValue,0,n-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int[,] dp;\\n    int[] prefix;\\n    public int Solve(int[] arr, int i, int j)\\n    {\\n        if(i>=j) return 0;\\n        if(dp[i,j]!=0) return dp[i,j];\\n        int res = 0;\\n        for(int k=i;k<=j;k++)\\n        {\\n            int left = prefix[k+1] - prefix[i];\\n            int right = prefix[j+1] - prefix[k+1];\\n            if(left>right)\\n            {\\n                res = Math.Max(res, right + Solve(arr,k+1,j));\\n            }\\n            else if(left<right)\\n            {\\n                res = Math.Max(res, left + Solve(arr,i,k));\\n            }\\n            else\\n            {\\n                res = Math.Max(res, right + Math.Max(Solve(arr,i,k),Solve(arr,k+1,j)));\\n            }\\n            \\n        }\\n        \\n        dp[i,j] = res;\\n        return res;\\n        \\n    }\\n    public int StoneGameV(int[] stoneValue) {\\n        int n = stoneValue.Count();\\n        dp = new int[n,n];\\n        prefix = new int[n+1];\\n        prefix[0] = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            prefix[i+1] = prefix[i] + stoneValue[i];\\n        }\\n        return Solve(stoneValue,0,n-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194596,
                "title": "100-t-100-s-c-python-memoization",
                "content": "Down below, you\\'ll find C and Python implementations for the same. Funny how a 100% faster C solution exceeds the allotted time limit when coded in Python, The code is pretty self explanatory. Let me know if you still need help in the comments below.\\n\\n**C**\\n\\n```\\nint dp[501][501];\\n\\nint max(int a, int b)\\n{\\n    return (a > b)? a: b;\\n}\\n\\nint playGame(int* sumValue, int* arr, int i, int j)\\n{\\n    if(dp[i][j] != -1)\\n        return dp[i][j];\\n    if(i == j)\\n    {\\n        dp[i][j] = 0;\\n        return 0;\\n    }\\n    int res, k, ans = 0;\\n    for(k = i; k < j; k++)\\n    {\\n        int left = sumValue[k + 1] - sumValue[i], right = sumValue[j + 1] - sumValue[k + 1];\\n        if(left > right)\\n            res = right + playGame(sumValue, arr, k + 1, j);    \\n        else if(left < right)\\n            res = left + playGame(sumValue, arr, i, k);                    \\n        else\\n            res = max(left + playGame(sumValue, arr, i, k), right + playGame(sumValue, arr, k + 1, j)); \\n        ans = max(ans, res);\\n    }\\n    dp[i][j] = ans;\\n    return ans;\\n}\\n\\nint stoneGameV(int* stoneValue, int stoneValueSize)\\n{\\n    memset(dp, -1, sizeof(dp));\\n    if(stoneValueSize == 1)\\n        return 0;\\n        \\n    int i;\\n    int* sumValue = (int*)malloc(sizeof(int) * (stoneValueSize + 1));\\n    sumValue[0] = 0;\\n    sumValue[1] = stoneValue[0];\\n    \\n    for(i = 1; i < stoneValueSize; i++)\\n        sumValue[i + 1] = sumValue[i] + stoneValue[i];\\n    \\n    return playGame(sumValue, stoneValue, 0, stoneValueSize - 1);\\n}\\n```\\n\\n**Python**\\n\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def stoneGameV(self, arr: List[int]) -> int:\\n        if len(arr) == 1:\\n            return 0\\n        \\n        sumValue = [0, arr[0]]\\n        for i in range(1, len(arr)):\\n            sumValue.append(sumValue[-1] + arr[i])\\n            \\n        @lru_cache(None)\\n        def playGame(i, j):\\n            if i == j:\\n                return 0\\n            ans = 0\\n            for k in range(i, j):\\n                left, right = sumValue[k + 1] - sumValue[i], sumValue[j + 1] - sumValue[k + 1] \\n                # sum(arr[i: k + 1]), sum(arr[k + 1: j + 1])\\n                if left > right:\\n                    res = right + playGame(k + 1, j)    \\n                elif left < right:\\n                    res = left + playGame(i, k)                    \\n                else:\\n                    res = max(left + playGame(i, k), right + playGame(k + 1, j))    \\n                ans = max(ans, res)\\n            return ans\\n        return playGame(0, len(arr) - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Memoization"
                ],
                "code": "```\\nint dp[501][501];\\n\\nint max(int a, int b)\\n{\\n    return (a > b)? a: b;\\n}\\n\\nint playGame(int* sumValue, int* arr, int i, int j)\\n{\\n    if(dp[i][j] != -1)\\n        return dp[i][j];\\n    if(i == j)\\n    {\\n        dp[i][j] = 0;\\n        return 0;\\n    }\\n    int res, k, ans = 0;\\n    for(k = i; k < j; k++)\\n    {\\n        int left = sumValue[k + 1] - sumValue[i], right = sumValue[j + 1] - sumValue[k + 1];\\n        if(left > right)\\n            res = right + playGame(sumValue, arr, k + 1, j);    \\n        else if(left < right)\\n            res = left + playGame(sumValue, arr, i, k);                    \\n        else\\n            res = max(left + playGame(sumValue, arr, i, k), right + playGame(sumValue, arr, k + 1, j)); \\n        ans = max(ans, res);\\n    }\\n    dp[i][j] = ans;\\n    return ans;\\n}\\n\\nint stoneGameV(int* stoneValue, int stoneValueSize)\\n{\\n    memset(dp, -1, sizeof(dp));\\n    if(stoneValueSize == 1)\\n        return 0;\\n        \\n    int i;\\n    int* sumValue = (int*)malloc(sizeof(int) * (stoneValueSize + 1));\\n    sumValue[0] = 0;\\n    sumValue[1] = stoneValue[0];\\n    \\n    for(i = 1; i < stoneValueSize; i++)\\n        sumValue[i + 1] = sumValue[i] + stoneValue[i];\\n    \\n    return playGame(sumValue, stoneValue, 0, stoneValueSize - 1);\\n}\\n```\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def stoneGameV(self, arr: List[int]) -> int:\\n        if len(arr) == 1:\\n            return 0\\n        \\n        sumValue = [0, arr[0]]\\n        for i in range(1, len(arr)):\\n            sumValue.append(sumValue[-1] + arr[i])\\n            \\n        @lru_cache(None)\\n        def playGame(i, j):\\n            if i == j:\\n                return 0\\n            ans = 0\\n            for k in range(i, j):\\n                left, right = sumValue[k + 1] - sumValue[i], sumValue[j + 1] - sumValue[k + 1] \\n                # sum(arr[i: k + 1]), sum(arr[k + 1: j + 1])\\n                if left > right:\\n                    res = right + playGame(k + 1, j)    \\n                elif left < right:\\n                    res = left + playGame(i, k)                    \\n                else:\\n                    res = max(left + playGame(i, k), right + playGame(k + 1, j))    \\n                ans = max(ans, res)\\n            return ans\\n        return playGame(0, len(arr) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132778,
                "title": "80ms-c-dp-and-reduce-branches",
                "content": "The key to accelerate the code is to reduce branches (`if(2*min(sumL, sumR) < tmp) continue;`), which helps to reduce runtime from 800ms to 80ms (faster than 97%).\\n```c++\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& v) {\\n        //dp[i][j]: max scores obtained from v[i:j]\\n        //dp[i][j] = max{ (  sum(v[i:k])  <  sum(v[k+1:j])  )  ?  sum(v[i:k]) + dp[i][k]  :  sum(v[k+1:j]) + dp[k+1][j] } for k in [i,j-1]\\n        int n = v.size();\\n        if(n == 1) return 0;\\n        vector<int> sum(n, 0);\\n        int lsum = 0;\\n        for(int i = 0; i < n; i++) sum[i] = lsum = lsum + v[i];\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        function<int(int,int)> helper = [&](int i, int j){ \\n            if(i == j) return 0;\\n            if(dp[i][j]) return dp[i][j];\\n            int tmp = 0;\\n            int init = i > 0 ? sum[i-1] : 0; //careful\\n            for(int k = i; k <= j-1; k++){ //careful about range of k\\n                int sumL = sum[k] - init;\\n                int sumR = sum[j] - sum[k];\\n                if(2*min(sumL, sumR) < tmp) continue; //key to reduce the runtime: 2*min(sumL, sumR) is the score upper bound for this cut (reduce runtime from 800ms to 80ms)\\n                if(sumL != sumR) tmp = max(tmp, (sumL<sumR) ? sumL + helper(i,k) : sumR + helper(k+1,j));\\n                else tmp = max(tmp, max(sumL + helper(i,k), sumR + helper(k+1,j)));\\n            }\\n            return dp[i][j] = tmp;\\n        };\\n        return helper(0, n-1);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& v) {\\n        //dp[i][j]: max scores obtained from v[i:j]\\n        //dp[i][j] = max{ (  sum(v[i:k])  <  sum(v[k+1:j])  )  ?  sum(v[i:k]) + dp[i][k]  :  sum(v[k+1:j]) + dp[k+1][j] } for k in [i,j-1]\\n        int n = v.size();\\n        if(n == 1) return 0;\\n        vector<int> sum(n, 0);\\n        int lsum = 0;\\n        for(int i = 0; i < n; i++) sum[i] = lsum = lsum + v[i];\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        function<int(int,int)> helper = [&](int i, int j){ \\n            if(i == j) return 0;\\n            if(dp[i][j]) return dp[i][j];\\n            int tmp = 0;\\n            int init = i > 0 ? sum[i-1] : 0; //careful\\n            for(int k = i; k <= j-1; k++){ //careful about range of k\\n                int sumL = sum[k] - init;\\n                int sumR = sum[j] - sum[k];\\n                if(2*min(sumL, sumR) < tmp) continue; //key to reduce the runtime: 2*min(sumL, sumR) is the score upper bound for this cut (reduce runtime from 800ms to 80ms)\\n                if(sumL != sumR) tmp = max(tmp, (sumL<sumR) ? sumL + helper(i,k) : sumR + helper(k+1,j));\\n                else tmp = max(tmp, max(sumL + helper(i,k), sumR + helper(k+1,j)));\\n            }\\n            return dp[i][j] = tmp;\\n        };\\n        return helper(0, n-1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122670,
                "title": "javascript-beats-100-time-and-100-memory-368ms-39-4mb",
                "content": "```\\nvar stoneGameV = function(stones) {\\n    let bestAns = 0\\n    let stoneSum = stones.reduce((sum, current)=> {return sum+ current},0)\\n\\n    function splitAndAdd(stoneSum, ans, leftBound,rightBound){\\n\\t\\n        if (rightBound === leftBound){return ans}\\n\\n        if (rightBound - leftBound === 1){\\n            return ans + Math.min(stones[leftBound], stones[rightBound])\\n        }\\n        let bestSoFar = 0\\n        let leftSum = 0\\n        let rightSum = stoneSum\\n        for(let i = leftBound; i <= rightBound; i++){\\n            leftSum += stones[i]\\n            rightSum -=stones[i]\\n            \\n      \\n            if (2* Math.min(leftSum, rightSum) + ans < bestAns){continue} \\n            if (leftSum === rightSum){\\n                bestSoFar =  Math.max(splitAndAdd(leftSum, ans+leftSum, leftBound,i), bestSoFar)\\n                bestSoFar = Math.max(splitAndAdd(rightSum, ans+rightSum, i+1, rightBound), bestSoFar)\\n                  \\n            } else{\\n                    \\n                    leftSum > rightSum\\n                    ? bestSoFar = Math.max(splitAndAdd(rightSum, ans+rightSum, i+1, rightBound),bestSoFar)\\n                    : bestSoFar = Math.max(splitAndAdd(leftSum, ans+leftSum, leftBound, i), bestSoFar)\\n            }\\n        \\n        }\\n        \\n        bestAns = Math.max(bestAns, bestSoFar)\\n        return bestSoFar\\n    }\\n    \\n    \\n    let ans = splitAndAdd(stoneSum, 0, 0, stones.length-1)\\n    return ans\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar stoneGameV = function(stones) {\\n    let bestAns = 0\\n    let stoneSum = stones.reduce((sum, current)=> {return sum+ current},0)\\n\\n    function splitAndAdd(stoneSum, ans, leftBound,rightBound){\\n\\t\\n        if (rightBound === leftBound){return ans}\\n\\n        if (rightBound - leftBound === 1){\\n            return ans + Math.min(stones[leftBound], stones[rightBound])\\n        }\\n        let bestSoFar = 0\\n        let leftSum = 0\\n        let rightSum = stoneSum\\n        for(let i = leftBound; i <= rightBound; i++){\\n            leftSum += stones[i]\\n            rightSum -=stones[i]\\n            \\n      \\n            if (2* Math.min(leftSum, rightSum) + ans < bestAns){continue} \\n            if (leftSum === rightSum){\\n                bestSoFar =  Math.max(splitAndAdd(leftSum, ans+leftSum, leftBound,i), bestSoFar)\\n                bestSoFar = Math.max(splitAndAdd(rightSum, ans+rightSum, i+1, rightBound), bestSoFar)\\n                  \\n            } else{\\n                    \\n                    leftSum > rightSum\\n                    ? bestSoFar = Math.max(splitAndAdd(rightSum, ans+rightSum, i+1, rightBound),bestSoFar)\\n                    : bestSoFar = Math.max(splitAndAdd(leftSum, ans+leftSum, leftBound, i), bestSoFar)\\n            }\\n        \\n        }\\n        \\n        bestAns = Math.max(bestAns, bestSoFar)\\n        return bestSoFar\\n    }\\n    \\n    \\n    let ans = splitAndAdd(stoneSum, 0, 0, stones.length-1)\\n    return ans\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1005878,
                "title": "c-solution-recursive-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> presum;\\n    \\n    vector<vector<int>> dp;\\n    \\n    vector<int> stones;\\n    \\n    int solve(int i,int j)\\n    {\\n        \\n\\n\\n        if(i>j)\\n            return 0;\\n\\n        \\n        if(i == j)\\n            return 0;\\n       \\n        \\n        if(j-i == 1)\\n        {\\n            return min(stones[i],stones[j]);\\n        }\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int ans = 0;\\n        \\n        \\n        for(int k = i;k<j;k++)\\n        {\\n            \\n            \\n            int pre_;\\n            \\n            if(i-1 <0)\\n            {\\n                pre_ = 0;\\n            }\\n            else\\n            {\\n                pre_ = presum[i-1];\\n            }\\n            \\n            if(presum[k]-pre_>presum[j]-presum[k])\\n            {\\n                int temp = solve(k+1,j);\\n                int x_ = presum[j]-presum[k];\\n                ans = max(ans,temp+x_);\\n            }\\n            else if(presum[k]-pre_<presum[j]-presum[k])\\n            {\\n                int temp = solve(i,k);\\n                int x_ = presum[k]-pre_;\\n                ans = max(ans,temp+x_);\\n            }\\n            else\\n            {\\n                \\n                int temp1 = solve(k+1,j)+presum[j]-presum[k];\\n                int temp2 = solve(i,k)+presum[k]-pre_;\\n                ans = max(ans,max(temp1,temp2));\\n                \\n            }            \\n            \\n        }\\n        return  dp[i][j] = ans;\\n    }\\n    \\n    \\n    \\n    int stoneGameV(vector<int>& stoneValue) {\\n        \\n        \\n        \\n        dp.resize(stoneValue.size()+1,vector<int>(stoneValue.size()+1,-1));\\n        presum.resize(stoneValue.size(),0);\\n        stones = stoneValue;\\n        \\n        presum[0] = stoneValue[0];        \\n        for(int i = 1;i<stoneValue.size();i++)\\n        {\\n            presum[i] = presum[i-1]+stoneValue[i];\\n        }\\n        \\n        \\n        return solve(0,stoneValue.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> presum;\\n    \\n    vector<vector<int>> dp;\\n    \\n    vector<int> stones;\\n    \\n    int solve(int i,int j)\\n    {\\n        \\n\\n\\n        if(i>j)\\n            return 0;\\n\\n        \\n        if(i == j)\\n            return 0;\\n       \\n        \\n        if(j-i == 1)\\n        {\\n            return min(stones[i],stones[j]);\\n        }\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int ans = 0;\\n        \\n        \\n        for(int k = i;k<j;k++)\\n        {\\n            \\n            \\n            int pre_;\\n            \\n            if(i-1 <0)\\n            {\\n                pre_ = 0;\\n            }\\n            else\\n            {\\n                pre_ = presum[i-1];\\n            }\\n            \\n            if(presum[k]-pre_>presum[j]-presum[k])\\n            {\\n                int temp = solve(k+1,j);\\n                int x_ = presum[j]-presum[k];\\n                ans = max(ans,temp+x_);\\n            }\\n            else if(presum[k]-pre_<presum[j]-presum[k])\\n            {\\n                int temp = solve(i,k);\\n                int x_ = presum[k]-pre_;\\n                ans = max(ans,temp+x_);\\n            }\\n            else\\n            {\\n                \\n                int temp1 = solve(k+1,j)+presum[j]-presum[k];\\n                int temp2 = solve(i,k)+presum[k]-pre_;\\n                ans = max(ans,max(temp1,temp2));\\n                \\n            }            \\n            \\n        }\\n        return  dp[i][j] = ans;\\n    }\\n    \\n    \\n    \\n    int stoneGameV(vector<int>& stoneValue) {\\n        \\n        \\n        \\n        dp.resize(stoneValue.size()+1,vector<int>(stoneValue.size()+1,-1));\\n        presum.resize(stoneValue.size(),0);\\n        stones = stoneValue;\\n        \\n        presum[0] = stoneValue[0];        \\n        for(int i = 1;i<stoneValue.size();i++)\\n        {\\n            presum[i] = presum[i-1]+stoneValue[i];\\n        }\\n        \\n        \\n        return solve(0,stoneValue.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 911395,
                "title": "c-dp-ft-prefix-sum-clean-code",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int prefixSum[501];\\n    \\n    int helper(vector<int>& s, int l, int r){\\n        \\n        if(l >= r) return 0;  // BASE case\\n        \\n        if(dp[l][r] != -1)return dp[l][r]; // Return pre commputed sub-problem.\\n        \\n        int ans = INT_MIN;\\n        \\n        for(int i = 0; i < r-l; i++){  // You can only break the array at l+0, l+1, l+2,.....r-1 th index.\\n            \\n           int L = prefixSum[l+i+1] - prefixSum[l];\\n           int R = prefixSum[r+1] - prefixSum[l+i+1];\\n            \\n            if(L < R){\\n                int temp = dp[l][l+i] == -1 ? helper(s, l, l+i) : dp[l][l+i];\\n                ans = max(ans, L + temp);\\n            }\\n            else if (R < L){\\n                int temp = dp[l+i+1][r] == -1 ? helper(s, l + i + 1, r) : dp[l+i+1][r];\\n                ans = max(ans, temp + R);\\n            }\\n            else{\\n                int temp1 = dp[l][l+i] == -1 ? helper(s, l, l+i) : dp[l][l+i];\\n                int temp2 = dp[l+i+1][r] == -1 ? helper(s, l + i + 1, r) : dp[l+i+1][r];\\n                ans = max(ans, L + max(temp1, temp2));\\n            }\\n        }\\n        return dp[l][r] = ans;\\n    }\\n    \\n    \\n    int stoneGameV(vector<int>& stoneValue) {\\n        int ans = INT_MIN;\\n        memset(dp, -1, sizeof dp);\\n        int n = stoneValue.size();\\n        \\n        prefixSum[0] = 0;  // Prefix sum is used to optimize the intermediate Range Sum...\\n        \\n        for(int i = 0; i < n; i++)prefixSum[i+1] = prefixSum[i] + stoneValue[i];\\n        \\n        ans = helper(stoneValue, 0, n - 1);\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int prefixSum[501];\\n    \\n    int helper(vector<int>& s, int l, int r){\\n        \\n        if(l >= r) return 0;  // BASE case\\n        \\n        if(dp[l][r] != -1)return dp[l][r]; // Return pre commputed sub-problem.\\n        \\n        int ans = INT_MIN;\\n        \\n        for(int i = 0; i < r-l; i++){  // You can only break the array at l+0, l+1, l+2,.....r-1 th index.\\n            \\n           int L = prefixSum[l+i+1] - prefixSum[l];\\n           int R = prefixSum[r+1] - prefixSum[l+i+1];\\n            \\n            if(L < R){\\n                int temp = dp[l][l+i] == -1 ? helper(s, l, l+i) : dp[l][l+i];\\n                ans = max(ans, L + temp);\\n            }\\n            else if (R < L){\\n                int temp = dp[l+i+1][r] == -1 ? helper(s, l + i + 1, r) : dp[l+i+1][r];\\n                ans = max(ans, temp + R);\\n            }\\n            else{\\n                int temp1 = dp[l][l+i] == -1 ? helper(s, l, l+i) : dp[l][l+i];\\n                int temp2 = dp[l+i+1][r] == -1 ? helper(s, l + i + 1, r) : dp[l+i+1][r];\\n                ans = max(ans, L + max(temp1, temp2));\\n            }\\n        }\\n        return dp[l][r] = ans;\\n    }\\n    \\n    \\n    int stoneGameV(vector<int>& stoneValue) {\\n        int ans = INT_MIN;\\n        memset(dp, -1, sizeof dp);\\n        int n = stoneValue.size();\\n        \\n        prefixSum[0] = 0;  // Prefix sum is used to optimize the intermediate Range Sum...\\n        \\n        for(int i = 0; i < n; i++)prefixSum[i+1] = prefixSum[i] + stoneValue[i];\\n        \\n        ans = helper(stoneValue, 0, n - 1);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879351,
                "title": "java-solution-from-brute-force-to-dp-o-n-3",
                "content": "Solution brute-force - Time Limit Exceeded \\n```\\npublic class StoneGameVRecursiveApproach {\\n    public static void main(String[] args) {\\n        int[] stoneGame = {6, 2, 3, 4, 5, 5};\\n        System.out.println(stoneGameV(stoneGame));\\n    }\\n\\n    public static int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] sum = createPrefixSum(stoneValue);\\n        return stoneGameV(0, n - 1, sum);\\n    }\\n\\n    private static int stoneGameV(int i, int k, int[] sum) {\\n        if (i >= k) return 0;\\n        int maxScore = Integer.MIN_VALUE;\\n        for (int j = i; j < k; j++) { // divides to 2 rows (i, j), (j+1, k)\\n            int sum1 = sum[j + 1] - sum[i]; // sum from i -> j inclusive\\n            int sum2 = sum[k + 1] - sum[j + 1]; // sum from j+1 -> k inclusive\\n            if (sum1 > sum2) { // Bob removes left\\n                maxScore = Math.max(maxScore, stoneGameV(j + 1, k, sum) + sum2);\\n            } else if (sum1 < sum2) { // Bob removes right\\n                maxScore = Math.max(maxScore, stoneGameV(i, j, sum) + sum1);\\n            } else { // Bob let Alice to decide which rows will be removed.\\n                maxScore = Math.max(maxScore, Math.max(stoneGameV(i, j, sum), stoneGameV(j + 1, k, sum)) + sum1);\\n            }\\n        }\\n        return maxScore;\\n    }\\n\\n    private static int[] createPrefixSum(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] sum = new int[n + 1];\\n        for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + stoneValue[i];\\n        return sum;\\n    }\\n}\\n\\n```\\n\\nSolution uses memoization\\n```\\npublic class StoneGameVMemoizationApproach {\\n    public static void main(String[] args) {\\n        int[] stoneGame = {6, 2, 3, 4, 5, 5};\\n        System.out.println(stoneGameV(stoneGame));\\n    }\\n\\n    public static int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] sum = createPrefixSum(stoneValue);\\n        int[][] memo = new int[n][n];\\n        stoneGameV(0, n - 1, sum, memo);\\n        return memo[0][n - 1];\\n    }\\n\\n    private static int stoneGameV(int i, int k, int[] sum, int[][] memo) {\\n        if (i >= k) return 0;\\n        if (memo[i][k] > 0) return memo[i][k];\\n        int maxScore = Integer.MIN_VALUE;\\n        for (int j = i; j < k; j++) { // divides to 2 rows (i, j), (j+1, k)\\n            int sum1 = sum[j + 1] - sum[i]; // sum from i -> j inclusive\\n            int sum2 = sum[k + 1] - sum[j + 1]; // sum from j+1 -> k inclusive\\n            if (sum1 > sum2) { // Bob removes left\\n                maxScore = Math.max(maxScore, stoneGameV(j + 1, k, sum, memo) + sum2);\\n            } else if (sum1 < sum2) { // Bob removes right\\n                maxScore = Math.max(maxScore, stoneGameV(i, j, sum, memo) + sum1);\\n            } else { // Bob let Alice to decide which rows will be removed.\\n                maxScore = Math.max(maxScore, Math.max(stoneGameV(i, j, sum, memo), stoneGameV(j + 1, k, sum, memo)) + sum1);\\n            }\\n        }\\n        memo[i][k] = maxScore;\\n        return maxScore;\\n    }\\n\\n    private static int[] createPrefixSum(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] sum = new int[n + 1];\\n        for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + stoneValue[i];\\n        return sum;\\n    }\\n}\\n```\\n\\nSolution uses DP Bottom-up\\n```\\n\\npublic class StoneGameVBottomUpApproach {\\n    public static void main(String[] args) {\\n        int[] stoneGame = {6, 2, 3, 4, 5, 5};\\n        System.out.println(stoneGameV(stoneGame));\\n    }\\n\\n    public static int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] sum = createPrefixSum(stoneValue);\\n        int[][] dp = new int[n][n];\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int k = 0; k < n; k++) {\\n                if (i >= k) continue;\\n                dp[i][k] = Integer.MIN_VALUE;\\n                for (int j = i; j < k; j++) { // divides to 2 rows (i, j), (j+1, k)\\n                    int sum1 = sum[j + 1] - sum[i]; // sum from i -> j inclusive\\n                    int sum2 = sum[k + 1] - sum[j + 1]; // sum from j+1 -> k inclusive\\n                    if (sum1 > sum2) { // Bob removes left\\n                        dp[i][k] = Math.max(dp[i][k], dp[j + 1][k] + sum2);\\n                    } else if (sum1 < sum2) { // Bob removes right\\n                        dp[i][k] = Math.max(dp[i][k], dp[i][j] + sum1);\\n                    } else { // Bob let Alice to decide which rows will be removed.\\n                        dp[i][k] = Math.max(dp[i][k], Math.max(dp[i][j], dp[j + 1][k]) + sum1);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][n - 1];\\n    }\\n\\n    private static int[] createPrefixSum(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] sum = new int[n + 1];\\n        for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + stoneValue[i];\\n        return sum;\\n    }\\n}\\n```\\nReference: https://leetcode.com/problems/stone-game-v/discuss/870497/Java-Recursive-greater-Memoization-greater-2D-Bottom-Up\\n",
                "solutionTags": [],
                "code": "```\\npublic class StoneGameVRecursiveApproach {\\n    public static void main(String[] args) {\\n        int[] stoneGame = {6, 2, 3, 4, 5, 5};\\n        System.out.println(stoneGameV(stoneGame));\\n    }\\n\\n    public static int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] sum = createPrefixSum(stoneValue);\\n        return stoneGameV(0, n - 1, sum);\\n    }\\n\\n    private static int stoneGameV(int i, int k, int[] sum) {\\n        if (i >= k) return 0;\\n        int maxScore = Integer.MIN_VALUE;\\n        for (int j = i; j < k; j++) { // divides to 2 rows (i, j), (j+1, k)\\n            int sum1 = sum[j + 1] - sum[i]; // sum from i -> j inclusive\\n            int sum2 = sum[k + 1] - sum[j + 1]; // sum from j+1 -> k inclusive\\n            if (sum1 > sum2) { // Bob removes left\\n                maxScore = Math.max(maxScore, stoneGameV(j + 1, k, sum) + sum2);\\n            } else if (sum1 < sum2) { // Bob removes right\\n                maxScore = Math.max(maxScore, stoneGameV(i, j, sum) + sum1);\\n            } else { // Bob let Alice to decide which rows will be removed.\\n                maxScore = Math.max(maxScore, Math.max(stoneGameV(i, j, sum), stoneGameV(j + 1, k, sum)) + sum1);\\n            }\\n        }\\n        return maxScore;\\n    }\\n\\n    private static int[] createPrefixSum(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] sum = new int[n + 1];\\n        for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + stoneValue[i];\\n        return sum;\\n    }\\n}\\n\\n```\n```\\npublic class StoneGameVMemoizationApproach {\\n    public static void main(String[] args) {\\n        int[] stoneGame = {6, 2, 3, 4, 5, 5};\\n        System.out.println(stoneGameV(stoneGame));\\n    }\\n\\n    public static int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] sum = createPrefixSum(stoneValue);\\n        int[][] memo = new int[n][n];\\n        stoneGameV(0, n - 1, sum, memo);\\n        return memo[0][n - 1];\\n    }\\n\\n    private static int stoneGameV(int i, int k, int[] sum, int[][] memo) {\\n        if (i >= k) return 0;\\n        if (memo[i][k] > 0) return memo[i][k];\\n        int maxScore = Integer.MIN_VALUE;\\n        for (int j = i; j < k; j++) { // divides to 2 rows (i, j), (j+1, k)\\n            int sum1 = sum[j + 1] - sum[i]; // sum from i -> j inclusive\\n            int sum2 = sum[k + 1] - sum[j + 1]; // sum from j+1 -> k inclusive\\n            if (sum1 > sum2) { // Bob removes left\\n                maxScore = Math.max(maxScore, stoneGameV(j + 1, k, sum, memo) + sum2);\\n            } else if (sum1 < sum2) { // Bob removes right\\n                maxScore = Math.max(maxScore, stoneGameV(i, j, sum, memo) + sum1);\\n            } else { // Bob let Alice to decide which rows will be removed.\\n                maxScore = Math.max(maxScore, Math.max(stoneGameV(i, j, sum, memo), stoneGameV(j + 1, k, sum, memo)) + sum1);\\n            }\\n        }\\n        memo[i][k] = maxScore;\\n        return maxScore;\\n    }\\n\\n    private static int[] createPrefixSum(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] sum = new int[n + 1];\\n        for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + stoneValue[i];\\n        return sum;\\n    }\\n}\\n```\n```\\n\\npublic class StoneGameVBottomUpApproach {\\n    public static void main(String[] args) {\\n        int[] stoneGame = {6, 2, 3, 4, 5, 5};\\n        System.out.println(stoneGameV(stoneGame));\\n    }\\n\\n    public static int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] sum = createPrefixSum(stoneValue);\\n        int[][] dp = new int[n][n];\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int k = 0; k < n; k++) {\\n                if (i >= k) continue;\\n                dp[i][k] = Integer.MIN_VALUE;\\n                for (int j = i; j < k; j++) { // divides to 2 rows (i, j), (j+1, k)\\n                    int sum1 = sum[j + 1] - sum[i]; // sum from i -> j inclusive\\n                    int sum2 = sum[k + 1] - sum[j + 1]; // sum from j+1 -> k inclusive\\n                    if (sum1 > sum2) { // Bob removes left\\n                        dp[i][k] = Math.max(dp[i][k], dp[j + 1][k] + sum2);\\n                    } else if (sum1 < sum2) { // Bob removes right\\n                        dp[i][k] = Math.max(dp[i][k], dp[i][j] + sum1);\\n                    } else { // Bob let Alice to decide which rows will be removed.\\n                        dp[i][k] = Math.max(dp[i][k], Math.max(dp[i][j], dp[j + 1][k]) + sum1);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][n - 1];\\n    }\\n\\n    private static int[] createPrefixSum(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] sum = new int[n + 1];\\n        for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + stoneValue[i];\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839050,
                "title": "over-commented-code-for-stone-game-v-1563",
                "content": "Hopefully this helps some folks. Over-commented :-)\\n```\\nclass Solution {\\npublic:\\n    int sgv(    int b,                      /* Beginning index of row of stones */\\n                int e,                      /* Ending index of row */\\n                vector<int>& s,             /* Original row of stones - prefix-summed */\\n                vector<vector<int>>& memo)  /* Memo to not TLE */\\n    {\\n        int m/*ax score*/ = 0;\\n        \\n        /* Return if we have seen this answer from before */\\n        if (memo[b][e] != -1) return memo[b][e];\\n\\n        for (int i = b; i < e; i++) {\\n            int t = 0;\\n            /* \\n             * Alice divides the row into two different rows -\\n             * left (b - i) and right (i+1 - e). Bob now calculates\\n             * total sums using precomputed prefix sums.\\n             */\\n            int l = s[i] - (b ? s[b - 1] : 0);\\n            int r = s[e] - s[i];  \\n            if (l == r) {                   /* Alice gets a chance to pick. So, here she\\n                                             * evaluates both rows for max possible score.\\n                                             */\\n                t = l +                     /* Score Alice has now */\\n                    max(sgv(b, i, s, memo), /* Score from recursion on left row */\\n                        sgv(i+1, e, s, memo));/* Score from recursion on right row */\\n            } else if (l > r ) {            /* Bob throws away left row */\\n                t = r +                     /* Score Alice has now - right row sum */ \\n                    sgv(i+1, e, s, memo);   /* Score from recursion on the right row */\\n            } else {                        /* Bob throws away right row */\\n                t = l +                     /* Score Alice has now - left row sum */\\n                    sgv(b, i, s, memo);     /* Score from recursion on the left row */\\n            }\\n            m = max(m, t);                  /* The max score that Alice can get */\\n        }\\n        \\n        /* Remember the max score that Alice can get if \\n         * she has a row of stones beginning at b and \\n         * ending in e\\n         */\\n        return memo[b][e] = m;\\n    }\\n    \\n    int stoneGameV(vector<int>& s) {\\n        vector<vector<int>> memo(501, vector<int>(501, -1));\\n        for (int i = 1; i < s.size(); i++) s[i] += s[i-1];  /* prefix sum */\\n        return sgv(0, s.size() - 1, s, memo);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sgv(    int b,                      /* Beginning index of row of stones */\\n                int e,                      /* Ending index of row */\\n                vector<int>& s,             /* Original row of stones - prefix-summed */\\n                vector<vector<int>>& memo)  /* Memo to not TLE */\\n    {\\n        int m/*ax score*/ = 0;\\n        \\n        /* Return if we have seen this answer from before */\\n        if (memo[b][e] != -1) return memo[b][e];\\n\\n        for (int i = b; i < e; i++) {\\n            int t = 0;\\n            /* \\n             * Alice divides the row into two different rows -\\n             * left (b - i) and right (i+1 - e). Bob now calculates\\n             * total sums using precomputed prefix sums.\\n             */\\n            int l = s[i] - (b ? s[b - 1] : 0);\\n            int r = s[e] - s[i];  \\n            if (l == r) {                   /* Alice gets a chance to pick. So, here she\\n                                             * evaluates both rows for max possible score.\\n                                             */\\n                t = l +                     /* Score Alice has now */\\n                    max(sgv(b, i, s, memo), /* Score from recursion on left row */\\n                        sgv(i+1, e, s, memo));/* Score from recursion on right row */\\n            } else if (l > r ) {            /* Bob throws away left row */\\n                t = r +                     /* Score Alice has now - right row sum */ \\n                    sgv(i+1, e, s, memo);   /* Score from recursion on the right row */\\n            } else {                        /* Bob throws away right row */\\n                t = l +                     /* Score Alice has now - left row sum */\\n                    sgv(b, i, s, memo);     /* Score from recursion on the left row */\\n            }\\n            m = max(m, t);                  /* The max score that Alice can get */\\n        }\\n        \\n        /* Remember the max score that Alice can get if \\n         * she has a row of stones beginning at b and \\n         * ending in e\\n         */\\n        return memo[b][e] = m;\\n    }\\n    \\n    int stoneGameV(vector<int>& s) {\\n        vector<vector<int>> memo(501, vector<int>(501, -1));\\n        for (int i = 1; i < s.size(); i++) s[i] += s[i-1];  /* prefix sum */\\n        return sgv(0, s.size() - 1, s, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822562,
                "title": "python-need-help-with-tle-dp-o-n-3",
                "content": "126/131 cases passed. I used lru to cache results from function. \\n```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        # stoneValue\\n        prefix = [0] \\n        for v in stoneValue:\\n            prefix.append(prefix[-1]+v)\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == j:\\n                return 0\\n            val = 0\\n            for cut in range(i, j):\\n                l, r = prefix[cut+1] - prefix[i], prefix[j+1] - prefix[cut+1]\\n                if l > r:\\n                    val = max(val, r+dp(cut+1, j))\\n                elif l < r:\\n                    val = max(val, l+dp(i, cut))\\n                else:\\n                    val = max(val, l+dp(i, cut), r+dp(cut+1, j))\\n            return val\\n        return dp(0, len(stoneValue)-1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        # stoneValue\\n        prefix = [0] \\n        for v in stoneValue:\\n            prefix.append(prefix[-1]+v)\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == j:\\n                return 0\\n            val = 0\\n            for cut in range(i, j):\\n                l, r = prefix[cut+1] - prefix[i], prefix[j+1] - prefix[cut+1]\\n                if l > r:\\n                    val = max(val, r+dp(cut+1, j))\\n                elif l < r:\\n                    val = max(val, l+dp(i, cut))\\n                else:\\n                    val = max(val, l+dp(i, cut), r+dp(cut+1, j))\\n            return val\\n        return dp(0, len(stoneValue)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819238,
                "title": "java-easy-bottom-up-o-n-3",
                "content": "```\\n\\npublic int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] sum = new int[n + 1];\\n        \\n        for(int i = 0; i < n; i++){\\n            sum[i+1] = sum[i] + stoneValue[i];\\n        }\\n        \\n        int[][] dp = new int[n + 1][n + 1];\\n        \\n        for(int len = 2; len <= n; len++){\\n            for(int i = 0; i + len <= n; i++){\\n                int j = i + len;\\n                \\n                for(int k = i + 1; k < j; k++){\\n                    int left  = sum[k] - sum[i];\\n                    int right = sum[j] - sum[k];\\n                    \\n                    if(left <= right){\\n                        dp[i][j] = Math.max(dp[i][j], left + dp[i][k]);\\n                    }\\n                    \\n                    if(right <= left){\\n                        dp[i][j] = Math.max(dp[i][j], right + dp[k][j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n];\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n\\npublic int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] sum = new int[n + 1];\\n        \\n        for(int i = 0; i < n; i++){\\n            sum[i+1] = sum[i] + stoneValue[i];\\n        }\\n        \\n        int[][] dp = new int[n + 1][n + 1];\\n        \\n        for(int len = 2; len <= n; len++){\\n            for(int i = 0; i + len <= n; i++){\\n                int j = i + len;\\n                \\n                for(int k = i + 1; k < j; k++){\\n                    int left  = sum[k] - sum[i];\\n                    int right = sum[j] - sum[k];\\n                    \\n                    if(left <= right){\\n                        dp[i][j] = Math.max(dp[i][j], left + dp[i][k]);\\n                    }\\n                    \\n                    if(right <= left){\\n                        dp[i][j] = Math.max(dp[i][j], right + dp[k][j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n];\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 817678,
                "title": "well-comment-and-easy-to-understand",
                "content": "We are going to explore all the devisior of stoneValue and maintain a sum...\\nat any position there could be 3 condition\\n1.leftsum is greater then right sum\\n\\tin this case bob will through out left part and alice got the point as right sum and rest of game start with right part of stoneValue\\n2.right sum is greater then left sum\\n\\tin this case bob will through out right part and alice got the point as left sum and rest of game start with left part of stoneValue\\n3.both are equal\\n\\tlet\\'s play the alice as both above 1 and 2 condition and decide which one is better\\n```\\nint solve( vector<int> &sum ,int **dp, int left , int right ){\\n\\tif(left>right) return 0;//invalid interavel\\n\\tint &ans=dp[left][right];\\n\\tif(ans!=-1) return ans;\\n\\tfor(int i=left ; i<=right ; i++){\\n\\t\\tint leftSum=sum[i]-sum[left-1];//get the left sum and get the right sum\\n\\t\\tint rightSum=sum[right]-sum[i];\\n\\t\\tif(leftSum>rightSum){\\n\\t\\t\\t//left sum will be through out\\n\\t\\t\\tans=max(ans , rightSum+solve(sum, dp ,i+1 ,right));\\n\\t\\t}else if(leftSum<rightSum){\\n\\t\\t\\t//right sum will be through out\\n\\t\\t\\tans=max(ans , leftSum+solve(sum, dp , left , i));\\n\\t\\t}else{\\n\\t\\t\\t//let\\'s find both way\\n\\t\\t\\tans=max(ans , max(rightSum+solve(sum ,dp,  i+1 , right) , leftSum+solve(sum ,dp, left , i)));\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\nint stoneGameV(vector<int>& stoneValue) {\\n\\tint n=stoneValue.size();\\n\\tvector<int> sum(n+1);\\n\\tint **dp=new int*[n+1];\\n\\tsum[0]=0;\\n\\tfor(int i=0 ; i<=n;i++){\\n\\t\\tdp[i]=new int[n+1];\\n\\t\\tif(i) sum[i]=sum[i-1]+stoneValue[i-1];\\n\\t\\tfor(int j=0 ; j<=n ; j++) dp[i][j]=-1;\\n\\t}\\n\\treturn solve(sum,dp ,1 , stoneValue.size());\\n}\\n```\\nHappy coding!!!",
                "solutionTags": [],
                "code": "```\\nint solve( vector<int> &sum ,int **dp, int left , int right ){\\n\\tif(left>right) return 0;//invalid interavel\\n\\tint &ans=dp[left][right];\\n\\tif(ans!=-1) return ans;\\n\\tfor(int i=left ; i<=right ; i++){\\n\\t\\tint leftSum=sum[i]-sum[left-1];//get the left sum and get the right sum\\n\\t\\tint rightSum=sum[right]-sum[i];\\n\\t\\tif(leftSum>rightSum){\\n\\t\\t\\t//left sum will be through out\\n\\t\\t\\tans=max(ans , rightSum+solve(sum, dp ,i+1 ,right));\\n\\t\\t}else if(leftSum<rightSum){\\n\\t\\t\\t//right sum will be through out\\n\\t\\t\\tans=max(ans , leftSum+solve(sum, dp , left , i));\\n\\t\\t}else{\\n\\t\\t\\t//let\\'s find both way\\n\\t\\t\\tans=max(ans , max(rightSum+solve(sum ,dp,  i+1 , right) , leftSum+solve(sum ,dp, left , i)));\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\nint stoneGameV(vector<int>& stoneValue) {\\n\\tint n=stoneValue.size();\\n\\tvector<int> sum(n+1);\\n\\tint **dp=new int*[n+1];\\n\\tsum[0]=0;\\n\\tfor(int i=0 ; i<=n;i++){\\n\\t\\tdp[i]=new int[n+1];\\n\\t\\tif(i) sum[i]=sum[i-1]+stoneValue[i-1];\\n\\t\\tfor(int j=0 ; j<=n ; j++) dp[i][j]=-1;\\n\\t}\\n\\treturn solve(sum,dp ,1 , stoneValue.size());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 809585,
                "title": "easy-java-dp-solution",
                "content": "```\\nclass Solution {\\n    Integer dp[][];\\n    public int stoneGameV(int[] stoneValue) {\\n        dp=new Integer[stoneValue.length][stoneValue.length];\\n        for(int i=1;i<stoneValue.length;i++)  stoneValue[i]+=stoneValue[i-1];\\n        return check(0,stoneValue.length-1,stoneValue);\\n    }\\n    public int check(int i, int j, int arr[]){\\n        if(dp[i][j]!=null) return dp[i][j];\\n        if(i>=j) return dp[i][j]=0;\\n        int ans=0,b=(i==0)?0:arr[i-1];\\n        for(int a=i;a<j;a++){\\n            int c=arr[j]-arr[a];\\n            if(c>arr[a]-b) ans=Math.max(ans, arr[a]-b+check(i,a,arr));\\n            else if(c<arr[a]-b) ans=Math.max(ans, c+check(a+1,j,arr));\\n            else ans=Math.max(arr[a]-b+check(i,a,arr),c+check(a+1,j,arr));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    Integer dp[][];\\n    public int stoneGameV(int[] stoneValue) {\\n        dp=new Integer[stoneValue.length][stoneValue.length];\\n        for(int i=1;i<stoneValue.length;i++)  stoneValue[i]+=stoneValue[i-1];\\n        return check(0,stoneValue.length-1,stoneValue);\\n    }\\n    public int check(int i, int j, int arr[]){\\n        if(dp[i][j]!=null) return dp[i][j];\\n        if(i>=j) return dp[i][j]=0;\\n        int ans=0,b=(i==0)?0:arr[i-1];\\n        for(int a=i;a<j;a++){\\n            int c=arr[j]-arr[a];\\n            if(c>arr[a]-b) ans=Math.max(ans, arr[a]-b+check(i,a,arr));\\n            else if(c<arr[a]-b) ans=Math.max(ans, c+check(a+1,j,arr));\\n            else ans=Math.max(arr[a]-b+check(i,a,arr),c+check(a+1,j,arr));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809299,
                "title": "easy-dp-solution-using-cumulative-sum-java",
                "content": "```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n= stoneValue.length;\\n        if(n==1) return 0;\\n        int A[]= new int[n+1];\\n        int dp[][] = new int[n+1][n+1];\\n        for(int[] x:dp)Arrays.fill(x,-1);\\n        A[0]=0;\\n        for(int i=1;i<n+1;i++) A[i]=A[i-1]+stoneValue[i-1];\\n        System.out.println(Arrays.toString(A)); \\n        return dfs(dp,0,n-1,A,stoneValue); \\n    }\\n    public int dfs(int dp[][],int i, int j,int A[],int arr[]){\\n        if(j<=i) return dp[i][j]=0;\\n        if(dp[i][j]!=-1) return dp[i][j]; \\n        int max =Integer.MIN_VALUE;\\n        for(int k=i+1;k<=j;k++){\\n            int left =A[k]-A[i];\\n            int right = A[j+1]-A[k];\\n            int a;\\n            if(left<right)\\n            a =left+dfs(dp,i,k-1,A,arr);\\n            else if(right<left)\\n            a =right+dfs(dp,k,j,A,arr);\\n            else\\n            a=left+ Math.max(dfs(dp,i,k-1,A,arr),dfs(dp,k,j,A,arr));    \\n            max= Math.max(a,max);      \\n        }\\n        dp[i][j]=max;\\n        return dp[i][j];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n= stoneValue.length;\\n        if(n==1) return 0;\\n        int A[]= new int[n+1];\\n        int dp[][] = new int[n+1][n+1];\\n        for(int[] x:dp)Arrays.fill(x,-1);\\n        A[0]=0;\\n        for(int i=1;i<n+1;i++) A[i]=A[i-1]+stoneValue[i-1];\\n        System.out.println(Arrays.toString(A)); \\n        return dfs(dp,0,n-1,A,stoneValue); \\n    }\\n    public int dfs(int dp[][],int i, int j,int A[],int arr[]){\\n        if(j<=i) return dp[i][j]=0;\\n        if(dp[i][j]!=-1) return dp[i][j]; \\n        int max =Integer.MIN_VALUE;\\n        for(int k=i+1;k<=j;k++){\\n            int left =A[k]-A[i];\\n            int right = A[j+1]-A[k];\\n            int a;\\n            if(left<right)\\n            a =left+dfs(dp,i,k-1,A,arr);\\n            else if(right<left)\\n            a =right+dfs(dp,k,j,A,arr);\\n            else\\n            a=left+ Math.max(dfs(dp,i,k-1,A,arr),dfs(dp,k,j,A,arr));    \\n            max= Math.max(a,max);      \\n        }\\n        dp[i][j]=max;\\n        return dp[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807987,
                "title": "dp-javascript",
                "content": "```\\n/**\\n:subproblem\\n  what is the maximum score of the rest of the stones\\n\\n:recurrence\\n    for all possible break points\\n        if equal halfs\\n            dp[left][right] = max(\\n                leftsum + recur( left ),\\n                rightsum + recur( right )\\n            )\\n        else \\n            dp[left][right] = max( dp, recur( min( left, right ) ) )\\n    \\n    return dp[left][right]\\n */\\nvar stoneGameV = function(a) {\\n    const rowSum = getRowSumWithNums( a )\\n    const dp = Array.from({length:a.length+1},_=>Array(a.length+1).fill(0))\\n    const guess = ( left, right ) => {\\n        if ( left === right ) return 0\\n        if ( dp[ left ][ right ] ) return dp[ left ][ right ]\\n\\n        for ( let i = left + 1; i <= right; i++ ) {\\n            const leftSum = rowSum( left, i - 1 )\\n            const rightSum = rowSum( i, right )\\n\\n            if ( leftSum === rightSum ) {\\n                dp[ left ][ right ] = Math.max(\\n                    dp[ left ][ right ],\\n                    leftSum + guess( left, i - 1 ),\\n                    rightSum + guess( i, right )\\n                )\\n            } else if ( rightSum > leftSum ) {\\n                dp[ left ][ right ] = Math.max(\\n                    dp[ left ][ right ],\\n                    leftSum + guess( left, i - 1 )\\n                )\\n            } else {\\n                dp[ left ][ right ] = Math.max(\\n                    dp[ left ][ right ],\\n                    rightSum + guess( i, right )\\n                )\\n            }\\n        }\\n        \\n        return dp[ left ][ right ]\\n    }\\n     guess( 0, a.length-1 )\\n    \\n    return dp[ 0 ][ a.length-1 ]\\n}\\n\\nconst getRowSumWithNums = nums => {\\n    const sums = nums.reduce( ( s, x ) => [ ...s, x + ( s[s.length - 1 ] || 0 ) ], [] )\\n\\n    return ( left, right ) => sums[ right ] - ( sums[ left - 1 ] || 0 )\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n:subproblem\\n  what is the maximum score of the rest of the stones\\n\\n:recurrence\\n    for all possible break points\\n        if equal halfs\\n            dp[left][right] = max(\\n                leftsum + recur( left ),\\n                rightsum + recur( right )\\n            )\\n        else \\n            dp[left][right] = max( dp, recur( min( left, right ) ) )\\n    \\n    return dp[left][right]\\n */\\nvar stoneGameV = function(a) {\\n    const rowSum = getRowSumWithNums( a )\\n    const dp = Array.from({length:a.length+1},_=>Array(a.length+1).fill(0))\\n    const guess = ( left, right ) => {\\n        if ( left === right ) return 0\\n        if ( dp[ left ][ right ] ) return dp[ left ][ right ]\\n\\n        for ( let i = left + 1; i <= right; i++ ) {\\n            const leftSum = rowSum( left, i - 1 )\\n            const rightSum = rowSum( i, right )\\n\\n            if ( leftSum === rightSum ) {\\n                dp[ left ][ right ] = Math.max(\\n                    dp[ left ][ right ],\\n                    leftSum + guess( left, i - 1 ),\\n                    rightSum + guess( i, right )\\n                )\\n            } else if ( rightSum > leftSum ) {\\n                dp[ left ][ right ] = Math.max(\\n                    dp[ left ][ right ],\\n                    leftSum + guess( left, i - 1 )\\n                )\\n            } else {\\n                dp[ left ][ right ] = Math.max(\\n                    dp[ left ][ right ],\\n                    rightSum + guess( i, right )\\n                )\\n            }\\n        }\\n        \\n        return dp[ left ][ right ]\\n    }\\n     guess( 0, a.length-1 )\\n    \\n    return dp[ 0 ][ a.length-1 ]\\n}\\n\\nconst getRowSumWithNums = nums => {\\n    const sums = nums.reduce( ( s, x ) => [ ...s, x + ( s[s.length - 1 ] || 0 ) ], [] )\\n\\n    return ( left, right ) => sums[ right ] - ( sums[ left - 1 ] || 0 )\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 807755,
                "title": "c-prefix-sum-memoization",
                "content": "Runtime: 228 ms\\nMemory Usage: 33.7 MB\\n```\\n    public int StoneGameV(int[] stoneValue) {\\n        int[,] dp = new int[stoneValue.Length, stoneValue.Length];       \\n        int[] prefixSum = new int[stoneValue.Length+1];\\n        \\n        for(int i=0; i< stoneValue.Length; i++)\\n        {\\n            prefixSum[i+1] =  prefixSum[i] + stoneValue[i];\\n        }\\n              \\n        return Traverse(stoneValue, 0, stoneValue.Length-1, dp, prefixSum);\\n    }\\n    \\n    private int Traverse(int[] stoneValue, int start, int end, int[,] dp,  int[] prefixSum)\\n    {     \\n        if (start >= end) { return 0; }\\n        if (dp[start,end] != 0) { return (dp[start,end]==-1)? 0 : dp[start,end]; }\\n        \\n        int total = prefixSum[end+1] - prefixSum[start];\\n               \\n        int left =0;\\n        int right;\\n        int result = -1;\\n        \\n        for(int i=start; i < end; i++)\\n        {\\n            left = prefixSum[i+1] - prefixSum[start];\\n            right = total - left;\\n            \\n            if (left >= right)\\n            {\\n                result = Math.Max(result, right + Traverse(stoneValue, i+1, end, dp,  prefixSum));\\n            }\\n            \\n            if (left <= right)\\n            {\\n                result = Math.Max(result, left + Traverse(stoneValue, start, i, dp,  prefixSum));\\n            }\\n        }\\n        \\n        dp[start, end] = result;\\n        return result;\\n    }\\n```\\n\\nSecond way of doing this but it takes much longer to execute:\\n\\nRuntime: 1328 ms\\nMemory Usage: 33.5 MB\\n```\\n\\n    public int StoneGameV(int[] stoneValue) {\\n        int[,] dp = new int[stoneValue.Length, stoneValue.Length];\\n       \\n        int[] prefixSum = new int[stoneValue.Length+1];\\n        \\n        for(int i=0; i< stoneValue.Length; i++)\\n        {\\n            dp[i,i] = 0;\\n            prefixSum[i+1] =  prefixSum[i] + stoneValue[i];\\n        }\\n        \\n        for(int k=1; k< stoneValue.Length; k++)\\n        {\\n            for(int i=0; i + k < stoneValue.Length; i++)\\n            {\\n               Traverse(stoneValue, i, i+k, dp, prefixSum);\\n            }\\n        }\\n              \\n        return dp[0, stoneValue.Length-1];\\n    }\\n    \\n    private int Traverse(int[] stoneValue, int start, int end, int[,] dp,  int[] prefixSum)\\n    {        \\n        int total = prefixSum[end+1] - prefixSum[start];\\n               \\n        int left =0;\\n        int right;\\n        int result = 0;\\n        \\n        for(int i=start; i < end; i++)\\n        {\\n            left = prefixSum[i+1] - prefixSum[start];\\n            right = total - left;\\n            \\n            if (left >= right)\\n            {\\n                result = Math.Max(result, right + dp[i+1,end]);\\n            }\\n            \\n            if (left <= right)\\n            {\\n                result = Math.Max(result, left + dp[start, i]);\\n            }\\n        }\\n        \\n        dp[start, end] = result;\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int StoneGameV(int[] stoneValue) {\\n        int[,] dp = new int[stoneValue.Length, stoneValue.Length];       \\n        int[] prefixSum = new int[stoneValue.Length+1];\\n        \\n        for(int i=0; i< stoneValue.Length; i++)\\n        {\\n            prefixSum[i+1] =  prefixSum[i] + stoneValue[i];\\n        }\\n              \\n        return Traverse(stoneValue, 0, stoneValue.Length-1, dp, prefixSum);\\n    }\\n    \\n    private int Traverse(int[] stoneValue, int start, int end, int[,] dp,  int[] prefixSum)\\n    {     \\n        if (start >= end) { return 0; }\\n        if (dp[start,end] != 0) { return (dp[start,end]==-1)? 0 : dp[start,end]; }\\n        \\n        int total = prefixSum[end+1] - prefixSum[start];\\n               \\n        int left =0;\\n        int right;\\n        int result = -1;\\n        \\n        for(int i=start; i < end; i++)\\n        {\\n            left = prefixSum[i+1] - prefixSum[start];\\n            right = total - left;\\n            \\n            if (left >= right)\\n            {\\n                result = Math.Max(result, right + Traverse(stoneValue, i+1, end, dp,  prefixSum));\\n            }\\n            \\n            if (left <= right)\\n            {\\n                result = Math.Max(result, left + Traverse(stoneValue, start, i, dp,  prefixSum));\\n            }\\n        }\\n        \\n        dp[start, end] = result;\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 807305,
                "title": "please-clear-my-doubt",
                "content": "```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        ans = 0\\n        def game(l,score):\\n            #print(l)\\n            #print(score)\\n            if len(l) <= 1:\\n                nonlocal ans\\n                ans = max((ans,score))\\n                return\\n            s = sum(l)\\n            x = 0\\n            for i in range(len(l)):\\n                x += l[i]\\n                if x == s/2:\\n                    game(l[:i+1],score+x)\\n                    game(l[i+1:],score+x)\\n                    return\\n                elif x >s/2:\\n                    game(l[i+1:],score+s-x)\\n                    game(l[:i],score+x-l[i])\\n                    return            \\n        game(stoneValue,0)\\n        return ans\\n        \\n```\\n\\nhere is my greedy approch for this Question.\\nmy approch is as follow \\n\\n1. i first find the element, that add to either side of the array gives the sum greater than or equal to half of the sum of initial array.\\n2. then there are two path now , either we choose first half or we choose second half .\\n3. we compare the result for each such possiblity and return maximum of them \\n\\nmy ans for arr = [98 ,77 ,24 ,49 ,6 ,12 ,2 ,44 ,51 ,96] is 307\\nbut expected ans is 330\\n\\nis have checked my ans many times but i can\\'t find any way to get the ans (score) 330.\\ni thought ans is wrong\\ncan you help me out how the ans is 330.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        ans = 0\\n        def game(l,score):\\n            #print(l)\\n            #print(score)\\n            if len(l) <= 1:\\n                nonlocal ans\\n                ans = max((ans,score))\\n                return\\n            s = sum(l)\\n            x = 0\\n            for i in range(len(l)):\\n                x += l[i]\\n                if x == s/2:\\n                    game(l[:i+1],score+x)\\n                    game(l[i+1:],score+x)\\n                    return\\n                elif x >s/2:\\n                    game(l[i+1:],score+s-x)\\n                    game(l[:i],score+x-l[i])\\n                    return            \\n        game(stoneValue,0)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 807238,
                "title": "topdowndfs-memo-o-n-3-and-bottomupdp-o-n-2",
                "content": "Top Down DFS + Memo 460ms\\n```cpp\\nclass Solution {\\n    vector<int> prefixSum;\\n    vector<vector<int>> mem;\\n    int cnt = 0;\\n    void dfs(const vector<int>& prefixSum, int begin, int end) {\\n        if (mem[begin][end])\\n            return;\\n        if (begin+1 == end)\\n            return;\\n        cnt ++;\\n        int ans = 0;\\n        int total = prefixSum[end] - prefixSum[begin];\\n        if (end - begin >= 2) {\\n            for (int mid = begin+1; mid < end; mid++) {\\n                int left = prefixSum[mid] - prefixSum[begin];\\n                int right = total - left;\\n                int tmp = 0;\\n                if (left < right) {\\n                    tmp += left;\\n                    dfs(prefixSum, begin, mid);\\n                    tmp += mem[begin][mid];\\n                } else if (left > right) {\\n                    tmp += right;\\n                    dfs(prefixSum, mid, end);\\n                    tmp += mem[mid][end];\\n                } else {\\n                    tmp += left;\\n                    dfs(prefixSum, begin, mid);\\n                    dfs(prefixSum, mid, end);\\n                    tmp += max(mem[begin][mid], mem[mid][end]);\\n                }\\n                ans = max(ans, tmp);\\n            }\\n        } \\n        mem[begin][end] = ans;\\n    }\\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        cout << stoneValue.size() << endl;\\n        int n = stoneValue.size();\\n        prefixSum.resize(n+1);\\n        mem.resize(n+1, vector<int>(n+1));\\n        for (int i = 0; i < n; i++)\\n            prefixSum[i+1] = prefixSum[i] + stoneValue[i];\\n        dfs(prefixSum, 0, stoneValue.size());\\n        cout << cnt << endl; // See how many states visited if you want to know why O(n^3) topdown works\\n        return mem[0][n];\\n    }\\n};\\n```\\n\\nBottom Up DP 200+ms\\n```cpp\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        const int n = stoneValue.size();\\n        vector<int> ps(n+1); // prefix_sum\\n        vector<vector<int>> dp(n+1, vector<int>(n+1));\\n        vector<vector<int>> maxL = dp;\\n        vector<vector<int>> maxR = dp;\\n        vector<vector<int>> mid = dp;\\n        \\n        for (int i = 0; i < n; i++)\\n            ps[i+1] = ps[i] + stoneValue[i];\\n        \\n        for (int i = 0; i <= n; i++) {\\n            int middle = i+1;\\n            for (int j = i+2; j <= n; j++) {\\n                while (middle < j && \\n                       ps[middle] - ps[i] <= ps[j] - ps[middle]) {\\n                    middle ++;\\n                }\\n                mid[i][j] = middle-1;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++)\\n            maxL[i][i+1] = maxR[i][i+1] = stoneValue[i];\\n        \\n        for (int i = n; i >= 0; i--) {\\n            for (int j = i+2; j <= n; j++) {\\n                int middle = mid[i][j];\\n                if (ps[middle] - ps[i] < ps[j] - ps[middle]) {\\n                    dp[i][j] = max(maxL[i][middle], maxR[middle+1][j]);\\n                } else {\\n                    dp[i][j] = max(maxL[i][middle], maxR[middle][j]);\\n                }\\n                maxL[i][j] = max(maxL[i][j-1], dp[i][j] + ps[j] - ps[i]);\\n                maxR[i][j] = max(maxR[i+1][j], dp[i][j] + ps[j] - ps[i]);\\n            }\\n        }\\n        return dp[0][n];\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n    vector<int> prefixSum;\\n    vector<vector<int>> mem;\\n    int cnt = 0;\\n    void dfs(const vector<int>& prefixSum, int begin, int end) {\\n        if (mem[begin][end])\\n            return;\\n        if (begin+1 == end)\\n            return;\\n        cnt ++;\\n        int ans = 0;\\n        int total = prefixSum[end] - prefixSum[begin];\\n        if (end - begin >= 2) {\\n            for (int mid = begin+1; mid < end; mid++) {\\n                int left = prefixSum[mid] - prefixSum[begin];\\n                int right = total - left;\\n                int tmp = 0;\\n                if (left < right) {\\n                    tmp += left;\\n                    dfs(prefixSum, begin, mid);\\n                    tmp += mem[begin][mid];\\n                } else if (left > right) {\\n                    tmp += right;\\n                    dfs(prefixSum, mid, end);\\n                    tmp += mem[mid][end];\\n                } else {\\n                    tmp += left;\\n                    dfs(prefixSum, begin, mid);\\n                    dfs(prefixSum, mid, end);\\n                    tmp += max(mem[begin][mid], mem[mid][end]);\\n                }\\n                ans = max(ans, tmp);\\n            }\\n        } \\n        mem[begin][end] = ans;\\n    }\\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        cout << stoneValue.size() << endl;\\n        int n = stoneValue.size();\\n        prefixSum.resize(n+1);\\n        mem.resize(n+1, vector<int>(n+1));\\n        for (int i = 0; i < n; i++)\\n            prefixSum[i+1] = prefixSum[i] + stoneValue[i];\\n        dfs(prefixSum, 0, stoneValue.size());\\n        cout << cnt << endl; // See how many states visited if you want to know why O(n^3) topdown works\\n        return mem[0][n];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        const int n = stoneValue.size();\\n        vector<int> ps(n+1); // prefix_sum\\n        vector<vector<int>> dp(n+1, vector<int>(n+1));\\n        vector<vector<int>> maxL = dp;\\n        vector<vector<int>> maxR = dp;\\n        vector<vector<int>> mid = dp;\\n        \\n        for (int i = 0; i < n; i++)\\n            ps[i+1] = ps[i] + stoneValue[i];\\n        \\n        for (int i = 0; i <= n; i++) {\\n            int middle = i+1;\\n            for (int j = i+2; j <= n; j++) {\\n                while (middle < j && \\n                       ps[middle] - ps[i] <= ps[j] - ps[middle]) {\\n                    middle ++;\\n                }\\n                mid[i][j] = middle-1;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++)\\n            maxL[i][i+1] = maxR[i][i+1] = stoneValue[i];\\n        \\n        for (int i = n; i >= 0; i--) {\\n            for (int j = i+2; j <= n; j++) {\\n                int middle = mid[i][j];\\n                if (ps[middle] - ps[i] < ps[j] - ps[middle]) {\\n                    dp[i][j] = max(maxL[i][middle], maxR[middle+1][j]);\\n                } else {\\n                    dp[i][j] = max(maxL[i][middle], maxR[middle][j]);\\n                }\\n                maxL[i][j] = max(maxL[i][j-1], dp[i][j] + ps[j] - ps[i]);\\n                maxR[i][j] = max(maxR[i+1][j], dp[i][j] + ps[j] - ps[i]);\\n            }\\n        }\\n        return dp[0][n];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 807232,
                "title": "prefix-sum-dp-memoization",
                "content": "```\\nint cache[505][505];\\nint pre[505];\\nint n;\\nint dp(int left,int right)\\n{\\n    if(left == right)\\n        return 0;\\n    int &ans = cache[left][right];\\n    if(ans != -1)\\n        return ans;\\n    // left subarray  -> [left , partition_index]\\n    // right subarray -> [partition_index + 1 , right]\\n    \\n    for(int partition_index = left ; partition_index < right; ++partition_index)\\n    {\\n        int leftsum = pre[partition_index];\\n        if(left > 0)\\n            leftsum -= pre[left-1];\\n        \\n        int rightsum = pre[right] - pre[partition_index];\\n        \\n        // if leftsum value greater than rightsum than bob throw away left subarray([left,partition_index]) and rightsum value will added to answer and do following step using right subarray([partition_index+1,right]).\\n        \\n        if(leftsum > rightsum)\\n            ans = max(ans, rightsum + dp(partition_index+1 , right));\\n        \\n        else if(leftsum < rightsum)\\n            ans = max(ans ,leftsum + dp(left , partition_index));\\n        // if leftsum equal to rightsum than we go both subarray seperately.\\n        else\\n        {\\n            ans = max(ans , rightsum + dp(partition_index+1 , right));\\n            ans = max(ans , leftsum + dp(left , partition_index));\\n        }\\n    }\\n    return ans;\\n    \\n}\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& a) {\\n         n = a.size();\\n         // initialize\\n         for(int i = 0;i<n;++i)\\n         {\\n            for(int j =0;j<n;++j)\\n                cache[i][j]=-1;\\n            pre[i] =0;\\n        }\\n\\t\\t// build prefix\\n        for(int i = 0;i < n;++i)\\n        {\\n            if(i > 0)\\n                pre[i]+=pre[i-1];\\n            pre[i]+=a[i];\\n        }\\n       \\n        return dp(0,n-1);\\n        \\n    }\\n};\\n```\\nTime :  O(n^3)\\nSpace : O(n^2)",
                "solutionTags": [],
                "code": "```\\nint cache[505][505];\\nint pre[505];\\nint n;\\nint dp(int left,int right)\\n{\\n    if(left == right)\\n        return 0;\\n    int &ans = cache[left][right];\\n    if(ans != -1)\\n        return ans;\\n    // left subarray  -> [left , partition_index]\\n    // right subarray -> [partition_index + 1 , right]\\n    \\n    for(int partition_index = left ; partition_index < right; ++partition_index)\\n    {\\n        int leftsum = pre[partition_index];\\n        if(left > 0)\\n            leftsum -= pre[left-1];\\n        \\n        int rightsum = pre[right] - pre[partition_index];\\n        \\n        // if leftsum value greater than rightsum than bob throw away left subarray([left,partition_index]) and rightsum value will added to answer and do following step using right subarray([partition_index+1,right]).\\n        \\n        if(leftsum > rightsum)\\n            ans = max(ans, rightsum + dp(partition_index+1 , right));\\n        \\n        else if(leftsum < rightsum)\\n            ans = max(ans ,leftsum + dp(left , partition_index));\\n        // if leftsum equal to rightsum than we go both subarray seperately.\\n        else\\n        {\\n            ans = max(ans , rightsum + dp(partition_index+1 , right));\\n            ans = max(ans , leftsum + dp(left , partition_index));\\n        }\\n    }\\n    return ans;\\n    \\n}\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& a) {\\n         n = a.size();\\n         // initialize\\n         for(int i = 0;i<n;++i)\\n         {\\n            for(int j =0;j<n;++j)\\n                cache[i][j]=-1;\\n            pre[i] =0;\\n        }\\n\\t\\t// build prefix\\n        for(int i = 0;i < n;++i)\\n        {\\n            if(i > 0)\\n                pre[i]+=pre[i-1];\\n            pre[i]+=a[i];\\n        }\\n       \\n        return dp(0,n-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806883,
                "title": "python-prefixsum-dfs-memo",
                "content": "```\\nclass Solution(object):\\n    def stoneGameV(self, stones):\\n        \"\"\"\\n        :type stoneValue: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(stones)\\n        preSum = [0] * (n + 1)\\n        for i in range(1, n + 1):\\n            preSum[i] = stones[i - 1] + preSum[i - 1]\\n        memo = {}\\n        def dfs(s, e):\\n            if s == e: return 0\\n            if (s, e) in memo: return memo[(s, e)]\\n            res = -float(\\'inf\\')\\n            for i in range(s, e):\\n                option1 = preSum[i + 1] - preSum[s]\\n                option2 = preSum[e + 1] - preSum[i + 1]\\n                if option1 > option2:\\n                    res = max(res, option2 + dfs(i + 1, e))\\n                elif option1 < option2:\\n                    res = max(res, option1 + dfs(s, i))\\n                else:\\n                    res = max(res, option1 + dfs(s, i), option2 + dfs(i + 1, e))\\n            memo[(s, e)] = res\\n            return res\\n        return dfs(0, n - 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def stoneGameV(self, stones):\\n        \"\"\"\\n        :type stoneValue: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(stones)\\n        preSum = [0] * (n + 1)\\n        for i in range(1, n + 1):\\n            preSum[i] = stones[i - 1] + preSum[i - 1]\\n        memo = {}\\n        def dfs(s, e):\\n            if s == e: return 0\\n            if (s, e) in memo: return memo[(s, e)]\\n            res = -float(\\'inf\\')\\n            for i in range(s, e):\\n                option1 = preSum[i + 1] - preSum[s]\\n                option2 = preSum[e + 1] - preSum[i + 1]\\n                if option1 > option2:\\n                    res = max(res, option2 + dfs(i + 1, e))\\n                elif option1 < option2:\\n                    res = max(res, option1 + dfs(s, i))\\n                else:\\n                    res = max(res, option1 + dfs(s, i), option2 + dfs(i + 1, e))\\n            memo[(s, e)] = res\\n            return res\\n        return dfs(0, n - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806807,
                "title": "any-idea-how-to-speedup-bottoms-up-dp-c-o-n-3-tle",
                "content": "> imo, dp questions should accept both top down and bottom up approaches. No able to figure out what I could have done to improve this solution. Suggestions are welcome.\\n\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int stoneGameV(vector<int>& sv) {\\n        int n = sv.size();\\n        vector<int> presum(n, 0);\\n        for (int i = 0; i<n; i++) presum[i] = sv[i] + ((i>0)?presum[i-1]:0);\\n\\n        vector<vector<ll>> dp(n, vector<ll>(n, INT_MIN));\\n\\n        for (int l = 0; l<n; l++) {\\n            for (int i = 0; i<(n-l); i++){ \\n                int j = i+l;\\n                if (i==j) dp[i][j] = 0;\\n                else if(i+1 == j) dp[i][j] = min(sv[i], sv[j]);\\n                else {\\n                    ll &v = dp[i][j];\\n                    for (int k = i+1; k<=j; k++) {\\n                        int lsum = presum[k-1] - ((i>0)?presum[i-1]:0);\\n                        int rsum = presum[j] - presum[k-1];\\n\\n                        if (rsum == lsum) v = max(dp[i][k-1],dp[k][j]) + lsum;\\n                        else if (lsum > rsum) v = max(v, rsum + dp[k][j]);\\n                        else v = max(v, lsum + dp[i][k-1]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int stoneGameV(vector<int>& sv) {\\n        int n = sv.size();\\n        vector<int> presum(n, 0);\\n        for (int i = 0; i<n; i++) presum[i] = sv[i] + ((i>0)?presum[i-1]:0);\\n\\n        vector<vector<ll>> dp(n, vector<ll>(n, INT_MIN));\\n\\n        for (int l = 0; l<n; l++) {\\n            for (int i = 0; i<(n-l); i++){ \\n                int j = i+l;\\n                if (i==j) dp[i][j] = 0;\\n                else if(i+1 == j) dp[i][j] = min(sv[i], sv[j]);\\n                else {\\n                    ll &v = dp[i][j];\\n                    for (int k = i+1; k<=j; k++) {\\n                        int lsum = presum[k-1] - ((i>0)?presum[i-1]:0);\\n                        int rsum = presum[j] - presum[k-1];\\n\\n                        if (rsum == lsum) v = max(dp[i][k-1],dp[k][j]) + lsum;\\n                        else if (lsum > rsum) v = max(v, rsum + dp[k][j]);\\n                        else v = max(v, lsum + dp[i][k-1]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806806,
                "title": "c-dp-easy-solution-memoization",
                "content": "class Solution {\\npublic:\\n    \\n    \\n    int findMax(vector<int>&prefix, int start, int end, vector<vector<int>>&dp ){\\n        \\n        if(start==end){\\n            return 0;\\n        }       \\n        if(dp[start][end]!=-1)\\n            return dp[start][end];\\n         int maxans=0;\\n        \\n        for(int cut=start;cut<end;cut++){\\n            \\n            int leftRowSum=prefix[cut]-prefix[start-1];\\n            int rightRowSum=prefix[end]-prefix[cut];\\n            \\n            if(leftRowSum < rightRowSum ){\\n                maxans=max(maxans, leftRowSum+findMax(prefix, start, cut,dp));\\n            }else if(leftRowSum>rightRowSum){\\n                maxans=max(maxans, rightRowSum+findMax(prefix, cut+1, end,dp));\\n            }else{\\n                maxans=max(maxans, leftRowSum+findMax(prefix, start, cut, dp));\\n                maxans=max(maxans, rightRowSum+findMax(prefix, cut+1, end, dp));\\n            }\\n        }\\n        \\n        return  dp[start][end]=maxans;\\n    }\\n\\n    int stoneGameV(vector<int>& arr) {\\n        \\n        arr.insert(arr.begin(),0);\\n        vector<vector<int>>dp(502,vector<int>(502,-1));\\n        \\n        for(int i=2;i<arr.size();i++){\\n            arr[i]+=arr[i-1];\\n        }    \\n\\t\\t\\n        return findMax(arr, 1, arr.size()-1,dp);\\n      }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    int findMax(vector<int>&prefix, int start, int end, vector<vector<int>>&dp ){\\n        \\n        if(start==end){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 806794,
                "title": "python3-top-down-dp",
                "content": "\\n```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        # prefix sum \\n        prefix = [0]\\n        for x in stoneValue: prefix.append(prefix[-1] + x)\\n        \\n        @lru_cache(None)\\n        def fn(lo, hi):\\n            \"\"\"Return the score of arranging values from lo (inclusive) to hi (exclusive). \"\"\"\\n            if lo+1 == hi: return 0 \\n            val = 0\\n            for mid in range(lo+1, hi): \\n                lower = prefix[mid] - prefix[lo]\\n                upper = prefix[hi] - prefix[mid]\\n                if lower < upper: val = max(val, lower + fn(lo, mid))\\n                elif lower > upper: val = max(val, upper + fn(mid, hi))\\n                else: val = max(val, lower + max(fn(lo, mid), fn(mid, hi)))\\n            return val \\n                \\n        return fn(0, len(stoneValue))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        # prefix sum \\n        prefix = [0]\\n        for x in stoneValue: prefix.append(prefix[-1] + x)\\n        \\n        @lru_cache(None)\\n        def fn(lo, hi):\\n            \"\"\"Return the score of arranging values from lo (inclusive) to hi (exclusive). \"\"\"\\n            if lo+1 == hi: return 0 \\n            val = 0\\n            for mid in range(lo+1, hi): \\n                lower = prefix[mid] - prefix[lo]\\n                upper = prefix[hi] - prefix[mid]\\n                if lower < upper: val = max(val, lower + fn(lo, mid))\\n                elif lower > upper: val = max(val, upper + fn(mid, hi))\\n                else: val = max(val, lower + max(fn(lo, mid), fn(mid, hi)))\\n            return val \\n                \\n        return fn(0, len(stoneValue))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806752,
                "title": "java-top-down-dp-with-memo-o-n-3",
                "content": "```\\nclass Solution {\\n    int[][] memo;\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] pSum = new int[n+1];\\n        memo = new int[n+1][n+1];\\n        for(int i=1; i<=n; i++){\\n            pSum[i] = pSum[i-1] + stoneValue[i-1];\\n        }\\n        return calc(pSum, 0, n-1);\\n    }\\n    \\n    public int calc(int[] pSum, int lo, int hi){\\n        if(lo>=hi){\\n            return 0;\\n        }\\n        if(memo[lo][hi]!=0){\\n            return memo[lo][hi];\\n        }\\n        int max = 0;\\n        for(int k=lo; k<hi; k++){\\n            int cur = 0;\\n            int left = pSum[k+1] - pSum[lo];\\n            int right = pSum[hi+1] - pSum[k+1];\\n            if(left>right){\\n                cur = right + calc(pSum, k+1, hi);\\n            }\\n            else if(left<right){\\n                cur = left + calc(pSum, lo, k);\\n            }\\n            else{\\n                cur = left + Math.max(calc(pSum, lo, k), calc(pSum, k+1, hi));\\n            }\\n            max = Math.max(max, cur);\\n        }\\n        memo[lo][hi] = max;\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] memo;\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] pSum = new int[n+1];\\n        memo = new int[n+1][n+1];\\n        for(int i=1; i<=n; i++){\\n            pSum[i] = pSum[i-1] + stoneValue[i-1];\\n        }\\n        return calc(pSum, 0, n-1);\\n    }\\n    \\n    public int calc(int[] pSum, int lo, int hi){\\n        if(lo>=hi){\\n            return 0;\\n        }\\n        if(memo[lo][hi]!=0){\\n            return memo[lo][hi];\\n        }\\n        int max = 0;\\n        for(int k=lo; k<hi; k++){\\n            int cur = 0;\\n            int left = pSum[k+1] - pSum[lo];\\n            int right = pSum[hi+1] - pSum[k+1];\\n            if(left>right){\\n                cur = right + calc(pSum, k+1, hi);\\n            }\\n            else if(left<right){\\n                cur = left + calc(pSum, lo, k);\\n            }\\n            else{\\n                cur = left + Math.max(calc(pSum, lo, k), calc(pSum, k+1, hi));\\n            }\\n            max = Math.max(max, cur);\\n        }\\n        memo[lo][hi] = max;\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806750,
                "title": "easy-to-understand-java-dfs-memory-presum",
                "content": "I think it is clear to understand! Maybe someone can help me to explain it.\\n\\n```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n\\n        int n=stoneValue.length;\\n        if(n<2) return 0;\\n        \\n        long[] preSum=new long[n+1];\\n        Map<Pair<Integer,Integer>,Long> memo= new HashMap<>();\\n        for(int i=1;i<=n;i++){\\n            preSum[i]=preSum[i-1]+stoneValue[i-1];\\n        }\\n        \\n        return  (int)dfs(preSum,0,n,memo);\\n        \\n    }\\n\\n    long dfs(long[] sum, int lo, int hi, Map<Pair<Integer,Integer>,Long> memo){\\n        //System.out.println(lo+\",\"+hi);\\n        if(lo+1==hi) return 0;\\n        Pair<Integer,Integer> key = new Pair<>(lo,hi);\\n        \\n        if(memo.containsKey(key)) return memo.get(key);\\n        \\n        long ans=0;\\n        for(int i=lo+1;i<hi;i++){\\n            long left=sum[i]-sum[lo];\\n            long right=sum[hi]-sum[i];\\n            \\n            if(left>right){\\n                ans=Math.max(right+dfs(sum,i,hi,memo),ans);\\n            }else if(left < right){\\n                ans=Math.max(left+dfs(sum,lo,i,memo),ans);\\n            }else{\\n                ans=Math.max(left+Math.max(dfs(sum,i,hi,memo),dfs(sum,lo,i,memo)),ans);\\n            }\\n        }\\n        \\n        memo.put(key,ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n\\n        int n=stoneValue.length;\\n        if(n<2) return 0;\\n        \\n        long[] preSum=new long[n+1];\\n        Map<Pair<Integer,Integer>,Long> memo= new HashMap<>();\\n        for(int i=1;i<=n;i++){\\n            preSum[i]=preSum[i-1]+stoneValue[i-1];\\n        }\\n        \\n        return  (int)dfs(preSum,0,n,memo);\\n        \\n    }\\n\\n    long dfs(long[] sum, int lo, int hi, Map<Pair<Integer,Integer>,Long> memo){\\n        //System.out.println(lo+\",\"+hi);\\n        if(lo+1==hi) return 0;\\n        Pair<Integer,Integer> key = new Pair<>(lo,hi);\\n        \\n        if(memo.containsKey(key)) return memo.get(key);\\n        \\n        long ans=0;\\n        for(int i=lo+1;i<hi;i++){\\n            long left=sum[i]-sum[lo];\\n            long right=sum[hi]-sum[i];\\n            \\n            if(left>right){\\n                ans=Math.max(right+dfs(sum,i,hi,memo),ans);\\n            }else if(left < right){\\n                ans=Math.max(left+dfs(sum,lo,i,memo),ans);\\n            }else{\\n                ans=Math.max(left+Math.max(dfs(sum,i,hi,memo),dfs(sum,lo,i,memo)),ans);\\n            }\\n        }\\n        \\n        memo.put(key,ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806747,
                "title": "top-down-dp-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        vector<int> prefix(n + 1, 0);\\n        for (int i = 1 ; i <= n ; ++i) {\\n            prefix[i] = prefix[i - 1] + arr[i - 1];\\n        }\\n        \\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return topDown(arr, 0, n - 1, prefix, dp);\\n    }\\n    \\nprivate:\\n    int topDown(\\n            vector<int>& arr,\\n            int l, int r,\\n            vector<int>& prefix,\\n            vector<vector<int>>& dp) {\\n        \\n        if (l == r) {\\n            return 0;\\n        }\\n        \\n        if (dp[l][r] != -1) {\\n            return dp[l][r];\\n        }\\n        \\n        int opt = 0;        \\n        for (int m = l ; m < r ; ++m) {\\n            int left = prefix[m + 1] - prefix[l];\\n            int right = prefix[r + 1] - prefix[m + 1];\\n            \\n            if (left > right) {\\n                int sum = right + topDown(arr, m + 1, r, prefix, dp);\\n                opt = max(opt, sum);\\n            } else if (left < right) {\\n                int sum = left + topDown(arr, l, m, prefix, dp);\\n                opt = max(opt, sum);\\n            } else {\\n                int sum = right + topDown(arr, m + 1, r, prefix, dp);\\n                opt = max(opt, sum);\\n                sum = left + topDown(arr, l, m, prefix, dp);\\n                opt = max(opt, sum);                \\n            }\\n        }\\n        \\n        return dp[l][r] = opt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        vector<int> prefix(n + 1, 0);\\n        for (int i = 1 ; i <= n ; ++i) {\\n            prefix[i] = prefix[i - 1] + arr[i - 1];\\n        }\\n        \\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return topDown(arr, 0, n - 1, prefix, dp);\\n    }\\n    \\nprivate:\\n    int topDown(\\n            vector<int>& arr,\\n            int l, int r,\\n            vector<int>& prefix,\\n            vector<vector<int>>& dp) {\\n        \\n        if (l == r) {\\n            return 0;\\n        }\\n        \\n        if (dp[l][r] != -1) {\\n            return dp[l][r];\\n        }\\n        \\n        int opt = 0;        \\n        for (int m = l ; m < r ; ++m) {\\n            int left = prefix[m + 1] - prefix[l];\\n            int right = prefix[r + 1] - prefix[m + 1];\\n            \\n            if (left > right) {\\n                int sum = right + topDown(arr, m + 1, r, prefix, dp);\\n                opt = max(opt, sum);\\n            } else if (left < right) {\\n                int sum = left + topDown(arr, l, m, prefix, dp);\\n                opt = max(opt, sum);\\n            } else {\\n                int sum = right + topDown(arr, m + 1, r, prefix, dp);\\n                opt = max(opt, sum);\\n                sum = left + topDown(arr, l, m, prefix, dp);\\n                opt = max(opt, sum);                \\n            }\\n        }\\n        \\n        return dp[l][r] = opt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806735,
                "title": "java-simple-top-down-dfs-memo-with-comments",
                "content": "**Intuition**\\nSimulate the game by dividing the array into two subarrays at each iteration. Add the subarray with smaller sum to result of current search and continue searching the subarray with smaller sum.\\n\\n`dp[i][j]` represents the max score we can get in range `[i, j]`\\n\\nWe use the `presum` array to comput the subarray sum in `O(1)`\\n\\n```java\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length, sum = 0;;\\n        Integer[][] dp = new Integer[n][n];\\n        // initialize presum array\\n        int[] presum = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            sum += stoneValue[i];\\n            presum[i] = sum;\\n        }\\n        return dfs(dp, 0, n-1, presum, stoneValue);\\n    }\\n    \\n    private int dfs(Integer[][] dp, int start, int end, int[] presum, int[] stoneValue) {\\n        // base condition\\n        // when start == end, we already added the value in previous function all. \\n        if(start == end) {\\n            return 0;\\n        }\\n        // return if we already searched this range\\n        if(dp[start][end] != null) return dp[start][end];\\n        int res = 0;\\n        \\n        // left: [start, i]\\n        // right: (i, end]\\n        for(int i = start; i < end; i++) {\\n            int left = presum[i] - (start > 0 ? presum[start - 1] : 0);\\n            int right = presum[end] - presum[i];\\n            // add the smaller pile to current result and continue search on the smaller pile\\n            if(left > right) {\\n                res = Math.max(res, right + dfs(dp, i + 1, end, presum, stoneValue));\\n            } else if(left < right) {\\n                res = Math.max(res, left + dfs(dp, start, i, presum, stoneValue));\\n            } else {\\n                res = Math.max(res, right + dfs(dp, i + 1, end, presum, stoneValue));\\n                res = Math.max(res, left + dfs(dp, start, i, presum, stoneValue));\\n            }\\n        }\\n        return dp[start][end] = res;\\n    }\\n}\\n```\\n\\nTime: O(n<sup>3</sup>)\\n\\nSpace: O(n<sup>2</sup>)\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length, sum = 0;;\\n        Integer[][] dp = new Integer[n][n];\\n        // initialize presum array\\n        int[] presum = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            sum += stoneValue[i];\\n            presum[i] = sum;\\n        }\\n        return dfs(dp, 0, n-1, presum, stoneValue);\\n    }\\n    \\n    private int dfs(Integer[][] dp, int start, int end, int[] presum, int[] stoneValue) {\\n        // base condition\\n        // when start == end, we already added the value in previous function all. \\n        if(start == end) {\\n            return 0;\\n        }\\n        // return if we already searched this range\\n        if(dp[start][end] != null) return dp[start][end];\\n        int res = 0;\\n        \\n        // left: [start, i]\\n        // right: (i, end]\\n        for(int i = start; i < end; i++) {\\n            int left = presum[i] - (start > 0 ? presum[start - 1] : 0);\\n            int right = presum[end] - presum[i];\\n            // add the smaller pile to current result and continue search on the smaller pile\\n            if(left > right) {\\n                res = Math.max(res, right + dfs(dp, i + 1, end, presum, stoneValue));\\n            } else if(left < right) {\\n                res = Math.max(res, left + dfs(dp, start, i, presum, stoneValue));\\n            } else {\\n                res = Math.max(res, right + dfs(dp, i + 1, end, presum, stoneValue));\\n                res = Math.max(res, left + dfs(dp, start, i, presum, stoneValue));\\n            }\\n        }\\n        return dp[start][end] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080302,
                "title": "knapsack-partition-solution-with-explenation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo; \\n    \\n    int solve(int ind, int n, vector<int>& pre, vector<int>& s)\\n    {\\n        //If there\\'s only one stone (n == ind), no points can be scored.\\n        if (n == ind)\\n            return 0;\\n        if (memo[ind][n] != -1)\\n            return memo[ind][n];\\n        \\n        int ans = 0;  \\n        // Loop through the possible partition points\\n        for (int i = ind; i < n; i++) {\\n            // Calculate the sum of values on the left and right sides of the partition\\n            int left = pre[i] - (ind > 0 ? pre[ind - 1] : 0);\\n            int right = pre[n] - pre[i];\\n            \\n            int score = 0;\\n            if (left < right) {\\n                // If the left side has fewer points, calculate the score for taking left stones\\n                score = left + solve(ind, i, pre, s);\\n            } else if (left > right) {\\n                // If the right side has fewer points, calculate the score for taking right stones\\n                score = right + solve(i + 1, n, pre, s);\\n            } else {\\n                // If both sides have equal points, consider both options and choose the maximum\\n                score = max(left + solve(ind, i, pre, s), right + solve(i + 1, n, pre, s));\\n            }\\n            \\n            // Update the maximum score for this subproblem\\n            ans = max(ans, score);\\n        }\\n        \\n        \\n        return memo[ind][n] = ans;\\n        \\n    }\\n    \\n    int stoneGameV(vector<int>& s) {\\n        int n = s.size();\\n        \\n        \\n        memo.assign(n, vector<int>(n, -1));\\n        \\n        // Calculate the prefix sum array for efficient sum calculations\\n        vector<int> pre(n, 0);\\n        pre[0] = s[0];\\n        for (int i = 1; i < n; i++) {\\n            pre[i] = pre[i - 1] + s[i];\\n        }\\n        \\n        return solve(0, n - 1, pre, s);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo; \\n    \\n    int solve(int ind, int n, vector<int>& pre, vector<int>& s)\\n    {\\n        //If there\\'s only one stone (n == ind), no points can be scored.\\n        if (n == ind)\\n            return 0;\\n        if (memo[ind][n] != -1)\\n            return memo[ind][n];\\n        \\n        int ans = 0;  \\n        // Loop through the possible partition points\\n        for (int i = ind; i < n; i++) {\\n            // Calculate the sum of values on the left and right sides of the partition\\n            int left = pre[i] - (ind > 0 ? pre[ind - 1] : 0);\\n            int right = pre[n] - pre[i];\\n            \\n            int score = 0;\\n            if (left < right) {\\n                // If the left side has fewer points, calculate the score for taking left stones\\n                score = left + solve(ind, i, pre, s);\\n            } else if (left > right) {\\n                // If the right side has fewer points, calculate the score for taking right stones\\n                score = right + solve(i + 1, n, pre, s);\\n            } else {\\n                // If both sides have equal points, consider both options and choose the maximum\\n                score = max(left + solve(ind, i, pre, s), right + solve(i + 1, n, pre, s));\\n            }\\n            \\n            // Update the maximum score for this subproblem\\n            ans = max(ans, score);\\n        }\\n        \\n        \\n        return memo[ind][n] = ans;\\n        \\n    }\\n    \\n    int stoneGameV(vector<int>& s) {\\n        int n = s.size();\\n        \\n        \\n        memo.assign(n, vector<int>(n, -1));\\n        \\n        // Calculate the prefix sum array for efficient sum calculations\\n        vector<int> pre(n, 0);\\n        pre[0] = s[0];\\n        for (int i = 1; i < n; i++) {\\n            pre[i] = pre[i - 1] + s[i];\\n        }\\n        \\n        return solve(0, n - 1, pre, s);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056909,
                "title": "c-memoization-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[504][504];\\n    int solve(int st,int end,vector<int>&pref){\\n        if(st>=end) return 0;\\n        if(dp[st][end]!=-1) return dp[st][end];\\n        int ans=INT_MIN;\\n        for(int i=st;i<=end;i++){\\n            int left=0,right=0;\\n            if(st==0) left=pref[i];\\n            else{\\n                left=pref[i]-pref[st-1];\\n            }\\n            right=pref[end]-pref[i];\\n            if(left>right){\\n                ans=max(ans,right+solve(i+1,end,pref));\\n            }\\n            else if(left==right){\\n                ans=max({ans,right+solve(i+1,end,pref),left+solve(st,i,pref)});\\n            }\\n            else{\\n                ans=max(ans,left+solve(st,i,pref));\\n            }\\n        }\\n        return dp[st][end]=ans;\\n            \\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n=stoneValue.size();\\n        vector<int>pref(n,0);\\n        pref[0]=stoneValue[0];\\n        for(int i=1;i<n;i++){\\n            pref[i]=pref[i-1]+stoneValue[i];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,n-1,pref);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[504][504];\\n    int solve(int st,int end,vector<int>&pref){\\n        if(st>=end) return 0;\\n        if(dp[st][end]!=-1) return dp[st][end];\\n        int ans=INT_MIN;\\n        for(int i=st;i<=end;i++){\\n            int left=0,right=0;\\n            if(st==0) left=pref[i];\\n            else{\\n                left=pref[i]-pref[st-1];\\n            }\\n            right=pref[end]-pref[i];\\n            if(left>right){\\n                ans=max(ans,right+solve(i+1,end,pref));\\n            }\\n            else if(left==right){\\n                ans=max({ans,right+solve(i+1,end,pref),left+solve(st,i,pref)});\\n            }\\n            else{\\n                ans=max(ans,left+solve(st,i,pref));\\n            }\\n        }\\n        return dp[st][end]=ans;\\n            \\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n=stoneValue.size();\\n        vector<int>pref(n,0);\\n        pref[0]=stoneValue[0];\\n        for(int i=1;i<n;i++){\\n            pref[i]=pref[i-1]+stoneValue[i];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,n-1,pref);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956404,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int stoneGameV(int[] stoneValue) {\\n    final int n = stoneValue.length;\\n    // dp[i][j] := max score that Alice can obtain from stoneValue[i..j]\\n    dp = new int[n][n];\\n    Arrays.stream(dp).forEach(row -> Arrays.fill(row, Integer.MIN_VALUE));\\n    prefix = new int[n + 1];\\n\\n    for (int i = 0; i < n; ++i)\\n      prefix[i + 1] = stoneValue[i] + prefix[i];\\n\\n    return stoneGameV(stoneValue, 0, n - 1);\\n  }\\n\\n  private int[][] dp;\\n  private int[] prefix;\\n\\n  private int stoneGameV(int[] stoneValue, int i, int j) {\\n    if (i == j)\\n      return 0;\\n    if (dp[i][j] > 0)\\n      return dp[i][j];\\n\\n    // Try all possible partitions\\n    for (int p = i; p < j; ++p) {\\n      // Sum of stoneValue[i..p]\\n      final int leftSum = prefix[p + 1] - prefix[i];\\n      final int throwRight = leftSum + stoneGameV(stoneValue, i, p);\\n      // Sum of stoneValue[p + 1..j]\\n      final int rightSum = prefix[j + 1] - prefix[p + 1];\\n      final int throwLeft = rightSum + stoneGameV(stoneValue, p + 1, j);\\n      if (leftSum < rightSum) // Bob throws right row\\n        dp[i][j] = Math.max(dp[i][j], throwRight);\\n      else if (leftSum > rightSum) // Bob throws left row\\n        dp[i][j] = Math.max(dp[i][j], throwLeft);\\n      else // Alice decide which row to throw\\n        dp[i][j] = Math.max(dp[i][j], Math.max(throwLeft, throwRight));\\n    }\\n\\n    return dp[i][j];\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int stoneGameV(int[] stoneValue) {\\n    final int n = stoneValue.length;\\n    // dp[i][j] := max score that Alice can obtain from stoneValue[i..j]\\n    dp = new int[n][n];\\n    Arrays.stream(dp).forEach(row -> Arrays.fill(row, Integer.MIN_VALUE));\\n    prefix = new int[n + 1];\\n\\n    for (int i = 0; i < n; ++i)\\n      prefix[i + 1] = stoneValue[i] + prefix[i];\\n\\n    return stoneGameV(stoneValue, 0, n - 1);\\n  }\\n\\n  private int[][] dp;\\n  private int[] prefix;\\n\\n  private int stoneGameV(int[] stoneValue, int i, int j) {\\n    if (i == j)\\n      return 0;\\n    if (dp[i][j] > 0)\\n      return dp[i][j];\\n\\n    // Try all possible partitions\\n    for (int p = i; p < j; ++p) {\\n      // Sum of stoneValue[i..p]\\n      final int leftSum = prefix[p + 1] - prefix[i];\\n      final int throwRight = leftSum + stoneGameV(stoneValue, i, p);\\n      // Sum of stoneValue[p + 1..j]\\n      final int rightSum = prefix[j + 1] - prefix[p + 1];\\n      final int throwLeft = rightSum + stoneGameV(stoneValue, p + 1, j);\\n      if (leftSum < rightSum) // Bob throws right row\\n        dp[i][j] = Math.max(dp[i][j], throwRight);\\n      else if (leftSum > rightSum) // Bob throws left row\\n        dp[i][j] = Math.max(dp[i][j], throwLeft);\\n      else // Alice decide which row to throw\\n        dp[i][j] = Math.max(dp[i][j], Math.max(throwLeft, throwRight));\\n    }\\n\\n    return dp[i][j];\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922774,
                "title": "c-solution-with-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n\\n    int solve(vector<int>& stoneValues, vector<int>& prefix, int i, int j) {\\n        if (i >= j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n\\n        int ans = 0;\\n        for (int k = i; k < j; k++) {\\n            // Calculate the sum of values in the first partition\\n            int first = prefix[k] - ((i > 0) ? prefix[i - 1] : 0);\\n            // Calculate the sum of values in the second partition\\n            int second = prefix[j] - prefix[k];\\n            \\n            if (first == second) {\\n                // If both partitions have the same sum, consider the maximum value\\n                ans = max(ans, max(first + solve(stoneValues, prefix, i, k), second + solve(stoneValues, prefix, k + 1, j)));\\n            } else if (first < second) {\\n                // If the first partition has a smaller sum, recurse with the first partition\\n                ans = max(ans, (first + solve(stoneValues, prefix, i, k)));\\n            } else {\\n                // If the second partition has a smaller sum, recurse with the second partition\\n                ans = max(ans, (second + solve(stoneValues, prefix, k + 1, j)));\\n            }\\n        }\\n        // Memorize the calculated value and return\\n        return dp[i][j] = ans;\\n    }\\n\\n    int stoneGameV(vector<int>& stoneValues) {\\n        int n = stoneValues.size();\\n        memset(dp, -1, sizeof dp);\\n        \\n        // Calculate prefix sum to efficiently calculate partition sums\\n        vector<int> prefix(n, 0);\\n        prefix[0] = stoneValues[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] + stoneValues[i];\\n        }\\n        \\n        // Start the recursive solving process from the whole array\\n        return solve(stoneValues, prefix, 0, n - 1);\\n    }\\n};\\n\\n\\n\\n\\n```\\n\\n\\n\\n\\n# upvote if you like the solution",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n\\n    int solve(vector<int>& stoneValues, vector<int>& prefix, int i, int j) {\\n        if (i >= j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n\\n        int ans = 0;\\n        for (int k = i; k < j; k++) {\\n            // Calculate the sum of values in the first partition\\n            int first = prefix[k] - ((i > 0) ? prefix[i - 1] : 0);\\n            // Calculate the sum of values in the second partition\\n            int second = prefix[j] - prefix[k];\\n            \\n            if (first == second) {\\n                // If both partitions have the same sum, consider the maximum value\\n                ans = max(ans, max(first + solve(stoneValues, prefix, i, k), second + solve(stoneValues, prefix, k + 1, j)));\\n            } else if (first < second) {\\n                // If the first partition has a smaller sum, recurse with the first partition\\n                ans = max(ans, (first + solve(stoneValues, prefix, i, k)));\\n            } else {\\n                // If the second partition has a smaller sum, recurse with the second partition\\n                ans = max(ans, (second + solve(stoneValues, prefix, k + 1, j)));\\n            }\\n        }\\n        // Memorize the calculated value and return\\n        return dp[i][j] = ans;\\n    }\\n\\n    int stoneGameV(vector<int>& stoneValues) {\\n        int n = stoneValues.size();\\n        memset(dp, -1, sizeof dp);\\n        \\n        // Calculate prefix sum to efficiently calculate partition sums\\n        vector<int> prefix(n, 0);\\n        prefix[0] = stoneValues[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] + stoneValues[i];\\n        }\\n        \\n        // Start the recursive solving process from the whole array\\n        return solve(stoneValues, prefix, 0, n - 1);\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875589,
                "title": "dp-memorization-top-down-search-cut-branches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBuild your DP table and do a Top-down search. Just like searching a tree top-down(you can cut some branches). Your dp table would be filled during this and used to avoid duplicated search again.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndp[i][j]: max score of the row from stone[i] to stone[j]\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size();\\n        vector<int> sums(n+1, 0);\\n        int sum = 0;\\n        for(int i = 0; i<n; ++i){\\n            sum += stoneValue[i];\\n            sums[i+1] = sum;\\n        }\\n\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        return findOpt(0, n-1, sums, dp);\\n    }\\n    int findOpt(int left, int right, vector<int>& sums, vector<vector<int>>& dp){\\n        //avoid duplicated searches\\n        if(dp[left][right]!=0) return dp[left][right];\\n        int res = 0;\\n        for(int i = left; i < right; i++){\\n            int lsum = sums[i+1]-sums[left];\\n            int rsum = sums[right+1]-sums[i+1];\\n            //cut branches\\n            if(lsum<rsum){\\n                res = max(res, lsum+findOpt(left, i, sums, dp));\\n            }\\n            else if(lsum>rsum){\\n                res = max(res, rsum+findOpt(i+1, right, sums, dp));\\n            }\\n            else{\\n                res = max(res, lsum+findOpt(left, i, sums, dp));\\n                res = max(res, rsum+findOpt(i+1, right, sums, dp));\\n            }\\n        }\\n        //fill your dp once you finished this sub-tree\\n        dp[left][right] = res;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size();\\n        vector<int> sums(n+1, 0);\\n        int sum = 0;\\n        for(int i = 0; i<n; ++i){\\n            sum += stoneValue[i];\\n            sums[i+1] = sum;\\n        }\\n\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        return findOpt(0, n-1, sums, dp);\\n    }\\n    int findOpt(int left, int right, vector<int>& sums, vector<vector<int>>& dp){\\n        //avoid duplicated searches\\n        if(dp[left][right]!=0) return dp[left][right];\\n        int res = 0;\\n        for(int i = left; i < right; i++){\\n            int lsum = sums[i+1]-sums[left];\\n            int rsum = sums[right+1]-sums[i+1];\\n            //cut branches\\n            if(lsum<rsum){\\n                res = max(res, lsum+findOpt(left, i, sums, dp));\\n            }\\n            else if(lsum>rsum){\\n                res = max(res, rsum+findOpt(i+1, right, sums, dp));\\n            }\\n            else{\\n                res = max(res, lsum+findOpt(left, i, sums, dp));\\n                res = max(res, rsum+findOpt(i+1, right, sums, dp));\\n            }\\n        }\\n        //fill your dp once you finished this sub-tree\\n        dp[left][right] = res;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875158,
                "title": "easy-dp-memoization-c",
                "content": "\\n\\n# Code\\n```\\n//Akash\\nclass Solution {\\npublic:\\n      int dp[501][501];\\n    int solve(int i,int j,vector<int>& stone,vector<int>&pre)\\n       {\\n        if(i>=j) return 0;\\n        int ans=0;\\n       \\n       if(dp[i][j]!=-1) return dp[i][j];\\n\\n        for(int k=i;k<j;k++)\\n        {  int temp=1e9;;\\n            int left=(i==0)?pre[k]:(pre[k]-pre[i-1]);\\n            int right=pre[j]-pre[k];\\n           if(left!=right)\\n          temp=min(temp,((min(left,right))+((left>right)?solve(k+1,j,stone,pre):solve(i,k,stone,pre))));\\n         else if(left==right)\\n          temp=max((left+solve(k+1,j,stone,pre)),right+solve(i,k,stone,pre));\\n          ans=max(ans,temp);\\n        }\\n          \\n return dp[i][j]= ans;\\n       }\\n    int stoneGameV(vector<int>& stone) {\\n        int n=stone.size();\\n        memset(dp,-1,sizeof(dp));\\n        vector<int>pre(n);\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=stone[i];\\n            pre[i]=sum;\\n        }\\n       return solve(0,n-1,stone,pre);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\n//Akash\\nclass Solution {\\npublic:\\n      int dp[501][501];\\n    int solve(int i,int j,vector<int>& stone,vector<int>&pre)\\n       {\\n        if(i>=j) return 0;\\n        int ans=0;\\n       \\n       if(dp[i][j]!=-1) return dp[i][j];\\n\\n        for(int k=i;k<j;k++)\\n        {  int temp=1e9;;\\n            int left=(i==0)?pre[k]:(pre[k]-pre[i-1]);\\n            int right=pre[j]-pre[k];\\n           if(left!=right)\\n          temp=min(temp,((min(left,right))+((left>right)?solve(k+1,j,stone,pre):solve(i,k,stone,pre))));\\n         else if(left==right)\\n          temp=max((left+solve(k+1,j,stone,pre)),right+solve(i,k,stone,pre));\\n          ans=max(ans,temp);\\n        }\\n          \\n return dp[i][j]= ans;\\n       }\\n    int stoneGameV(vector<int>& stone) {\\n        int n=stone.size();\\n        memset(dp,-1,sizeof(dp));\\n        vector<int>pre(n);\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=stone[i];\\n            pre[i]=sum;\\n        }\\n       return solve(0,n-1,stone,pre);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854962,
                "title": "beats-88-c-users-recursion-mcm-memo-dp-2d",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\napproach in MCM notice on temp situation and gain the intuition based on it \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst recognize which do pattern  ,see the time complexity\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![upvote me please.png](https://assets.leetcode.com/users/images/0cd91952-cee6-4758-9444-b1724a69aaeb_1691004163.8985064.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp[501][501];\\n    int stoneGameV(vector<int>& s) {\\n        int n=s.size();\\n        vector<int>prefSum(n);\\n        prefSum[0]=s[0];\\n        for(int i=1;i<n;++i)\\n        prefSum[i]=prefSum[i-1]+s[i];\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return solve(prefSum,0,n-1);\\n    }\\n    int solve(vector<int>&prefSum, int s,int e)\\n    {\\n        if(s>=e) return 0;\\n        int maxi=INT_MIN;\\n        if(dp[s][e]!=-1) return dp[s][e];\\n        for(int k=s;k<e;++k)\\n        {\\n            int leftSum=(s==0)?prefSum[k]:prefSum[k]-prefSum[s-1];\\n            int rightSum=prefSum[e]-prefSum[k];\\n             \\n             if(leftSum>rightSum)\\n              {\\n                  maxi=max(maxi,rightSum+solve(prefSum,k+1,e));\\n              }else if(rightSum>leftSum)\\n              {\\n                  maxi=max(maxi,leftSum+solve(prefSum,s,k));\\n              }\\n          else\\n          {\\n              maxi=max({maxi,leftSum+solve(prefSum,s,k),rightSum+solve(prefSum,k+1,e)});\\n          }\\n\\n        }\\n        return dp[s][e]= maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[501][501];\\n    int stoneGameV(vector<int>& s) {\\n        int n=s.size();\\n        vector<int>prefSum(n);\\n        prefSum[0]=s[0];\\n        for(int i=1;i<n;++i)\\n        prefSum[i]=prefSum[i-1]+s[i];\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return solve(prefSum,0,n-1);\\n    }\\n    int solve(vector<int>&prefSum, int s,int e)\\n    {\\n        if(s>=e) return 0;\\n        int maxi=INT_MIN;\\n        if(dp[s][e]!=-1) return dp[s][e];\\n        for(int k=s;k<e;++k)\\n        {\\n            int leftSum=(s==0)?prefSum[k]:prefSum[k]-prefSum[s-1];\\n            int rightSum=prefSum[e]-prefSum[k];\\n             \\n             if(leftSum>rightSum)\\n              {\\n                  maxi=max(maxi,rightSum+solve(prefSum,k+1,e));\\n              }else if(rightSum>leftSum)\\n              {\\n                  maxi=max(maxi,leftSum+solve(prefSum,s,k));\\n              }\\n          else\\n          {\\n              maxi=max({maxi,leftSum+solve(prefSum,s,k),rightSum+solve(prefSum,k+1,e)});\\n          }\\n\\n        }\\n        return dp[s][e]= maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767660,
                "title": "prefix-sum-partition-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int recur (int i, int j , vector<int>& stone,vector<int>& prefix,\\n    vector<vector<int>>& dp)\\n    {\\n        if(i == j)\\n        return 0;\\n        \\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        int ans = 0;\\n\\n        for (int k = i+1; k <= j; k++)\\n        {\\n            int leftsum = prefix[k]-prefix[i];\\n            int rightsum = prefix[j+1]-prefix[k];\\n\\n            if ( leftsum < rightsum)\\n            {\\n                ans = max (ans, leftsum + recur (i, k-1 ,stone,prefix,dp));\\n            }\\n            else if (leftsum > rightsum)\\n            {\\n                ans = max (ans ,rightsum + recur(k,j,stone,prefix,dp));\\n            }\\n            else\\nans = max \\n(ans ,leftsum +  max (recur (i,k-1,stone,prefix,dp) , recur(k,j,stone,prefix,dp)));\\n        }\\n\\n        return dp[i][j] = ans;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        \\n        int n = stoneValue.size();\\n        vector<int> prefix(n+1,0);\\n        for (int i = 0; i < n; i++)\\n        {\\n            if(i==0) prefix[i+1] = stoneValue[i];\\n            else prefix[i+1] = prefix[i] + stoneValue[i];\\n        }\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return recur(0,n-1,stoneValue,prefix,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur (int i, int j , vector<int>& stone,vector<int>& prefix,\\n    vector<vector<int>>& dp)\\n    {\\n        if(i == j)\\n        return 0;\\n        \\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        int ans = 0;\\n\\n        for (int k = i+1; k <= j; k++)\\n        {\\n            int leftsum = prefix[k]-prefix[i];\\n            int rightsum = prefix[j+1]-prefix[k];\\n\\n            if ( leftsum < rightsum)\\n            {\\n                ans = max (ans, leftsum + recur (i, k-1 ,stone,prefix,dp));\\n            }\\n            else if (leftsum > rightsum)\\n            {\\n                ans = max (ans ,rightsum + recur(k,j,stone,prefix,dp));\\n            }\\n            else\\nans = max \\n(ans ,leftsum +  max (recur (i,k-1,stone,prefix,dp) , recur(k,j,stone,prefix,dp)));\\n        }\\n\\n        return dp[i][j] = ans;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        \\n        int n = stoneValue.size();\\n        vector<int> prefix(n+1,0);\\n        for (int i = 0; i < n; i++)\\n        {\\n            if(i==0) prefix[i+1] = stoneValue[i];\\n            else prefix[i+1] = prefix[i] + stoneValue[i];\\n        }\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return recur(0,n-1,stoneValue,prefix,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748623,
                "title": "c-dp-recursion-memoization",
                "content": "# Intuition\\ntry all possible partitions of left and rigt part\\n\\n# Approach\\nrun a loop trying every partition at all recursive call\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)+recusion stack space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sum(int l,int r,vector<int>&pref){\\n        return pref[r]-(l==0?0:pref[l-1]);\\n    }\\n    int rec(int i,int j,vector<int>&pref,vector<vector<int>>&dp){\\n        if(i>=j)return 0;\\n\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=0;\\n        for(int k=i;k<=j;k++){\\n            int left=sum(i,k,pref);\\n            int right=sum(k+1,j,pref);\\n            if(left>right){\\n                ans=max(ans,right+rec(k+1,j,pref,dp));\\n            }\\n            else if(left<right){\\n                ans=max(ans,left+rec(i,k,pref,dp));\\n            }\\n            else{\\n                ans=max(ans,max(left+rec(i,k,pref,dp),right+rec(k+1,j,pref,dp)));\\n            }\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int stoneGameV(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>pref(n,0);\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        pref[0]=arr[0];\\n        for(int i=1;i<n;i++){\\n            pref[i]=pref[i-1]+arr[i];\\n        }\\n        return rec(0,n-1,pref,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum(int l,int r,vector<int>&pref){\\n        return pref[r]-(l==0?0:pref[l-1]);\\n    }\\n    int rec(int i,int j,vector<int>&pref,vector<vector<int>>&dp){\\n        if(i>=j)return 0;\\n\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=0;\\n        for(int k=i;k<=j;k++){\\n            int left=sum(i,k,pref);\\n            int right=sum(k+1,j,pref);\\n            if(left>right){\\n                ans=max(ans,right+rec(k+1,j,pref,dp));\\n            }\\n            else if(left<right){\\n                ans=max(ans,left+rec(i,k,pref,dp));\\n            }\\n            else{\\n                ans=max(ans,max(left+rec(i,k,pref,dp),right+rec(k+1,j,pref,dp)));\\n            }\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int stoneGameV(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>pref(n,0);\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        pref[0]=arr[0];\\n        for(int i=1;i<n;i++){\\n            pref[i]=pref[i-1]+arr[i];\\n        }\\n        return rec(0,n-1,pref,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719335,
                "title": "mcm-and-knapsack-combined-algo-faster-than-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int f(int i, int j, vector<int> &val, int tsum){\\n        if(dp[i][j] != -1)return dp[i][j];\\n        if(i == j)return 0;\\n        int sum = 0;\\n        int ans = INT_MIN;\\n        for(int k = i; k < j; k++){\\n            sum+=val[k];\\n            if(sum < tsum-sum){\\n                ans = max(ans, sum+f(i, k, val, sum));\\n            }\\n            else if(sum > tsum-sum){\\n                ans = max(ans, (tsum-sum)+f(k+1, j, val, tsum-sum));\\n            }\\n            else{\\n                ans = max(ans, max(sum+f(i, k, val, sum), sum+f(k+1, j, val, tsum-sum)));\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int tsum = 0;\\n        tsum = accumulate(stoneValue.begin(), stoneValue.end(), tsum);\\n        int n = stoneValue.size();\\n        memset(dp, -1, sizeof(dp));\\n        return f(0, n-1, stoneValue, tsum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int f(int i, int j, vector<int> &val, int tsum){\\n        if(dp[i][j] != -1)return dp[i][j];\\n        if(i == j)return 0;\\n        int sum = 0;\\n        int ans = INT_MIN;\\n        for(int k = i; k < j; k++){\\n            sum+=val[k];\\n            if(sum < tsum-sum){\\n                ans = max(ans, sum+f(i, k, val, sum));\\n            }\\n            else if(sum > tsum-sum){\\n                ans = max(ans, (tsum-sum)+f(k+1, j, val, tsum-sum));\\n            }\\n            else{\\n                ans = max(ans, max(sum+f(i, k, val, sum), sum+f(k+1, j, val, tsum-sum)));\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int tsum = 0;\\n        tsum = accumulate(stoneValue.begin(), stoneValue.end(), tsum);\\n        int n = stoneValue.size();\\n        memset(dp, -1, sizeof(dp));\\n        return f(0, n-1, stoneValue, tsum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661115,
                "title": "java-mcm-type",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntry each cut from start to end index.which cut gives max is our max.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n=stoneValue.length;\\n        int[] prefix=new int[n+1];\\n        prefix[0]=stoneValue[0];\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+stoneValue[i];\\n        }\\n        int st=0,end=n-1;\\n        if(n==1)return 0;\\n        int ans=0;\\n        int dp[][]=new int[n][n];\\n        for(int r[]:dp)Arrays.fill(r,-1);\\n        return solve(st,end,prefix,dp);\\n    }\\n    public int solve(int st,int end,int[] prefix,int[][] dp){\\n      if(st>=end)return 0;\\n      if(dp[st][end]!=-1)return dp[st][end];\\n       int a=0,b=0;\\n       int res=0;\\n       int count=0;\\n         for(int i=st;i<=end;i++){\\n          if(st==0)a=prefix[i];\\n          else a=prefix[i]-prefix[st-1];\\n          b=prefix[end]-prefix[i];\\n           if(b>a){\\n               count=a+solve(st,i,prefix,dp);\\n           }\\n           else if(a>b){\\n               count =b+solve(i+1,end,prefix,dp);\\n           }\\n           else {\\n               count=a+Math.max(solve(st,i,prefix,dp),solve(i+1,end,prefix,dp));\\n           }\\n           res=Math.max(res,count);\\n         }\\n         return dp[st][end]=res;\\n    }\\n \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n=stoneValue.length;\\n        int[] prefix=new int[n+1];\\n        prefix[0]=stoneValue[0];\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+stoneValue[i];\\n        }\\n        int st=0,end=n-1;\\n        if(n==1)return 0;\\n        int ans=0;\\n        int dp[][]=new int[n][n];\\n        for(int r[]:dp)Arrays.fill(r,-1);\\n        return solve(st,end,prefix,dp);\\n    }\\n    public int solve(int st,int end,int[] prefix,int[][] dp){\\n      if(st>=end)return 0;\\n      if(dp[st][end]!=-1)return dp[st][end];\\n       int a=0,b=0;\\n       int res=0;\\n       int count=0;\\n         for(int i=st;i<=end;i++){\\n          if(st==0)a=prefix[i];\\n          else a=prefix[i]-prefix[st-1];\\n          b=prefix[end]-prefix[i];\\n           if(b>a){\\n               count=a+solve(st,i,prefix,dp);\\n           }\\n           else if(a>b){\\n               count =b+solve(i+1,end,prefix,dp);\\n           }\\n           else {\\n               count=a+Math.max(solve(st,i,prefix,dp),solve(i+1,end,prefix,dp));\\n           }\\n           res=Math.max(res,count);\\n         }\\n         return dp[st][end]=res;\\n    }\\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629462,
                "title": "c-dp",
                "content": "```\\npublic class Solution {\\n    public int StoneGameV(int[] stoneValue) {\\n        int n= stoneValue.Length;\\n        int[,] dp=new int[n,n];\\n        \\n        int[] sm=new int[n];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            sm[i]=i>0 ? sm[i-1]+stoneValue[i] : stoneValue[i];\\n            //dp[i,i]=stoneValue[i];\\n            for(int j=i-1;j>=0;j--){\\n                int res=0;\\n                for(int k=i;k>j;k--){\\n                    int sleft=j>0 ? sm[k-1]-sm[j-1] : sm[k-1];\\n                    int sright=sm[i]-sm[k-1];\\n                    \\n                    \\n                    if(sright>sleft)\\n                        res=Math.Max(dp[j,k-1]+ sleft,res);\\n                    else if(sright<sleft)\\n                        res=Math.Max(dp[k,i]+ sright,res);\\n                    else \\n                        res=Math.Max(res,Math.Max(dp[j,k-1]+ sleft,dp[k,i]+ sright));\\n                }    \\n                dp[j,i]=res;\\n            }\\n        }\\n        \\n        \\n        return dp[0,n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int StoneGameV(int[] stoneValue) {\\n        int n= stoneValue.Length;\\n        int[,] dp=new int[n,n];\\n        \\n        int[] sm=new int[n];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            sm[i]=i>0 ? sm[i-1]+stoneValue[i] : stoneValue[i];\\n            //dp[i,i]=stoneValue[i];\\n            for(int j=i-1;j>=0;j--){\\n                int res=0;\\n                for(int k=i;k>j;k--){\\n                    int sleft=j>0 ? sm[k-1]-sm[j-1] : sm[k-1];\\n                    int sright=sm[i]-sm[k-1];\\n                    \\n                    \\n                    if(sright>sleft)\\n                        res=Math.Max(dp[j,k-1]+ sleft,res);\\n                    else if(sright<sleft)\\n                        res=Math.Max(dp[k,i]+ sright,res);\\n                    else \\n                        res=Math.Max(res,Math.Max(dp[j,k-1]+ sleft,dp[k,i]+ sright));\\n                }    \\n                dp[j,i]=res;\\n            }\\n        }\\n        \\n        \\n        return dp[0,n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583808,
                "title": "easy-solution-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef vector< vector<int>>vv;\\ntypedef vector<int>vi;\\n#define all(v) ((v).begin()),((v).end())\\nclass Solution {\\npublic:\\nvector<int> Cum_Sum;\\nint n;\\nvv DP;\\n    int stoneGameV(vector<int>& Piles) {\\n     n=Piles.size(); \\n    Cum_Sum= vector<int>(1, 0);\\n    DP = vv(n + 5, vi(n+5, -1));\\n    partial_sum(all(Piles), back_inserter(Cum_Sum));\\n    return Solve(1, n);\\n    }\\n\\n    \\nint Solve(int i, int j) {\\n    int& ret = DP[i][j];\\n    if (ret != -1)return ret;\\n    if (i == j)return ret=0;\\n    int Max_Coost = 0;\\n    for (int x = i; x < j; x++) {\\n        int row1=Cum_Sum[x]-Cum_Sum[i-1], row2= Cum_Sum[j] - Cum_Sum[x];\\n        if (row1 > row2)\\n            Max_Coost = max(Max_Coost, Solve(x + 1, j)+row2);\\n        else if(row1==row2)\\n            Max_Coost = max(Max_Coost,max(Solve(i, x) + row1,Solve(x + 1, j) + row2));\\n        else\\n            Max_Coost = max(Max_Coost, Solve(i, x)+row1);\\n    }\\n    return ret=Max_Coost;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ntypedef vector< vector<int>>vv;\\ntypedef vector<int>vi;\\n#define all(v) ((v).begin()),((v).end())\\nclass Solution {\\npublic:\\nvector<int> Cum_Sum;\\nint n;\\nvv DP;\\n    int stoneGameV(vector<int>& Piles) {\\n     n=Piles.size(); \\n    Cum_Sum= vector<int>(1, 0);\\n    DP = vv(n + 5, vi(n+5, -1));\\n    partial_sum(all(Piles), back_inserter(Cum_Sum));\\n    return Solve(1, n);\\n    }\\n\\n    \\nint Solve(int i, int j) {\\n    int& ret = DP[i][j];\\n    if (ret != -1)return ret;\\n    if (i == j)return ret=0;\\n    int Max_Coost = 0;\\n    for (int x = i; x < j; x++) {\\n        int row1=Cum_Sum[x]-Cum_Sum[i-1], row2= Cum_Sum[j] - Cum_Sum[x];\\n        if (row1 > row2)\\n            Max_Coost = max(Max_Coost, Solve(x + 1, j)+row2);\\n        else if(row1==row2)\\n            Max_Coost = max(Max_Coost,max(Solve(i, x) + row1,Solve(x + 1, j) + row2));\\n        else\\n            Max_Coost = max(Max_Coost, Solve(i, x)+row1);\\n    }\\n    return ret=Max_Coost;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581776,
                "title": "memoization-recursion-c",
                "content": "# Complexity\\n- Time complexity: O(n^3)\\n\\n- Space complexity: O(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pre[501];\\n    int dp[501][501];\\n    int helper(int start, int end, vector<int>&a){\\n        if(start>=end) return 0;\\n        if(dp[start][end]!=-1) return dp[start][end];\\n        int sum=0,resum=0;\\n        for(int i=start; i<=end; i++) resum+=a[i];\\n        int ans=0;\\n        for(int i=start; i<=end-1; i++){\\n            sum+=a[i];\\n            if(start==0){\\n                if(pre[i]==pre[end]-pre[i]){ \\n                    ans=max({ans,pre[end]-pre[i]+helper(i+1,end,a),pre[i]+helper(start,i,a)}); // if both part sum equal then alice can chose which part of array will remain\\n                }\\n                else if(pre[i]>pre[end]-pre[i]){\\n                    // if left part sum is greater than right part than bob remove left part\\n                    ans=max(ans,pre[end]-pre[i]+helper(i+1,end,a));\\n                }\\n                else{\\n                    // if right part sum is greater than left part then bob remove right part\\n                    ans=max(ans,pre[i]+helper(start,i,a));\\n                }\\n            }\\n            else{\\n                if(pre[i]-pre[start-1]==pre[end]-pre[i]){\\n                    ans=max({ans,pre[end]-pre[i]+helper(i+1,end,a),pre[i]-pre[start-1]+helper(start,i,a)});\\n                }\\n                else if(pre[i]-pre[start-1]>pre[end]-pre[i]){\\n                    ans=max(ans,pre[end]-pre[i]+helper(i+1,end,a));\\n                }\\n                else{\\n                    ans=max(ans,pre[i]-pre[start-1]+helper(start,i,a));\\n                }\\n\\n            }\\n        }\\n        return dp[start][end]=ans;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        pre[0]=stoneValue[0];\\n        for(int i=1; i<stoneValue.size(); i++){\\n            pre[i]=pre[i-1]+stoneValue[i];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,stoneValue.size()-1,stoneValue);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pre[501];\\n    int dp[501][501];\\n    int helper(int start, int end, vector<int>&a){\\n        if(start>=end) return 0;\\n        if(dp[start][end]!=-1) return dp[start][end];\\n        int sum=0,resum=0;\\n        for(int i=start; i<=end; i++) resum+=a[i];\\n        int ans=0;\\n        for(int i=start; i<=end-1; i++){\\n            sum+=a[i];\\n            if(start==0){\\n                if(pre[i]==pre[end]-pre[i]){ \\n                    ans=max({ans,pre[end]-pre[i]+helper(i+1,end,a),pre[i]+helper(start,i,a)}); // if both part sum equal then alice can chose which part of array will remain\\n                }\\n                else if(pre[i]>pre[end]-pre[i]){\\n                    // if left part sum is greater than right part than bob remove left part\\n                    ans=max(ans,pre[end]-pre[i]+helper(i+1,end,a));\\n                }\\n                else{\\n                    // if right part sum is greater than left part then bob remove right part\\n                    ans=max(ans,pre[i]+helper(start,i,a));\\n                }\\n            }\\n            else{\\n                if(pre[i]-pre[start-1]==pre[end]-pre[i]){\\n                    ans=max({ans,pre[end]-pre[i]+helper(i+1,end,a),pre[i]-pre[start-1]+helper(start,i,a)});\\n                }\\n                else if(pre[i]-pre[start-1]>pre[end]-pre[i]){\\n                    ans=max(ans,pre[end]-pre[i]+helper(i+1,end,a));\\n                }\\n                else{\\n                    ans=max(ans,pre[i]-pre[start-1]+helper(start,i,a));\\n                }\\n\\n            }\\n        }\\n        return dp[start][end]=ans;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        pre[0]=stoneValue[0];\\n        for(int i=1; i<stoneValue.size(); i++){\\n            pre[i]=pre[i-1]+stoneValue[i];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,stoneValue.size()-1,stoneValue);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578832,
                "title": "intuitive-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int solve(int i, int j, vector<int> &arr, int sum){\\n        \\n        if(i > j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int cs = 0, ans = 0;\\n        for(int k = i; k <= j; ++k){\\n            cs += arr[k];\\n            int t = 0;\\n            if(cs < sum-cs){\\n                t = cs + solve(i, k-1, arr, cs);\\n            }\\n            else if(cs > sum-cs){\\n                t = sum-cs + solve(k+1, j, arr, sum-cs);\\n            }\\n            else{\\n                t = cs + max(solve(i, k-1, arr, cs), solve(k+1, j, arr, cs)); \\n            }\\n            ans = max(ans, t);\\n        }\\n        return dp[i][j] = ans;\\n\\n\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int sm = 0;\\n        int n = stoneValue.size();\\n        dp = vector<vector<int>> (n+1, vector<int>(n+1, -1));\\n        for(auto &i : stoneValue) sm += i;\\n        return solve(0, n-1, stoneValue, sm);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int solve(int i, int j, vector<int> &arr, int sum){\\n        \\n        if(i > j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int cs = 0, ans = 0;\\n        for(int k = i; k <= j; ++k){\\n            cs += arr[k];\\n            int t = 0;\\n            if(cs < sum-cs){\\n                t = cs + solve(i, k-1, arr, cs);\\n            }\\n            else if(cs > sum-cs){\\n                t = sum-cs + solve(k+1, j, arr, sum-cs);\\n            }\\n            else{\\n                t = cs + max(solve(i, k-1, arr, cs), solve(k+1, j, arr, cs)); \\n            }\\n            ans = max(ans, t);\\n        }\\n        return dp[i][j] = ans;\\n\\n\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int sm = 0;\\n        int n = stoneValue.size();\\n        dp = vector<vector<int>> (n+1, vector<int>(n+1, -1));\\n        for(auto &i : stoneValue) sm += i;\\n        return solve(0, n-1, stoneValue, sm);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577070,
                "title": "kotlin-dynamic-programming-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun stoneGameV(stoneValue: IntArray): Int {\\n        val n = stoneValue.size\\n        val dp = Array(n){ IntArray(n){ -1 } }\\n\\n        val sums = IntArray(n){ stoneValue[it] }\\n        for (i in 1 until n) {\\n            sums[i] += sums[i - 1]\\n        }\\n\\n        fun dfs(left: Int, right: Int): Int{\\n            if (dp[left][right] >= 0) return dp[left][right]\\n            if (left >= right) return 0\\n\\n            var result = Int.MIN_VALUE\\n            for (pivot in left until right) {\\n                var ls = sums[pivot] - (if (left == 0) 0 else sums[left - 1])\\n                var rs = sums[right] - sums[pivot]\\n\\n                if (ls > rs) {\\n                    result = Math.max(result, rs + dfs(pivot + 1, right))\\n                } else if (ls < rs) {\\n                    result = Math.max(result, ls + dfs(left, pivot))\\n                } else {\\n                    result = Math.max(Math.max(result, ls + dfs(left, pivot)), rs + dfs(pivot + 1, right))\\n                }\\n            }\\n\\n            dp[left][right] = result\\n            return result\\n        }\\n\\n        return dfs(0, n - 1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun stoneGameV(stoneValue: IntArray): Int {\\n        val n = stoneValue.size\\n        val dp = Array(n){ IntArray(n){ -1 } }\\n\\n        val sums = IntArray(n){ stoneValue[it] }\\n        for (i in 1 until n) {\\n            sums[i] += sums[i - 1]\\n        }\\n\\n        fun dfs(left: Int, right: Int): Int{\\n            if (dp[left][right] >= 0) return dp[left][right]\\n            if (left >= right) return 0\\n\\n            var result = Int.MIN_VALUE\\n            for (pivot in left until right) {\\n                var ls = sums[pivot] - (if (left == 0) 0 else sums[left - 1])\\n                var rs = sums[right] - sums[pivot]\\n\\n                if (ls > rs) {\\n                    result = Math.max(result, rs + dfs(pivot + 1, right))\\n                } else if (ls < rs) {\\n                    result = Math.max(result, ls + dfs(left, pivot))\\n                } else {\\n                    result = Math.max(Math.max(result, ls + dfs(left, pivot)), rs + dfs(pivot + 1, right))\\n                }\\n            }\\n\\n            dp[left][right] = result\\n            return result\\n        }\\n\\n        return dfs(0, n - 1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572959,
                "title": "partition-dp-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(vector<int>&stones,int i,int j,vector<int>&prefix){\\n        if(j-i==0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int a=0;\\n    \\n        for(int k=i+1;k<=j;k++){\\n            int leftsum=prefix[k-1]-(i-1>=0 ? prefix[i-1]:0);\\n            int rightsum=prefix[j]-(k-1>=0 ? prefix[k-1]:0);\\n            if(leftsum==rightsum){\\n                a=max(leftsum+solve(stones,i,k-1,prefix),rightsum+solve(stones,k,j,prefix));\\n                \\n\\n            }\\n            else if(leftsum>rightsum){\\n                a=max(a,rightsum+solve(stones,k,j,prefix));\\n\\n\\n            }\\n            else{\\n                a=max(a,leftsum+solve(stones,i,k-1,prefix));\\n            }\\n        }\\n        return dp[i][j]=a;\\n\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        memset(dp,-1,sizeof dp);\\n        int n=stoneValue.size();\\n        vector<int> prefix(n,0);\\n        prefix[0]=stoneValue[0];\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+stoneValue[i];\\n        }\\n        for(auto x: prefix){\\n            cout<<x<<\" \";\\n        }\\n\\n        return solve(stoneValue,0,stoneValue.size()-1,prefix);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(vector<int>&stones,int i,int j,vector<int>&prefix){\\n        if(j-i==0){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int a=0;\\n    \\n        for(int k=i+1;k<=j;k++){\\n            int leftsum=prefix[k-1]-(i-1>=0 ? prefix[i-1]:0);\\n            int rightsum=prefix[j]-(k-1>=0 ? prefix[k-1]:0);\\n            if(leftsum==rightsum){\\n                a=max(leftsum+solve(stones,i,k-1,prefix),rightsum+solve(stones,k,j,prefix));\\n                \\n\\n            }\\n            else if(leftsum>rightsum){\\n                a=max(a,rightsum+solve(stones,k,j,prefix));\\n\\n\\n            }\\n            else{\\n                a=max(a,leftsum+solve(stones,i,k-1,prefix));\\n            }\\n        }\\n        return dp[i][j]=a;\\n\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        memset(dp,-1,sizeof dp);\\n        int n=stoneValue.size();\\n        vector<int> prefix(n,0);\\n        prefix[0]=stoneValue[0];\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+stoneValue[i];\\n        }\\n        for(auto x: prefix){\\n            cout<<x<<\" \";\\n        }\\n\\n        return solve(stoneValue,0,stoneValue.size()-1,prefix);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3571781,
                "title": "simple-recursive-memoized-solution-96-efficient-faseter-easy-to-understand",
                "content": "```\\nint dp[502][502] ;\\n    \\n    int solve(vector<int>& stone , int start , int end )\\n    {\\n        if( start >= end ) return 0 ;\\n        \\n        if( dp[start][end] != -1 ) return dp[start][end] ;\\n        \\n        int total = 0 ;\\n        \\n        for( int i = start ; i <= end ; i++ )\\n        {\\n            total += stone[i] ;\\n        }\\n        \\n        int left = 0 ;\\n        \\n        int ans = 0 ;\\n        \\n        for( int i = start ; i <= end ; i++ )\\n        {\\n            left += stone[i] ;\\n            int right = total - left ;\\n            \\n            if( right > left )\\n            {\\n                ans = max( ans , left + solve( stone , start , i ) ) ;\\n            }\\n            else if( left > right )\\n            {\\n                ans = max( ans , right + solve( stone , i+1 , end ) ) ;\\n            }\\n            else{\\n                \\n                ans = max( ans , left + solve( stone , start , i  ) ) ;\\n                ans = max( ans , right + solve( stone , i+1  , end )) ;\\n            }\\n        }\\n        \\n        return dp[start][end] = ans ;\\n        \\n    }\\n    int stoneGameV(vector<int>& stone ) {\\n        \\n        memset( dp , -1 , sizeof(dp) ) ;\\n        return solve( stone , 0 , stone.size() - 1 ) ;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint dp[502][502] ;\\n    \\n    int solve(vector<int>& stone , int start , int end )\\n    {\\n        if( start >= end ) return 0 ;\\n        \\n        if( dp[start][end] != -1 ) return dp[start][end] ;\\n        \\n        int total = 0 ;\\n        \\n        for( int i = start ; i <= end ; i++ )\\n        {\\n            total += stone[i] ;\\n        }\\n        \\n        int left = 0 ;\\n        \\n        int ans = 0 ;\\n        \\n        for( int i = start ; i <= end ; i++ )\\n        {\\n            left += stone[i] ;\\n            int right = total - left ;\\n            \\n            if( right > left )\\n            {\\n                ans = max( ans , left + solve( stone , start , i ) ) ;\\n            }\\n            else if( left > right )\\n            {\\n                ans = max( ans , right + solve( stone , i+1 , end ) ) ;\\n            }\\n            else{\\n                \\n                ans = max( ans , left + solve( stone , start , i  ) ) ;\\n                ans = max( ans , right + solve( stone , i+1  , end )) ;\\n            }\\n        }\\n        \\n        return dp[start][end] = ans ;\\n        \\n    }\\n    int stoneGameV(vector<int>& stone ) {\\n        \\n        memset( dp , -1 , sizeof(dp) ) ;\\n        return solve( stone , 0 , stone.size() - 1 ) ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569989,
                "title": "game-theory-one-of-the-best-question-dp-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[501][501];\\n    int f(int start,int end,vector<int>&pref){\\n        if(start == end)return 0;//base case of tge dynamic programming \\n\\n        if(dp[start][end]!=-1)return dp[start][end];\\n\\n        int ans = 0;\\n        for(int i=start+1;i<=end;i++){\\n            int l = pref[i] - pref[start];\\n            int r = pref[end+1] - pref[i];\\n\\n            if(l<r){\\n                ans = max(ans,l+f(start,i-1,pref));\\n            }\\n            else if(l>r){\\n                ans =max(ans,r+f(i,end,pref));\\n            }\\n            else{\\n                ans = max(ans,l+max(f(start,i-1,pref),f(i,end,pref)));\\n            }\\n        }\\n        return dp[start][end] = ans;\\n    }\\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        \\n        int  n = stoneValue.size();\\n        vector<int> pref(n+1,0);\\n        for(int i=0;i<stoneValue.size();i++){\\n            pref[i+1] = pref[i] + stoneValue[i];\\n        }\\n        //1 based index prefix sum is ready now f(0,n)\\n\\n        memset(dp,-1,sizeof(dp));\\n\\n        return f(0,n-1,pref);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dp[501][501];\\n    int f(int start,int end,vector<int>&pref){\\n        if(start == end)return 0;//base case of tge dynamic programming \\n\\n        if(dp[start][end]!=-1)return dp[start][end];\\n\\n        int ans = 0;\\n        for(int i=start+1;i<=end;i++){\\n            int l = pref[i] - pref[start];\\n            int r = pref[end+1] - pref[i];\\n\\n            if(l<r){\\n                ans = max(ans,l+f(start,i-1,pref));\\n            }\\n            else if(l>r){\\n                ans =max(ans,r+f(i,end,pref));\\n            }\\n            else{\\n                ans = max(ans,l+max(f(start,i-1,pref),f(i,end,pref)));\\n            }\\n        }\\n        return dp[start][end] = ans;\\n    }\\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        \\n        int  n = stoneValue.size();\\n        vector<int> pref(n+1,0);\\n        for(int i=0;i<stoneValue.size();i++){\\n            pref[i+1] = pref[i] + stoneValue[i];\\n        }\\n        //1 based index prefix sum is ready now f(0,n)\\n\\n        memset(dp,-1,sizeof(dp));\\n\\n        return f(0,n-1,pref);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566954,
                "title": "c-recursive-memoization-prefix-sum-explained",
                "content": "# Intuition\\n- We need to try all possible divisions for the current row to get the max score.\\n- As calculating all possible divisions will lead us to calculate some sub-problems more than once, we need to think of memoizing the result.\\n\\n# Approach\\nWe will first calculate prefix-sum.It will be helpful for finding sum of segments in O(1).\\nWe will pass the parameters to recursive function.Parameters include-\\nstart index,ending index,prefix_sum array\\nNow we have choice to break the segment.We will try each possible choice and will find the max result.\\n\\n\\n\\n\\n# Code [recursive TLE]\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int find(int i,int j,vector<int>&stone)\\n    {\\n        if(i==j) // base case (only 1 stone left so no possible division )\\n        return 0;\\n        int ans=0;\\n        for(int k=i;k<=j-1;k++)  // exploring all choices \\n        {\\n            int left_sum=stone[k];  // calculate left_sum\\n            if(i!=0)\\n            left_sum-=stone[i-1];\\n\\n            int right_sum=stone[j]-stone[k];          // right sum \\n\\n            if(left_sum<right_sum)                     // bob will discard right_sum\\n            ans=max(ans,left_sum+find(i,k,stone));\\n            else if(right_sum<left_sum)                // bob will discard left_sum\\n            ans=max(ans,right_sum+find(k+1,j,stone));\\n            else\\n            { \\n            // if left_sum==right_sum then alice has choice to pick \\n                 ans=max(ans,left_sum+find(i,k,stone));    // left segment\\n                 ans=max(ans,right_sum+find(k+1,j,stone));   // right segment \\n            }\\n        }\\n        return ans;\\n    }\\n    int stoneGameV(vector<int>& stone) \\n    {\\n        for(int i=1;i<stone.size();i++)\\n        {\\n            stone[i]+=stone[i-1];  // calculating prefix sum \\n            \\n        }\\n        int ans=find(0,stone.size()-1,stone);\\n        return ans;\\n    }\\n};\\n```\\n# Code [memoized ACCEPTED]\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int find(int i,int j,vector<int>&stone,vector<vector<int>>&dp)\\n    {\\n        if(i==j)\\n        return 0;\\n        if(dp[i][j]!=-1)\\n        return dp[i][j];\\n        int ans=0;\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left_sum=stone[k];\\n            if(i!=0)\\n            left_sum-=stone[i-1];\\n            int right_sum=stone[j]-stone[k];\\n            if(left_sum<right_sum)\\n            ans=max(ans,left_sum+find(i,k,stone,dp));\\n            else if(right_sum<left_sum)\\n            ans=max(ans,right_sum+find(k+1,j,stone,dp));\\n            else\\n            {\\n                 ans=max(ans,left_sum+find(i,k,stone,dp));\\n                 ans=max(ans,right_sum+find(k+1,j,stone,dp));\\n            }\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int stoneGameV(vector<int>& stone) \\n    {\\n        for(int i=1;i<stone.size();i++)\\n        {\\n            stone[i]+=stone[i-1];   \\n        }\\n        int n=stone.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1)); // for memoizing\\n        int ans=find(0,stone.size()-1,stone,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int find(int i,int j,vector<int>&stone)\\n    {\\n        if(i==j) // base case (only 1 stone left so no possible division )\\n        return 0;\\n        int ans=0;\\n        for(int k=i;k<=j-1;k++)  // exploring all choices \\n        {\\n            int left_sum=stone[k];  // calculate left_sum\\n            if(i!=0)\\n            left_sum-=stone[i-1];\\n\\n            int right_sum=stone[j]-stone[k];          // right sum \\n\\n            if(left_sum<right_sum)                     // bob will discard right_sum\\n            ans=max(ans,left_sum+find(i,k,stone));\\n            else if(right_sum<left_sum)                // bob will discard left_sum\\n            ans=max(ans,right_sum+find(k+1,j,stone));\\n            else\\n            { \\n            // if left_sum==right_sum then alice has choice to pick \\n                 ans=max(ans,left_sum+find(i,k,stone));    // left segment\\n                 ans=max(ans,right_sum+find(k+1,j,stone));   // right segment \\n            }\\n        }\\n        return ans;\\n    }\\n    int stoneGameV(vector<int>& stone) \\n    {\\n        for(int i=1;i<stone.size();i++)\\n        {\\n            stone[i]+=stone[i-1];  // calculating prefix sum \\n            \\n        }\\n        int ans=find(0,stone.size()-1,stone);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int find(int i,int j,vector<int>&stone,vector<vector<int>>&dp)\\n    {\\n        if(i==j)\\n        return 0;\\n        if(dp[i][j]!=-1)\\n        return dp[i][j];\\n        int ans=0;\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left_sum=stone[k];\\n            if(i!=0)\\n            left_sum-=stone[i-1];\\n            int right_sum=stone[j]-stone[k];\\n            if(left_sum<right_sum)\\n            ans=max(ans,left_sum+find(i,k,stone,dp));\\n            else if(right_sum<left_sum)\\n            ans=max(ans,right_sum+find(k+1,j,stone,dp));\\n            else\\n            {\\n                 ans=max(ans,left_sum+find(i,k,stone,dp));\\n                 ans=max(ans,right_sum+find(k+1,j,stone,dp));\\n            }\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int stoneGameV(vector<int>& stone) \\n    {\\n        for(int i=1;i<stone.size();i++)\\n        {\\n            stone[i]+=stone[i-1];   \\n        }\\n        int n=stone.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1)); // for memoizing\\n        int ans=find(0,stone.size()-1,stone,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566650,
                "title": "memoization-prefix-sum-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int t[501][501];\\n    int maxAliceScore(vector<int>& stoneValue,int i,int j,vector<int> &prefix_score)\\n    {\\n        if (i==j)\\n           return 0;\\n        int maxi=INT_MIN;\\n        if (t[i][j]!=-1)\\n          return t[i][j];\\n        for (int x=i+1;x<=j;x++)\\n        {\\n            int left_sum=prefix_score[x]-prefix_score[i];\\n            int right_sum=prefix_score[j+1]-prefix_score[x];\\n            if (left_sum>right_sum)\\n               maxi=max(maxi,right_sum+maxAliceScore(stoneValue,x,j,prefix_score));\\n            else if (left_sum<right_sum)\\n               maxi=max(maxi,left_sum+maxAliceScore(stoneValue,i,x-1,prefix_score));\\n            else\\n               maxi=max(maxi,left_sum+max(maxAliceScore(stoneValue,x,j,prefix_score),maxAliceScore(stoneValue,i,x-1,prefix_score)));\\n        }\\n        return t[i][j]=maxi;\\n        \\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n=stoneValue.size();\\n        vector<int> prefix_score(n+1,0);\\n        for (int i=0;i<n;i++)\\n            prefix_score[i+1]=prefix_score[i]+stoneValue[i];\\n         memset(t,-1,sizeof(t));\\n        return maxAliceScore(stoneValue,0,n-1,prefix_score);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[501][501];\\n    int maxAliceScore(vector<int>& stoneValue,int i,int j,vector<int> &prefix_score)\\n    {\\n        if (i==j)\\n           return 0;\\n        int maxi=INT_MIN;\\n        if (t[i][j]!=-1)\\n          return t[i][j];\\n        for (int x=i+1;x<=j;x++)\\n        {\\n            int left_sum=prefix_score[x]-prefix_score[i];\\n            int right_sum=prefix_score[j+1]-prefix_score[x];\\n            if (left_sum>right_sum)\\n               maxi=max(maxi,right_sum+maxAliceScore(stoneValue,x,j,prefix_score));\\n            else if (left_sum<right_sum)\\n               maxi=max(maxi,left_sum+maxAliceScore(stoneValue,i,x-1,prefix_score));\\n            else\\n               maxi=max(maxi,left_sum+max(maxAliceScore(stoneValue,x,j,prefix_score),maxAliceScore(stoneValue,i,x-1,prefix_score)));\\n        }\\n        return t[i][j]=maxi;\\n        \\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n=stoneValue.size();\\n        vector<int> prefix_score(n+1,0);\\n        for (int i=0;i<n;i++)\\n            prefix_score[i+1]=prefix_score[i]+stoneValue[i];\\n         memset(t,-1,sizeof(t));\\n        return maxAliceScore(stoneValue,0,n-1,prefix_score);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566633,
                "title": "simple-dp-memoized-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[502][502];\\n\\n    int help(vector<int>&pre,vector<int>&stone,int i,int j){\\n\\n\\n        //the base case \\n        \\n        if(i==j){\\n            return 0;\\n        }\\n\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n\\n        //now in the current recursive call and alice will make all possible partition \\n        //and then both removes the one with max sum\\n        //and the smaller sum one is added to the score of alice\\n        int curr=INT_MIN;;\\n\\n        for(int a=i;a<j;a++){\\n            //since it is nessary to break it into 2 non empty parition in each round of the \\n            //gameplay\\n            int c1=pre[a]-(i-1>=0?pre[i-1]:0);\\n            int c2=pre[j]-pre[a];\\n            if(c1>c2){\\n                curr=max(curr,c2+help(pre,stone,a+1,j));\\n\\n            }else if(c1<c2){\\n                curr=max(curr,c1+help(pre,stone,i,a));\\n\\n            }else{\\n                curr=max(curr,c2+help(pre,stone,a+1,j));\\n                curr=max(curr,c1+help(pre,stone,i,a));\\n\\n                //if the value is equal then we will be able to check both the values\\n\\n            }\\n\\n        }\\n        return dp[i][j]=curr;\\n    }\\n    int stoneGameV(vector<int>& stone) {\\n        memset(dp,-1,sizeof(dp));\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        int n=stone.size();\\n        vector<int>pre(n,0);\\n        pre[0]=stone[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]+=pre[i-1]+stone[i];\\n        }\\n\\n\\n\\n        //both play optimally and in that case we need to finmd the max score aqlice can obtain\\n       return  help(pre,stone,0,n-1);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[502][502];\\n\\n    int help(vector<int>&pre,vector<int>&stone,int i,int j){\\n\\n\\n        //the base case \\n        \\n        if(i==j){\\n            return 0;\\n        }\\n\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n\\n        //now in the current recursive call and alice will make all possible partition \\n        //and then both removes the one with max sum\\n        //and the smaller sum one is added to the score of alice\\n        int curr=INT_MIN;;\\n\\n        for(int a=i;a<j;a++){\\n            //since it is nessary to break it into 2 non empty parition in each round of the \\n            //gameplay\\n            int c1=pre[a]-(i-1>=0?pre[i-1]:0);\\n            int c2=pre[j]-pre[a];\\n            if(c1>c2){\\n                curr=max(curr,c2+help(pre,stone,a+1,j));\\n\\n            }else if(c1<c2){\\n                curr=max(curr,c1+help(pre,stone,i,a));\\n\\n            }else{\\n                curr=max(curr,c2+help(pre,stone,a+1,j));\\n                curr=max(curr,c1+help(pre,stone,i,a));\\n\\n                //if the value is equal then we will be able to check both the values\\n\\n            }\\n\\n        }\\n        return dp[i][j]=curr;\\n    }\\n    int stoneGameV(vector<int>& stone) {\\n        memset(dp,-1,sizeof(dp));\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        int n=stone.size();\\n        vector<int>pre(n,0);\\n        pre[0]=stone[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]+=pre[i-1]+stone[i];\\n        }\\n\\n\\n\\n        //both play optimally and in that case we need to finmd the max score aqlice can obtain\\n       return  help(pre,stone,0,n-1);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564646,
                "title": "stone-game-v",
                "content": "---------------- Easy Solution ----------------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int stoneGameV(vector<int>& stoneValue) {\\n     int n = stoneValue.size();\\n    dp.resize(n, vector<int>(n, -1));\\n    return stoneGameV(stoneValue, 0, n - 1);\\n  }\\n\\n private:\\n  vector<vector<int>> dp;\\n\\n  int stoneGameV(const vector<int>& stoneValue, int i, int j) {\\n    if(i>j)\\n      return 0;\\n    if(dp[i][j]!=-1)\\n      return dp[i][j];\\n    int r=0;\\n    int l=0;\\n    for(int s=i;s<=j;s++){\\n       r+=stoneValue[s];\\n    }\\n    int ans=0;\\n    for (int p = i; p <j; ++p) {\\n       l+=stoneValue[p];\\n       r=r-stoneValue[p];\\n      if (l < r)  \\n        ans = max(ans, l + stoneGameV(stoneValue, i, p));\\n      else if (l > r) \\n        ans = max(ans, r + stoneGameV(stoneValue, p+1, j));\\n      else  if(l==r)\\n        ans = max(ans, l + max(stoneGameV(stoneValue, i, p), stoneGameV(stoneValue, p+1, j)));\\n    }\\n\\n    return dp[i][j]=ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int stoneGameV(vector<int>& stoneValue) {\\n     int n = stoneValue.size();\\n    dp.resize(n, vector<int>(n, -1));\\n    return stoneGameV(stoneValue, 0, n - 1);\\n  }\\n\\n private:\\n  vector<vector<int>> dp;\\n\\n  int stoneGameV(const vector<int>& stoneValue, int i, int j) {\\n    if(i>j)\\n      return 0;\\n    if(dp[i][j]!=-1)\\n      return dp[i][j];\\n    int r=0;\\n    int l=0;\\n    for(int s=i;s<=j;s++){\\n       r+=stoneValue[s];\\n    }\\n    int ans=0;\\n    for (int p = i; p <j; ++p) {\\n       l+=stoneValue[p];\\n       r=r-stoneValue[p];\\n      if (l < r)  \\n        ans = max(ans, l + stoneGameV(stoneValue, i, p));\\n      else if (l > r) \\n        ans = max(ans, r + stoneGameV(stoneValue, p+1, j));\\n      else  if(l==r)\\n        ans = max(ans, l + max(stoneGameV(stoneValue, i, p), stoneGameV(stoneValue, p+1, j)));\\n    }\\n\\n    return dp[i][j]=ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405592,
                "title": "c-memo-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmemoization\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nright_part = total - left_part.\\n\\n1.According to question if left_part more then solve for right_part and temp_ans = right_part + solve(i+1,end).\\n2. if right_part more then solve for left_part ans temp_ans = left_part + solve(st,i).\\n3.if both part equal then add which will give us maximum ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     \\n    int solve(int st,int end,vector<int>& stoneValue,vector<vector<int>>&dp){\\n        \\n        if(st >= end)return 0;\\n\\n        if(dp[st][end]!=-1)return dp[st][end];\\n\\n        int sum = 0;\\n        for(int i = st ; i<=end;i++){\\n            sum+= stoneValue[i];\\n        }\\n        int ans = 0;\\n        int temp = 0;\\n        for(int i =st; i<=end;i++){\\n            temp+= stoneValue[i];\\n            if(temp < sum - temp){\\n                ans = max(ans,temp + solve(st,i,stoneValue,dp) );\\n            }else if(temp > sum-temp){\\n                ans = max(ans,sum-temp + solve(i+1,end,stoneValue,dp));\\n            }else{\\n                ans = max( {ans,temp + solve(st,i,stoneValue,dp),sum-temp + solve(i+1,end,stoneValue,dp)});\\n            }\\n        }\\n        return dp[st][end] = ans;\\n    }\\n\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int st = 0;\\n        int end = stoneValue.size();\\n        vector<vector<int>>dp(end+1,vector<int>(end+1,-1));\\n        return solve(st,end-1,stoneValue,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     \\n    int solve(int st,int end,vector<int>& stoneValue,vector<vector<int>>&dp){\\n        \\n        if(st >= end)return 0;\\n\\n        if(dp[st][end]!=-1)return dp[st][end];\\n\\n        int sum = 0;\\n        for(int i = st ; i<=end;i++){\\n            sum+= stoneValue[i];\\n        }\\n        int ans = 0;\\n        int temp = 0;\\n        for(int i =st; i<=end;i++){\\n            temp+= stoneValue[i];\\n            if(temp < sum - temp){\\n                ans = max(ans,temp + solve(st,i,stoneValue,dp) );\\n            }else if(temp > sum-temp){\\n                ans = max(ans,sum-temp + solve(i+1,end,stoneValue,dp));\\n            }else{\\n                ans = max( {ans,temp + solve(st,i,stoneValue,dp),sum-temp + solve(i+1,end,stoneValue,dp)});\\n            }\\n        }\\n        return dp[st][end] = ans;\\n    }\\n\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int st = 0;\\n        int end = stoneValue.size();\\n        vector<vector<int>>dp(end+1,vector<int>(end+1,-1));\\n        return solve(st,end-1,stoneValue,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361388,
                "title": "c-soln-rec-dp-memo",
                "content": "# Intuition\\nIntuition is pretty simple if you have done recursion previously it automatically clicks as a partition type problem where you have to try all possible ways.\\n\\nQuestion comes in the implementation part which can be a bit tricky sometimes for some people here is you haven\\'t done a question like this before.Still let me try to explain it to you as best as possible\\n\\n\\n# Approach\\nApproach 1 is obviously recursion\\n(i)We have to thinks of two point the start point of our array and the end point of the array which will be much easier to manipulate rather then making the array small/big by trimming or adding values.\\n(ii)For base case we can think of like when our start point exceeds end point we simply return 0 as no more partition is possible.\\n(iii)Now we have to calculate two sums one for left half and the other for right half.We have to do it for all possible ways and find max out of them.\\n(iv)Lets use prefix sum kind of technique where we add all of elements first and then later we perform n-1 partitions.\\n(v)After finding total sum we do n-1 partitions and add each incoming element once to get left half sum and subtract element from totsum to get right half.\\n(vi)Now we are getting left and rigth half sums.\\n(vii)Simply perform the game 3 conditions\\nCondition 1:left<right take left and add in smaller array with start to index i.This will give one result out of many so take max and store.\\nCondition2:left==right take max of left+rec(start,i) and right+rec(i+1,end).And as left=right you can simply do left+max((start,i),(i+1,end)).\\nCondition 3:left>right take right and add in smalleri+1,end arrayand take max of all possibilities.\\n\\n\\nNow easy return max ans;\\n\\n# Complexity\\n- Time complexity:\\n- for recursion exponential\\nO(N^3) for optimal solution of top down approach\\n\\n- Space complexity:\\n- for memoization it is O(N^2)+ recursive stack space\\nO(N^2) for optimal solution top-down\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // int maxValueAlice(int start,int end,vector<int>& stones,vector<vector<int>>&dp){\\n\\n    //     if(start>end)return 0;\\n    //     int left=0;\\n    //     int right=0;\\n    //     if(dp[start][end]!=-1)return dp[start][end];\\n    //     for(int i=start;i<=end;i++){\\n    //         right+=stones[i];\\n    //     }\\n    //     int ans=0;\\n    //     for(int i=start;i<end;i++){\\n    //         left+=stones[i];\\n    //         right-=stones[i];\\n\\n    //         if(left<right)ans=max(ans,left+maxValueAlice(start,i,stones,dp));\\n    //         //when equal alice decides so we take the path with maximum ans down the line.\\n    //         //we can also so left + max((s,i)and (i+1,e)) because left==right.\\n    //         else if(left==right)ans=max(ans,max(left+maxValueAlice(start,i,stones,dp),\\n    //         right+maxValueAlice(i+1,end,stones,dp)));\\n    //         else if(left>right)ans=max(ans,right+maxValueAlice(i+1,end,stones,dp));\\n    //     }\\n    //     return dp[start][end]=ans;\\n    // }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n=stoneValue.size();\\n        // vector<vector<int>> dp(n,vector<int>(n,-1));\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                if(i>j){\\n                    dp[i][j]=0;\\n                    continue;\\n                }\\n                else{\\n                    int left=0;\\n                    int right=0;\\n                    \\n                    for(int k=i;k<=j;k++){\\n                        right+=stoneValue[k];\\n                    }\\n                    int ans=0;\\n                    for(int k=i;k<j;k++){\\n                        left+=stoneValue[k];\\n                        right-=stoneValue[k];\\n\\n                        if(left<right)ans=max(ans,left+dp[i][k]);\\n                        //when equal alice decides so we take the path with maximum ans down the line.\\n                        //we can also so left + max((s,i)and (i+1,e)) because left==right.\\n                        else if(left==right)ans=max(ans,max(left+dp[i][k],\\n                        right+dp[k+1][j]));\\n                        else if(left>right)ans=max(ans,right+dp[k+1][j]);\\n                    }\\n                     dp[i][j]=ans;\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n        // return maxValueAlice(0,n-1,stoneValue,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // int maxValueAlice(int start,int end,vector<int>& stones,vector<vector<int>>&dp){\\n\\n    //     if(start>end)return 0;\\n    //     int left=0;\\n    //     int right=0;\\n    //     if(dp[start][end]!=-1)return dp[start][end];\\n    //     for(int i=start;i<=end;i++){\\n    //         right+=stones[i];\\n    //     }\\n    //     int ans=0;\\n    //     for(int i=start;i<end;i++){\\n    //         left+=stones[i];\\n    //         right-=stones[i];\\n\\n    //         if(left<right)ans=max(ans,left+maxValueAlice(start,i,stones,dp));\\n    //         //when equal alice decides so we take the path with maximum ans down the line.\\n    //         //we can also so left + max((s,i)and (i+1,e)) because left==right.\\n    //         else if(left==right)ans=max(ans,max(left+maxValueAlice(start,i,stones,dp),\\n    //         right+maxValueAlice(i+1,end,stones,dp)));\\n    //         else if(left>right)ans=max(ans,right+maxValueAlice(i+1,end,stones,dp));\\n    //     }\\n    //     return dp[start][end]=ans;\\n    // }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n=stoneValue.size();\\n        // vector<vector<int>> dp(n,vector<int>(n,-1));\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                if(i>j){\\n                    dp[i][j]=0;\\n                    continue;\\n                }\\n                else{\\n                    int left=0;\\n                    int right=0;\\n                    \\n                    for(int k=i;k<=j;k++){\\n                        right+=stoneValue[k];\\n                    }\\n                    int ans=0;\\n                    for(int k=i;k<j;k++){\\n                        left+=stoneValue[k];\\n                        right-=stoneValue[k];\\n\\n                        if(left<right)ans=max(ans,left+dp[i][k]);\\n                        //when equal alice decides so we take the path with maximum ans down the line.\\n                        //we can also so left + max((s,i)and (i+1,e)) because left==right.\\n                        else if(left==right)ans=max(ans,max(left+dp[i][k],\\n                        right+dp[k+1][j]));\\n                        else if(left>right)ans=max(ans,right+dp[k+1][j]);\\n                    }\\n                     dp[i][j]=ans;\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n        // return maxValueAlice(0,n-1,stoneValue,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341563,
                "title": "o-n-2-top-down-approach",
                "content": "# Intuition\\nDFS+memo\\n\\n# Approach\\nf(i,j) returns (reward, maxLeft, maxRight, mid1,mid2),where mid1 is the max k1 for [i,k1] to ensure smaller(or equal) sum of left interval, mid2 is the min k2 for [k2,j] to ensure smaller(or equal) sum of right interval. In fact mid1+1==mid2 always holds for interval length>=2, this redundancy is for the convenience of coding only\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        prefix = [0]\\n        for x in stoneValue:\\n            prefix.append(prefix[-1]+x)\\n        \\n        @lru_cache(None)\\n        def f(i,j):\\n            if i==j:\\n                return (0,0,0,i-1,j+1)\\n            _, maxLeft, _,mid1,_ = f(i,j-1)\\n            _, _,maxRight,_,mid2 = f(i+1,j)\\n            mid1 += 1\\n            while mid1<j and prefix[mid1]-prefix[i-1]<=prefix[j]-prefix[mid1]:\\n                maxLeft = max(maxLeft,prefix[mid1]-prefix[i-1]+f(i,mid1)[0])\\n                mid1 += 1\\n            mid1 -= 1\\n            mid2 -= 1\\n            while mid2>i and prefix[j]-prefix[mid2-1]<=prefix[mid2-1]-prefix[i-1]:\\n                maxRight = max(maxRight,prefix[j]-prefix[mid2-1]+f(mid2,j)[0])\\n                mid2 -= 1\\n            mid2 += 1\\n            reward = max(maxLeft, maxRight)\\n            return reward,maxLeft,maxRight, mid1,mid2\\n        \\n        return f(1,len(prefix)-1)[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        prefix = [0]\\n        for x in stoneValue:\\n            prefix.append(prefix[-1]+x)\\n        \\n        @lru_cache(None)\\n        def f(i,j):\\n            if i==j:\\n                return (0,0,0,i-1,j+1)\\n            _, maxLeft, _,mid1,_ = f(i,j-1)\\n            _, _,maxRight,_,mid2 = f(i+1,j)\\n            mid1 += 1\\n            while mid1<j and prefix[mid1]-prefix[i-1]<=prefix[j]-prefix[mid1]:\\n                maxLeft = max(maxLeft,prefix[mid1]-prefix[i-1]+f(i,mid1)[0])\\n                mid1 += 1\\n            mid1 -= 1\\n            mid2 -= 1\\n            while mid2>i and prefix[j]-prefix[mid2-1]<=prefix[mid2-1]-prefix[i-1]:\\n                maxRight = max(maxRight,prefix[j]-prefix[mid2-1]+f(mid2,j)[0])\\n                mid2 -= 1\\n            mid2 += 1\\n            reward = max(maxLeft, maxRight)\\n            return reward,maxLeft,maxRight, mid1,mid2\\n        \\n        return f(1,len(prefix)-1)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234991,
                "title": "dp-memo-simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int l,int r,int tot,vector<int>&a,vector<vector<int>>&dp){\\n        if(l==r) return 0;\\n        if(l+1==r) return min(a[l],a[l+1]);\\n        if(dp[l][r]!=-1) return dp[l][r];\\n        int s=0,res=0;\\n        for(int i=l;i<=r;i++){\\n            s=s+a[i];\\n            int x=s;\\n            int y=tot-s;\\n            if(x<y){\\n                res=max(res,x+f(l,i,x,a,dp));\\n            }\\n            else if(x>y){\\n                res=max(res,y+f(i+1,r,y,a,dp));\\n            }\\n            else{\\n                res=max(res,max(x+f(l,i,x,a,dp),y+f(i+1,r,y,a,dp)));\\n            }\\n        }\\n        return dp[l][r]=res;\\n    }\\n    int stoneGameV(vector<int>& stone) {\\n        int sum=0,n=stone.size();\\n        if(n==1) return 0;\\n        vector<int>pre(n+1,0);\\n        for(auto it:stone) sum+=it;\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return f(0,n-1,sum,stone,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int l,int r,int tot,vector<int>&a,vector<vector<int>>&dp){\\n        if(l==r) return 0;\\n        if(l+1==r) return min(a[l],a[l+1]);\\n        if(dp[l][r]!=-1) return dp[l][r];\\n        int s=0,res=0;\\n        for(int i=l;i<=r;i++){\\n            s=s+a[i];\\n            int x=s;\\n            int y=tot-s;\\n            if(x<y){\\n                res=max(res,x+f(l,i,x,a,dp));\\n            }\\n            else if(x>y){\\n                res=max(res,y+f(i+1,r,y,a,dp));\\n            }\\n            else{\\n                res=max(res,max(x+f(l,i,x,a,dp),y+f(i+1,r,y,a,dp)));\\n            }\\n        }\\n        return dp[l][r]=res;\\n    }\\n    int stoneGameV(vector<int>& stone) {\\n        int sum=0,n=stone.size();\\n        if(n==1) return 0;\\n        vector<int>pre(n+1,0);\\n        for(auto it:stone) sum+=it;\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return f(0,n-1,sum,stone,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181461,
                "title": "dp-simple-with-recursion",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n2)$$\\n\\n> just check left and right sum for every point\\n\\n# Code\\n``` \\nclass Solution {\\npublic:\\n    int calc(vector<vector<int>>& dp,vector<int>& stones, int l, int r){\\n        if(l==r) return 0;\\n        if(dp[l][r]!=-1) return dp[l][r];\\n        int ans=INT_MIN;\\n        for(int i=l; i<r; i++){\\n            int leftsum=stones[i]-stones[l-1];\\n            int rightsum=stones[r]-stones[i];\\n            if(leftsum<=rightsum) ans=max(ans,leftsum+calc(dp,stones,l,i));\\n            if(leftsum>=rightsum) ans=max(ans,rightsum+calc(dp,stones,i+1,r));\\n        }\\n        return dp[l][r]=ans;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        stoneValue.insert(stoneValue.begin(),0);\\n        int n=stoneValue.size();\\n        for(int i=1; i<n; i++) stoneValue[i]=stoneValue[i]+stoneValue[i-1];\\n        vector<vector<int>> dp(n, vector<int>(n,-1));\\n        return calc(dp,stoneValue,1,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    int calc(vector<vector<int>>& dp,vector<int>& stones, int l, int r){\\n        if(l==r) return 0;\\n        if(dp[l][r]!=-1) return dp[l][r];\\n        int ans=INT_MIN;\\n        for(int i=l; i<r; i++){\\n            int leftsum=stones[i]-stones[l-1];\\n            int rightsum=stones[r]-stones[i];\\n            if(leftsum<=rightsum) ans=max(ans,leftsum+calc(dp,stones,l,i));\\n            if(leftsum>=rightsum) ans=max(ans,rightsum+calc(dp,stones,i+1,r));\\n        }\\n        return dp[l][r]=ans;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        stoneValue.insert(stoneValue.begin(),0);\\n        int n=stoneValue.size();\\n        for(int i=1; i<n; i++) stoneValue[i]=stoneValue[i]+stoneValue[i-1];\\n        vector<vector<int>> dp(n, vector<int>(n,-1));\\n        return calc(dp,stoneValue,1,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171103,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn stone_game_v(stone_value: Vec<i32>) -> i32 {\\n        let mut dp = vec![vec![0; stone_value.len()]; stone_value.len()];\\n        let mut sum = vec![0; stone_value.len() + 1];\\n        for i in 0..stone_value.len() {\\n            sum[i + 1] = sum[i] + stone_value[i];\\n        }\\n        for i in (0..stone_value.len()).rev() {\\n            for j in i + 1..stone_value.len() {\\n                for k in i..j {\\n                    let left = sum[k + 1] - sum[i];\\n                    let right = sum[j + 1] - sum[k + 1];\\n                    match left.cmp(&right) {\\n                        std::cmp::Ordering::Less => {\\n                            dp[i][j] = dp[i][j].max(dp[i][k] + left);\\n                        }\\n                        std::cmp::Ordering::Greater => {\\n                            dp[i][j] = dp[i][j].max(dp[k + 1][j] + right);\\n                        }\\n                        std::cmp::Ordering::Equal => {\\n                            dp[i][j] = dp[i][j].max(dp[i][k] + left);\\n                            dp[i][j] = dp[i][j].max(dp[k + 1][j] + right);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        dp[0][stone_value.len() - 1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn stone_game_v(stone_value: Vec<i32>) -> i32 {\\n        let mut dp = vec![vec![0; stone_value.len()]; stone_value.len()];\\n        let mut sum = vec![0; stone_value.len() + 1];\\n        for i in 0..stone_value.len() {\\n            sum[i + 1] = sum[i] + stone_value[i];\\n        }\\n        for i in (0..stone_value.len()).rev() {\\n            for j in i + 1..stone_value.len() {\\n                for k in i..j {\\n                    let left = sum[k + 1] - sum[i];\\n                    let right = sum[j + 1] - sum[k + 1];\\n                    match left.cmp(&right) {\\n                        std::cmp::Ordering::Less => {\\n                            dp[i][j] = dp[i][j].max(dp[i][k] + left);\\n                        }\\n                        std::cmp::Ordering::Greater => {\\n                            dp[i][j] = dp[i][j].max(dp[k + 1][j] + right);\\n                        }\\n                        std::cmp::Ordering::Equal => {\\n                            dp[i][j] = dp[i][j].max(dp[i][k] + left);\\n                            dp[i][j] = dp[i][j].max(dp[k + 1][j] + right);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        dp[0][stone_value.len() - 1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3118500,
                "title": "c-simple-dp-and-prefix-sum-o-n-3",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &dp, vector<int> &stoneValue,vector<vector<int>> &sum, int i, int j)\\n    {\\n        int n = stoneValue.size(), ans =0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(i==j)return dp[i][j]=0;\\n        for(int k=i;k<j;k++)\\n        {\\n            if(sum[i][k] > sum[k+1][j])ans = max(ans, sum[k+1][j] + solve(dp,stoneValue, sum, k+1, j));\\n            else if(sum[i][k] < sum[k+1][j])ans = max(ans, sum[i][k] + solve(dp,stoneValue, sum, i,k));\\n            else ans = max({ans, sum[i][k] + solve(dp,stoneValue, sum, i,k),  sum[i][k] + solve(dp,stoneValue, sum, k+1, j)});\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size();\\n        vector<vector<int>> sum(n, vector<int>(n,0));\\n        vector<vector<int>> dp(n, vector<int>(n,-1));\\n        vector<int> pref(n+1,0);\\n        pref[1]=stoneValue[0];\\n        for(int i=1;i<n;i++)pref[i+1]=pref[i]+stoneValue[i];\\n        for(int i=0;i<n;i++)\\n            for(int j=i;j<n;j++)\\n                sum[i][j]=pref[j+1]-pref[i];\\n        return solve(dp, stoneValue, sum, 0, n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &dp, vector<int> &stoneValue,vector<vector<int>> &sum, int i, int j)\\n    {\\n        int n = stoneValue.size(), ans =0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(i==j)return dp[i][j]=0;\\n        for(int k=i;k<j;k++)\\n        {\\n            if(sum[i][k] > sum[k+1][j])ans = max(ans, sum[k+1][j] + solve(dp,stoneValue, sum, k+1, j));\\n            else if(sum[i][k] < sum[k+1][j])ans = max(ans, sum[i][k] + solve(dp,stoneValue, sum, i,k));\\n            else ans = max({ans, sum[i][k] + solve(dp,stoneValue, sum, i,k),  sum[i][k] + solve(dp,stoneValue, sum, k+1, j)});\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size();\\n        vector<vector<int>> sum(n, vector<int>(n,0));\\n        vector<vector<int>> dp(n, vector<int>(n,-1));\\n        vector<int> pref(n+1,0);\\n        pref[1]=stoneValue[0];\\n        for(int i=1;i<n;i++)pref[i+1]=pref[i]+stoneValue[i];\\n        for(int i=0;i<n;i++)\\n            for(int j=i;j<n;j++)\\n                sum[i][j]=pref[j+1]-pref[i];\\n        return solve(dp, stoneValue, sum, 0, n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096853,
                "title": "top-down-and-bottom-up-dp-java",
                "content": "# Intuition\\nthe same idea with [1140. Stone Game II](https://leetcode.com/problems/stone-game-ii/solutions/3096779/top-down-dp-recursion-with-memoization/?orderBy=most_votes) , we\\'ll use memoization.\\n\\ndp[i][j] means the max stoneValue of we can get picking from stone[i] to stones[j] \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n    private int[][] memoi;\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n\\n        int[] prefixSum = new int[n+1];\\n        for (int i = 0; i < n; i++) \\n            prefixSum[i+1] = prefixSum[i] + stoneValue[i];\\n        \\n        memoi = new int[n][n];\\n        return maxStone(prefixSum, 0, n-1);\\n    }\\n\\n    private int maxStone(int[] prefixSum, int left, int right) {\\n        int ans = 0;\\n        if (left >= right) return 0;\\n        if (memoi[left][right] != 0) return memoi[left][right];\\n\\n        for (int i = left; i < right; i++) {\\n            int frontSum = prefixSum[i+1] - prefixSum[left];\\n            int rearSum = prefixSum[right+1] - prefixSum[i+1];\\n            int curSum = 0;\\n            if (frontSum > rearSum) {\\n                curSum += rearSum;\\n                curSum += maxStone(prefixSum, i+1, right);\\n            }\\n            else if (frontSum < rearSum){\\n                curSum += frontSum;\\n                curSum += maxStone(prefixSum, left, i);\\n            } else {\\n                curSum += frontSum;\\n                curSum += Math.max(maxStone(prefixSum, i+1, right), maxStone(prefixSum, left, i));\\n            }\\n            ans = Math.max(ans, curSum);\\n        }\\n        return memoi[left][right] = ans;\\n    }\\n}\\n```\\n\\n# bottom-up DP\\n```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n\\n        int[] prefixSum = new int[n+1];\\n        for (int i = 0; i < n; i++) \\n            prefixSum[i+1] = prefixSum[i] + stoneValue[i];\\n        \\n        int[][] dp = new int[n][n];\\n        for (int l = 2; l <= n; l++) {\\n            for (int i = 0; l + i - 1 < n; i++) {\\n                int j = l + i - 1;\\n                for (int k = i; k < j; k++) {\\n                    int curSum = 0;\\n                    int frontSum = prefixSum[k+1] - prefixSum[i];\\n                    int rearSum = prefixSum[j+1] - prefixSum[k+1];\\n                    if (frontSum < rearSum) {\\n                        curSum += frontSum + dp[i][k];\\n                    } else if (rearSum < frontSum) {\\n                        curSum += rearSum + dp[k+1][j];\\n                    } else {\\n                        curSum += rearSum + Math.max(dp[i][k], dp[k+1][j]);\\n                    }\\n                    dp[i][j] = Math.max(dp[i][j], curSum); \\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private int[][] memoi;\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n\\n        int[] prefixSum = new int[n+1];\\n        for (int i = 0; i < n; i++) \\n            prefixSum[i+1] = prefixSum[i] + stoneValue[i];\\n        \\n        memoi = new int[n][n];\\n        return maxStone(prefixSum, 0, n-1);\\n    }\\n\\n    private int maxStone(int[] prefixSum, int left, int right) {\\n        int ans = 0;\\n        if (left >= right) return 0;\\n        if (memoi[left][right] != 0) return memoi[left][right];\\n\\n        for (int i = left; i < right; i++) {\\n            int frontSum = prefixSum[i+1] - prefixSum[left];\\n            int rearSum = prefixSum[right+1] - prefixSum[i+1];\\n            int curSum = 0;\\n            if (frontSum > rearSum) {\\n                curSum += rearSum;\\n                curSum += maxStone(prefixSum, i+1, right);\\n            }\\n            else if (frontSum < rearSum){\\n                curSum += frontSum;\\n                curSum += maxStone(prefixSum, left, i);\\n            } else {\\n                curSum += frontSum;\\n                curSum += Math.max(maxStone(prefixSum, i+1, right), maxStone(prefixSum, left, i));\\n            }\\n            ans = Math.max(ans, curSum);\\n        }\\n        return memoi[left][right] = ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n\\n        int[] prefixSum = new int[n+1];\\n        for (int i = 0; i < n; i++) \\n            prefixSum[i+1] = prefixSum[i] + stoneValue[i];\\n        \\n        int[][] dp = new int[n][n];\\n        for (int l = 2; l <= n; l++) {\\n            for (int i = 0; l + i - 1 < n; i++) {\\n                int j = l + i - 1;\\n                for (int k = i; k < j; k++) {\\n                    int curSum = 0;\\n                    int frontSum = prefixSum[k+1] - prefixSum[i];\\n                    int rearSum = prefixSum[j+1] - prefixSum[k+1];\\n                    if (frontSum < rearSum) {\\n                        curSum += frontSum + dp[i][k];\\n                    } else if (rearSum < frontSum) {\\n                        curSum += rearSum + dp[k+1][j];\\n                    } else {\\n                        curSum += rearSum + Math.max(dp[i][k], dp[k+1][j]);\\n                    }\\n                    dp[i][j] = Math.max(dp[i][j], curSum); \\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987068,
                "title": "c-solution-using-dp-and-prefix-sum-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& stoneValue, int lo, int hi, vector<int>& prefixSum, vector<vector<int>>& dp) {\\n        \\n        // Base Case\\n        if(lo >= hi) {\\n            return 0;\\n        }\\n        if(dp[lo][hi] != -1) {\\n            return dp[lo][hi];\\n        }\\n       \\n        // Recursive Case\\n        int ans = 0;\\n        \\n        // Iterating to get all the possible values of partition.\\n        for(int j = lo; j < hi; j++) {\\n            int mid = j, currAns = 0;\\n            \\n            // Getting the leftSum and rightSum using the prefixSum array.\\n            int leftSum = prefixSum[mid] - prefixSum[lo - 1], rightSum = prefixSum[hi] - prefixSum[mid];\\n            \\n            // If Left Sum is greater, then Bob throws away the left row.\\n            if(leftSum > rightSum) {\\n                currAns = rightSum + helper(stoneValue, mid + 1, hi, prefixSum, dp);\\n            } \\n            \\n            // If Right Sum is greater, then Bob throws away the right row.\\n            else if(leftSum < rightSum){\\n                currAns = leftSum + helper(stoneValue, lo, mid, prefixSum, dp);\\n            }\\n            \\n            // If both are equal then check for both the left row and the right row and take which ever returns the maximum sum.\\n            else {\\n                int takenLeft = leftSum + helper(stoneValue, lo, mid, prefixSum, dp);\\n                int takenRight = rightSum + helper(stoneValue, mid + 1, hi, prefixSum, dp);\\n                currAns = max(takenLeft, takenRight);\\n            }\\n            ans = max(ans, currAns);\\n        }\\n        return dp[lo][hi] = ans;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        vector<int>prefixSum;\\n        prefixSum.push_back(0);\\n        \\n        // PrefixSum array\\n        for(int i = 0; i < stoneValue.size(); i++) {\\n            prefixSum.push_back(prefixSum.back() + stoneValue[i]);\\n        }\\n        vector<vector<int>>dp(stoneValue.size() + 1, vector<int>(stoneValue.size() + 1, -1));\\n        return helper(stoneValue, 1, stoneValue.size(), prefixSum, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& stoneValue, int lo, int hi, vector<int>& prefixSum, vector<vector<int>>& dp) {\\n        \\n        // Base Case\\n        if(lo >= hi) {\\n            return 0;\\n        }\\n        if(dp[lo][hi] != -1) {\\n            return dp[lo][hi];\\n        }\\n       \\n        // Recursive Case\\n        int ans = 0;\\n        \\n        // Iterating to get all the possible values of partition.\\n        for(int j = lo; j < hi; j++) {\\n            int mid = j, currAns = 0;\\n            \\n            // Getting the leftSum and rightSum using the prefixSum array.\\n            int leftSum = prefixSum[mid] - prefixSum[lo - 1], rightSum = prefixSum[hi] - prefixSum[mid];\\n            \\n            // If Left Sum is greater, then Bob throws away the left row.\\n            if(leftSum > rightSum) {\\n                currAns = rightSum + helper(stoneValue, mid + 1, hi, prefixSum, dp);\\n            } \\n            \\n            // If Right Sum is greater, then Bob throws away the right row.\\n            else if(leftSum < rightSum){\\n                currAns = leftSum + helper(stoneValue, lo, mid, prefixSum, dp);\\n            }\\n            \\n            // If both are equal then check for both the left row and the right row and take which ever returns the maximum sum.\\n            else {\\n                int takenLeft = leftSum + helper(stoneValue, lo, mid, prefixSum, dp);\\n                int takenRight = rightSum + helper(stoneValue, mid + 1, hi, prefixSum, dp);\\n                currAns = max(takenLeft, takenRight);\\n            }\\n            ans = max(ans, currAns);\\n        }\\n        return dp[lo][hi] = ans;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        vector<int>prefixSum;\\n        prefixSum.push_back(0);\\n        \\n        // PrefixSum array\\n        for(int i = 0; i < stoneValue.size(); i++) {\\n            prefixSum.push_back(prefixSum.back() + stoneValue[i]);\\n        }\\n        vector<vector<int>>dp(stoneValue.size() + 1, vector<int>(stoneValue.size() + 1, -1));\\n        return helper(stoneValue, 1, stoneValue.size(), prefixSum, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981499,
                "title": "prefix-sum-recursion-memorization-dp",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    int dp[501][501];\\n    int solve(int i,int j,vector<int> &pref){\\n        if(j-i == 0) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int maxi = 0;\\n        for(int l=i;l<j;l++){\\n            int l_sum = pref[l] - (i-1 >= 0 ? pref[i-1] : 0);\\n            int r_sum = pref[j] - pref[l];\\n            if(l_sum == r_sum){\\n                maxi = max(maxi,l_sum + max(solve(i,l,pref), solve(l+1,j,pref)));\\n            }else if(l_sum > r_sum){\\n                maxi = max(maxi,r_sum + solve(l+1,j,pref));\\n            }else{\\n                maxi = max(maxi,l_sum + solve(i,l,pref));\\n            }\\n        }\\n\\n        return dp[i][j] = maxi;\\n    }\\npublic:\\n    int stoneGameV(vector<int>& s) {\\n        int prev = 0;\\n        for(auto &e : s){\\n            prev += e;\\n            e = prev;\\n        }\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,s.size()-1,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[501][501];\\n    int solve(int i,int j,vector<int> &pref){\\n        if(j-i == 0) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int maxi = 0;\\n        for(int l=i;l<j;l++){\\n            int l_sum = pref[l] - (i-1 >= 0 ? pref[i-1] : 0);\\n            int r_sum = pref[j] - pref[l];\\n            if(l_sum == r_sum){\\n                maxi = max(maxi,l_sum + max(solve(i,l,pref), solve(l+1,j,pref)));\\n            }else if(l_sum > r_sum){\\n                maxi = max(maxi,r_sum + solve(l+1,j,pref));\\n            }else{\\n                maxi = max(maxi,l_sum + solve(i,l,pref));\\n            }\\n        }\\n\\n        return dp[i][j] = maxi;\\n    }\\npublic:\\n    int stoneGameV(vector<int>& s) {\\n        int prev = 0;\\n        for(auto &e : s){\\n            prev += e;\\n            e = prev;\\n        }\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,s.size()-1,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894205,
                "title": "c-detailed-solution-related-to-questions-you-solved-previously",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry to relate the problem to the problems you solved previously .\\nafter seeing constraint you will realise that it matches wih matrix chain multiplication\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nsame as matrix chain multiplication O(N* N * N) ;\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*N + N ) (N = 505 ) for dp array and prefix array \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[505][505] ;\\n    int prefix[505] ;\\n    int cal_prefix(int st , int ed ){\\n        if(st != 0 ) return prefix[ed]-prefix[st-1] ;\\n        return prefix[ed] ;\\n    }\\n\\n    int solve(int st , int ed  ){\\n        if(st == ed ){\\n            return 0 ; \\n        }\\n        if(dp[st][ed] != -1 ) return dp[st][ed] ;\\n\\n        int ans = 0 ; \\n        for(int i = st ; i< ed ; ++i ){\\n            int t1 = cal_prefix(st , i ) ;\\n            int t2 = cal_prefix(i+1 , ed ) ;\\n            if(t1 >= t2 ){\\n                int t = solve(i+1 , ed  ) ;\\n                ans = max(ans , t + t2 ) ; \\n            }\\n            if(t2 >= t1 ){\\n                int t = solve(st , i  ) ;\\n                ans = max(ans , t + t1 ) ;\\n            }\\n        }\\n        dp[st][ed] = ans ; \\n        return ans ; \\n    }\\n\\n    int stoneGameV(vector<int>& nums ) {\\n        memset(dp , -1 , sizeof(dp)) ;\\n        prefix[0] = nums[0] ;\\n        int n = nums.size() ;\\n        for(int i = 1 ; i< n ; ++i ){\\n            prefix[i] = prefix[i-1] + nums[i] ;\\n        } \\n        return solve(0 , nums.size()-1 ) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[505][505] ;\\n    int prefix[505] ;\\n    int cal_prefix(int st , int ed ){\\n        if(st != 0 ) return prefix[ed]-prefix[st-1] ;\\n        return prefix[ed] ;\\n    }\\n\\n    int solve(int st , int ed  ){\\n        if(st == ed ){\\n            return 0 ; \\n        }\\n        if(dp[st][ed] != -1 ) return dp[st][ed] ;\\n\\n        int ans = 0 ; \\n        for(int i = st ; i< ed ; ++i ){\\n            int t1 = cal_prefix(st , i ) ;\\n            int t2 = cal_prefix(i+1 , ed ) ;\\n            if(t1 >= t2 ){\\n                int t = solve(i+1 , ed  ) ;\\n                ans = max(ans , t + t2 ) ; \\n            }\\n            if(t2 >= t1 ){\\n                int t = solve(st , i  ) ;\\n                ans = max(ans , t + t1 ) ;\\n            }\\n        }\\n        dp[st][ed] = ans ; \\n        return ans ; \\n    }\\n\\n    int stoneGameV(vector<int>& nums ) {\\n        memset(dp , -1 , sizeof(dp)) ;\\n        prefix[0] = nums[0] ;\\n        int n = nums.size() ;\\n        for(int i = 1 ; i< n ; ++i ){\\n            prefix[i] = prefix[i-1] + nums[i] ;\\n        } \\n        return solve(0 , nums.size()-1 ) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725687,
                "title": "c-dynamic-programming-o-n-n-n-time-o-n-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& a) \\n    {\\n        int n = a.size();\\n\\n        int pfsum[n]; pfsum[0] = a[0];\\n        for(int i = 1; i < n; i++)\\n            pfsum[i] = pfsum[i - 1] + a[i];\\n\\n        int dp[n][n];\\n        memset(&dp, 0x00, sizeof(dp));\\n\\n        for(int i  = 0; i < n; i++)\\n        {\\n            if(i + 1 >= n) continue;\\n            dp[i][i + 1] = min(a[i], a[i + 1]);\\n        }\\n        \\n        for(int c = 2; c < n; c++)\\n        {\\n            int i = 0;\\n            int j = c;\\n\\n            while(i < n && j < n)\\n            {\\n                for(int k = i; k < j; k++)\\n                {\\n                    int lsum = (i) ? pfsum[k] - pfsum[i - 1] : pfsum[k]; //a[i ..... k]\\n                    int rsum = pfsum[j] - pfsum[k]; // a[k + 1 ...... j]\\n\\n                    if(lsum < rsum)\\n                    {   \\n                        dp[i][j] = max(dp[i][j], lsum + dp[i][k]);\\n                    }\\n                    else if(rsum < lsum)\\n                    {\\n                        dp[i][j] = max(dp[i][j], rsum + dp[k + 1][j]);\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = max(dp[i][j], lsum + dp[i][k]);\\n                        dp[i][j] = max(dp[i][j], rsum + dp[k + 1][j]);\\n                    }\\n\\n\\n                }\\n\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return dp[0][n - 1];\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& a) \\n    {\\n        int n = a.size();\\n\\n        int pfsum[n]; pfsum[0] = a[0];\\n        for(int i = 1; i < n; i++)\\n            pfsum[i] = pfsum[i - 1] + a[i];\\n\\n        int dp[n][n];\\n        memset(&dp, 0x00, sizeof(dp));\\n\\n        for(int i  = 0; i < n; i++)\\n        {\\n            if(i + 1 >= n) continue;\\n            dp[i][i + 1] = min(a[i], a[i + 1]);\\n        }\\n        \\n        for(int c = 2; c < n; c++)\\n        {\\n            int i = 0;\\n            int j = c;\\n\\n            while(i < n && j < n)\\n            {\\n                for(int k = i; k < j; k++)\\n                {\\n                    int lsum = (i) ? pfsum[k] - pfsum[i - 1] : pfsum[k]; //a[i ..... k]\\n                    int rsum = pfsum[j] - pfsum[k]; // a[k + 1 ...... j]\\n\\n                    if(lsum < rsum)\\n                    {   \\n                        dp[i][j] = max(dp[i][j], lsum + dp[i][k]);\\n                    }\\n                    else if(rsum < lsum)\\n                    {\\n                        dp[i][j] = max(dp[i][j], rsum + dp[k + 1][j]);\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = max(dp[i][j], lsum + dp[i][k]);\\n                        dp[i][j] = max(dp[i][j], rsum + dp[k + 1][j]);\\n                    }\\n\\n\\n                }\\n\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return dp[0][n - 1];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721208,
                "title": "python-dp-tc-o-n-3-sc-o-n-2-always-got-tle-but-can-reach-100-in-javascript",
                "content": "the following is my code:\\n```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n      n = len(stoneValue)\\n      prefix = [0]\\n      total = 0\\n      for val in stoneValue:\\n        total += val\\n        prefix.append(total)\\n      \\n      @lru_cache(None)\\n      def dfs(left, right):\\n        if left == right:\\n          return 0\\n        \\n        result = 0\\n        sum_r = prefix[right + 1] - prefix[left]\\n        sum_l = 0\\n        for i in range(left, right):\\n          sum_l += stoneValue[i]\\n          sum_r -= stoneValue[i]\\n          if sum_l > sum_r:\\n            result = max(result, sum_r + dfs(i + 1, right))\\n          elif sum_l < sum_r:\\n            result = max(result, sum_l + dfs(left, i))\\n          else:\\n            result = max(result, sum_r + dfs(i + 1, right), sum_l + dfs(left, i))\\n        return result\\n      \\n      return dfs(0, n - 1)\\n```\\n\\nalways got TLE in python, but when I rewrite the code to javascript, I got this:\\n![image](https://assets.leetcode.com/users/images/93591689-19b6-49d2-8b75-f3aa71938536_1666166863.97619.png)\\n\\nHow can be so huge difference between different languages? Shouldn\\'t this be considered a system problem? How can I report this?",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n      n = len(stoneValue)\\n      prefix = [0]\\n      total = 0\\n      for val in stoneValue:\\n        total += val\\n        prefix.append(total)\\n      \\n      @lru_cache(None)\\n      def dfs(left, right):\\n        if left == right:\\n          return 0\\n        \\n        result = 0\\n        sum_r = prefix[right + 1] - prefix[left]\\n        sum_l = 0\\n        for i in range(left, right):\\n          sum_l += stoneValue[i]\\n          sum_r -= stoneValue[i]\\n          if sum_l > sum_r:\\n            result = max(result, sum_r + dfs(i + 1, right))\\n          elif sum_l < sum_r:\\n            result = max(result, sum_l + dfs(left, i))\\n          else:\\n            result = max(result, sum_r + dfs(i + 1, right), sum_l + dfs(left, i))\\n        return result\\n      \\n      return dfs(0, n - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709223,
                "title": "python-o-n-2-dp-solution-faster-than-100-1399ms",
                "content": "```\\n\\'\\'\\'\\nSuppose we know the k\\' for stones[i..j], what do we know about k\\' for stones[i..j+1]? It is either the same or it got shifted a few places to the right.\\nAnd so if we calculate dp values in the order: dp[i][i], dp[i][i+1], dp[i][i+2], ..., dp[i][j], we can essentially keep track of k\\' as we go within that same linear time bound.\\n\\nUsing this idea, we implement the final solution. Couple of pointers about my code:\\n\\n1) mid: represents k\\' or first index such that left half >= right half\\n2) with i < j, max[i][j] represents left[i][j] of previous solution i.e. max(dp[i][i], dp[i][i+1], dp[i][i+2] .. dp[i][j]) and max[j][i] represents right[i][j] of previous solution i.e. max(dp[i][j], dp[i+1][j], dp[i+2][j] .. dp[j][j]). We could have used two different arrays left and right just like previous solution but this trick saves space.\\n3) I am traversing in the order: dp[j][j], dp[j-1,j], dp[j-2, j], .., dp[i][j] instead of the above mentioned order but the idea remains same.\\n\\'\\'\\'\\n\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        sz = len(stoneValue)\\n        dp, maxScore = [[0] * sz for _ in range(sz)], [[0] * sz for _ in range(sz)]\\n        for i in range(sz):\\n            maxScore[i][i] = stoneValue[i]\\n        for j in range(1, sz):\\n            mid, sm, rightHalf = j, stoneValue[j], 0\\n            for i in range(j - 1, -1, -1):\\n                sm += stoneValue[i]\\n                while (rightHalf + stoneValue[mid]) * 2 <= sm:\\n                    rightHalf += stoneValue[mid]\\n                    mid -= 1\\n                dp[i][j] = maxScore[i][mid] if rightHalf * 2 == sm else (0 if mid == i else maxScore[i][mid - 1]);\\n                dp[i][j] = max(dp[i][j], 0 if mid == j else maxScore[j][mid + 1])\\n                maxScore[i][j] = max(maxScore[i][j - 1], dp[i][j] + sm);\\n                maxScore[j][i] = max(maxScore[j][i + 1], dp[i][j] + sm);\\n        return dp[0][sz - 1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\'\\'\\'\\nSuppose we know the k\\' for stones[i..j], what do we know about k\\' for stones[i..j+1]? It is either the same or it got shifted a few places to the right.\\nAnd so if we calculate dp values in the order: dp[i][i], dp[i][i+1], dp[i][i+2], ..., dp[i][j], we can essentially keep track of k\\' as we go within that same linear time bound.\\n\\nUsing this idea, we implement the final solution. Couple of pointers about my code:\\n\\n1) mid: represents k\\' or first index such that left half >= right half\\n2) with i < j, max[i][j] represents left[i][j] of previous solution i.e. max(dp[i][i], dp[i][i+1], dp[i][i+2] .. dp[i][j]) and max[j][i] represents right[i][j] of previous solution i.e. max(dp[i][j], dp[i+1][j], dp[i+2][j] .. dp[j][j]). We could have used two different arrays left and right just like previous solution but this trick saves space.\\n3) I am traversing in the order: dp[j][j], dp[j-1,j], dp[j-2, j], .., dp[i][j] instead of the above mentioned order but the idea remains same.\\n\\'\\'\\'\\n\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        sz = len(stoneValue)\\n        dp, maxScore = [[0] * sz for _ in range(sz)], [[0] * sz for _ in range(sz)]\\n        for i in range(sz):\\n            maxScore[i][i] = stoneValue[i]\\n        for j in range(1, sz):\\n            mid, sm, rightHalf = j, stoneValue[j], 0\\n            for i in range(j - 1, -1, -1):\\n                sm += stoneValue[i]\\n                while (rightHalf + stoneValue[mid]) * 2 <= sm:\\n                    rightHalf += stoneValue[mid]\\n                    mid -= 1\\n                dp[i][j] = maxScore[i][mid] if rightHalf * 2 == sm else (0 if mid == i else maxScore[i][mid - 1]);\\n                dp[i][j] = max(dp[i][j], 0 if mid == j else maxScore[j][mid + 1])\\n                maxScore[i][j] = max(maxScore[i][j - 1], dp[i][j] + sm);\\n                maxScore[j][i] = max(maxScore[j][i + 1], dp[i][j] + sm);\\n        return dp[0][sz - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702278,
                "title": "c-dp-memoization-easy-to-understand-code",
                "content": "```\\nclass Solution {\\n    int help(vector<int> &row , int rowsum , int i , int j , vector<vector<int>> &dp)\\n    {\\n        if(i == j) return 0;\\n        if(dp[i][j] != INT_MIN) return dp[i][j];\\n        int curr_sum = 0;   //maintains the sum of the current partitioned row.\\n        int score;\\n        int ans = 0;\\n        for(int k = i ; k < j ; k++)    //for partitioning the row\\n        {\\n            curr_sum += row[k];\\n\\t\\t\\tint sum1 = curr_sum;     //sum of partition 1\\n            int sum2 = rowsum-sum1;     //sum of partition 2\\n            if(sum1 > sum2)\\n               score = sum2 + help(row , sum2 , k+1 , j , dp);\\n            else if(sum1 < sum2)\\n                score = sum1 + help(row , sum1 , i , k , dp);\\n            else\\n                score = max(sum1 + help(row , sum1 , i , k , dp) , sum2 + help(row , sum2 , k+1 , j , dp));\\n            ans = max(ans , score);\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int sum = accumulate(stoneValue.begin(), stoneValue.end(), 0);\\n        vector<vector<int>> dp(stoneValue.size() + 1 , vector<int>(stoneValue.size() + 1 , INT_MIN));\\n        return help(stoneValue , sum , 0 , stoneValue.size() - 1 , dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int help(vector<int> &row , int rowsum , int i , int j , vector<vector<int>> &dp)\\n    {\\n        if(i == j) return 0;\\n        if(dp[i][j] != INT_MIN) return dp[i][j];\\n        int curr_sum = 0;   //maintains the sum of the current partitioned row.\\n        int score;\\n        int ans = 0;\\n        for(int k = i ; k < j ; k++)    //for partitioning the row\\n        {\\n            curr_sum += row[k];\\n\\t\\t\\tint sum1 = curr_sum;     //sum of partition 1\\n            int sum2 = rowsum-sum1;     //sum of partition 2\\n            if(sum1 > sum2)\\n               score = sum2 + help(row , sum2 , k+1 , j , dp);\\n            else if(sum1 < sum2)\\n                score = sum1 + help(row , sum1 , i , k , dp);\\n            else\\n                score = max(sum1 + help(row , sum1 , i , k , dp) , sum2 + help(row , sum2 , k+1 , j , dp));\\n            ans = max(ans , score);\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int sum = accumulate(stoneValue.begin(), stoneValue.end(), 0);\\n        vector<vector<int>> dp(stoneValue.size() + 1 , vector<int>(stoneValue.size() + 1 , INT_MIN));\\n        return help(stoneValue , sum , 0 , stoneValue.size() - 1 , dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699121,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} stoneValue\\n * @return {number}\\n */\\nvar stoneGameV = function(stoneValue) {\\n\\n    let length = stoneValue.length\\n    let totalSum = 0\\n\\n    stoneValue.forEach(num => {\\n        totalSum = totalSum + num //25\\n    })\\nlet dp = Array(stoneValue.length).fill().map(() => Array(stoneValue.length).fill(0));\\n    function calculate(totalSum, left, right, score) {\\n        if(dp[left][right]) return dp[left][right]\\n        let leftSum = 0\\n        let curr_score = 0\\n\\n        if (left === right) {\\n            return 0\\n        }\\n        for (let i = left; i < right; i++) {\\n            leftSum = leftSum + stoneValue[i]\\n            let rightSum = totalSum - leftSum\\n\\n            if (leftSum < rightSum) {\\n                curr_score = Math.max(curr_score, leftSum + calculate(leftSum, left, i))\\n            } else if (leftSum > rightSum) {\\n                curr_score = Math.max(curr_score, rightSum + calculate(rightSum, i + 1, right))\\n            } else {\\n                curr_score = Math.max(curr_score, leftSum + calculate(leftSum, left, i, score + leftSum), rightSum + calculate(rightSum, i + 1, right))\\n            }\\n        }\\n        dp[left][right]= curr_score\\n        return curr_score\\n    }\\n\\n    return calculate(totalSum, 0, length - 1, 0)\\n\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} stoneValue\\n * @return {number}\\n */\\nvar stoneGameV = function(stoneValue) {\\n\\n    let length = stoneValue.length\\n    let totalSum = 0\\n\\n    stoneValue.forEach(num => {\\n        totalSum = totalSum + num //25\\n    })\\nlet dp = Array(stoneValue.length).fill().map(() => Array(stoneValue.length).fill(0));\\n    function calculate(totalSum, left, right, score) {\\n        if(dp[left][right]) return dp[left][right]\\n        let leftSum = 0\\n        let curr_score = 0\\n\\n        if (left === right) {\\n            return 0\\n        }\\n        for (let i = left; i < right; i++) {\\n            leftSum = leftSum + stoneValue[i]\\n            let rightSum = totalSum - leftSum\\n\\n            if (leftSum < rightSum) {\\n                curr_score = Math.max(curr_score, leftSum + calculate(leftSum, left, i))\\n            } else if (leftSum > rightSum) {\\n                curr_score = Math.max(curr_score, rightSum + calculate(rightSum, i + 1, right))\\n            } else {\\n                curr_score = Math.max(curr_score, leftSum + calculate(leftSum, left, i, score + leftSum), rightSum + calculate(rightSum, i + 1, right))\\n            }\\n        }\\n        dp[left][right]= curr_score\\n        return curr_score\\n    }\\n\\n    return calculate(totalSum, 0, length - 1, 0)\\n\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2604189,
                "title": "cpp-memoization",
                "content": "```\\nint f(int i, int j, vector<int> &x, vector<vector<int>> &dp)\\n{\\n    if (i==j)return 0;\\n    if (dp[i][j]!=-1) return dp[i][j];\\n    int k,ans=0,ss=0,su=0;\\n    for(k=i;k<=j;k++) su+=x[k];\\n    for(k=i;k<j;k++)\\n    {\\n        ss+=x[k];\\n        if (ss>su-ss)\\n        ans=max(ans,f(k+1,j,x,dp)+su-ss);\\n        else if (ss<su-ss)\\n            ans=max(ans,f(i,k,x,dp)+ss);\\n        else\\n            ans=max(max(ans,f(i,k,x,dp)+ss),f(k+1,j,x,dp)+su-ss);\\n    }\\n    dp[i][j]=ans;\\n    return ans;\\n}\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& x) {\\n        int n=x.size();\\n        vector<vector<int>> dp;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> z;\\n            for(int j=0;j<n;j++)\\n                z.push_back(-1);\\n            dp.push_back(z);\\n        }\\n        return f(0,n-1,x,dp);   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint f(int i, int j, vector<int> &x, vector<vector<int>> &dp)\\n{\\n    if (i==j)return 0;\\n    if (dp[i][j]!=-1) return dp[i][j];\\n    int k,ans=0,ss=0,su=0;\\n    for(k=i;k<=j;k++) su+=x[k];\\n    for(k=i;k<j;k++)\\n    {\\n        ss+=x[k];\\n        if (ss>su-ss)\\n        ans=max(ans,f(k+1,j,x,dp)+su-ss);\\n        else if (ss<su-ss)\\n            ans=max(ans,f(i,k,x,dp)+ss);\\n        else\\n            ans=max(max(ans,f(i,k,x,dp)+ss),f(k+1,j,x,dp)+su-ss);\\n    }\\n    dp[i][j]=ans;\\n    return ans;\\n}\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& x) {\\n        int n=x.size();\\n        vector<vector<int>> dp;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> z;\\n            for(int j=0;j<n;j++)\\n                z.push_back(-1);\\n            dp.push_back(z);\\n        }\\n        return f(0,n-1,x,dp);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517525,
                "title": "cpp-mcm-variation-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int memo[501][501];  // array for memoization\\n    int mcm(vector<int> &vec,int i,int j){\\n        if(j<=i) return 0; // basically we have one element left thus return 0\\n        if(memo[i][j]!=-1) return memo[i][j];\\n        int temp =0;\\n        for(int k=i+1;k<j;k++){  // loop to one by one check all partions\\n           int val1 = vec[j]-vec[k];  // check if left value is great or right\\n            int val2 = vec[k]-vec[i];\\n            if(val1>val2){\\n                temp = max(temp,val2+mcm(vec,i,k));\\n            }\\n            else if(val1<val2){\\n                temp = max(temp,val1+mcm(vec,k,j));\\n            }\\n            else{\\n                temp = max({temp,val2+mcm(vec,i,k),val1+mcm(vec,k,j)});\\n            }\\n        }\\n        return memo[i][j]=temp;\\n    }\\n    int stoneGameV(vector<int>& sV) {\\n        vector<int> pre;\\n        pre.push_back(0);\\n        memset(memo,-1,sizeof(memo));\\n        for(auto x:sV){\\n            pre.push_back(pre.back()+x);\\n        }\\n        return mcm(pre,0,sV.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo[501][501];  // array for memoization\\n    int mcm(vector<int> &vec,int i,int j){\\n        if(j<=i) return 0; // basically we have one element left thus return 0\\n        if(memo[i][j]!=-1) return memo[i][j];\\n        int temp =0;\\n        for(int k=i+1;k<j;k++){  // loop to one by one check all partions\\n           int val1 = vec[j]-vec[k];  // check if left value is great or right\\n            int val2 = vec[k]-vec[i];\\n            if(val1>val2){\\n                temp = max(temp,val2+mcm(vec,i,k));\\n            }\\n            else if(val1<val2){\\n                temp = max(temp,val1+mcm(vec,k,j));\\n            }\\n            else{\\n                temp = max({temp,val2+mcm(vec,i,k),val1+mcm(vec,k,j)});\\n            }\\n        }\\n        return memo[i][j]=temp;\\n    }\\n    int stoneGameV(vector<int>& sV) {\\n        vector<int> pre;\\n        pre.push_back(0);\\n        memset(memo,-1,sizeof(memo));\\n        for(auto x:sV){\\n            pre.push_back(pre.back()+x);\\n        }\\n        return mcm(pre,0,sV.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452554,
                "title": "java-simple-ac-solution",
                "content": "```\\nclass Solution {\\n    int[][] memo;\\n    public int stoneGameV(int[] arr) {\\n        int n = arr.length;\\n        if(n == 1)\\n            return 0;\\n        memo = new int[n+1][n+1];\\n        for(int[] x: memo)\\n            Arrays.fill(x, -1);\\n        \\n        int[] prefix = new int[n];\\n        prefix[0] = arr[0];\\n        for(int i=1;i<n;i++)\\n            prefix[i] = prefix[i-1] + arr[i];\\n        return find(0, n-1, prefix);\\n    }\\n   \\n    public int find(int i, int j, int[] arr)\\n    {\\n        if(i == j)//single element\\n            return 0;\\n        \\n        if(memo[i][j] != -1)\\n            return memo[i][j];\\n        \\n        int max = Integer.MIN_VALUE;\\n        for(int k=i;k<j;k++)\\n        {\\n            int left = arr[k] - (i-1<0 ? 0 : arr[i-1]);\\n            int right = arr[j] - arr[k];\\n            if(left < right)\\n                max = Math.max(max, left + find(i, k, arr));\\n            else if(left > right)\\n                max = Math.max(max, right + find(k+1, j, arr));\\n            else\\n                max = Math.max(max, Math.max(left + find(i, k, arr), right + find(k+1, j, arr)));\\n        }\\n        return memo[i][j] = max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    int[][] memo;\\n    public int stoneGameV(int[] arr) {\\n        int n = arr.length;\\n        if(n == 1)\\n            return 0;\\n        memo = new int[n+1][n+1];\\n        for(int[] x: memo)\\n            Arrays.fill(x, -1);\\n        \\n        int[] prefix = new int[n];\\n        prefix[0] = arr[0];\\n        for(int i=1;i<n;i++)\\n            prefix[i] = prefix[i-1] + arr[i];\\n        return find(0, n-1, prefix);\\n    }\\n   \\n    public int find(int i, int j, int[] arr)\\n    {\\n        if(i == j)//single element\\n            return 0;\\n        \\n        if(memo[i][j] != -1)\\n            return memo[i][j];\\n        \\n        int max = Integer.MIN_VALUE;\\n        for(int k=i;k<j;k++)\\n        {\\n            int left = arr[k] - (i-1<0 ? 0 : arr[i-1]);\\n            int right = arr[j] - arr[k];\\n            if(left < right)\\n                max = Math.max(max, left + find(i, k, arr));\\n            else if(left > right)\\n                max = Math.max(max, right + find(k+1, j, arr));\\n            else\\n                max = Math.max(max, Math.max(left + find(i, k, arr), right + find(k+1, j, arr)));\\n        }\\n        return memo[i][j] = max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416732,
                "title": "c-mcm-variant-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>& arr, int l, int r, vector<int>& prefixSum, vector<vector<int>>& memo){\\n        if(l == r){\\n            return 0;\\n        }\\n        if(memo[l][r] != -1){\\n            return memo[l][r];\\n        }\\n        \\n        int result = INT_MIN;\\n        \\n        // try out all the possible partitions\\n        for(int m=l+1; m<=r; m++){\\n            int leftSum = prefixSum[m]-prefixSum[l];\\n            int rightSum = prefixSum[r+1]-prefixSum[m];\\n            \\n            if(leftSum > rightSum){\\n                result = max(result, rightSum + solve(arr, m, r, prefixSum, memo));\\n            }\\n            else if(leftSum < rightSum){\\n                result = max(result, leftSum + solve(arr, l, m-1, prefixSum, memo));\\n            }\\n            else{\\n                result = max({ result, rightSum + solve(arr, m, r, prefixSum, memo), leftSum + solve(arr, l, m-1, prefixSum, memo) });\\n            }\\n        }\\n        \\n        return memo[l][r] = result;\\n    }\\n    \\n    int stoneGameV(vector<int>& stoneValue) {        \\n        // calculate the prefix sum array\\n        vector<int> prefixSum(stoneValue.size()+1, 0);\\n        \\n        for(int i=1; i<=stoneValue.size(); i++){\\n            prefixSum[i] = prefixSum[i-1] + stoneValue[i-1];\\n        }\\n        \\n        // solve using MCM dp strategy\\n        vector<vector<int>> memo(stoneValue.size(), vector<int>(stoneValue.size(), -1));\\n        \\n        return solve(stoneValue, 0, stoneValue.size()-1, prefixSum, memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>& arr, int l, int r, vector<int>& prefixSum, vector<vector<int>>& memo){\\n        if(l == r){\\n            return 0;\\n        }\\n        if(memo[l][r] != -1){\\n            return memo[l][r];\\n        }\\n        \\n        int result = INT_MIN;\\n        \\n        // try out all the possible partitions\\n        for(int m=l+1; m<=r; m++){\\n            int leftSum = prefixSum[m]-prefixSum[l];\\n            int rightSum = prefixSum[r+1]-prefixSum[m];\\n            \\n            if(leftSum > rightSum){\\n                result = max(result, rightSum + solve(arr, m, r, prefixSum, memo));\\n            }\\n            else if(leftSum < rightSum){\\n                result = max(result, leftSum + solve(arr, l, m-1, prefixSum, memo));\\n            }\\n            else{\\n                result = max({ result, rightSum + solve(arr, m, r, prefixSum, memo), leftSum + solve(arr, l, m-1, prefixSum, memo) });\\n            }\\n        }\\n        \\n        return memo[l][r] = result;\\n    }\\n    \\n    int stoneGameV(vector<int>& stoneValue) {        \\n        // calculate the prefix sum array\\n        vector<int> prefixSum(stoneValue.size()+1, 0);\\n        \\n        for(int i=1; i<=stoneValue.size(); i++){\\n            prefixSum[i] = prefixSum[i-1] + stoneValue[i-1];\\n        }\\n        \\n        // solve using MCM dp strategy\\n        vector<vector<int>> memo(stoneValue.size(), vector<int>(stoneValue.size(), -1));\\n        \\n        return solve(stoneValue, 0, stoneValue.size()-1, prefixSum, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416178,
                "title": "intuitive-recursive-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int stoneGameV(vector<int>& s) {\\n        memset(dp,-1,sizeof(dp));\\n        return fun(0,s.size()-1,s);\\n    }\\n    int fun(int i,int j,vector<int>& s){\\n        if(i>=j) return 0;\\n        int ans=-1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int right=0,left=0;\\n        for(int k=i;k<=j;k++){\\n            right+=s[k];\\n        }\\n        for(int k=i;k<j;k++){\\n            right-=s[k];\\n            left+=s[k];\\n            int sum1=left,sum2=right;\\n            if(sum1>sum2){\\n                ans=max(ans,sum2+fun(k+1,j,s));\\n            }else if(sum2>sum1){\\n                ans=max(ans,sum1+fun(i,k,s));\\n            }else ans=max(ans,max(sum2+fun(k+1,j,s), sum1+fun(i,k,s)));\\n            \\n        }\\n       \\n        return dp[i][j]=ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int stoneGameV(vector<int>& s) {\\n        memset(dp,-1,sizeof(dp));\\n        return fun(0,s.size()-1,s);\\n    }\\n    int fun(int i,int j,vector<int>& s){\\n        if(i>=j) return 0;\\n        int ans=-1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int right=0,left=0;\\n        for(int k=i;k<=j;k++){\\n            right+=s[k];\\n        }\\n        for(int k=i;k<j;k++){\\n            right-=s[k];\\n            left+=s[k];\\n            int sum1=left,sum2=right;\\n            if(sum1>sum2){\\n                ans=max(ans,sum2+fun(k+1,j,s));\\n            }else if(sum2>sum1){\\n                ans=max(ans,sum1+fun(i,k,s));\\n            }else ans=max(ans,max(sum2+fun(k+1,j,s), sum1+fun(i,k,s)));\\n            \\n        }\\n       \\n        return dp[i][j]=ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409841,
                "title": "cpp-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int rec(int low, int high, vector<int>& s){\\n        if (low==high) return 0;\\n        int sum = 0, leftsum = 0, res = -1;\\n        if (dp[low][high]!=-1) return dp[low][high];\\n        for (int i=low;i<=high;i++) sum += s[i];\\n        for (int i=low;i<high;i++){\\n            leftsum += s[i];\\n            int rightSum = sum - leftsum;\\n            if (leftsum<=rightSum){\\n                res = max(rec(low,i,s) + leftsum, res);\\n            }\\n            if (leftsum>=rightSum){\\n                res = max(rec(i+1,high,s) + rightSum, res);\\n            }\\n        }\\n        return dp[low][high] = res;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        memset(dp,-1,sizeof dp);\\n        return rec(0,stoneValue.size()-1,stoneValue);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int rec(int low, int high, vector<int>& s){\\n        if (low==high) return 0;\\n        int sum = 0, leftsum = 0, res = -1;\\n        if (dp[low][high]!=-1) return dp[low][high];\\n        for (int i=low;i<=high;i++) sum += s[i];\\n        for (int i=low;i<high;i++){\\n            leftsum += s[i];\\n            int rightSum = sum - leftsum;\\n            if (leftsum<=rightSum){\\n                res = max(rec(low,i,s) + leftsum, res);\\n            }\\n            if (leftsum>=rightSum){\\n                res = max(rec(i+1,high,s) + rightSum, res);\\n            }\\n        }\\n        return dp[low][high] = res;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        memset(dp,-1,sizeof dp);\\n        return rec(0,stoneValue.size()-1,stoneValue);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376411,
                "title": "c-clean-code-dp-mcm",
                "content": "**Code** : \\n```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    \\n    int f(vector<int> &v,int i,int j){\\n        \\n        if(i>=j) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int r=0;\\n        for(int k=i;k<=j;k++) r+=v[k];\\n        \\n        int l=0,ans=0;\\n        for(int k=i;k<=j;k++){\\n            l+=v[k];\\n            r-=v[k];\\n            if(l<r) ans=max(ans,l+f(v,i,k));\\n            else if(r<l) ans=max(ans,r+f(v,k+1,j));\\n            else ans=max(ans,max(l+f(v,i,k),r+f(v,k+1,j)));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    \\n    int stoneGameV(vector<int>& stoneValue) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return f(stoneValue,0,stoneValue.size()-1);\\n        \\n    }\\n};\\n```\\n\\nTime Complexity : **0(n^3)**\\nSpace Complexity : **0(n^2)**\\n\\nHope this helps :)\\nAny suggestions or updations are happily invited.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    \\n    int f(vector<int> &v,int i,int j){\\n        \\n        if(i>=j) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int r=0;\\n        for(int k=i;k<=j;k++) r+=v[k];\\n        \\n        int l=0,ans=0;\\n        for(int k=i;k<=j;k++){\\n            l+=v[k];\\n            r-=v[k];\\n            if(l<r) ans=max(ans,l+f(v,i,k));\\n            else if(r<l) ans=max(ans,r+f(v,k+1,j));\\n            else ans=max(ans,max(l+f(v,i,k),r+f(v,k+1,j)));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    \\n    int stoneGameV(vector<int>& stoneValue) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return f(stoneValue,0,stoneValue.size()-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351330,
                "title": "easy-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int stoneGameV(vector<int>& stoneValue) {\\n        if(stoneValue.size()<=1) return 0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=1; i<stoneValue.size(); i++) stoneValue[i]+=stoneValue[i-1];\\n        return solve(0,(int)stoneValue.size()-1,stoneValue);\\n    }\\n    int solve(int L,int R,vector<int>&stones) {\\n         if(L>R) return 0;\\n         if(dp[L][R]!=-1) return dp[L][R];\\n         int scoreAlice = 0;\\n         for(int i = L; i<R; i++) {\\n               int score = 0;\\n               int left = stones[i] -  (L>0?stones[L-1]:0);\\n               int right = stones[R] - stones[i];\\n               if(left < right) {\\n                    // if left subarray is small , take the sum and remove right subarray i.e recurse inside the left segment\\n                    score = left + solve(L,i,stones); \\n               }else if(right < left) {\\n                    // if right subarray is small , take the sum and remove the left subarray i.e recurse inside the right segment\\n                    score = right + solve(i+1,R,stones);\\n               }else {\\n                    // check both , eg :  2 1 1 , you might remove a big value instead of a big range!\\n                    score = right + max(solve(L,i,stones),solve(i+1,R,stones));\\n               }\\n               scoreAlice = max(scoreAlice,score);\\n         }\\n        return dp[L][R] = scoreAlice;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int stoneGameV(vector<int>& stoneValue) {\\n        if(stoneValue.size()<=1) return 0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=1; i<stoneValue.size(); i++) stoneValue[i]+=stoneValue[i-1];\\n        return solve(0,(int)stoneValue.size()-1,stoneValue);\\n    }\\n    int solve(int L,int R,vector<int>&stones) {\\n         if(L>R) return 0;\\n         if(dp[L][R]!=-1) return dp[L][R];\\n         int scoreAlice = 0;\\n         for(int i = L; i<R; i++) {\\n               int score = 0;\\n               int left = stones[i] -  (L>0?stones[L-1]:0);\\n               int right = stones[R] - stones[i];\\n               if(left < right) {\\n                    // if left subarray is small , take the sum and remove right subarray i.e recurse inside the left segment\\n                    score = left + solve(L,i,stones); \\n               }else if(right < left) {\\n                    // if right subarray is small , take the sum and remove the left subarray i.e recurse inside the right segment\\n                    score = right + solve(i+1,R,stones);\\n               }else {\\n                    // check both , eg :  2 1 1 , you might remove a big value instead of a big range!\\n                    score = right + max(solve(L,i,stones),solve(i+1,R,stones));\\n               }\\n               scoreAlice = max(scoreAlice,score);\\n         }\\n        return dp[L][R] = scoreAlice;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276577,
                "title": "c-dp-tabulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& a) {\\n        int n=a.size();\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        vector<long long> sum(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            sum[i]=sum[i-1]+a[i-1];\\n        }\\n        for(int g=0;g<n;g++){\\n            for(int i=0,j=g;j<n;i++,j++){\\n                if(g==0){\\n                    dp[i][j]=0;\\n                }\\n                else if(g==1){\\n                    dp[i][j]=min(a[i],a[j]);\\n                }\\n                else{\\n                    int ans=0;\\n                    for(int k=i;k<j;k++){\\n                        int lsum=sum[k+1]-sum[i];\\n                        int rsum=sum[j+1]-sum[k+1];\\n                        if(lsum<rsum){\\n                            ans=max(ans,lsum+dp[i][k]);\\n                        }\\n                        else if(lsum>rsum){\\n                            ans=max(ans,rsum+dp[k+1][j]);\\n                        }\\n                        else{\\n                            ans=max(ans,rsum+max(dp[i][k],dp[k+1][j]));\\n                        }\\n                        \\n                    }\\n                    dp[i][j]=ans;\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& a) {\\n        int n=a.size();\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        vector<long long> sum(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            sum[i]=sum[i-1]+a[i-1];\\n        }\\n        for(int g=0;g<n;g++){\\n            for(int i=0,j=g;j<n;i++,j++){\\n                if(g==0){\\n                    dp[i][j]=0;\\n                }\\n                else if(g==1){\\n                    dp[i][j]=min(a[i],a[j]);\\n                }\\n                else{\\n                    int ans=0;\\n                    for(int k=i;k<j;k++){\\n                        int lsum=sum[k+1]-sum[i];\\n                        int rsum=sum[j+1]-sum[k+1];\\n                        if(lsum<rsum){\\n                            ans=max(ans,lsum+dp[i][k]);\\n                        }\\n                        else if(lsum>rsum){\\n                            ans=max(ans,rsum+dp[k+1][j]);\\n                        }\\n                        else{\\n                            ans=max(ans,rsum+max(dp[i][k],dp[k+1][j]));\\n                        }\\n                        \\n                    }\\n                    dp[i][j]=ans;\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242153,
                "title": "c-code-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    \\n    int func(vector<int> &v,int start,int end,int total){\\n        if (end<=start){\\n            return 0;\\n        }\\n        \\n        if (dp[start][end]!=-1){\\n            return dp[start][end];\\n        }\\n        \\n        int val=0,sum=0;\\n        for (int i=start; i<end; i++){\\n            sum+=v[i];\\n            int rem=total-sum;\\n            \\n            if (rem>sum){\\n                val=max(val,sum+func(v,start,i,sum));\\n            }\\n            else if (sum>rem){\\n                val=max(val,rem+func(v,i+1,end,rem));\\n            }\\n            else{\\n                val=max(val,max(sum+func(v,start,i,sum),rem+func(v,i+1,end,rem)));\\n            }\\n        }\\n        \\n     return dp[start][end]=val;\\n    }\\n    \\n    int stoneGameV(vector<int>& v) {\\n        int i;\\n        int sum=0;\\n        \\n        for (i=0; i<v.size(); i++){\\n            sum+=v[i];\\n        }\\n        \\n        int n=v.size();\\n        int total=sum;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n       return func(v,0,n-1,total);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    \\n    int func(vector<int> &v,int start,int end,int total){\\n        if (end<=start){\\n            return 0;\\n        }\\n        \\n        if (dp[start][end]!=-1){\\n            return dp[start][end];\\n        }\\n        \\n        int val=0,sum=0;\\n        for (int i=start; i<end; i++){\\n            sum+=v[i];\\n            int rem=total-sum;\\n            \\n            if (rem>sum){\\n                val=max(val,sum+func(v,start,i,sum));\\n            }\\n            else if (sum>rem){\\n                val=max(val,rem+func(v,i+1,end,rem));\\n            }\\n            else{\\n                val=max(val,max(sum+func(v,start,i,sum),rem+func(v,i+1,end,rem)));\\n            }\\n        }\\n        \\n     return dp[start][end]=val;\\n    }\\n    \\n    int stoneGameV(vector<int>& v) {\\n        int i;\\n        int sum=0;\\n        \\n        for (i=0; i<v.size(); i++){\\n            sum+=v[i];\\n        }\\n        \\n        int n=v.size();\\n        int total=sum;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n       return func(v,0,n-1,total);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232331,
                "title": "java-recursion-memo-based",
                "content": "```\\nclass Solution {\\n    int dp[][];\\n    public int fnc(int a[], int i, int j, int sum){\\n        //System.out.println(i+\" \"+j);\\n        int n=a.length;\\n        if(i>j)\\n            return 0;\\n        if(j>n)\\n            return 0;\\n        if(i==j){\\n            dp[i][j]=-1;\\n            return 0;\\n        }\\n        if(dp[i][j]!=0)\\n            return dp[i][j];\\n        \\n   int temp=0;\\n        int ans=Integer.MIN_VALUE;\\n       \\n        for(int index=i;index<=j;index++){\\n            temp+=a[index];\\n            if(temp>sum-temp){\\n                ans=Math.max(ans,((sum-temp)+fnc(a,index+1,j,sum-temp)));\\n            }\\n            else if(temp<sum-temp){\\n                ans=Math.max(ans,temp+fnc(a,i,index,temp));\\n            }\\n            else\\n                ans=Math.max(ans,Math.max(sum-temp+fnc(a,index+1,j,sum-temp),temp+fnc(a,i,index,temp)));\\n        }\\n        dp[i][j]=ans;\\n        return dp[i][j];\\n    }\\n    public int stoneGameV(int[] stoneValue) {\\n        int n=stoneValue.length;\\n        int sum=0;\\n        for(int ele:stoneValue)\\n            sum+=ele;\\n        dp= new int[n][n];\\n        return fnc(stoneValue,0,n-1,sum);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int dp[][];\\n    public int fnc(int a[], int i, int j, int sum){\\n        //System.out.println(i+\" \"+j);\\n        int n=a.length;\\n        if(i>j)\\n            return 0;\\n        if(j>n)\\n            return 0;\\n        if(i==j){\\n            dp[i][j]=-1;\\n            return 0;\\n        }\\n        if(dp[i][j]!=0)\\n            return dp[i][j];\\n        \\n   int temp=0;\\n        int ans=Integer.MIN_VALUE;\\n       \\n        for(int index=i;index<=j;index++){\\n            temp+=a[index];\\n            if(temp>sum-temp){\\n                ans=Math.max(ans,((sum-temp)+fnc(a,index+1,j,sum-temp)));\\n            }\\n            else if(temp<sum-temp){\\n                ans=Math.max(ans,temp+fnc(a,i,index,temp));\\n            }\\n            else\\n                ans=Math.max(ans,Math.max(sum-temp+fnc(a,index+1,j,sum-temp),temp+fnc(a,i,index,temp)));\\n        }\\n        dp[i][j]=ans;\\n        return dp[i][j];\\n    }\\n    public int stoneGameV(int[] stoneValue) {\\n        int n=stoneValue.length;\\n        int sum=0;\\n        for(int ele:stoneValue)\\n            sum+=ele;\\n        dp= new int[n][n];\\n        return fnc(stoneValue,0,n-1,sum);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203385,
                "title": "brute-force-to-optimize-solution-c",
                "content": "```\\n// Brute Force\\n// Time:O(2^(n*n))\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<int> &v){\\n        if(i>=j) return 0;\\n        int ans=INT_MIN;\\n        int sum=0,tot=0;\\n        for(int k=i;k<=j;k++) sum+=v[k];\\n        for(int k=i;k<=j;k++){\\n            tot+=v[k];\\n            if(tot>sum-tot){\\n                ans=max(ans,sum-tot+solve(k+1,j,v));\\n            }\\n            else if(tot<sum-tot){\\n                ans=max(ans,tot+solve(i,k,v));\\n            }\\n            else{\\n                ans=max(ans,max(sum-tot+solve(k+1,j,v),tot+solve(i,k,v)));\\n            }\\n        }\\n        return ans;\\n    }\\n    int stoneGameV(vector<int>& v) {\\n        int n=v.size();\\n        return solve(0,n-1,v);\\n    }\\n};\\n\\n// DP+Memoization\\n//Time:O(N^3), Space:O(N^2)\\nint dp[501][501];\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<int> &v){\\n        if(i>=j) return 0;\\n        int ans=INT_MIN;\\n        int sum=0,tot=0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        for(int k=i;k<=j;k++) sum+=v[k];\\n        for(int k=i;k<=j;k++){\\n            tot+=v[k];\\n            if(tot>sum-tot){\\n                ans=max(ans,sum-tot+solve(k+1,j,v));\\n            }\\n            else if(tot<sum-tot){\\n                ans=max(ans,tot+solve(i,k,v));\\n            }\\n            else{\\n                ans=max(ans,max(sum-tot+solve(k+1,j,v),tot+solve(i,k,v)));\\n            }\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int stoneGameV(vector<int>& v) {\\n        int n=v.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,n-1,v);\\n    }\\n};\\n\\n// Bottom Up\\n// Time : O(n^3), Space:O(n^2)\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& v) {\\n        int n=v.size();\\n        int dp[n][n],prf[n+1];\\n        prf[0]=0;\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++){\\n            prf[i]=prf[i-1]+v[i-1];\\n        }\\n        for(int l=1;l<=n;l++){\\n            for(int i=0;i<n-l;i++){\\n                int j=i+l,res=0;\\n                for(int k=i;k<j;k++){\\n                    int left=prf[k+1]-prf[i],right=prf[j+1]-prf[k+1];\\n                    if(left>right){\\n                        res=max(res,right+dp[k+1][j]);\\n                    }\\n                    else if(left<right){\\n                        res=max(res,left+dp[i][k]);\\n                    }\\n                    else{\\n                        res=max(res,max(right+dp[k+1][j],left+dp[i][k]));\\n                    }\\n                }\\n                dp[i][j]=res;\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int solve(int i,int j,vector<int> &v){\\n        if(i>=j) return 0;\\n        int ans=INT_MIN;\\n        int sum=0,tot=0;\\n        for(int k=i;k<=j;k++) sum+=v[k];\\n        for(int k=i;k<=j;k++){\\n            tot+=v[k];\\n            if(tot>sum-tot){\\n                ans=max(ans,sum-tot+solve(k+1,j,v));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2177475,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int recur(vector<int>&s,int i,int j,int sum){\\n        if(i>j)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ss = 0;\\n        int maxx = 0;\\n        for(int index = i; index<=j; index++){\\n            ss+=s[index];\\n            if(sum-2*ss>0){\\n                maxx = max(maxx,ss+recur(s,i,index,ss));\\n            }\\n            else if(sum-2*ss==0){\\n                int left = ss+recur(s,i,index,ss);\\n                int right = ss+recur(s,index+1,j,ss);\\n                maxx = max(maxx,max(left,right));\\n            }\\n            else{\\n                maxx = max(maxx,sum-ss+recur(s,index+1,j,sum-ss));\\n            }\\n        }\\n        return dp[i][j] = maxx;\\n    }\\n    int stoneGameV(vector<int>& s) {\\n        int sum = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n; i++){\\n            sum+=s[i];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return recur(s,0,n-1,sum);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int recur(vector<int>&s,int i,int j,int sum){\\n        if(i>j)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ss = 0;\\n        int maxx = 0;\\n        for(int index = i; index<=j; index++){\\n            ss+=s[index];\\n            if(sum-2*ss>0){\\n                maxx = max(maxx,ss+recur(s,i,index,ss));\\n            }\\n            else if(sum-2*ss==0){\\n                int left = ss+recur(s,i,index,ss);\\n                int right = ss+recur(s,index+1,j,ss);\\n                maxx = max(maxx,max(left,right));\\n            }\\n            else{\\n                maxx = max(maxx,sum-ss+recur(s,index+1,j,sum-ss));\\n            }\\n        }\\n        return dp[i][j] = maxx;\\n    }\\n    int stoneGameV(vector<int>& s) {\\n        int sum = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n; i++){\\n            sum+=s[i];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return recur(s,0,n-1,sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154304,
                "title": "c-dp-memoize",
                "content": "class Solution {\\npublic:\\n    \\n    int dp[510][510];\\n    \\n    int rec(int st,int en,vector<int>& pf){\\n        \\n        if(st==en)return 0; \\n        \\n        if(dp[st][en]!=-1)return dp[st][en];\\n\\n        int ans = 0;\\n        \\n        for(int i=st;i<=en;i++){\\n            \\n            int left = pf[i]-pf[st-1];\\n            int right = pf[en]-pf[i];\\n            \\n            if(left>right){\\n                ans = max(ans,right+rec(i+1,en,pf));\\n            }\\n            \\n            else if(right>left){\\n                ans = max(ans,left+rec(st,i,pf));\\n            }\\n            \\n            else{\\n               ans = max({ans,left+rec(st,i,pf),right+rec(i+1,en,pf)}); \\n            }\\n        }\\n        return dp[st][en]=ans;\\n    }\\n    \\n    \\n    int stoneGameV(vector<int>& v) {\\n        \\n        int n = v.size();\\n        \\n        vector <int> pf(n+1,0);\\n        \\n        for(int i=1;i<=n;i++){\\n            pf[i]=pf[i-1]+v[i-1];\\n        }\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        int ans = rec(1,n,pf);\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int dp[510][510];\\n    \\n    int rec(int st,int en,vector<int>& pf){\\n        \\n        if(st==en)return 0; \\n        \\n        if(dp[st][en]!=-1)return dp[st][en];\\n\\n        int ans = 0;\\n        \\n        for(int i=st;i<=en;i++){\\n            \\n            int left = pf[i]-pf[st-1];\\n            int right = pf[en]-pf[i];\\n            \\n            if(left>right){\\n                ans = max(ans,right+rec(i+1,en,pf));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2106907,
                "title": "javascript-recursive-dp-o-n-2-time-o-n-2-space-50-time-50-space",
                "content": "```\\nvar stoneGameV = function(stoneValue) {\\n    // Find the stoneValue array\\'s prefix sum\\n    let prefix = Array(stoneValue.length).fill(0);\\n    for (let i = 0; i < stoneValue.length; i++) {\\n        prefix[i] = stoneValue[i] + (prefix[i - 1] || 0);\\n    }\\n    \\n    let dp = Array(stoneValue.length).fill().map(() => Array(stoneValue.length).fill(0));\\n    \\n    function game(start, end) {\\n        if (dp[start][end]) return dp[start][end];\\n        if (start === end) return 0;\\n        \\n        let max = 0;\\n        for (let i = start + 1; i <= end; i++) {\\n            let sumL = prefix[i - 1] - (prefix[start - 1] || 0);\\n            let sumR = prefix[end] - (prefix[i - 1] || 0);\\n            if (sumL > sumR) {\\n                max = Math.max(max, sumR + game(i, end));\\n            } else if (sumL < sumR) {\\n                max = Math.max(max, sumL + game(start, i - 1));\\n            } else {\\n                // If tied, check both rows\\n                let left = sumR + game(i, end);\\n                let right = sumL + game(start, i - 1);\\n                max = Math.max(max, left, right);\\n            }\\n        } return dp[start][end] = max;\\n    }\\n    \\n    return game(0, stoneValue.length - 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar stoneGameV = function(stoneValue) {\\n    // Find the stoneValue array\\'s prefix sum\\n    let prefix = Array(stoneValue.length).fill(0);\\n    for (let i = 0; i < stoneValue.length; i++) {\\n        prefix[i] = stoneValue[i] + (prefix[i - 1] || 0);\\n    }\\n    \\n    let dp = Array(stoneValue.length).fill().map(() => Array(stoneValue.length).fill(0));\\n    \\n    function game(start, end) {\\n        if (dp[start][end]) return dp[start][end];\\n        if (start === end) return 0;\\n        \\n        let max = 0;\\n        for (let i = start + 1; i <= end; i++) {\\n            let sumL = prefix[i - 1] - (prefix[start - 1] || 0);\\n            let sumR = prefix[end] - (prefix[i - 1] || 0);\\n            if (sumL > sumR) {\\n                max = Math.max(max, sumR + game(i, end));\\n            } else if (sumL < sumR) {\\n                max = Math.max(max, sumL + game(start, i - 1));\\n            } else {\\n                // If tied, check both rows\\n                let left = sumR + game(i, end);\\n                let right = sumL + game(start, i - 1);\\n                max = Math.max(max, left, right);\\n            }\\n        } return dp[start][end] = max;\\n    }\\n    \\n    return game(0, stoneValue.length - 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2096144,
                "title": "c-dp-memoization-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>pr;\\n    int dp[501][501];\\n    int solve(int i,int j){\\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        dp[i][j]=0;\\n        for(int k=i+1;k<=j;++k){\\n            int ls=pr[k]-pr[i],rs=pr[j+1]-pr[k];\\n            if(ls<rs)dp[i][j]=max(dp[i][j],ls+solve(i,k-1));\\n            else if(ls>rs)dp[i][j]=max(dp[i][j],rs+solve(k,j));\\n            else dp[i][j]=max(dp[i][j],max(ls+solve(i,k-1),rs+solve(k,j)));\\n        }\\n        return dp[i][j];\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        memset(dp,-1,sizeof(dp));\\n        pr.resize(stoneValue.size()+1);\\n        for(int i=0;i<size(stoneValue);++i)pr[i+1]=pr[i]+stoneValue[i];\\n        return solve(0,size(stoneValue)-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>pr;\\n    int dp[501][501];\\n    int solve(int i,int j){\\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        dp[i][j]=0;\\n        for(int k=i+1;k<=j;++k){\\n            int ls=pr[k]-pr[i],rs=pr[j+1]-pr[k];\\n            if(ls<rs)dp[i][j]=max(dp[i][j],ls+solve(i,k-1));\\n            else if(ls>rs)dp[i][j]=max(dp[i][j],rs+solve(k,j));\\n            else dp[i][j]=max(dp[i][j],max(ls+solve(i,k-1),rs+solve(k,j)));\\n        }\\n        return dp[i][j];\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        memset(dp,-1,sizeof(dp));\\n        pr.resize(stoneValue.size()+1);\\n        for(int i=0;i<size(stoneValue);++i)pr[i+1]=pr[i]+stoneValue[i];\\n        return solve(0,size(stoneValue)-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095369,
                "title": "simple-c-backtracking-with-memorization",
                "content": "It is a DP put into a backtracking. Explore all possibilities in recursion, use memorization to trim the search space. \\n\\n```\\nclass Solution {\\n    int mem[501][501];\\n    \\n    int dfs(vector<int>& ps, int x, int y) {\\n        if (y==x) return mem[x][x]=0;\\n        if (y==x+1) return mem[x][y]=min(ps[y]-ps[y-1], ps[x]-ps[x-1]);\\n        if (mem[x][y]!=-1) return mem[x][y];\\n        \\n        int res= INT_MIN;\\n        for (int j=x; j<y; j++) {\\n            int lf=ps[j]-ps[x-1], rt=ps[y]-ps[j];\\n            if (lf == rt)\\n                res = max(res, lf+max(dfs(ps, x, j), dfs(ps, j+1, y)));\\n            else if (lf<rt)\\n                res = max(res, lf+dfs(ps,x,j));\\n            else \\n                res = max(res, rt+dfs(ps,j+1,y));\\n        }\\n        return mem[x][y]=res;\\n    }\\n    \\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        memset(mem, -1, sizeof(mem));\\n        int n=stoneValue.size();\\n        \\n        vector<int> ps(n+1, 0); //prefix sum\\n        for (int i=0; i<n; i++) ps[i+1] = ps[i]+stoneValue[i];\\n        return dfs(ps, 1, n);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int mem[501][501];\\n    \\n    int dfs(vector<int>& ps, int x, int y) {\\n        if (y==x) return mem[x][x]=0;\\n        if (y==x+1) return mem[x][y]=min(ps[y]-ps[y-1], ps[x]-ps[x-1]);\\n        if (mem[x][y]!=-1) return mem[x][y];\\n        \\n        int res= INT_MIN;\\n        for (int j=x; j<y; j++) {\\n            int lf=ps[j]-ps[x-1], rt=ps[y]-ps[j];\\n            if (lf == rt)\\n                res = max(res, lf+max(dfs(ps, x, j), dfs(ps, j+1, y)));\\n            else if (lf<rt)\\n                res = max(res, lf+dfs(ps,x,j));\\n            else \\n                res = max(res, rt+dfs(ps,j+1,y));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2093271,
                "title": "memorization-on-recursion-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    \\n    int sol(int i,int j,vector<int> &a)\\n    {\\n        if(i==j) return 0;\\n        \\n        int ans=dp[i][j];\\n        if(ans!=-1) return ans;\\n        ans=0;\\n        \\n        for(int k=i;k<j;k++)\\n        {\\n            int ls=a[k]-a[i-1],rs=a[j]-a[k];\\n            if(ls<rs) ans=max(ans,ls+sol(i,k,a));\\n            else if(ls>rs) ans=max(ans,rs+sol(k+1,j,a));\\n            else ans=max(ans,ls+max(sol(i,k,a),sol(k+1,j,a)));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    \\n    int stoneGameV(vector<int>& a) \\n    {\\n        a.insert(a.begin(),0);\\n        for(int i=1;i<a.size();i++)\\n            a[i]+=a[i-1];\\n        memset(dp,-1,sizeof(dp));\\n        return sol(1,a.size()-1,a);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    \\n    int sol(int i,int j,vector<int> &a)\\n    {\\n        if(i==j) return 0;\\n        \\n        int ans=dp[i][j];\\n        if(ans!=-1) return ans;\\n        ans=0;\\n        \\n        for(int k=i;k<j;k++)\\n        {\\n            int ls=a[k]-a[i-1],rs=a[j]-a[k];\\n            if(ls<rs) ans=max(ans,ls+sol(i,k,a));\\n            else if(ls>rs) ans=max(ans,rs+sol(k+1,j,a));\\n            else ans=max(ans,ls+max(sol(i,k,a),sol(k+1,j,a)));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    \\n    int stoneGameV(vector<int>& a) \\n    {\\n        a.insert(a.begin(),0);\\n        for(int i=1;i<a.size();i++)\\n            a[i]+=a[i-1];\\n        memset(dp,-1,sizeof(dp));\\n        return sol(1,a.size()-1,a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936111,
                "title": "simple-solution-in-java-elegant-and-concise-memoization",
                "content": "```\\nclass Solution {\\n    private Integer[][] memo;\\n    \\n    public int stoneGameV(int[] stoneValue) {\\n        this.memo = new Integer[stoneValue.length][stoneValue.length];\\n        \\n        int[] preSum = new int[stoneValue.length];\\n        preSum[0] = stoneValue[0];\\n        for(int i=1; i<stoneValue.length; i++){\\n            preSum[i] = preSum[i-1] + stoneValue[i];\\n        }\\n        \\n        return find(0, stoneValue.length-1, stoneValue, preSum);\\n    }\\n    \\n    private int find(int s, int e, int[] stoneValue, int[] preSum){\\n        if(s >= e) return 0;\\n        if(memo[s][e] != null){\\n            return memo[s][e];\\n        }\\n        \\n        int maxScore = 0;\\n        int rowSum = preSum[e] - (s >= 1 ? preSum[s-1] : 0);\\n        for(int i=s; i<e; i++){ // Do the parition\\n            int firstRowSum = preSum[i] - (s >= 1 ? preSum[s-1] : 0);\\n            int secondRowSum = rowSum - firstRowSum;\\n            \\n            if(firstRowSum > secondRowSum){\\n                // First row will be thrown\\n                maxScore = Math.max(maxScore, secondRowSum + find(i+1, e, stoneValue, preSum));\\n            }else if(firstRowSum < secondRowSum){\\n                // Second row will be thrown\\n                maxScore = Math.max(maxScore, firstRowSum + find(s, i, stoneValue, preSum));\\n            }else{ // Rows have equal sum \\n                maxScore = Math.max(maxScore, secondRowSum + find(i+1, e, stoneValue, preSum));\\n                maxScore = Math.max(maxScore, firstRowSum + find(s, i, stoneValue, preSum));\\n            }\\n        }\\n        \\n        memo[s][e] = maxScore;\\n        return maxScore;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Integer[][] memo;\\n    \\n    public int stoneGameV(int[] stoneValue) {\\n        this.memo = new Integer[stoneValue.length][stoneValue.length];\\n        \\n        int[] preSum = new int[stoneValue.length];\\n        preSum[0] = stoneValue[0];\\n        for(int i=1; i<stoneValue.length; i++){\\n            preSum[i] = preSum[i-1] + stoneValue[i];\\n        }\\n        \\n        return find(0, stoneValue.length-1, stoneValue, preSum);\\n    }\\n    \\n    private int find(int s, int e, int[] stoneValue, int[] preSum){\\n        if(s >= e) return 0;\\n        if(memo[s][e] != null){\\n            return memo[s][e];\\n        }\\n        \\n        int maxScore = 0;\\n        int rowSum = preSum[e] - (s >= 1 ? preSum[s-1] : 0);\\n        for(int i=s; i<e; i++){ // Do the parition\\n            int firstRowSum = preSum[i] - (s >= 1 ? preSum[s-1] : 0);\\n            int secondRowSum = rowSum - firstRowSum;\\n            \\n            if(firstRowSum > secondRowSum){\\n                // First row will be thrown\\n                maxScore = Math.max(maxScore, secondRowSum + find(i+1, e, stoneValue, preSum));\\n            }else if(firstRowSum < secondRowSum){\\n                // Second row will be thrown\\n                maxScore = Math.max(maxScore, firstRowSum + find(s, i, stoneValue, preSum));\\n            }else{ // Rows have equal sum \\n                maxScore = Math.max(maxScore, secondRowSum + find(i+1, e, stoneValue, preSum));\\n                maxScore = Math.max(maxScore, firstRowSum + find(s, i, stoneValue, preSum));\\n            }\\n        }\\n        \\n        memo[s][e] = maxScore;\\n        return maxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872555,
                "title": "c-dp-prefix-sum-recursion-memoization-o-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int func(vector<int>& prefixSum, int l, int r){\\n        if(r-l+1 == 1){\\n            return 0;\\n        }\\n        \\n        if(dp[l][r]!=-1)\\n            return dp[l][r];\\n        \\n        int res=0;\\n        for(int i=l;i<r;i++){\\n            int left_sum=prefixSum[i+1]-prefixSum[l];\\n            int right_sum=prefixSum[r+1]-prefixSum[i+1];\\n            if(left_sum<right_sum){\\n                res=max(left_sum+func(prefixSum,l,i),res);\\n            }else if(left_sum>right_sum){\\n                res=max(right_sum+func(prefixSum,i+1,r),res);\\n            }else{\\n                res=max({res,left_sum+func(prefixSum,l,i),right_sum+func(prefixSum,i+1,r)});\\n            }            \\n        }\\n        return dp[l][r] = res;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n=stoneValue.size();\\n        vector<int> prefixSum(n+1,0);\\n        for(int i=1;i<n+1;i++){\\n            prefixSum[i]=prefixSum[i-1]+stoneValue[i-1];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return func(prefixSum,0,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int func(vector<int>& prefixSum, int l, int r){\\n        if(r-l+1 == 1){\\n            return 0;\\n        }\\n        \\n        if(dp[l][r]!=-1)\\n            return dp[l][r];\\n        \\n        int res=0;\\n        for(int i=l;i<r;i++){\\n            int left_sum=prefixSum[i+1]-prefixSum[l];\\n            int right_sum=prefixSum[r+1]-prefixSum[i+1];\\n            if(left_sum<right_sum){\\n                res=max(left_sum+func(prefixSum,l,i),res);\\n            }else if(left_sum>right_sum){\\n                res=max(right_sum+func(prefixSum,i+1,r),res);\\n            }else{\\n                res=max({res,left_sum+func(prefixSum,l,i),right_sum+func(prefixSum,i+1,r)});\\n            }            \\n        }\\n        return dp[l][r] = res;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n=stoneValue.size();\\n        vector<int> prefixSum(n+1,0);\\n        for(int i=1;i<n+1;i++){\\n            prefixSum[i]=prefixSum[i-1]+stoneValue[i-1];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return func(prefixSum,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853619,
                "title": "python-o-n-2-dp",
                "content": "Python implementation based on\\nhttps://leetcode.com/problems/stone-game-v/discuss/911676/Java-O(n3)-O(n2-log-n)-and-O(n2)-with-explanation\\n\\n```\\nfrom collections import defaultdict\\nfrom itertools import accumulate\\n\\nclass Solution:\\n    \\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        n = len(stoneValue)\\n        dp = [[0]*n for _ in range(n)]\\n        left = [[0]*n for _ in range(n)]\\n        prefix = list(accumulate(stoneValue))\\n        prefix = [0]+prefix+[prefix[-1]]\\n\\n        def sum(i,j):\\n            return prefix[j+1]-prefix[i]\\n        \\n        row_idx = [i for i in range(n)]\\n        for i in range(n):\\n            left[i][i] = stoneValue[i]\\n        for d in range(1,n):\\n            for i in range(n-d):\\n                j = i+d\\n                while sum(i,row_idx[i]) < sum(row_idx[i]+1,j):\\n                    row_idx[i] +=1\\n                if sum(i, row_idx[i]) == sum(row_idx[i]+1,j):\\n                    dp[i][j] = max(left[i][row_idx[i]], left[j][row_idx[i]+1])\\n                else:\\n                    if row_idx[i] == i:\\n                        dp[i][j] = left[j][i+1]                    \\n                    elif row_idx[i] == j:\\n                        dp[i][j] = left[i][j-1]\\n                    else:\\n                        dp[i][j] = max(left[i][row_idx[i]-1], left[j][row_idx[i]+1])\\n                left[j][i] = max(left[j][i+1],sum(i,j)+dp[i][j])\\n                left[i][j] = max(left[i][j-1],sum(i,j)+dp[i][j])\\n        return dp[0][n-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom itertools import accumulate\\n\\nclass Solution:\\n    \\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        n = len(stoneValue)\\n        dp = [[0]*n for _ in range(n)]\\n        left = [[0]*n for _ in range(n)]\\n        prefix = list(accumulate(stoneValue))\\n        prefix = [0]+prefix+[prefix[-1]]\\n\\n        def sum(i,j):\\n            return prefix[j+1]-prefix[i]\\n        \\n        row_idx = [i for i in range(n)]\\n        for i in range(n):\\n            left[i][i] = stoneValue[i]\\n        for d in range(1,n):\\n            for i in range(n-d):\\n                j = i+d\\n                while sum(i,row_idx[i]) < sum(row_idx[i]+1,j):\\n                    row_idx[i] +=1\\n                if sum(i, row_idx[i]) == sum(row_idx[i]+1,j):\\n                    dp[i][j] = max(left[i][row_idx[i]], left[j][row_idx[i]+1])\\n                else:\\n                    if row_idx[i] == i:\\n                        dp[i][j] = left[j][i+1]                    \\n                    elif row_idx[i] == j:\\n                        dp[i][j] = left[i][j-1]\\n                    else:\\n                        dp[i][j] = max(left[i][row_idx[i]-1], left[j][row_idx[i]+1])\\n                left[j][i] = max(left[j][i+1],sum(i,j)+dp[i][j])\\n                left[i][j] = max(left[i][j-1],sum(i,j)+dp[i][j])\\n        return dp[0][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840320,
                "title": "ruby-solution-beats-100-100",
                "content": "```\\n# @param {Integer[]} stone_value\\n# @return {Integer}\\ndef stone_game_v(stone_value)\\n  @a = stone_value\\n  n = stone_value.size\\n  x = 0\\n  @sum = stone_value.map { x += _1 } << 0\\n  @mem = Array.new(n) { |i| Array.new(n) { |j| 0 if i == j } }\\n  f(0, n - 1)\\nend\\n\\ndef f(x, y)\\n  @mem[x][y] ||=\\n    begin\\n        ans = 0\\n        (x...y).each do |z|\\n          sumz = @sum[z]\\n          s1 = sumz - @sum[x - 1]\\n          s2 = @sum[y] - sumz\\n          t =\\n            case s1 <=> s2\\n            when -1 then \\n                ans < s1 + maxf(x, z) ? s1 + f(x, z) : 0\\n            when 1 then \\n                ans < s2 + maxf(z + 1, y) ? s2 + f(z + 1, y) : 0\\n            when 0 then \\n                ans < s1 + s1 + mx(maxf(x, z), maxf(z + 1, y)) ? s1 + mx(f(x, z), f(z + 1, y)) : 0\\n            end\\n          ans = t if ans < t\\n        end\\n        ans\\n    end\\nend\\n            \\ndef maxf(x, z)\\n  s = @sum[z] - @sum[x - 1]\\n  t = 0\\n  t += (s /= 2) while s > 0\\n  t\\nend\\n\\ndef mx(x, y)\\n  x < y ? y : x\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} stone_value\\n# @return {Integer}\\ndef stone_game_v(stone_value)\\n  @a = stone_value\\n  n = stone_value.size\\n  x = 0\\n  @sum = stone_value.map { x += _1 } << 0\\n  @mem = Array.new(n) { |i| Array.new(n) { |j| 0 if i == j } }\\n  f(0, n - 1)\\nend\\n\\ndef f(x, y)\\n  @mem[x][y] ||=\\n    begin\\n        ans = 0\\n        (x...y).each do |z|\\n          sumz = @sum[z]\\n          s1 = sumz - @sum[x - 1]\\n          s2 = @sum[y] - sumz\\n          t =\\n            case s1 <=> s2\\n            when -1 then \\n                ans < s1 + maxf(x, z) ? s1 + f(x, z) : 0\\n            when 1 then \\n                ans < s2 + maxf(z + 1, y) ? s2 + f(z + 1, y) : 0\\n            when 0 then \\n                ans < s1 + s1 + mx(maxf(x, z), maxf(z + 1, y)) ? s1 + mx(f(x, z), f(z + 1, y)) : 0\\n            end\\n          ans = t if ans < t\\n        end\\n        ans\\n    end\\nend\\n            \\ndef maxf(x, z)\\n  s = @sum[z] - @sum[x - 1]\\n  t = 0\\n  t += (s /= 2) while s > 0\\n  t\\nend\\n\\ndef mx(x, y)\\n  x < y ? y : x\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1797304,
                "title": "python-dp-o-n-2-solution",
                "content": "This is a python implementation of the idea explained by \\'XavierWantMoreMoney\\' in the post below.\\nI suggest you also read through his post to understand the logic thoroughly.\\n\\nhttps://leetcode.com/problems/stone-game-v/discuss/1754938/O(N2)-A-(hopefully)-confusion-free-intuitive-explanation\\n\\nThe main idea can be listed as following steps. But the implementation can be quite tricky for 45min interview.\\n\\n1) Find the pivot point for every [l, r] substring, store them in a matrix for O(1) access.\\n- The pivot point is where the left_sum becomes more than the right_sum.\\n- For any i between [l, p), it is guaranteed to take the left substring\\n- For any i between (p, r] (or [p, r] in the case of left_sum == right_sum), it is guaranteed to take the right substring\\n\\n2) Based on the pivot point matrix, we now need another two utility matrices left_best and right_best, the purpose is for O(1) access of the max result for i in [l, p) and (p, r], respectively\\n- These two matrices need to be updated along the dp iteration\\n\\n3) Now for the dp part\\n- dp[l][r] means the max result for subarray [l, r]\\n- dp[l][r] = max(left_best[l][p-1], right_best[p+1][r]) or (max(left_best[l][p-1], right_best[p][r] in the left-right-equal case)\\n- left_best[l][r] = max(left_best[l][r-1], dp[l][r] + sum(l, r)) records the max (dp[l][i] + sum(l,i)) for i in [l, r]\\n- right_best[l][r] = max(right_best[l+1][r], dp[l][r] + sum(l, r)) records the max (dp[i][r] + sum(i,r)) for i in [l, r]\\n\\n\\n\\n```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        presum = [0] + list(accumulate(stoneValue))\\n        N = len(stoneValue)\\n        \\n        pivot = [[0] * N for _ in range(N)]\\n        \\n        for i in range(N):\\n            for j in range(i, N):\\n                if i == j:\\n                    pivot[i][j] = i\\n                else:\\n                    summ = presum[j+1] - presum[i]\\n                    p = pivot[i][j-1]\\n                    while p < j:\\n                        left_summ = presum[p+1] - presum[i]\\n                        right_summ = summ - left_summ\\n                        if left_summ > right_summ: break\\n                        p += 1\\n                    pivot[i][j] = p\\n                    \\n                    \\n        dp = [[0] * N for _ in range(N)]\\n        left_best = [[0] * N for _ in range(N)]\\n        right_best = [[0] * N for _ in range(N)]\\n        \\n        for i in range(N):\\n            left_best[i][i] = right_best[i][i] = stoneValue[i]\\n             \\n        for r in range(N):\\n            for l in range(r-1, -1, -1):\\n                p = pivot[l][r]\\n                take_left = left_best[l][p-1] if p > l else 0\\n                if presum[p] - presum[l] == presum[r+1] - presum[p]:\\n                    take_right = right_best[p][r]\\n                else:\\n                    take_right = right_best[p+1][r] if p < r else 0\\n                dp[l][r] = max(take_left, take_right)\\n                left_best[l][r] = max(left_best[l][r-1], dp[l][r] + presum[r+1] - presum[l])\\n                right_best[l][r] = max(right_best[l+1][r], dp[l][r] + presum[r+1] - presum[l])\\n                # print(l, r, dp[l][r], left_best[l][r], right_best[l][r])\\n        \\n        return dp[0][N-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGameV(self, stoneValue: List[int]) -> int:\\n        presum = [0] + list(accumulate(stoneValue))\\n        N = len(stoneValue)\\n        \\n        pivot = [[0] * N for _ in range(N)]\\n        \\n        for i in range(N):\\n            for j in range(i, N):\\n                if i == j:\\n                    pivot[i][j] = i\\n                else:\\n                    summ = presum[j+1] - presum[i]\\n                    p = pivot[i][j-1]\\n                    while p < j:\\n                        left_summ = presum[p+1] - presum[i]\\n                        right_summ = summ - left_summ\\n                        if left_summ > right_summ: break\\n                        p += 1\\n                    pivot[i][j] = p\\n                    \\n                    \\n        dp = [[0] * N for _ in range(N)]\\n        left_best = [[0] * N for _ in range(N)]\\n        right_best = [[0] * N for _ in range(N)]\\n        \\n        for i in range(N):\\n            left_best[i][i] = right_best[i][i] = stoneValue[i]\\n             \\n        for r in range(N):\\n            for l in range(r-1, -1, -1):\\n                p = pivot[l][r]\\n                take_left = left_best[l][p-1] if p > l else 0\\n                if presum[p] - presum[l] == presum[r+1] - presum[p]:\\n                    take_right = right_best[p][r]\\n                else:\\n                    take_right = right_best[p+1][r] if p < r else 0\\n                dp[l][r] = max(take_left, take_right)\\n                left_best[l][r] = max(left_best[l][r-1], dp[l][r] + presum[r+1] - presum[l])\\n                right_best[l][r] = max(right_best[l+1][r], dp[l][r] + presum[r+1] - presum[l])\\n                # print(l, r, dp[l][r], left_best[l][r], right_best[l][r])\\n        \\n        return dp[0][N-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708814,
                "title": "c-easy-solution",
                "content": "```\\nint dp[501][501];\\nclass Solution {\\npublic:\\n    int solve(int s, int e, vector<int> &v)\\n    {\\n        if(s>e)\\n        return 0;\\n        if(dp[s][e] != -1)\\n        return dp[s][e];\\n        int r = 0;\\n        for(int i=s; i<=e; i++)\\n        {\\n            r += v[i];\\n        }\\n        int l = 0;\\n        int ans = 0;\\n        for(int i = s; i<e; i++)\\n        {\\n            l += v[i];\\n            r -= v[i];\\n            if(l<r)\\n            ans = max(ans, l+solve(s, i, v));\\n            if(l == r)\\n            ans = max(ans, l+max(solve(s, i, v), solve(i+1, e, v)));\\n            if(l>r)\\n            ans = max(ans, r+solve(i+1, e, v));\\n        }\\n        return dp[s][e] = ans;\\n    }\\n    int stoneGameV(vector<int>& s) {\\n        memset(dp, -1, sizeof(dp));\\n        int n = s.size();\\n        return solve(0, n-1, s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint dp[501][501];\\nclass Solution {\\npublic:\\n    int solve(int s, int e, vector<int> &v)\\n    {\\n        if(s>e)\\n        return 0;\\n        if(dp[s][e] != -1)\\n        return dp[s][e];\\n        int r = 0;\\n        for(int i=s; i<=e; i++)\\n        {\\n            r += v[i];\\n        }\\n        int l = 0;\\n        int ans = 0;\\n        for(int i = s; i<e; i++)\\n        {\\n            l += v[i];\\n            r -= v[i];\\n            if(l<r)\\n            ans = max(ans, l+solve(s, i, v));\\n            if(l == r)\\n            ans = max(ans, l+max(solve(s, i, v), solve(i+1, e, v)));\\n            if(l>r)\\n            ans = max(ans, r+solve(i+1, e, v));\\n        }\\n        return dp[s][e] = ans;\\n    }\\n    int stoneGameV(vector<int>& s) {\\n        memset(dp, -1, sizeof(dp));\\n        int n = s.size();\\n        return solve(0, n-1, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707558,
                "title": "java-easy-dp-solution-with-comments",
                "content": "```\\nclass Solution {\\n    private int solve(int i,int n,int sum,int[] nums,int[][] dp){\\n        if(i==n) // if only one element in the array.\\n            return 0;\\n        if(dp[i][n]!=-1)\\n            return dp[i][n];\\n        int temp=0,ans=0; // temp will store the sum of the first array and ans will store the maximum ans found.\\n        for(int j=i;j<=n;j++){ // putting the partion of the array starting from the starting index to the ending index\\n            temp+=nums[j]; // sum of the first half of the array.\\n            if(temp>sum-temp){ // if the sum of first half is greater so alice will take the second array sum and send that array for further calculations.\\n                ans=Math.max(ans,sum-temp+solve(j+1,n,sum-temp,nums,dp));\\n            }else if(temp<sum-temp){ // if the first half is lesser o alice will take that.\\n                ans=Math.max(ans,temp+solve(i,j,temp,nums,dp));\\n            }else{ // if the sum of both the array is same then alice will try both the arrays and take the maximum one.\\n                ans=Math.max(ans,sum-temp+solve(j+1,n,sum-temp,nums,dp));\\n                ans=Math.max(ans,temp+solve(i,j,temp,nums,dp));\\n            }\\n        }\\n        return dp[i][n]=ans;\\n    }\\n    public int stoneGameV(int[] stoneValue) {\\n        int sum=0;\\n        for(int ele:stoneValue)\\n            sum+=ele; // Calculating the sum of the whole array.\\n        int[][] dp=new int[stoneValue.length+1][stoneValue.length+1];\\n        for(int[] arr:dp)\\n            Arrays.fill(arr,-1);\\n        return solve(0,stoneValue.length-1,sum,stoneValue,dp); // 0 is the starting and n-1 the end of each array.\\n    }\\n}\\n```\\nHope i was able to explain.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private int solve(int i,int n,int sum,int[] nums,int[][] dp){\\n        if(i==n) // if only one element in the array.\\n            return 0;\\n        if(dp[i][n]!=-1)\\n            return dp[i][n];\\n        int temp=0,ans=0; // temp will store the sum of the first array and ans will store the maximum ans found.\\n        for(int j=i;j<=n;j++){ // putting the partion of the array starting from the starting index to the ending index\\n            temp+=nums[j]; // sum of the first half of the array.\\n            if(temp>sum-temp){ // if the sum of first half is greater so alice will take the second array sum and send that array for further calculations.\\n                ans=Math.max(ans,sum-temp+solve(j+1,n,sum-temp,nums,dp));\\n            }else if(temp<sum-temp){ // if the first half is lesser o alice will take that.\\n                ans=Math.max(ans,temp+solve(i,j,temp,nums,dp));\\n            }else{ // if the sum of both the array is same then alice will try both the arrays and take the maximum one.\\n                ans=Math.max(ans,sum-temp+solve(j+1,n,sum-temp,nums,dp));\\n                ans=Math.max(ans,temp+solve(i,j,temp,nums,dp));\\n            }\\n        }\\n        return dp[i][n]=ans;\\n    }\\n    public int stoneGameV(int[] stoneValue) {\\n        int sum=0;\\n        for(int ele:stoneValue)\\n            sum+=ele; // Calculating the sum of the whole array.\\n        int[][] dp=new int[stoneValue.length+1][stoneValue.length+1];\\n        for(int[] arr:dp)\\n            Arrays.fill(arr,-1);\\n        return solve(0,stoneValue.length-1,sum,stoneValue,dp); // 0 is the starting and n-1 the end of each array.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702134,
                "title": "c-top-down-dp-very-intuitive",
                "content": "```\\nint rec(vector<int> &v, vector<int> &pref, int l, int r, vector<vector<int>> &dp)\\n{\\n    if (l == r)\\n    {\\n        return 0;\\n    }\\n    if (dp[l][r] != -1)\\n    {\\n        return dp[l][r];\\n    }\\n    int ans = 0;\\n\\n    for (int i = l; i < r; i++)\\n    {\\n        int score1 = pref[i] - (l == 0 ? 0 : pref[l - 1]);\\n        int score2 = pref[r] - pref[i];\\n        if (score1 < score2)\\n        {\\n            ans = max(ans, score1 + rec(v, pref, l, i, dp));\\n        }\\n        else if (score1 > score2)\\n        {\\n            ans = max(ans, score2 + rec(v, pref, i + 1, r, dp));\\n        }\\n        else\\n        {\\n            ans = max(ans, score1 + max(rec(v, pref, l, i, dp), rec(v, pref, i + 1, r, dp)));\\n        }\\n    }\\n    return dp[l][r] = ans;\\n}\\n\\nint stoneGameV(vector<int> &v)\\n{\\n    int n = (int)v.size();\\n    vector<int> pref(n);\\n    for (int i = 0; i < n; i++)\\n    {\\n        pref[i] = (i == 0 ? 0 : pref[i - 1]) + v[i];\\n    }\\n    vector<vector<int>> dp(n, vector<int>(n, -1));\\n    return rec(v, pref, 0, n - 1, dp);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint rec(vector<int> &v, vector<int> &pref, int l, int r, vector<vector<int>> &dp)\\n{\\n    if (l == r)\\n    {\\n        return 0;\\n    }\\n    if (dp[l][r] != -1)\\n    {\\n        return dp[l][r];\\n    }\\n    int ans = 0;\\n\\n    for (int i = l; i < r; i++)\\n    {\\n        int score1 = pref[i] - (l == 0 ? 0 : pref[l - 1]);\\n        int score2 = pref[r] - pref[i];\\n        if (score1 < score2)\\n        {\\n            ans = max(ans, score1 + rec(v, pref, l, i, dp));\\n        }\\n        else if (score1 > score2)\\n        {\\n            ans = max(ans, score2 + rec(v, pref, i + 1, r, dp));\\n        }\\n        else\\n        {\\n            ans = max(ans, score1 + max(rec(v, pref, l, i, dp), rec(v, pref, i + 1, r, dp)));\\n        }\\n    }\\n    return dp[l][r] = ans;\\n}\\n\\nint stoneGameV(vector<int> &v)\\n{\\n    int n = (int)v.size();\\n    vector<int> pref(n);\\n    for (int i = 0; i < n; i++)\\n    {\\n        pref[i] = (i == 0 ? 0 : pref[i - 1]) + v[i];\\n    }\\n    vector<vector<int>> dp(n, vector<int>(n, -1));\\n    return rec(v, pref, 0, n - 1, dp);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1643906,
                "title": "javascript-o-n-3",
                "content": "\\n\\n**Basic approach**  O(n^3)\\n\\ndp[i][j]: max score you can obtain from stones[i..j]\\nsum[i][j]: sum of stoneValues[i..j]\\nTry all possible k i.e. k goes from i to j-1:\\nwe have 2 choices for score: sum[i][k] + dp[i][k] and sum[k+1][j] + dp[k+1][j]\\nbut we can only pick the side where sum is smaller or either of them when both sides are equal.\\nTake the maximum score from all of these choices and we have computed dp[i][j].\\nIn all my codes, I am building the dp table bottom-up i.e. dp[0][1], dp[1][2] gets calculated before dp[0][2].\\n\\n```\\nvar stoneGameV = function(stoneValue) {\\n  let n = stoneValue.length;\\n  const pre = new Array(n + 1).fill(0);\\n  for (let i = 1; i <= n; i++) {\\n    pre[i] = pre[i - 1] + stoneValue[i - 1];\\n  }\\n  const dp = [...Array(n).fill(null)].map((_) => new Array(n).fill(0));\\n  for (let l = 1; l < n; l++) {\\n    for (let i = 0; i < n - l; i++) {\\n      let j = i + l,\\n        res = 0;\\n      for (let k = i; k < j; k++) {\\n        let left = pre[k + 1] - pre[i],\\n          right = pre[j + 1] - pre[k + 1];\\n        if (left < right) {\\n          res = Math.max(res, left + dp[i][k]);\\n        } else if (left > right) {\\n          res = Math.max(res, right + dp[k + 1][j]);\\n        } else {\\n          res = Math.max(res, left + dp[i][k]);\\n          res = Math.max(res, right + dp[k + 1][j]);\\n        }\\n      }\\n      dp[i][j] = res;\\n    }\\n  }\\n  return dp[0][n - 1];\\n};\\n```\\n\\n\\n\\n**Optimization**  O(n^2)\\n\\nSuppose we know the k\\' for stones[i..j], what do we know about k\\' for stones[i..j+1]? It is either the same or it got shifted a few places to the right.\\nAnd so if we calculate dp values in the order: dp[i][i], dp[i][i+1], dp[i][i+2], ..., dp[i][j], we can essentially keep track of k\\' as we go within that same linear time bound.\\n\\nUsing this idea, we implement the final solution. Couple of pointers about my code:\\n\\nmid: represents k\\' or first index such that left half >= right half\\nwith i < j, max[i][j] represents left[i][j] of previous solution i.e. max(dp[i][i], dp[i][i+1], dp[i][i+2] .. dp[i][j]) and max[j][i] represents right[i][j] of previous solution i.e. max(dp[i][j], dp[i+1][j], dp[i+2][j] .. dp[j][j]). We could have used two different arrays left and right just like previous solution but this trick saves space.\\nI am traversing in the order: dp[j][j], dp[j-1,j], dp[j-2, j], .., dp[i][j] instead of the above mentioned order but the idea remains same.\\n\\n```\\n\\nvar stoneGameV = function(stoneValue) {\\n  let n = stoneValue.length;\\n  let dp = new Array(n).fill(null).map((_) => new Array(n).fill(0)),\\n    max = new Array(n).fill(null).map((_) => new Array(n).fill(0));\\n  for (let i = 0; i < n; i++) {\\n    max[i][i] = stoneValue[i];\\n  }\\n  for (let j = 1; j < n; j++) {\\n    let mid = j,\\n      sum = stoneValue[j],\\n      rightHalf = 0;\\n    for (let i = j - 1; i >= 0; i--) {\\n      sum += stoneValue[i];\\n      while ((rightHalf + stoneValue[mid]) * 2 <= sum) {\\n        rightHalf += stoneValue[mid--];\\n      }\\n      dp[i][j] =\\n        rightHalf * 2 == sum ? max[i][mid] : mid == i ? 0 : max[i][mid - 1];\\n      dp[i][j] = Math.max(dp[i][j], mid == j ? 0 : max[j][mid + 1]);\\n      max[i][j] = Math.max(max[i][j - 1], dp[i][j] + sum);\\n      max[j][i] = Math.max(max[j][i + 1], dp[i][j] + sum);\\n    }\\n  }\\n  return dp[0][n - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar stoneGameV = function(stoneValue) {\\n  let n = stoneValue.length;\\n  const pre = new Array(n + 1).fill(0);\\n  for (let i = 1; i <= n; i++) {\\n    pre[i] = pre[i - 1] + stoneValue[i - 1];\\n  }\\n  const dp = [...Array(n).fill(null)].map((_) => new Array(n).fill(0));\\n  for (let l = 1; l < n; l++) {\\n    for (let i = 0; i < n - l; i++) {\\n      let j = i + l,\\n        res = 0;\\n      for (let k = i; k < j; k++) {\\n        let left = pre[k + 1] - pre[i],\\n          right = pre[j + 1] - pre[k + 1];\\n        if (left < right) {\\n          res = Math.max(res, left + dp[i][k]);\\n        } else if (left > right) {\\n          res = Math.max(res, right + dp[k + 1][j]);\\n        } else {\\n          res = Math.max(res, left + dp[i][k]);\\n          res = Math.max(res, right + dp[k + 1][j]);\\n        }\\n      }\\n      dp[i][j] = res;\\n    }\\n  }\\n  return dp[0][n - 1];\\n};\\n```\n```\\n\\nvar stoneGameV = function(stoneValue) {\\n  let n = stoneValue.length;\\n  let dp = new Array(n).fill(null).map((_) => new Array(n).fill(0)),\\n    max = new Array(n).fill(null).map((_) => new Array(n).fill(0));\\n  for (let i = 0; i < n; i++) {\\n    max[i][i] = stoneValue[i];\\n  }\\n  for (let j = 1; j < n; j++) {\\n    let mid = j,\\n      sum = stoneValue[j],\\n      rightHalf = 0;\\n    for (let i = j - 1; i >= 0; i--) {\\n      sum += stoneValue[i];\\n      while ((rightHalf + stoneValue[mid]) * 2 <= sum) {\\n        rightHalf += stoneValue[mid--];\\n      }\\n      dp[i][j] =\\n        rightHalf * 2 == sum ? max[i][mid] : mid == i ? 0 : max[i][mid - 1];\\n      dp[i][j] = Math.max(dp[i][j], mid == j ? 0 : max[j][mid + 1]);\\n      max[i][j] = Math.max(max[i][j - 1], dp[i][j] + sum);\\n      max[j][i] = Math.max(max[j][i + 1], dp[i][j] + sum);\\n    }\\n  }\\n  return dp[0][n - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1638059,
                "title": "java-two-solutions-dp-memorization",
                "content": "Memorization\\n\\n```\\nclass Solution {\\n    public int trav(int store[],int i,int j,int dp[][])\\n    {\\n        if(j==i)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int ans=0,index=-1;\\n        for(int k=i;k<j;k++)\\n        {\\n            int left=store[k+1]-store[i];\\n            int right=store[j+1]-store[k+1];\\n            if(left>right)\\n            {\\n                ans=Math.max(ans,right+trav(store,k+1,j,dp));\\n            }\\n            else\\n            {\\n                if(right>left)\\n                {\\n                    ans=Math.max(ans,left+trav(store,i,k,dp));\\n                }\\n                else\\n                {\\n                    ans=Math.max(ans,Math.max(right+trav(store,k+1,j,dp),left+trav(store,i,k,dp)));\\n                }\\n            }\\n        }\\n        dp[i][j]=ans;\\n        return ans;\\n    }\\n    public int stoneGameV(int[] s) {\\n        int n=s.length;\\n        int store[]=new int[n+1];\\n        int dp[][]=new int[n+1][n+1];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                dp[i][j]=-1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            store[i]=s[i-1]+store[i-1];\\n        }\\n        return trav(store,0,n-1,dp);\\n    }\\n}\\n```\\n\\nDp Solution :\\n\\n```\\nclass Solution {\\n    public int find(int dp[][],int i,int j,int store[])\\n    {\\n        int ans=0;\\n        for(int k=i;k<j;k++)\\n        {\\n            int left=store[k+1]-store[i];\\n            int right=store[j+1]-store[k+1];\\n            if(left>right)\\n                ans=Math.max(ans,right+dp[k+1][j]);\\n            else\\n            {\\n                if(right>left)\\n                    ans=Math.max(ans,left+dp[i][k]);\\n                else\\n                    ans=Math.max(ans,Math.max(right+dp[k+1][j],left+dp[i][k]));\\n            }\\n        }\\n        return ans;\\n    }\\n    public int stoneGameV(int[] s) {\\n        int n=s.length;\\n        int store[]=new int[n+1];\\n        int dp[][]=new int[n+1][n+1];\\n        for(int i=1;i<=n;i++)\\n        {\\n            store[i]=s[i-1]+store[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                dp[i][j]=find(dp,i,j,store);\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int trav(int store[],int i,int j,int dp[][])\\n    {\\n        if(j==i)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int ans=0,index=-1;\\n        for(int k=i;k<j;k++)\\n        {\\n            int left=store[k+1]-store[i];\\n            int right=store[j+1]-store[k+1];\\n            if(left>right)\\n            {\\n                ans=Math.max(ans,right+trav(store,k+1,j,dp));\\n            }\\n            else\\n            {\\n                if(right>left)\\n                {\\n                    ans=Math.max(ans,left+trav(store,i,k,dp));\\n                }\\n                else\\n                {\\n                    ans=Math.max(ans,Math.max(right+trav(store,k+1,j,dp),left+trav(store,i,k,dp)));\\n                }\\n            }\\n        }\\n        dp[i][j]=ans;\\n        return ans;\\n    }\\n    public int stoneGameV(int[] s) {\\n        int n=s.length;\\n        int store[]=new int[n+1];\\n        int dp[][]=new int[n+1][n+1];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                dp[i][j]=-1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            store[i]=s[i-1]+store[i-1];\\n        }\\n        return trav(store,0,n-1,dp);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int find(int dp[][],int i,int j,int store[])\\n    {\\n        int ans=0;\\n        for(int k=i;k<j;k++)\\n        {\\n            int left=store[k+1]-store[i];\\n            int right=store[j+1]-store[k+1];\\n            if(left>right)\\n                ans=Math.max(ans,right+dp[k+1][j]);\\n            else\\n            {\\n                if(right>left)\\n                    ans=Math.max(ans,left+dp[i][k]);\\n                else\\n                    ans=Math.max(ans,Math.max(right+dp[k+1][j],left+dp[i][k]));\\n            }\\n        }\\n        return ans;\\n    }\\n    public int stoneGameV(int[] s) {\\n        int n=s.length;\\n        int store[]=new int[n+1];\\n        int dp[][]=new int[n+1][n+1];\\n        for(int i=1;i<=n;i++)\\n        {\\n            store[i]=s[i-1]+store[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                dp[i][j]=find(dp,i,j,store);\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599969,
                "title": "java-clean-and-detailed-dp-memoization-prefix-sum-solution",
                "content": "```\\nclass Solution {\\n    public int[] pre;\\n    public int[][] dp;\\n    public int stoneGameV(int[] stoneValue) {\\n        pre = new int[stoneValue.length];\\n        pre[0] = stoneValue[0];\\n        for(int i = 1; i < pre.length; i++)\\n            pre[i] = pre[i - 1] + stoneValue[i];        \\n        dp = new int[stoneValue.length][stoneValue.length];\\n        return find(stoneValue, 0, stoneValue.length - 1);\\n    }\\n    \\n    public int find(int[] values, int si, int ei){\\n        if(si == ei)\\n            return 0;\\n        if(dp[si][ei] != 0)\\n            return dp[si][ei];        \\n        int max = Integer.MIN_VALUE;\\n        for(int i = si; i < ei; i++){\\n            int left = pre[i] - (si == 0 ? 0: pre[si - 1]);\\n            int right = pre[ei] - pre[i];\\n            if(left > right)\\n                max = Math.max(max, right + find(values, i + 1, ei));\\n            else if(left < right)\\n                max = Math.max(max, left + find(values, si, i));\\n            else\\n                max = Math.max(max, Math.max(left + find(values, si, i), right + find(values, i + 1, ei)));\\n        }\\n        return dp[si][ei] = max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pre;\\n    public int[][] dp;\\n    public int stoneGameV(int[] stoneValue) {\\n        pre = new int[stoneValue.length];\\n        pre[0] = stoneValue[0];\\n        for(int i = 1; i < pre.length; i++)\\n            pre[i] = pre[i - 1] + stoneValue[i];        \\n        dp = new int[stoneValue.length][stoneValue.length];\\n        return find(stoneValue, 0, stoneValue.length - 1);\\n    }\\n    \\n    public int find(int[] values, int si, int ei){\\n        if(si == ei)\\n            return 0;\\n        if(dp[si][ei] != 0)\\n            return dp[si][ei];        \\n        int max = Integer.MIN_VALUE;\\n        for(int i = si; i < ei; i++){\\n            int left = pre[i] - (si == 0 ? 0: pre[si - 1]);\\n            int right = pre[ei] - pre[i];\\n            if(left > right)\\n                max = Math.max(max, right + find(values, i + 1, ei));\\n            else if(left < right)\\n                max = Math.max(max, left + find(values, si, i));\\n            else\\n                max = Math.max(max, Math.max(left + find(values, si, i), right + find(values, i + 1, ei)));\\n        }\\n        return dp[si][ei] = max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598368,
                "title": "java-2d-top-down-dp-prefix-suffixsum-with-explanation",
                "content": "Personally I found this hard problem easier than some of the medium stone games problems. Game Theory is not involved because Bob just discards the bigger part of the array, so basically we just want to iterate through all the possibilities and find the maximum outcome, and in order to do this effeciently, we need to use DP. \\n\\nPrefix/SuffixSum array comes in great help with this. If you know how to do https://leetcode.com/problems/stone-game-vii/, then this problem should be of no issue for you. Just remember to add a 0 in the end for the prefix/suffix sum array so that we have the option to keep the first/last array element.\\n\\n```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int N = stoneValue.length;\\n        int[][] dp = new int[N][N+1]; //have to add 1 here because the way we set up suffix sum array\\n\\n        int[] prefixSum = new int[N + 1]; //add 1 space for the last spot to be 0 (also it should be named suffixsum)\\n        for (int i = N - 1; i >= 0; --i) \\n            prefixSum[i] += (prefixSum[i + 1] + stoneValue[i]);\\n\\n        getMax(prefixSum, 0, N, dp);\\n        return dp[0][N];\\n    }\\n\\n    private int getMax(int[] pSum, int lo, int hi, int[][] dp){\\n        if (lo >= hi - 1) return 0; //one stone remaining, terminate.\\n        if (dp[lo][hi] != 0) return dp[lo][hi];\\n\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 1; lo + i < hi; i++){\\n            int r = pSum[lo + i] - pSum[hi];\\n            int l = pSum[lo] - pSum[lo + i];\\n            if (r > l) max = Math.max(l + getMax(pSum, lo, lo + i, dp), max); //discard r portion\\n            if (r < l) max = Math.max(r + getMax(pSum, lo + i, hi, dp), max); //discard l portion\\n            if (r == l){\\n                int left = getMax(pSum, lo, lo + i, dp) + r;\\n                int right= getMax(pSum, lo + i, hi, dp) + l;\\n                max = Math.max(max, Math.max(right, left)); //Alice chooses the maximum option when r == l\\n            }\\n        }\\n\\n        return dp[lo][hi] = max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int N = stoneValue.length;\\n        int[][] dp = new int[N][N+1]; //have to add 1 here because the way we set up suffix sum array\\n\\n        int[] prefixSum = new int[N + 1]; //add 1 space for the last spot to be 0 (also it should be named suffixsum)\\n        for (int i = N - 1; i >= 0; --i) \\n            prefixSum[i] += (prefixSum[i + 1] + stoneValue[i]);\\n\\n        getMax(prefixSum, 0, N, dp);\\n        return dp[0][N];\\n    }\\n\\n    private int getMax(int[] pSum, int lo, int hi, int[][] dp){\\n        if (lo >= hi - 1) return 0; //one stone remaining, terminate.\\n        if (dp[lo][hi] != 0) return dp[lo][hi];\\n\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 1; lo + i < hi; i++){\\n            int r = pSum[lo + i] - pSum[hi];\\n            int l = pSum[lo] - pSum[lo + i];\\n            if (r > l) max = Math.max(l + getMax(pSum, lo, lo + i, dp), max); //discard r portion\\n            if (r < l) max = Math.max(r + getMax(pSum, lo + i, hi, dp), max); //discard l portion\\n            if (r == l){\\n                int left = getMax(pSum, lo, lo + i, dp) + r;\\n                int right= getMax(pSum, lo + i, hi, dp) + l;\\n                max = Math.max(max, Math.max(right, left)); //Alice chooses the maximum option when r == l\\n            }\\n        }\\n\\n        return dp[lo][hi] = max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575784,
                "title": "c-dp-real-o-n-2-35ms",
                "content": "This is the first easy version. It\\'s o(N^3)\\n```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size(); \\n        int dp[501][501] = {0};\\n        int prefix[501] = {0};\\n        for(int i=0; i<n; i++)\\n            prefix[i+1] = prefix[i]+stoneValue[i];\\n        if (n==1)\\n            return 0; \\n        for(int k=1; k<n; k++) \\n        {\\n            for(int i=0; i<n-k; i++)     \\n            {\\n                int j = i+k+1; \\n                int c = i+1;\\n                int maxv = 0;\\n                while(c<j)\\n                {\\n                    int sumi2c = prefix[c] - prefix[i];\\n                    int sumc2j = prefix[j] - prefix[c];\\n                    int v = 0;\\n                    if (sumi2c >= sumc2j)\\n                        maxv = max(maxv, dp[c][j] + sumc2j);\\n                    if (sumi2c <= sumc2j)\\n                        maxv = max(maxv, dp[i][c] + sumi2c);\\n                    c++;\\n                }\\n                dp[i][j] = maxv;\\n            }\\n        }\\n        return dp[0][n];\\n    }\\n```\\nyou can merge dp[c][j] + sumc2j as newdp[c][j]\\nand dp[i][c] + sumi2c as newdp[i][c]\\n```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size(); \\n        int dp[501][501] = {0};\\n        int prefix[501] = {0};\\n        for(int i=0; i<n; i++)\\n        {\\n            dp[i][i+1] = stoneValue[i];\\n            prefix[i+1] = prefix[i]+stoneValue[i];\\n        }\\n        if (n==1)\\n            return 0; \\n        for(int k=1; k<n; k++) \\n        {\\n            for(int i=0; i<n-k; i++)     \\n            {\\n                int j = i+k+1; \\n                int c = i+1;\\n                int maxv = 0;\\n                while(c<j)\\n                {\\n                    int sumi2c = prefix[c] - prefix[i];\\n                    int sumc2j = prefix[j] - prefix[c];\\n                    int v = 0;\\n                    if (sumi2c >= sumc2j)\\n                        maxv = max(maxv, dp[c][j]);\\n                    if (sumi2c <= sumc2j)\\n                        maxv = max(maxv, dp[i][c]);\\n                    c++;\\n                }\\n                if (k==n-1)\\n                    return maxv;\\n                dp[i][j] = maxv + prefix[j] - prefix[i];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\nWe can find the first index c between [i, j) and the sum from [i,c) >= the sum from [c,j)\\nIt is easy to show all k < c we have sum from [i,k) < sum from [k,j)\\nand all k > c  we have sum from [i,k) > sum from [k,j)\\nWe can find c in O(1) by using extra array index and the code is shown as below\\n\\n```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size(); \\n        int dp[501][501] = {0};\\n        int prefix[501] = {0};\\n        int index[501] = {0};\\n        for(int i=0; i<n; i++)\\n        {\\n            dp[i][i+1] = stoneValue[i];\\n            index[i] = i+1;\\n            prefix[i+1] = prefix[i]+stoneValue[i];\\n        }\\n        if (n==1)\\n            return 0; \\n        for(int k=1; k<n; k++) \\n        {\\n            for(int i=0; i<n-k; i++)     \\n            {\\n                int j = i+k+1; \\n                int sumi2j = prefix[j] - prefix[i];\\n                //index[i] is first index in [i~j) in which sum[i~index[i])>=sum[index[i]~j)\\n                int c = index[i];\\n                int maxv = 0;\\n                int sumi2c, sumc2j;\\n                while(c<j)\\n                {\\n                    sumi2c = prefix[c] - prefix[i];\\n                    sumc2j = prefix[j] - prefix[c];\\n                    if (sumi2c >= sumc2j)\\n                        break;\\n                    c++;\\n                }\\n                index[i] = c;\\n                if (c<j)//we have found the index in which sum[i~c)>=sum[c~j)\\n                {\\n                    for(int p=c; p<j; p++)\\n                        maxv = max(maxv, dp[p][j]);\\n                }\\n                if (sumi2c == sumc2j)\\n                    c++;\\n                for(int p=i+1; p<=c-1; p++)\\n                    maxv = max(maxv, dp[i][p]);\\n                if (k==n-1)\\n                    return maxv;\\n                dp[i][j] = maxv + sumi2j;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\nThis code give Runtime: 196 ms, faster than 94.35% of C++ online submissions for Stone Game V(it\\'s still O(N^3)). But we can simplify it again\\nWe set dp1[i][j] as min_p{dp[p][j]} for all p in (i,j) and dp2 as min_p{dp[i][p]} for all p in (i,j).\\nThis loop \\n```\\n                    for(int p=c; p<j; p++)\\n                        maxv = max(maxv, dp[p][j]);\\n```\\nwill be reduced as maxv = max(maxv, dp2[c][j]);\\nsame as another loop. dp1 and dp2 shold be updated in each iteration.\\n```\\ndp1[i][p] = max(dp[i][p-1], maxv + sumi2p);\\ndp2[p][j] = max(dp[p+1][j], maxv + sump2j);\\n```\\nFinally we put dp1 and dp2 to single dp. And set dp[j][p] = dp2[p][j], dp[i][p]=dp1[i][p]. Final version is O(N^2)\\n```\\nclass Solution {\\npublic:\\n    //dp[i,j] is \"max stone value + sum[i,c)\" in [i,c) in which Alice could get \\n    //i<c<j\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size(); \\n        int dp[501][501] = {0};\\n        int index[501] = {0};\\n        int prefix[501] = {0};\\n        for(int i=0; i<n; i++)\\n        {\\n            dp[i+1][i] = dp[i][i+1] = stoneValue[i];\\n            index[i] = i+1;\\n            prefix[i+1] = prefix[i]+stoneValue[i];\\n        }\\n        if (n==1)\\n            return 0; \\n        for(int k=1; k<n; k++) \\n        {\\n            for(int i=0; i<n-k; i++)     \\n            {\\n                int j = i+k+1; \\n                int sumi2j = prefix[j] - prefix[i];\\n                //index[i] is first index in [i~j) in which sum[i~index[i])>=sum[index[i]~j)\\n                int c = index[i];\\n                int maxv = 0;\\n                int sumi2c, sumc2j;\\n                while(c<j)\\n                {\\n                    sumi2c = prefix[c] - prefix[i];\\n                    sumc2j = prefix[j] - prefix[c];\\n                    if (sumi2c >= sumc2j)\\n                        break;\\n                    c++;\\n                }\\n                index[i] = c;\\n                if (c<j)\\n                    maxv = max(maxv, dp[j][c]);\\n                if (sumi2c == sumc2j)\\n                    c++;\\n                maxv = max(maxv, dp[i][c-1]);\\n                if (k==n-1)\\n                    return maxv;\\n                dp[i][j] = max(dp[i][j-1], maxv + sumi2j);\\n                dp[j][i] = max(dp[j][i+1], maxv + sumi2j);\\n            }\\n        }\\n        return 0; \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size(); \\n        int dp[501][501] = {0};\\n        int prefix[501] = {0};\\n        for(int i=0; i<n; i++)\\n            prefix[i+1] = prefix[i]+stoneValue[i];\\n        if (n==1)\\n            return 0; \\n        for(int k=1; k<n; k++) \\n        {\\n            for(int i=0; i<n-k; i++)     \\n            {\\n                int j = i+k+1; \\n                int c = i+1;\\n                int maxv = 0;\\n                while(c<j)\\n                {\\n                    int sumi2c = prefix[c] - prefix[i];\\n                    int sumc2j = prefix[j] - prefix[c];\\n                    int v = 0;\\n                    if (sumi2c >= sumc2j)\\n                        maxv = max(maxv, dp[c][j] + sumc2j);\\n                    if (sumi2c <= sumc2j)\\n                        maxv = max(maxv, dp[i][c] + sumi2c);\\n                    c++;\\n                }\\n                dp[i][j] = maxv;\\n            }\\n        }\\n        return dp[0][n];\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size(); \\n        int dp[501][501] = {0};\\n        int prefix[501] = {0};\\n        for(int i=0; i<n; i++)\\n        {\\n            dp[i][i+1] = stoneValue[i];\\n            prefix[i+1] = prefix[i]+stoneValue[i];\\n        }\\n        if (n==1)\\n            return 0; \\n        for(int k=1; k<n; k++) \\n        {\\n            for(int i=0; i<n-k; i++)     \\n            {\\n                int j = i+k+1; \\n                int c = i+1;\\n                int maxv = 0;\\n                while(c<j)\\n                {\\n                    int sumi2c = prefix[c] - prefix[i];\\n                    int sumc2j = prefix[j] - prefix[c];\\n                    int v = 0;\\n                    if (sumi2c >= sumc2j)\\n                        maxv = max(maxv, dp[c][j]);\\n                    if (sumi2c <= sumc2j)\\n                        maxv = max(maxv, dp[i][c]);\\n                    c++;\\n                }\\n                if (k==n-1)\\n                    return maxv;\\n                dp[i][j] = maxv + prefix[j] - prefix[i];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size(); \\n        int dp[501][501] = {0};\\n        int prefix[501] = {0};\\n        int index[501] = {0};\\n        for(int i=0; i<n; i++)\\n        {\\n            dp[i][i+1] = stoneValue[i];\\n            index[i] = i+1;\\n            prefix[i+1] = prefix[i]+stoneValue[i];\\n        }\\n        if (n==1)\\n            return 0; \\n        for(int k=1; k<n; k++) \\n        {\\n            for(int i=0; i<n-k; i++)     \\n            {\\n                int j = i+k+1; \\n                int sumi2j = prefix[j] - prefix[i];\\n                //index[i] is first index in [i~j) in which sum[i~index[i])>=sum[index[i]~j)\\n                int c = index[i];\\n                int maxv = 0;\\n                int sumi2c, sumc2j;\\n                while(c<j)\\n                {\\n                    sumi2c = prefix[c] - prefix[i];\\n                    sumc2j = prefix[j] - prefix[c];\\n                    if (sumi2c >= sumc2j)\\n                        break;\\n                    c++;\\n                }\\n                index[i] = c;\\n                if (c<j)//we have found the index in which sum[i~c)>=sum[c~j)\\n                {\\n                    for(int p=c; p<j; p++)\\n                        maxv = max(maxv, dp[p][j]);\\n                }\\n                if (sumi2c == sumc2j)\\n                    c++;\\n                for(int p=i+1; p<=c-1; p++)\\n                    maxv = max(maxv, dp[i][p]);\\n                if (k==n-1)\\n                    return maxv;\\n                dp[i][j] = maxv + sumi2j;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\n                    for(int p=c; p<j; p++)\\n                        maxv = max(maxv, dp[p][j]);\\n```\n```\\ndp1[i][p] = max(dp[i][p-1], maxv + sumi2p);\\ndp2[p][j] = max(dp[p+1][j], maxv + sump2j);\\n```\n```\\nclass Solution {\\npublic:\\n    //dp[i,j] is \"max stone value + sum[i,c)\" in [i,c) in which Alice could get \\n    //i<c<j\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n = stoneValue.size(); \\n        int dp[501][501] = {0};\\n        int index[501] = {0};\\n        int prefix[501] = {0};\\n        for(int i=0; i<n; i++)\\n        {\\n            dp[i+1][i] = dp[i][i+1] = stoneValue[i];\\n            index[i] = i+1;\\n            prefix[i+1] = prefix[i]+stoneValue[i];\\n        }\\n        if (n==1)\\n            return 0; \\n        for(int k=1; k<n; k++) \\n        {\\n            for(int i=0; i<n-k; i++)     \\n            {\\n                int j = i+k+1; \\n                int sumi2j = prefix[j] - prefix[i];\\n                //index[i] is first index in [i~j) in which sum[i~index[i])>=sum[index[i]~j)\\n                int c = index[i];\\n                int maxv = 0;\\n                int sumi2c, sumc2j;\\n                while(c<j)\\n                {\\n                    sumi2c = prefix[c] - prefix[i];\\n                    sumc2j = prefix[j] - prefix[c];\\n                    if (sumi2c >= sumc2j)\\n                        break;\\n                    c++;\\n                }\\n                index[i] = c;\\n                if (c<j)\\n                    maxv = max(maxv, dp[j][c]);\\n                if (sumi2c == sumc2j)\\n                    c++;\\n                maxv = max(maxv, dp[i][c-1]);\\n                if (k==n-1)\\n                    return maxv;\\n                dp[i][j] = max(dp[i][j-1], maxv + sumi2j);\\n                dp[j][i] = max(dp[j][i+1], maxv + sumi2j);\\n            }\\n        }\\n        return 0; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526466,
                "title": "java-basic-dp",
                "content": "```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int[] pre = new int[stoneValue.length];\\n        pre[0] = stoneValue[0];\\n        for (int i = 1; i < stoneValue.length; i++) {\\n            pre[i] = pre[i - 1] + stoneValue[i];\\n        }\\n        int[][] dp = new int[stoneValue.length + 1][stoneValue.length + 1];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        return solve(pre, 0, pre.length - 1, dp);\\n    }\\n\\n    private int getSum(int[] arr, int start, int end) {\\n        if (start > 0) {\\n            return arr[end] - arr[start - 1];\\n        }\\n        return arr[end];\\n    }\\n\\n    private int solve(int[] arr, int start, int end, int[][] dp) {\\n        if (start >= end) {\\n            return 0;\\n        }\\n        if (dp[start][end] != -1) {\\n            return dp[start][end];\\n        }\\n        int best = 0;\\n        for (int i = start; i <= end; i++) {\\n            int left = getSum(arr, start, i);\\n            int right = getSum(arr, i + 1, end);\\n            if (left == right) {\\n                best = Math.max(Math.max(best, left + solve(arr, start, i, dp)), left + solve(arr, i + 1, end, dp));\\n            } else if (left < right) {\\n                best = Math.max(best, left + solve(arr, start, i, dp));\\n            } else {\\n                best = Math.max(best, right + solve(arr, i + 1, end, dp));\\n            }\\n        }\\n        return dp[start][end] = best;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int[] pre = new int[stoneValue.length];\\n        pre[0] = stoneValue[0];\\n        for (int i = 1; i < stoneValue.length; i++) {\\n            pre[i] = pre[i - 1] + stoneValue[i];\\n        }\\n        int[][] dp = new int[stoneValue.length + 1][stoneValue.length + 1];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        return solve(pre, 0, pre.length - 1, dp);\\n    }\\n\\n    private int getSum(int[] arr, int start, int end) {\\n        if (start > 0) {\\n            return arr[end] - arr[start - 1];\\n        }\\n        return arr[end];\\n    }\\n\\n    private int solve(int[] arr, int start, int end, int[][] dp) {\\n        if (start >= end) {\\n            return 0;\\n        }\\n        if (dp[start][end] != -1) {\\n            return dp[start][end];\\n        }\\n        int best = 0;\\n        for (int i = start; i <= end; i++) {\\n            int left = getSum(arr, start, i);\\n            int right = getSum(arr, i + 1, end);\\n            if (left == right) {\\n                best = Math.max(Math.max(best, left + solve(arr, start, i, dp)), left + solve(arr, i + 1, end, dp));\\n            } else if (left < right) {\\n                best = Math.max(best, left + solve(arr, start, i, dp));\\n            } else {\\n                best = Math.max(best, right + solve(arr, i + 1, end, dp));\\n            }\\n        }\\n        return dp[start][end] = best;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501623,
                "title": "c-easy-to-understand-recur-memo",
                "content": "class Solution {\\npublic:\\n    \\n    int dp[505][505];\\n    \\n    int func(vector<int>&nums,int start,int end){\\n        \\n        if(start>end){\\n            return 0;\\n        }\\n        \\n        if(dp[start][end]!=-1){\\n            return dp[start][end];\\n        }\\n        \\n        int l=0,r=0,maxval=0;\\n        \\n        for(int i=start;i<=end;i++){\\n            r+=nums[i];\\n        }\\n        \\n        for(int i=start;i<end;i++){\\n            \\n            l+=nums[i];\\n            r-=nums[i];\\n            \\n            if(l<r){\\n                maxval=max(maxval,l+func(nums,start,i));\\n            }\\n            \\n            if(l>r){\\n                maxval=max(maxval,r+func(nums,i+1,end));\\n            }\\n            \\n            if(l==r){\\n                \\n                int val1=l+func(nums,start,i);\\n                int val2=r+func(nums,i+1,end);\\n                \\n                maxval=max(maxval,max(val1,val2));\\n                \\n            }\\n            \\n        }\\n        \\n        return dp[start][end]=maxval;\\n        \\n    }\\n    \\n    int stoneGameV(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return func(nums,0,n-1);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int dp[505][505];\\n    \\n    int func(vector<int>&nums,int start,int end){\\n        \\n        if(start>end){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1477642,
                "title": "c-prefix-sum-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int func(int x,int y,vector<int>&s,vector<vector<int>>&dp){\\n        int n = y-x+1;\\n        if(n==1)return 0;\\n        if(dp[x][y]!=-1)return dp[x][y]; \\n        int ans = -1e9;\\n        int left = (x==0?0:s[x-1]);\\n        for(int i=x;i<y;i++){\\n            int a = s[i]-left;\\n            int b = s[y]-s[i];\\n            if(a<b){\\n                ans = max(ans,a+func(x,i,s,dp));\\n            }\\n            else if(b<a){\\n                ans = max(ans,b+func(i+1,y,s,dp));\\n            }\\n            else{\\n                ans = max({ans,a+func(x,i,s,dp),a+func(i+1,y,s,dp)});\\n            }\\n        }\\n        return dp[x][y] = ans;\\n    }\\n    int stoneGameV(vector<int>& s) {\\n        int n = s.size();\\n        if(n==1)return 0;\\n        for(int i=1;i<n;i++){\\n            s[i]+=s[i-1];\\n        }\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return func(0,n-1,s,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(int x,int y,vector<int>&s,vector<vector<int>>&dp){\\n        int n = y-x+1;\\n        if(n==1)return 0;\\n        if(dp[x][y]!=-1)return dp[x][y]; \\n        int ans = -1e9;\\n        int left = (x==0?0:s[x-1]);\\n        for(int i=x;i<y;i++){\\n            int a = s[i]-left;\\n            int b = s[y]-s[i];\\n            if(a<b){\\n                ans = max(ans,a+func(x,i,s,dp));\\n            }\\n            else if(b<a){\\n                ans = max(ans,b+func(i+1,y,s,dp));\\n            }\\n            else{\\n                ans = max({ans,a+func(x,i,s,dp),a+func(i+1,y,s,dp)});\\n            }\\n        }\\n        return dp[x][y] = ans;\\n    }\\n    int stoneGameV(vector<int>& s) {\\n        int n = s.size();\\n        if(n==1)return 0;\\n        for(int i=1;i<n;i++){\\n            s[i]+=s[i-1];\\n        }\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return func(0,n-1,s,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402368,
                "title": "easy-to-understand-c-solution-rec-memo",
                "content": "class Solution {\\npublic:\\n    \\n    vector<vector<int>>t;\\n    vector<int>presum ;\\n    \\n    int rec( int start , int end , vector<int>&nums) \\n    {\\n        if( start > end ) return  0 ;\\n        if( start == end) return 0 ; //  only one element is left so we have to remove the max part and choose the least part se we took 0\\n        \\n        if( t[start][end] != -1) return t[start][end] ;\\n        \\n        int right = 0 ;  // initally right sum is total sum from start to end \\n        \\n        // now we have to split \\n        int ans = 0 ;\\n        int left = 0 ;\\n        for( int i= start ; i<= end ; i++)\\n        {\\n            left = left + nums[i] ;  //   (6) | (2,3,4,5,5)     (6, 2) | (3,4,5,5)\\n            \\n            //right = right - nums[i] ;\\n            right = presum[end] - presum[i] ;\\n            \\n            if( left < right)  // we have to add left part \\n            {\\n                ans = max( ans , left + rec(start , i, nums ) ) ;\\n            }\\n            else if( left == right)  // we let alice decive which part she want \\n            {\\n                ans = max({ ans , left+ rec( start , i , nums)  , right + rec( i+ 1, end, nums) });\\n            }\\n            else if( left > right) \\n            {\\n                ans = max( ans , right + rec( i+ 1, end , nums) ) ;\\n            }\\n        }\\n        \\n        return t[start][end] = ans ;\\n    }\\n    \\n    int stoneGameV(vector<int>& nums)\\n    {\\n        //[6,2,3,4,5,5]\\n        int n = nums.size() ;\\n        if( n<= 1) return 0;\\n        \\n        presum.resize( nums.size() , 0) ;\\n        presum[0] = nums[0] ;\\n        for( int i= 1 ; i<n ; i++)\\n        {\\n            presum[i] = presum[i-1] + nums[i] ;\\n        }\\n        \\n        for( int i= 0 ; i<n ; i++) cout<<presum[i]<<\" \";\\n        \\n        t.resize( n+ 1, vector<int>( n+ 1, -1) ) ;\\n        \\n        return rec( 0 , n-1 , nums ) ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    vector<vector<int>>t;\\n    vector<int>presum ;\\n    \\n    int rec( int start , int end , vector<int>&nums) \\n    {\\n        if( start > end ) return  0 ;\\n        if( start == end) return 0 ; //  only one element is left so we have to remove the max part and choose the least part se we took 0\\n        \\n        if( t[start][end] != -1) return t[start][end] ;\\n        \\n        int right = 0 ;  // initally right sum is total sum from start to end \\n        \\n        // now we have to split \\n        int ans = 0 ;\\n        int left = 0 ;\\n        for( int i= start ; i<= end ; i++)\\n        {\\n            left = left + nums[i] ;  //   (6) | (2,3,4,5,5)     (6, 2) | (3,4,5,5)\\n            \\n            //right = right - nums[i] ;\\n            right = presum[end] - presum[i] ;\\n            \\n            if( left < right)  // we have to add left part \\n            {\\n                ans = max( ans , left + rec(start , i, nums ) ) ;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574882,
                "content": [
                    {
                        "username": "carlmachaalani",
                        "content": "Why does [10,9,8,7,6,5,4,3,2,1] output 37?!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "first division will be [10,9,8] and [7,6,5,4,3,2,1].\\nthus adding 27 to the score.\\nnext division will be [10] and [9,8]\\nthus adding 10 more. \\nfinal answer is 37"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "Playing with stones in the 5th game... I\\'m genuinely sorry for the poor kids"
                    },
                    {
                        "username": "arowshan",
                        "content": "- Pick [2,4,6] vs [3,5,5] -> Bob throws away right, Alice scores  = 2 + 4 + 6 = 12\\n- Pick [2,4] vs [6] -> Bob lets Alice pick since they\\'re equal so Alices throws away [6]. Alice score = 12 + 2 + 4 = 18\\n- Pick [2] vs [4] -> Bob throws away right. Alice score = 18 + 2 = 20 \\n- Game Over"
                    },
                    {
                        "username": "NothingIsKnight",
                        "content": "Ya what? Am I missing something?"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "VERY GOOD PROBLEM \\nCLASSIC DP "
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "What wrong with my code.it @ fail on testcase: \\ninput: [1,1,2]\\nactual output: 2\\nexpected output: 3\\n\\nPlease cheak my code what wrong with it\\n\\nclass Solution {\\npublic:\\n    //game theory variation\\n    //tc=o(n*n*n)+o(n*n)\\n    //sc=o(n*n)\\n    int find(int i,int j,vector<int>& v,vector<vector<int>>& dp,vector<vector<int>>& value){\\n        if(i==j){\\n            return dp[i][j]=0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int maxi=0;\\n        for(int k=i;k<j;k++){\\n            if(value[i][k]<value[k+1][j]){\\n                maxi=max(maxi,value[i][k]+find(i,k,v,dp,value));\\n            }else if(value[i][j]==value[k+1][j]){\\n                maxi=max(maxi,value[i][k]+max(find(i,k,v,dp,value),find(k+1,j,v,dp,value)));\\n            }\\n            else{\\n                maxi=max(maxi,value[k+1][j]+find(k+1,j,v,dp,value));\\n            }\\n        }\\n        return dp[i][j]=maxi;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n=stoneValue.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1)),value(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=i;j<n;j++){\\n                sum+=stoneValue[j];\\n                value[i][j]=sum;\\n                // cout<<i<<\" \"<<j<<\" \"<<sum<<endl;\\n            }\\n        }\\n        find(0,n-1,stoneValue,dp,value);\\n        \\n        return 1;\\n    }\\n};"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "Hey [@Jayesh badgujar](/Jayesh_06)\\n  this is the case where both , SUM(left half array) == SUM(right half array). In this case Bob give alice the control which part of array to ignore. \\n\\nlets understand with this example: \\n[2,1,1]   ---> [2] , [1,1] -- This is the partition which gives equal sum\\nWhic subarray should Alice keep ?\\nGo further with the subProblem which gives max. result . Can you figure out why ?\\nmeans ignore [2]  , sum = 1+1 = 2;\\nnow we have [1,1] , remove left half , sum  = 2+1 =3 \\n\\n"
                    }
                ]
            },
            {
                "id": 1907973,
                "content": [
                    {
                        "username": "carlmachaalani",
                        "content": "Why does [10,9,8,7,6,5,4,3,2,1] output 37?!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "first division will be [10,9,8] and [7,6,5,4,3,2,1].\\nthus adding 27 to the score.\\nnext division will be [10] and [9,8]\\nthus adding 10 more. \\nfinal answer is 37"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "Playing with stones in the 5th game... I\\'m genuinely sorry for the poor kids"
                    },
                    {
                        "username": "arowshan",
                        "content": "- Pick [2,4,6] vs [3,5,5] -> Bob throws away right, Alice scores  = 2 + 4 + 6 = 12\\n- Pick [2,4] vs [6] -> Bob lets Alice pick since they\\'re equal so Alices throws away [6]. Alice score = 12 + 2 + 4 = 18\\n- Pick [2] vs [4] -> Bob throws away right. Alice score = 18 + 2 = 20 \\n- Game Over"
                    },
                    {
                        "username": "NothingIsKnight",
                        "content": "Ya what? Am I missing something?"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "VERY GOOD PROBLEM \\nCLASSIC DP "
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "What wrong with my code.it @ fail on testcase: \\ninput: [1,1,2]\\nactual output: 2\\nexpected output: 3\\n\\nPlease cheak my code what wrong with it\\n\\nclass Solution {\\npublic:\\n    //game theory variation\\n    //tc=o(n*n*n)+o(n*n)\\n    //sc=o(n*n)\\n    int find(int i,int j,vector<int>& v,vector<vector<int>>& dp,vector<vector<int>>& value){\\n        if(i==j){\\n            return dp[i][j]=0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int maxi=0;\\n        for(int k=i;k<j;k++){\\n            if(value[i][k]<value[k+1][j]){\\n                maxi=max(maxi,value[i][k]+find(i,k,v,dp,value));\\n            }else if(value[i][j]==value[k+1][j]){\\n                maxi=max(maxi,value[i][k]+max(find(i,k,v,dp,value),find(k+1,j,v,dp,value)));\\n            }\\n            else{\\n                maxi=max(maxi,value[k+1][j]+find(k+1,j,v,dp,value));\\n            }\\n        }\\n        return dp[i][j]=maxi;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n=stoneValue.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1)),value(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=i;j<n;j++){\\n                sum+=stoneValue[j];\\n                value[i][j]=sum;\\n                // cout<<i<<\" \"<<j<<\" \"<<sum<<endl;\\n            }\\n        }\\n        find(0,n-1,stoneValue,dp,value);\\n        \\n        return 1;\\n    }\\n};"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "Hey [@Jayesh badgujar](/Jayesh_06)\\n  this is the case where both , SUM(left half array) == SUM(right half array). In this case Bob give alice the control which part of array to ignore. \\n\\nlets understand with this example: \\n[2,1,1]   ---> [2] , [1,1] -- This is the partition which gives equal sum\\nWhic subarray should Alice keep ?\\nGo further with the subProblem which gives max. result . Can you figure out why ?\\nmeans ignore [2]  , sum = 1+1 = 2;\\nnow we have [1,1] , remove left half , sum  = 2+1 =3 \\n\\n"
                    }
                ]
            },
            {
                "id": 1570127,
                "content": [
                    {
                        "username": "carlmachaalani",
                        "content": "Why does [10,9,8,7,6,5,4,3,2,1] output 37?!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "first division will be [10,9,8] and [7,6,5,4,3,2,1].\\nthus adding 27 to the score.\\nnext division will be [10] and [9,8]\\nthus adding 10 more. \\nfinal answer is 37"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "Playing with stones in the 5th game... I\\'m genuinely sorry for the poor kids"
                    },
                    {
                        "username": "arowshan",
                        "content": "- Pick [2,4,6] vs [3,5,5] -> Bob throws away right, Alice scores  = 2 + 4 + 6 = 12\\n- Pick [2,4] vs [6] -> Bob lets Alice pick since they\\'re equal so Alices throws away [6]. Alice score = 12 + 2 + 4 = 18\\n- Pick [2] vs [4] -> Bob throws away right. Alice score = 18 + 2 = 20 \\n- Game Over"
                    },
                    {
                        "username": "NothingIsKnight",
                        "content": "Ya what? Am I missing something?"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "VERY GOOD PROBLEM \\nCLASSIC DP "
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "What wrong with my code.it @ fail on testcase: \\ninput: [1,1,2]\\nactual output: 2\\nexpected output: 3\\n\\nPlease cheak my code what wrong with it\\n\\nclass Solution {\\npublic:\\n    //game theory variation\\n    //tc=o(n*n*n)+o(n*n)\\n    //sc=o(n*n)\\n    int find(int i,int j,vector<int>& v,vector<vector<int>>& dp,vector<vector<int>>& value){\\n        if(i==j){\\n            return dp[i][j]=0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int maxi=0;\\n        for(int k=i;k<j;k++){\\n            if(value[i][k]<value[k+1][j]){\\n                maxi=max(maxi,value[i][k]+find(i,k,v,dp,value));\\n            }else if(value[i][j]==value[k+1][j]){\\n                maxi=max(maxi,value[i][k]+max(find(i,k,v,dp,value),find(k+1,j,v,dp,value)));\\n            }\\n            else{\\n                maxi=max(maxi,value[k+1][j]+find(k+1,j,v,dp,value));\\n            }\\n        }\\n        return dp[i][j]=maxi;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n=stoneValue.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1)),value(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=i;j<n;j++){\\n                sum+=stoneValue[j];\\n                value[i][j]=sum;\\n                // cout<<i<<\" \"<<j<<\" \"<<sum<<endl;\\n            }\\n        }\\n        find(0,n-1,stoneValue,dp,value);\\n        \\n        return 1;\\n    }\\n};"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "Hey [@Jayesh badgujar](/Jayesh_06)\\n  this is the case where both , SUM(left half array) == SUM(right half array). In this case Bob give alice the control which part of array to ignore. \\n\\nlets understand with this example: \\n[2,1,1]   ---> [2] , [1,1] -- This is the partition which gives equal sum\\nWhic subarray should Alice keep ?\\nGo further with the subProblem which gives max. result . Can you figure out why ?\\nmeans ignore [2]  , sum = 1+1 = 2;\\nnow we have [1,1] , remove left half , sum  = 2+1 =3 \\n\\n"
                    }
                ]
            },
            {
                "id": 1939543,
                "content": [
                    {
                        "username": "carlmachaalani",
                        "content": "Why does [10,9,8,7,6,5,4,3,2,1] output 37?!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "first division will be [10,9,8] and [7,6,5,4,3,2,1].\\nthus adding 27 to the score.\\nnext division will be [10] and [9,8]\\nthus adding 10 more. \\nfinal answer is 37"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "Playing with stones in the 5th game... I\\'m genuinely sorry for the poor kids"
                    },
                    {
                        "username": "arowshan",
                        "content": "- Pick [2,4,6] vs [3,5,5] -> Bob throws away right, Alice scores  = 2 + 4 + 6 = 12\\n- Pick [2,4] vs [6] -> Bob lets Alice pick since they\\'re equal so Alices throws away [6]. Alice score = 12 + 2 + 4 = 18\\n- Pick [2] vs [4] -> Bob throws away right. Alice score = 18 + 2 = 20 \\n- Game Over"
                    },
                    {
                        "username": "NothingIsKnight",
                        "content": "Ya what? Am I missing something?"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "VERY GOOD PROBLEM \\nCLASSIC DP "
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "What wrong with my code.it @ fail on testcase: \\ninput: [1,1,2]\\nactual output: 2\\nexpected output: 3\\n\\nPlease cheak my code what wrong with it\\n\\nclass Solution {\\npublic:\\n    //game theory variation\\n    //tc=o(n*n*n)+o(n*n)\\n    //sc=o(n*n)\\n    int find(int i,int j,vector<int>& v,vector<vector<int>>& dp,vector<vector<int>>& value){\\n        if(i==j){\\n            return dp[i][j]=0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int maxi=0;\\n        for(int k=i;k<j;k++){\\n            if(value[i][k]<value[k+1][j]){\\n                maxi=max(maxi,value[i][k]+find(i,k,v,dp,value));\\n            }else if(value[i][j]==value[k+1][j]){\\n                maxi=max(maxi,value[i][k]+max(find(i,k,v,dp,value),find(k+1,j,v,dp,value)));\\n            }\\n            else{\\n                maxi=max(maxi,value[k+1][j]+find(k+1,j,v,dp,value));\\n            }\\n        }\\n        return dp[i][j]=maxi;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n=stoneValue.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1)),value(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=i;j<n;j++){\\n                sum+=stoneValue[j];\\n                value[i][j]=sum;\\n                // cout<<i<<\" \"<<j<<\" \"<<sum<<endl;\\n            }\\n        }\\n        find(0,n-1,stoneValue,dp,value);\\n        \\n        return 1;\\n    }\\n};"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "Hey [@Jayesh badgujar](/Jayesh_06)\\n  this is the case where both , SUM(left half array) == SUM(right half array). In this case Bob give alice the control which part of array to ignore. \\n\\nlets understand with this example: \\n[2,1,1]   ---> [2] , [1,1] -- This is the partition which gives equal sum\\nWhic subarray should Alice keep ?\\nGo further with the subProblem which gives max. result . Can you figure out why ?\\nmeans ignore [2]  , sum = 1+1 = 2;\\nnow we have [1,1] , remove left half , sum  = 2+1 =3 \\n\\n"
                    }
                ]
            },
            {
                "id": 1828045,
                "content": [
                    {
                        "username": "carlmachaalani",
                        "content": "Why does [10,9,8,7,6,5,4,3,2,1] output 37?!"
                    },
                    {
                        "username": "ms232gg",
                        "content": "first division will be [10,9,8] and [7,6,5,4,3,2,1].\\nthus adding 27 to the score.\\nnext division will be [10] and [9,8]\\nthus adding 10 more. \\nfinal answer is 37"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "Playing with stones in the 5th game... I\\'m genuinely sorry for the poor kids"
                    },
                    {
                        "username": "arowshan",
                        "content": "- Pick [2,4,6] vs [3,5,5] -> Bob throws away right, Alice scores  = 2 + 4 + 6 = 12\\n- Pick [2,4] vs [6] -> Bob lets Alice pick since they\\'re equal so Alices throws away [6]. Alice score = 12 + 2 + 4 = 18\\n- Pick [2] vs [4] -> Bob throws away right. Alice score = 18 + 2 = 20 \\n- Game Over"
                    },
                    {
                        "username": "NothingIsKnight",
                        "content": "Ya what? Am I missing something?"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "VERY GOOD PROBLEM \\nCLASSIC DP "
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "What wrong with my code.it @ fail on testcase: \\ninput: [1,1,2]\\nactual output: 2\\nexpected output: 3\\n\\nPlease cheak my code what wrong with it\\n\\nclass Solution {\\npublic:\\n    //game theory variation\\n    //tc=o(n*n*n)+o(n*n)\\n    //sc=o(n*n)\\n    int find(int i,int j,vector<int>& v,vector<vector<int>>& dp,vector<vector<int>>& value){\\n        if(i==j){\\n            return dp[i][j]=0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int maxi=0;\\n        for(int k=i;k<j;k++){\\n            if(value[i][k]<value[k+1][j]){\\n                maxi=max(maxi,value[i][k]+find(i,k,v,dp,value));\\n            }else if(value[i][j]==value[k+1][j]){\\n                maxi=max(maxi,value[i][k]+max(find(i,k,v,dp,value),find(k+1,j,v,dp,value)));\\n            }\\n            else{\\n                maxi=max(maxi,value[k+1][j]+find(k+1,j,v,dp,value));\\n            }\\n        }\\n        return dp[i][j]=maxi;\\n    }\\n    int stoneGameV(vector<int>& stoneValue) {\\n        int n=stoneValue.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1)),value(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=i;j<n;j++){\\n                sum+=stoneValue[j];\\n                value[i][j]=sum;\\n                // cout<<i<<\" \"<<j<<\" \"<<sum<<endl;\\n            }\\n        }\\n        find(0,n-1,stoneValue,dp,value);\\n        \\n        return 1;\\n    }\\n};"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "Hey [@Jayesh badgujar](/Jayesh_06)\\n  this is the case where both , SUM(left half array) == SUM(right half array). In this case Bob give alice the control which part of array to ignore. \\n\\nlets understand with this example: \\n[2,1,1]   ---> [2] , [1,1] -- This is the partition which gives equal sum\\nWhic subarray should Alice keep ?\\nGo further with the subProblem which gives max. result . Can you figure out why ?\\nmeans ignore [2]  , sum = 1+1 = 2;\\nnow we have [1,1] , remove left half , sum  = 2+1 =3 \\n\\n"
                    }
                ]
            }
        ]
    }
]