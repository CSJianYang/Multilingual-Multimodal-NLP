[
    {
        "title": "Candy",
        "question_content": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\nYou are giving candies to these children subjected to the following requirements:\n\n\tEach child must have at least one candy.\n\tChildren with a higher rating get more candies than their neighbors.\n\nReturn the minimum number of candies you need to have to distribute the candies to the children.\n&nbsp;\nExample 1:\n\nInput: ratings = [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\nExample 2:\n\nInput: ratings = [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n\n&nbsp;\nConstraints:\n\n\tn == ratings.length\n\t1 <= n <= 2 * 104\n\t0 <= ratings[i] <= 2 * 104",
        "solutions": [
            {
                "id": 42769,
                "title": "a-simple-solution",
                "content": "  \\n\\n      int candy(vector<int> &ratings)\\n     {\\n    \\t int size=ratings.size();\\n    \\t if(size<=1)\\n    \\t\\t return size;\\n    \\t vector<int> num(size,1);\\n    \\t for (int i = 1; i < size; i++)\\n    \\t {\\n    \\t\\t if(ratings[i]>ratings[i-1])\\n    \\t\\t\\t num[i]=num[i-1]+1;\\n    \\t }\\n    \\t for (int i= size-1; i>0 ; i--)\\n    \\t {\\n    \\t\\t if(ratings[i-1]>ratings[i])\\n    \\t\\t\\t num[i-1]=max(num[i]+1,num[i-1]);\\n    \\t }\\n    \\t int result=0;\\n    \\t for (int i = 0; i < size; i++)\\n    \\t {\\n    \\t\\t result+=num[i];\\n    \\t\\t// cout<<num[i]<<\" \";\\n    \\t }\\n    \\t return result;\\n     }",
                "solutionTags": [],
                "code": "  \\n\\n      int candy(vector<int> &ratings)\\n     {\\n    \\t int size=ratings.size();\\n    \\t if(size<=1)\\n    \\t\\t return size;\\n    \\t vector<int> num(size,1);\\n    \\t for (int i = 1; i < size; i++)\\n    \\t {\\n    \\t\\t if(ratings[i]>ratings[i-1])\\n    \\t\\t\\t num[i]=num[i-1]+1;\\n    \\t }\\n    \\t for (int i= size-1; i>0 ; i--)\\n    \\t {\\n    \\t\\t if(ratings[i-1]>ratings[i])\\n    \\t\\t\\t num[i-1]=max(num[i]+1,num[i-1]);\\n    \\t }\\n    \\t int result=0;\\n    \\t for (int i = 0; i < size; i++)\\n    \\t {\\n    \\t\\t result+=num[i];\\n    \\t\\t// cout<<num[i]<<\" \";\\n    \\t }\\n    \\t return result;\\n     }",
                "codeTag": "C++"
            },
            {
                "id": 2234434,
                "title": "c-o-n-time-o-1-space-full-explanation",
                "content": "***Upvote if Found Helpful***\\n\\n**Alternate O(n) Space Approach :**\\n\\nWe can easily calculate the number of candy needed by using an array to store the candy of each child. And after that traverse the rating array twice. The first loop makes sure children with a higher rating get more candy than its left neighbor, the second loop makes sure children with a higher rating get more candy than its right neighbor. At last add the total number of candies. This approach is O(n) time and O(n) space. This type of solutions are available in other posts.\\n\\n# **O(1) Space Approach :**\\n\\nWe can consider this problem like valley and peak problem. In each valley there should be 1 candy and for each increasing solpe in either side we need to increse candy by 1. Peaks have highest candy. If any equal rating is found then candy resets to 1 as two equal neighbours may have any number of candies. The peak should contain the higher number of candy between which is calculated from the incresing slope and which is calculated from decreasing slope. Because this will satisfy the condition that peak element is having more candies than its neighbours. \\n\\n***Example :***\\n\\n```\\nLet take the Rating as : [1,3,6,8,9,5,3,6,8,5,4,2,2,3,7,7,9,8,6,6,6,4,2]\\n\\nEach child represented as rating(candy he is given)\\nPeak = max(peak, valley)\\n\\nSee when peak is encountered we take max of the peak calculated from left and valley calculated from right.\\nWhen we get any equal element it gets reset to 1 candy or if it is peak we take max(0, right valley)\\n\\n           (5)         (4)                         (3)\\n            9           8                           9\\n           /|\\\\         /|\\\\                         /|\\\\\\n          / | \\\\       / | \\\\                (3)    / | \\\\\\n      (4)8  |  5(2)  6  |  5(3)             7 __ 7  |  8(2)\\n        /   |   \\\\   (2) |   \\\\              /|   (1) |   \\\\\\n       /    |    \\\\ /    |    \\\\            / |    |  |    \\\\         (3)\\n   (3)6     |     3     |     4(2)       3(2)    |  |     6 __ 6 __ 6    -> Total candy = 50\\n     /      |    (1)    |      \\\\        /   | Reset |    (1)  (1)   |\\\\\\n    /       |           |       \\\\      /    |  to 1 |          |    | \\\\\\n(2)3        |           |        2 __ 2     |       |          |    |  4(2)\\n  /         |           |       (1)  (1)    |       |        Reset  |   \\\\\\n /          |           |                   |       |         to 1  |    \\\\\\n1(1)        |           |                   |       |               |     2(1)\\n   Peak= max(5,3)  Peak= max(3,4)    Peak= max(3,0) |         Peak= max(0,3)\\n                                               Peak= max(2,3)   \\n```\\n\\n**Implementation :**\\n\\n* So we take initially n candy for n children. Then we start traversing the rating array from the second element. If we find equal elements we continue to next element as they already have 1 candy.\\n\\n* If an increasing slop is found `(ratings[i] > ratings [i-1])` we increase value of peak and and add the peak value to candy. After each iteration new peak is found and the value is added to candy. In this way we also get the value of minimum height of the peak at the end.\\n\\n* If a decreasing slope is found `(ratings[i] < ratings [i-1])` we calculate the depth of the valley which is in turn the minimum height of the previous peak. In each iteration we increse the valley by 1 and add it to the candy. You can visualise it as 1 candy is added to each of the previous members untill peak or the new peak value is interted at the previous peak and other values are shifted to right by 1 place. We also need to check if it is going out of array if so then return the number of candy.\\n\\n* After this we can see we have added the peak value twice in candy once as peak and once as valley. But we need only the max value out of these two so we substract the `min(peak, valley)` from candy. \\n\\n* After that return the candy.\\n\\n**Note :** We have considered the sequence increasing -> decreasing as peak should have the max value between the height of left (increasing) side and height of right (decreasing) side. In case of decresing -> increasing we dont need to give special attention as the vallley will always have 1 candy and in our code in this case peak will have 0 value so nothing will be substracted from the candy in the end of iteration.\\n\\nSee the example for better understanding :\\n\\n```\\nIn our code we increase the peak and add peak value untill we get the minimum actual peak.\\nIn case of the decreasing part take this example.\\n\\n[7,5,3,2], initial candy = 4, In each iteration valley++ and candy += valley\\n\\n7 starting (valley = 0, candy = 4, candy configuaration  = [1,1,1,1])\\n \\\\\\n  5 (valley = 1, candy = 4+1 = 5, candy configuaration  = [2,1,1,1])\\n   \\\\\\n    3 (valley = 2, candy = 5+2 = 7, candy configuaration = [3,2,1,1])\\n     \\\\\\n      2 [valley = 3, candy = 7+3 = 10, candy configuartion = [4,3,2,1])\\n\\t  \\nHere see the valley is at last equal to the minimum previous peak value.\\n\\nAs we have given 1 candy to all before so the peak and valley values are actually 1 less than the actual candy they should get.\\n```\\n\\n**Code :**\\n\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candy = n, i=1;\\n        while(i<n){\\n            if(ratings[i] == ratings[i-1]){\\n                i++;\\n                continue;\\n            }\\n            \\n            //For increasing slope\\n            int peak = 0;\\n            while(ratings[i] > ratings [i-1]){\\n                peak++;\\n                candy += peak;\\n                i++;\\n                if(i == n) return candy;\\n            }\\n            \\n            //For decreasing slope\\n            int valley = 0;\\n            while(i<n && ratings[i] < ratings[i-1]){\\n                valley++;\\n                candy += valley;\\n                i++;\\n            }\\n            candy -= min(peak, valley); //Keep only the higher peak\\n        }\\n        return candy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nLet take the Rating as : [1,3,6,8,9,5,3,6,8,5,4,2,2,3,7,7,9,8,6,6,6,4,2]\\n\\nEach child represented as rating(candy he is given)\\nPeak = max(peak, valley)\\n\\nSee when peak is encountered we take max of the peak calculated from left and valley calculated from right.\\nWhen we get any equal element it gets reset to 1 candy or if it is peak we take max(0, right valley)\\n\\n           (5)         (4)                         (3)\\n            9           8                           9\\n           /|\\\\         /|\\\\                         /|\\\\\\n          / | \\\\       / | \\\\                (3)    / | \\\\\\n      (4)8  |  5(2)  6  |  5(3)             7 __ 7  |  8(2)\\n        /   |   \\\\   (2) |   \\\\              /|   (1) |   \\\\\\n       /    |    \\\\ /    |    \\\\            / |    |  |    \\\\         (3)\\n   (3)6     |     3     |     4(2)       3(2)    |  |     6 __ 6 __ 6    -> Total candy = 50\\n     /      |    (1)    |      \\\\        /   | Reset |    (1)  (1)   |\\\\\\n    /       |           |       \\\\      /    |  to 1 |          |    | \\\\\\n(2)3        |           |        2 __ 2     |       |          |    |  4(2)\\n  /         |           |       (1)  (1)    |       |        Reset  |   \\\\\\n /          |           |                   |       |         to 1  |    \\\\\\n1(1)        |           |                   |       |               |     2(1)\\n   Peak= max(5,3)  Peak= max(3,4)    Peak= max(3,0) |         Peak= max(0,3)\\n                                               Peak= max(2,3)   \\n```\n```\\nIn our code we increase the peak and add peak value untill we get the minimum actual peak.\\nIn case of the decreasing part take this example.\\n\\n[7,5,3,2], initial candy = 4, In each iteration valley++ and candy += valley\\n\\n7 starting (valley = 0, candy = 4, candy configuaration  = [1,1,1,1])\\n \\\\\\n  5 (valley = 1, candy = 4+1 = 5, candy configuaration  = [2,1,1,1])\\n   \\\\\\n    3 (valley = 2, candy = 5+2 = 7, candy configuaration = [3,2,1,1])\\n     \\\\\\n      2 [valley = 3, candy = 7+3 = 10, candy configuartion = [4,3,2,1])\\n\\t  \\nHere see the valley is at last equal to the minimum previous peak value.\\n\\nAs we have given 1 candy to all before so the peak and valley values are actually 1 less than the actual candy they should get.\\n```\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candy = n, i=1;\\n        while(i<n){\\n            if(ratings[i] == ratings[i-1]){\\n                i++;\\n                continue;\\n            }\\n            \\n            //For increasing slope\\n            int peak = 0;\\n            while(ratings[i] > ratings [i-1]){\\n                peak++;\\n                candy += peak;\\n                i++;\\n                if(i == n) return candy;\\n            }\\n            \\n            //For decreasing slope\\n            int valley = 0;\\n            while(i<n && ratings[i] < ratings[i-1]){\\n                valley++;\\n                candy += valley;\\n                i++;\\n            }\\n            candy -= min(peak, valley); //Keep only the higher peak\\n        }\\n        return candy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 135698,
                "title": "simple-solution-with-one-pass-using-o-1-space",
                "content": "To use two variables  \\'up\\' and \\'down\\' to count the steps of continuous up and down respectively, and a \\'peak\\' representing the peak before going down. In the below example:\\n```\\n[0, 1, 20, 9, 8, 7]\\n```\\nScan from left to right, first child is given 1 candy;\\nthe second child is given 2 candies,  and up=1;\\nthe third child is given 3 candies,  and up=2; peak=2;\\nthe fourth child is given 1 candy,  and down=1; and third child still has 3 candies since peak=2;\\nthe fifth child is given 1 candy,  and down=2; and the previous child needs 1 more candy now but the third child no need more;\\nthe sixth child is given 1 candy,  and down=3; and both the fifth and fourth child needs 1 more candy now, and the peak, the third child need 1 more as well.\\n```\\n        public int Candy(int[] ratings) {\\n            if (ratings.Length == 0) return 0;\\n            int ret = 1;\\n            int up = 0, down = 0, peak = 0;\\n            for (int i = 1; i < ratings.Length; i++) {\\n                if (ratings[i - 1] < ratings[i]) {\\n                    peak = ++up;\\n                    down = 0;\\n                    ret += 1 + up;\\n                } else if (ratings[i - 1] == ratings[i])  {\\n                    peak = up = down = 0;\\n                    ret += 1;\\n                } else {\\n                    up = 0;\\n                    down++;\\n                    ret += 1 + down + (peak >= down ? -1 : 0);\\n                }\\n            }\\n\\n            return ret;\\n        }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n[0, 1, 20, 9, 8, 7]\\n```\n```\\n        public int Candy(int[] ratings) {\\n            if (ratings.Length == 0) return 0;\\n            int ret = 1;\\n            int up = 0, down = 0, peak = 0;\\n            for (int i = 1; i < ratings.Length; i++) {\\n                if (ratings[i - 1] < ratings[i]) {\\n                    peak = ++up;\\n                    down = 0;\\n                    ret += 1 + up;\\n                } else if (ratings[i - 1] == ratings[i])  {\\n                    peak = up = down = 0;\\n                    ret += 1;\\n                } else {\\n                    up = 0;\\n                    down++;\\n                    ret += 1 + down + (peak >= down ? -1 : 0);\\n                }\\n            }\\n\\n            return ret;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 42794,
                "title": "simple-o-n-java-solution-with-comments",
                "content": "    public int candy(int[] ratings) {\\n        int candies[] = new int[ratings.length];        \\n        Arrays.fill(candies, 1);// Give each child 1 candy \\n        \\t\\n        for (int i = 1; i < candies.length; i++){// Scan from left to right, to make sure right higher rated child gets 1 more candy than left lower rated child\\n\\t        if (ratings[i] > ratings[i - 1]) candies[i] = (candies[i - 1] + 1);\\n\\t    }\\n\\t     \\n\\t    for (int i = candies.length - 2; i >= 0; i--) {// Scan from right to left, to make sure left higher rated child gets 1 more candy than right lower rated child\\n\\t\\t    if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], (candies[i + 1] + 1));\\n\\t    }\\n\\t    \\n        int sum = 0;        \\n        for (int candy : candies)  \\n        \\tsum += candy;        \\n        return sum;\\n\\t}",
                "solutionTags": [],
                "code": "    public int candy(int[] ratings) {\\n        int candies[] = new int[ratings.length];        \\n        Arrays.fill(candies, 1);// Give each child 1 candy \\n        \\t\\n        for (int i = 1; i < candies.length; i++){// Scan from left to right, to make sure right higher rated child gets 1 more candy than left lower rated child\\n\\t        if (ratings[i] > ratings[i - 1]) candies[i] = (candies[i - 1] + 1);\\n\\t    }\\n\\t     \\n\\t    for (int i = candies.length - 2; i >= 0; i--) {// Scan from right to left, to make sure left higher rated child gets 1 more candy than right lower rated child\\n\\t\\t    if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], (candies[i + 1] + 1));\\n\\t    }\\n\\t    \\n        int sum = 0;        \\n        for (int candy : candies)  \\n        \\tsum += candy;        \\n        return sum;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 4037646,
                "title": "99-20-greedy-two-one-pass",
                "content": "# Comprehensive Guide to Solving \"Candy\": Distributing Candies Like a Pro\\n\\n## Introduction & Problem Statement\\n\\nHey there, coding enthusiasts! Welcome back to another exciting coding session. Today\\'s problem is a treat\\u2014literally! We\\'re going to solve the \"Candy\" problem. Imagine you have a bunch of kids lined up, each with a rating assigned to them. Your task is to distribute candies to these kids following two simple rules:\\n\\n1. Every child must get at least one candy.\\n2. A child with a higher rating should get more candies than their immediate neighbors.\\n\\nSounds like a piece of cake, right? But here\\'s the twist: you need to accomplish this with the fewest candies possible. Let\\'s dig into the mechanics of this problem and how to approach it.\\n\\n## Key Concepts and Constraints\\n\\n### Why is This Problem Unique?\\n\\n1. **Child Ratings**: \\n   The ratings of each child are your only guide in how you distribute the candies. Following the rules while using these ratings makes this problem an intriguing puzzle.\\n  \\n2. **Minimum Candies**: \\n   You\\'re not just distributing candies willy-nilly; the goal is to meet the conditions using the least amount of candy.\\n\\n3. **Constraints**: \\n   - The length of the ratings array, `n` , is between  $$1$$  and $$ 2 \\\\times 10^4 $$.\\n   - Ratings are integers between $$0$$ and $$ 2 \\\\times 10^4 $$.\\n\\n### Strategies to Tackle the Problem\\n\\n1. **Greedy Algorithm: Two-Pass Method**  \\n   This method takes two passes through the ratings array to ensure that each child gets the appropriate amount of candy.\\n\\n2. **One-Pass Greedy Algorithm: Up-Down-Peak Method**  \\n   This more advanced method uses a single pass and employs three key variables\\u2014Up, Down, and Peak\\u2014to efficiently determine the minimum number of candies needed.\\n\\n---\\n\\n## Live Coding + Explenation of Greedy Two Pass\\nhttps://youtu.be/JqrZHuhljps?si=TxkUjNTZ1CxMviij\\n\\n## Greedy Algorithm: Two-Pass Method Explained\\n\\n### What is a Greedy Algorithm?\\n\\nA Greedy Algorithm makes choices that seem optimal at the moment. For this problem, we use a two-pass greedy approach to make sure each child gets the minimum number of candies that still satisfy the conditions.\\n\\n### The Nuts and Bolts of the Two-Pass Method\\n\\n1. **Initialize Candies Array**  \\n   - We start by creating a `candies` array of the same length as the `ratings` array and initialize all its values to 1. This is the base case and ensures that every child will receive at least one candy, satisfying the first condition.\\n  \\n2. **Forward Pass: Left to Right**\\n   - Now, we iterate through the `ratings` array from the beginning to the end. For each child (except the first), we compare their rating with the one to the left. If it\\'s higher, we update the `candies` array for that child to be one more than the child on the left. This takes care of the second condition but only accounts for the child\\'s left neighbor.\\n   \\n3. **Backward Pass: Right to Left**  \\n   - After the forward pass, we loop through the array again but in the reverse direction. This time, we compare each child\\'s rating with the child to their right. If the rating is higher, we need to make sure the child has more candies than the right neighbor. So, we update the `candies` array for that child to be the maximum between its current number of candies and one more than the right neighbor\\'s candies. This ensures that both neighboring conditions are checked and satisfied.\\n   \\n4. **Summing it All Up**\\n   - Finally, we sum up all the values in the `candies` array. This will give us the minimum total number of candies that need to be distributed to satisfy both conditions.\\n  \\n### Time and Space Complexity\\n\\n- **Time Complexity**: $$O(n)$$, because we make two passes through the array.\\n- **Space Complexity**: $$O(n)$$, for storing the `candies` array.\\n\\n## Code Greedy\\n``` Python []\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        candies = [1] * n \\n\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i-1]:\\n                candies[i] = candies[i-1] + 1\\n\\n        for i in range(n-2, -1, -1):\\n            if ratings[i] > ratings[i+1]:\\n                candies[i] = max(candies[i], candies[i+1] + 1)\\n        \\n        return sum(candies)\\n```\\n``` Go []\\nfunc candy(ratings []int) int {\\n    n := len(ratings)\\n    candies := make([]int, n)\\n    for i := range candies {\\n        candies[i] = 1\\n    }\\n\\n    for i := 1; i < n; i++ {\\n        if ratings[i] > ratings[i-1] {\\n            candies[i] = candies[i-1] + 1\\n        }\\n    }\\n\\n    for i := n - 2; i >= 0; i-- {\\n        if ratings[i] > ratings[i+1] {\\n            if candies[i] <= candies[i+1] {\\n                candies[i] = candies[i+1] + 1\\n            }\\n        }\\n    }\\n\\n    totalCandies := 0\\n    for _, candy := range candies {\\n        totalCandies += candy\\n    }\\n\\n    return totalCandies\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn candy(ratings: Vec<i32>) -> i32 {\\n        let n = ratings.len();\\n        let mut candies = vec![1; n];\\n\\n        for i in 1..n {\\n            if ratings[i] > ratings[i - 1] {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        for i in (0..n - 1).rev() {\\n            if ratings[i] > ratings[i + 1] {\\n                candies[i] = std::cmp::max(candies[i], candies[i + 1] + 1);\\n            }\\n        }\\n\\n        candies.iter().sum()\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int candy(std::vector<int>& ratings) {\\n        int n = ratings.size();\\n        std::vector<int> candies(n, 1);\\n\\n        for (int i = 1; i < n; ++i) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 2; i >= 0; --i) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                candies[i] = std::max(candies[i], candies[i + 1] + 1);\\n            }\\n        }\\n\\n        int totalCandies = 0;\\n        for (int candy : candies) {\\n            totalCandies += candy;\\n        }\\n\\n        return totalCandies;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] candies = new int[n];\\n        Arrays.fill(candies, 1);\\n\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                candies[i] = Math.max(candies[i], candies[i + 1] + 1);\\n            }\\n        }\\n\\n        int totalCandies = 0;\\n        for (int candy : candies) {\\n            totalCandies += candy;\\n        }\\n\\n        return totalCandies;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public int Candy(int[] ratings) {\\n        int n = ratings.Length;\\n        int[] candies = new int[n];\\n        Array.Fill(candies, 1);\\n\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                candies[i] = Math.Max(candies[i], candies[i + 1] + 1);\\n            }\\n        }\\n\\n        int totalCandies = 0;\\n        foreach (int candy in candies) {\\n            totalCandies += candy;\\n        }\\n\\n        return totalCandies;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} ratings\\n * @return {number}\\n */\\nvar candy = function(ratings) {\\n    const n = ratings.length;\\n    const candies = new Array(n).fill(1);\\n\\n    for (let i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (let i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1]) {\\n            candies[i] = Math.max(candies[i], candies[i + 1] + 1);\\n        }\\n    }\\n\\n    return candies.reduce((a, b) => a + b, 0);\\n};\\n```\\n``` PHP []\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $ratings\\n     * @return Integer\\n     */\\n    function candy($ratings) {\\n        $n = count($ratings);\\n        $candies = array_fill(0, $n, 1);\\n\\n        for ($i = 1; $i < $n; $i++) {\\n            if ($ratings[$i] > $ratings[$i - 1]) {\\n                $candies[$i] = $candies[$i - 1] + 1;\\n            }\\n        }\\n\\n        for ($i = $n - 2; $i >= 0; $i--) {\\n            if ($ratings[$i] > $ratings[$i + 1]) {\\n                $candies[$i] = max($candies[$i], $candies[$i + 1] + 1);\\n            }\\n        }\\n\\n        return array_sum($candies);\\n    }\\n}\\n```\\n## One-Pass Greedy Algorithm: Up-Down-Peak Method\\n\\n### Why `Up`, `Down`, and `Peak`?\\n\\nThe essence of the one-pass greedy algorithm lies in these three variables: `Up`, `Down`, and `Peak`. They serve as counters for the following:\\n\\n- **`Up`:** Counts how many children have **increasing ratings** from the last child. This helps us determine how many candies we need for a child with a higher rating than the previous child.\\n  \\n- **`Down`:** Counts how many children have **decreasing ratings** from the last child. This helps us determine how many candies we need for a child with a lower rating than the previous child.\\n\\n- **`Peak`:** Keeps track of the **last highest point** in an increasing sequence. When we have a decreasing sequence after the peak, we can refer back to the `Peak` to adjust the number of candies if needed.\\n\\n### How Does it Work?\\n\\n1. **Initialize Your Counters**\\n   - Start with `ret = 1` because each child must have at least one candy. Initialize `up`, `down`, and `peak` to 0.\\n   \\n2. **Loop Through Ratings**\\n   - For each pair of adjacent children, compare their ratings. Here are the scenarios:\\n   \\n     - **If the rating is increasing**: Update `up` and `peak` by incrementing them by 1. Set `down` to 0. Add `up + 1` to `ret` because the current child must have one more candy than the previous child.\\n     \\n     - **If the rating is the same**: Reset `up`, `down`, and `peak` to 0, because neither an increasing nor a decreasing trend is maintained. Add 1 to `ret` because the current child must have at least one candy.\\n     \\n     - **If the rating is decreasing**: Update `down` by incrementing it by 1. Reset `up` to 0. Add `down` to `ret`. Additionally, if `peak` is greater than or equal to `down`, decrement `ret` by 1. This is because the peak child can share the same number of candies as one of the children in the decreasing sequence, which allows us to reduce the total number of candies.\\n  \\n3. **Return the Total Candy Count**\\n   - At the end of the loop, `ret` will contain the minimum total number of candies needed for all the children, so return `ret`.\\n\\nBy using `up`, `down`, and `peak`, we can efficiently traverse the ratings list just once, updating our total candies count (`ret`) as we go. This method is efficient and helps us solve the problem in a single pass, with a time complexity of $$O(n)$$.\\n### Time and Space Complexity\\n\\n- **Time Complexity**: $$O(n)$$, for the single pass through the ratings array.\\n- **Space Complexity**: $$O(1)$$, as we only use a few extra variables.\\n\\n## Code One-Pass Greedy\\n``` Python []\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        if not ratings:\\n            return 0\\n        \\n        ret, up, down, peak = 1, 0, 0, 0\\n        \\n        for prev, curr in zip(ratings[:-1], ratings[1:]):\\n            if prev < curr:\\n                up, down, peak = up + 1, 0, up + 1\\n                ret += 1 + up\\n            elif prev == curr:\\n                up = down = peak = 0\\n                ret += 1\\n            else:\\n                up, down = 0, down + 1\\n                ret += 1 + down - int(peak >= down)\\n        \\n        return ret\\n\\n```\\n``` Go []\\nfunc candy(ratings []int) int {\\n    if len(ratings) == 0 {\\n        return 0\\n    }\\n\\n    ret, up, down, peak := 1, 0, 0, 0\\n\\n    for i := 0; i < len(ratings) - 1; i++ {\\n        prev, curr := ratings[i], ratings[i+1]\\n\\n        if prev < curr {\\n            up++\\n            down = 0\\n            peak = up\\n            ret += 1 + up\\n        } else if prev == curr {\\n            up, down, peak = 0, 0, 0\\n            ret += 1\\n        } else {\\n            up = 0\\n            down++\\n            ret += 1 + down\\n            if peak >= down {\\n                ret--\\n            }\\n        }\\n    }\\n\\n    return ret\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn candy(ratings: Vec<i32>) -> i32 {\\n        if ratings.is_empty() {\\n            return 0;\\n        }\\n\\n        let mut ret = 1;\\n        let mut up = 0;\\n        let mut down = 0;\\n        let mut peak = 0;\\n\\n        for i in 0..ratings.len() - 1 {\\n            let (prev, curr) = (ratings[i], ratings[i + 1]);\\n\\n            if prev < curr {\\n                up += 1;\\n                down = 0;\\n                peak = up;\\n                ret += 1 + up;\\n            } else if prev == curr {\\n                up = 0;\\n                down = 0;\\n                peak = 0;\\n                ret += 1;\\n            } else {\\n                up = 0;\\n                down += 1;\\n                ret += 1 + down;\\n                if peak >= down {\\n                    ret -= 1;\\n                }\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n```\\n\\n## Performance Comparison\\n\\n| Language  | Approach  | Time (ms)  | Memory (MB) |\\n|-----------|-----------|------------|-------------|\\n| Rust      | One Pass  | 1          | 2.1         |\\n| Rust      | Two Pass  | 2          | 2.3         |\\n| Java      | Two Pass  | 3          | 44.3        |\\n| Go        | One Pass  | 9          | 6.2         |\\n| C++       | Two Pass  | 11         | 17.8        |\\n| Go        | Two Pass  | 14         | 6.6         |\\n| PHP       | Two Pass  | 42         | 21.9        |\\n| JavaScript| Two Pass  | 59         | 45.1        |\\n| C#        | Two Pass  | 98         | 44.3        |\\n| Python3   | One Pass  | 126        | 19.5        |\\n| Python3   | Two Pass  | 139        | 19.2        |\\n\\n![h2.png](https://assets.leetcode.com/users/images/098d38e8-c14e-48b3-9c98-3394eb56d996_1694566150.8876379.png)\\n\\n## Live Coding & Explenation - One Pass\\nhttps://youtu.be/_MVFeqfiDK4?si=t8El9b9mlUQneXDk\\n\\n## Code Highlights and Best Practices\\n\\n- The Two-Pass Greedy Algorithm is straightforward and effective, making it a solid approach for this problem.\\n- The One-Pass Greedy Algorithm is even more efficient in terms of space complexity and is also a bit more challenging to understand.\\n  \\nBy mastering these approaches, you\\'ll be well-equipped to tackle other optimization problems, which are common in coding interviews and competitive programming. So, are you ready to distribute some candies? Let\\'s get coding!\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Array",
                    "Greedy"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        candies = [1] * n \\n\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i-1]:\\n                candies[i] = candies[i-1] + 1\\n\\n        for i in range(n-2, -1, -1):\\n            if ratings[i] > ratings[i+1]:\\n                candies[i] = max(candies[i], candies[i+1] + 1)\\n        \\n        return sum(candies)\\n```\n``` Go []\\nfunc candy(ratings []int) int {\\n    n := len(ratings)\\n    candies := make([]int, n)\\n    for i := range candies {\\n        candies[i] = 1\\n    }\\n\\n    for i := 1; i < n; i++ {\\n        if ratings[i] > ratings[i-1] {\\n            candies[i] = candies[i-1] + 1\\n        }\\n    }\\n\\n    for i := n - 2; i >= 0; i-- {\\n        if ratings[i] > ratings[i+1] {\\n            if candies[i] <= candies[i+1] {\\n                candies[i] = candies[i+1] + 1\\n            }\\n        }\\n    }\\n\\n    totalCandies := 0\\n    for _, candy := range candies {\\n        totalCandies += candy\\n    }\\n\\n    return totalCandies\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn candy(ratings: Vec<i32>) -> i32 {\\n        let n = ratings.len();\\n        let mut candies = vec![1; n];\\n\\n        for i in 1..n {\\n            if ratings[i] > ratings[i - 1] {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        for i in (0..n - 1).rev() {\\n            if ratings[i] > ratings[i + 1] {\\n                candies[i] = std::cmp::max(candies[i], candies[i + 1] + 1);\\n            }\\n        }\\n\\n        candies.iter().sum()\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int candy(std::vector<int>& ratings) {\\n        int n = ratings.size();\\n        std::vector<int> candies(n, 1);\\n\\n        for (int i = 1; i < n; ++i) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 2; i >= 0; --i) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                candies[i] = std::max(candies[i], candies[i + 1] + 1);\\n            }\\n        }\\n\\n        int totalCandies = 0;\\n        for (int candy : candies) {\\n            totalCandies += candy;\\n        }\\n\\n        return totalCandies;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] candies = new int[n];\\n        Arrays.fill(candies, 1);\\n\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                candies[i] = Math.max(candies[i], candies[i + 1] + 1);\\n            }\\n        }\\n\\n        int totalCandies = 0;\\n        for (int candy : candies) {\\n            totalCandies += candy;\\n        }\\n\\n        return totalCandies;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public int Candy(int[] ratings) {\\n        int n = ratings.Length;\\n        int[] candies = new int[n];\\n        Array.Fill(candies, 1);\\n\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                candies[i] = Math.Max(candies[i], candies[i + 1] + 1);\\n            }\\n        }\\n\\n        int totalCandies = 0;\\n        foreach (int candy in candies) {\\n            totalCandies += candy;\\n        }\\n\\n        return totalCandies;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} ratings\\n * @return {number}\\n */\\nvar candy = function(ratings) {\\n    const n = ratings.length;\\n    const candies = new Array(n).fill(1);\\n\\n    for (let i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (let i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1]) {\\n            candies[i] = Math.max(candies[i], candies[i + 1] + 1);\\n        }\\n    }\\n\\n    return candies.reduce((a, b) => a + b, 0);\\n};\\n```\n``` PHP []\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $ratings\\n     * @return Integer\\n     */\\n    function candy($ratings) {\\n        $n = count($ratings);\\n        $candies = array_fill(0, $n, 1);\\n\\n        for ($i = 1; $i < $n; $i++) {\\n            if ($ratings[$i] > $ratings[$i - 1]) {\\n                $candies[$i] = $candies[$i - 1] + 1;\\n            }\\n        }\\n\\n        for ($i = $n - 2; $i >= 0; $i--) {\\n            if ($ratings[$i] > $ratings[$i + 1]) {\\n                $candies[$i] = max($candies[$i], $candies[$i + 1] + 1);\\n            }\\n        }\\n\\n        return array_sum($candies);\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        if not ratings:\\n            return 0\\n        \\n        ret, up, down, peak = 1, 0, 0, 0\\n        \\n        for prev, curr in zip(ratings[:-1], ratings[1:]):\\n            if prev < curr:\\n                up, down, peak = up + 1, 0, up + 1\\n                ret += 1 + up\\n            elif prev == curr:\\n                up = down = peak = 0\\n                ret += 1\\n            else:\\n                up, down = 0, down + 1\\n                ret += 1 + down - int(peak >= down)\\n        \\n        return ret\\n\\n```\n``` Go []\\nfunc candy(ratings []int) int {\\n    if len(ratings) == 0 {\\n        return 0\\n    }\\n\\n    ret, up, down, peak := 1, 0, 0, 0\\n\\n    for i := 0; i < len(ratings) - 1; i++ {\\n        prev, curr := ratings[i], ratings[i+1]\\n\\n        if prev < curr {\\n            up++\\n            down = 0\\n            peak = up\\n            ret += 1 + up\\n        } else if prev == curr {\\n            up, down, peak = 0, 0, 0\\n            ret += 1\\n        } else {\\n            up = 0\\n            down++\\n            ret += 1 + down\\n            if peak >= down {\\n                ret--\\n            }\\n        }\\n    }\\n\\n    return ret\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn candy(ratings: Vec<i32>) -> i32 {\\n        if ratings.is_empty() {\\n            return 0;\\n        }\\n\\n        let mut ret = 1;\\n        let mut up = 0;\\n        let mut down = 0;\\n        let mut peak = 0;\\n\\n        for i in 0..ratings.len() - 1 {\\n            let (prev, curr) = (ratings[i], ratings[i + 1]);\\n\\n            if prev < curr {\\n                up += 1;\\n                down = 0;\\n                peak = up;\\n                ret += 1 + up;\\n            } else if prev == curr {\\n                up = 0;\\n                down = 0;\\n                peak = 0;\\n                ret += 1;\\n            } else {\\n                up = 0;\\n                down += 1;\\n                ret += 1 + down;\\n                if peak >= down {\\n                    ret -= 1;\\n                }\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42770,
                "title": "one-pass-constant-space-java-solution",
                "content": "Hi guys!\\n\\nThis solution picks each element from the input array only once. First, we give a candy to the first child. Then for each child we have three cases:\\n\\n 1. His/her rating is equal to the previous one -> give 1 candy.\\n 2. His/her rating is greater than the previous one -> give him (previous + 1) candies.\\n 3. His/her rating is less than the previous one -> don't know what to do yet, let's just count the number of such consequent cases.\\n \\nWhen we enter 1 or 2 condition we can check our count from 3. If it's not zero then we know that we were descending before and we have everything to update our total candies amount: number of children in descending sequence of raitings - coundDown, number of candies given at peak - prev (we don't update prev when descending). Total number of candies for \"descending\" children can be found through arithmetic progression formula (1+2+...+countDown). Plus we need to update our peak child if his number of candies is less then or equal to countDown. \\n\\nHere's a pretty concise code below.\\n\\n----------\\n\\n    public class Solution {\\n        public int candy(int[] ratings) {\\n            if (ratings == null || ratings.length == 0) return 0;\\n            int total = 1, prev = 1, countDown = 0;\\n            for (int i = 1; i < ratings.length; i++) {\\n                if (ratings[i] >= ratings[i-1]) {\\n                    if (countDown > 0) {\\n                        total += countDown*(countDown+1)/2; // arithmetic progression\\n                        if (countDown >= prev) total += countDown - prev + 1;\\n                        countDown = 0;\\n                        prev = 1;\\n                    }\\n                    prev = ratings[i] == ratings[i-1] ? 1 : prev+1;\\n                    total += prev;\\n                } else countDown++;\\n            }\\n            if (countDown > 0) { // if we were descending at the end\\n                total += countDown*(countDown+1)/2;\\n                if (countDown >= prev) total += countDown - prev + 1;\\n            }\\n            return total;\\n        }\\n    }\\n\\nHave a nice coding!",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int candy(int[] ratings) {\\n            if (ratings == null || ratings.length == 0) return 0;\\n            int total = 1, prev = 1, countDown = 0;\\n            for (int i = 1; i < ratings.length; i++) {\\n                if (ratings[i] >= ratings[i-1]) {\\n                    if (countDown > 0) {\\n                        total += countDown*(countDown+1)/2; // arithmetic progression\\n                        if (countDown >= prev) total += countDown - prev + 1;\\n                        countDown = 0;\\n                        prev = 1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1300194,
                "title": "python-o-n-time-solution-explained",
                "content": "Go from left to right and while increase, give the the next person +1 candy from previous, if not, leave number of candies as it was. In this way when we make this pass we make sure that condition that person with bigger value gets more candies fulfilled for pairs of adjusent persons where left person is smaller than right. Now, go from right to left and do the same: now we cover pairs of adjacent persons where right is smaller than left. After these two passes all persons are happy.\\n\\n#### Complexity\\nOverall time and space complexity is `O(n)`. Remark: there is also `O(1)` space complexity solution using the idea of peaks and valleys.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def candy(self, R):\\n        n, ans = len(R), [1]*len(R)\\n        \\n        for i in range(n-1):\\n            if R[i] < R[i+1]:\\n                ans[i+1] = max(1 + ans[i], ans[i+1])\\n                \\n        for i in range(n-2, -1, -1):\\n            if R[i+1] < R[i]:\\n                ans[i] = max(1 + ans[i+1], ans[i])\\n        \\n        return sum(ans)\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def candy(self, R):\\n        n, ans = len(R), [1]*len(R)\\n        \\n        for i in range(n-1):\\n            if R[i] < R[i+1]:\\n                ans[i+1] = max(1 + ans[i], ans[i+1])\\n                \\n        for i in range(n-2, -1, -1):\\n            if R[i+1] < R[i]:\\n                ans[i] = max(1 + ans[i+1], ans[i])\\n        \\n        return sum(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42774,
                "title": "very-simple-java-solution-with-detail-explanation",
                "content": "    We take ratings array as [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]\\n\\nIn the given problem each student will have at least 1 candy. So distribute 1 candy to each.\\n\\n    ratings:     [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]\\n    candies:     [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n\\nNow traverse the array from left to right. If the rating of (n+1) child is greater than (n) child then set the candy of (n+1) child as one candy more than the (n) child candies.\\n\\n    ratings:     [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]\\n    candies:     [1, 2, 1, 1, 2, 3, 4, 1, 1, 1, 2, 1]\\n\\nNow  traverse the array from right to left. If the (n) child rating is more than (n+1) child and (n) child candies is less than one more than (n+1) child candies then update the candies of (n) child as 1+ (n+1) candies.\\n\\n    ratings:     [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]\\n    candies:     [1, 2, 1, 1, 2, 3, 4, 3, 2, 1, 2, 1]\\n\\nTotal minimum candies: 23\\n\\n    public int candy(int[] ratings) {\\n            int sum=0;\\n            int[] a=new int[ratings.length];\\n            for(int i=0;i<a.length;i++)\\n            {\\n                a[i]=1;\\n            }\\n            for(int i=0;i<ratings.length-1;i++)\\n            {\\n                if(ratings[i+1]>ratings[i])\\n                {\\n                    a[i+1]=a[i]+1;\\n                }\\n            }\\n            for(int i=ratings.length-1;i>0;i--)\\n            {\\n                if(ratings[i-1]>ratings[i])\\n                {\\n                    if(a[i-1]<(a[i]+1))\\n                    {\\n                        a[i-1]=a[i]+1;\\n                    }\\n                }\\n            }\\n            for(int i=0;i<a.length;i++)\\n            {\\n                sum+=a[i];\\n            }\\n            return sum;\\n        }",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "    We take ratings array as [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]\\n\\nIn the given problem each student will have at least 1 candy. So distribute 1 candy to each.\\n\\n    ratings:     [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]\\n    candies:     [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n\\nNow traverse the array from left to right. If the rating of (n+1) child is greater than (n) child then set the candy of (n+1) child as one candy more than the (n) child candies.\\n\\n    ratings:     [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]\\n    candies:     [1, 2, 1, 1, 2, 3, 4, 1, 1, 1, 2, 1]\\n\\nNow  traverse the array from right to left. If the (n) child rating is more than (n+1) child and (n) child candies is less than one more than (n+1) child candies then update the candies of (n) child as 1+ (n+1) candies.\\n\\n    ratings:     [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]\\n    candies:     [1, 2, 1, 1, 2, 3, 4, 3, 2, 1, 2, 1]\\n\\nTotal minimum candies: 23\\n\\n    public int candy(int[] ratings) {\\n            int sum=0;\\n            int[] a=new int[ratings.length];\\n            for(int i=0;i<a.length;i++)\\n            {\\n                a[i]=1;\\n            }\\n            for(int i=0;i<ratings.length-1;i++)\\n            {\\n                if(ratings[i+1]>ratings[i])\\n                {\\n                    a[i+1]=a[i]+1;\\n                }\\n            }\\n            for(int i=ratings.length-1;i>0;i--)\\n            {\\n                if(ratings[i-1]>ratings[i])\\n                {\\n                    if(a[i-1]<(a[i]+1))\\n                    {\\n                        a[i-1]=a[i]+1;\\n                    }\\n                }\\n            }\\n            for(int i=0;i<a.length;i++)\\n            {\\n                sum+=a[i];\\n            }\\n            return sum;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1300022,
                "title": "candy-distribution-c-99-faster-explained",
                "content": "Used greedy aproach:\\n1. every student should get atleast one so initially give 1 candy to every student\\n2. Now traverse left to right, whenever we get a higher rating, it should get more candy from its neighbour( left neighbour in the curr case) so give just one more candy than its left neighbour\\n3. Now another case left when its right neighbour has higher rating, traverse from right, and if we get a higher rating, give it max(curr, 1+candy of its right). max ensures that for local maxima candies shuld be high than both neighbours;\\n\\n```\\nint candy(vector<int>& r) {\\n        int n = r.size();\\n        vector<int> c(n, 1);\\n        for (int i = 1; i < n; i++)\\n            if (r[i] > r[i - 1]) c[i] = c[i - 1] + 1;\\n        for (int i = n - 2; ~i; i--)\\n            if (r[i] > r[i + 1]) c[i] = max(c[i], c[i + 1] + 1);\\n        int res = 0;\\n        for (auto t: c) res += t;\\n        return res;\\n    }\\n```\\n**If you find it helpful, plz upvote**",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint candy(vector<int>& r) {\\n        int n = r.size();\\n        vector<int> c(n, 1);\\n        for (int i = 1; i < n; i++)\\n            if (r[i] > r[i - 1]) c[i] = c[i - 1] + 1;\\n        for (int i = n - 2; ~i; i--)\\n            if (r[i] > r[i + 1]) c[i] = max(c[i], c[i + 1] + 1);\\n        int res = 0;\\n        for (auto t: c) res += t;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037652,
                "title": "beats-99-93-greedy-two-solutions-c-java-python-commented-code",
                "content": "# Problem Description\\nThe task is distributing candies to a group of `n` children standing in a line. Each child is assigned a **rating value**, represented as an **integer** array called `ratings`.\\n\\nFollow **two specific requirements** while distributing the candies:\\n- Each child must have at least one candy.\\n- Children with a higher rating should receive more candies than their neighbors.\\n\\nThe **goal** is to determine the **minimum** number of candies needed to satisfy these requirements and distribute the candies to the children accordingly.\\n\\n- **Constraints:**\\n    - `n == ratings.length`\\n    - `1 <= n <= 2 * 104`\\n    - `0 <= ratings[i] <= 2 * 104`\\n    - at **least one candy** for each child\\n    - neighbours with **higher rating** have **more candies**\\n\\n\\n---\\n\\n\\n\\n# Intuition\\nHi there\\uD83D\\uDE00\\nLet\\'s take a look on this interesting problem.\\n\\nFor our candies task we have **two crucial requirements**: Each child must have **at least one** candy, and children with **higher ratings** than their **neighbors** have more candies than them... Interesting.\\n\\nLet\\'s explore some ratings\\' cases together:\\n\\n\\n```\\n2, 2, 2 \\n```\\nHere we can see that **each child** of them can have **one candy** since no one has higher rating than its neighbor.\\n\\n```\\n1, 2, 2, 2 \\n```\\nHere we can see that the array of candies will be `1, 2, 1, 1`.\\n\\n```\\n9, 8, 7\\n```\\nHere we can see that array of candies will be `3, 2, 1`.\\n\\n```\\n7, 8, 9\\n```\\nHere we can see that array of candies will be `1, 2, 3`.\\n\\n\\nI think now we have some **idea** about what is going on here\\uD83E\\uDD14\\n- Children with **equal ratings** can have different candies and that won\\'t violate our requirements since we are aiming for giving **minimum** candies.\\n- We must take care of **decreasing** subarrays and **increasing** ones.\\n\\nHow can we use an approach that take care of these **observations**?\\uD83D\\uDE80\\n\\n## Two Pass Approach \\nIn this approach we will:\\n- Iterate from `left to right` to take care of **increasing** subarrays \\n- Iterate from `right to left` to take care of **decreasing** subarrays\\n- We **won\\'t do anything** to **equal** neighbours since they won\\'t affect our requirements\\n\\nLet\\'s take an example:\\n```\\n9, 8, 8, 7, 7, 8, 9\\n```\\n**First** we have array of candes `1, 1, 1, 1, 1, 1, 1`\\n\\nAfter our **first pass** (from left to right) we will have array of candies `1, 1, 1, 1, 1, 2, 3`.\\nWe can see that it **handled** the **increasing** subarray perfectly.\\n\\nAfter our **second pass**(from right to left) we will have array of candies `2, 1, 2, 1, 1, 2, 3 `.\\nwe can see that it also **handled** the **decreasing** subarray perfectly.\\n\\nAlso, it handled the equal neighbours after the two passes. It finally minimized our candies. \\n\\n\\n## One Pass Approach \\nThis solution is more challenging since it requires us to handle the **three cases** in **one** pass. How can we start? \\uD83E\\uDD14\\nWe saw before that we have three cases **increasing** subarrays,  **decreasing** subarrays and **equal** subbarrays.\\nWe can start by intialize **three variables** to handle the three of them.\\n\\nFor **increasing** subarray we need one variable `up` to handle what candy we give to current child.\\nfor each child in the **increasing** subarray increase the `up` variable by one and give the current child `up + 1` candies indicating that it must have more that the child before him\\nwe will call `up + 1` as `peak` to mean the highest child in our subarray\\n\\nFor **equal** subarrays, only give them `one` candy and we will see that we only give one to the children in the middle of the subarray\\n\\nFor **decreasing** subarray here comes the challenge \\nWe will introduce variable like first case called `down` but the purpose of it **not** indicating that we give candies to current child but, giving **one** candy to current child and **one** candy for each child before him in the decreasing subarray to meet the requirements.\\n\\nExample : `1, 2, 3, 3, 2, 1`\\n![1.jpg](https://assets.leetcode.com/users/images/a99e9752-25cb-46f7-8d18-364b17088f96_1694573615.3577487.jpeg)\\n\\nBut what if we have **increasing** then **decreasing** subarrays?\\nWe will have the **last** child of the first subarray as first child on the second and then we give each child in the decreasing subarray one candy except that child who is our `peak` until the length of the subarray is larger than the `peak`.\\n\\nExample : `1, 2, 3, 2, 1`\\n![2.jpg](https://assets.leetcode.com/users/images/53bc278c-a910-47a6-846c-d8d85461c79c_1694573659.6552763.jpeg)\\n\\n\\n\\n---\\n\\n\\n\\n# Approach\\n\\n## Two Pass Approach\\n### Steps\\n- **Initialize** variables:\\n    - `n` is number of children.\\n    - `candies` to store candies for each child..\\n- **First Pass** (Left to Right):\\n    - For each child, **check** if the previous child has a **lower** rating and has **more** or **equal** candies.\\n    - If **true**, give the current child one more candy than the previous child.\\n- **Second Pass** (Right to Left):\\n    - For each child, **check** if the next child has a **lower** rating and has **more** or **equal** candies.\\n    - If **true**, give the current child one more candy than the next child.\\n    \\n- Calculate and return totalCandies.\\n\\n### Complexity\\n- **Time complexity:** $$O(N)$$\\nSince we are looping over the ratings array twice then the time complexity is `2*N` which is `O(N)`.\\n- **Space complexity:** $$O(N)$$\\nSince we are storing the number of candies for each child then the space complexity is `O(N)`.\\n\\n\\n---\\n\\n## One Pass Approach\\n### Steps\\n- **Initialize** variables:\\n    - `n` to store the number of children.\\n    - `upCount` to keep track of consecutive increasing ratings.\\n    - `downCount` to keep track of consecutive decreasing ratings.\\n    - `peakCount` to store the number of candies at the peak of increasing ratings.\\n    - `totalCandies` to count required candies.\\n- **Iterate** Through Ratings:\\n    - **compare** the child rating with the **previous** child\\n    - If current child has a **higher** rating than previous one then update the variables and add `peakCount` to `totalCandies`.\\n    - If current child has the **same** rating as previous one then update and add `1` to ``totalCandies``.\\n    - If current child has a **lower** rating than previous one update and update `totalCandies` by adding `downCount` + 1, subtracting `1` if `peakCount` is greater than `downCount`.\\n- **Return** `totalCandies`\\n\\n### Complexity\\n- **Time complexity:** $$O(N)$$\\nSince we are looping over the ratings array one time then the time complexity is `N` which is `O(N)`.\\n- **Space complexity:** $$O(1)$$\\nSince we are storing only couple of variables then the space complexity is `O(1)`.\\n\\n\\n---\\n\\n\\n\\n# Code\\n## Two Pass Approach\\n```C++ []\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size(); // Get the number of children\\n        \\n        vector<int> candies(n, 1); // Initialize a vector to store the number of candies for each child\\n        \\n        // First pass: Check ratings from left to right\\n        for(int i = 1; i < n; i++){\\n            if(ratings[i - 1] < ratings[i] && candies[i - 1] >= candies[i]){\\n                // If the current child has a higher rating and fewer or equal candies than the previous child,\\n                // give them one more candy than the previous child\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n        \\n        // Second pass: Check ratings from right to left\\n        for(int i = n - 2; i >= 0; i--){\\n            if(ratings[i + 1] < ratings[i] && candies[i + 1] >= candies[i]){\\n                // If the current child has a higher rating and fewer or equal candies than the next child,\\n                // give them one more candy than the next child\\n                candies[i] = candies[i + 1] + 1;\\n            }\\n        }\\n        \\n        int totalCandies = 0;\\n        \\n        // Calculate the total number of candies needed\\n        for(int i = 0; i < n; i++){\\n            totalCandies += candies[i];\\n        }\\n        \\n        return totalCandies;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length; // Get the number of children\\n        \\n        int[] candies = new int[n]; // Initialize an array to store the number of candies for each child\\n        \\n        // First pass: Check ratings from left to right\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i - 1] < ratings[i] && candies[i - 1] >= candies[i]) {\\n                // If the current child has a higher rating and fewer or equal candies than the previous child,\\n                // give them one more candy than the previous child\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n        \\n        // Second pass: Check ratings from right to left\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i + 1] < ratings[i] && candies[i + 1] >= candies[i]) {\\n                // If the current child has a higher rating and fewer or equal candies than the next child,\\n                // give them one more candy than the next child\\n                candies[i] = candies[i + 1] + 1;\\n            }\\n        }\\n        \\n        int totalCandies = 0;\\n        \\n        // Calculate the total number of candies needed\\n        for (int i = 0; i < n; i++) {\\n            totalCandies += candies[i] + 1;\\n        }\\n        \\n        return totalCandies;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def candy(self, ratings) -> int:\\n        n = len(ratings)  # Get the number of children\\n        \\n        candies = [1] * n  # Initialize a list to store the number of candies for each child\\n        \\n        # First pass: Check ratings from left to right\\n        for i in range(1, n):\\n            if ratings[i - 1] < ratings[i] and candies[i - 1] >= candies[i]:\\n                # If the current child has a higher rating and fewer or equal candies than the previous child,\\n                # give them one more candy than the previous child\\n                candies[i] = candies[i - 1] + 1\\n        \\n        # Second pass: Check ratings from right to left\\n        for i in range(n - 2, -1, -1):\\n            if ratings[i + 1] < ratings[i] and candies[i + 1] >= candies[i]:\\n                # If the current child has a higher rating and fewer or equal candies than the next child,\\n                # give them one more candy than the next child\\n                candies[i] = candies[i + 1] + 1\\n        \\n        total_candies = sum(candies)  # Calculate the total number of candies needed\\n        \\n        return total_candies\\n```\\n\\n## One Pass Approach\\n```C++ []\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size(); // Get the number of children\\n        int upCount = 0, downCount = 0, peakCount = 0, totalCandies = 1; // Initialize variables\\n        \\n        for(int i = 1; i < n ; i ++){\\n            if(ratings[i - 1] < ratings[i]){\\n                // If the current child has a higher rating than the previous one\\n                downCount = 0;\\n                upCount += 1;\\n                peakCount = upCount + 1;\\n                totalCandies += peakCount;\\n            } else if(ratings[i - 1] == ratings[i]){\\n                // If the current child has the same rating as the previous one\\n                downCount = 0;\\n                upCount = 0;\\n                peakCount = 0;\\n                totalCandies += 1;\\n            } else {\\n                // If the current child has a lower rating than the previous one\\n                downCount += 1;\\n                upCount = 0;\\n                totalCandies += downCount + 1 - (peakCount > downCount);\\n            }\\n        }\\n        \\n        return totalCandies;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length; // Get the number of children\\n        int upCount = 0, downCount = 0, peakCount = 0, totalCandies = 1; // Initialize variables\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i - 1] < ratings[i]) {\\n                // If the current child has a higher rating than the previous one\\n                downCount = 0;\\n                upCount += 1;\\n                peakCount = upCount + 1;\\n                totalCandies += peakCount;\\n            } else if (ratings[i - 1] == ratings[i]) {\\n                // If the current child has the same rating as the previous one\\n                downCount = 0;\\n                upCount = 0;\\n                peakCount = 0;\\n                totalCandies += 1;\\n            } else {\\n                // If the current child has a lower rating than the previous one\\n                downCount += 1;\\n                upCount = 0;\\n                totalCandies += downCount + 1 - (peakCount > downCount ? 1 : 0);\\n            }\\n        }\\n        \\n        return totalCandies;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def candy(self, ratings) -> int:\\n        n = len(ratings)  # Get the number of children\\n        upCount = downCount = peakCount = 0\\n        totalCandies = 1  # Initialize variables\\n        \\n        for i in range(1, n):\\n            if ratings[i - 1] < ratings[i]:\\n                # If the current child has a higher rating than the previous one\\n                downCount = 0\\n                upCount += 1\\n                peakCount = upCount + 1\\n                totalCandies += peakCount\\n            elif ratings[i - 1] == ratings[i]:\\n                # If the current child has the same rating as the previous one\\n                downCount = 0\\n                upCount = 0\\n                peakCount = 0\\n                totalCandies += 1\\n            else:\\n                # If the current child has a lower rating than the previous one\\n                downCount += 1\\n                upCount = 0\\n                totalCandies += downCount + 1 - (1 if peakCount > downCount else 0)\\n        \\n        return totalCandies\\n```\\n\\n\\n![leet_sol.jpg](https://assets.leetcode.com/users/images/fa9927ee-3d40-447d-ae31-148ce5f55633_1694564084.5767484.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\n2, 2, 2 \\n```\n```\\n1, 2, 2, 2 \\n```\n```\\n9, 8, 7\\n```\n```\\n7, 8, 9\\n```\n```\\n9, 8, 8, 7, 7, 8, 9\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size(); // Get the number of children\\n        \\n        vector<int> candies(n, 1); // Initialize a vector to store the number of candies for each child\\n        \\n        // First pass: Check ratings from left to right\\n        for(int i = 1; i < n; i++){\\n            if(ratings[i - 1] < ratings[i] && candies[i - 1] >= candies[i]){\\n                // If the current child has a higher rating and fewer or equal candies than the previous child,\\n                // give them one more candy than the previous child\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n        \\n        // Second pass: Check ratings from right to left\\n        for(int i = n - 2; i >= 0; i--){\\n            if(ratings[i + 1] < ratings[i] && candies[i + 1] >= candies[i]){\\n                // If the current child has a higher rating and fewer or equal candies than the next child,\\n                // give them one more candy than the next child\\n                candies[i] = candies[i + 1] + 1;\\n            }\\n        }\\n        \\n        int totalCandies = 0;\\n        \\n        // Calculate the total number of candies needed\\n        for(int i = 0; i < n; i++){\\n            totalCandies += candies[i];\\n        }\\n        \\n        return totalCandies;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length; // Get the number of children\\n        \\n        int[] candies = new int[n]; // Initialize an array to store the number of candies for each child\\n        \\n        // First pass: Check ratings from left to right\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i - 1] < ratings[i] && candies[i - 1] >= candies[i]) {\\n                // If the current child has a higher rating and fewer or equal candies than the previous child,\\n                // give them one more candy than the previous child\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n        \\n        // Second pass: Check ratings from right to left\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i + 1] < ratings[i] && candies[i + 1] >= candies[i]) {\\n                // If the current child has a higher rating and fewer or equal candies than the next child,\\n                // give them one more candy than the next child\\n                candies[i] = candies[i + 1] + 1;\\n            }\\n        }\\n        \\n        int totalCandies = 0;\\n        \\n        // Calculate the total number of candies needed\\n        for (int i = 0; i < n; i++) {\\n            totalCandies += candies[i] + 1;\\n        }\\n        \\n        return totalCandies;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def candy(self, ratings) -> int:\\n        n = len(ratings)  # Get the number of children\\n        \\n        candies = [1] * n  # Initialize a list to store the number of candies for each child\\n        \\n        # First pass: Check ratings from left to right\\n        for i in range(1, n):\\n            if ratings[i - 1] < ratings[i] and candies[i - 1] >= candies[i]:\\n                # If the current child has a higher rating and fewer or equal candies than the previous child,\\n                # give them one more candy than the previous child\\n                candies[i] = candies[i - 1] + 1\\n        \\n        # Second pass: Check ratings from right to left\\n        for i in range(n - 2, -1, -1):\\n            if ratings[i + 1] < ratings[i] and candies[i + 1] >= candies[i]:\\n                # If the current child has a higher rating and fewer or equal candies than the next child,\\n                # give them one more candy than the next child\\n                candies[i] = candies[i + 1] + 1\\n        \\n        total_candies = sum(candies)  # Calculate the total number of candies needed\\n        \\n        return total_candies\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size(); // Get the number of children\\n        int upCount = 0, downCount = 0, peakCount = 0, totalCandies = 1; // Initialize variables\\n        \\n        for(int i = 1; i < n ; i ++){\\n            if(ratings[i - 1] < ratings[i]){\\n                // If the current child has a higher rating than the previous one\\n                downCount = 0;\\n                upCount += 1;\\n                peakCount = upCount + 1;\\n                totalCandies += peakCount;\\n            } else if(ratings[i - 1] == ratings[i]){\\n                // If the current child has the same rating as the previous one\\n                downCount = 0;\\n                upCount = 0;\\n                peakCount = 0;\\n                totalCandies += 1;\\n            } else {\\n                // If the current child has a lower rating than the previous one\\n                downCount += 1;\\n                upCount = 0;\\n                totalCandies += downCount + 1 - (peakCount > downCount);\\n            }\\n        }\\n        \\n        return totalCandies;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length; // Get the number of children\\n        int upCount = 0, downCount = 0, peakCount = 0, totalCandies = 1; // Initialize variables\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i - 1] < ratings[i]) {\\n                // If the current child has a higher rating than the previous one\\n                downCount = 0;\\n                upCount += 1;\\n                peakCount = upCount + 1;\\n                totalCandies += peakCount;\\n            } else if (ratings[i - 1] == ratings[i]) {\\n                // If the current child has the same rating as the previous one\\n                downCount = 0;\\n                upCount = 0;\\n                peakCount = 0;\\n                totalCandies += 1;\\n            } else {\\n                // If the current child has a lower rating than the previous one\\n                downCount += 1;\\n                upCount = 0;\\n                totalCandies += downCount + 1 - (peakCount > downCount ? 1 : 0);\\n            }\\n        }\\n        \\n        return totalCandies;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def candy(self, ratings) -> int:\\n        n = len(ratings)  # Get the number of children\\n        upCount = downCount = peakCount = 0\\n        totalCandies = 1  # Initialize variables\\n        \\n        for i in range(1, n):\\n            if ratings[i - 1] < ratings[i]:\\n                # If the current child has a higher rating than the previous one\\n                downCount = 0\\n                upCount += 1\\n                peakCount = upCount + 1\\n                totalCandies += peakCount\\n            elif ratings[i - 1] == ratings[i]:\\n                # If the current child has the same rating as the previous one\\n                downCount = 0\\n                upCount = 0\\n                peakCount = 0\\n                totalCandies += 1\\n            else:\\n                # If the current child has a lower rating than the previous one\\n                downCount += 1\\n                upCount = 0\\n                totalCandies += downCount + 1 - (1 if peakCount > downCount else 0)\\n        \\n        return totalCandies\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301166,
                "title": "c-solution-o-n-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int>left(n, 1), right(n, 1);\\n        \\n        //traverse left to right and compare curr value with left side value\\n        for(int i = 1; i < n; i++)\\n            if(ratings[i] > ratings[i-1]) left[i] = left[i-1]+1;\\n              \\n         //traverse right to left and compare curr value with right side value\\n        for(int i = n-2; i >= 0; i--)\\n            if(ratings[i] > ratings[i+1]) right[i] = right[i+1]+1;\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            ans += max(left[i], right[i]);\\n        \\n        return ans;            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int>left(n, 1), right(n, 1);\\n        \\n        //traverse left to right and compare curr value with left side value\\n        for(int i = 1; i < n; i++)\\n            if(ratings[i] > ratings[i-1]) left[i] = left[i-1]+1;\\n              \\n         //traverse right to left and compare curr value with right side value\\n        for(int i = n-2; i >= 0; i--)\\n            if(ratings[i] > ratings[i+1]) right[i] = right[i+1]+1;\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            ans += max(left[i], right[i]);\\n        \\n        return ans;            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42795,
                "title": "two-c-solutions-given-with-explanation-both-with-o-n-time-one-with-o-1-space-the-other-with-o-n-space",
                "content": "The question requires us to make sure a child with a higher rate has more candies than its left and right neighbors. One simple solution is to do two scans: one foward scan (from 1 to N-1) to make sure child i has more candies than its left neighbor if its rate is higher than its left neighbor. After the forward scan, we can guarantee that the left neighbor relationship is correct but we have to do more to make the right neighbor relationship in order; so we do the backwarad scan (from N-2 to 0) to make child i has more candies than its right neighbor i+1 if its rate is higher than its right neighbor. In the following implementation, we need a O(N) array number to save the number of candies needed for children, so it has O(N) space complexity and we do two linear scans so the time complexity is O(N) \\n\\n    class Solution {\\n    public:\\n        int candy(vector<int>& ratings) {\\n            int len = ratings.size(), res = 0, i;\\n            if(len>0)\\n            {\\n                vector<int> number(len,0); // to save the number of candies for child[0:N-1]\\n                number[0] = 1; \\n    // forward scan to calculate how many candies needed for child i to make sure it has more candies than its left neighbor if it has a higher rate, otherwise, give one candy to it\\n                for(i=1; i<len;++i) number[i] = ratings[i]>ratings[i-1]?number[i-1]+1:1;\\n    \\n    // backward scan to calculate to make sure child i has more candies than its right neighbor if it has a higher rate, pick the bigger one from forward and backward scans as the final number for child i\\n                for(i=len-2, res = number[len-1]; i>=0;--i)\\n                {\\n                    if( (ratings[i]>ratings[i+1]) && number[i]<(number[i+1]+1) ) number[i] = number[i+1]+1;\\n                    res += number[i];\\n                }\\n            }\\n            return res;\\n        }\\n    };\\n\\nNow, the question is can we do better? Do we really need two scans? If we do only forward scan, then the problem is we can not guarantee the right neighbor relationship holds. i.e. we don't know if the following order is descending (i>i+1>i+2>...). and that may cause issues. To fix that, we will detect the dips (the points at which the order switchs from increasing to decreasng). We will make sure all the local dips (minimum points) has only one candy and update its previous neighbors (which has hgher rates than its rate) accordingly. To do such update, we need to know when the decrease starts, so we use pPos to save that starting points. \\nSo the solution becomes: do the forward scan, if it is in an increasing order (child i rate > child i-1 order), check if it is a local dip (neg_peak == true): if so, update the candy number to make sure child i-1 has one candy. if not, just give one more candy to child i. If it is in an decreasing order (child i rate < child i-1 order)\\n, just give one less candy to i. don't forget at last, we still need to make sure child N-1 has one or more candy. So O(1) space , O(N) time\\n\\n        class Solution {\\n        public:\\n            int candy(vector<int>& ratings) {\\n                const int len = ratings.size();\\n                if(len<=1) return len;\\n                \\n                int i, pPos, res=1, peak=1; // peak: # candies given to the i-1 child\\n                bool neg_peak = false; // flag to indicate if it is a local dip\\n                for(i=1; i<len;i++)\\n                {\\n                    if(ratings[i] >= ratings[i-1]) \\n                    {   // it is increasing\\n                        if(neg_peak) \\n                        {  // it is a local dip, we need to make sure i-1 has one candy\\n                            res -= (peak-1) * (i-pPos - (peak>0));\\n                            peak = 1;\\n                            neg_peak = false;\\n                        }\\n                       // update child i candy number, if equal, set to 1\\n                        peak = (ratings[i] == ratings[i-1])? 1:++peak;\\n                        res += peak;\\n                    }\\n                    else\\n                    { // decreasing, just give one less candy, if it is the starting point of a decrease, update pPos\\n                        if(!neg_peak) {pPos = i-1; neg_peak = true;}\\n                        res += --peak;\\n                    }\\n                }\\n    // don't forget to update res, if the last one is a local dip\\n                return !neg_peak? res : res - (peak-1) * (i-pPos - (peak>0));\\n        \\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int candy(vector<int>& ratings) {\\n            int len = ratings.size(), res = 0, i;\\n            if(len>0)\\n            {\\n                vector<int> number(len,0); // to save the number of candies for child[0:N-1]\\n                number[0] = 1; \\n    // forward scan to calculate how many candies needed for child i to make sure it has more candies than its left neighbor if it has a higher rate, otherwise, give one candy to it\\n                for(i=1; i<len;++i) number[i] = ratings[i]>ratings[i-1]?number[i-1]+1:1;\\n    \\n    // backward scan to calculate to make sure child i has more candies than its right neighbor if it has a higher rate, pick the bigger one from forward and backward scans as the final number for child i\\n                for(i=len-2, res = number[len-1]; i>=0;--i)\\n                {\\n                    if( (ratings[i]>ratings[i+1]) && number[i]<(number[i+1]+1) ) number[i] = number[i+1]+1;\\n                    res += number[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 42881,
                "title": "python-two-pass-solution-left-to-right-then-right-to-left",
                "content": "        \\n    def candy(self, ratings):\\n        res = len(ratings) * [1]\\n        for i in xrange(1, len(ratings)):  # from left to right\\n            if ratings[i] > ratings[i-1]:\\n                res[i] = res[i-1] + 1\\n        for i in xrange(len(ratings)-1, 0, -1):  # from right to left\\n            if ratings[i-1] > ratings[i]:\\n                res[i-1] = max(res[i-1], res[i]+1)\\n        return sum(res)",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def candy(self, ratings):\\n        res = len(ratings) * [1]\\n        for i in xrange(1, len(ratings)):  # from left to right\\n            if ratings[i] > ratings[i-1]:\\n                res[i] = res[i-1] + 1\\n        for i in xrange(len(ratings)-1, 0, -1):  # from right to left\\n            if ratings[i-1] > ratings[i]:\\n                res[i-1] = max(res[i-1], res[i]+1)\\n        return sum(res)",
                "codeTag": "Python3"
            },
            {
                "id": 42878,
                "title": "c-easy-to-understand-solution-with-lot-of-comments-o-n-constant-space-one-pass",
                "content": "Let me know if you find it easy please.\\n\\n    Ratings:\\n                        Peak\\n            Peak        |\\n            |           | |\\n          | |           | | |   \\n        | | | |       | | | | |       | | |\\n      | | | | | |   | | | | | | |     | | |\\n    | | | | | | | | | | | | | | | | | | | |\\n                    Candies:\\n    1 2 3 4 5 3 2 1 2 3 5 4 3 2 1 1 1 2 1 1\\n    x---a---x\\n            x--b--x    \\n\\n\\n\\n\\n\\n    \\n\\n\\n\\n It seems easy to track the length of the slopes of the mountains (sequence of all ascending or \\n all descending ratings)\\n and then sum the candies for the two slopes (an easy n*(n+1)/2), with land sequences adding +1 each \\n rating value. \\n\\n It almost works.\\n Big problem is we don't know who the peak belongs (left or right slope?)\\n\\n Example: the first sequence \"a\" is made of 5 ascending elements. \\n    The second sequence \"b\" is made of 4 descending elements.\\n    Which slope gets the peak? \\n\\n Answer: the longest. So for the first mountain \"a\" slope is\\n \\n    L(a)=4    ==>  4+3+2+1 candies \\n\\nand \"b\" is \\n\\n    L(b)=3 ==> 3+2+1 candies\\n\\nPeak is \\n\\n    max(L(a),L(b)) + 1 ==>5 candies.\\n         \\n\\n Unfortunately we can know the longer side of the mountain at the end of the mountain only.\\n\\n So we use \"up\" and \"down\" variable to track the length of the slopes. We sum the candies \\n at the end of each mountain and then we reset the slopes to zero.\\n\\n Special case: we have same rating twice (land). This ends a mountain even if it was ascending \\n (that means: descending slope of length = 0)\\n\\n And to make things more complicated, the last element of a sequence \\n is also the beginning of the next sequence (another mountain or land),\\n so we take that into account.\\n\\n\\n    class Solution {\\n    public:\\n        // Candies for a slope of n elements\\n        int slope(int n)\\n        {\\n            return (n*(n+1))/2;\\n        }\\n    \\n        int candy(vector<int> &ratings) {\\n            if (ratings.size() <= 1 )\\n            {\\n                return ratings.size();\\n            }\\n            int tot = 0;        // The final amount of candies\\n            int up = 0;         // Lenght of the last ascending slope\\n            int down = 0;       // Lenght of the last descending slope\\n            int oldsign = 0;    // Previous ratings trend (1 = ascending, -1 == descending, 0 = stable) \\n    \\n            for (int i = 1; i< ratings.size(); i++)\\n            {\\n                            // Current ratings trend, same meaning as oldsign\\n                int newsign = ratings[i] > ratings[i-1] ? 1 : \\n                              ratings[i] < ratings[i-1] ? -1 : 0;\\n                            // We can calculate the contribution of a slope \\n                            // when that slope ends and it's not the peak of a mountain,\\n                            // that's why we have \"newsign == 0\" and not \"newsign <= 0\"\\n                if ((oldsign > 0 && newsign == 0)  ||\\n                    (oldsign < 0  && newsign >= 0) )\\n                    {\\n                            // The peak of the mountain should have max(up,down)+1\\n                            // candies, but the end of the mountain is the beginning of\\n                            // the next sequence, so we don't the candy at the end of \\n                            // the mountain\\n                        tot += slope(up) + slope(down) + std::max(up, down);\\n                        up = 0;\\n                        down = 0;\\n                    }\\n    \\n                if(newsign > 0)\\n                    up++;\\n                if(newsign < 0)\\n                    down++;\\n                        // Same rating of the previous child?\\n                        // Take one candy.If you are better then the next child\\n                        // the descending slope will take that into account, don't worry\\n                if(newsign == 0)\\n                    tot++;\\n                    \\n                oldsign = newsign;\\n            }\\n            \\n                        // Final sequence has to be closed\\n                        // Why +1? Because we don't have a sequence next!\\n            tot += ramp(up) + ramp(down) + std::max(up, down) + 1;\\n            return tot;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        // Candies for a slope of n elements\\n        int slope(int n)\\n        {\\n            return (n*(n+1))/2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2234774,
                "title": "c-using-two-arrays-easy-to-understand-with-comments",
                "content": "**TIME COMPLEXITY = O(N)**\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int ans = 0, n= ratings.size();\\n        \\n        // it take care about student get more candies than its left neighbor\\n        vector<int>L_candy(n,1);\\n        for(int i=1; i<n; i++){\\n            if(ratings[i]>ratings[i-1] )\\n                L_candy[i]=L_candy[i-1]+1;\\n        }\\n        \\n        // it take care about student get more candies than its right neighbor\\n        vector<int> R_candy(n,1);\\n        for(int i=n-2; i>=0; i--){\\n            if(ratings[i]>ratings[i+1] )\\n                R_candy[i] = R_candy[i+1]+1;\\n        }\\n        \\n        // here we take the maximum value which satisfy both the left and the right neighbor condition \\n        for(int i=0; i<n; i++){\\n            ans += max(L_candy[i], R_candy[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf you like the post then **upVote!!!**",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int ans = 0, n= ratings.size();\\n        \\n        // it take care about student get more candies than its left neighbor\\n        vector<int>L_candy(n,1);\\n        for(int i=1; i<n; i++){\\n            if(ratings[i]>ratings[i-1] )\\n                L_candy[i]=L_candy[i-1]+1;\\n        }\\n        \\n        // it take care about student get more candies than its right neighbor\\n        vector<int> R_candy(n,1);\\n        for(int i=n-2; i>=0; i--){\\n            if(ratings[i]>ratings[i+1] )\\n                R_candy[i] = R_candy[i+1]+1;\\n        }\\n        \\n        // here we take the maximum value which satisfy both the left and the right neighbor condition \\n        for(int i=0; i<n; i++){\\n            ans += max(L_candy[i], R_candy[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038784,
                "title": "video-o-n-time-o-1-space-solution-python-javascript-java-c",
                "content": "# Intuition\\nKeep two peak values and subtract the lower peak from total.\\n\\n---\\n\\n# Solution Video\\n\\nhttps://youtu.be/f5oFx-X0eS4\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2310\\nThank you for your support!\\n\\n---\\n\\n# Approach\\n\\n## \\u25A0 Step 1\\nIntialize `total_candies` with `len(ratings)` because at least all children has one candy.\\n\\n## \\u25A0 Step 2\\nWe iterate through `ratings` one by one.\\n\\n### case1\\n```\\nif ratings[i] == ratings[i - 1]:\\n```\\nwe don\\'t have to give a candy to the current `i` child because current `i` child has the same rating with previous child. Just increment `i` and continue.\\n\\n### case2\\n```\\nwhile i < n and ratings[i] > ratings[i - 1]:\\n```\\nThis case indicates that the current `i` child has higher raiting than `i - 1` previous child. In this case, we need to give candies to the current `i` child.\\n\\nAdd `+1` to `current_peak` and add `current_peak` to `total_candies` and incremtnt `i`. this process continues until we don\\'t meet case2 `while condition` above.\\n\\nLet me explain `current_peak` in \"How it works\" section.\\n\\n### case3\\n```\\nwhile i < n and ratings[i] < ratings[i - 1]:\\n```\\nThis case indicates that the current `i` child has lower raiting than `i - 1` previous child. In this case, actually we do the same thing of `case2`. Because even if input is decreasing order `[9,5,3,1]`, we need to give candies to the current `i` child. In the end, total candies are 10 `[4,3,2,1]`. we need some extra candies.\\n\\nAdd `+1` to `current_valley` and add `current_valley` to `total_candies` and incremtnt `i`. this process continues until we don\\'t meet case 3 `while condition` above.\\n\\nLet me explain `current_valley` in \"How it works\" section.\\n\\nIn the last of Step 2, subtract minium of `current_peak` or `current_valley` from `total_candies`.\\n\\n# How it works\\nLet\\'s think with this input. \\n```\\nInput: ratings = [2,4,6,7,3,2,2]\\n```\\n```\\ntotal_candies(Let\\'s say \"total\") = 7 (length of input array)\\ncurrent_peak(Let\\'s say \"peak\") = 0\\ncurrent_valley(Let\\'s say \"valley\") = 0\\n\\n```\\nIn Step2, starting from `index 1`.\\n```\\n\\u25A0 Case2\\ncondtion: while i < n and ratings[i] > ratings[i - 1]:\\n\\nindex 1 > index 0, so peak = 1, valley = 0, total = 8 (7 + 1)\\nindex 2 > index 1, so peak = 2, valley = 0, total = 10 (8 + 2)\\nindex 3 > index 2, so peak = 3, valley = 0, total = 13 (10 + 3)\\nindex 4 < index 3, then stop Case2\\n\\nOur code distrubtes candies like this so far\\nfrom [1,1,1,1,1,1,1]\\nto   [1,2,3,4,1,1,1](total 13 candies)\\n```\\n```\\n\\u25A0 Case3\\ncondtion: while i < n and ratings[i] < ratings[i - 1]:\\n\\nindex 4 < index 3, so peak = 3, valley = 1, total = 14 (13 + 1)\\nindex 5 < index 4, so peak = 3, valley = 2, total = 16 (14 + 2)\\nindex 6 == index 5, then stop Case3\\n\\nOur code distrubtes candies like this so far\\nfrom [1,2,3,4,1,1,1](Case2)\\nto   [1,2,3,4,2,3,1](total 16 candies)\\n```\\n\\nLet me explain `total_candies -= min(current_peak, current_valley)`\\nBefore that, `the last rating(index 6)` is equal to `index 5`, so we don\\'t do anything(meet `Case1`). Let me skip it.\\n\\nNow Look at this. When ratings = `[2,4,6,7,3,2,2]`\\n```\\nThis is real distribution, In other words, the minimum number of\\ncandies you need to have to distribute\\n\\n[1,2,3,4,2,1,1] = 14 candies\\n[1,1,1,1,1,1,1]\\n[0,1,2,3,1,0,0](additional candies for each children)\\n```\\n```\\nHow our code distributes candies\\n\\n[1,2,3,4,2,3,1] = 16 candies\\n[1,1,1,1,1,1,1]\\n[0,1,2,3,1,2,0](additional candies for each children)\\n```\\n\\nCompare distribution of adittional candies.\\n```\\n[0,1,2,3,1,0,0](Real)\\n[0,1,2,3,1,2,0](Our code)\\n```\\nOur code distributes `extra 2 candies` at `index 5` which is equal to minimum of `current_peak` or `current_valley`. That\\'s because actually we add peaks twice as a `peak` and as a `valley` in Case2 and Case3. For this question, we need peak value only once. More precisely, we need only higher peak between range of one of `peak` and `valley` combinations(in this case between `index1` and `index5`), because of constraints from the description saying \"Children with a higher rating get more candies than their neighbors\".\\n\\nThat\\'s why we need to substract `minimum peak` from `total_candies`. In this case `16 - 2`. `peak = 3` vs `valley = 2`\\n\\n```\\nOutput: 14\\n```\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\'n\\' is the number of elements in the \\'ratings\\' list. This is because we are using a single loop to iterate through the ratings, and within the loop, we perform constant time operations.\\n\\n- Space complexity: O(1), which means it uses a constant amount of additional memory regardless of the size of the \\'ratings\\' list. The only variables that consume memory are \\'n\\', \\'total_candies\\', \\'i\\', \\'current_peak\\', and \\'current_valley\\', and these variables do not depend on the input size \\'n\\'.\\n\\n```python []\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        total_candies = n\\n        i = 1\\n\\n        while i < n:\\n            if ratings[i] == ratings[i - 1]:\\n                i += 1\\n                continue\\n\\n            current_peak = 0\\n            while i < n and ratings[i] > ratings[i - 1]:\\n                current_peak += 1\\n                total_candies += current_peak\\n                i += 1\\n            \\n            if i == n:\\n                return total_candies\\n\\n            current_valley = 0\\n            while i < n and ratings[i] < ratings[i - 1]:\\n                current_valley += 1\\n                total_candies += current_valley\\n                i += 1\\n\\n            total_candies -= min(current_peak, current_valley)\\n\\n        return total_candies\\n```\\n```javascript []\\n/**\\n * @param {number[]} ratings\\n * @return {number}\\n */\\nvar candy = function(ratings) {\\n    const n = ratings.length;\\n    let totalCandies = n;\\n    let i = 1;\\n\\n    while (i < n) {\\n        if (ratings[i] === ratings[i - 1]) {\\n            i++;\\n            continue;\\n        }\\n\\n        let currentPeak = 0;\\n        while (i < n && ratings[i] > ratings[i - 1]) {\\n            currentPeak++;\\n            totalCandies += currentPeak;\\n            i++;\\n        }\\n\\n        if (i === n) {\\n            return totalCandies;\\n        }\\n\\n        let currentValley = 0;\\n        while (i < n && ratings[i] < ratings[i - 1]) {\\n            currentValley++;\\n            totalCandies += currentValley;\\n            i++;\\n        }\\n\\n        totalCandies -= Math.min(currentPeak, currentValley);\\n    }\\n\\n    return totalCandies;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int totalCandies = n;\\n        int i = 1;\\n\\n        while (i < n) {\\n            if (ratings[i] == ratings[i - 1]) {\\n                i++;\\n                continue;\\n            }\\n\\n            int currentPeak = 0;\\n            while (i < n && ratings[i] > ratings[i - 1]) {\\n                currentPeak++;\\n                totalCandies += currentPeak;\\n                i++;\\n            }\\n\\n            if (i == n) {\\n                return totalCandies;\\n            }\\n\\n            int currentValley = 0;\\n            while (i < n && ratings[i] < ratings[i - 1]) {\\n                currentValley++;\\n                totalCandies += currentValley;\\n                i++;\\n            }\\n\\n            totalCandies -= Math.min(currentPeak, currentValley);\\n        }\\n\\n        return totalCandies;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n       int n = ratings.size();\\n        int totalCandies = n;\\n        int i = 1;\\n\\n        while (i < n) {\\n            if (ratings[i] == ratings[i - 1]) {\\n                i++;\\n                continue;\\n            }\\n\\n            int currentPeak = 0;\\n            while (i < n && ratings[i] > ratings[i - 1]) {\\n                currentPeak++;\\n                totalCandies += currentPeak;\\n                i++;\\n            }\\n\\n            if (i == n) {\\n                return totalCandies;\\n            }\\n\\n            int currentValley = 0;\\n            while (i < n && ratings[i] < ratings[i - 1]) {\\n                currentValley++;\\n                totalCandies += currentValley;\\n                i++;\\n            }\\n\\n            totalCandies -= min(currentPeak, currentValley);\\n        }\\n\\n        return totalCandies;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nif ratings[i] == ratings[i - 1]:\\n```\n```\\nwhile i < n and ratings[i] > ratings[i - 1]:\\n```\n```\\nwhile i < n and ratings[i] < ratings[i - 1]:\\n```\n```\\nInput: ratings = [2,4,6,7,3,2,2]\\n```\n```\\ntotal_candies(Let\\'s say \"total\") = 7 (length of input array)\\ncurrent_peak(Let\\'s say \"peak\") = 0\\ncurrent_valley(Let\\'s say \"valley\") = 0\\n\\n```\n```\\n\\u25A0 Case2\\ncondtion: while i < n and ratings[i] > ratings[i - 1]:\\n\\nindex 1 > index 0, so peak = 1, valley = 0, total = 8 (7 + 1)\\nindex 2 > index 1, so peak = 2, valley = 0, total = 10 (8 + 2)\\nindex 3 > index 2, so peak = 3, valley = 0, total = 13 (10 + 3)\\nindex 4 < index 3, then stop Case2\\n\\nOur code distrubtes candies like this so far\\nfrom [1,1,1,1,1,1,1]\\nto   [1,2,3,4,1,1,1](total 13 candies)\\n```\n```\\n\\u25A0 Case3\\ncondtion: while i < n and ratings[i] < ratings[i - 1]:\\n\\nindex 4 < index 3, so peak = 3, valley = 1, total = 14 (13 + 1)\\nindex 5 < index 4, so peak = 3, valley = 2, total = 16 (14 + 2)\\nindex 6 == index 5, then stop Case3\\n\\nOur code distrubtes candies like this so far\\nfrom [1,2,3,4,1,1,1](Case2)\\nto   [1,2,3,4,2,3,1](total 16 candies)\\n```\n```\\nThis is real distribution, In other words, the minimum number of\\ncandies you need to have to distribute\\n\\n[1,2,3,4,2,1,1] = 14 candies\\n[1,1,1,1,1,1,1]\\n[0,1,2,3,1,0,0](additional candies for each children)\\n```\n```\\nHow our code distributes candies\\n\\n[1,2,3,4,2,3,1] = 16 candies\\n[1,1,1,1,1,1,1]\\n[0,1,2,3,1,2,0](additional candies for each children)\\n```\n```\\n[0,1,2,3,1,0,0](Real)\\n[0,1,2,3,1,2,0](Our code)\\n```\n```\\nOutput: 14\\n```\n```python []\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        total_candies = n\\n        i = 1\\n\\n        while i < n:\\n            if ratings[i] == ratings[i - 1]:\\n                i += 1\\n                continue\\n\\n            current_peak = 0\\n            while i < n and ratings[i] > ratings[i - 1]:\\n                current_peak += 1\\n                total_candies += current_peak\\n                i += 1\\n            \\n            if i == n:\\n                return total_candies\\n\\n            current_valley = 0\\n            while i < n and ratings[i] < ratings[i - 1]:\\n                current_valley += 1\\n                total_candies += current_valley\\n                i += 1\\n\\n            total_candies -= min(current_peak, current_valley)\\n\\n        return total_candies\\n```\n```javascript []\\n/**\\n * @param {number[]} ratings\\n * @return {number}\\n */\\nvar candy = function(ratings) {\\n    const n = ratings.length;\\n    let totalCandies = n;\\n    let i = 1;\\n\\n    while (i < n) {\\n        if (ratings[i] === ratings[i - 1]) {\\n            i++;\\n            continue;\\n        }\\n\\n        let currentPeak = 0;\\n        while (i < n && ratings[i] > ratings[i - 1]) {\\n            currentPeak++;\\n            totalCandies += currentPeak;\\n            i++;\\n        }\\n\\n        if (i === n) {\\n            return totalCandies;\\n        }\\n\\n        let currentValley = 0;\\n        while (i < n && ratings[i] < ratings[i - 1]) {\\n            currentValley++;\\n            totalCandies += currentValley;\\n            i++;\\n        }\\n\\n        totalCandies -= Math.min(currentPeak, currentValley);\\n    }\\n\\n    return totalCandies;    \\n};\\n```\n```java []\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int totalCandies = n;\\n        int i = 1;\\n\\n        while (i < n) {\\n            if (ratings[i] == ratings[i - 1]) {\\n                i++;\\n                continue;\\n            }\\n\\n            int currentPeak = 0;\\n            while (i < n && ratings[i] > ratings[i - 1]) {\\n                currentPeak++;\\n                totalCandies += currentPeak;\\n                i++;\\n            }\\n\\n            if (i == n) {\\n                return totalCandies;\\n            }\\n\\n            int currentValley = 0;\\n            while (i < n && ratings[i] < ratings[i - 1]) {\\n                currentValley++;\\n                totalCandies += currentValley;\\n                i++;\\n            }\\n\\n            totalCandies -= Math.min(currentPeak, currentValley);\\n        }\\n\\n        return totalCandies;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n       int n = ratings.size();\\n        int totalCandies = n;\\n        int i = 1;\\n\\n        while (i < n) {\\n            if (ratings[i] == ratings[i - 1]) {\\n                i++;\\n                continue;\\n            }\\n\\n            int currentPeak = 0;\\n            while (i < n && ratings[i] > ratings[i - 1]) {\\n                currentPeak++;\\n                totalCandies += currentPeak;\\n                i++;\\n            }\\n\\n            if (i == n) {\\n                return totalCandies;\\n            }\\n\\n            int currentValley = 0;\\n            while (i < n && ratings[i] < ratings[i - 1]) {\\n                currentValley++;\\n                totalCandies += currentValley;\\n                i++;\\n            }\\n\\n            totalCandies -= min(currentPeak, currentValley);\\n        }\\n\\n        return totalCandies;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235599,
                "title": "candy-java-solution-simple-approach",
                "content": "**Approach: **\\n![image](https://assets.leetcode.com/users/images/8e625675-840e-438f-9733-90d8a5f60a05_1656919335.6807528.jpeg)\\n![image](https://assets.leetcode.com/users/images/ad4ee21e-ec47-434d-81d0-b534cf240158_1656919335.635522.jpeg)\\n\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n =  ratings.length;\\n        if(n==0)\\n            return 0;\\n        int left[] = new int[n];\\n        Arrays.fill(left,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(ratings[i] > ratings[i-1])\\n                left[i] = left[i-1]+1;\\n        }\\n        int right[] = new int[n];\\n        Arrays.fill(right,1);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(ratings[i] > ratings[i+1])\\n                right[i] = right[i+1]+1;\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n            ans += Math.max(left[i],right[i]);\\n        return ans;\\n    }\\n}\\n```\\n\\nTime Complexity : O(n)\\nSpace Complexity : O(n) coz we are taking two arrays here\\n\\n**Though this is the accepted solution here, this can be optimised more:\\nThe optimal solution is here:\\n[https://leetcode.com/problems/candy/discuss/2235735/Candy-or-Java-Solution-or-Optimized](http://)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n =  ratings.length;\\n        if(n==0)\\n            return 0;\\n        int left[] = new int[n];\\n        Arrays.fill(left,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(ratings[i] > ratings[i-1])\\n                left[i] = left[i-1]+1;\\n        }\\n        int right[] = new int[n];\\n        Arrays.fill(right,1);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(ratings[i] > ratings[i+1])\\n                right[i] = right[i+1]+1;\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n            ans += Math.max(left[i],right[i]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038277,
                "title": "beginner-friendly-line-by-line-explanation-easy-candy-solution-python-java-beats-95",
                "content": "# Beats \\n![image.png](https://assets.leetcode.com/users/images/b132f758-40f8-4e36-8898-57b76f9ae0d8_1694582712.425661.png)\\n\\n# JAVA CODE 1-2ms \\n# UPVOTE IF U LIKE !!!\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe main intuition behind this problem is to ensure that children with higher ratings receive more candies than their neighbors, while still giving each child at least one candy. One way to approach this is to scan the ratings array from left to right and then from right to left, adjusting the number of candies given based on the rating comparisons.\\n# Approach\\n1. Initialize variables:\\n\\n- 1. \"up_count\" to count increasing ratings sequences (starts at 1).\\n- 2. \"down_count\" to count decreasing ratings sequences (starts at 0).\\n- 3. \"candies_given\" to keep track of the total number of candies given (starts at 1).\\n- 4. \"peak\" to keep track of the peak of increasing ratings (starts at 0).\\n2. Iterate through the ratings list starting from the second element.\\n\\n- 1. If the current rating is greater than the previous one, it\\'s an increasing sequence:\\n- - - Increment up_count.\\n- - - Reset down_count to 0.\\n- - - Increment candies_given by up_count.\\n- - - Update peak to the value of up_count (as this is the peak of the current increasing sequence).\\n- 2. If the current rating is equal to the previous one, reset counts:\\n- - - Reset down_count and peak to 0.\\n- - - Reset up_count to 1.\\n- - - Increment candies_given by 1 (since they have the same rating, they should have the same number of candies).\\n- 3. If the current rating is less than the previous one, it\\'s a decreasing sequence:\\n- - - Increment down_count.\\n- - - Reset up_count to 1.\\n- - - Increment candies_given by down_count.\\n- - - If the current down_count is greater than or equal to peak, give an extra candy to the child at the peak of the decreasing sequence.\\n3. Return candies_given, which represents the minimum number of candies given to satisfy the conditions\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time Complexity: $$O(n)$$ - We iterate through the ratings array twice, once from left to right and once from right to left.\\n- Space Complexity: $$O(1)$$ - We use a constant amount of extra space for variables.\\n\\n\\n# Code\\n# Python\\n```\\n# Define a class named Solution.\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        up_count = 1  # Initialize a variable to count increasing ratings sequences.\\n        down_count = 0  # Initialize a variable to count decreasing ratings sequences.\\n        candies_given = 1  # Initialize the total count of candies given, starting with one.\\n        peak = 0  # Initialize a variable to keep track of the peak of increasing ratings.\\n\\n        # Iterate through the ratings list starting from the second element.\\n        for i in range(1, len(ratings)):\\n            if ratings[i] > ratings[i - 1]:\\n                # If the current rating is greater than the previous one, it\\'s an increasing sequence.\\n                up_count += 1\\n                down_count = 0\\n                candies_given += up_count  # Increment the candy count for the current child.\\n                peak = up_count  # Update the peak for the current increasing sequence.\\n            elif ratings[i] == ratings[i - 1]:\\n                # If the current rating is equal to the previous one, reset counts.\\n                down_count = 0\\n                peak = 0\\n                up_count = 1\\n                candies_given += 1  # Increment the candy count for the current child (since they have the same rating).\\n            else:\\n                # If the current rating is less than the previous one, it\\'s a decreasing sequence.\\n                down_count += 1\\n                up_count = 1\\n                candies_given += down_count  # Increment the candy count for the current child.\\n                if peak <= down_count:\\n                    candies_given += 1  # Give an extra candy to the child at the peak of the decreasing sequence.\\n\\n        return candies_given  # Return the total number of candies given to all children.\\n\\n          \\n```\\n# JAVA\\n```\\n// Define a class named Solution.\\nclass Solution {\\n    // Define a method named candy.\\n    public int candy(int[] ratings) {\\n        // Check if the ratings array is empty; if so, return 0 candies.\\n        if (ratings.length == 0)\\n            return 0;\\n        \\n        int n = ratings.length; // Get the number of children.\\n        int[] candies = new int[n]; // Create an array to store the number of candies for each child.\\n\\n        // Initialize each child with 1 candy (as a baseline).\\n        for (int i = 0; i < n; i++) {\\n            candies[i] = 1;\\n        }\\n\\n        // Pass through the ratings array from left to right and adjust candies as needed.\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = 1 + candies[i - 1];\\n            }\\n        }\\n\\n        // Pass through the ratings array from right to left to ensure the right neighbors also get appropriate candies.\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\\n                candies[i] = 1 + candies[i + 1];\\n            }\\n        }\\n\\n        int totalCandies = 0; // Initialize a variable to store the total number of candies given.\\n\\n        // Sum up the candies for all children to get the total count.\\n        for (int candyCount : candies) {\\n            totalCandies += candyCount;\\n        }\\n\\n        return totalCandies; // Return the total number of candies given to all children.\\n    }\\n}\\n\\n```\\n# C++\\n```\\n// Define a class named Solution.\\nclass Solution {\\npublic:\\n    // Define a method named candy.\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size(); // Get the number of children.\\n        vector<int> left(n, 1), right(n, 1); // Create vectors to store left and right candy counts for each child.\\n\\n        // Calculate the left candies.\\n        for (int i = 1; i < n; ++i) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n\\n        // Calculate the right candies.\\n        for (int i = n - 2; i >= 0; --i) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n\\n        int totalCandies = 0; // Initialize a variable to store the total number of candies given.\\n\\n        // Calculate the maximum candies for each child from the left and right counts and sum them up.\\n        for (int i = 0; i < n; ++i) {\\n            totalCandies += max(left[i], right[i]);\\n        }\\n\\n        return totalCandies; // Return the total number of candies given to all children.\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n# Define a class named Solution.\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        up_count = 1  # Initialize a variable to count increasing ratings sequences.\\n        down_count = 0  # Initialize a variable to count decreasing ratings sequences.\\n        candies_given = 1  # Initialize the total count of candies given, starting with one.\\n        peak = 0  # Initialize a variable to keep track of the peak of increasing ratings.\\n\\n        # Iterate through the ratings list starting from the second element.\\n        for i in range(1, len(ratings)):\\n            if ratings[i] > ratings[i - 1]:\\n                # If the current rating is greater than the previous one, it\\'s an increasing sequence.\\n                up_count += 1\\n                down_count = 0\\n                candies_given += up_count  # Increment the candy count for the current child.\\n                peak = up_count  # Update the peak for the current increasing sequence.\\n            elif ratings[i] == ratings[i - 1]:\\n                # If the current rating is equal to the previous one, reset counts.\\n                down_count = 0\\n                peak = 0\\n                up_count = 1\\n                candies_given += 1  # Increment the candy count for the current child (since they have the same rating).\\n            else:\\n                # If the current rating is less than the previous one, it\\'s a decreasing sequence.\\n                down_count += 1\\n                up_count = 1\\n                candies_given += down_count  # Increment the candy count for the current child.\\n                if peak <= down_count:\\n                    candies_given += 1  # Give an extra candy to the child at the peak of the decreasing sequence.\\n\\n        return candies_given  # Return the total number of candies given to all children.\\n\\n          \\n```\n```\\n// Define a class named Solution.\\nclass Solution {\\n    // Define a method named candy.\\n    public int candy(int[] ratings) {\\n        // Check if the ratings array is empty; if so, return 0 candies.\\n        if (ratings.length == 0)\\n            return 0;\\n        \\n        int n = ratings.length; // Get the number of children.\\n        int[] candies = new int[n]; // Create an array to store the number of candies for each child.\\n\\n        // Initialize each child with 1 candy (as a baseline).\\n        for (int i = 0; i < n; i++) {\\n            candies[i] = 1;\\n        }\\n\\n        // Pass through the ratings array from left to right and adjust candies as needed.\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = 1 + candies[i - 1];\\n            }\\n        }\\n\\n        // Pass through the ratings array from right to left to ensure the right neighbors also get appropriate candies.\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\\n                candies[i] = 1 + candies[i + 1];\\n            }\\n        }\\n\\n        int totalCandies = 0; // Initialize a variable to store the total number of candies given.\\n\\n        // Sum up the candies for all children to get the total count.\\n        for (int candyCount : candies) {\\n            totalCandies += candyCount;\\n        }\\n\\n        return totalCandies; // Return the total number of candies given to all children.\\n    }\\n}\\n\\n```\n```\\n// Define a class named Solution.\\nclass Solution {\\npublic:\\n    // Define a method named candy.\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size(); // Get the number of children.\\n        vector<int> left(n, 1), right(n, 1); // Create vectors to store left and right candy counts for each child.\\n\\n        // Calculate the left candies.\\n        for (int i = 1; i < n; ++i) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n\\n        // Calculate the right candies.\\n        for (int i = n - 2; i >= 0; --i) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n\\n        int totalCandies = 0; // Initialize a variable to store the total number of candies given.\\n\\n        // Calculate the maximum candies for each child from the left and right counts and sum them up.\\n        for (int i = 0; i < n; ++i) {\\n            totalCandies += max(left[i], right[i]);\\n        }\\n\\n        return totalCandies; // Return the total number of candies given to all children.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433313,
                "title": "python-simple-two-pass-forth-and-back",
                "content": "# Intuition\\nSome other solutions are too much complicated, which shouldn\\'t be. Just play some cases to get this idea. Please up vote if you agree with this idea and let me see if you like it.\\n\\nOkay, just saw other friends already got this idea. I did work it out alone since it\\'s pretty straightforward. Anyways, I hope my comments here help understanding.\\n\\n# Approach\\nGoing foward to reward higher rating on the right. Going backward for higher rating on left. Generally, there is only one rule:\\n- If you see a higher rating on the next child, it deserves one more candies if it didn\\'t\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ since only two passes on the rating array.\\n\\n- Space complexity:\\n$$O(n)$$ due to the $$give$$ list.\\n\\n# Code\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        give = [1] * n\\n\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i-1]:\\n                give[i] = give[i-1] + 1\\n\\n        for i in range(n-2, -1, -1):\\n            if ratings[i] > ratings[i+1] and give[i] <= give[i+1]:\\n                give[i] = give[i+1] + 1\\n\\n        return sum(give)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        give = [1] * n\\n\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i-1]:\\n                give[i] = give[i-1] + 1\\n\\n        for i in range(n-2, -1, -1):\\n            if ratings[i] > ratings[i+1] and give[i] <= give[i+1]:\\n                give[i] = give[i+1] + 1\\n\\n        return sum(give)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42889,
                "title": "simple-python-solution-with-two-passes",
                "content": "    class Solution:\\n        # @param {integer[]} ratings\\n        # @return {integer}\\n        def candy(self, ratings):\\n            # use two pass scan from left to right and vice versa to keep the candy level up to now\\n            # similar to like the Trapping Rain Water question\\n            res = [1]*len(ratings) # also compatable with [] input\\n            lbase = rbase = 1\\n            # left scan\\n            for i in xrange(1, len(ratings)):\\n                lbase = lbase + 1 if ratings[i] > ratings[i-1] else 1\\n                res[i] = lbase\\n            # right scan\\n            for i in xrange(len(ratings)-2, -1, -1):\\n                rbase = rbase + 1 if ratings[i] > ratings[i+1] else 1\\n                res[i] = max(rbase, res[i])\\n            return sum(res)",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 4037722,
                "title": "c-10ms-99-62-beginner-friendly-fast",
                "content": "# C++ | 10ms | 99.62% | Beginner Friendly | Fast\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int> &ratings)\\n {\\n\\t int size=ratings.size();\\n\\t if(size<=1)\\n\\t\\t return size;\\n\\t vector<int> num(size,1);\\n\\t for (int i = 1; i < size; i++)\\n\\t {\\n\\t\\t if(ratings[i]>ratings[i-1])\\n\\t\\t\\t num[i]=num[i-1]+1;\\n\\t }\\n\\t for (int i= size-1; i>0 ; i--)\\n\\t {\\n\\t\\t if(ratings[i-1]>ratings[i])\\n\\t\\t\\t num[i-1]=max(num[i]+1,num[i-1]);\\n\\t }\\n\\t int result=0;\\n\\t for (int i = 0; i < size; i++)\\n\\t {\\n\\t\\t result+=num[i];\\n\\t\\t// cout<<num[i]<<\" \";\\n\\t }\\n\\t return result;\\n }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int> &ratings)\\n {\\n\\t int size=ratings.size();\\n\\t if(size<=1)\\n\\t\\t return size;\\n\\t vector<int> num(size,1);\\n\\t for (int i = 1; i < size; i++)\\n\\t {\\n\\t\\t if(ratings[i]>ratings[i-1])\\n\\t\\t\\t num[i]=num[i-1]+1;\\n\\t }\\n\\t for (int i= size-1; i>0 ; i--)\\n\\t {\\n\\t\\t if(ratings[i-1]>ratings[i])\\n\\t\\t\\t num[i-1]=max(num[i]+1,num[i-1]);\\n\\t }\\n\\t int result=0;\\n\\t for (int i = 0; i < size; i++)\\n\\t {\\n\\t\\t result+=num[i];\\n\\t\\t// cout<<num[i]<<\" \";\\n\\t }\\n\\t return result;\\n }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4037727,
                "title": "python-99-82-beginner-friendly-optimal-solution",
                "content": "# Python | 99.82% | Beginner Friendly | Optimal Solution\\n```\\nclass Solution:\\n    def candy(self, R):\\n        n, ans = len(R), [1]*len(R)\\n        \\n        for i in range(n-1):\\n            if R[i] < R[i+1]:\\n                ans[i+1] = max(1 + ans[i], ans[i+1])\\n                \\n        for i in range(n-2, -1, -1):\\n            if R[i+1] < R[i]:\\n                ans[i] = max(1 + ans[i+1], ans[i])\\n        \\n        return sum(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, R):\\n        n, ans = len(R), [1]*len(R)\\n        \\n        for i in range(n-1):\\n            if R[i] < R[i+1]:\\n                ans[i+1] = max(1 + ans[i], ans[i+1])\\n                \\n        for i in range(n-2, -1, -1):\\n            if R[i+1] < R[i]:\\n                ans[i] = max(1 + ans[i+1], ans[i])\\n        \\n        return sum(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234990,
                "title": "c-easy-greedy-o-n-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& rat) {\\n        int n = rat.size(), sum = 0;\\n        vector<int> res(n, 1);  // initialize the resultant array with all elements 1 since each child will get minimum 1 candy\\n        \\n        if (n == 1) \\n        {\\n            return 1;\\n        }\\n        \\n        // traverse the given ratings array and if the value of rat[i + 1] is greater than rat[i],\\n        // then update the value of ans[i + 1] as ans[i] + 1\\n        // this is to make sure higher rating one gets more than right neighbour\\n        for(int i=0; i<n-1; i++)\\n        {\\n            if (rat[i+1] > rat[i]) \\n            {\\n                res[i+1] = res[i] + 1;\\n            }\\n        }\\n        \\n        // traverse the given array from the back and if the value of rat[i] > rat[i + 1] and the value of res[i] <= res[i + 1],\\n        // then update the value of res[i] as res[i + 1] + 1\\n        // this is to make sure higher rating one gets more than left neighbour\\n        for (int i=n-2; i>=0; i--) \\n        {\\n            if (rat[i] > rat[i+1] && res[i] <= res[i+1]) \\n            {\\n                res[i] = res[i+1]+1;\\n            }\\n        \\n            sum += res[i]; // increment the sum by res[i]\\n        }\\n        \\n        sum += res[n-1]; // increment with last element as it was left earlier\\n        \\n        return sum; // return the resultant sum\\n    }\\n};\\n```\\n\\n**Time Complexity: O(N)\\nSpace Complexity: O(N)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& rat) {\\n        int n = rat.size(), sum = 0;\\n        vector<int> res(n, 1);  // initialize the resultant array with all elements 1 since each child will get minimum 1 candy\\n        \\n        if (n == 1) \\n        {\\n            return 1;\\n        }\\n        \\n        // traverse the given ratings array and if the value of rat[i + 1] is greater than rat[i],\\n        // then update the value of ans[i + 1] as ans[i] + 1\\n        // this is to make sure higher rating one gets more than right neighbour\\n        for(int i=0; i<n-1; i++)\\n        {\\n            if (rat[i+1] > rat[i]) \\n            {\\n                res[i+1] = res[i] + 1;\\n            }\\n        }\\n        \\n        // traverse the given array from the back and if the value of rat[i] > rat[i + 1] and the value of res[i] <= res[i + 1],\\n        // then update the value of res[i] as res[i + 1] + 1\\n        // this is to make sure higher rating one gets more than left neighbour\\n        for (int i=n-2; i>=0; i--) \\n        {\\n            if (rat[i] > rat[i+1] && res[i] <= res[i+1]) \\n            {\\n                res[i] = res[i+1]+1;\\n            }\\n        \\n            sum += res[i]; // increment the sum by res[i]\\n        }\\n        \\n        sum += res[n-1]; // increment with last element as it was left earlier\\n        \\n        return sum; // return the resultant sum\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300170,
                "title": "c-python-java-simple-solution-with-explanation-and-sample-tc-o-n",
                "content": "*------Please **upvote!** if you like the solution and explanation.  Please put your questions/doubts in the comments section below.  I will try my best to answer them.------*\\n\\n**EXPLANATION:**\\n\\nCreate a result array (**`candies`**) to store the candies for each person.  First go from left to right and increment candies by 1 of people whose rating is more than the left neighbor.\\n\\nThen, go from right to left and if **`ratings [i] > ratings [i+1]`** update **`candies [i]`** to max of **`candies [i], candies [i+1] + 1`**\\n\\nFinally return sum of candies [].\\n\\nTake sample example:\\n`candies [] = [1, 1, 1, 1, 1, 1, 1]` : Initialize candies with 1 candy each \\n`ratings [] = [1, 6, 10, 8, 7, 3, 2]`\\n\\n**After 1st iteration:** update candies while going left to right: **`if ratings [i] > ratings [i-1] ---> candies [i] = candies [i-1] + 1`**\\n\\n`ratings [] = [1, 6, 10, 8, 7, 3, 2]`\\n`candies [] = [1, 2, 3, 1, 1, 1, 1]`\\n\\n**After 2nd iteration:** update candies while going right to left:**`if ratings [i] > ratings [i+1] ---> candies [i] = max (candies [i+1] + 1, candies [i])`**\\n\\n`ratings [] = [1, 6, 10, 8, 7, 3, 2]`\\n`candies [] = [1, 2, 5, 4, 3, 2, 1]`\\n\\n**Sum = 18** ---> Answer\\n\\n**C++ Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector <int> candies (n, 1);\\n        for (int i = 1; i < n; i++) {\\n            if (ratings [i] > ratings [i-1])\\n                candies [i] = candies [i-1] + 1;\\n        }\\n        int sum = candies [n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            if (ratings [i] > ratings [i+1])\\n                candies [i] = max (candies [i], candies [i+1] + 1);\\n            sum += candies [i];\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n**Python Code:**\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len (ratings)\\n        candies = [1] * n\\n        for i in range (1, n):\\n            if ratings [i] > ratings [i-1]:\\n                candies [i] = candies [i-1] + 1\\n        for i in range (n-2, -1, -1):\\n            if ratings [i] > ratings [i+1]:\\n                candies [i] = max (candies [i], candies [i+1] + 1)\\n        return sum (candies)\\n```\\n\\n**Java Code:**\\n\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int candies [] = new int [n];\\n        Arrays.fill (candies, 1);\\n        for (int i = 1; i < n; i++) {\\n            if (ratings [i] > ratings [i-1])\\n                candies [i] = candies [i-1] + 1;\\n        }\\n        int sum = candies [n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            if (ratings [i] > ratings [i+1])\\n                candies [i] = Math.max (candies [i], candies [i+1] + 1);\\n            sum += candies [i];\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\nPlease **upvote!** if you like the solution and explanation.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector <int> candies (n, 1);\\n        for (int i = 1; i < n; i++) {\\n            if (ratings [i] > ratings [i-1])\\n                candies [i] = candies [i-1] + 1;\\n        }\\n        int sum = candies [n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            if (ratings [i] > ratings [i+1])\\n                candies [i] = max (candies [i], candies [i+1] + 1);\\n            sum += candies [i];\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len (ratings)\\n        candies = [1] * n\\n        for i in range (1, n):\\n            if ratings [i] > ratings [i-1]:\\n                candies [i] = candies [i-1] + 1\\n        for i in range (n-2, -1, -1):\\n            if ratings [i] > ratings [i+1]:\\n                candies [i] = max (candies [i], candies [i+1] + 1)\\n        return sum (candies)\\n```\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int candies [] = new int [n];\\n        Arrays.fill (candies, 1);\\n        for (int i = 1; i < n; i++) {\\n            if (ratings [i] > ratings [i-1])\\n                candies [i] = candies [i-1] + 1;\\n        }\\n        int sum = candies [n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            if (ratings [i] > ratings [i+1])\\n                candies [i] = Math.max (candies [i], candies [i+1] + 1);\\n            sum += candies [i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161652,
                "title": "one-pass-o-n-with-o-1-space-shortest-solution-easy-to-understand",
                "content": "* We use ```inc``` to record the length of the **current (or the last)** increasing sequence\\n* We use ```dec``` to record the length of the current decresing sequence\\n### Scan the ```ratings```, there are 3 cases:\\n1. Sequence is increasing:\\n\\t* If the sequence was previously decresing, reset ```inc``` to ```1```\\n\\t* Bump up ```inc``` and increase our final answer ```ans``` by ```inc``` (*give the last child ```inc``` candies*)\\n\\t* Since the sequence is currently increasing, reset ```dec``` to ```1```\\n2. Sequence is decreasing:\\n\\t* Bump up ```dec``` and increase ```ans``` by ```dec - 1```. *Meaining we give ```1``` candy to the last child, and bump up the candies for everyone before him, expect the first child in the decreasing sequence.*\\n\\t* Bump up ```ans``` if ```dec > inc```: *because the length of the current decreasing sequence exceeds the last increasing sequence, which implies we need to bump up the candies for the first child in the decreasing sequence. Consider the sample ```[1, 5, 3, 2, 1]```: initially we gave the second child only 2 candies, but when we reach ```ratings[3]=2```, 2 is not enough for him*\\n3. Otherwise (```ratings[i] == ratings[i - 1]```): simply increment ```ans``` (*1 candy for the child is enough*) and reset ```inc``` and ```dec``` to 1.\\n\\n```\\n    public int candy(int[] ratings) {\\n        int ans = 1, inc = 1, dec = 1;\\n        for (int i = 1; i < ratings.length; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                if (i > 1 && ratings[i - 1] < ratings[i - 2]) inc = 1;\\n                ans += ++inc;\\n                dec = 1;\\n            }\\n            else if (ratings[i] < ratings[i - 1]) {\\n                dec++;\\n                ans += dec - 1;\\n                if (dec > inc) ans++;\\n            }\\n            else {\\n                ans++;\\n                inc = 1;\\n                dec = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```inc```\n```dec```\n```ratings```\n```inc```\n```1```\n```inc```\n```ans```\n```inc```\n```inc```\n```dec```\n```1```\n```dec```\n```ans```\n```dec - 1```\n```1```\n```ans```\n```dec > inc```\n```[1, 5, 3, 2, 1]```\n```ratings[3]=2```\n```ratings[i] == ratings[i - 1]```\n```ans```\n```inc```\n```dec```\n```\\n    public int candy(int[] ratings) {\\n        int ans = 1, inc = 1, dec = 1;\\n        for (int i = 1; i < ratings.length; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                if (i > 1 && ratings[i - 1] < ratings[i - 2]) inc = 1;\\n                ans += ++inc;\\n                dec = 1;\\n            }\\n            else if (ratings[i] < ratings[i - 1]) {\\n                dec++;\\n                ans += dec - 1;\\n                if (dec > inc) ans++;\\n            }\\n            else {\\n                ans++;\\n                inc = 1;\\n                dec = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2234828,
                "title": "python-two-pass-explanation-intuition-greedy",
                "content": "**Upvote if u like**\\n1. Traverse once right to left and later left to right\\n2. temp contains candy counts , with initially all having one candy\\n3. In right to left traversal, if ratings[i]>ratings[i-1] , give one candy to i th child.\\n4. We traverse backward for testcases like [1,3,2,2,1] here before backward traversal temp is [1,2,1,1,1] , but real ans should be [1,2,1,2,1]. So for this we traverse backward.\\n\\n\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n=len(ratings)\\n        temp = [1]*n\\n        \\n        for i in range(1,n):\\n            if(ratings[i]>ratings[i-1]):\\n                temp[i]=temp[i-1]+1\\n        if(n>1):\\n            if(ratings[0]>ratings[1]):\\n                temp[0]=2\\n                \\n            \\n        for i in range(n-2,-1,-1):\\n            if(ratings[i]>ratings[i+1] and temp[i]<=temp[i+1]):\\n                temp[i]=temp[i+1]+1\\n\\n                \\n        return sum(temp)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n=len(ratings)\\n        temp = [1]*n\\n        \\n        for i in range(1,n):\\n            if(ratings[i]>ratings[i-1]):\\n                temp[i]=temp[i-1]+1\\n        if(n>1):\\n            if(ratings[0]>ratings[1]):\\n                temp[0]=2\\n                \\n            \\n        for i in range(n-2,-1,-1):\\n            if(ratings[i]>ratings[i+1] and temp[i]<=temp[i+1]):\\n                temp[i]=temp[i+1]+1\\n\\n                \\n        return sum(temp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912299,
                "title": "python3-100-time-efficient-soln-o-n-time-o-1-space",
                "content": "class Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        \\n        \\n        up = 1\\n        down = 0\\n        rat = 1\\n        peak = 0\\n        \\n        for i in range(1,len(ratings)):\\n            \\n            if ratings[i]>ratings[i-1]:\\n                up+=1\\n                down =  0\\n                rat+=up\\n                peak = up\\n                \\n            elif ratings[i]==ratings[i-1]:\\n                down = 0\\n                peak = 0\\n                up = 1\\n                rat+=1\\n                \\n            else:\\n                down+=1\\n                up = 1\\n                rat+=down\\n                if peak<=down:\\n                    rat+=1\\n                    \\n        return rat",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "class Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        \\n        \\n        up = 1\\n        down = 0\\n        rat = 1\\n        peak = 0\\n        \\n        for i in range(1,len(ratings)):\\n            \\n            if ratings[i]>ratings[i-1]:\\n                up+=1\\n                down =  0\\n                rat+=up\\n                peak = up\\n                \\n            elif ratings[i]==ratings[i-1]:\\n                down = 0\\n                peak = 0\\n                up = 1\\n                rat+=1\\n                \\n            else:\\n                down+=1\\n                up = 1\\n                rat+=down\\n                if peak<=down:\\n                    rat+=1\\n                    \\n        return rat",
                "codeTag": "Java"
            },
            {
                "id": 42849,
                "title": "the-simplest-and-well-explained-solution-accepted-as-best-submission-in-c",
                "content": "When we first encounter such problem, the *least* is the keyword here. There are two constraints: \\n\\n - each child will have candy which means at least one candy;\\n - children with higher ratings will have more candies, which means their amount of candies is larger than neighboring children - to the left and to the right;\\n\\nSince the problem is resolved into these two constraints, then it can be easy to be handled now. The basic idea is as follows: \\n\\n -  traverse from the left to the right to determine the minimal amount of candies for each child that is constrained by the left; \\n - traverse from the right to the left and  determine the minimal amount of candies for each child that is constrained by the right;\\n - finally we can get the minimal constrained by both the left and the right neighbors for each child by retrieving the them from the results of the above two. \\n\\nOkay, by now you might be wonder how to determine the minimal constrained by the left or the right; actually it's quite intuitive that suppose we are traversing from the left to the right and set the leftmost child to 1 candy and then \\n\\n - if the next child ratings is higher ratings[i+1]>ratings[i] then **limits[i+1]=limits[i]+1**; \\n - if the next child ratings is equal to the current one ratings[i+1]==ratings[i] then **limits[i+1]=limits[i]**;\\n - if the next child ratings is smaller (ratings[i+1] < ratings[i]) then the child is not constrained by the left now and can be any but we need to reach global minimal so **limits[i]=1**;\\n\\nEach child will be either constrained by the left or the right or both, but since it's constrained by *the higher ratings more candies rule* the minimal can only be achieved by following it; then it's the valid least amount of candies we can reach.\\n\\nMerging the two results into final limits traversing from the left to the right: \\n\\n - if the ratings[i+1] > ratings[i] then obviously limits[i+1] will be determined by the max(limits[i]+1, limits[i]) - the second parameter limits[i] here is the previous traversal (from right to left) result limits[i] constrained by the right. We have to meet the constraints of both side, so we select the higher limit here;\\n - if the ratings[i+] <= ratings[i] then limits[i+1] should be less than limits[i]  determined by the left but limits[i+1] which is determined by the right in the previous traversal (from right to left) is already less then limits[i]; so limits[i+1] in from-right-to-left is the valid minimal value we can get here; \\n\\nSince we have to store the limits for each child either from left to right or from right to left, so space cost will be O(n) but as an optimized option we can reuse it to reduce the space cost from 2*n to n. As for time cost, we are traversing, man! Obviously it will be O(n), to further reduce the time cost we can sum them up at the second traversal to reduce the time cost from 3 traversals to 2 traversals only.\\n\\n - Space cost O(n)\\n - Time cost O(n)\\n\\n\\n----------\\n\\n    #define MAX(a, b) ((a) > (b) ? (a) : (b))\\n    #define MIN(a, b) ((a) < (b) ? (a) : (b))\\n    //AC - 16ms;\\n    int candy(int* ratings, int size)\\n    {\\n        if(!size) return 0;\\n        int* limits = (int*)malloc(sizeof(int)*size);\\n        limits[size-1] = 1;\\n        for(int i = size-2; i >-1; i--) //from right to left;\\n            if(ratings[i] > ratings[i+1]) limits[i] = limits[i+1]+1;\\n            else limits[i] = 1;\\n        int sum = limits[0];\\n        for(int i = 1; i < size; i++) //from left to right and collect the results;\\n        {\\n            if(ratings[i] > ratings[i-1]) limits[i] = MAX(limits[i], limits[i-1]+1);\\n            else limits[i] = MIN(limits[i-1]-1, limits[i]);\\n            sum += limits[i];\\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "When we first encounter such problem, the *least* is the keyword here. There are two constraints: \\n\\n - each child will have candy which means at least one candy;\\n - children with higher ratings will have more candies, which means their amount of candies is larger than neighboring children - to the left and to the right;\\n\\nSince the problem is resolved into these two constraints, then it can be easy to be handled now. The basic idea is as follows: \\n\\n -  traverse from the left to the right to determine the minimal amount of candies for each child that is constrained by the left; \\n - traverse from the right to the left and  determine the minimal amount of candies for each child that is constrained by the right;\\n - finally we can get the minimal constrained by both the left and the right neighbors for each child by retrieving the them from the results of the above two. \\n\\nOkay, by now you might be wonder how to determine the minimal constrained by the left or the right; actually it's quite intuitive that suppose we are traversing from the left to the right and set the leftmost child to 1 candy and then \\n\\n - if the next child ratings is higher ratings[i+1]>ratings[i] then **limits[i+1]=limits[i]+1**; \\n - if the next child ratings is equal to the current one ratings[i+1]==ratings[i] then **limits[i+1]=limits[i]**;\\n - if the next child ratings is smaller (ratings[i+1] < ratings[i]) then the child is not constrained by the left now and can be any but we need to reach global minimal so **limits[i]=1**;\\n\\nEach child will be either constrained by the left or the right or both, but since it's constrained by *the higher ratings more candies rule* the minimal can only be achieved by following it; then it's the valid least amount of candies we can reach.\\n\\nMerging the two results into final limits traversing from the left to the right: \\n\\n - if the ratings[i+1] > ratings[i] then obviously limits[i+1] will be determined by the max(limits[i]+1, limits[i]) - the second parameter limits[i] here is the previous traversal (from right to left) result limits[i] constrained by the right. We have to meet the constraints of both side, so we select the higher limit here;\\n - if the ratings[i+] <= ratings[i] then limits[i+1] should be less than limits[i]  determined by the left but limits[i+1] which is determined by the right in the previous traversal (from right to left) is already less then limits[i]; so limits[i+1] in from-right-to-left is the valid minimal value we can get here; \\n\\nSince we have to store the limits for each child either from left to right or from right to left, so space cost will be O(n) but as an optimized option we can reuse it to reduce the space cost from 2*n to n. As for time cost, we are traversing, man! Obviously it will be O(n), to further reduce the time cost we can sum them up at the second traversal to reduce the time cost from 3 traversals to 2 traversals only.\\n\\n - Space cost O(n)\\n - Time cost O(n)\\n\\n\\n----------\\n\\n    #define MAX(a, b) ((a) > (b) ? (a) : (b))\\n    #define MIN(a, b) ((a) < (b) ? (a) : (b))\\n    //AC - 16ms;\\n    int candy(int* ratings, int size)\\n    {\\n        if(!size) return 0;\\n        int* limits = (int*)malloc(sizeof(int)*size);\\n        limits[size-1] = 1;\\n        for(int i = size-2; i >-1; i--) //from right to left;\\n            if(ratings[i] > ratings[i+1]) limits[i] = limits[i+1]+1;\\n            else limits[i] = 1;\\n        int sum = limits[0];\\n        for(int i = 1; i < size; i++) //from left to right and collect the results;\\n        {\\n            if(ratings[i] > ratings[i-1]) limits[i] = MAX(limits[i], limits[i-1]+1);\\n            else limits[i] = MIN(limits[i-1]-1, limits[i]);\\n            sum += limits[i];\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2237688,
                "title": "c-o-n-time-o-1-space-intuitive-explanation",
                "content": "**Intuition**\\nWhen there\\'s a group of `n` ascending ratings, we can just assign `1,2,...,n` candies. For example, if `ratings=[3,6,7,10]`, then we can assign candies `[1,2,3,4]` to minimize the number of candies given. Similarly, for `n` descending ratings, we can assign `n,n-1,...,1` candies.\\n\\nThe only tricky case is when a rating is a \"peak\". In the case `ratings=[1,3,5,4]`, the `5` acts as a peak. Since there\\'s a group of `3` ascending candies before the peak (including the peak itself), we should assign the peak `3` candies, but there\\'s a group of `2` descending candies after the peak (including the peak itself). If this happens, we should assign the peak `max(3,2) = 3` candies to satisfy all conditions.\\n\\nIn the case there\\'s a group with all the same ratings, we can just assign them `1` candy, given that they aren\\'t part of a peak or valley.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int direction(int x, int y) {\\n        if (x == y) return 0;\\n        return (x > y ? -1 : 1);\\n    }\\n    \\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int i = 0, prev = 1;\\n        int ans = 1;\\n        while (i + 1 < n) {\\n            int run = 1, dir = direction(ratings[i], ratings[i + 1]);\\n            while (i + 1 < n && dir == direction(ratings[i], ratings[i + 1])) {\\n                run++;\\n                i++;\\n            }\\n            if (dir == 0) {\\n                ans += run;\\n                ans -= 1;\\n                prev = 1;\\n            } else {\\n                ans += run * (run + 1) / 2;\\n                if (dir == -1) {\\n                    ans -= min(prev, run);\\n                } else {\\n                    ans -= 1;\\n                }\\n                prev = run;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity:** O(n) - One pass through the array.\\n**Space Complexity:** O(1) - Only constant number of extra variables used.\\n\\n\\n**Upvote** if you like quick and simple explanations!\\n\\n**Join our discord** to meet other people prepping for interviews!\\n**https://discord.gg/7wpQQFYC**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int direction(int x, int y) {\\n        if (x == y) return 0;\\n        return (x > y ? -1 : 1);\\n    }\\n    \\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int i = 0, prev = 1;\\n        int ans = 1;\\n        while (i + 1 < n) {\\n            int run = 1, dir = direction(ratings[i], ratings[i + 1]);\\n            while (i + 1 < n && dir == direction(ratings[i], ratings[i + 1])) {\\n                run++;\\n                i++;\\n            }\\n            if (dir == 0) {\\n                ans += run;\\n                ans -= 1;\\n                prev = 1;\\n            } else {\\n                ans += run * (run + 1) / 2;\\n                if (dir == -1) {\\n                    ans -= min(prev, run);\\n                } else {\\n                    ans -= 1;\\n                }\\n                prev = run;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938475,
                "title": "100-fastest-swift-solution-0-n-o-n",
                "content": "```\\nclass Solution {\\n\\t// - Complexity:\\n    //   - time: 0(n) + O(n)\\n\\n    func candy(_ ratings: [Int]) -> Int {\\n\\t\\tvar indexs: [Int] = []\\n\\t\\tvar count = 0\\n        \\n        for i in 0..<ratings.count {\\n\\t\\t\\tlet left = i > 0 ? ratings[i - 1] : Int.max\\n\\t\\t\\tlet right = i < ratings.count - 1 ? ratings[i + 1] : Int.max\\n\\t\\t\\t\\n            if ratings[i] <= left && ratings[i] <= right {\\n\\t\\t\\t\\tindexs.append(i)\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        indexs.append(ratings.count)\\n\\t\\t\\n        var prev = -1\\n        for index in indexs {\\n\\t\\t\\tlet start = prev + 1\\n\\t\\t\\tlet end = index\\n\\t\\t\\t\\n            if end > start {\\n\\t\\t\\t\\tvar maxRating = Int.min\\n\\t\\t\\t\\tvar maxIndex = Int.min\\n\\t\\t\\t\\t\\n                for i in start..<end {\\n\\t\\t\\t\\t\\tif ratings[i] >= maxRating {\\n\\t\\t\\t\\t\\t\\tmaxRating = ratings[i]\\n\\t\\t\\t\\t\\t\\tmaxIndex = i\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n                var leftCount = maxIndex - start\\n\\t\\t\\t\\tvar rightCount = end - maxIndex - 1\\n\\t\\t\\t\\t\\n                if maxIndex - 1 >= start && ratings[maxIndex - 1] == maxRating {\\n\\t\\t\\t\\t\\trightCount += 1\\n\\t\\t\\t\\t\\n                } else {\\n\\t\\t\\t\\t\\tif leftCount > rightCount {\\n\\t\\t\\t\\t\\t\\tleftCount += 1\\n\\t\\t\\t\\t\\t\\n                    } else {\\n\\t\\t\\t\\t\\t\\trightCount += 1\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n                \\n\\t\\t\\t\\tcount += (2 + leftCount + 1) * leftCount / 2 + (2 + rightCount + 1) * rightCount / 2\\n\\t\\t\\t}\\n\\t\\t\\t\\n            prev = index\\n\\t\\t}\\n        \\n\\t\\treturn count\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\t// - Complexity:\\n    //   - time: 0(n) + O(n)\\n\\n    func candy(_ ratings: [Int]) -> Int {\\n\\t\\tvar indexs: [Int] = []\\n\\t\\tvar count = 0\\n        \\n        for i in 0..<ratings.count {\\n\\t\\t\\tlet left = i > 0 ? ratings[i - 1] : Int.max\\n\\t\\t\\tlet right = i < ratings.count - 1 ? ratings[i + 1] : Int.max\\n\\t\\t\\t\\n            if ratings[i] <= left && ratings[i] <= right {\\n\\t\\t\\t\\tindexs.append(i)\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        indexs.append(ratings.count)\\n\\t\\t\\n        var prev = -1\\n        for index in indexs {\\n\\t\\t\\tlet start = prev + 1\\n\\t\\t\\tlet end = index\\n\\t\\t\\t\\n            if end > start {\\n\\t\\t\\t\\tvar maxRating = Int.min\\n\\t\\t\\t\\tvar maxIndex = Int.min\\n\\t\\t\\t\\t\\n                for i in start..<end {\\n\\t\\t\\t\\t\\tif ratings[i] >= maxRating {\\n\\t\\t\\t\\t\\t\\tmaxRating = ratings[i]\\n\\t\\t\\t\\t\\t\\tmaxIndex = i\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n                var leftCount = maxIndex - start\\n\\t\\t\\t\\tvar rightCount = end - maxIndex - 1\\n\\t\\t\\t\\t\\n                if maxIndex - 1 >= start && ratings[maxIndex - 1] == maxRating {\\n\\t\\t\\t\\t\\trightCount += 1\\n\\t\\t\\t\\t\\n                } else {\\n\\t\\t\\t\\t\\tif leftCount > rightCount {\\n\\t\\t\\t\\t\\t\\tleftCount += 1\\n\\t\\t\\t\\t\\t\\n                    } else {\\n\\t\\t\\t\\t\\t\\trightCount += 1\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n                \\n\\t\\t\\t\\tcount += (2 + leftCount + 1) * leftCount / 2 + (2 + rightCount + 1) * rightCount / 2\\n\\t\\t\\t}\\n\\t\\t\\t\\n            prev = index\\n\\t\\t}\\n        \\n\\t\\treturn count\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679044,
                "title": "java-solution-simple-solution-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int[] arr = new int[ratings.length];\\n        Arrays.fill(arr, 1);\\n        int ans = ratings.length;\\n\\n        while(true){\\n            boolean bool = false;\\n            for(int i = 0; i < ratings.length-1; i++){\\n\\n                if(ratings[i] > ratings[i+1] && arr[i] <= arr[i+1]){\\n                    arr[i]++;\\n                    ans++;\\n                    bool = true;\\n                }\\n\\n                if(ratings[i] < ratings[i+1] && arr[i] >= arr[i+1]){\\n                    arr[i+1]++;\\n                    ans++;\\n                    bool = true;\\n                }\\n            }\\n\\n            if(!bool)\\n                break;\\n        }\\n\\n        return ans;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int[] arr = new int[ratings.length];\\n        Arrays.fill(arr, 1);\\n        int ans = ratings.length;\\n\\n        while(true){\\n            boolean bool = false;\\n            for(int i = 0; i < ratings.length-1; i++){\\n\\n                if(ratings[i] > ratings[i+1] && arr[i] <= arr[i+1]){\\n                    arr[i]++;\\n                    ans++;\\n                    bool = true;\\n                }\\n\\n                if(ratings[i] < ratings[i+1] && arr[i] >= arr[i+1]){\\n                    arr[i+1]++;\\n                    ans++;\\n                    bool = true;\\n                }\\n            }\\n\\n            if(!bool)\\n                break;\\n        }\\n\\n        return ans;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42831,
                "title": "simple-javascript-solution",
                "content": "    var candy = function(ratings) {\\n        var len = ratings.length;\\n        var forward = new Array(len);\\n        backward = new Array(len);\\n\\n        forward[0] = 1;\\n        backward[len-1] = 1;\\n        for (var i = 1; i < len; i++) {\\n            if (ratings[i] > ratings[i-1]) forward[i] = forward[i-1] + 1;\\n            else forward[i] = 1;\\n        }\\n\\n        for (var i = len - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i+1]) backward[i] = backward[i+1] + 1;\\n            else backward[i] = 1;\\n        }\\n        var sum = 0;\\n        for (var i = 0; i < len; i++) {\\n            sum += Math.max(forward[i], backward[i]);\\n        }\\n        return sum;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var candy = function(ratings) {\\n        var len = ratings.length;\\n        var forward = new Array(len);\\n        backward = new Array(len);\\n\\n        forward[0] = 1;\\n        backward[len-1] = 1;\\n        for (var i = 1; i < len; i++) {\\n            if (ratings[i] > ratings[i-1]) forward[i] = forward[i-1] + 1;\\n            else forward[i] = 1;\\n        }\\n\\n        for (var i = len - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i+1]) backward[i] = backward[i+1] + 1;\\n            else backward[i] = 1;\\n        }\\n        var sum = 0;\\n        for (var i = 0; i < len; i++) {\\n            sum += Math.max(forward[i], backward[i]);\\n        }\\n        return sum;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 42870,
                "title": "my-two-36ms-codes-one-pass-o-1-space-plus-another-easy-to-understand-code-c",
                "content": "    class Solution { // O(n) single pass\\n    public:\\n        int candy(vector<int>& ratings) {\\n            int ans = 0;\\n            int i = 1; int dip = 1;\\n            if(ratings.size() == 1) return 1;\\n            while(i < ratings.size())\\n            {  \\n                int len2 = 1;\\n                while( i < ratings.size() && ratings[i] == ratings[i-1]){\\n                    i++; ans += len2;\\n                }\\n                while(i < ratings.size() && ratings[i-1] < ratings[i]){\\n                    len2++; i++;\\n                } ans += len2*(len2+1)/2;\\n                while( i < ratings.size() && ratings[i] == ratings[i-1]){\\n                    i++; ans += 1;\\n                    len2 = 1;\\n                }\\n                len2--;\\n                int len = 0;\\n                while( i < ratings.size() && ratings[i-1] > ratings[i]){\\n                    len++;  i++;\\n                }\\n                if( i-1 != ratings.size()-1 ) { ans -= 1; }\\n                ans += len*(len+1)/2;\\n                if(len > len2) ans += len-len2;\\n            }\\n            return ans;\\n        }\\n    };\\n\\nEasy to understand 2 pass code:    \\nIdea: Forward pass is intuitively ok and gives min candies, the second reverse pass doesn't break any thing from the previous pass and completes the reverse direction requirements too.\\n\\n    class Solution {\\n    public:\\n        int candy(vector<int>& arr) {\\n            int cand[100001] = {0};\\n            int n = arr.size();\\n            for(int i = 1; i < n; i++) \\n                if(arr[i] > arr[i-1]) cand[i] = cand[i-1] + 1;\\n            for(int i = n-2; i>= 0; i--) \\n                if(arr[i] > arr[i+1]) cand[i] = max(cand[i], cand[i+1] + 1);\\n            int sum = n;\\n            for(int i = 0; i < n; i++) sum += cand[i];\\n            return sum;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution { // O(n) single pass\\n    public:\\n        int candy(vector<int>& ratings) {\\n            int ans = 0;\\n            int i = 1; int dip = 1;\\n            if(ratings.size() == 1) return 1;\\n            while(i < ratings.size())\\n            {  \\n                int len2 = 1;\\n                while( i < ratings.size() && ratings[i] == ratings[i-1]){\\n                    i++; ans += len2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2234710,
                "title": "cpp-java-code-2-approach-with-simple-explanation-o-n-time-o-1-space-optimized-sol",
                "content": "**Approach - 1 --> Time Complexity O(n) and Space Complexity O(n)**\\n\\n**Step-1** : Assign 1 candy to each children i.e in left and right array .\\n**Step-2** : Create a left array , that make sure to have a candy greater than left element only.\\n                  if(arr [ i  ] > arr [ i - 1  ]   )  then left [ i ] = left [ i - 1 ] + 1;\\n**Step-3** : Create a right array , that make sure to have a candy greater than right element only.\\n\\t\\t\\t\\t if( arr [ i ] > arr [ i + 1] ) then right [ i ] = right [ i +1 ] + 1;\\n**Step-4** : Calculate max of ( left[i] , right[i] )\\n\\nE.g :\\n3    8    4   5   7  9\\n1    1    1   1   1   1    --->  left array assigned with 1\\n1    2    1   2   3   4   ---->  step-2\\n1    1    1   1   1   1   ---> right array assigned with 1\\n1    2    1   1   1   1   ----> step-3\\ncalculate max of step 2 and step 3\\n1    2    1   2   3   4   ----------------------> ANSWER = 1 + 2+ 1+ 2+3 +4 = 13\\n\\n**Note : You can also do it in a two loop with single extra array. **\\n\\n\\n**Approach - 2 : We can apply the approach of valley and peak problem.**\\npeek will have maximum candy while valley have 1 candy.\\nInitialize candy_count = no. of childern ( bcz each children must have 1 candy )\\nStart the looping from 1 to arr.size() -1\\nstep -1 : if current value is equal to previous value then they have same number of Candy.\\nstep -2 : if we have increasing slope , we increase the peak value by one for each increasing element \\n``` while( arr [ i ] > arr [ i - 1 ] ) peak++;``` and add count_candy with peak value.\\nstep - 3 : if we have decreasing slope , we increase the value of valley by one for each decreasing element\\n```while ( arr [ i ] < arr [ i - 1 ] ) valley++``` and add count_candy with valley value.\\nstep -4 : count_candy = count_candy - min ( peak , valley )\\n\\n**J A V A     S O L U T I O N**\\n```\\nclass Solution {\\n    public int candy(int[] ratings) { \\n        int peak = 0 , valley = 0 , size = ratings.length,candy_count = size ;\\n        for(int i = 1 ; i< size ;){\\n            if(ratings[i] == ratings[i-1]){ i++ ; continue;}\\n            peak = 0 ;\\n            valley = 0;\\n            while( i< size && ratings[i] > ratings[i-1]){\\n                peak++;\\n                i++;\\n                candy_count += peak;\\n            }\\n               \\n            \\n            while(i<size && ratings[i] < ratings[i-1]){\\n                valley++;\\n                i++;\\n                candy_count += valley;\\n            }\\n               \\n            candy_count -= Math.min(peak,valley);\\n        }\\n        return candy_count;\\n    }\\n}\\n```\\n**C P P  S O L U T I O N**\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int peak = 0 , valley = 0 , size = ratings.size(),candy_count = size ;\\n        for(int i = 1 ; i< size ;){\\n            if(ratings[i] == ratings[i-1]){ i++ ; continue;}\\n            peak = 0 ;\\n            valley = 0;\\n            while( i< size && ratings[i] > ratings[i-1]){\\n                peak++;\\n                i++;\\n                candy_count += peak;\\n            }\\n               \\n            \\n            while(i<size && ratings[i] < ratings[i-1]){\\n                valley++;\\n                i++;\\n                candy_count += valley;\\n            }\\n               \\n            candy_count -= min(peak,valley);\\n        }\\n        return candy_count;\\n    }\\n};\\n```\\n\\n**Upvote if you found it helpful**\\n**",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "``` while( arr [ i ] > arr [ i - 1 ] ) peak++;```\n```while ( arr [ i ] < arr [ i - 1 ] ) valley++```\n```\\nclass Solution {\\n    public int candy(int[] ratings) { \\n        int peak = 0 , valley = 0 , size = ratings.length,candy_count = size ;\\n        for(int i = 1 ; i< size ;){\\n            if(ratings[i] == ratings[i-1]){ i++ ; continue;}\\n            peak = 0 ;\\n            valley = 0;\\n            while( i< size && ratings[i] > ratings[i-1]){\\n                peak++;\\n                i++;\\n                candy_count += peak;\\n            }\\n               \\n            \\n            while(i<size && ratings[i] < ratings[i-1]){\\n                valley++;\\n                i++;\\n                candy_count += valley;\\n            }\\n               \\n            candy_count -= Math.min(peak,valley);\\n        }\\n        return candy_count;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int peak = 0 , valley = 0 , size = ratings.size(),candy_count = size ;\\n        for(int i = 1 ; i< size ;){\\n            if(ratings[i] == ratings[i-1]){ i++ ; continue;}\\n            peak = 0 ;\\n            valley = 0;\\n            while( i< size && ratings[i] > ratings[i-1]){\\n                peak++;\\n                i++;\\n                candy_count += peak;\\n            }\\n               \\n            \\n            while(i<size && ratings[i] < ratings[i-1]){\\n                valley++;\\n                i++;\\n                candy_count += valley;\\n            }\\n               \\n            candy_count -= min(peak,valley);\\n        }\\n        return candy_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42890,
                "title": "does-anyone-have-a-better-idea",
                "content": "My code is accepted with **a run-time complexity of O(n)** and **a space complexity of nearly O(1), less than O(n)**.\\n\\nI deal with it for two times:\\n\\n1st, from left to right, I add all the rising points, including the right edges without the left edges.\\n\\n2nd, from right to left, I add all the rising points, which are falling points at the 1st time, including the right and left edges.\\n\\nThere are 4 points should be noticed:\\n\\n1) The right edges must be dealt with for two times, so I only add the difference values or 0. I use a stack to mark every tops' candies except for the last child.\\n\\n2) The left edges are not dealt with for the 1st time, but they are dealt with for the 2nd time.\\n\\n3) For the flat parts, the left edges are dealt with as rising points, while the right edges are dealt with by adding 1 for the 1st time. So for the 2nd time, I add the values they should have then minus 1 when meeting the right edges. The rest are dealt with by adding 1 for the 1st time and not dealt with for the 2nd time.\\n\\n4) As to the point 0, I deal with it if it's less than or equal to point 1 by adding 1. If it's larger than point 1, I don't deal with it until the 2nd time is finished.\\n\\nHere is the code:\\n\\n    class Solution {\\n    public:\\n    \\tint candy(vector<int> &ratings) {\\n    \\t\\t// IMPORTANT: Please reset any member data you declared, as\\n    \\t\\t// the same Solution instance will be reused for each test case.\\n    \\t\\tif( ratings.size()<2 )\\n    \\t\\t\\treturn ratings.size();\\n    \\t\\tint len=1, sum=0, flat=1, tmp;\\n    \\t\\tvector<int> tops;\\n    \\t\\tsum += ratings[0]>ratings[1] ? 0 : len ;\\n    \\t\\tfor(int i=1; i<ratings.size(); ++i)\\n    \\t\\t{\\n    \\t\\t\\tif( ratings[i]>ratings[i-1] )\\n    \\t\\t\\t\\tsum += ++len;\\n    \\t\\t\\telse if( ratings[i]==ratings[i-1] )\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tlen = 1;\\n    \\t\\t\\t\\tsum += 1;\\n    \\t\\t\\t}\\n    \\t\\t\\telse if( ratings[i]<ratings[i-1] && len!=1 )\\n    \\t\\t\\t{\\n    \\t\\t\\t\\ttops.push_back(len);\\n    \\t\\t\\t\\tlen=1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tlen=1;\\n    \\t\\tfor(int i=ratings.size()-1; i>0; --i)\\n    \\t\\t{\\n    \\t\\t\\tif( ratings[i]<ratings[i-1] )\\n    \\t\\t\\t\\tsum += len++;\\n    \\t\\t\\tif( ratings[i]==ratings[i-1] )\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tsum += len-1;\\n    \\t\\t\\t\\tlen = 1;\\n    \\t\\t\\t}\\n    \\t\\t\\telse if( ratings[i]>ratings[i-1] && len!=1 )\\n    \\t\\t\\t{\\n    \\t\\t\\t\\ttmp = tops.back();\\n    \\t\\t\\t\\ttops.pop_back();\\n    \\t\\t\\t\\tsum += len>tmp?(len-tmp):0;\\n    \\t\\t\\t\\tlen = 1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tsum += ratings[0]>ratings[1] ? len : 0 ;\\n    \\t\\treturn sum;\\n    \\t}\\n    };\\n\\nDoes anyone have a better idea? My code has a complicated judgement and seems not elegant enough.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tint candy(vector<int> &ratings) {\\n    \\t\\t// IMPORTANT: Please reset any member data you declared, as\\n    \\t\\t// the same Solution instance will be reused for each test case.\\n    \\t\\tif( ratings.size()<2 )\\n    \\t\\t\\treturn ratings.size();\\n    \\t\\tint len=1, sum=0, flat=1, tmp;\\n    \\t\\tvector<int> tops;\\n    \\t\\tsum += ratings[0]>ratings[1] ? 0 : len ;\\n    \\t\\tfor(int i=1; i<ratings.size(); ++i)\\n    \\t\\t{\\n    \\t\\t\\tif( ratings[i]>ratings[i-1] )\\n    \\t\\t\\t\\tsum += ++len;\\n    \\t\\t\\telse if( ratings[i]==ratings[i-1] )\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tlen = 1;\\n    \\t\\t\\t\\tsum += 1;\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3994447,
                "title": "fully-explained-c-solution-clean-code-beats-95-of-solutions-easy-to-understand",
                "content": "# Intuition\\nTo maintain the given rule, the solution uses a two-pass approach:\\n\\n- **First Pass (Forward Traversal):**\\n\\nIn the first pass, the code iterates through the ratings from left to right. For each child, it checks if the child to the right has a higher rating. If so, it gives the current child one more candy than the child to the left. This step ensures that children with higher ratings receive more candies than their lower-rated neighbours.\\n\\n- **Second Pass (Backward Traversal):**\\n\\nIn the second pass, the code iterates through the ratings from right to left. For each child, it checks if the child to the left has a higher rating and ***hasn\\'t received more candies already*** (this is to prevent over-candying). If both conditions are met, it gives the left child more candy than the rigth child.\\n\\nBy performing these two passes, the solution guarantees that both conditions are met while minimizing the total number of candies distributed. The key insight is that you can start with an initial distribution of one candy per child and adjust it as needed based on the ratings and neighboring children. This approach ensures fairness and satisfies the problem constraints efficiently.\\n\\nIn summary, the intuition of this solution is to iteratively adjust the number of candies given to each child based on their ratings and the ratings of their neighbors, ensuring that the conditions of the problem are met while minimizing the total number of candies distributed. It\\'s a greedy approach that works by making local decisions to achieve a globally optimal solution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere\\'s how the code works:\\n\\nIt first initializes a vector called \\'candy\\' with the same length as the input \\'ratings\\' vector, with each element set to \"1\". Each child is initially given one candy.\\n\\nIn the first pass (forward traversal), it checks for increasing ratings. If the rating of the next child is higher than the current child, it gives the next child one more candy than the current child. This ensures that children with higher ratings receive more candies.\\n\\nIn the second pass (backward traversal), it checks for decreasing ratings. **If the rating of the previous child is higher, and the previous child hasn\\'t received more candies already**, it gives the previous child one more candy to satisfy the rule.\\n\\nFinally, it calculates the total number of candies distributed by summing up the elements in the candy vector and returns that value as the minimum total number of candies needed to satisfy the constraints.\\n\\nThis code guarantees that the constraints are met while minimizing the total number of candies distributed.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n10ms RUNTIME - Beats 95% solutions\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size() ;\\n        vector<int> candy(n, 1) ;\\n        \\n        //First Pass:Forward traversal to handle increasing ratings\\n        for(int i = 0; i<n-1; i++) {\\n            if(ratings[i+1] > ratings[i])\\n                candy[i+1] = candy[i] + 1 ; //If the next child has a higher rating, give them one more candy than previous child\\n        }\\n        \\n        //Second Pass:Backward traversal to handle decreasing ratings\\n        for(int i = n-1; i>0; i--) {\\n            if(ratings[i-1] > ratings[i] && candy[i-1] <= candy[i])\\n                candy[i-1] = candy[i] + 1 ; \\n                //If the previous child has a higher rating and hasn\\'t received more candy, give them more candy than current child\\n        }\\n\\n        int totalCandy = 0 ;\\n        for(int i = 0; i<n; i++)\\n            totalCandy = totalCandy + candy[i] ;\\n        \\n        return totalCandy ;\\n    }\\n};\\n```\\n# IF YOU UNDERSTOOD AND LIKED THE CODE, PLEASE UPVOTE",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size() ;\\n        vector<int> candy(n, 1) ;\\n        \\n        //First Pass:Forward traversal to handle increasing ratings\\n        for(int i = 0; i<n-1; i++) {\\n            if(ratings[i+1] > ratings[i])\\n                candy[i+1] = candy[i] + 1 ; //If the next child has a higher rating, give them one more candy than previous child\\n        }\\n        \\n        //Second Pass:Backward traversal to handle decreasing ratings\\n        for(int i = n-1; i>0; i--) {\\n            if(ratings[i-1] > ratings[i] && candy[i-1] <= candy[i])\\n                candy[i-1] = candy[i] + 1 ; \\n                //If the previous child has a higher rating and hasn\\'t received more candy, give them more candy than current child\\n        }\\n\\n        int totalCandy = 0 ;\\n        for(int i = 0; i<n; i++)\\n            totalCandy = totalCandy + candy[i] ;\\n        \\n        return totalCandy ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205689,
                "title": "135-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem can be solved using two passes of linear scans over the given ratings list. First, we can allocate 1 candy to each child. Then, we can do a forward scan and check if the current child\\'s rating is greater than the previous child\\'s rating. If it is, we can give one more candy to the current child than the previous child. Similarly, we can do a backward scan and check if the current child\\'s rating is greater than the next child\\'s rating. If it is, we can give one more candy to the current child than the next child. Finally, we can return the sum of the candies allocated to all the children.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def candy(self, ratings: List[int]) -> int:\\n    n = len(ratings)\\n    candies = [1] * n  # Allocate 1 candy to each child\\n    for i in range(1, n):\\n        if ratings[i] > ratings[i - 1]:\\n            candies[i] = candies[i - 1] + 1  # Give one more candy to current child than previous child\\n    for i in range(n - 2, -1, -1):\\n        if ratings[i] > ratings[i + 1]:\\n            candies[i] = max(candies[i], candies[i + 1] + 1)  # Give one more candy to current child than next child\\n    return sum(candies)  # Return the total number of candies allocated\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n  def candy(self, ratings: List[int]) -> int:\\n    n = len(ratings)\\n    candies = [1] * n  # Allocate 1 candy to each child\\n    for i in range(1, n):\\n        if ratings[i] > ratings[i - 1]:\\n            candies[i] = candies[i - 1] + 1  # Give one more candy to current child than previous child\\n    for i in range(n - 2, -1, -1):\\n        if ratings[i] > ratings[i + 1]:\\n            candies[i] = max(candies[i], candies[i + 1] + 1)  # Give one more candy to current child than next child\\n    return sum(candies)  # Return the total number of candies allocated\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235501,
                "title": "easy-python-solution-candy",
                "content": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        length = len(ratings)\\n        candies = [1] * length\\n        for i in range(1, length):\\n            if ratings[i] > ratings[i-1] and candies[i] <= candies[i-1]:\\n                candies[i] = candies[i-1] + 1\\n        for i in range(length - 2, -1, -1):\\n            if ratings[i] > ratings[i + 1] and candies[i] <= candies[i+1]:\\n                candies[i] = candies[i+1] + 1\\n        return sum(candies)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        length = len(ratings)\\n        candies = [1] * length\\n        for i in range(1, length):\\n            if ratings[i] > ratings[i-1] and candies[i] <= candies[i-1]:\\n                candies[i] = candies[i-1] + 1\\n        for i in range(length - 2, -1, -1):\\n            if ratings[i] > ratings[i + 1] and candies[i] <= candies[i+1]:\\n                candies[i] = candies[i+1] + 1\\n        return sum(candies)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235318,
                "title": "c-topological-sort-graph",
                "content": "Did not see any graph based approach in the discuss section, so adding it here ^^\\nNot the fastest approach but is intuitive.\\nVisualize array of ratings as graph. Edge(u --> v) is made when u < v.\\nThen assign candies in topology sort order starting from 1 and increment after every level of bfs.\\n```\\nint candy(vector<int> &a)\\n{\\n    int n = a.size();\\n    vector<int> adj[n];\\n    vector<int> inDegree(n, 0);\\n    for (int i = 0; i < n - 1; i++)\\n    {\\n        int u = a[i], v = a[i + 1];\\n        if (v > u)\\n            adj[i].push_back(i + 1), inDegree[i + 1]++;\\n        else if (u > v)\\n            adj[i + 1].push_back(i), inDegree[i]++;\\n    }\\n    queue<int> q;\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (inDegree[i] == 0)\\n            q.push(i);\\n    }\\n    int ans = 0, curr = 1;\\n    while (!q.empty())\\n    {\\n        int size = q.size();\\n        while (size--)\\n        {\\n            int node = q.front();\\n            q.pop();\\n            ans += curr;\\n            for (auto &x : adj[node])\\n            {\\n                inDegree[x]--;\\n                if (inDegree[x] == 0)\\n                    q.push(x);\\n            }\\n        }\\n        curr++;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nint candy(vector<int> &a)\\n{\\n    int n = a.size();\\n    vector<int> adj[n];\\n    vector<int> inDegree(n, 0);\\n    for (int i = 0; i < n - 1; i++)\\n    {\\n        int u = a[i], v = a[i + 1];\\n        if (v > u)\\n            adj[i].push_back(i + 1), inDegree[i + 1]++;\\n        else if (u > v)\\n            adj[i + 1].push_back(i), inDegree[i]++;\\n    }\\n    queue<int> q;\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (inDegree[i] == 0)\\n            q.push(i);\\n    }\\n    int ans = 0, curr = 1;\\n    while (!q.empty())\\n    {\\n        int size = q.size();\\n        while (size--)\\n        {\\n            int node = q.front();\\n            q.pop();\\n            ans += curr;\\n            for (auto &x : adj[node])\\n            {\\n                inDegree[x]--;\\n                if (inDegree[x] == 0)\\n                    q.push(x);\\n            }\\n        }\\n        curr++;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2234889,
                "title": "c-o-n-easy-solution-using-single-array",
                "content": "\\t// we can not check neighbour directly for any index because if we change that index i according \\n\\t// to the neighbour i+1 then may be error because index i+1 will further depend on index i+2\\n\\t// so two times traversal will be required \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint candy(vector<int>& ratings) {\\n\\t\\t\\tint n=ratings.size();\\n\\t\\t\\t  vector<int>ans(n,1);\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1])\\n\\t\\t\\t\\t\\tans[i]=ans[i-1]+1;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=n-2;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1])\\n\\t\\t\\t\\t\\tans[i]=ans[i+1]+1;\\n\\t\\t\\t}\\n\\t\\t\\treturn accumulate(ans.begin(),ans.end(),0);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint candy(vector<int>& ratings) {\\n\\t\\t\\tint n=ratings.size();\\n\\t\\t\\t  vector<int>ans(n,1);\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1])\\n\\t\\t\\t\\t\\tans[i]=ans[i-1]+1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 868478,
                "title": "a-solution-you-can-easily-figure-out-during-an-interview-topological-sort-solution",
                "content": "The actual rating of each child doesn\\'t really matter. \\nThe only thing matters is the relationship(larger/smaller) between two adjacent children, so we could convert it to a graph problem.\\nWe can do **topological sort** to this graph and give one more candy for each level of the graph.\\n\\nOne thing to note that we don\\'t need to build this graph actually. Instead simply use an array to track indegree. \\nThis could make the code concise and easier to implement during an interview.\\n\\n\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] ind = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            if(i!=0 && ratings[i-1] > ratings[i]) ind[i-1]++;\\n            if(i!=n-1 && ratings[i+1] > ratings[i]) ind[i+1]++;\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i = 0; i < n; i++)\\n            if(ind[i] == 0) q.offer(i);\\n        \\n        int ans = 0;\\n        int level = 1;\\n        while(!q.isEmpty()) {\\n            for(int k = q.size(); k > 0; k--) {\\n                int idx = q.poll();\\n                ans+=level;\\n                if(idx!=0 && ratings[idx-1] > ratings[idx] && --ind[idx-1] == 0) q.offer(idx-1);\\n                if(idx!=n-1 && ratings[idx+1] > ratings[idx] && --ind[idx+1] == 0) q.offer(idx+1);\\n            }\\n            level++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] ind = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            if(i!=0 && ratings[i-1] > ratings[i]) ind[i-1]++;\\n            if(i!=n-1 && ratings[i+1] > ratings[i]) ind[i+1]++;\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i = 0; i < n; i++)\\n            if(ind[i] == 0) q.offer(i);\\n        \\n        int ans = 0;\\n        int level = 1;\\n        while(!q.isEmpty()) {\\n            for(int k = q.size(); k > 0; k--) {\\n                int idx = q.poll();\\n                ans+=level;\\n                if(idx!=0 && ratings[idx-1] > ratings[idx] && --ind[idx-1] == 0) q.offer(idx-1);\\n                if(idx!=n-1 && ratings[idx+1] > ratings[idx] && --ind[idx+1] == 0) q.offer(idx+1);\\n            }\\n            level++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327158,
                "title": "intuitive-o-n-time-and-o-1-explained-like-a-5th-grader",
                "content": "When I read this question the thing that came into my mind was that which person will get 1 candy. So I imagined ratings as heights of towers and then realized that locally minimum tower will get 1 candy.\\n\\n- Consider ratings as heights of towers as shown in the figure below.\\n- First of all we build infinite size towers to left and right of the array.\\n- We define pits as the points, which have tower size as local minimum,\\n  i.e. height of tower just to the left >= height_pit <= height of tower just to the right\\n- In the below figure P1,P2...P5 are pits\\n\\n```\\nRatings:\\n\\nInf                                      Inf\\n|                   Peak                  |\\n|       Peak          |                   |\\n|         |           | |                 |\\n|       | |           | | |               |\\n|     | | | |       | | | | |     | | |   |\\n|   | | | | | |   | | | | | | |   | | |   |\\n| _ | | | | | | | | | | | | | | _ | | | | |\\n-------------------------------------------\\n* 0 2 3 4 5 3 2 1 2 3 6 5 4 3 2 0 3 3 3 1 *\\ni=0 1 2 3 4 5 6 7 8 9...             ...19\\n  ^\\t\\t        ^               ^   ^   ^\\n  P1\\t\\t    P2              P3  P4  P5\\n```\\n\\n- We assign candy=1 (minimum candy) to the pit tower and go left and right to the pit tower till we encounter peak. Assigning candy to the towers by increasing it by 1.\\n- For example if we start with pit P1, then we assign\\n\\t- candy=1 to tower at i=0\\n\\t- candy=2 to tower at i=1\\n\\t- candy=3 to tower at i=2\\n\\t- candy=4 to tower at i=3\\n\\t- candy=5 to tower at i=4\\n\\t- **we have now reached the peak so we store the peakIndex and peakVal**\\n\\t- we store peakIndex and peakVal only when we go to the right of pit\\n\\n- When we go to the left of the pit and if we reach the peak which already has candy assigned so we check if the new candy we are carrying is greater than the candy already assigned, if yes then we remove the original candy assigned and assign it the new candy.\\n- For example, when we start with pit=P2 and keep going left we see that when we reach peak at i=4\\n\\t- new candy = 4 \\n\\t- But old candy assigned = 5, so we don\\'t assign it new candy\\n\\t\\nHence we start with \\n```\\npeakIndex = None  #index of peak to the right of the pit\\npeakVal = None  # candy assigned to the peak\\ntotalSum = 0 # total candies assigned\\n```\\n\\n**Python code:**\\n\\n```\\ndef candy(self, L):\\n    #whenever you encounter a pit then assign values to towers by going left and right\\n    \\n    #creating infinte size towers to left and right borders\\n    L.insert(0,float(\\'inf\\'))\\n    L.append(float(\\'inf\\'))\\n    \\n    peakIndex = None\\n    peakVal = None\\n    totalCandy = 0\\n    \\n    for i in xrange(1,len(L)-1):\\n        if L[i-1]>=L[i]<=L[i+1]:\\n            #means this point is a pit so start filling left and right\\n            \\n            # +1 corresponds to assigning candy=1 to the pit\\n            totalCandy+=1\\n            \\n            #going left\\n            index = i-1\\n            curr_candy = 2\\n            \\n            #index>=1 so that we don\\'t reach the left infinite tower\\n            while index>=1 and L[index]>L[index+1]:\\n                #if we encounter peak\\n                if index==peakIndex:\\n                    totalCandy -= peakVal\\n                    totalCandy += max(peakVal,curr_candy)\\n                else:\\n                    totalCandy += curr_candy\\n                index-=1\\n                curr_candy+=1\\n                \\n            #going right\\n            index = i+1\\n            curr_candy = 2\\n            \\n            #index<len(L)-1 so that we don\\'t reach the right infinite tower\\n            while index<len(L)-1 and L[index]>L[index-1]:\\n                totalCandy += curr_candy\\n                index+=1\\n                curr_candy+=1\\n            \\n            #updating encountered peak\\n            peakIndex = index-1\\n            peakVal = curr_candy-1\\n    return totalCandy\\n```",
                "solutionTags": [],
                "code": "```\\nRatings:\\n\\nInf                                      Inf\\n|                   Peak                  |\\n|       Peak          |                   |\\n|         |           | |                 |\\n|       | |           | | |               |\\n|     | | | |       | | | | |     | | |   |\\n|   | | | | | |   | | | | | | |   | | |   |\\n| _ | | | | | | | | | | | | | | _ | | | | |\\n-------------------------------------------\\n* 0 2 3 4 5 3 2 1 2 3 6 5 4 3 2 0 3 3 3 1 *\\ni=0 1 2 3 4 5 6 7 8 9...             ...19\\n  ^\\t\\t        ^               ^   ^   ^\\n  P1\\t\\t    P2              P3  P4  P5\\n```\n```\\npeakIndex = None  #index of peak to the right of the pit\\npeakVal = None  # candy assigned to the peak\\ntotalSum = 0 # total candies assigned\\n```\n```\\ndef candy(self, L):\\n    #whenever you encounter a pit then assign values to towers by going left and right\\n    \\n    #creating infinte size towers to left and right borders\\n    L.insert(0,float(\\'inf\\'))\\n    L.append(float(\\'inf\\'))\\n    \\n    peakIndex = None\\n    peakVal = None\\n    totalCandy = 0\\n    \\n    for i in xrange(1,len(L)-1):\\n        if L[i-1]>=L[i]<=L[i+1]:\\n            #means this point is a pit so start filling left and right\\n            \\n            # +1 corresponds to assigning candy=1 to the pit\\n            totalCandy+=1\\n            \\n            #going left\\n            index = i-1\\n            curr_candy = 2\\n            \\n            #index>=1 so that we don\\'t reach the left infinite tower\\n            while index>=1 and L[index]>L[index+1]:\\n                #if we encounter peak\\n                if index==peakIndex:\\n                    totalCandy -= peakVal\\n                    totalCandy += max(peakVal,curr_candy)\\n                else:\\n                    totalCandy += curr_candy\\n                index-=1\\n                curr_candy+=1\\n                \\n            #going right\\n            index = i+1\\n            curr_candy = 2\\n            \\n            #index<len(L)-1 so that we don\\'t reach the right infinite tower\\n            while index<len(L)-1 and L[index]>L[index-1]:\\n                totalCandy += curr_candy\\n                index+=1\\n                curr_candy+=1\\n            \\n            #updating encountered peak\\n            peakIndex = index-1\\n            peakVal = curr_candy-1\\n    return totalCandy\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 42896,
                "title": "concise-java-solution",
                "content": "In the forward pass, if we meet r[i] < r[i+1] , assign candy[i+1] = candy[i]+1;\\n\\nIn the backward pass, the only difference is the case when r[i-1] < r[i] > r[i+1], need to compare candy[i+1]+1, and candy[i] (which is calculated in forward side).\\n\\n\\n    public class Solution {\\n        public int candy(int[] ratings) {\\n            // initialize\\n            int candy[] = new int[ratings.length];\\n            int sum = 0;\\n            Arrays.fill(candy,1); // crucial step!\\n            \\n            // forward pass, assign candy for increasing ones\\n            for(int i = 1;i < ratings.length;i++)\\n                if(ratings[i] > ratings[i-1])\\n                    candy[i] = candy[i-1]+1;\\n                    \\n            // backforward pass, assign candy for decreasing ones\\n            for(int i = ratings.length-2;i >= 0;i--)\\n                if(ratings[i] > ratings[i+1]){\\n                    if(i-1 >= 0 && ratings[i-1] <= ratings[i])\\n                        candy[i] = Math.max(candy[i+1]+1, candy[i]);\\n                    else\\n                        candy[i] = candy[i+1] + 1;\\n                }\\n            \\n            // sum up candy\\n            for(int i = 0;i < candy.length;i++)\\n                sum += candy[i];\\n            return sum;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int candy(int[] ratings) {\\n            // initialize\\n            int candy[] = new int[ratings.length];\\n            int sum = 0;\\n            Arrays.fill(candy,1); // crucial step!\\n            \\n            // forward pass, assign candy for increasing ones\\n            for(int i = 1;i < ratings.length;i++)\\n                if(ratings[i] > ratings[i-1])\\n                    candy[i] = candy[i-1]+1;\\n                    \\n            // backforward pass, assign candy for decreasing ones\\n            for(int i = ratings.length-2;i >= 0;i--)\\n                if(ratings[i] > ratings[i+1]){\\n                    if(i-1 >= 0 && ratings[i-1] <= ratings[i])\\n                        candy[i] = Math.max(candy[i+1]+1, candy[i]);\\n                    else\\n                        candy[i] = candy[i+1] + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4038177,
                "title": "100-easy-one-pass-solution-with-explanation-and-example-visualization",
                "content": "\\n# Approach\\nFirstly we\\'ll create an array ```left``` of ```size n+1```, this array will store the ```number of candies``` to be allotted to ith child considering his ```neighbours to left```.\\n\\nTraverse through the ratings array and if rating of current child is more than rating of previous child, increase the number of candies by 1, i.e ```left[i] = left[i-1] + 1```.\\n\\nWe\\'re accounting for the left neighbours, now we need to account for right neigbours, for this we can have another for loop which will run from ```right to left```, but this will just ```add on to space complexity```.\\n\\nOne thing that we notice in our left for loop is that we need to increment only when the current child\\'s rating is greater than previous child\\'r rating.\\n\\nSo in the for loop for ```right neighbour```, we will check if rating of current child is greater than one to its right, if it is we will increment the value of right and do ```left[i] = max(left[i], right)```.\\n\\nBy doing this we are incrementing the value of right ```only when the current rating is greater than next```, if its not our ```right``` stands at ```1```, this way we don\\'t need to store our candies for right neighbours in another array and then later take maximum, so we ```save ourselves a lot of time and space```.\\n\\nAt last find the ```sum``` of candies and ```return sum```.\\n\\n# I\\'ve explained an example below for better understanding-\\n![image.png](https://assets.leetcode.com/users/images/73408bf6-d2b5-4c93-ab81-a532d5210989_1694580577.7185543.png)\\n\\n\\n# Do upvote if you liked even a bit!\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n      vector<int> left(n+1,1);\\n      for(int i=1;i<n;i++){\\n          if(ratings[i]>ratings[i-1]) left[i]=left[i-1]+1;\\n      }  \\n\\n      int right=1;\\n      for(int i=n-2;i>=0;i--){\\n          if(ratings[i]>ratings[i+1]){\\n            right++;\\n            left[i]=max(left[i],right);\\n          }else right=1;\\n      }\\n\\n      int sum=0;\\n      for(int i=0;i<n;i++){\\n            sum+=left[i];\\n      }\\n      return sum;\\n    }\\n};\\n```\\n# JAVA Code\\n```\\npublic class Solution {\\n    public int candy(int[] ratings) {\\n        if (ratings == null || ratings.length == 0) return 0;\\n        int total = 1, prev = 1, countDown = 0;\\n        for (int i = 1; i < ratings.length; i++) {\\n            if (ratings[i] >= ratings[i-1]) {\\n                if (countDown > 0) {\\n                    total += countDown*(countDown+1)/2; // arithmetic progression\\n                    if (countDown >= prev) total += countDown - prev + 1;\\n                    countDown = 0;\\n                    prev = 1;\\n                }\\n                prev = ratings[i] == ratings[i-1] ? 1 : prev+1;\\n                total += prev;\\n            } else countDown++;\\n        }\\n        if (countDown > 0) { // if we were descending at the end\\n            total += countDown*(countDown+1)/2;\\n            if (countDown >= prev) total += countDown - prev + 1;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```left```\n```size n+1```\n```number of candies```\n```neighbours to left```\n```left[i] = left[i-1] + 1```\n```right to left```\n```add on to space complexity```\n```right neighbour```\n```left[i] = max(left[i], right)```\n```only when the current rating is greater than next```\n```right```\n```1```\n```save ourselves a lot of time and space```\n```sum```\n```return sum```\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n      vector<int> left(n+1,1);\\n      for(int i=1;i<n;i++){\\n          if(ratings[i]>ratings[i-1]) left[i]=left[i-1]+1;\\n      }  \\n\\n      int right=1;\\n      for(int i=n-2;i>=0;i--){\\n          if(ratings[i]>ratings[i+1]){\\n            right++;\\n            left[i]=max(left[i],right);\\n          }else right=1;\\n      }\\n\\n      int sum=0;\\n      for(int i=0;i<n;i++){\\n            sum+=left[i];\\n      }\\n      return sum;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public int candy(int[] ratings) {\\n        if (ratings == null || ratings.length == 0) return 0;\\n        int total = 1, prev = 1, countDown = 0;\\n        for (int i = 1; i < ratings.length; i++) {\\n            if (ratings[i] >= ratings[i-1]) {\\n                if (countDown > 0) {\\n                    total += countDown*(countDown+1)/2; // arithmetic progression\\n                    if (countDown >= prev) total += countDown - prev + 1;\\n                    countDown = 0;\\n                    prev = 1;\\n                }\\n                prev = ratings[i] == ratings[i-1] ? 1 : prev+1;\\n                total += prev;\\n            } else countDown++;\\n        }\\n        if (countDown > 0) { // if we were descending at the end\\n            total += countDown*(countDown+1)/2;\\n            if (countDown >= prev) total += countDown - prev + 1;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558829,
                "title": "c-easy-o-n-solution-using-2-only-for-loop",
                "content": "# Intuition  \\n   If neighbour rating is less we should give that child one more candy.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAt initials - give 1 candy to every child to meet the condition - every child must get a candy.\\n\\nTHEN \\n\\n    for loop ---------------->\\n      If ratings[i]>ratings[i-1]\\n            i+1 th child get one more candy than i th child,so increase it once\\n     for loop <-----------------\\n      If ratings[i]>ratings[i+1]\\n           i th child get one more candy than i+1 th child, so increase it once \\n\\n\\nOne more thing you have to keep in mind that, while reverse traversing in 2nd loop you should not give a increment to a child who already got in first loop and not required increment anymore\\n\\n         example :-\\n     ratings              1 3 2 2 1\\n     candy get:-\\n     intitials            1 1 1 1 1\\n     after 1st loop       1 2 1 1 1\\n     after 2nd loop       1 3 1 2 1\\n                            ^\\n                            |\\n                        got increment twice, but dont need in 2nd loop\\n    so while reverse traversing we also check\\n               candy[i]<=candy[i+1]\\n                              then only it get a increment.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        if(ratings.size()==1){\\n            return 1;\\n        }\\n        \\n        vector<int>ans(ratings.size(),1);  \\n        for(int i=1;i<ratings.size();i++){\\n            if(ratings[i]>ratings[i-1]){\\n                ans[i]=ans[i-1]+1;\\n            }\\n        }\\n        for(int i=ratings.size()-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                ans[i]=ans[i+1]+1;\\n            }\\n        }\\n      \\n     return accumulate(ans.begin(),ans.end(),0LL);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        if(ratings.size()==1){\\n            return 1;\\n        }\\n        \\n        vector<int>ans(ratings.size(),1);  \\n        for(int i=1;i<ratings.size();i++){\\n            if(ratings[i]>ratings[i-1]){\\n                ans[i]=ans[i-1]+1;\\n            }\\n        }\\n        for(int i=ratings.size()-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                ans[i]=ans[i+1]+1;\\n            }\\n        }\\n      \\n     return accumulate(ans.begin(),ans.end(),0LL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013668,
                "title": "java-1ms-simple-solution-with-detailed-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic Trapping Rainwater like solution. https://leetcode.com/problems/trapping-rain-water/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nObservations : \\n- init with all 1.\\n- we only give one more when we see adjacent increase (both from left to right).\\n- I want to use some case to illustrate this.\\n- notice we don\\'t care for the exact values of ratings, only their relation\\n\\nthe rating is similar to \\'wave\\', increase of decrease\\n\\nlet\\'s look at this case:\\n```\\nratings: [1,3,6,9,4,2]\\ncandies: [1,2,3,4,2,1]\\n```\\n\\nthe highest rating is 9, when scan from left to right, num of candies should be 4, scan right to left, it should be 3, then we choose the larger value.\\n\\nand let\\'s look at some case containing adjacent-equal\\n\\nwhen there are adjacent-equal, lets look at some cases:\\n\\n```\\nratings: [1,2,3,3,3,3,4,5]\\ncandies: [1,2,3,1,1,1,2,3]\\n```\\n\\n```\\nratings: [1,2,8,8,8,8,8,2]\\ncandies: [1,2,3,1,1,1,2,1]\\n```\\n\\nwith these cases it should be easier to understand\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int[] cendies = new int[ratings.length];\\n        \\n        for(int i=0; i<cendies.length; ++i){\\n            cendies[i]=1;\\n        }\\n\\n        for(int i=1; i<cendies.length; ++i){\\n            if(ratings[i]>ratings[i-1]){\\n                cendies[i]=cendies[i-1]+1;\\n            }\\n        }\\n\\n        for(int i=cendies.length-2; i>=0; --i){\\n            if(ratings[i]>ratings[i+1] && cendies[i]<cendies[i+1]+1){\\n                cendies[i]=cendies[i+1]+1;\\n            }\\n        }\\n\\n        int sum=0;\\n        for(int i=0; i<cendies.length; ++i){\\n            sum+=cendies[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nratings: [1,3,6,9,4,2]\\ncandies: [1,2,3,4,2,1]\\n```\n```\\nratings: [1,2,3,3,3,3,4,5]\\ncandies: [1,2,3,1,1,1,2,3]\\n```\n```\\nratings: [1,2,8,8,8,8,8,2]\\ncandies: [1,2,3,1,1,1,2,1]\\n```\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int[] cendies = new int[ratings.length];\\n        \\n        for(int i=0; i<cendies.length; ++i){\\n            cendies[i]=1;\\n        }\\n\\n        for(int i=1; i<cendies.length; ++i){\\n            if(ratings[i]>ratings[i-1]){\\n                cendies[i]=cendies[i-1]+1;\\n            }\\n        }\\n\\n        for(int i=cendies.length-2; i>=0; --i){\\n            if(ratings[i]>ratings[i+1] && cendies[i]<cendies[i+1]+1){\\n                cendies[i]=cendies[i+1]+1;\\n            }\\n        }\\n\\n        int sum=0;\\n        for(int i=0; i<cendies.length; ++i){\\n            sum+=cendies[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301339,
                "title": "candy-python-144ms-runtime-2-solutions",
                "content": "\\n\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        lenratings = len(ratings)       # call len only once. It is used 3 times\\n        ans = [1] * lenratings\\n        for i in range(1, lenratings):\\n            if ratings[i] > ratings[i-1]:\\n                ans[i] = ans[i-1] + 1\\n        for i in range(lenratings-2, -1, -1):\\n            a = i+1                     # a is used 2 times in if\\n            # compare rantings and candys is faster than use \"max\" to calculate.\\n            if ratings[i] > ratings[a] and ans[i] <= ans[a]:\\n                ans[i] = ans[a] + 1\\n        return sum(ans)\\n```\\n\\nIn this second solution I try to save some time in the reverse loop saving only indexes that should be visited. But in the end of the tests the runtime is the same but usage memory is bigger.\\n\\n```\\nclass Solution:\\n    def candy(self, ratings: list) -> int:\\n        lenratings = len(ratings)       # call len only once. It is used 3 times\\n        ans = [1] * lenratings\\n        b = []\\n        for i in range(1, lenratings):\\n            if ratings[i] > ratings[i-1]:\\n                ans[i] = ans[i-1] + 1\\n            else:\\n                b.append(i-1)\\n        b.reverse()\\n        for i in b:\\n            a = i+1                     # a is used 2 times in if\\n            # compare rantings and candys is faster than use \"max\" to calculate.\\n            if ratings[i] > ratings[a] and ans[i] <= ans[a]:\\n                ans[i] = ans[a] + 1\\n        return sum(ans)\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        lenratings = len(ratings)       # call len only once. It is used 3 times\\n        ans = [1] * lenratings\\n        for i in range(1, lenratings):\\n            if ratings[i] > ratings[i-1]:\\n                ans[i] = ans[i-1] + 1\\n        for i in range(lenratings-2, -1, -1):\\n            a = i+1                     # a is used 2 times in if\\n            # compare rantings and candys is faster than use \"max\" to calculate.\\n            if ratings[i] > ratings[a] and ans[i] <= ans[a]:\\n                ans[i] = ans[a] + 1\\n        return sum(ans)\\n```\n```\\nclass Solution:\\n    def candy(self, ratings: list) -> int:\\n        lenratings = len(ratings)       # call len only once. It is used 3 times\\n        ans = [1] * lenratings\\n        b = []\\n        for i in range(1, lenratings):\\n            if ratings[i] > ratings[i-1]:\\n                ans[i] = ans[i-1] + 1\\n            else:\\n                b.append(i-1)\\n        b.reverse()\\n        for i in b:\\n            a = i+1                     # a is used 2 times in if\\n            # compare rantings and candys is faster than use \"max\" to calculate.\\n            if ratings[i] > ratings[a] and ans[i] <= ans[a]:\\n                ans[i] = ans[a] + 1\\n        return sum(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037690,
                "title": "c-greedy-vs-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s a greedy problem.\\nLook at this example. You\\'ll find how unfair this rule is.\\n```\\n[60, 80, 100, 100, 100, 100, 100]\\n```\\ncandies for children\\n```\\n1, 2, 3, 1, 1, 1, 1\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse prefix sum.It\\'s easier to understand. Transverse forward & backward. 3 conditions to consider\\n1. ratings[i-1] < ratings[i]: c[i]=c[i-1]+1;\\n2. ratings[i-1] ==ratings[i]==ratings[i+1]: c[i]; 1 candy is enough\\n3. ratings[i]>ratings[i+1]: c[i]=max(c[i], c[i+1]+1); Use it when backward \\n\\nThis can be done just using one loop. But the handeling is a little bit subtle.\\n\\nSupposed one has arrived the peak, i.e. ```c[i]=peak+1```. From index i on, ```ratings[i]``` form a strictly decreasing sebsequence of length down+1. If peak>=down the candies for subdsequence of length ```down+1```.\\n```\\ncs=[peak+1,down, down-1, ...., 2, 1] \\n```\\notherwise, i.e. peak<down, when adding 1 more ```ratings[i]``` with ```ratings[i-1]>ratings[i]```\\nevery element in ```cs```should be increased by 1 whose total amount is ```down+1```.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1st code: $O(1)$\\n2nd code: $O(n)$\\n#  Code using 1 transversal &  O(1) SC\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        int ans = 1;\\n        int up = 0, down = 0, peak = 0;\\n         for (int i = 1; i <n; i++) {\\n             //ascending\\n            if (ratings[i-1] < ratings[i]) {\\n                peak = ++up;\\n                down = 0;\\n                ans+= 1+peak;//c[i]=1+peak\\n            } \\n            //slope=0\\n            else if (ratings[i-1] == ratings[i])  {\\n                peak =up = down = 0;\\n                ans++;//c[i]=1\\n            } \\n            else {//decreasing\\n                up = 0;\\n                down++;//length for decreasing subsequence\\n                ans += (peak<down)? down+1: down;\\n                //If peak>=down the candies for subdsequence of length down+1\\n                //cs=[peak+1,down, down-1, ...., 2, 1] otherwise when adding 1 more \\n                //every element in cs should be increased by 1 which amount down+1\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Prefix Sum\\n```\\nclass Solution {\\npublic:\\n    void print(vector<int>& c){\\n        for(int i=0; i<c.size(); i++)\\n            cout<<c[i]<<\",\";\\n        cout<<endl;\\n    }\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int> c(n, 1);\\n\\n        for (int i=1; i<n; i++){\\n            if (ratings[i]>ratings[i-1]) \\n                c[i]=c[i-1]+1;\\n        }\\n        for (int i=n-2; i>=0; i--)\\n            if (ratings[i]>ratings[i+1]) \\n                c[i]=max(c[i], c[i+1]+1);\\n    //    print(c);\\n        return accumulate(c.begin(), c.begin()+n,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\n[60, 80, 100, 100, 100, 100, 100]\\n```\n```\\n1, 2, 3, 1, 1, 1, 1\\n```\n```c[i]=peak+1```\n```ratings[i]```\n```down+1```\n```\\ncs=[peak+1,down, down-1, ...., 2, 1] \\n```\n```ratings[i]```\n```ratings[i-1]>ratings[i]```\n```cs```\n```down+1```\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        int ans = 1;\\n        int up = 0, down = 0, peak = 0;\\n         for (int i = 1; i <n; i++) {\\n             //ascending\\n            if (ratings[i-1] < ratings[i]) {\\n                peak = ++up;\\n                down = 0;\\n                ans+= 1+peak;//c[i]=1+peak\\n            } \\n            //slope=0\\n            else if (ratings[i-1] == ratings[i])  {\\n                peak =up = down = 0;\\n                ans++;//c[i]=1\\n            } \\n            else {//decreasing\\n                up = 0;\\n                down++;//length for decreasing subsequence\\n                ans += (peak<down)? down+1: down;\\n                //If peak>=down the candies for subdsequence of length down+1\\n                //cs=[peak+1,down, down-1, ...., 2, 1] otherwise when adding 1 more \\n                //every element in cs should be increased by 1 which amount down+1\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void print(vector<int>& c){\\n        for(int i=0; i<c.size(); i++)\\n            cout<<c[i]<<\",\";\\n        cout<<endl;\\n    }\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int> c(n, 1);\\n\\n        for (int i=1; i<n; i++){\\n            if (ratings[i]>ratings[i-1]) \\n                c[i]=c[i-1]+1;\\n        }\\n        for (int i=n-2; i>=0; i--)\\n            if (ratings[i]>ratings[i+1]) \\n                c[i]=max(c[i], c[i+1]+1);\\n    //    print(c);\\n        return accumulate(c.begin(), c.begin()+n,0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3812877,
                "title": "python-easy-code-beats-95-82-runtime-and-94-23-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI used the approach of once iterating from left to right and then from right to left. Here, we had to consider kids on either sides, hence this was a good technique to achieve O(n).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo maintain our O(n) complexity target, dynamic programming seems to be a likable option. We initialize our dp array with all 1s as each child has to have atleast one candy. We then iterate and compare with the neighbours and keep adding candies so that a child with higher rating gets more candies than neighbours.\\nNote: We have to check whether the high rated child already has more candies, if so then we do not add more. So we have to compare ratings as well as candies at hand before assigning. This is because we need to allot \\'minimum\\' number of candies.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/05ae6b88-ee2c-4f3c-9fd0-81abdea06599_1690264401.968263.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        dp = [1]*n\\n        #left to right\\n        for i in range(1,n):\\n            if ratings[i]>ratings[i-1] and dp[i]<=dp[i-1]:\\n                dp[i] = dp[i-1]+1\\n        #right to left\\n        for i in range(n-2,-1,-1):\\n            if ratings[i]>ratings[i+1] and dp[i]<=dp[i+1]:\\n                dp[i] = dp[i+1]+1\\n        return sum(dp)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        dp = [1]*n\\n        #left to right\\n        for i in range(1,n):\\n            if ratings[i]>ratings[i-1] and dp[i]<=dp[i-1]:\\n                dp[i] = dp[i-1]+1\\n        #right to left\\n        for i in range(n-2,-1,-1):\\n            if ratings[i]>ratings[i+1] and dp[i]<=dp[i+1]:\\n                dp[i] = dp[i+1]+1\\n        return sum(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640353,
                "title": "easy-and-fast",
                "content": "# Intuition\\nThis is array based question.\\n\\n# Approach\\n1. Take candy array with size ratings and initialize with one.\\n2. Move left to right and compare the ratings and candy value if ratings high and candy value less or equal to then increase the candy array value.\\n3. Move right to left and do same #2.\\n4. Sum the values of candy array.\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} ratings\\n * @return {number}\\n */\\nvar candy = function(ratings) {\\n    let candy = new Array(ratings.length).fill(1);\\n\\n// left to right \\n    for(let i=1;i<ratings.length;i++){\\n        if(ratings[i]>ratings[i-1] && candy[i] <= candy[i-1]){\\n            candy[i]=candy[i-1]+1;\\n        }\\n    }\\n\\n// right to left\\n    for(let i=ratings.length-2;i>=0;i--){\\n    if(ratings[i]>ratings[i+1] && candy[i] <= candy[i+1]){\\n            candy[i]=candy[i+1]+1;\\n        }\\n    }\\n\\n    let sum = candy.reduce((cur,acc)=> acc=cur+acc);\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} ratings\\n * @return {number}\\n */\\nvar candy = function(ratings) {\\n    let candy = new Array(ratings.length).fill(1);\\n\\n// left to right \\n    for(let i=1;i<ratings.length;i++){\\n        if(ratings[i]>ratings[i-1] && candy[i] <= candy[i-1]){\\n            candy[i]=candy[i-1]+1;\\n        }\\n    }\\n\\n// right to left\\n    for(let i=ratings.length-2;i>=0;i--){\\n    if(ratings[i]>ratings[i+1] && candy[i] <= candy[i+1]){\\n            candy[i]=candy[i+1]+1;\\n        }\\n    }\\n\\n    let sum = candy.reduce((cur,acc)=> acc=cur+acc);\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2236598,
                "title": "python-o-n-time-o-n-space-explained",
                "content": "```\\n#Baraa\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        \"\"\"\\n        Good Example to check: \\n        [8, 4, 2, 1, 3, 6, 7, 9, 5]\\n        \\n        STEP 1: we compare each number with number before it\\n        if current number > number before it we have to increment our reward\\n        i.e: res[i] = res[i - 1] + 1\\n        \\n        STEP 2: We compare same way but from end of the array to beggining of it\\n        if current number > number after it we increment if and only if there is a need to increment\\n        because maybe when we incremented in the first step we already gave more rewards for current number\\n        this can be observed in the above example \\n        \"\"\"\\n        \\n        n = len(ratings)\\n        res = [1] * (n)\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1] and res[i] <= res[i - 1]:\\n                res[i] = res[i - 1] + 1\\n        for i in range(n - 2, -1, -1):\\n            if ratings[i] > ratings[i + 1] and res[i] <= res[i + 1]:\\n                res[i] = res[i + 1] + 1\\n        return sum(res)\\n    \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n#Baraa\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        \"\"\"\\n        Good Example to check: \\n        [8, 4, 2, 1, 3, 6, 7, 9, 5]\\n        \\n        STEP 1: we compare each number with number before it\\n        if current number > number before it we have to increment our reward\\n        i.e: res[i] = res[i - 1] + 1\\n        \\n        STEP 2: We compare same way but from end of the array to beggining of it\\n        if current number > number after it we increment if and only if there is a need to increment\\n        because maybe when we incremented in the first step we already gave more rewards for current number\\n        this can be observed in the above example \\n        \"\"\"\\n        \\n        n = len(ratings)\\n        res = [1] * (n)\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1] and res[i] <= res[i - 1]:\\n                res[i] = res[i - 1] + 1\\n        for i in range(n - 2, -1, -1):\\n            if ratings[i] > ratings[i + 1] and res[i] <= res[i + 1]:\\n                res[i] = res[i + 1] + 1\\n        return sum(res)\\n    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235735,
                "title": "candy-java-solution-optimized",
                "content": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n =  ratings.length;\\n        if(n <= 1)\\n            return n;\\n        int up = 0,down = 0;\\n        int prevSlope = 0;\\n        int candies = 0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            //calculate the slope\\n            //assign -ve +iv or zero for the decreasing increasing or plain slope\\n            //increasing slope = 1\\n            //decreasing slope = -1\\n            //plain slope = 0\\n            int current_Slope = ratings[i]>ratings[i-1]?1:\\n                                (ratings[i]<ratings[i-1]?-1:0);\\n            //divide the mountains on 3 conditions\\n            /*Condition 1:\\n              If we are getting a mountain like \\\\/ i.e the slope is decreasing and then increasing,\\n              \\n            */\\n            \\n            /*Condition 2:\\n              If we are getting a mountain like \\\\_ i.e the slope is decreasing and then plain,\\n              \\n            */\\n            \\n            /*Condition 3:\\n                                               _\\n              If we are getting mountain like /  i.e the slope is decreasing and then increasing,\\n              \\n            */\\n            if((prevSlope<0 && current_Slope>=0) || (prevSlope>0 && current_Slope==0))\\n            {\\n                candies = candies + sum(up) + sum(down) + Math.max(up,down);\\n                up=0;\\n                down=0;\\n            }\\n            if(current_Slope > 0)\\n                up++;\\n            else if(current_Slope < 0)\\n                down++;\\n            else\\n                candies++;\\n            prevSlope = current_Slope;\\n        }\\n        //add the candies that are there for the last mountain\\n        candies = candies + sum(up) + sum(down) + Math.max(up,down) + 1;\\n        return candies;\\n    }\\n    public int sum(int n)\\n    {\\n        return (n*(n+1))/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n =  ratings.length;\\n        if(n <= 1)\\n            return n;\\n        int up = 0,down = 0;\\n        int prevSlope = 0;\\n        int candies = 0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            //calculate the slope\\n            //assign -ve +iv or zero for the decreasing increasing or plain slope\\n            //increasing slope = 1\\n            //decreasing slope = -1\\n            //plain slope = 0\\n            int current_Slope = ratings[i]>ratings[i-1]?1:\\n                                (ratings[i]<ratings[i-1]?-1:0);\\n            //divide the mountains on 3 conditions\\n            /*Condition 1:\\n              If we are getting a mountain like \\\\/ i.e the slope is decreasing and then increasing,\\n              \\n            */\\n            \\n            /*Condition 2:\\n              If we are getting a mountain like \\\\_ i.e the slope is decreasing and then plain,\\n              \\n            */\\n            \\n            /*Condition 3:\\n                                               _\\n              If we are getting mountain like /  i.e the slope is decreasing and then increasing,\\n              \\n            */\\n            if((prevSlope<0 && current_Slope>=0) || (prevSlope>0 && current_Slope==0))\\n            {\\n                candies = candies + sum(up) + sum(down) + Math.max(up,down);\\n                up=0;\\n                down=0;\\n            }\\n            if(current_Slope > 0)\\n                up++;\\n            else if(current_Slope < 0)\\n                down++;\\n            else\\n                candies++;\\n            prevSlope = current_Slope;\\n        }\\n        //add the candies that are there for the last mountain\\n        candies = candies + sum(up) + sum(down) + Math.max(up,down) + 1;\\n        return candies;\\n    }\\n    public int sum(int n)\\n    {\\n        return (n*(n+1))/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234474,
                "title": "c-from-the-left-from-the-right-max-of-both",
                "content": "iterate from the left to right\\niterate from right to left\\nadd max of left pass and right pass at each index\\n\\n**SOLVED LIVE ON TWITCH.   Everyday 6pm PT.  Link in profile.**\\n\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        \\n        vector<int> lefts(n, 1);\\n        vector<int> rights(n, 1);\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                lefts[i] = lefts[i-1] + 1;\\n            }\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                rights[i] = rights[i+1] + 1;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < n; i++) {\\n            ans += max(lefts[i], rights[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        \\n        vector<int> lefts(n, 1);\\n        vector<int> rights(n, 1);\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                lefts[i] = lefts[i-1] + 1;\\n            }\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                rights[i] = rights[i+1] + 1;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < n; i++) {\\n            ans += max(lefts[i], rights[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739602,
                "title": "solution-swift-candy-test-cases",
                "content": "```swift\\nclass Solution {\\n    func candy(_ ratings: [Int]) -> Int {\\n        let len = ratings.count\\n        guard len > 1 else { return len }\\n        \\n        var value = 0\\n        \\n        var lhs2rhs = [Int](repeating: 1, count: len)\\n        var rhs2lhs = [Int](repeating: 1, count: len)\\n        \\n        for i in 1..<len where ratings[i] > ratings[i - 1] {\\n            lhs2rhs[i] = lhs2rhs[i - 1] + 1\\n        }\\n        for i in (0..<(len - 1)).reversed() where ratings[i] > ratings[i + 1] {\\n            rhs2lhs[i] = rhs2lhs[ i + 1] + 1\\n        }\\n        for i in 0..<len {\\n            value += max(lhs2rhs[i], rhs2lhs[i])\\n        }\\n        return value\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.010 (0.012) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\\n    func test0() {\\n        let value = solution.candy([1,0,2])\\n        XCTAssertEqual(value, 5)\\n    }\\n    \\n    // You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\\n    // The third child gets 1 candy because it satisfies the above two conditions.\\n    func test1() {\\n        let value = solution.candy([1,2,2])\\n        XCTAssertEqual(value, 4)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func candy(_ ratings: [Int]) -> Int {\\n        let len = ratings.count\\n        guard len > 1 else { return len }\\n        \\n        var value = 0\\n        \\n        var lhs2rhs = [Int](repeating: 1, count: len)\\n        var rhs2lhs = [Int](repeating: 1, count: len)\\n        \\n        for i in 1..<len where ratings[i] > ratings[i - 1] {\\n            lhs2rhs[i] = lhs2rhs[i - 1] + 1\\n        }\\n        for i in (0..<(len - 1)).reversed() where ratings[i] > ratings[i + 1] {\\n            rhs2lhs[i] = rhs2lhs[ i + 1] + 1\\n        }\\n        for i in 0..<len {\\n            value += max(lhs2rhs[i], rhs2lhs[i])\\n        }\\n        return value\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\\n    func test0() {\\n        let value = solution.candy([1,0,2])\\n        XCTAssertEqual(value, 5)\\n    }\\n    \\n    // You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\\n    // The third child gets 1 candy because it satisfies the above two conditions.\\n    func test1() {\\n        let value = solution.candy([1,2,2])\\n        XCTAssertEqual(value, 4)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917156,
                "title": "java-greedy-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int candy(int[] arr) {\\n        int n=arr.length;\\n        int a[]=new int[n];\\n        Arrays.fill(a,1);\\n        for(int i=0;i<n-1;i++){\\n            if(arr[i]<arr[i+1]){\\n                a[i+1]=1+a[i];\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            if(arr[i]<arr[i-1]&&a[i-1]<=a[i]){\\n                a[i-1]=a[i]+1;\\n            }\\n        }\\n        int sum=0;\\n        for(int i:a)sum+=i;\\n        return sum;\\n    }\\n}\\n```\\n# Please upvote",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] arr) {\\n        int n=arr.length;\\n        int a[]=new int[n];\\n        Arrays.fill(a,1);\\n        for(int i=0;i<n-1;i++){\\n            if(arr[i]<arr[i+1]){\\n                a[i+1]=1+a[i];\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            if(arr[i]<arr[i-1]&&a[i-1]<=a[i]){\\n                a[i-1]=a[i]+1;\\n            }\\n        }\\n        int sum=0;\\n        for(int i:a)sum+=i;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702993,
                "title": "5-lines-of-efficient-code-step-by-step-approach",
                "content": "# Intuition\\nMy initial thoughts on how to solve this problem are to iterate through the ratings array and compare each element with its neighboring elements. If an element is greater than its previous element, I would assign it one more candy than the previous element. Similarly, if an element is greater than its next element, I would assign it one more candy than the next element. This way, I can ensure that higher-rated students receive more candies than their neighbors.\\n\\n# Approach\\nTo solve the problem, I will use a greedy approach. I will initialize a result variable as 0 to keep track of the total number of candies needed. I will also create two arrays, ltr and rtl, both of length n (where n is the number of elements in the ratings array). The ltr array will store the number of candies assigned to each student from left to right, and the rtl array will store the number of candies assigned to each student from right to left.\\n\\nFirst, I will iterate through the ratings array from index 1 to n-1. If the current rating is greater than the previous rating, I will assign one more candy than the previous student to the current student by updating the ltr array.\\n\\nThen, I will iterate through the ratings array from index n-2 to 0. If the current rating is greater than the next rating, I will assign one more candy than the next student to the current student by updating the rtl array.\\n\\nFinally, I will iterate through the ratings array and add the maximum value between ltr[i] and rtl[i] to the result variable.\\n\\nAfter the iterations, the result variable will contain the minimum number of candies needed to satisfy the given conditions. I will return this result.\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution is O(n), where n is the number of elements in the ratings array. This is because we iterate through the ratings array three times, which takes linear time.\\n- Space complexity: The space complexity is also O(n) because we create two arrays, ltr and rtl, of length n to store the number of candies assigned to each student.\\n\\n# Code\\n```\\nfunction candy(ratings: number[]): number {\\n    let res = 0 , n = ratings.length, ltr = new Array(n).fill(1) , rtl = new Array(n).fill(1);\\n    for( let i = 1 ; i < n ; i++ )if( ratings[i] > ratings[i - 1])ltr[i] = ltr[i - 1] + 1;\\n    for( let i = n - 2 ; i >= 0 ; i-- )if( ratings[i] > ratings[i + 1])rtl[i] = rtl[i + 1] + 1;\\n    for( let i = 0 ; i < n ; i++ )res += Math.max(ltr[i] , rtl[i])\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nfunction candy(ratings: number[]): number {\\n    let res = 0 , n = ratings.length, ltr = new Array(n).fill(1) , rtl = new Array(n).fill(1);\\n    for( let i = 1 ; i < n ; i++ )if( ratings[i] > ratings[i - 1])ltr[i] = ltr[i - 1] + 1;\\n    for( let i = n - 2 ; i >= 0 ; i-- )if( ratings[i] > ratings[i + 1])rtl[i] = rtl[i + 1] + 1;\\n    for( let i = 0 ; i < n ; i++ )res += Math.max(ltr[i] , rtl[i])\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3490359,
                "title": "java-solution-for-candy-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to use two passes to distribute candies to children. In the first pass, we traverse the ratings from left to right and assign candies to each child based on the ratings of the previous child. If the rating of the current child is higher than the previous child, we assign one more candy than the previous child. Otherwise, we assign one candy. In the second pass, we traverse the ratings from right to left and update the candies assigned to each child based on the ratings of the next child. If the rating of the current child is higher than the next child, we assign one more candy than the next child. We take the maximum of the candies assigned in both passes for each child and return the sum of all candies assigned.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if the input array ratings is null or empty. If so, return 0, as there are no children to distribute candies to.\\n2. Initialize an array candies of the same length as ratings to store the candies assigned to each child.\\n3. Assign one candy to the first child.\\n4. Traverse the ratings from left to right and assign candies to each child based on the ratings of the previous child. If the rating of the current child is higher than the previous child, assign one more candy than the previous child. Otherwise, assign one candy.\\n5. Traverse the ratings from right to left and update the candies assigned to each child based on the ratings of the next child. If the rating of the current child is higher than the next child, assign one more candy than the next child. Take the maximum of the candies assigned in both passes for each child.\\n6. Return the sum of all candies assigned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the input array ratings. The algorithm iterates through the array twice, performing constant-time operations for each element.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), as the algorithm uses an additional array candies of the same length as ratings to store the candies assigned to each child.\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int candy(int[] ratings) \\n    {\\n        if (ratings == null || ratings.length == 0) \\n        {\\n            return 0;\\n        }\\n        int[] candies = new int[ratings.length];\\n        candies[0] = 1;\\n        //from let to right\\n        for (int i = 1; i < ratings.length; i++) \\n        {\\n            if (ratings[i] > ratings[i - 1]) \\n            {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n            else \\n            {\\n                // if not ascending, assign 1\\n                candies[i] = 1;\\n            }\\n        }\\n        int result = candies[ratings.length - 1];\\n        //from right to left\\n        for (int i = ratings.length - 2; i >= 0; i--) \\n        {\\n            int cur = 1;\\n            if (ratings[i] > ratings[i + 1]) \\n            {\\n                cur = candies[i + 1] + 1;\\n            }\\n            result += Math.max(cur, candies[i]);\\n            candies[i] = cur;\\n        }\\n        return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int candy(int[] ratings) \\n    {\\n        if (ratings == null || ratings.length == 0) \\n        {\\n            return 0;\\n        }\\n        int[] candies = new int[ratings.length];\\n        candies[0] = 1;\\n        //from let to right\\n        for (int i = 1; i < ratings.length; i++) \\n        {\\n            if (ratings[i] > ratings[i - 1]) \\n            {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n            else \\n            {\\n                // if not ascending, assign 1\\n                candies[i] = 1;\\n            }\\n        }\\n        int result = candies[ratings.length - 1];\\n        //from right to left\\n        for (int i = ratings.length - 2; i >= 0; i--) \\n        {\\n            int cur = 1;\\n            if (ratings[i] > ratings[i + 1]) \\n            {\\n                cur = candies[i + 1] + 1;\\n            }\\n            result += Math.max(cur, candies[i]);\\n            candies[i] = cur;\\n        }\\n        return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300609,
                "title": "very-simple-approach-with-explained-theory-and-code-using-one-array-o-n",
                "content": "**To solve this problem we will traverse the Rating array two times , Once Left to right ,second\\nRight to left\\nFirst we will make a resultant array equal to the size of ratings and fill it with 1 at every index\\nWhile Traversing left to right we will start from 2nd element and check if this is greater then prev elem then we will increase resultant array[i] = resultant[i-1]+1\\nNow second traversal \\nwe will start from right second element and check if  this is greater then next element  then we will check further if res[i]<=res[i+1] then we will inc res[i]=  res[i+1]+1\\nNow we will traverse the res array and return sum of its element\\nNow below is the code \\nDo Upvote please!  :)\\nHappy Leetcoding**\\n\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] res = new int[n];\\n        Arrays.fill(res,1);\\n        //Left to right scan and check whether ratings[i]>ratings[i-1] if yes then increment by res[i-1]+1\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                res[i] = res[i-1]+1;\\n            }\\n        }\\n        \\n        System.out.println(Arrays.toString(res));\\n        // Right to left scan and check whether raings[i]>ratings[i+1] if yes then check whether res[i]<=res[i+1] \\n        //inc by res[i+1]+1\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                if(res[i]<=res[i+1]){\\n                    res[i] = res[i+1]+1;\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            cnt+=res[i];\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] res = new int[n];\\n        Arrays.fill(res,1);\\n        //Left to right scan and check whether ratings[i]>ratings[i-1] if yes then increment by res[i-1]+1\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                res[i] = res[i-1]+1;\\n            }\\n        }\\n        \\n        System.out.println(Arrays.toString(res));\\n        // Right to left scan and check whether raings[i]>ratings[i+1] if yes then check whether res[i]<=res[i+1] \\n        //inc by res[i+1]+1\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                if(res[i]<=res[i+1]){\\n                    res[i] = res[i+1]+1;\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            cnt+=res[i];\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016949,
                "title": "java-one-pass-o-1-space-4-line-solution",
                "content": "The general idea of one-pass solution with constant space is to use a few variables (rather than an array) to keep track of \"how many candies are needed\" in each section (with the same trend of fluctuation) and to reset these variables at good timing (when the trend changes).\\n\\nThe main logic consist of only 4 lines of code, dealing with the increasing trend, the stable trend, the decreasing trend and the compensation settlement, respectively.\\n\\n**case 1: increasing trend**\\nIf the current kid\\'s rating is higher than its preceding term: we increment `inc` and add it to `sum`. A simple explanation is that if this kid\\'s rating is higher than the preceding one, he/she should be assigned one more candy.\\n\\n**case 2: stable trend**\\nIf the current kid\\'s has the same rating with the preceding kid: we reset `inc` to be `0`.\\n\\n**case 3: decreasing trend**\\nThis case is a bit of complicated.  We add `dec` to `sum`, then increment `dec`. After doing so, we check whether the decresing trend terminates or changes. If the current element is the last element, we say \"the trend terminates\". If the next kid\\'s rating is not less than this one, we say \"the trend changes\". In either situation, a \\'compensation settlement\\' should be processed.\\n\\nThere are two tasks in the **compensation settlement**: first, we check whether `dec` is greater than `inc`, if so, we append their difference to `sum`. That is, `if (dec > ince) sum += (dec - inc); ` Note, `inc` is not updated in the decreasing section, it holds the peak value at the top of this downward slope. That\\'s why we compare `inc` and `dec` and update `sum`. The second task is to reset `inc` and `dec` to `0`.\\n\\nThe following code combines these two tasks in one statement (which is not very readable yet makes the whole code block more \\'compressed\\').\\n\\n```\\npublic int candy(int[] kid) {\\n  int sum = kid.length;\\n  int inc = 0;\\n  int dec = 0;\\n  \\n  for (int i = 1; i < kid.length; ++i) {\\n    if (kid[i - 1] < kid[i]) {\\n\\t  sum += (++inc);\\n\\t}\\n\\telse if (kid[i - 1] == kid[i]) {\\n\\t  inc = 0;\\n\\t}\\n\\telse {\\n\\t  sum += (dec++);\\n      // compensation settlement\\n\\t  if (i + 1 == kid.length || kid[i] <= kid[i + 1])\\n\\t    sum += Math.max(dec - inc, dec = inc = 0);\\n\\t}\\n  }\\n  return sum;\\n}\\n```\\n\\n\\n**Supplements:**\\n1. `sum` is initialized with the value of `kid.length`, which means that we already give each kid at least one candy.\\n\\n2. why the default value of `inc` and `dec` are `0`\\'s and why `sum` is updated in the form `(++inc)` and `(dec++)`? A simple explanation is that they (initial values and updating logic) are not fixed, however, they need to be consistent with each other (and other conditions). By comparing different initial values and corresponding update statements, I think the following code is concisest. You can, say, set the default value of `inc` to be `1` or set the default value of `dec` to be `-1`, etc. Yet, if so, you need also to adjust your code. \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int candy(int[] kid) {\\n  int sum = kid.length;\\n  int inc = 0;\\n  int dec = 0;\\n  \\n  for (int i = 1; i < kid.length; ++i) {\\n    if (kid[i - 1] < kid[i]) {\\n\\t  sum += (++inc);\\n\\t}\\n\\telse if (kid[i - 1] == kid[i]) {\\n\\t  inc = 0;\\n\\t}\\n\\telse {\\n\\t  sum += (dec++);\\n      // compensation settlement\\n\\t  if (i + 1 == kid.length || kid[i] <= kid[i + 1])\\n\\t    sum += Math.max(dec - inc, dec = inc = 0);\\n\\t}\\n  }\\n  return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172118,
                "title": "python-simple-10-line-two-passes-solution-with-explanation",
                "content": "1. Scan the ratings forward, comparing ratings[i] to ratings[i-1]. candies[i] = candies[i-1] + 1 if rating is larger than the previous neighbor. After this pass, we know each child gets more candies to its left neighbor if the rating is higher.\\n2. Scan the ratings backward, comparing ratings[i] to ratings[i+1]. Update candies if candies[i+1] > candies[i] and ratings[i] < ratings[i+1]. Because we have detected an inversion in the number of candies, we have to increment candies[i] to candies[i+1] + 1. After the second pass, we maintain the order from first pass and also make sure each child gets more candies to its right neighbor if the rating is higher. \\n3. Return total candies\\n```\\nclass Solution(object):\\n    def candy(self, ratings):\\n        \"\"\"\\n        :type ratings: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if ratings == []:\\n            return 0\\n        \\n        candies = [1] * len(ratings)\\n        \\n        for i in range(1, len(ratings)):\\n            if ratings[i] > ratings[i-1]:\\n                candies[i] = candies[i-1] + 1\\n                \\n        for i in range(len(ratings)-2, -1, -1):\\n            if ratings[i] > ratings[i+1] and candies[i] <= candies[i+1]:\\n                candies[i] = candies[i+1] + 1\\n        \\n        return sum(candies)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def candy(self, ratings):\\n        \"\"\"\\n        :type ratings: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if ratings == []:\\n            return 0\\n        \\n        candies = [1] * len(ratings)\\n        \\n        for i in range(1, len(ratings)):\\n            if ratings[i] > ratings[i-1]:\\n                candies[i] = candies[i-1] + 1\\n                \\n        for i in range(len(ratings)-2, -1, -1):\\n            if ratings[i] > ratings[i+1] and candies[i] <= candies[i+1]:\\n                candies[i] = candies[i+1] + 1\\n        \\n        return sum(candies)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42954,
                "title": "my-accepted-solution-is-quite-neat-but-not-sure-if-can-further-optimize-it",
                "content": "    public class Solution {\\n        public int candy(int[] ratings) {\\n    \\n            if(ratings.length < 2) return ratings.length;\\n            int[] leftTrav = new int[ratings.length];\\n            int[] rightTrav = new int[ratings.length];\\n            for(int i=0; i<length; i++) {\\n                leftTrav[i] = 1;\\n                rightTrav[i] = 1;\\n            }\\n            \\n            for(int i=0; i<length - 1; i++) {\\n                int j = (length - 1) - i;\\n                if(ratings[i+1] > ratings[i]) leftTrav[i+1] = leftTrav[i] + 1;\\n                if(ratings[j-1] > ratings[j]) rightTrav[j-1] = rightTrav[j] + 1;\\n            }\\n            int total = 0;\\n            for(int i=0; i<length; i++) total += Math.max(leftTrav[i], rightTrav[i]);\\n            return total;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int candy(int[] ratings) {\\n    \\n            if(ratings.length < 2) return ratings.length;\\n            int[] leftTrav = new int[ratings.length];\\n            int[] rightTrav = new int[ratings.length];\\n            for(int i=0; i<length; i++) {\\n                leftTrav[i] = 1;\\n                rightTrav[i] = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4040520,
                "title": "greedy-c-java-python-commented-code",
                "content": "# Intuition && approach\\n<!--  -->\\nThe first step is to create a vector of integers called candies with the same size as the ratings array. Each element of candies will store the number of candies that the corresponding child should get. We initialize all elements of candies to 1.\\n\\nIn the next step, we iterate through the ratings array from left to right. For each child, we check if its rating is higher than the rating of its left neighbor. If so, we update the value of candies[i] to candies[i-1] + 1. This is because a child with a higher rating should get more candies than its neighbor.\\n\\nWe also iterate through the ratings array from right to left. For each child, we check if its rating is higher than the rating of its right neighbor. If so, we update the value of candies[i] to the maximum of candies[i] and candies[i+1] + 1. This is because a child with a higher rating should never get fewer candies than its neighbor.\\n\\nFinally, we iterate through the candies array and add up all the elements. This gives us the total number of candies that we need to distribute.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\nThe time complexity of this solution is O(n), where n is the number of children. This is because we iterate through the ratings array twice.\\n- Space complexity:O(n)\\nThe space complexity of this solution is O(n), where n is the number of children. This is because we create a vector of size n to store the number of candies for each child.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> candies(n, 1);\\n\\n        // Iterate from left to right and update candies[i] if ratings[i] > ratings[i - 1].\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        // Iterate from right to left and update candies[i] to the maximum of candies[i] and candies[i + 1] + 1.\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\\n                candies[i] = candies[i + 1] + 1;\\n            }\\n        }\\n\\n        // Calculate the total number of candies.\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            total += candies[i];\\n        }\\n\\n        return total;\\n    }\\n};\\n\\n```\\n```\\n//java code \\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, 1);\\n\\n        // Iterate from left to right and update dp[i] if ratings[i] > ratings[i - 1].\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                dp[i] = dp[i - 1] + 1;\\n            }\\n        }\\n\\n        // Iterate from right to left and update dp[i] to the maximum of dp[i] and dp[i + 1] + 1.\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                dp[i] = Math.max(dp[i], dp[i + 1] + 1);\\n            }\\n        }\\n\\n        // Calculate the total number of candies.\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            total += dp[i];\\n        }\\n\\n        return total;\\n    }\\n}\\n```\\n```\\n//python code\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        dp = [1] * n\\n\\n        # Iterate from left to right and update dp[i] if ratings[i] > ratings[i - 1].\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1]:\\n                dp[i] = dp[i - 1] + 1\\n\\n        # Iterate from right to left and update dp[i] to the maximum of dp[i] and dp[i + 1] + 1.\\n        for i in range(n - 2, -1, -1):\\n            if ratings[i] > ratings[i + 1]:\\n                dp[i] = max(dp[i], dp[i + 1] + 1)\\n\\n        # Calculate the total number of candies.\\n        total = sum(dp)\\n\\n        return total\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> candies(n, 1);\\n\\n        // Iterate from left to right and update candies[i] if ratings[i] > ratings[i - 1].\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        // Iterate from right to left and update candies[i] to the maximum of candies[i] and candies[i + 1] + 1.\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\\n                candies[i] = candies[i + 1] + 1;\\n            }\\n        }\\n\\n        // Calculate the total number of candies.\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            total += candies[i];\\n        }\\n\\n        return total;\\n    }\\n};\\n\\n```\n```\\n//java code \\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, 1);\\n\\n        // Iterate from left to right and update dp[i] if ratings[i] > ratings[i - 1].\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                dp[i] = dp[i - 1] + 1;\\n            }\\n        }\\n\\n        // Iterate from right to left and update dp[i] to the maximum of dp[i] and dp[i + 1] + 1.\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                dp[i] = Math.max(dp[i], dp[i + 1] + 1);\\n            }\\n        }\\n\\n        // Calculate the total number of candies.\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            total += dp[i];\\n        }\\n\\n        return total;\\n    }\\n}\\n```\n```\\n//python code\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        dp = [1] * n\\n\\n        # Iterate from left to right and update dp[i] if ratings[i] > ratings[i - 1].\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1]:\\n                dp[i] = dp[i - 1] + 1\\n\\n        # Iterate from right to left and update dp[i] to the maximum of dp[i] and dp[i + 1] + 1.\\n        for i in range(n - 2, -1, -1):\\n            if ratings[i] > ratings[i + 1]:\\n                dp[i] = max(dp[i], dp[i + 1] + 1)\\n\\n        # Calculate the total number of candies.\\n        total = sum(dp)\\n\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039128,
                "title": "simple-approach-always-for-you",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*We distribute candies in two passes, ```left-to-right and right-to-left```, ensuring higher-rated children get more while meeting constraints. This approach maintains two arrays (`left` and `right`) to guarantee maximum candies for each child, satisfying both the \"at least one candy\" and \"higher than neighbors\" constraints. It minimizes the total number of candies needed.*\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n*Step-1 -> Create arrays ```left``` and ```right``` filled with 1\\'s for initial candies.\\nStep-2 -> Traverse ratings ```left to right``` and check if ```current > previous rating if so add a candy to previous``` , incrementing left for higher ratings.\\nStep-3 -> Traverse ratings ```right to left``` and check if ```current rating > next if so add a candy to next```, incrementing right for higher ratings.\\nStep-4 -> Initialize totalCandies to 0.\\nStep-5 -> Iterate arrays, adding ```max of left and right``` to totalCandies.\\nStep-6 -> Return ```totalCandies``` as the minimum total candies needed.*\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] left = new int[n];\\n        Arrays.fill(left,1);\\n        for(int i=1; i<n; i++){\\n            if(ratings[i] > ratings[i-1]) left[i] = left[i-1]+1;      \\n        }\\n        int[] right = new int[n];\\n        Arrays.fill(right,1);\\n        for(int i=n-2; i>=0; i--){\\n            if(ratings[i] > ratings[i+1]) right[i] = right[i+1]+1;\\n        }\\n        int totalCandies = 0;\\n        for(int i=0; i<n; i++){\\n            totalCandies += Math.max(left[i],right[i]);\\n        }\\n        return totalCandies;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```left-to-right and right-to-left```\n```left```\n```right```\n```left to right```\n```current > previous rating if so add a candy to previous```\n```right to left```\n```current rating > next if so add a candy to next```\n```max of left and right```\n```totalCandies```\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] left = new int[n];\\n        Arrays.fill(left,1);\\n        for(int i=1; i<n; i++){\\n            if(ratings[i] > ratings[i-1]) left[i] = left[i-1]+1;      \\n        }\\n        int[] right = new int[n];\\n        Arrays.fill(right,1);\\n        for(int i=n-2; i>=0; i--){\\n            if(ratings[i] > ratings[i+1]) right[i] = right[i+1]+1;\\n        }\\n        int totalCandies = 0;\\n        for(int i=0; i<n; i++){\\n            totalCandies += Math.max(left[i],right[i]);\\n        }\\n        return totalCandies;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038470,
                "title": "simple-java-solution-leftcandyarray-rightcandyarray",
                "content": "# Intuition\\nSimple Left Max Array and Right Max Array\\n\\n# Approach\\n1.First consider at any cost you will distrubute one candy to every child, so take left Max Array and store 1 in every index.\\n2.Next you start traversing from i=1 to N-1 and checking if the rating of before is greater than current if so you add one to the current.\\n\\nKeep in Mind that he said both the neighbhours not a single side, so we do the same for right Max Array also\\n\\nAt last we need to take max of both such that if we pick an index i then for sure if his rating is greater than his neighbours he will be getting more chocolates.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n      int N = ratings.length;\\n         int[] leftCandy = new int[N];\\n        int[] rightCandy=new int[N];\\n        Arrays.fill(leftCandy,1);\\n        Arrays.fill(rightCandy,1);\\n        for(int i=1;i<N;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                leftCandy[i]=leftCandy[i-1]+1;\\n            }\\n        }\\n        for(int i=N-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                rightCandy[i]=rightCandy[i+1]+1;\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<N;i++){\\n            res+=Math.max(leftCandy[i],rightCandy[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n      int N = ratings.length;\\n         int[] leftCandy = new int[N];\\n        int[] rightCandy=new int[N];\\n        Arrays.fill(leftCandy,1);\\n        Arrays.fill(rightCandy,1);\\n        for(int i=1;i<N;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                leftCandy[i]=leftCandy[i-1]+1;\\n            }\\n        }\\n        for(int i=N-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                rightCandy[i]=rightCandy[i+1]+1;\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<N;i++){\\n            res+=Math.max(leftCandy[i],rightCandy[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813440,
                "title": "o-n-solution-with-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& r) {\\n        int n=r.size();\\n        vector<int>c(n,1);\\n        //0 1 2 1 3\\n        if(n==1)return 1;\\n        if(r[0]>r[1])c[0]=2;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(r[i]>r[i-1] )\\n            {\\n                c[i]+=c[i-1];\\n            }\\n           \\n        }\\n        \\n         for(int i=n-2;i>=0;i--)\\n        {\\n            if(r[i]>r[i+1] && c[i]<=c[i+1] )\\n            {\\n                c[i]=max(c[i],c[i+1]+1);\\n            }\\n           \\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n          ans+=c[i];\\n         \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& r) {\\n        int n=r.size();\\n        vector<int>c(n,1);\\n        //0 1 2 1 3\\n        if(n==1)return 1;\\n        if(r[0]>r[1])c[0]=2;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(r[i]>r[i-1] )\\n            {\\n                c[i]+=c[i-1];\\n            }\\n           \\n        }\\n        \\n         for(int i=n-2;i>=0;i--)\\n        {\\n            if(r[i]>r[i+1] && c[i]<=c[i+1] )\\n            {\\n                c[i]=max(c[i],c[i+1]+1);\\n            }\\n           \\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n          ans+=c[i];\\n         \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782563,
                "title": "super-simple-solution",
                "content": "# Intuition:\\nThe approach to solving this problem involves using the concept of two passes. In the first pass, we scan the ratings from left to right and assign candies to each child based on the increasing ratings from left to right. In the second pass, we scan the ratings from right to left and adjust the candies assigned based on the increasing ratings from right to left. The idea is to ensure that each child gets at least one candy and children with higher ratings get more candies than their neighbors.\\n\\n# Algorithm:\\n\\nInitialize an array left of size n+1 to store the number of candies assigned to each child based on the increasing ratings from left to right. Set all elements of left to 1, as each child must have at least one candy.\\nPerform the first pass (left to right) over the ratings array and update the left array as follows:\\na. If the rating of the current child ratings[i] is greater than the rating of the previous child ratings[i-1], assign one more candy than the previous child to the current child (i.e., left[i] = left[i-1] + 1).\\nInitialize a variable right to 1, which will be used to keep track of the candies for the second pass (right to left).\\nPerform the second pass (right to left) over the ratings array and update the left array as follows:\\na. If the rating of the current child ratings[i] is greater than the rating of the next child ratings[i+1], we increment the right variable by 1.\\nb. We then update the number of candies for the current child by taking the maximum between the current value in the left array and the value of right. This step ensures that we consider both the left-to-right and right-to-left information while assigning candies.\\nAfter both passes are completed, sum up all the elements in the left array to get the minimum number of candies needed to satisfy the requirements.\\nComplexity Analysis:\\n\\n# Time Complexity:\\n The algorithm performs two passes through the ratings array, which takes O(n) time, where n is the number of children.\\n# Space Complexity:\\n The algorithm uses a left array of size n+1 to store the candies assigned to each child, which takes O(n) extra space.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n      vector<int> left(n+1,1);\\n      for(int i=1;i<n;i++){\\n          if(ratings[i]>ratings[i-1]) left[i]=left[i-1]+1;\\n      }  \\n\\n      int right=1;\\n      for(int i=n-2;i>=0;i--){\\n          if(ratings[i]>ratings[i+1]){\\n            right++;\\n            left[i]=max(left[i],right);\\n          }else right=1;\\n      }\\n\\n      int sum=0;\\n      for(int i=0;i<n;i++){\\n            sum+=left[i];\\n      }\\n      return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n      vector<int> left(n+1,1);\\n      for(int i=1;i<n;i++){\\n          if(ratings[i]>ratings[i-1]) left[i]=left[i-1]+1;\\n      }  \\n\\n      int right=1;\\n      for(int i=n-2;i>=0;i--){\\n          if(ratings[i]>ratings[i+1]){\\n            right++;\\n            left[i]=max(left[i],right);\\n          }else right=1;\\n      }\\n\\n      int sum=0;\\n      for(int i=0;i<n;i++){\\n            sum+=left[i];\\n      }\\n      return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649454,
                "title": "easy-c-solution-t-c-o-n-s-c-o-n",
                "content": "**Up vote if found useful**\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int> l (ratings.size(),1);\\n        vector<int> r (ratings.size(),1);\\n\\n        for(int i=1; i<ratings.size(); i++){\\n            if(ratings[i]>ratings[i-1]){\\n                l[i]=l[i-1]+1;\\n            }\\n        }\\n\\n        for(int i = ratings.size()-2; i>=0; i--){\\n            if(ratings[i+1]<ratings[i]){\\n                r[i]= r[i+1]+1;\\n            }\\n        }\\n        \\n        int sum =0;\\n        for(int i=0; i<ratings.size();i++){\\n            sum+=max(l[i],r[i]);\\n        }\\n\\n        return sum;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int> l (ratings.size(),1);\\n        vector<int> r (ratings.size(),1);\\n\\n        for(int i=1; i<ratings.size(); i++){\\n            if(ratings[i]>ratings[i-1]){\\n                l[i]=l[i-1]+1;\\n            }\\n        }\\n\\n        for(int i = ratings.size()-2; i>=0; i--){\\n            if(ratings[i+1]<ratings[i]){\\n                r[i]= r[i+1]+1;\\n            }\\n        }\\n        \\n        int sum =0;\\n        for(int i=0; i<ratings.size();i++){\\n            sum+=max(l[i],r[i]);\\n        }\\n\\n        return sum;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564844,
                "title": "using-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<vector<int>> v;//make vector for store element of rating with index and want get fist minimum rating element and give him minimum candy 1\\n        for(int i = 0; i < ratings.size(); i++){\\n            v.push_back({ratings[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        int n = ratings.size(),x = 0, k= 0;\\n        vector<int> ans(n,0);\\n        for(auto &i: v){\\n            x = 0;\\n            if(i[1]-1>=0&&ratings[i[1]]>ratings[i[1]-1]){//if ith index person have rating >= left person than he desirve more candy compare to left\\n                x = max(x,ans[i[1]-1]);\\n            }\\n            if(i[1]+1 < n&&ratings[i[1]]>ratings[i[1]+1]){//same for right.\\n                x = max(x,ans[i[1]+1]);\\n            }\\n            ans[i[1]] = x+1;//how much candy ith person get\\n            k += x+1;//total candy allocated\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<vector<int>> v;//make vector for store element of rating with index and want get fist minimum rating element and give him minimum candy 1\\n        for(int i = 0; i < ratings.size(); i++){\\n            v.push_back({ratings[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        int n = ratings.size(),x = 0, k= 0;\\n        vector<int> ans(n,0);\\n        for(auto &i: v){\\n            x = 0;\\n            if(i[1]-1>=0&&ratings[i[1]]>ratings[i[1]-1]){//if ith index person have rating >= left person than he desirve more candy compare to left\\n                x = max(x,ans[i[1]-1]);\\n            }\\n            if(i[1]+1 < n&&ratings[i[1]]>ratings[i[1]+1]){//same for right.\\n                x = max(x,ans[i[1]+1]);\\n            }\\n            ans[i[1]] = x+1;//how much candy ith person get\\n            k += x+1;//total candy allocated\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316575,
                "title": "c-90-faster-easy-and-clean-with-best-explanation",
                "content": "# Intuition\\nWe can divide this problem into 3 sub parts, that is\\n1) Incresing sequence\\n2) Decresing sequence\\n3) Sequence with same elements\\n\\nFor example:\\nSequence A with ratings - [1, 5, 10, 15, 20]\\nwe will assign candies optimisely as [1, 2, 3, 4, 5]\\n\\nSequence B with ratings - [10, 5, 3, 2, 1]\\nAssign candies as [5, 4, 3, 2, 1]\\n\\nSequence C with ratings - [5, 5, 5, 5]\\nAssign candies as [1, 1, 1, 1]\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int> count(ratings.size(), 1);\\n\\n        int i=0, j=0;\\n        while(j < ratings.size()-1){\\n            if(ratings[j] < ratings[j+1]){\\n                while(j < ratings.size()-1 && ratings[j] < ratings[j+1]){\\n                    j++;\\n                }\\n\\n                int num = 1;\\n\\n                for(int k=i; k<=j; k++){\\n                    count[k] = max(count[k], num);\\n                    num++;\\n                }\\n\\n                i = j;\\n            }\\n            else if(ratings[j] > ratings[j+1]){\\n                while(j < ratings.size()-1 && ratings[j] > ratings[j+1]){\\n                    j++;\\n                }\\n\\n                int num = 1;\\n\\n                for(int k=j; k>=i; k--){\\n                    count[k] = max(count[k], num);\\n                    num++;\\n                }\\n\\n                i = j;\\n            }\\n            else{\\n                while(j < ratings.size()-1 && ratings[j] == ratings[j+1]){\\n                    j++;\\n                }\\n\\n                i = j;\\n            }\\n        }\\n        \\n\\n        int ans = 0;\\n        for(auto i : count){\\n            ans += i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int> count(ratings.size(), 1);\\n\\n        int i=0, j=0;\\n        while(j < ratings.size()-1){\\n            if(ratings[j] < ratings[j+1]){\\n                while(j < ratings.size()-1 && ratings[j] < ratings[j+1]){\\n                    j++;\\n                }\\n\\n                int num = 1;\\n\\n                for(int k=i; k<=j; k++){\\n                    count[k] = max(count[k], num);\\n                    num++;\\n                }\\n\\n                i = j;\\n            }\\n            else if(ratings[j] > ratings[j+1]){\\n                while(j < ratings.size()-1 && ratings[j] > ratings[j+1]){\\n                    j++;\\n                }\\n\\n                int num = 1;\\n\\n                for(int k=j; k>=i; k--){\\n                    count[k] = max(count[k], num);\\n                    num++;\\n                }\\n\\n                i = j;\\n            }\\n            else{\\n                while(j < ratings.size()-1 && ratings[j] == ratings[j+1]){\\n                    j++;\\n                }\\n\\n                i = j;\\n            }\\n        }\\n        \\n\\n        int ans = 0;\\n        for(auto i : count){\\n            ans += i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029049,
                "title": "my-very-first-solution-contribution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy very first solution contribution, based on my Python solution\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInstead of using loop twice, to solve 3 cases happened between ratings[i] and ratings[i-1]:\\n- ratings[i]==ratings[i-1]: new start, because no condition\\n- ratings[i]>ratings[i-1]: increase, and record the maximum\\n- ratings[i]<ratings[i-1]: add 1 at new position, but be careful for the violation:\\n    a. The candies from previous maximum index to the i-1th should increase by 1 to maintain the relation\\n    b. The candies from 1+previous maximum index should increase by 1.\\nI created 3 variables for curr candy (val), index of previous \\'peak\\' (maxIdx) and number of candies at the previous peak (maxVal)\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int Candy(int[] ratings) {\\n        int maxVal = 1;\\n        int val = 1;\\n        int ans = 1;\\n        int maxIdx = 0;\\n        for(int i = 1; i<ratings.Length;i++){\\n            if(ratings[i]> ratings[i-1]){\\n                ++val;\\n                ans += val;\\n                maxIdx = i;\\n                maxVal = val;\\n            }\\n            else if(ratings[i] < ratings[i-1]) {\\n                val = 1;\\n                ans+= i - maxIdx;\\n                if (i - maxIdx == maxVal) {\\n                    maxVal+=1;\\n                    ans+=1;\\n                }\\n            }\\n            else {\\n                maxVal = 1;\\n                val =1;\\n                maxIdx = i;\\n                ans +=1;\\n            }\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int Candy(int[] ratings) {\\n        int maxVal = 1;\\n        int val = 1;\\n        int ans = 1;\\n        int maxIdx = 0;\\n        for(int i = 1; i<ratings.Length;i++){\\n            if(ratings[i]> ratings[i-1]){\\n                ++val;\\n                ans += val;\\n                maxIdx = i;\\n                maxVal = val;\\n            }\\n            else if(ratings[i] < ratings[i-1]) {\\n                val = 1;\\n                ans+= i - maxIdx;\\n                if (i - maxIdx == maxVal) {\\n                    maxVal+=1;\\n                    ans+=1;\\n                }\\n            }\\n            else {\\n                maxVal = 1;\\n                val =1;\\n                maxIdx = i;\\n                ans +=1;\\n            }\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641180,
                "title": "solution-using-multi-source-bfs-idk-why",
                "content": "Approach: \\n1) Start with the positions that are smaller than both their neighbors and add this to a set.\\n2) Then loop until this set has elements and for each iteration add the neighbor for the positions in the set that have a higher rating. At each iteration the number of candies for a position increments by 1 (shown in code by variable curr). \\n```\\nclass Solution(object):\\n    def candy(self, ratings):\\n        \"\"\"\\n        :type ratings: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(ratings)\\n        if n == 1:\\n            return 1\\n        \\n\\t\\t#stores the elements that are smaller than both its neighbors\\n        s = set()\\n        \\n        if ratings[0] <= ratings[1]:\\n            s.add(0) # first position\\n            \\n        if ratings[n-1] <= ratings[n-2]:\\n            s.add(n-1) # last position \\n        \\n        for i in range(1, n-1):\\n            if ratings[i] <= ratings[i-1] and ratings[i] <= ratings[i+1]:\\n                s.add(i) # everything in between\\n  \\n        curr = 0\\n        count = [1] * n # start with everyone having one candy\\n        \\n        while s:\\n            curr += 1\\n            ns = set()\\n            \\n            for i in s:\\n                count[i] = curr\\n                if i != 0 and ratings[i-1] > ratings[i]:\\n                    ns.add(i-1) # add left neighbor if it is greater\\n                if i != n-1 and ratings[i+1] > ratings[i]:\\n                    ns.add(i+1) # add right neighbor if it is greater\\n            s = ns\\n            \\n        return sum(count)```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def candy(self, ratings):\\n        \"\"\"\\n        :type ratings: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(ratings)\\n        if n == 1:\\n            return 1\\n        \\n\\t\\t#stores the elements that are smaller than both its neighbors\\n        s = set()\\n        \\n        if ratings[0] <= ratings[1]:\\n            s.add(0) # first position\\n            \\n        if ratings[n-1] <= ratings[n-2]:\\n            s.add(n-1) # last position \\n        \\n        for i in range(1, n-1):\\n            if ratings[i] <= ratings[i-1] and ratings[i] <= ratings[i+1]:\\n                s.add(i) # everything in between\\n  \\n        curr = 0\\n        count = [1] * n # start with everyone having one candy\\n        \\n        while s:\\n            curr += 1\\n            ns = set()\\n            \\n            for i in s:\\n                count[i] = curr\\n                if i != 0 and ratings[i-1] > ratings[i]:\\n                    ns.add(i-1) # add left neighbor if it is greater\\n                if i != n-1 and ratings[i+1] > ratings[i]:\\n                    ns.add(i+1) # add right neighbor if it is greater\\n            s = ns\\n            \\n        return sum(count)```",
                "codeTag": "Java"
            },
            {
                "id": 2237293,
                "title": "c-yt-link-easy-explanation",
                "content": "https://www.youtube.com/watch?v=PzBYQA6FshA\\n\\n\\tc++ code\\n\\t\\n\\t\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint candy(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<int> left(n, 1);\\n\\t\\t\\tvector<int> right(n, 1);\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]>nums[i-1])left[i]=left[i-1]+1;\\n\\t\\t\\t}\\n\\t\\t\\t for(int i=n-2;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]>nums[i+1])right[i]=right[i+1]+1;\\n\\t\\t\\t}       \\n\\t\\t\\tint s=0;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t   s+=max(left[i],right[i]);\\n\\t\\t\\t}\\n\\t\\t   return s;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint candy(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<int> left(n, 1);\\n\\t\\t\\tvector<int> right(n, 1);\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]>nums[i-1])left[i]=left[i-1]+1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2235576,
                "title": "very-easy-c-sol-o-n-sol-using-single-array",
                "content": "int n=nums.size();\\n        \\n        vector<int>ans(n,1);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>nums[i-1] )\\n            {\\n                ans[i]=ans[i-1]+1;\\n                \\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]>nums[i+1] and ans[i]<=ans[i+1])\\n            {\\n                ans[i]=ans[i+1]+1;\\n            }\\n        }\\n        int sum=0;\\n        for(auto itr:ans)\\n        {\\n            sum+=itr;\\n        }\\n        \\n        return sum;",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Greedy"
                ],
                "code": "int n=nums.size();\\n        \\n        vector<int>ans(n,1);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>nums[i-1] )\\n            {\\n                ans[i]=ans[i-1]+1;\\n                \\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]>nums[i+1] and ans[i]<=ans[i+1])\\n            {\\n                ans[i]=ans[i+1]+1;\\n            }\\n        }\\n        int sum=0;\\n        for(auto itr:ans)\\n        {\\n            sum+=itr;\\n        }\\n        \\n        return sum;",
                "codeTag": "Unknown"
            },
            {
                "id": 2235548,
                "title": "easy-to-understand-solution-with-explanation",
                "content": "## **Problem**: \\nWe are given a vector of integer, ratings which contain ratings of \\'n\\' children standing in a line. We have to distribute candies to these children such that the total number of candies distributed are minimum. We have to consider the following conditions while distributing:\\n* Each child must recieve atleast 1 candy.\\n* The child with higher rating than his neighbours, must recieve more candies than them.\\n\\n## **Approach**:\\nWe will take a vector of integer, candies, of size \\'n\\' and initialize all values with \\'1\\'. Then we would check whether the size of ratings, i.e., the number of children is less than or equal to 1, in which case, we would return the size itself.\\n\\nThen we will run a loop from 1 till n, where we will check if the rating of the current child is greater than the previous one, if yes, we would set the value of candies with the child as 1 more than the candies with the previous one.\\n\\nWe would then run a loop from n-1, i.e., the last child till i is greater than 0, and we would check if the previous, i.e., i-1 has more rating than i, then we would set value of i-1th one as, the maximum of increment of ith one and his own candies.\\n\\nFinally, we have assigned the candies to be distributed to each child, now we would just run an iteration for each child and add the number of candies to total number of candies.\\n\\nAnd we will return the total candies.\\n\\n## **Solution**:\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size(); //total number of children\\n        int totalcandies = 0; //set total candies as 0\\n        \\n        if(n<=1) //check if the number of children are 1 or less\\n            return n;\\n        \\n        vector<int> candies(n,1); // initialize a vector candies with 1 of size n\\n        for(int i=1;i<n;i++)\\n            if(ratings[i]>ratings[i-1]) //if the current child\\'s rating is more than the previous one\\n                candies[i]=candies[i-1]+1; //set his candies as 1 more than the previous one\\n        \\n        for(int i=n-1;i>0;i--)\\n            if(ratings[i-1]>ratings[i]) //if the i-1th child has more rating than ith one\\n                candies[i-1]=max(candies[i-1],candies[i]+1); //set the i-1th candies as maximum of his own and 1 more than the previous one\\n        \\n        for(int i=0;i<n;i++)\\n            totalcandies+=candies[i]; //add each child\\'s number of candies to the total\\n        \\n        return totalcandies; //return the total number of candies\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size(); //total number of children\\n        int totalcandies = 0; //set total candies as 0\\n        \\n        if(n<=1) //check if the number of children are 1 or less\\n            return n;\\n        \\n        vector<int> candies(n,1); // initialize a vector candies with 1 of size n\\n        for(int i=1;i<n;i++)\\n            if(ratings[i]>ratings[i-1]) //if the current child\\'s rating is more than the previous one\\n                candies[i]=candies[i-1]+1; //set his candies as 1 more than the previous one\\n        \\n        for(int i=n-1;i>0;i--)\\n            if(ratings[i-1]>ratings[i]) //if the i-1th child has more rating than ith one\\n                candies[i-1]=max(candies[i-1],candies[i]+1); //set the i-1th candies as maximum of his own and 1 more than the previous one\\n        \\n        for(int i=0;i<n;i++)\\n            totalcandies+=candies[i]; //add each child\\'s number of candies to the total\\n        \\n        return totalcandies; //return the total number of candies\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235182,
                "title": "c-o-n-time-o-n-space-easy-brute-force-solution-with-explanation",
                "content": "1. traverse towards towards left-right then towards right-left\\n 2. if not understood why dry run this testcase once 1 2 87 87 87 2 1\\n```\\nint candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        if(n==1) return 1;\\n        vector<int> ans(n,1);\\n        //firsly traverse owards right\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==0 && ratings[i]>ratings[i+1])\\n            {\\n                ans[i]=ans[i+1]+1;\\n            }\\n            else if(i>0 && i<n-1)\\n            {\\n                if(ratings[i]>ratings[i-1] && ratings[i]>ratings[i+1])\\n                {\\n                    ans[i]=max(ans[i+1],ans[i-1])+1;\\n                }\\n                else if(ratings[i]>ratings[i-1])\\n                {\\n                    ans[i]=ans[i-1]+1;\\n                }\\n                else if(ratings[i]>ratings[i+1] )\\n                {\\n                    ans[i]=ans[i+1]+1;\\n                }\\n            }\\n            else if(i==n-1)\\n            {\\n                if(ratings[i]>ratings[i-1])\\n                {\\n                    ans[i]=ans[i-1]+1;\\n                }\\n            }\\n        }\\n        \\n\\t\\t//then traverse towards left\\n\\t\\t\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i==0 && ratings[i]>ratings[i+1])\\n            {\\n                ans[i]=ans[i+1]+1;\\n            }\\n            else if(i>0 && i<n-1)\\n            {\\n                if(ratings[i]>ratings[i-1] && ratings[i]>ratings[i+1])\\n                {\\n                    ans[i]=max(ans[i+1],ans[i-1])+1;\\n                }\\n                else if(ratings[i]>ratings[i-1])\\n                {\\n                    ans[i]=ans[i-1]+1;\\n                }\\n                else if(ratings[i]>ratings[i+1] )\\n                {\\n                    ans[i]=ans[i+1]+1;\\n                }\\n            }\\n            else if(i==n-1)\\n            {\\n                if(ratings[i]>ratings[i-1])\\n                {\\n                    ans[i]=ans[i-1]+1;\\n                }\\n            }\\n        }\\n       \\n       \\n        int res=accumulate(ans.begin(),ans.end(),0);\\n        return res;\\n    }\\n\\t\\t```\\n\\t\\tif you have reached there then you would have probably understood the solution , So\\n\\t\\t**upvote please**\\n\\t\\t",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nint candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        if(n==1) return 1;\\n        vector<int> ans(n,1);\\n        //firsly traverse owards right\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==0 && ratings[i]>ratings[i+1])\\n            {\\n                ans[i]=ans[i+1]+1;\\n            }\\n            else if(i>0 && i<n-1)\\n            {\\n                if(ratings[i]>ratings[i-1] && ratings[i]>ratings[i+1])\\n                {\\n                    ans[i]=max(ans[i+1],ans[i-1])+1;\\n                }\\n                else if(ratings[i]>ratings[i-1])\\n                {\\n                    ans[i]=ans[i-1]+1;\\n                }\\n                else if(ratings[i]>ratings[i+1] )\\n                {\\n                    ans[i]=ans[i+1]+1;\\n                }\\n            }\\n            else if(i==n-1)\\n            {\\n                if(ratings[i]>ratings[i-1])\\n                {\\n                    ans[i]=ans[i-1]+1;\\n                }\\n            }\\n        }\\n        \\n\\t\\t//then traverse towards left\\n\\t\\t\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i==0 && ratings[i]>ratings[i+1])\\n            {\\n                ans[i]=ans[i+1]+1;\\n            }\\n            else if(i>0 && i<n-1)\\n            {\\n                if(ratings[i]>ratings[i-1] && ratings[i]>ratings[i+1])\\n                {\\n                    ans[i]=max(ans[i+1],ans[i-1])+1;\\n                }\\n                else if(ratings[i]>ratings[i-1])\\n                {\\n                    ans[i]=ans[i-1]+1;\\n                }\\n                else if(ratings[i]>ratings[i+1] )\\n                {\\n                    ans[i]=ans[i+1]+1;\\n                }\\n            }\\n            else if(i==n-1)\\n            {\\n                if(ratings[i]>ratings[i-1])\\n                {\\n                    ans[i]=ans[i-1]+1;\\n                }\\n            }\\n        }\\n       \\n       \\n        int res=accumulate(ans.begin(),ans.end(),0);\\n        return res;\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2235181,
                "title": "simple-o-n-python-solution-faster-than-99-with-explanation",
                "content": "**In Short :**\\nSplit ratings array to multi **strictly decreasing** sub ratings, and update candy with each sub ratings(suppose to be like n, n-1, ......, 2, 1) base on length and the last candy from last sub ratings .\\n\\n**Detail :**\\nWe have three cases :  current rating  (\\'>\\'  , \\'=\\'  , \\'<\\' )  last rating\\n\\nIf is greater, then we simply take last candy + 1.\\nif is equal, then we set candy to 1.\\nIf is less, then we set candy to 1, however if the last candy is also 1,  we have to update the last candy to 2, since the last rating is greater.\\nWe need to keep updating former candy to make sure higher rating get more candy. After finish all update we can find out the candy we updated is a sequence like n, n-1, ......, 2, 1 or n-1, ......, 2, 1. (depends on whether we update the head of current strictly decreasing sub ratings and n is the number of strictly decreasing sub ratings)\\n\\ntake ratings : [1,2,4,3,2,1] as example \\n\\n![image](https://assets.leetcode.com/users/images/f7cae0dd-1835-44d8-8bd1-fd98245f7315_1656912730.3116095.png)\\n![image](https://assets.leetcode.com/users/images/eacdb5d5-72b1-4318-afb5-d4dedd68953f_1656912740.543344.png)\\n![image](https://assets.leetcode.com/users/images/791024f9-503e-41fc-acb1-9af3e46b41f9_1656912749.0252995.png)\\n![image](https://assets.leetcode.com/users/images/ede5c705-b8f8-4014-9403-c8abb76a06e1_1656912758.5754123.png)\\n![image](https://assets.leetcode.com/users/images/516a20aa-43c1-43fa-a707-7da05604bde9_1656912765.297426.png)\\n\\nWe can have some observations from above.( taking sc as the start of current strictly decreasing sub ratings)\\n1. Update candy to the sc at most.\\n2. Sc\\'s candy only update if the length of strictly decreasing sub ratings is  >  Sc\\'s candy.\\n\\nSo we can maintin a stack to keep track on strictly decreasing sub ratings, and update the candy after we get a new strictly decreasing sub ratings. \\n(in fact we can calculate total candy for every sub ratings thus we can reduce space complexity to O(1))\\n\\t\\n\\tdef candy(self, ratings: List[int]) -> int:\\n        #make sure last stack is calculated \\n        ratings.append(float(\\'inf\\'))\\n\\n        #default set candy to 1\\n        candy = [1] * len(ratings)\\n\\n        #stack init with index 0\\n        stack_startindex, stack_leftcandy, stack_count  = 0, 1, 1\\n\\n        for i in range(1, len(ratings)) :\\n\\n            #if rating is greater or equal : start new stack and update candy for old stack\\n            if ratings[i] >= ratings[i-1] :\\n\\n                #set candy to n, n-1, ......, 1 in the stack\\n                if stack_count > stack_leftcandy :\\n                    for j in range(stack_startindex, i) :\\n                        candy[j] = stack_count \\n                        stack_count -= 1\\n\\n                #set candy to k(leftcandy), n, n-1, ......, 1 in the stack \\n                else :\\n                    for j in range(stack_startindex+1, i) :\\n                        candy[j] = stack_count-1 \\n                        stack_count -= 1\\n\\n                #set current candy to left + 1 if rating is greater\\n                #set current candy to 1 if rating is equal\\n                if ratings[i] > ratings[i-1] : candy[i] = candy[i-1] + 1\\n                else : candy[i] = 1\\n\\n                #init new stack start from i\\n                stack_startindex, stack_leftcandy, stack_count = i, candy[i], 1\\n\\n            #if rating is less : update stack count\\n            else : stack_count += 1\\n\\n        #sum all candy except the last one we added first\\n        return sum(candy[:-1])\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "**In Short :**\\nSplit ratings array to multi **strictly decreasing** sub ratings, and update candy with each sub ratings(suppose to be like n, n-1, ......, 2, 1) base on length and the last candy from last sub ratings .\\n\\n**Detail :**\\nWe have three cases :  current rating  (\\'>\\'  , \\'=\\'  , \\'<\\' )  last rating\\n\\nIf is greater, then we simply take last candy + 1.\\nif is equal, then we set candy to 1.\\nIf is less, then we set candy to 1, however if the last candy is also 1,  we have to update the last candy to 2, since the last rating is greater.\\nWe need to keep updating former candy to make sure higher rating get more candy. After finish all update we can find out the candy we updated is a sequence like n, n-1, ......, 2, 1 or n-1, ......, 2, 1. (depends on whether we update the head of current strictly decreasing sub ratings and n is the number of strictly decreasing sub ratings)\\n\\ntake ratings : [1,2,4,3,2,1] as example \\n\\n![image](https://assets.leetcode.com/users/images/f7cae0dd-1835-44d8-8bd1-fd98245f7315_1656912730.3116095.png)\\n![image](https://assets.leetcode.com/users/images/eacdb5d5-72b1-4318-afb5-d4dedd68953f_1656912740.543344.png)\\n![image](https://assets.leetcode.com/users/images/791024f9-503e-41fc-acb1-9af3e46b41f9_1656912749.0252995.png)\\n![image](https://assets.leetcode.com/users/images/ede5c705-b8f8-4014-9403-c8abb76a06e1_1656912758.5754123.png)\\n![image](https://assets.leetcode.com/users/images/516a20aa-43c1-43fa-a707-7da05604bde9_1656912765.297426.png)\\n\\nWe can have some observations from above.( taking sc as the start of current strictly decreasing sub ratings)\\n1. Update candy to the sc at most.\\n2. Sc\\'s candy only update if the length of strictly decreasing sub ratings is  >  Sc\\'s candy.\\n\\nSo we can maintin a stack to keep track on strictly decreasing sub ratings, and update the candy after we get a new strictly decreasing sub ratings. \\n(in fact we can calculate total candy for every sub ratings thus we can reduce space complexity to O(1))\\n\\t\\n\\tdef candy(self, ratings: List[int]) -> int:\\n        #make sure last stack is calculated \\n        ratings.append(float(\\'inf\\'))\\n\\n        #default set candy to 1\\n        candy = [1] * len(ratings)\\n\\n        #stack init with index 0\\n        stack_startindex, stack_leftcandy, stack_count  = 0, 1, 1\\n\\n        for i in range(1, len(ratings)) :\\n\\n            #if rating is greater or equal : start new stack and update candy for old stack\\n            if ratings[i] >= ratings[i-1] :\\n\\n                #set candy to n, n-1, ......, 1 in the stack\\n                if stack_count > stack_leftcandy :\\n                    for j in range(stack_startindex, i) :\\n                        candy[j] = stack_count \\n                        stack_count -= 1\\n\\n                #set candy to k(leftcandy), n, n-1, ......, 1 in the stack \\n                else :\\n                    for j in range(stack_startindex+1, i) :\\n                        candy[j] = stack_count-1 \\n                        stack_count -= 1\\n\\n                #set current candy to left + 1 if rating is greater\\n                #set current candy to 1 if rating is equal\\n                if ratings[i] > ratings[i-1] : candy[i] = candy[i-1] + 1\\n                else : candy[i] = 1\\n\\n                #init new stack start from i\\n                stack_startindex, stack_leftcandy, stack_count = i, candy[i], 1\\n\\n            #if rating is less : update stack count\\n            else : stack_count += 1\\n\\n        #sum all candy except the last one we added first\\n        return sum(candy[:-1])\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2235027,
                "title": "unique-solution-using-sorting",
                "content": "Question - \\n**You are giving candies to these children subjected to the following requirements:**\\n\\n- Each child must have at least one candy.\\n- Children with a higher rating get more candies than their neighbors.\\n\\nSo I thought, we can distribute candies to student with minimum ratings first, and if nearby childrens have candies, and they have lower rating than current student then we will take max of (1, 1 + candy on left, 1 + candy on right) for the current student\\n\\nBut you might think what if we haven\\'t yet assigned the candy to neighbor childrens??\\n- It will not happen as we are going in sorted order of rating. \\n- So, if we are at some rating **x+1** and neaby childrens have rating **x**, it would have been already filled. \\n- And if rating of nearby children is higher, then we just assign 1 candy to this student.\\n\\n```\\n    int candy(vector<int>& ratings) {\\n        vector<pair<int,int>> vec;\\n        int n = ratings.size();\\n        vec.reserve(n);\\n        \\n        for(int i = 0; i<n; i++){\\n            vec.push_back({ratings[i], i});\\n        }\\n        \\n        sort(vec.begin(), vec.end());\\n        vector<int> candy(n, 0);\\n        int ans = 0;\\n        \\n        for(int i = 0; i<n; i++){\\n            int rating = vec[i].first;\\n            int ind = vec[i].second;\\n            \\n            int candies = 1;\\n            if(ind > 0 && ratings[ind] > ratings[ind-1]){\\n                candies = max(candies, candy[ind-1] + 1);\\n            }\\n            if(ind < n-1 && ratings[ind] > ratings[ind+1]){\\n                candies = max(candies, candy[ind+1] + 1);\\n            }\\n            ans += candies;\\n            candy[ind] = candies;\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nI know there is a better complexity solution in *O(N) time*.\\nJust thought to share a different approach. :)\\n\\n\\nT.C. -> O(nlogn)\\nS.C. -> O(n)\\n\\nIf something is not understood you can comment below \\uD83D\\uDC47\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n    int candy(vector<int>& ratings) {\\n        vector<pair<int,int>> vec;\\n        int n = ratings.size();\\n        vec.reserve(n);\\n        \\n        for(int i = 0; i<n; i++){\\n            vec.push_back({ratings[i], i});\\n        }\\n        \\n        sort(vec.begin(), vec.end());\\n        vector<int> candy(n, 0);\\n        int ans = 0;\\n        \\n        for(int i = 0; i<n; i++){\\n            int rating = vec[i].first;\\n            int ind = vec[i].second;\\n            \\n            int candies = 1;\\n            if(ind > 0 && ratings[ind] > ratings[ind-1]){\\n                candies = max(candies, candy[ind-1] + 1);\\n            }\\n            if(ind < n-1 && ratings[ind] > ratings[ind+1]){\\n                candies = max(candies, candy[ind+1] + 1);\\n            }\\n            ans += candies;\\n            candy[ind] = candies;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2234593,
                "title": "4ms-java-solution-greedy-approach",
                "content": "**Time Complexity: O(N)**\\n\\n**```Java Code```**\\n\\n```\\nimport java.util.*;  \\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int size = ratings.length;\\n        int[] left = new int[size];\\n        int[] right = new int[size];\\n        left[0] = 1;\\n        right[size-1] = 1;\\n        for(int i = 1; i < size; i++){\\n            if(ratings[i] > ratings[i - 1])\\n                left[i] = left[i - 1] + 1;\\n            else \\n                left[i] = 1;\\n        }\\n        \\n        for(int i = size - 2; i >= 0; i--){\\n            if(ratings[i] > ratings[i + 1])\\n                right[i] = right[i + 1] + 1;\\n            else \\n                right[i] = 1;\\n        }\\n        \\n        int answer = 0;\\n        for(int i = 0; i < size; i++){\\n            answer+=Math.max(left[i], right[i]);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```Java Code```\n```\\nimport java.util.*;  \\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int size = ratings.length;\\n        int[] left = new int[size];\\n        int[] right = new int[size];\\n        left[0] = 1;\\n        right[size-1] = 1;\\n        for(int i = 1; i < size; i++){\\n            if(ratings[i] > ratings[i - 1])\\n                left[i] = left[i - 1] + 1;\\n            else \\n                left[i] = 1;\\n        }\\n        \\n        for(int i = size - 2; i >= 0; i--){\\n            if(ratings[i] > ratings[i + 1])\\n                right[i] = right[i + 1] + 1;\\n            else \\n                right[i] = 1;\\n        }\\n        \\n        int answer = 0;\\n        for(int i = 0; i < size; i++){\\n            answer+=Math.max(left[i], right[i]);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187052,
                "title": "simple-solution-using-min-heap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> ans(n,1);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> qe;\\n        for(int i = 0 ; i < n ; i++){\\n            qe.push({ratings[i],i});\\n        }\\n        while(!qe.empty()){\\n            auto it = qe.top();\\n            qe.pop();\\n            if(it.second > 0 && ratings[it.second-1] > ratings[it.second])\\n                ans[it.second-1] = max(ans[it.second-1],ans[it.second]+1);\\n            if(it.second < n-1 && ratings[it.second+1] > ratings[it.second])\\n                ans[it.second+1] = max(ans[it.second+1],ans[it.second]+1);\\n        }\\n        int x = 0;\\n        for(auto &it : ans)\\n            x += it;\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> ans(n,1);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> qe;\\n        for(int i = 0 ; i < n ; i++){\\n            qe.push({ratings[i],i});\\n        }\\n        while(!qe.empty()){\\n            auto it = qe.top();\\n            qe.pop();\\n            if(it.second > 0 && ratings[it.second-1] > ratings[it.second])\\n                ans[it.second-1] = max(ans[it.second-1],ans[it.second]+1);\\n            if(it.second < n-1 && ratings[it.second+1] > ratings[it.second])\\n                ans[it.second+1] = max(ans[it.second+1],ans[it.second]+1);\\n        }\\n        int x = 0;\\n        for(auto &it : ans)\\n            x += it;\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300298,
                "title": "c-simple-approach-o-n-easy-to-undersatand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int> num(ratings.size(),1);\\n //  if only one element then just return the size\\n        \\n        if(ratings.size()<=1)\\n            return ratings.size();\\n        \\n       /* The first loop makes sure children with a higher rating get more candy than its left neighbor \\n       */   \\n        \\n        for(int i=0;i<ratings.size()-1;i++)\\n        {\\n            if(ratings[i]<ratings[i+1])\\n                num[i+1]=num[i]+1;\\n        }\\n        \\n      /*  the second loop makes sure children with a higher rating get more candy than its right neighbor\\n      to increase */\\n        \\n        for(int i=ratings.size()-1;i>0;i--)\\n        {\\n            if(ratings[i-1]>ratings[i])\\n                // make sure that the increase in candies is minimum\\n                num[i-1]=max(num[i]+1,num[i-1]); \\n        }\\n        /*   sum the array formed and return it  \\n        */\\n        return accumulate(num.begin(),num.end(),0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int> num(ratings.size(),1);\\n //  if only one element then just return the size\\n        \\n        if(ratings.size()<=1)\\n            return ratings.size();\\n        \\n       /* The first loop makes sure children with a higher rating get more candy than its left neighbor \\n       */   \\n        \\n        for(int i=0;i<ratings.size()-1;i++)\\n        {\\n            if(ratings[i]<ratings[i+1])\\n                num[i+1]=num[i]+1;\\n        }\\n        \\n      /*  the second loop makes sure children with a higher rating get more candy than its right neighbor\\n      to increase */\\n        \\n        for(int i=ratings.size()-1;i>0;i--)\\n        {\\n            if(ratings[i-1]>ratings[i])\\n                // make sure that the increase in candies is minimum\\n                num[i-1]=max(num[i]+1,num[i-1]); \\n        }\\n        /*   sum the array formed and return it  \\n        */\\n        return accumulate(num.begin(),num.end(),0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743469,
                "title": "simple-bfs",
                "content": "Idea: \\n1. Find the worst-rated children and start with them\\n2. For Each worst child, give them just one candy (c)\\n3. For each of neighbour, \\n\\t- If they have a  higher rating, give them c + 1 candies\\n\\t- Otherwise give them 1 candy\\n4. If ever there is a conflict, round up.\\n\\nThe code is a straightforward breadth-first search. O(n) space and time. \\n\\n```\\nvar candy = function(ratings) {\\n    \\n    const result = new Array(ratings.length).fill(0);\\n    const min = Math.min(...ratings, 0);\\n\\n    const q = [];\\n    ratings.forEach((r, i) => {\\n        if(r === min) q.push([i, 1]);\\n    });\\n    \\n    while(q.length){    \\n        const [index, candies] = q.shift();\\n        \\n        if(result[index] < candies) result[index] = candies;\\n        else continue;\\n        \\n        if(index > 0){\\n            const left = index - 1;\\n            const leftCandy = ratings[left] > ratings[index] ? (candies+1) : 1;\\n            if(leftCandy > result[left]) q.push([left, leftCandy]);\\n        }\\n        \\n        if(index < ratings.length-1){\\n            const right = index + 1;\\n            const rightCandy = ratings[right] > ratings[index] ? (candies+1) : 1;\\n            if(rightCandy > result[right]) q.push([right, rightCandy]);\\n        }\\n    }\\n    \\n    return result.reduce((a, b) => a + b, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nvar candy = function(ratings) {\\n    \\n    const result = new Array(ratings.length).fill(0);\\n    const min = Math.min(...ratings, 0);\\n\\n    const q = [];\\n    ratings.forEach((r, i) => {\\n        if(r === min) q.push([i, 1]);\\n    });\\n    \\n    while(q.length){    \\n        const [index, candies] = q.shift();\\n        \\n        if(result[index] < candies) result[index] = candies;\\n        else continue;\\n        \\n        if(index > 0){\\n            const left = index - 1;\\n            const leftCandy = ratings[left] > ratings[index] ? (candies+1) : 1;\\n            if(leftCandy > result[left]) q.push([left, leftCandy]);\\n        }\\n        \\n        if(index < ratings.length-1){\\n            const right = index + 1;\\n            const rightCandy = ratings[right] > ratings[index] ? (candies+1) : 1;\\n            if(rightCandy > result[right]) q.push([right, rightCandy]);\\n        }\\n    }\\n    \\n    return result.reduce((a, b) => a + b, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 636991,
                "title": "simple-python-solution-runtime-o-n",
                "content": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        \\n        left=[1]*(len(ratings))\\n        right=[1]*len(ratings)\\n        \\n        for i in range(1,len(ratings)):\\n            if ratings[i]>ratings[i-1]:\\n                left[i]=left[i-1]+1\\n            \\n        for i in range(len(ratings)-2, -1,-1):\\n            if ratings[i]>ratings[i+1]:\\n                right[i]=right[i+1]+1\\n        \\n        total=[0]*len(ratings)\\n        for i in range(len(ratings)):\\n            total[i]=max(left[i], right[i])\\n        \\n        return sum(total)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        \\n        left=[1]*(len(ratings))\\n        right=[1]*len(ratings)\\n        \\n        for i in range(1,len(ratings)):\\n            if ratings[i]>ratings[i-1]:\\n                left[i]=left[i-1]+1\\n            \\n        for i in range(len(ratings)-2, -1,-1):\\n            if ratings[i]>ratings[i+1]:\\n                right[i]=right[i+1]+1\\n        \\n        total=[0]*len(ratings)\\n        for i in range(len(ratings)):\\n            total[i]=max(left[i], right[i])\\n        \\n        return sum(total)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326395,
                "title": "c-98-beat-o-n-speed-o-n-space-intuitive-solution",
                "content": "\\nDraw it out on paper.\\n\\n[2, 1, 1, 2, 3, 2, 3, 4, 0, 0, 1]\\n\\nHow many candies can be distribute? Manually plug in the values.\\n\\n[2, 1, 1, 2, 3, 1, 2, 3, 1, 1, 2]\\n\\nNotice that the numbers are influences by how many in a row are either ascending or descending.\\n\\nLike, [1, 5, 7, 8, 100] Would requre a distribution which was [1, 2, 3, 4, 5]\\n\\nAnd [100, 8, 7, 5, 1] Would requre a distribution which was [5, 4, 3, 2, 1]\\n\\nThrough inspection, we can see that the correct answer for each array slot is the max of these two values (ascending or descending).\\n\\nThis is how I figured it out. \\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        \\n        int aCount = ratings.size();\\n        \\n        int aAscend[aCount + 1];\\n        int aStreak = 1;\\n        aAscend[0] = 1;\\n        for (int i=1;i<aCount;i++) {\\n            if (ratings[i - 1] < ratings[i]) {\\n                ++aStreak;\\n            } else {\\n                aStreak = 1;\\n            }\\n            aAscend[i] = aStreak;\\n        }\\n        \\n        int aDescend[aCount + 1];\\n        aDescend[aCount - 1] = 1;\\n        aStreak = 1;\\n        for (int i=aCount-2;i>=0;i--) {\\n            if (ratings[i + 1] < ratings[i]) {\\n                ++aStreak;\\n            } else {\\n                aStreak = 1;\\n            }\\n            aDescend[i] = aStreak;\\n        }\\n        \\n        int aResult = 0;\\n        \\n        for (int i=0;i<aCount;i++) {\\n            aResult += max(aAscend[i], aDescend[i]);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        \\n        int aCount = ratings.size();\\n        \\n        int aAscend[aCount + 1];\\n        int aStreak = 1;\\n        aAscend[0] = 1;\\n        for (int i=1;i<aCount;i++) {\\n            if (ratings[i - 1] < ratings[i]) {\\n                ++aStreak;\\n            } else {\\n                aStreak = 1;\\n            }\\n            aAscend[i] = aStreak;\\n        }\\n        \\n        int aDescend[aCount + 1];\\n        aDescend[aCount - 1] = 1;\\n        aStreak = 1;\\n        for (int i=aCount-2;i>=0;i--) {\\n            if (ratings[i + 1] < ratings[i]) {\\n                ++aStreak;\\n            } else {\\n                aStreak = 1;\\n            }\\n            aDescend[i] = aStreak;\\n        }\\n        \\n        int aResult = 0;\\n        \\n        for (int i=0;i<aCount;i++) {\\n            aResult += max(aAscend[i], aDescend[i]);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247235,
                "title": "python-topological-sort-approach-o-n-time-and-o-n-space",
                "content": "The problem can be represented as a graph, where there is a node for each person, and a directed edge between two nodes if one node needs to get more candy than the other. \\nWith this graph, an easy variation of topological sort can solve the problem:\\n\\n\\tclass Solution(object):\\n\\t\\tdef candy(self, ratings):\\n\\t\\t\\tfrom collections import deque\\n\\t\\t\\tclass Node(object):\\n\\t\\t\\t\\tdef __init__(self,children):\\n\\t\\t\\t\\t\\tself.children = children\\n\\t\\t\\t\\t\\tself.visited = 0\\n\\t\\t\\t\\t\\tself.in_degree = 0\\n        \\n        #build graph:\\n        nodes = {}\\n        for i in range(len(ratings)):\\n            nodes[i] = Node([])\\n        \\n        for i,r in enumerate(ratings):\\n            if i > 0:\\n                if ratings[i-1] > r:\\n                    nodes[i].children.append(nodes[i-1])\\n                    nodes[i-1].in_degree += 1\\n                elif ratings[i-1] < r:\\n                    nodes[i-1].children.append(nodes[i])\\n                    nodes[i].in_degree += 1\\n            if i < len(ratings)-1 and ratings[i+1] > r:\\n                    nodes[i].children.append(nodes[i+1])\\n                    nodes[i+1].in_degree += 1\\n            elif i < len(ratings)-1 and ratings[i+1] < r:\\n                nodes[i+1].children.append(nodes[i])\\n                nodes[i].in_degree += 1\\n        \\n        #topological sort:\\n        sum_ = 0 \\n        q = deque([])\\n        for n in nodes.values():\\n            if n.in_degree == 0:\\n                q.append((n,1))\\n        while q:\\n            n,h = q.popleft()\\n            sum_ += h\\n            for neigh in n.children:\\n                neigh.in_degree -= 1\\n                if neigh.in_degree == 0:\\n                    q.append((neigh,h+1))\\n        return sum_\\n\\t\\t",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\t\\tdef candy(self, ratings):\\n\\t\\t\\tfrom collections import deque\\n\\t\\t\\tclass Node(object):\\n\\t\\t\\t\\tdef __init__(self,children):\\n\\t\\t\\t\\t\\tself.children = children\\n\\t\\t\\t\\t\\tself.visited = 0\\n\\t\\t\\t\\t\\tself.in_degree = 0\\n        \\n        #build graph:\\n        nodes = {}",
                "codeTag": "Java"
            },
            {
                "id": 42855,
                "title": "my-c-o-n-solution-with-good-explanation",
                "content": "The key of my solution is to eliminate backtrace and that can be achieved by introducing a decrease array, which stores the length of degressive sub arrary starting from any index. \\n\\nFor example, if the ratings array is [ 5, 1, 2, 3, 4, 9, 5, 3, 2, 2, 8 ], it's corresponding decrease array should look like this: [ 2, 1, 1, 1, 1, 4, 3, 2, 1, 1, 1 ]. sub array [ 9, 5, 3, 2 ] is degressive and its length is 4, that's where the 4 comes from. Any single-element sub array can make a degressive array of length 1. Obviously, this decrease array can be easily created by scanning ratings array from tail to head. \\n\\nWith this decrease array constructed, we can calculate candies for each child without backtrace.\\n\\n    int candy(vector<int>& ratings) {\\n        if( ratings.empty()) return 0;\\n        vector<int> decrease(ratings.size());\\n        decrease[ratings.size()-1] = 1;\\n        for( int i=ratings.size()-2; i>=0; i-- ) {\\n            if( ratings[i] > ratings[i+1] ) decrease[i] = decrease[i+1]+1;\\n            else decrease[i] = 1;\\n        }        \\n        vector<int> candy(ratings.size());\\n        candy[0] = decrease[0];\\n        int sum = candy[0];\\n        for( int i=1; i<ratings.size(); i++ ) {\\n            if( ratings[i] > ratings[i-1] ) candy[i] = max( decrease[i], candy[i-1]+1);\\n            else if( ratings[i] == ratings[i-1] ) {\\n                candy[i] = max( decrease[i], 1);\\n            }\\n            else candy[i] = min(candy[i-1]-1, decrease[i]);\\n            sum += candy[i];\\n        }\\n        return sum;\\n    }\\n\\nAnd, if you want to save more space, you can reuse the decrease array.\\n\\n    int candy(vector<int>& ratings) {\\n        if( ratings.empty()) return 0;\\n        vector<int> decrease(ratings.size());\\n        decrease[ratings.size()-1] = 1;\\n        for( int i=ratings.size()-2; i>=0; i-- ) {\\n            decrease[i] = ratings[i] > ratings[i+1] ? decrease[i+1] + 1 : 1;\\n        }        \\n        int sum = decrease[0];\\n        for( int i=1; i<ratings.size(); i++ ) {\\n            if( ratings[i] > ratings[i-1] ) \\n                decrease[i] = max( decrease[i], decrease[i-1]+1);\\n            else if( ratings[i] == ratings[i-1] ) \\n                decrease[i] = max( decrease[i], 1);\\n            else \\n                decrease[i] = min(decrease[i-1]-1, decrease[i]);\\n            sum += decrease[i];\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "The key of my solution is to eliminate backtrace and that can be achieved by introducing a decrease array, which stores the length of degressive sub arrary starting from any index. \\n\\nFor example, if the ratings array is [ 5, 1, 2, 3, 4, 9, 5, 3, 2, 2, 8 ], it's corresponding decrease array should look like this: [ 2, 1, 1, 1, 1, 4, 3, 2, 1, 1, 1 ]. sub array [ 9, 5, 3, 2 ] is degressive and its length is 4, that's where the 4 comes from. Any single-element sub array can make a degressive array of length 1. Obviously, this decrease array can be easily created by scanning ratings array from tail to head. \\n\\nWith this decrease array constructed, we can calculate candies for each child without backtrace.\\n\\n    int candy(vector<int>& ratings) {\\n        if( ratings.empty()) return 0;\\n        vector<int> decrease(ratings.size());\\n        decrease[ratings.size()-1] = 1;\\n        for( int i=ratings.size()-2; i>=0; i-- ) {\\n            if( ratings[i] > ratings[i+1] ) decrease[i] = decrease[i+1]+1;\\n            else decrease[i] = 1;\\n        }        \\n        vector<int> candy(ratings.size());\\n        candy[0] = decrease[0];\\n        int sum = candy[0];\\n        for( int i=1; i<ratings.size(); i++ ) {\\n            if( ratings[i] > ratings[i-1] ) candy[i] = max( decrease[i], candy[i-1]+1);\\n            else if( ratings[i] == ratings[i-1] ) {\\n                candy[i] = max( decrease[i], 1);\\n            }\\n            else candy[i] = min(candy[i-1]-1, decrease[i]);\\n            sum += candy[i];\\n        }\\n        return sum;\\n    }\\n\\nAnd, if you want to save more space, you can reuse the decrease array.\\n\\n    int candy(vector<int>& ratings) {\\n        if( ratings.empty()) return 0;\\n        vector<int> decrease(ratings.size());\\n        decrease[ratings.size()-1] = 1;\\n        for( int i=ratings.size()-2; i>=0; i-- ) {\\n            decrease[i] = ratings[i] > ratings[i+1] ? decrease[i+1] + 1 : 1;\\n        }        \\n        int sum = decrease[0];\\n        for( int i=1; i<ratings.size(); i++ ) {\\n            if( ratings[i] > ratings[i-1] ) \\n                decrease[i] = max( decrease[i], decrease[i-1]+1);\\n            else if( ratings[i] == ratings[i-1] ) \\n                decrease[i] = max( decrease[i], 1);\\n            else \\n                decrease[i] = min(decrease[i-1]-1, decrease[i]);\\n            sum += decrease[i];\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 42919,
                "title": "python-two-pass-solution",
                "content": "First, make sure I have right number of candy when compared to my left kid.\\nThen, make sure I have the right number of candy when compared to my right kid.\\n\\n    class Solution:\\n        # @param ratings, a list of integer\\n        # @return an integer\\n        # 5:46\\n        def candy(self, ratings):\\n            if not ratings:\\n                return 0\\n    \\n            n = len(ratings)\\n            candy = [1] * n\\n            for i in range(1, n):\\n                if ratings[i] > ratings[i - 1]:\\n                    candy[i] = candy[i - 1] + 1\\n                \\n            for i in range(n - 2, -1, -1):\\n                if ratings[i] > ratings[i + 1] and candy[i] <= candy[i + 1]:\\n                    candy[i] = candy[i + 1] + 1\\n    \\n            return sum(candy)",
                "solutionTags": [
                    "Python"
                ],
                "code": "First, make sure I have right number of candy when compared to my left kid.\\nThen, make sure I have the right number of candy when compared to my right kid.\\n\\n    class Solution:\\n        # @param ratings, a list of integer\\n        # @return an integer\\n        # 5:46\\n        def candy(self, ratings):\\n            if not ratings:\\n                return 0\\n    \\n            n = len(ratings)\\n            candy = [1] * n\\n            for i in range(1, n):\\n                if ratings[i] > ratings[i - 1]:\\n                    candy[i] = candy[i - 1] + 1\\n                \\n            for i in range(n - 2, -1, -1):\\n                if ratings[i] > ratings[i + 1] and candy[i] <= candy[i + 1]:\\n                    candy[i] = candy[i + 1] + 1\\n    \\n            return sum(candy)",
                "codeTag": "Java"
            },
            {
                "id": 42940,
                "title": "a-concise-c-solution-for-stl-lovers",
                "content": "If you like C++ and STL, you may also like the following solution:\\n\\n    class Solution {\\n    public:\\n        int candy(vector<int> &ratings) {\\n            \\n            // Corner case:\\n            if (ratings.size( ) <= 1)\\n            {\\n                return ratings.size( ); // Zero or one.\\n            }\\n            \\n            vector<int> candies(ratings.size(), 1);             // One candy per children at least.\\n            extraCandies(begin(candies), end(candies),          // Extra candies, left to right.\\n                         begin(ratings));\\n            extraCandies(candies.rbegin(), candies.rend(),      // Extra candies, right to left.\\n                         ratings.rbegin());\\n            return accumulate(begin(candies), end(candies), 0); // Total summ of candies.\\n        }\\n        \\n        template<typename It>\\n        int extraCandies(It candyIt, It candyEnd, It ratingIt)\\n        {\\n            int prevCandy = *candyIt;\\n            int prevRating = *ratingIt;\\n            while(candyIt != candyEnd)\\n            {\\n                if (*ratingIt > prevRating\\n                    && *candyIt <= prevCandy)\\n                {\\n                    // Bingo, extra candies for him!\\n                    (*candyIt) = prevCandy + 1;\\n                }\\n                \\n                prevRating = *ratingIt;\\n                prevCandy = *candyIt;\\n                ++candyIt;\\n                ++ratingIt;\\n            }\\n        }\\n    };\\n\\nComplexity:\\n - CPU: O(n)\\n - Memory: O(n)",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n        int candy(vector<int> &ratings) {\\n            \\n            // Corner case:\\n            if (ratings.size( ) <= 1)\\n            {\\n                return ratings.size( ); // Zero or one.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 42960,
                "title": "my-accepted-o-n-o-1-solution",
                "content": "    class Solution {\\n    public:\\n    \\tint candy(vector<int> &ratings) \\n    \\t{\\n    \\t\\tint i = 0; // start of the sequence\\n    \\t\\tint count = 1; //total number of candy needed\\n    \\t\\tint n = ratings.size();  //number of childen\\n    \\t\\tint lastCandy=1; //number of Candy the last child of previous sequence hold\\n    \\t\\twhile ( i < n - 1)\\n    \\t\\t{\\n    \\t\\t\\tint j = i+1; // j is the next node of end of this sequence\\n    \\t\\t\\tint tmp =0;\\n    \\t\\t\\tif (ratings[j] > ratings[i])\\n    \\t\\t\\t{//find the whole upside sequence, it's from i to j - 1, \\n    \\t\\t\\t\\twhile(j < n && ratings[j]>ratings[j-1]) j++;\\n    \\t\\t\\t\\ttmp = j - i - 1; // total number in up sequence, count them from 2 to (count +1) because the first one is already included in previous sequence\\n    \\t\\t\\t\\tcount += (tmp*(tmp+3)/2); // add them up\\n    \\t\\t\\t\\tlastCandy = tmp+lastCandy;\\n    \\t\\t\\t\\ti = j - 1;\\n    \\t\\t\\t}\\n    \\t\\t\\telse if (ratings[j] < ratings[i]) \\n    \\t\\t\\t{//find the downside sequence, it's from i to j - 1;\\n    \\t\\t\\t\\twhile(j<n && ratings[j]<ratings[j-1]) j++;\\n    \\t\\t\\t\\t// total number in down sequence, count them from (count - 1) to 1,\\n    \\t\\t\\t\\ttmp = j - i - 1; \\n    \\t\\t\\t\\tcount += (tmp*(tmp+1)/2);\\n    \\t\\t\\t\\t// if the last child in previous sequence has less candy than he/she should have, add it up by the down sequence number\\n    \\t\\t\\t\\tif (tmp >= lastCandy)\\n    \\t\\t\\t\\t\\tcount += (tmp + 1 - lastCandy);\\n    \\t\\t\\t\\tlastCandy = 1;\\n    \\t\\t\\t\\ti = j - 1;\\n    \\t\\t\\t}\\n    \\t\\t\\telse\\n    \\t\\t\\t{//same rating as previous one, start with only 1 candy\\n    \\t\\t\\t\\tcount++;\\n    \\t\\t\\t\\tlastCandy = 1;\\n    \\t\\t\\t\\ti = j;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn count;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tint candy(vector<int> &ratings) \\n    \\t{\\n    \\t\\tint i = 0; // start of the sequence\\n    \\t\\tint count = 1; //total number of candy needed\\n    \\t\\tint n = ratings.size();  //number of childen\\n    \\t\\tint lastCandy=1; //number of Candy the last child of previous sequence hold\\n    \\t\\twhile ( i < n - 1)\\n    \\t\\t{\\n    \\t\\t\\tint j = i+1; // j is the next node of end of this sequence\\n    \\t\\t\\tint tmp =0;\\n    \\t\\t\\tif (ratings[j] > ratings[i])\\n    \\t\\t\\t{//find the whole upside sequence, it's from i to j - 1, \\n    \\t\\t\\t\\twhile(j < n && ratings[j]>ratings[j-1]) j++;\\n    \\t\\t\\t\\ttmp = j - i - 1; // total number in up sequence, count them from 2 to (count +1) because the first one is already included in previous sequence\\n    \\t\\t\\t\\tcount += (tmp*(tmp+3)/2); // add them up\\n    \\t\\t\\t\\tlastCandy = tmp+lastCandy;\\n    \\t\\t\\t\\ti = j - 1;\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 42934,
                "title": "candy-problem-on-oj",
                "content": "> There are N children standing in a line. Each child is assigned a\\n> rating value. You are giving candies to these children subjected to\\n> the following requirements:\\n>      Each child must have at least one candy.      Children with a higher rating get more candies than their neighbors.           What is\\n> the minimum candies you must give?\\n\\n\\nI thought I got it correctly, but my code seems to fail for some test cases. The logic I was following:   \\ninitialize an array of size n, called candies, with all values set to 0    \\nset first value to 1    \\niterate through ratings array, starting at one, and check:   \\n  for element i in array rating:   \\n\\n 1. if rating[i] is greater than rating[i-1], set current candy nr. to\\n    previous nr.+1\\n 2. if rating[i] is equal to rating[i-1], set current candy nr. to the same nr. as previous\\n 3. if rating[i] is less than rating[i-1], there are two possible  situations:\\n\\n \\n - a) we can safely subtract 1 for previous candy number and still get a number that is greater than one; in that case set current candy nr.  to 1   \\n - b) setting the current candy nr. to previous-1 would be less than 1; in    that case we need to backtrack; continue backtracking     while    previous rating is greater than the current && previous  candy    nr.    is less than or equal to the current; in each   iteration increase       the previous candy nr.\\n\\n\\nI think my code now is pretty straighforward:\\n\\n    public int candy(int[] ratings) {\\n             \\n                if (ratings== null) return -1;\\n                int n = ratings.length;\\n                int[] candies = new int[n];\\n                if (n==0) return 0;\\n                candies[0] = 1;\\n                int sum = 1;\\n                for (int i=1; i<n; i++) {\\n                    if (ratings[i] > ratings[i-1]) {\\n\\n                        candies[i] = candies[i-1] + 1;\\n                        sum+=candies[i];\\n\\n                    } else if (ratings[i] == ratings[i-1]) {\\n                        \\n                        candies[i] = candies[i-1];\\n                        sum+=candies[i];\\n                    \\n                   }else {\\n                        if (candies[i-1]-1 >= 1) {\\n                             candies[i] = 1;\\n                            sum+= candies[i];\\n                        } else {\\n                            int k = i;\\n                            candies[k]++;\\n                            sum++;\\n                            while (k>0 && ratings[k]<ratings[k-1] && candies[k-1]<=candies[k]) {\\n                                candies[k-1]++;\\n                                sum++;\\n                                k--;\\n                            }\\n                        } \\n                    }\\n                }\\n                return sum;\\n            }\\n\\n[UPDATE:] Here is the failed case: [58,21,72,77,48,9,38,71,68,77,82,47,25,94,89,54,26,54,54,99,64,71,76,63,81,82,60,64,29,51,87,87,72,12,16,20,21,54,43,41,83,77,41,61,72,82,15,50,36,69,49,53,92,77,16,73,12,28,37,41,79,25,80,3,37,48,23,10,55,19,51,38,96,92,99,68,75,14,18,63,35,19,68,28,49,36,53,61,64,91,2,43,68,34,46,57,82,22,67,89]\\n\\nExpected: 208, I got: 210.",
                "solutionTags": [],
                "code": "> There are N children standing in a line. Each child is assigned a\\n> rating value. You are giving candies to these children subjected to\\n> the following requirements:\\n>      Each child must have at least one candy.      Children with a higher rating get more candies than their neighbors.           What is\\n> the minimum candies you must give?\\n\\n\\nI thought I got it correctly, but my code seems to fail for some test cases. The logic I was following:   \\ninitialize an array of size n, called candies, with all values set to 0    \\nset first value to 1    \\niterate through ratings array, starting at one, and check:   \\n  for element i in array rating:   \\n\\n 1. if rating[i] is greater than rating[i-1], set current candy nr. to\\n    previous nr.+1\\n 2. if rating[i] is equal to rating[i-1], set current candy nr. to the same nr. as previous\\n 3. if rating[i] is less than rating[i-1], there are two possible  situations:\\n\\n \\n - a) we can safely subtract 1 for previous candy number and still get a number that is greater than one; in that case set current candy nr.  to 1   \\n - b) setting the current candy nr. to previous-1 would be less than 1; in    that case we need to backtrack; continue backtracking     while    previous rating is greater than the current && previous  candy    nr.    is less than or equal to the current; in each   iteration increase       the previous candy nr.\\n\\n\\nI think my code now is pretty straighforward:\\n\\n    public int candy(int[] ratings) {\\n             \\n                if (ratings== null) return -1;\\n                int n = ratings.length;\\n                int[] candies = new int[n];\\n                if (n==0) return 0;\\n                candies[0] = 1;\\n                int sum = 1;\\n                for (int i=1; i<n; i++) {\\n                    if (ratings[i] > ratings[i-1]) {\\n\\n                        candies[i] = candies[i-1] + 1;\\n                        sum+=candies[i];\\n\\n                    } else if (ratings[i] == ratings[i-1]) {\\n                        \\n                        candies[i] = candies[i-1];\\n                        sum+=candies[i];\\n                    \\n                   }else {\\n                        if (candies[i-1]-1 >= 1) {\\n                             candies[i] = 1;\\n                            sum+= candies[i];\\n                        } else {\\n                            int k = i;\\n                            candies[k]++;\\n                            sum++;\\n                            while (k>0 && ratings[k]<ratings[k-1] && candies[k-1]<=candies[k]) {\\n                                candies[k-1]++;\\n                                sum++;\\n                                k--;\\n                            }\\n                        } \\n                    }\\n                }\\n                return sum;\\n            }\\n\\n[UPDATE:] Here is the failed case: [58,21,72,77,48,9,38,71,68,77,82,47,25,94,89,54,26,54,54,99,64,71,76,63,81,82,60,64,29,51,87,87,72,12,16,20,21,54,43,41,83,77,41,61,72,82,15,50,36,69,49,53,92,77,16,73,12,28,37,41,79,25,80,3,37,48,23,10,55,19,51,38,96,92,99,68,75,14,18,63,35,19,68,28,49,36,53,61,64,91,2,43,68,34,46,57,82,22,67,89]\\n\\nExpected: 208, I got: 210.",
                "codeTag": "Unknown"
            },
            {
                "id": 4038208,
                "title": "2-approach-brute-force-better-approach-easy-explanation-c",
                "content": "\\n# Approach\\n#### 1st Approach\\n- Go to every index and check how many neighbours are bigger than that ```max(left-neighbour, right-neighbour)```\\n\\n#### Better Approach\\n- Make two vertors ```left and right```\\n- ```left``` for storing the maximum neighbours to its recent left if any is equal to or bigger than the ```ith``` number then  we cannot further calculate\\n- ```right``` for storing the maximum neighbours to its recent right\\n- Now take the maximum of ```max(left[i], right[i] + 1``` and add it to the answer\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Approach 1:\\n    - Time complexity -- $$O(n^2)$$\\n    - Space complexity -- $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Approach 2:\\n    - Time complexity -- $$O(n)$$\\n    - Space complexity -- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Approach 1\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        if(n == 1)\\n            return 1;\\n\\n        int ans = n; \\n        int i = 0;\\n        while(i < n){\\n            int j = i - 1;\\n            int count = 0;\\n            while(j >= 0 && ratings[j + 1] > ratings[j]){\\n                count++, j--;\\n            }\\n            int count2 = 0;\\n            j = i + 1;\\n            while(j < n && ratings[j - 1] > ratings[j]){\\n                count2++, j++;\\n            }\\n            ans += max(count, count2);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Approach 2\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> left(n, 0), right(n, 0);\\n        for(int i = 1; i < n; i++)\\n            if(ratings[i] > ratings[i - 1])\\n                left[i] = left[i - 1] + 1;\\n\\n        for(int i = n - 2; i >= 0; i--)\\n            if(ratings[i] > ratings[i + 1])\\n                right[i] = right[i + 1] + 1;\\n\\n        int ans = n;\\n        for(int i = 0; i < n; i++)\\n            ans += max(left[i], right[i]);\\n        return ans;\\n    }\\n};\\n\\n```\\n![upvote_leetcode.jpeg](https://assets.leetcode.com/users/images/4a49ab74-4aa1-4097-82a2-240682ea3352_1694580760.1023214.jpeg)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```max(left-neighbour, right-neighbour)```\n```left and right```\n```left```\n```ith```\n```right```\n```max(left[i], right[i] + 1```\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        if(n == 1)\\n            return 1;\\n\\n        int ans = n; \\n        int i = 0;\\n        while(i < n){\\n            int j = i - 1;\\n            int count = 0;\\n            while(j >= 0 && ratings[j + 1] > ratings[j]){\\n                count++, j--;\\n            }\\n            int count2 = 0;\\n            j = i + 1;\\n            while(j < n && ratings[j - 1] > ratings[j]){\\n                count2++, j++;\\n            }\\n            ans += max(count, count2);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> left(n, 0), right(n, 0);\\n        for(int i = 1; i < n; i++)\\n            if(ratings[i] > ratings[i - 1])\\n                left[i] = left[i - 1] + 1;\\n\\n        for(int i = n - 2; i >= 0; i--)\\n            if(ratings[i] > ratings[i + 1])\\n                right[i] = right[i + 1] + 1;\\n\\n        int ans = n;\\n        for(int i = 0; i < n; i++)\\n            ans += max(left[i], right[i]);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038027,
                "title": "easy-0-n-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n### **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n### **[https://www.instagram.com/pratay_nandy/]()**\\n# Problem Statement\\n- The problem statement is as follows: You are given a list of ratings for a group of children, and you want to distribute candies to these children based on the following rules:\\n\\n1. Each child must have at least one candy.\\n2. Children with a higher rating than their neighbors must get more candies.\\n- The goal is to minimize the total number of candies used while satisfying these rules\\n# Approach\\n\\nHere\\'s the approach used in the provided C++ code:\\n\\n- Initialize a vector left with the same size as the input ratings vector. This vector will store the number of candies given to each child based on the ratings from the left side.\\n\\n- First Pass (from left to right):\\n\\n- Iterate through the ratings vector from left to right (from index 1 to the end).\\nIf the current child\\'s rating is greater than the previous child\\'s rating, increment the number of candies given to the current child by one more than what the previous child received (i.e., left[i] = left[i-1] + 1).Otherwise, leave left[i] as 1 because the current child\\'s rating is not greater than the previous one.\\nInitialize a variable right to 1. This variable will be used to keep track of the number of candies given to the children from the right side.\\n\\n- Second Pass (from right to left):\\n\\n- Iterate through the ratings vector from right to left (from the second-to-last element to the first element).\\nIf the current child\\'s rating is greater than the next child\\'s rating, increment right by 1 (since this child needs more candies than the next one).\\n- Update left[i] by taking the maximum of its current value and right (to ensure that the child gets the maximum of what they need from both sides).\\n- If the current child\\'s rating is not greater than the next one, reset right to 1, indicating that this child starts a new descending sequence.\\n- Calculate the total sum of candies in the left vector, which represents the minimum total number of candies needed to satisfy the given rules.\\n\\n- Return the total sum as the result.\\n\\nThis approach ensures that each child receives the required minimum number of candies while taking into account both left and right ratings comparisons. The final result is the minimum total number of candies needed to satisfy the rulesThe problem statement is as follows: You are given a list of ratings for a group of children, and you want to distribute candies to these children based on the following rules:\\n\\n# Complexity\\n- Time complexity:**0(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**0(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int>left(ratings.size()+1,1);\\n        // vector<int>right(ratings.size()+1,1);\\n        for(int i = 1; i < ratings.size(); i++ )\\n        {\\n            if(ratings[i]>ratings[i-1])\\n            {\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        int right = 1;\\n        for(int i = ratings.size()-2;i>=0;i--)\\n        {\\n            if(ratings[i] > ratings[i+1])\\n            {\\n                right++;\\n                left[i]=max(right, left[i]);\\n            }\\n            else\\n            right = 1;\\n        }\\n        int sum = 0 ;\\n        for(int i = 0; i < ratings.size(); i++ )\\n            sum+=left[i];\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int>left(ratings.size()+1,1);\\n        // vector<int>right(ratings.size()+1,1);\\n        for(int i = 1; i < ratings.size(); i++ )\\n        {\\n            if(ratings[i]>ratings[i-1])\\n            {\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        int right = 1;\\n        for(int i = ratings.size()-2;i>=0;i--)\\n        {\\n            if(ratings[i] > ratings[i+1])\\n            {\\n                right++;\\n                left[i]=max(right, left[i]);\\n            }\\n            else\\n            right = 1;\\n        }\\n        int sum = 0 ;\\n        for(int i = 0; i < ratings.size(); i++ )\\n            sum+=left[i];\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037939,
                "title": "easy-c-solution-using-prefix-and-suffix-vectors",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two arrays `pref` and `suff` with the same size as the ratings array, all set to 1. This ensures that each child starts with at least `one` candy.\\n\\n2. Loop through the ratings array from left to right. For each child, compare their rating with the rating of the previous child (if any). If the current child\\'s rating is greater than the previous child\\'s rating, increment the number of candies given to the current child by 1 more than what the previous child received `(pref[i] = 1 + pref[i-1])`.\\n\\n3. Loop through the ratings array from right to left. For each child, compare their rating with the rating of the next child (if any). If the current child\\'s rating is greater than the next child\\'s rating, update the number of candies given to the current child by taking the maximum of its current value and 1 plus what the next child received `(suff[i] = max(suff[i], 1 + suff[i+1]))`.\\n\\n4. Initialize a variable `ans` to keep track of the total number of candies needed.\\n\\n5. Loop through the ratings array one more time, and for each child, calculate the maximum number of candies they should receive by taking the maximum of the values in `pref` and `suff` for that child. Add this maximum value to `ans`.\\n\\n6. Return `ans`, which represents the` total minimum number of candies required to satisfy the conditions`.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n We traverse the ratings array three times independently, and each traversal takes `linear time`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n We use two additional arrays `pref` and `suff`, each of size `n`, for storing intermediate results.\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int>pref(n , 1);\\n        vector<int>suff(n , 1);\\n        for(int i = 1;i<n; i++){\\n            if(ratings[i]>ratings[i-1]) pref[i] = 1 + pref[i-1];\\n        }\\n        for(int i = n-2;i>=0; i--){\\n            if(ratings[i]>ratings[i+1]) suff[i] = 1 + suff[i+1];\\n        }\\n\\n        int ans = 0; \\n        for(int i=0;i<n; i++) ans += max(pref[i] , suff[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int>pref(n , 1);\\n        vector<int>suff(n , 1);\\n        for(int i = 1;i<n; i++){\\n            if(ratings[i]>ratings[i-1]) pref[i] = 1 + pref[i-1];\\n        }\\n        for(int i = n-2;i>=0; i--){\\n            if(ratings[i]>ratings[i+1]) suff[i] = 1 + suff[i+1];\\n        }\\n\\n        int ans = 0; \\n        for(int i=0;i<n; i++) ans += max(pref[i] , suff[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001238,
                "title": "java-easy-solution-with-proper-explanation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->1.We will make two array and we will keep each element value as 1 for those two array. Now we will move from left to right and if we found the element to be greater than the neightbouring element, then we will make the value of that index to be 1 greater than the previous index value and store this all value in array named as LtoR\\n2.Similarly we will move from right to left (we will start from n-2 element) and compare and do the same thing as mentioned above and store all value in RtoL array.\\n3.After that we will make another array named as \\'ans\\' and store the max value of LtoR and RtoL arrays.\\n4.Then we will sum up the value of res and get the final output.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] LtoR = new int[n];//LtoR(Left to right)\\n        int[] RtoL = new int[n];//RtoL(Right to left)\\n        for(int i=0; i<n; i++){\\n            LtoR[i]=RtoL[i]=1;// assign each element value as 1\\n        }\\n        for(int i=1; i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                LtoR[i]=LtoR[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2; i>=0; i--){\\n            if(ratings[i]>ratings[i+1]){\\n                RtoL[i]=RtoL[i+1]+1;\\n            }\\n        }\\n        int[] ans = new int[n];\\n        int sum =0;\\n        for(int i=0; i<n; i++){\\n            ans[i] = Math.max(LtoR[i],RtoL[i]);\\n            sum += ans[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] LtoR = new int[n];//LtoR(Left to right)\\n        int[] RtoL = new int[n];//RtoL(Right to left)\\n        for(int i=0; i<n; i++){\\n            LtoR[i]=RtoL[i]=1;// assign each element value as 1\\n        }\\n        for(int i=1; i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                LtoR[i]=LtoR[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2; i>=0; i--){\\n            if(ratings[i]>ratings[i+1]){\\n                RtoL[i]=RtoL[i+1]+1;\\n            }\\n        }\\n        int[] ans = new int[n];\\n        int sum =0;\\n        for(int i=0; i<n; i++){\\n            ans[i] = Math.max(LtoR[i],RtoL[i]);\\n            sum += ans[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747874,
                "title": "easy-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n\\n- Space complexity:O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> candies(n, 1);\\n        \\n        // Forward pass\\n        for(int i = 1; i < n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        \\n        // Backward pass\\n        for(int i = n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1] + 1);\\n            }\\n        }\\n        \\n        // Sum up the candies\\n        int sum = 0;\\n        for(int c : candies) sum += c;\\n        \\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> candies(n, 1);\\n        \\n        // Forward pass\\n        for(int i = 1; i < n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        \\n        // Backward pass\\n        for(int i = n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1] + 1);\\n            }\\n        }\\n        \\n        // Sum up the candies\\n        int sum = 0;\\n        for(int c : candies) sum += c;\\n        \\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689006,
                "title": "easy-solution-greedy-o-n",
                "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) \\n    {\\n        int n=ratings.size();\\n        if(ratings.size()==1)\\n        {\\n            return 1;\\n        }\\n        vector<int> temp(ratings.size(),1);\\n        int ans=0;\\n        if(ratings[0]>ratings[1])\\n        {\\n            temp[0]=max(temp[0]+1,temp[1]+1);\\n        }\\n        for(int i=1;i<ratings.size()-1;i++)\\n        {\\n            if(ratings[i]>ratings[i+1]||ratings[i]>ratings[i-1])\\n            {\\n                if(ratings[i]>ratings[i+1]&&ratings[i]>ratings[i-1])\\n                {\\n                    temp[i]=max(temp[i]+1,max(temp[i+1]+1,temp[i-1]+1));\\n                }\\n                else if(ratings[i]>ratings[i-1])\\n                {\\n                    temp[i]=max(temp[i]+1,temp[i-1]+1);\\n                }\\n                else if(ratings[i]>ratings[i+1])\\n                {\\n                     temp[i]=max(temp[i]+1,temp[i+1]+1);\\n                }\\n            }\\n        }\\n        if(n>=2) \\n        {\\n            if(ratings[n-1]>ratings[n-2])\\n            {\\n                temp[n-1]=max(temp[n-1]+1,temp[n-2]+1);\\n            }\\n        }\\n        for(int i=ratings.size()-1;i>=1;i--)\\n        {\\n            if(ratings[i]<ratings[i-1])\\n            {\\n                if(temp[i]>=temp[i-1])\\n                {\\n                    temp[i-1]=temp[i]+1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            ans+=temp[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) \\n    {\\n        int n=ratings.size();\\n        if(ratings.size()==1)\\n        {\\n            return 1;\\n        }\\n        vector<int> temp(ratings.size(),1);\\n        int ans=0;\\n        if(ratings[0]>ratings[1])\\n        {\\n            temp[0]=max(temp[0]+1,temp[1]+1);\\n        }\\n        for(int i=1;i<ratings.size()-1;i++)\\n        {\\n            if(ratings[i]>ratings[i+1]||ratings[i]>ratings[i-1])\\n            {\\n                if(ratings[i]>ratings[i+1]&&ratings[i]>ratings[i-1])\\n                {\\n                    temp[i]=max(temp[i]+1,max(temp[i+1]+1,temp[i-1]+1));\\n                }\\n                else if(ratings[i]>ratings[i-1])\\n                {\\n                    temp[i]=max(temp[i]+1,temp[i-1]+1);\\n                }\\n                else if(ratings[i]>ratings[i+1])\\n                {\\n                     temp[i]=max(temp[i]+1,temp[i+1]+1);\\n                }\\n            }\\n        }\\n        if(n>=2) \\n        {\\n            if(ratings[n-1]>ratings[n-2])\\n            {\\n                temp[n-1]=max(temp[n-1]+1,temp[n-2]+1);\\n            }\\n        }\\n        for(int i=ratings.size()-1;i>=1;i--)\\n        {\\n            if(ratings[i]<ratings[i-1])\\n            {\\n                if(temp[i]>=temp[i-1])\\n                {\\n                    temp[i-1]=temp[i]+1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            ans+=temp[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376636,
                "title": "easiest-approach-c-code-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& r) {\\n        vector< int> left(r.size(), 1);\\n        vector< int> right(r.size(), 1);\\n\\n        for(int i = 1; i<r.size(); i++){\\n            if(r[i]>r[i-1]) left[i] += left[i-1];\\n        }\\n\\n        for(int i = r.size()-2; i>=0; i--){\\n            if(r[i]>r[i+1]) right[i] += right[i+1];\\n        }\\n\\n        int ans = 0;\\n        for(int i = 0; i<left.size(); i++){\\n            ans = ans + max(left[i],right[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& r) {\\n        vector< int> left(r.size(), 1);\\n        vector< int> right(r.size(), 1);\\n\\n        for(int i = 1; i<r.size(); i++){\\n            if(r[i]>r[i-1]) left[i] += left[i-1];\\n        }\\n\\n        for(int i = r.size()-2; i>=0; i--){\\n            if(r[i]>r[i+1]) right[i] += right[i+1];\\n        }\\n\\n        int ans = 0;\\n        for(int i = 0; i<left.size(); i++){\\n            ans = ans + max(left[i],right[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305021,
                "title": "easy-java-greedy-approach-3ms-solution",
                "content": "# Approach\\n\\n1. **Just make an array of same size as the provided array and initilize it to 1 as the minimum count of candies is 1**\\n2. **Now 1st check for the condition from start to end and then from end to start and finally return the sum of new array**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int[] res = new int[ratings.length];\\n\\n        Arrays.fill(res, 1);\\n\\n        for(int i = 1;i < ratings.length;i++){\\n            if(ratings[i] > ratings[i-1]){\\n                res[i] = res[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i = ratings.length-2;i >= 0;i--){\\n            if(ratings[i] > ratings[i+1]){\\n                res[i] = Math.max(res[i], res[i+1]+1);\\n            }\\n        }\\n\\n        int sum = 0;\\n\\n        for(int i = 0;i < res.length;i++){\\n            sum += res[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int[] res = new int[ratings.length];\\n\\n        Arrays.fill(res, 1);\\n\\n        for(int i = 1;i < ratings.length;i++){\\n            if(ratings[i] > ratings[i-1]){\\n                res[i] = res[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i = ratings.length-2;i >= 0;i--){\\n            if(ratings[i] > ratings[i+1]){\\n                res[i] = Math.max(res[i], res[i+1]+1);\\n            }\\n        }\\n\\n        int sum = 0;\\n\\n        for(int i = 0;i < res.length;i++){\\n            sum += res[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076505,
                "title": "c-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& arr) {\\n        int n = arr.size();\\n        if( n == 1)\\n            return 1;\\n        vector<int> res(n , 1);\\n\\n        \\n        for( int i = 1 ; i < n  ; ++i){\\n            if( arr[i] > arr[i-1] ){\\n                res[i] = res[i-1]+1;\\n            }\\n        }\\n\\n        for( int i = n - 1 ; i > 0 ; --i){\\n            if( arr[i-1] > arr[i] ){\\n                res[i-1] = max(res[i] + 1 , res[i-1]);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto i : res){\\n            // cout<<i<<\" \";\\n            ans+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& arr) {\\n        int n = arr.size();\\n        if( n == 1)\\n            return 1;\\n        vector<int> res(n , 1);\\n\\n        \\n        for( int i = 1 ; i < n  ; ++i){\\n            if( arr[i] > arr[i-1] ){\\n                res[i] = res[i-1]+1;\\n            }\\n        }\\n\\n        for( int i = n - 1 ; i > 0 ; --i){\\n            if( arr[i-1] > arr[i] ){\\n                res[i-1] = max(res[i] + 1 , res[i-1]);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto i : res){\\n            // cout<<i<<\" \";\\n            ans+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3015077,
                "title": "c-o-n-time-solution-explanation",
                "content": "\\n# Upvote if Found Helpful\\n# Approach\\n\\n\\n**According to question**\\nThe child whose rating is higher than that of his left or right neighbors should get more candies than his neighbors and the total amount of candies should also be minimum.\\n```\\n// so we can say that \\nif current_child_rating > left_child_rating or current_child_rating > right_child_rating \\nthen \\ncurrent_child_get_candy = max( left_child_candy, right_child_candy ) + 1\\n```\\n\\n```\\ncase 1:For the minimum amount of all candies, each child will receive the minimum amount of candy possible (each child must have a minimum of 1 candy)\\ncase 2: Child with same rating can get minimum possible candies\\n```\\n```\\ncase 3: when  current_child_rating > left_child_rating \\n    then current_child_candy = left_child_candy + 1\\n```\\n**Let us take an example:**\\narr = [1, 0, 2]\\n1. for index 0 : because he is the first and don\\'t having left neighbor so we continue,\\n2. for index 1 : he is having left neighbor but because currnt child having low rating then left child he don\\'n get extra candy\\n3. for index 2 : he is having left neighbour and also high ratings then neighbor so he will get more candies then his neighbour \\n \\n    \\n```\\ncase 4: when  current_child_rating > right_child_rating \\n    then current_child_candy = right_child_candy + 1\\n```\\nnow we go from right to left:\\n1. for index 2: don\\'t have right child so continue,\\n2. for index 1: he is having right neighbor but don\\'t have high rating as compare to his right\\n3. for index 0: he is have right neighbor and also high rating then right neighbor so he will get more candy more candy as compare to right neighbor\\n\\n**but wait**...What if the current child has a higher rating than the left and right neighbors combined, and the left neighbor has more candies then the right neighbor? so to solve this problem we take max candy + 1\\n```\\nupdate case 4 : \\nwhen  current_child_rating > right_child_rating \\n    then current_child_candy = max (current_child_candy, right_child_candy + 1)\\n```\\nAnd finally we\\'ll add all the candy and return it.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {        \\n        int n = ratings.size();\\n        int total_candies =0;\\n        vector<int>candy(n,1);\\n        // case 1: Each child will get minimum 1 candy\\n        // case 2: children with same rating will get minimum candy.\\n\\n        for(int i=1;i<n;i++){\\n            // case 3: currend child having more rating left neighbor then he get more candy then left neighbor\\n            if( ratings[i] > ratings[i-1]) \\n                candy[i] = candy[i-1]+1;\\n        }\\n\\n        for(int i=n-1;i>=0;i--){\\n            // case 4: current child having more rating then right neighbor then he will get more candy then right child\\n            if( i<n-1 and ratings[i]>ratings[i+1])\\n                arr[i]=max(candy[i], candy[i+1]+1);\\n\\n            total_candies += candy[i];\\n            // add all the candies\\n        }\\n        \\n        return total_candies;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// so we can say that \\nif current_child_rating > left_child_rating or current_child_rating > right_child_rating \\nthen \\ncurrent_child_get_candy = max( left_child_candy, right_child_candy ) + 1\\n```\n```\\ncase 1:For the minimum amount of all candies, each child will receive the minimum amount of candy possible (each child must have a minimum of 1 candy)\\ncase 2: Child with same rating can get minimum possible candies\\n```\n```\\ncase 3: when  current_child_rating > left_child_rating \\n    then current_child_candy = left_child_candy + 1\\n```\n```\\ncase 4: when  current_child_rating > right_child_rating \\n    then current_child_candy = right_child_candy + 1\\n```\n```\\nupdate case 4 : \\nwhen  current_child_rating > right_child_rating \\n    then current_child_candy = max (current_child_candy, right_child_candy + 1)\\n```\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {        \\n        int n = ratings.size();\\n        int total_candies =0;\\n        vector<int>candy(n,1);\\n        // case 1: Each child will get minimum 1 candy\\n        // case 2: children with same rating will get minimum candy.\\n\\n        for(int i=1;i<n;i++){\\n            // case 3: currend child having more rating left neighbor then he get more candy then left neighbor\\n            if( ratings[i] > ratings[i-1]) \\n                candy[i] = candy[i-1]+1;\\n        }\\n\\n        for(int i=n-1;i>=0;i--){\\n            // case 4: current child having more rating then right neighbor then he will get more candy then right child\\n            if( i<n-1 and ratings[i]>ratings[i+1])\\n                arr[i]=max(candy[i], candy[i+1]+1);\\n\\n            total_candies += candy[i];\\n            // add all the candies\\n        }\\n        \\n        return total_candies;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919127,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int cnt = 0;\\n        vector<int> v(n, 1);\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) v[i] = max(v[i], v[i-1] + 1); \\n        }\\n        for(int i=n-2; i>=0; i--) {\\n            if(ratings[i] > ratings[i+1]) v[i] = max(v[i], v[i+1] + 1); \\n        }\\n        for(int i=0; i<n; i++) cnt += v[i];\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int cnt = 0;\\n        vector<int> v(n, 1);\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) v[i] = max(v[i], v[i-1] + 1); \\n        }\\n        for(int i=n-2; i>=0; i--) {\\n            if(ratings[i] > ratings[i+1]) v[i] = max(v[i], v[i+1] + 1); \\n        }\\n        for(int i=0; i<n; i++) cnt += v[i];\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754714,
                "title": "easy-to-understand-2-pass-solution",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/hard/greedy/Candy.java",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2589679,
                "title": "c-solution-solution-of-o-n-time-and-simple",
                "content": "```\\n  int candy(int* ra, int size){\\n    int a = 0;\\n    int s = size -1;\\n    int *r = malloc(4 * size);\\n    int *l = malloc(4 * size);\\n    l[0] = 1;\\n    r[size-1] = 1;\\n    for(int i = 1; i < size ; i++)\\n       l[i] = ra[i] > ra[i - 1] ? l[i - 1] + 1 :  1;\\n    for(int i = size - 2 ; i >=0 ; i--)\\n        r[i] = ra[i] > ra[i+1] ? r[i + 1] + 1 : 1;\\n    for(int i = 0 ; i < size ; i++)\\n       a += r[i] > l[i] ? r[i] :l[i];\\n    return a;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int candy(int* ra, int size){\\n    int a = 0;\\n    int s = size -1;\\n    int *r = malloc(4 * size);\\n    int *l = malloc(4 * size);\\n    l[0] = 1;\\n    r[size-1] = 1;\\n    for(int i = 1; i < size ; i++)\\n       l[i] = ra[i] > ra[i - 1] ? l[i - 1] + 1 :  1;\\n    for(int i = size - 2 ; i >=0 ; i--)\\n        r[i] = ra[i] > ra[i+1] ? r[i + 1] + 1 : 1;\\n    for(int i = 0 ; i < size ; i++)\\n       a += r[i] > l[i] ? r[i] :l[i];\\n    return a;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2238440,
                "title": "candy-java-o-n-tc-sc-easy-concept-greedy-solution-pre-computational-explanation",
                "content": "We keeps the track of the neighbour\\'s candy and stores it in the double array used, one from left side and other from right side using the greedy apporach which finally helps in getting the sum of the max of two values.\\nHere, values can be stored by using a precalculated value in the previous or, next array.\\n\\n\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int ans=0;\\n        int [] arr1=new int[ratings.length];\\n        int [] arr2=new int[ratings.length];\\n        for(int i=0;i<ratings.length;i++){\\n            arr1[i]++;\\n            arr2[i]++;\\n        }\\n        for(int i=0;i<ratings.length-1;i++){\\n            if(ratings[i]>ratings[i+1] && arr1[i]<=arr1[i+1]){\\n                arr1[i]=arr1[i+1]+1;\\n            }\\n            else if(ratings[i]<ratings[i+1] && arr1[i]>=arr1[i+1]){\\n                arr1[i+1]=arr1[i]+1;\\n            }\\n        }\\n        for(int i=ratings.length-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1] && arr2[i]<=arr2[i+1]){\\n                arr2[i]=arr2[i+1]+1;\\n            }\\n            else if(ratings[i]<ratings[i+1] && arr2[i]>=arr2[i+1]){\\n                arr2[i+1]=arr2[i]+1;\\n            }\\n        }\\n        for(int i=0;i<ratings.length;i++){\\n            ans+=Math.max(arr1[i],arr2[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\nKindly upvote, if you like it!!!",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int ans=0;\\n        int [] arr1=new int[ratings.length];\\n        int [] arr2=new int[ratings.length];\\n        for(int i=0;i<ratings.length;i++){\\n            arr1[i]++;\\n            arr2[i]++;\\n        }\\n        for(int i=0;i<ratings.length-1;i++){\\n            if(ratings[i]>ratings[i+1] && arr1[i]<=arr1[i+1]){\\n                arr1[i]=arr1[i+1]+1;\\n            }\\n            else if(ratings[i]<ratings[i+1] && arr1[i]>=arr1[i+1]){\\n                arr1[i+1]=arr1[i]+1;\\n            }\\n        }\\n        for(int i=ratings.length-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1] && arr2[i]<=arr2[i+1]){\\n                arr2[i]=arr2[i+1]+1;\\n            }\\n            else if(ratings[i]<ratings[i+1] && arr2[i]>=arr2[i+1]){\\n                arr2[i+1]=arr2[i]+1;\\n            }\\n        }\\n        for(int i=0;i<ratings.length;i++){\\n            ans+=Math.max(arr1[i],arr2[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236153,
                "title": "c-easy-left-and-right-traversal",
                "content": "\\t *****please upvote if you like \\u2764\\uD83D\\uDE0D\\n\\t class Solution {\\n\\tpublic:\\n    int candy(vector<int>& ratings) {\\n      int n=ratings.size();\\n        vector<int>v1(n,1),v2(n,1),ans;\\n        for(int i=1;i<n;i++){  // left to right\\n            if(ratings[i]>ratings[i-1])\\n                v1[i]+=v1[i-1];\\n        }\\n         for(int i=n-2;i>=0;i--){// right to left\\n            if(ratings[i]>ratings[i+1])\\n                v2[i]+=v2[i+1];\\n        }\\n        for(int i=0;i<n;i++){\\n            ans.push_back(max(v1[i],v2[i]));// take maximum no of candy in left and right vector\\n        }\\n        return accumulate(ans.begin(),ans.end(),0);//sum of all candies\\n        \\n    }\\n\\t };",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int candy(vector<int>& ratings) {\\n      int n=ratings.size();\\n        vector<int>v1(n,1),v2(n,1),ans;\\n        for(int i=1;i<n;i++){  // left to right\\n            if(ratings[i]>ratings[i-1])\\n                v1[i]+=v1[i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2236101,
                "title": "rust-o-n-time-o-1-space-using-functional-paradigm-0-ms",
                "content": "This corresponds to the \"slope\" solution. \\n\\n`front` denotes the number of candies at the \"front\". What is the front? It depends on the slope:\\n- if the slope is increasing or plateau-ing, the front is just the number of candies to give to the next kid;\\n- if the slope is decreasing, the front is the bottom of the slope - which is always `1`.\\n\\n`top` denotes the number of candies at the top of the hill, which is the element that is joining the previous (increasing) slope and the next (decreasing) slope.\\n\\nWhen we are in a decreasing slope, we need to make sure that we are not giving more candies to the kids in this slope than to the kid at the top. To ensure this, we record the number of kids in the slope aka `dec_count`. If there are `dec_count` kids in the slope, it means we should have given `dec_count` candies to the right neighbour of the `top` kid. Thus, since the `top` kid needs to have strictly more candies, he will end up having `dec_count + 1`.\\n\\nImplementation-wise, when we enter the decreasing slope, the top kid has whatever number of candies he had to satisfy the previous slope. Then we slide down the slope, and we count the kids: whenever the top kid has less than the current number of kids + 1, we give him one more candy. The code can be confusing: keep in mind that, on the ith iteration, we are not computing the number to give to the ith kid based on the i - 1 kid: we are computing the number of candies to give to the i + 1 th kid, and correcting the total number of candies `res` a posteriori after we witness that there is one more kid in the slope, and the top kid had fewer candies than what he should have. In a nutshell, we are simply correcting our mistake on the top kid by giving him more candies as needed, 1 by 1.\\n\\nComplexity: O(n) time - O(1) space\\n\\n```\\nuse std::cmp::{self, Ordering};\\n\\npub fn candy(ratings: Vec<i32>) -> i32 {\\n        ratings\\n        .windows(2)\\n        .map(|x| x[0].cmp(&x[1]))\\n        .fold((1, 1, 1, 0), |(res, front, top, dec_count): (i32, i32, i32, i32), x| {\\n           match x {\\n            Ordering::Greater => {\\n                if top <= dec_count + 1 {\\n                    (res + dec_count + 1 + 1, 1, top + 1, dec_count + 1)\\n                } else {\\n                    (res + dec_count + 1, 1, top, dec_count + 1)\\n                }\\n            },\\n            Ordering::Equal => {\\n                (res + 1, 1, 1, 0)\\n            },\\n            Ordering::Less => {\\n                (res + front + 1, front + 1, front + 1, 0)\\n            }\\n           } \\n        })\\n        .0\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::{self, Ordering};\\n\\npub fn candy(ratings: Vec<i32>) -> i32 {\\n        ratings\\n        .windows(2)\\n        .map(|x| x[0].cmp(&x[1]))\\n        .fold((1, 1, 1, 0), |(res, front, top, dec_count): (i32, i32, i32, i32), x| {\\n           match x {\\n            Ordering::Greater => {\\n                if top <= dec_count + 1 {\\n                    (res + dec_count + 1 + 1, 1, top + 1, dec_count + 1)\\n                } else {\\n                    (res + dec_count + 1, 1, top, dec_count + 1)\\n                }\\n            },\\n            Ordering::Equal => {\\n                (res + 1, 1, 1, 0)\\n            },\\n            Ordering::Less => {\\n                (res + front + 1, front + 1, front + 1, 0)\\n            }\\n           } \\n        })\\n        .0\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2235477,
                "title": "c-array-greedy-easy-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n         int n = ratings.size();\\n        map<int,vector<int>> m;\\n        for(int i = 0;i<n;i++){\\n            m[ratings[i]].push_back(i);\\n        }\\n        vector<int> res(n,1);\\n        for(auto it : m){\\n            vector<int> index = it.second;\\n            int val = it.first;\\n            for(auto idx : index){\\n                int pre = (idx-1)<0?INT_MAX:ratings[idx-1];\\n                int preres = (idx-1)<0?INT_MIN:res[idx-1];\\n            \\n                int suc = (idx+1)>=n?INT_MAX:ratings[idx+1];\\n                int sucres = (idx+1)>=n?INT_MIN:res[idx+1];\\n            \\n                if(pre>val && suc>val) continue;\\n                if(pre<val && suc<val) res[idx] = max(preres,sucres)+1;\\n                else if(pre<val) res[idx] = preres+1;\\n                else if(suc<val) res[idx] = sucres+1;\\n            }\\n            \\n        }\\n        \\n        int ans = 0;\\n        for(auto it : res){\\n            ans += it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n         int n = ratings.size();\\n        map<int,vector<int>> m;\\n        for(int i = 0;i<n;i++){\\n            m[ratings[i]].push_back(i);\\n        }\\n        vector<int> res(n,1);\\n        for(auto it : m){\\n            vector<int> index = it.second;\\n            int val = it.first;\\n            for(auto idx : index){\\n                int pre = (idx-1)<0?INT_MAX:ratings[idx-1];\\n                int preres = (idx-1)<0?INT_MIN:res[idx-1];\\n            \\n                int suc = (idx+1)>=n?INT_MAX:ratings[idx+1];\\n                int sucres = (idx+1)>=n?INT_MIN:res[idx+1];\\n            \\n                if(pre>val && suc>val) continue;\\n                if(pre<val && suc<val) res[idx] = max(preres,sucres)+1;\\n                else if(pre<val) res[idx] = preres+1;\\n                else if(suc<val) res[idx] = sucres+1;\\n            }\\n            \\n        }\\n        \\n        int ans = 0;\\n        for(auto it : res){\\n            ans += it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234927,
                "title": "single-array-implementation-o-n-time-o-n-space-java",
                "content": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int candies[] = new int[n];\\n        candies[0] = 1;\\n        // left traversal to cover the left neighbour condition\\n        for(int i = 1; i < n; i ++)\\n        {\\n            candies[i] = 1;\\n            if(ratings[i - 1] < ratings[i])\\n            {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        \\n        // Right Traversal to cover the right neighbour\\n        for(int i = n - 1; i >=1 ; i--)\\n        {\\n            if(ratings[i - 1] > ratings[i] && candies[i-1] <= candies[i] )\\n            {\\n                candies[i - 1] = candies[i] + 1;\\n            }\\n        }\\n        int res = 0;\\n        for(int a: candies) res += a;\\n        return res;\\n    }\\n}\\n```\\n\\n**If you like Please Upvote the solution**\\n\\n**Feel Free to Suggest any optimization possible**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int candies[] = new int[n];\\n        candies[0] = 1;\\n        // left traversal to cover the left neighbour condition\\n        for(int i = 1; i < n; i ++)\\n        {\\n            candies[i] = 1;\\n            if(ratings[i - 1] < ratings[i])\\n            {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        \\n        // Right Traversal to cover the right neighbour\\n        for(int i = n - 1; i >=1 ; i--)\\n        {\\n            if(ratings[i - 1] > ratings[i] && candies[i-1] <= candies[i] )\\n            {\\n                candies[i - 1] = candies[i] + 1;\\n            }\\n        }\\n        int res = 0;\\n        for(int a: candies) res += a;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234683,
                "title": "priority-queue-solution",
                "content": "Although it takes more running time and space than optimal solution, thought of sharing it.\\n\\nThe approach I came up with was to assign candies first to give minimum rating candidates. Then we use it to give candidates to higher rated candidates.\\n\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>  pq;\\n        vector<int> v(ratings.size(), 1);\\n        int ans = 0;\\n        \\n        for ( int i = 0; i < ratings.size(); i++ ) pq.push( { ratings[i], i } );\\n        \\n        while ( !pq.empty() ) {\\n            \\n            int rate = pq.top().first, ind = pq.top().second;\\n            pq.pop();\\n            \\n            \\n            if ( ind < ratings.size() - 1 && ind > 0 && rate > ratings[ind - 1] && rate > ratings[ind + 1] ) {\\n                v[ind] = max(v[ind - 1], v[ind + 1]) + 1;\\n            } else if ( ind < ratings.size() - 1 && rate > ratings[ind + 1] ) {\\n                v[ind] = v[ind + 1] + 1;\\n            } else if ( ind > 0 && rate > ratings[ind - 1] ) {\\n                v[ind] = v[ind - 1] + 1;\\n            }\\n            \\n        }\\n        \\n        \\n        ans = accumulate(v.begin(), v.end(), 0);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>  pq;\\n        vector<int> v(ratings.size(), 1);\\n        int ans = 0;\\n        \\n        for ( int i = 0; i < ratings.size(); i++ ) pq.push( { ratings[i], i } );\\n        \\n        while ( !pq.empty() ) {\\n            \\n            int rate = pq.top().first, ind = pq.top().second;\\n            pq.pop();\\n            \\n            \\n            if ( ind < ratings.size() - 1 && ind > 0 && rate > ratings[ind - 1] && rate > ratings[ind + 1] ) {\\n                v[ind] = max(v[ind - 1], v[ind + 1]) + 1;\\n            } else if ( ind < ratings.size() - 1 && rate > ratings[ind + 1] ) {\\n                v[ind] = v[ind + 1] + 1;\\n            } else if ( ind > 0 && rate > ratings[ind - 1] ) {\\n                v[ind] = v[ind - 1] + 1;\\n            }\\n            \\n        }\\n        \\n        \\n        ans = accumulate(v.begin(), v.end(), 0);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122040,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Greedy***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        \\n        int n = ratings.size();\\n        \\n        vector<int> left(n, 1);\\n        \\n        vector<int> right(n, 1);\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(ratings[i] > ratings[i - 1])\\n            {\\n                left[i] += left[i - 1];\\n            }\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            if(ratings[i] > ratings[i + 1])\\n            {\\n                right[i] += right[i + 1];\\n            }\\n        }\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            count += max(left[i], right[i]);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        \\n        int n = ratings.size();\\n        \\n        vector<int> left(n, 1);\\n        \\n        vector<int> right(n, 1);\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(ratings[i] > ratings[i - 1])\\n            {\\n                left[i] += left[i - 1];\\n            }\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            if(ratings[i] > ratings[i + 1])\\n            {\\n                right[i] += right[i + 1];\\n            }\\n        }\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            count += max(left[i], right[i]);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481857,
                "title": "python-simple-solution-greedy-approach-forward-and-backward-iteration",
                "content": "```\\nclass Solution:\\n    def backwardDistribution(self, ratings, start, end, candies):\\n        # Assign the max of current candies and one more then the next student candies to the current student if ratings of current student is more then the ratings of next student.\\n        for i in range(end - 1, start - 1, -1):\\n            if ratings[i] > ratings[i + 1]:\\n                candies[i] = max(candies[i], candies[i + 1] + 1)\\n    \\n    def forwardDistribution(self, ratings, start, end, candies):\\n        # Assign 1 candy more then the previous student to the current student if the ratings of current student is more then the previous student.\\n        for i in range(start, end):\\n            if ratings[i] > ratings[i - 1]:\\n                candies[i] = candies[i - 1] + 1\\n\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        candies = [1] * n\\n        self.forwardDistribution(ratings, 1, n, candies)\\n        self.backwardDistribution(ratings, 0, n - 1, candies)\\n        return sum(candies)\\n```\\n\\n***If you likes the above solution the please upvote!***",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def backwardDistribution(self, ratings, start, end, candies):\\n        # Assign the max of current candies and one more then the next student candies to the current student if ratings of current student is more then the ratings of next student.\\n        for i in range(end - 1, start - 1, -1):\\n            if ratings[i] > ratings[i + 1]:\\n                candies[i] = max(candies[i], candies[i + 1] + 1)\\n    \\n    def forwardDistribution(self, ratings, start, end, candies):\\n        # Assign 1 candy more then the previous student to the current student if the ratings of current student is more then the previous student.\\n        for i in range(start, end):\\n            if ratings[i] > ratings[i - 1]:\\n                candies[i] = candies[i - 1] + 1\\n\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        candies = [1] * n\\n        self.forwardDistribution(ratings, 1, n, candies)\\n        self.backwardDistribution(ratings, 0, n - 1, candies)\\n        return sum(candies)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322217,
                "title": "java-solution-0ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        \\n        int[] candies = new int[ratings.length];\\n        \\n        for(int i=0; i<candies.length; i++) candies[i] = 1;\\n        \\n        for(int i=0; i<ratings.length-1; i++) {\\n            if(ratings[i+1]>ratings[i]) candies[i+1]=candies[i]+1;\\n        }\\n        \\n        for(int i=ratings.length-1; i>0; i--) {\\n            if(ratings[i-1]>ratings[i]) {\\n                if(candies[i-1]<candies[i]+1) candies[i-1]=candies[i]+1; \\n            }\\n        }\\n        \\n        int total = 0;\\n        \\n        for(int i=0; i<candies.length; i++) total+=candies[i];\\n        \\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        \\n        int[] candies = new int[ratings.length];\\n        \\n        for(int i=0; i<candies.length; i++) candies[i] = 1;\\n        \\n        for(int i=0; i<ratings.length-1; i++) {\\n            if(ratings[i+1]>ratings[i]) candies[i+1]=candies[i]+1;\\n        }\\n        \\n        for(int i=ratings.length-1; i>0; i--) {\\n            if(ratings[i-1]>ratings[i]) {\\n                if(candies[i-1]<candies[i]+1) candies[i-1]=candies[i]+1; \\n            }\\n        }\\n        \\n        int total = 0;\\n        \\n        for(int i=0; i<candies.length; i++) total+=candies[i];\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301435,
                "title": "python-solution",
                "content": "Hope it helps\\n\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        candies = [1] * n\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1]:\\n                candies[i] = candies[i - 1] + 1\\n        for i in range(n - 1, 0, -1):\\n            if ratings[i] < ratings[i - 1] and candies[i] >= candies[i - 1]:\\n                candies[i - 1] = candies[i] + 1\\n        return sum(candies)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        candies = [1] * n\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1]:\\n                candies[i] = candies[i - 1] + 1\\n        for i in range(n - 1, 0, -1):\\n            if ratings[i] < ratings[i - 1] and candies[i] >= candies[i - 1]:\\n                candies[i - 1] = candies[i] + 1\\n        return sum(candies)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300753,
                "title": "python",
                "content": "```\\ndef candy(self, ratings: List[int]) -> int:\\n        record = [1]*len(ratings)\\n        for i in range(1,len(ratings)):\\n            if ratings[i]>ratings[i-1]:\\n                record[i] = record[i-1]+1\\n\\n        for j in range(len(ratings)-2,-1,-1):\\n            if ratings[j]>ratings[j+1]:\\n                record[j] = max(record[j], record[j+1]+1)   \\n        return sum(record)",
                "solutionTags": [],
                "code": "```\\ndef candy(self, ratings: List[int]) -> int:\\n        record = [1]*len(ratings)\\n        for i in range(1,len(ratings)):\\n            if ratings[i]>ratings[i-1]:\\n                record[i] = record[i-1]+1\\n\\n        for j in range(len(ratings)-2,-1,-1):\\n            if ratings[j]>ratings[j+1]:\\n                record[j] = max(record[j], record[j+1]+1)   \\n        return sum(record)",
                "codeTag": "Python3"
            },
            {
                "id": 841226,
                "title": "c-o-n-52ms",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int>ans(ratings.size(),1);\\n        for(int i=1;i<ratings.size();i++)\\n            if(ratings[i]>ratings[i-1])\\n                ans[i]=ans[i-1]+1;\\n        for(int i=ratings.size()-2;i>=0;i--)\\n            if(ratings[i]>ratings[i+1])\\n                ans[i]=max(ans[i],ans[i+1]+1);\\n        int sum=0;\\n        for(int s:ans)\\n            sum+=s;\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int>ans(ratings.size(),1);\\n        for(int i=1;i<ratings.size();i++)\\n            if(ratings[i]>ratings[i-1])\\n                ans[i]=ans[i-1]+1;\\n        for(int i=ratings.size()-2;i>=0;i--)\\n            if(ratings[i]>ratings[i+1])\\n                ans[i]=max(ans[i],ans[i+1]+1);\\n        int sum=0;\\n        for(int s:ans)\\n            sum+=s;\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394961,
                "title": "simple-three-pass-javascript-solution-o-3n-o-n",
                "content": "This solution goes through the ratings array forward and sets the first value to 1, then if the next value is greater then its immidiate previous one, the candy allocated to that one is 1 greater than the previous. Then it iterates through the ratings array again, backward, in order to cover the values that were less than their previous value. This time, it sets the value to one greater than its previous if the ratings is higher, or to the current candy amount, whichever is larger. \\n\\nThen it goes through the candy array and sums up all of the values\\n\\n```\\nvar candy = function(ratings) {\\n    var candies = [], i;\\n    var currentNum = 1;\\n    candies[0] = 1; // set first value to 1\\n    for(i = 1; i < ratings.length; i++){\\n\\t\\t/* set value to one greater if greater than previous value, otherwise to 1 */\\n        if (ratings[i] > ratings[i-1]) currentNum++;\\n        else currentNum = 1;\\n        candies[i] = currentNum;\\n    }\\n    for(i = ratings.length - 2; i >= 0; i--){\\n\\t\\t/* set value to max of one greater than previous or to current value */\\n        if (ratings[i] > ratings[i+1]) currentNum++;\\n        else currentNum = 1;\\n        candies[i] = Math.max(currentNum, candies[i]);\\n    }\\n\\t/* return sum of all candies array */\\n    return candies.reduce(function(total, value){\\n        return total + value;\\n    });\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar candy = function(ratings) {\\n    var candies = [], i;\\n    var currentNum = 1;\\n    candies[0] = 1; // set first value to 1\\n    for(i = 1; i < ratings.length; i++){\\n\\t\\t/* set value to one greater if greater than previous value, otherwise to 1 */\\n        if (ratings[i] > ratings[i-1]) currentNum++;\\n        else currentNum = 1;\\n        candies[i] = currentNum;\\n    }\\n    for(i = ratings.length - 2; i >= 0; i--){\\n\\t\\t/* set value to max of one greater than previous or to current value */\\n        if (ratings[i] > ratings[i+1]) currentNum++;\\n        else currentNum = 1;\\n        candies[i] = Math.max(currentNum, candies[i]);\\n    }\\n\\t/* return sum of all candies array */\\n    return candies.reduce(function(total, value){\\n        return total + value;\\n    });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166568,
                "title": "very-simple-greedy-solution-python",
                "content": "```\\nclass Solution:\\n    def candy(self, ratings):\\n        candies = [1]*len(ratings)\\n        give(ratings, candies)\\n        ratings.reverse()\\n        candies.reverse()\\n        give(ratings, candies)\\n        return sum(candies)\\n\\ndef give(ratings, candies):\\n    for i in range(len(ratings)):\\n        if i > 0 and ratings[i] > ratings[i-1]:\\n            candies[i] = max(candies[i], candies[i-1] + 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings):\\n        candies = [1]*len(ratings)\\n        give(ratings, candies)\\n        ratings.reverse()\\n        candies.reverse()\\n        give(ratings, candies)\\n        return sum(candies)\\n\\ndef give(ratings, candies):\\n    for i in range(len(ratings)):\\n        if i > 0 and ratings[i] > ratings[i-1]:\\n            candies[i] = max(candies[i], candies[i-1] + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157649,
                "title": "java-one-pass-o-1-space-easy-to-understand-version",
                "content": "If you draw all the rating points on a graph, there are peaks and bottoms and apparently:\\n\\n1. All the bottoms should be given 1 candy in the final result.\\n2. The neighbors of the bottoms should be given 1 more candy as we move from bottom point to peak point.\\n\\nFor example if you have an array [1,2,4,3,2,1], bottoms are the 1s on both sides and the peak is 4, both 1s should be given 1 candy and their neighbors 2s should be given 1+1=2 candies. Likewise, 3 should be given 2+1=3 candies and 4 which is the peak should be given 4 candies. If we know the lengths from the peak to bottom on both sides, we can figure out how many candies should be given to the peak (Math.max(left, right)) and the total candies needed for the array. For the above example, the length on the left is 2 ([1,2] peak not included) and length on the right is 3([3,2,1] peak not included), thus the peak should be assign Math.max(left, right)+1 candies and the total candies needed for the array will be (1+left)*left/2 + (1+right)*right/2 + peak. In the codes below, we minus it by 1 because the left bottom was calculated once in the previous round.\\n\\nIn real test cases, we can have array with multiple peaks and bottoms. For example: [1,2,4,3,2,1,5,6,9,4,2]. In this case, we just split the array by the bottoms and calculate each sub arr and merge the result. \\n[1,2,4,3,2,1,5,6,9,4,2] -> [1,2,4,3,2,1] and [1,5,6,9,4,2]\\nFor rating with same value, we just add 1 to the result.\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        if(ratings == null || ratings.length == 0) return 0;\\n        int n = ratings.length;\\n        int i = 0;\\n        int s = 0; //record the start index of the left and right sides of the peaks\\n        int sum = 1; //initialize as 1 because in each round we minus 1 for the left bottom \\n                   //since it was calculated once in the previous round\\n        while(i < n-1){\\n            //calculate the length from bottom -> peak on the left side of peak point, peak not included\\n            while(i < n-1 && ratings[i+1] > ratings[i]){\\n                i++;\\n            }\\n            int left = i-s;\\n            s = i;\\n            //calculate the length from peak-> bottom on the right side of peak point, peak not included\\n            while(i < n-1 && ratings[i+1] < ratings[i]){\\n                i++;\\n            }\\n            int right = i-s;\\n            s = i;\\n            //calculate the candies that needs to be assign to the peak\\n            int max = Math.max(left, right)+1;\\n            //total candies needed for current bottom->peak->bottom sub array\\n            sum += (1+left)*left/2+(1+right)*right/2+max-1;\\n            //skip points that have same value, increase i and final result by 1\\n            while(i < n-1 && ratings[i+1] == ratings[i]){\\n                i++;\\n                sum++;\\n            }\\n            s = i;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        if(ratings == null || ratings.length == 0) return 0;\\n        int n = ratings.length;\\n        int i = 0;\\n        int s = 0; //record the start index of the left and right sides of the peaks\\n        int sum = 1; //initialize as 1 because in each round we minus 1 for the left bottom \\n                   //since it was calculated once in the previous round\\n        while(i < n-1){\\n            //calculate the length from bottom -> peak on the left side of peak point, peak not included\\n            while(i < n-1 && ratings[i+1] > ratings[i]){\\n                i++;\\n            }\\n            int left = i-s;\\n            s = i;\\n            //calculate the length from peak-> bottom on the right side of peak point, peak not included\\n            while(i < n-1 && ratings[i+1] < ratings[i]){\\n                i++;\\n            }\\n            int right = i-s;\\n            s = i;\\n            //calculate the candies that needs to be assign to the peak\\n            int max = Math.max(left, right)+1;\\n            //total candies needed for current bottom->peak->bottom sub array\\n            sum += (1+left)*left/2+(1+right)*right/2+max-1;\\n            //skip points that have same value, increase i and final result by 1\\n            while(i < n-1 && ratings[i+1] == ratings[i]){\\n                i++;\\n                sum++;\\n            }\\n            s = i;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42828,
                "title": "40-ms-cpp-dp-solution",
                "content": "    class Solution {\\n        vector<int> dp;\\n        int min_candy(int k,vector<int>& ratings){\\n            dp[k]=1;\\n            if(k>0 && ratings[k]>ratings[k-1]) dp[k] = max(dp[k],(dp[k-1]>0?dp[k-1]:min_candy(k-1,ratings))+1);\\n            if(k<ratings.size()-1 && ratings[k]>ratings[k+1]) dp[k] = max(dp[k],(dp[k+1]>0?dp[k+1]:min_candy(k+1,ratings))+1);\\n            return dp[k];\\n        }\\n    public:\\n        int candy(vector<int>& ratings) {\\n            if(ratings.empty()) return 0;\\n            dp.assign(ratings.size(),0);\\n            int sum = 0;\\n            for(int i=0;i<ratings.size();i++) sum += dp[i]>0?dp[i]:min_candy(i,ratings);\\n            return sum;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        vector<int> dp;\\n        int min_candy(int k,vector<int>& ratings){\\n            dp[k]=1;\\n            if(k>0 && ratings[k]>ratings[k-1]) dp[k] = max(dp[k],(dp[k-1]>0?dp[k-1]:min_candy(k-1,ratings))+1);\\n            if(k<ratings.size()-1 && ratings[k]>ratings[k+1]) dp[k] = max(dp[k],(dp[k+1]>0?dp[k+1]:min_candy(k+1,ratings))+1);\\n            return dp[k];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 42836,
                "title": "o-n-time-constant-space-beats-90-in-c",
                "content": "\\n    if (ratings.size() <= 1) return ratings.size();\\n        int left=0, right=0, pos=0, n=ratings.size(), sum=0;\\n        while(left < n) {\\n        \\tint i, lval = 1, rval;\\n        \\tif(left!=0 && ratings[left]>ratings[left-1]) lval++;\\n        \\tfor(i = left+1; i<n && ratings[i]>ratings[i-1]; i++) {// gradient increase\\n        \\t\\tsum += lval;\\n        \\t\\tif (ratings[i] > ratings[i-1]) lval++;\\n        \\t}\\n        \\tpos = --i; // find local max\\n        \\tfor(right = i+1; right<n && ratings[right]<ratings[right-1]; right++); // gradient decrease\\n        \\tright--; // right point to the last local decrease element\\n        \\tfor(i = right, rval = 1; i > pos; i--) {\\n        \\t\\tsum += rval;\\n        \\t\\tif (ratings[i] < ratings[i-1]) {\\n        \\t\\t\\trval++;\\n        \\t\\t}\\n        \\t}\\n        \\tsum += max(max(lval, rval), 1);\\n        \\tleft = right+1;\\n        }\\n        return sum;\\n\\nI know my code may look ugly... =\\u3002=",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "\\n    if (ratings.size() <= 1) return ratings.size();\\n        int left=0, right=0, pos=0, n=ratings.size(), sum=0;\\n        while(left < n) {\\n        \\tint i, lval = 1, rval;\\n        \\tif(left!=0 && ratings[left]>ratings[left-1]) lval++;\\n        \\tfor(i = left+1; i<n && ratings[i]>ratings[i-1]; i++) {// gradient increase\\n        \\t\\tsum += lval;\\n        \\t\\tif (ratings[i] > ratings[i-1]) lval++;\\n        \\t}\\n        \\tpos = --i; // find local max\\n        \\tfor(right = i+1; right<n && ratings[right]<ratings[right-1]; right++); // gradient decrease\\n        \\tright--; // right point to the last local decrease element\\n        \\tfor(i = right, rval = 1; i > pos; i--) {\\n        \\t\\tsum += rval;\\n        \\t\\tif (ratings[i] < ratings[i-1]) {\\n        \\t\\t\\trval++;\\n        \\t\\t}\\n        \\t}\\n        \\tsum += max(max(lval, rval), 1);\\n        \\tleft = right+1;\\n        }\\n        return sum;\\n\\nI know my code may look ugly... =\\u3002=",
                "codeTag": "Unknown"
            },
            {
                "id": 42841,
                "title": "5ms-o-n-ac-solution-with-comments",
                "content": "public int candy(int[] ratings) {\\n\\t\\n\\tint candies[] = new int[ratings.length];\\n\\tcandies[0] = 1;//no need to initialize whole array, we only need the first for the first pass\\n\\n\\t// left to right\\n\\tfor (int i = 1; i < ratings.length; i++) {\\n\\t    // left neighbor\\n\\t    if (ratings[i - 1] < ratings[i])\\n\\t\\tcandies[i] = candies[i - 1] + 1;\\n\\t    else\\n\\t\\tcandies[i] = 1;\\n\\t}\\n\\n\\tint candy = candies[ratings.length - 1]; // second pass, now we add up the candies for the return value\\n\\n\\t// right to left\\n\\tfor (int i = ratings.length - 2; i >= 0; i--) {\\n\\t    // right neighbor\\n\\t    if (ratings[i + 1] < ratings[i] && (candies[i] < candies[i + 1] + 1))//right neighbor could have lower have less candy than i already has\\n\\t\\tcandies[i] = candies[i + 1] + 1;\\n\\n\\t    candy += candies[i];\\n\\t}\\n\\treturn candy;\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int candy(int[] ratings) {\\n\\t\\n\\tint candies[] = new int[ratings.length];\\n\\tcandies[0] = 1;//no need to initialize whole array, we only need the first for the first pass\\n\\n\\t// left to right\\n\\tfor (int i = 1; i < ratings.length; i++) {\\n\\t    // left neighbor\\n\\t    if (ratings[i - 1] < ratings[i])\\n\\t\\tcandies[i] = candies[i - 1] + 1;\\n\\t    else\\n\\t\\tcandies[i] = 1;\\n\\t}\\n\\n\\tint candy = candies[ratings.length - 1]; // second pass, now we add up the candies for the return value\\n\\n\\t// right to left\\n\\tfor (int i = ratings.length - 2; i >= 0; i--) {\\n\\t    // right neighbor\\n\\t    if (ratings[i + 1] < ratings[i] && (candies[i] < candies[i + 1] + 1))//right neighbor could have lower have less candy than i already has\\n\\t\\tcandies[i] = candies[i + 1] + 1;\\n\\n\\t    candy += candies[i];\\n\\t}\\n\\treturn candy;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 42892,
                "title": "simple-2-pass-python-code",
                "content": "Never take some guess for granted!\\n[1, 2, 2] is not 5, should be 4!\\n\\nUseq/Dseq stores one should have ?+1 candies since he/her has higher rating than left/right neighbor!\\n\\n    class Solution:\\n        # @param {integer[]} ratings\\n        # @return {integer}\\n        def candy(self, ratings):\\n            n = len(ratings)\\n            Useq = [0 for i in range(n)]\\n            for i in xrange(1, n):\\n                if ratings[i]>ratings[i-1]:\\n                    Useq[i] = Useq[i-1]+1\\n            \\n            Dseq = [0 for i in range(n)]\\n            for i in xrange(n-2, -1, -1):  #from i = n-2, ... 1, 0 ## will not reach -1!!\\n                if ratings[i]>ratings[i+1]:\\n                    Dseq[i] = Dseq[i+1]+1\\n            \\n            candies = [max(Useq[i], Dseq[i])+1 for i in range(n)]\\n            return sum(candies)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 42910,
                "title": "share-an-alternative-solution-by-using-a-stack",
                "content": "Though the smartest solution to this problem is the two-pass solution, I have come up with a stack-based solution which requires O(n) space. It can be further optimized to eliminate the stack structure.\\n\\nThe idea is as follows: assign as few candies as possible. First assign 1 candy to the first kid, then go through the kid one by one. If we encounter kids in increasing rating value, we simply increment the candy number for each kid and we are done. But if we encounter kids in decreasing rating value, we need to fix previous candy values to avoid zero or negative candies to the current kid. Thus I use a stack to keep track of the kids with decreasing ratings, so that we can give more candies to them when the 2nd requirement is violated. I use a subroutine `clearStack` to count the actual number of candies required for these kids. For each kid, there are three cases:\\n\\n1. current kid has higher rating than previous kid: in this case, we assign one more candy to this kid. Also pop all previous kids out (and count candies for them), and push current kid's candy number\\n2. current kid has equal rating to previous kid: we just assign 1 candy to this kid. Use the same stack operation as 1.\\n3. current kid has less rating to previous kid: we also assign only 1 candy to this kid temporarily, and push it to stack (to be fixed later)\\n\\nI also use a sentinel in the end of ratings to trigger `clearStack` at the last element.\\n\\nCode is as follows:\\n\\n\\n    class Solution {\\n    public:\\n        int candy(vector<int>& ratings) {\\n            ratings.insert(ratings.end(), INT_MAX); //sentinel at the end\\n            \\n            int n = ratings.size();\\n            if(n <= 1) return n; //corner cases\\n            \\n            int sum(0); //total number of candies\\n            int curr(0); //number of candies for current kid\\n            \\n            stack<int> s;\\n            s.push(1); //candy for the first kid\\n            for(int k = 1; k < n; ++k) {\\n                if(ratings[k] >= ratings[k-1]) { //current higher or equal than previous\\n                    if(ratings[k] == ratings[k-1]) curr = 1; \\n                    else curr = s.top()+1;\\n                    sum += clearStack(s); //count all previous\\n                    s.push(curr); //push current candy number in stack (don't count yet)\\n                } else { //lower than previous\\n                    s.push(1); //just give one candy to this kid, don't count yet\\n                }\\n            }\\n    \\n            return sum;\\n        }\\n        \\n        //count the actual number of candies of kids in the stack\\n        int clearStack(stack<int>& s) {\\n            int sum = 0;\\n            int curr(0), last(0);\\n            while(!s.empty()) {\\n                int curr = s.top(); s.pop();\\n                if(curr <= last) curr = last+1;\\n                sum += curr;\\n                last = curr;\\n            }\\n            return sum;\\n        }\\n    };",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n    public:\\n        int candy(vector<int>& ratings) {\\n            ratings.insert(ratings.end(), INT_MAX); //sentinel at the end\\n            \\n            int n = ratings.size();\\n            if(n <= 1) return n; //corner cases\\n            \\n            int sum(0); //total number of candies\\n            int curr(0); //number of candies for current kid\\n            \\n            stack<int> s;\\n            s.push(1); //candy for the first kid\\n            for(int k = 1; k < n; ++k) {\\n                if(ratings[k] >= ratings[k-1]) { //current higher or equal than previous\\n                    if(ratings[k] == ratings[k-1]) curr = 1; \\n                    else curr = s.top()+1;\\n                    sum += clearStack(s); //count all previous\\n                    s.push(curr); //push current candy number in stack (don't count yet)\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 42914,
                "title": "c-o-n-solution",
                "content": "    class Solution {\\n    public:\\n        int candy(vector<int> &ratings) {\\n            int sz=ratings.size();\\n            vector<int> scan0(sz);\\n            vector<int> scan1(sz);\\n            \\n            scan0[0] = 1; scan1[sz-1] = 1;\\n            for (int i=1; i<sz; i++) {\\n                scan0[i] = (ratings[i]>ratings[i-1] ? scan0[i-1]+1 : 1);\\n                scan1[sz-1-i] = (ratings[sz-1-i]>ratings[sz-i] ? scan1[sz-i]+1 : 1);\\n            }\\n            int sum = 0;\\n            for (int i=0; i<sz; i++) {\\n                sum += max(scan0[i], scan1[i]);\\n            }\\n            \\n            return sum;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int candy(vector<int> &ratings) {\\n            int sz=ratings.size();\\n            vector<int> scan0(sz);\\n            vector<int> scan1(sz);\\n            \\n            scan0[0] = 1; scan1[sz-1] = 1;\\n            for (int i=1; i<sz; i++) {\\n                scan0[i] = (ratings[i]>ratings[i-1] ? scan0[i-1]+1 : 1);\\n                scan1[sz-1-i] = (ratings[sz-1-i]>ratings[sz-i] ? scan1[sz-i]+1 : 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4040643,
                "title": "candy-c-solution",
                "content": "# Approach\\nTwo Pass Approach\\n\\nSteps\\n\\nInitialize variables:\\nn is number of children.\\ncandies to store candies for each child..\\n\\nFirst Pass (Left to Right):\\nFor each child, check if the previous child has a lower rating and has more or equal candies.\\nIf true, give the current child one more candy than the previous child.\\n\\nSecond Pass (Right to Left):\\nFor each child, check if the next child has a lower rating and has more or equal candies.\\n\\nIf true, give the current child one more candy than the next child.\\nCalculate and return totalCandies.\\nComplexity\\n\\n# Complexity\\n- Time complexity: O(N)O(N)O(N)\\nSince we are looping over the ratings array twice then the time complexity is 2*N which is O(N).\\n\\n- Space complexity: O(N)O(N)O(N)\\nSince we are storing the number of candies for each child then the space complexity is O(N).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        \\n        vector<int> candies(n, 1); \\n        \\n        for(int i = 1; i < n; i++){\\n            if(ratings[i - 1] < ratings[i] && candies[i - 1] >= candies[i]){\\n            \\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--){\\n            if(ratings[i + 1] < ratings[i] && candies[i + 1] >= candies[i]){\\n            \\n                candies[i] = candies[i + 1] + 1;\\n            }\\n        }\\n        \\n        int totalCandies = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            totalCandies += candies[i];\\n        }\\n        \\n        return totalCandies;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        \\n        vector<int> candies(n, 1); \\n        \\n        for(int i = 1; i < n; i++){\\n            if(ratings[i - 1] < ratings[i] && candies[i - 1] >= candies[i]){\\n            \\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--){\\n            if(ratings[i + 1] < ratings[i] && candies[i + 1] >= candies[i]){\\n            \\n                candies[i] = candies[i + 1] + 1;\\n            }\\n        }\\n        \\n        int totalCandies = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            totalCandies += candies[i];\\n        }\\n        \\n        return totalCandies;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040505,
                "title": "python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def candy(self, rating: List[int]) -> int:\\n        cand=[1]*len(rating)\\n        for i in range(1,len(cand)):\\n            if rating[i]>rating[i-1]:\\n                if cand[i]<=cand[i-1]:\\n                    cand[i]=max(cand[i],cand[i-1]+1)\\n        print(cand)\\n        for i in range(len(cand)-2, -1, -1):\\n            if rating[i]>rating[i+1]:\\n                if cand[i]<=cand[i+1]:\\n                    cand[i]=max(cand[i],cand[i+1]+1)\\n        print(cand)\\n        return sum(cand)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, rating: List[int]) -> int:\\n        cand=[1]*len(rating)\\n        for i in range(1,len(cand)):\\n            if rating[i]>rating[i-1]:\\n                if cand[i]<=cand[i-1]:\\n                    cand[i]=max(cand[i],cand[i-1]+1)\\n        print(cand)\\n        for i in range(len(cand)-2, -1, -1):\\n            if rating[i]>rating[i+1]:\\n                if cand[i]<=cand[i+1]:\\n                    cand[i]=max(cand[i],cand[i+1]+1)\\n        print(cand)\\n        return sum(cand)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040195,
                "title": "one-pass-betch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n You can really put two brain cells together to see that two loops are running same number of times, just one forward and one backward, so we can fit that into one loop and not be a betch about it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe basic thing is whenever we see any rating of a child with higher rating than neighbour, we need on more candy than that neighbour, if not that child is already getting more, so we store the maximized value of candies for each child in the vector. Lastly, we return the sum with a little accumulate function and save ourselves from being a betch again by nothaving to write another 3-4 lines of code.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the number of children in your basement.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ an extra array to calculate the result, technically the array is the result, but sneekily these mfs asked for the sum only, so this array counts as extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& r) {\\n        int n=r.size();vector<int> v(n,1);\\n        for(int i=1;i<n;i++){   int j=n-i-1;\\n            if(r[i]>r[i-1]) v[i]=max(v[i],v[i-1]+1);\\n            if(r[j]>r[j+1]) v[j]=max(v[j],v[j+1]+1);\\n        }return(accumulate(v.begin(),v.end(),0));\\n    }\\n};\\n```\\n\\n_**UPVOTE IF NOT BETCH**_",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& r) {\\n        int n=r.size();vector<int> v(n,1);\\n        for(int i=1;i<n;i++){   int j=n-i-1;\\n            if(r[i]>r[i-1]) v[i]=max(v[i],v[i-1]+1);\\n            if(r[j]>r[j+1]) v[j]=max(v[j],v[j+1]+1);\\n        }return(accumulate(v.begin(),v.end(),0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039284,
                "title": "c-simple-two-loops-o-n",
                "content": "\\n# Approach\\n**two loops**\\nThe first loop from left to right, starting from the ratings[1], ensures children with a higher rating get more candy than its left neighbor.\\nThe second loop from right to left, starting from the ratings[size - 2], ensures that each children with a higher rating get more candy than its right neighbor.\\n\\n**extra check** \\nEach comparison also needs to check whether the candy has met the conditions, otherwise there may be a situation where the current number of candies decreases while hoping increase. For example:\\n\\nratings[1,2,3,4,5,2] after first loop, the candy should be [1,2,3,4,5,1]. Then during the second loop, we find 5 > 2, and try to make candy[4] = candy[5] + 1 = 2, but that will change the results of the first loop. In fact candy[4] = 5 just meet the requirement, so we continue.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int> candy(ratings.size(), 1);\\n        for(int i = 1; i < ratings.size(); i++) {\\n            if(ratings[i] > ratings[i - 1]) {\\n                candy[i] = candy[i - 1] + 1;\\n            }\\n        }\\n        for(int i = ratings.size() - 2; i > -1; i--) {\\n            if(ratings[i] > ratings[i + 1] && candy[i] <= candy[i + 1]) {\\n                candy[i] = candy[i + 1] + 1;\\n            } \\n        }\\n        return accumulate(candy.begin(), candy.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int> candy(ratings.size(), 1);\\n        for(int i = 1; i < ratings.size(); i++) {\\n            if(ratings[i] > ratings[i - 1]) {\\n                candy[i] = candy[i - 1] + 1;\\n            }\\n        }\\n        for(int i = ratings.size() - 2; i > -1; i--) {\\n            if(ratings[i] > ratings[i + 1] && candy[i] <= candy[i + 1]) {\\n                candy[i] = candy[i + 1] + 1;\\n            } \\n        }\\n        return accumulate(candy.begin(), candy.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038405,
                "title": "o-n-beginner-friendly-100-beats-fully-explained",
                "content": "# Intuition\\nThe problem requires distributing candies to a line of children based on their ratings while satisfying two conditions: each child must have at least one candy, and children with higher ratings should get more candies than their neighbors. To minimize the total number of candies, we can follow a simple approach that ensures these conditions are met.\\n\\n# Approach\\nWe can start by initializing an array `candies` to keep track of the number of candies each child receives. We\\'ll initialize all elements of `candies` to 1 since each child must have at least one candy.\\n\\nWe then iterate through the ratings array from left to right, and for each child `i`, we compare their rating with the rating of the previous child (`i-1`). If the current child has a higher rating, we give them one more candy than the previous child by setting `candies[i] = candies[i-1] + 1`. If not, we leave their candy count as 1.\\n\\nNext, we iterate through the ratings array from right to left, and for each child `i`, we compare their rating with the rating of the next child (`i+1`). If the current child has a higher rating and has fewer or equal candies than the next child, we update their candy count to be one more than the next child\\'s candy count by setting `candies[i] = candies[i+1] + 1`.\\n\\nFinally, we calculate the total number of candies by summing up all the elements in the `candies` array.\\n\\nThis approach ensures that both conditions are met, and it minimizes the total number of candies required.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - We iterate through the ratings array twice, once from left to right and once from right to left, where n is the number of children.\\n- Space complexity: $$O(n)$$ - We use an additional array `candies` of size n to store the number of candies for each child.\\n\\n# Code\\n```java\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] candies = new int[n];\\n        candies[0] = 1;\\n\\n        // First pass: Left to right\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            } else {\\n                candies[i] = 1;\\n            }\\n        }\\n\\n        // Second pass: Right to left\\n        int totalCandies = candies[n - 1];\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\\n                candies[i] = candies[i + 1] + 1;\\n            }\\n            totalCandies += candies[i];\\n        }\\n\\n        return totalCandies;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```java\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] candies = new int[n];\\n        candies[0] = 1;\\n\\n        // First pass: Left to right\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            } else {\\n                candies[i] = 1;\\n            }\\n        }\\n\\n        // Second pass: Right to left\\n        int totalCandies = candies[n - 1];\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\\n                candies[i] = candies[i + 1] + 1;\\n            }\\n            totalCandies += candies[i];\\n        }\\n\\n        return totalCandies;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038303,
                "title": "easy-python-java-c-javascript-c-100",
                "content": "\\n```Python []\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        if n <= 1:\\n            return n\\n\\n        nums = [1] * n\\n\\n        # Make sure children with a higher rating get more candy than their left neighbor\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1]:\\n                nums[i] += nums[i - 1]\\n\\n    # Make sure children with a higher rating get more candy than their right neighbor\\n        for i in range(n - 1, 0, -1):\\n            if ratings[i - 1] > ratings[i]:\\n                nums[i - 1] = max(nums[i] + 1, nums[i - 1])\\n\\n        candies = sum(nums)\\n\\n        return candies\\n```\\n```Java []\\nint n = ratings.length;\\n        if (n <= 1) return n;\\n\\n        int[] nums = new int[n];\\n        Arrays.fill(nums, 1);\\n\\n        // Make sure children with a higher rating get more candy than their left neighbor\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                nums[i] += nums[i - 1];\\n            }\\n        }\\n\\n        // Make sure children with a higher rating get more candy than their right neighbor\\n        for (int i = n - 1; i > 0; i--) {\\n            if (ratings[i - 1] > ratings[i]) {\\n                nums[i - 1] = Math.max(nums[i] + 1, nums[i - 1]);\\n            }\\n        }\\n\\n        int candies = 0;\\n        for (int e : nums) {\\n            candies += e;\\n        }\\n\\n        return candies;\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        if(n <= 1) return n;\\n\\n        vector<int> nums( n , 1);\\n        // make sure children with a higher rating gets more candy than its left neighbour\\n        for(int i =1 ; i< n ; i++){\\n            if(ratings[i] > ratings[i-1]){\\n                nums[i]+=nums[i-1];\\n            }\\n        }\\n        // make sure children with higher rating get more candy than its right neighbour\\n        for(int i = n-1 ; i>0 ; i--){\\n            if(ratings[i-1] > ratings[i]){\\n                nums[i-1] = max(nums[i]+1 , nums[i-1]);\\n            }\\n        }\\n\\n        int candies = 0;\\n\\n        for(auto e : nums) candies+=e;\\n\\n        return candies;\\n    }\\n};\\n```\\n```JavaScript []\\nconst n = ratings.length;\\n    if (n <= 1) return n;\\n\\n    const nums = new Array(n).fill(1);\\n\\n    // Make sure children with a higher rating get more candy than their left neighbor\\n    for (let i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) {\\n            nums[i] += nums[i - 1];\\n        }\\n    }\\n\\n    // Make sure children with higher rating get more candy than their right neighbor\\n    for (let i = n - 1; i > 0; i--) {\\n        if (ratings[i - 1] > ratings[i]) {\\n            nums[i - 1] = Math.max(nums[i] + 1, nums[i - 1]);\\n        }\\n    }\\n\\n    let candies = 0;\\n\\n    for (const e of nums) {\\n        candies += e;\\n    }\\n\\n    return candies;\\n```\\n```C# []\\n int n = ratings.Length;\\n    if (n <= 1) return n;\\n\\n    int[] nums = new int[n];\\n    for (int i = 0; i < n; i++)\\n    {\\n        nums[i] = 1;\\n    }\\n\\n    // Make sure children with a higher rating get more candy than their left neighbor\\n    for (int i = 1; i < n; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1])\\n        {\\n            nums[i] += nums[i - 1];\\n        }\\n    }\\n\\n    // Make sure children with higher rating get more candy than their right neighbor\\n    for (int i = n - 1; i > 0; i--)\\n    {\\n        if (ratings[i - 1] > ratings[i])\\n        {\\n            nums[i - 1] = Math.Max(nums[i] + 1, nums[i - 1]);\\n        }\\n    }\\n\\n    int candies = 0;\\n    foreach (int e in nums)\\n    {\\n        candies += e;\\n    }\\n\\n    return candies;\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "```Python []\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        if n <= 1:\\n            return n\\n\\n        nums = [1] * n\\n\\n        # Make sure children with a higher rating get more candy than their left neighbor\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1]:\\n                nums[i] += nums[i - 1]\\n\\n    # Make sure children with a higher rating get more candy than their right neighbor\\n        for i in range(n - 1, 0, -1):\\n            if ratings[i - 1] > ratings[i]:\\n                nums[i - 1] = max(nums[i] + 1, nums[i - 1])\\n\\n        candies = sum(nums)\\n\\n        return candies\\n```\n```Java []\\nint n = ratings.length;\\n        if (n <= 1) return n;\\n\\n        int[] nums = new int[n];\\n        Arrays.fill(nums, 1);\\n\\n        // Make sure children with a higher rating get more candy than their left neighbor\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                nums[i] += nums[i - 1];\\n            }\\n        }\\n\\n        // Make sure children with a higher rating get more candy than their right neighbor\\n        for (int i = n - 1; i > 0; i--) {\\n            if (ratings[i - 1] > ratings[i]) {\\n                nums[i - 1] = Math.max(nums[i] + 1, nums[i - 1]);\\n            }\\n        }\\n\\n        int candies = 0;\\n        for (int e : nums) {\\n            candies += e;\\n        }\\n\\n        return candies;\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        if(n <= 1) return n;\\n\\n        vector<int> nums( n , 1);\\n        // make sure children with a higher rating gets more candy than its left neighbour\\n        for(int i =1 ; i< n ; i++){\\n            if(ratings[i] > ratings[i-1]){\\n                nums[i]+=nums[i-1];\\n            }\\n        }\\n        // make sure children with higher rating get more candy than its right neighbour\\n        for(int i = n-1 ; i>0 ; i--){\\n            if(ratings[i-1] > ratings[i]){\\n                nums[i-1] = max(nums[i]+1 , nums[i-1]);\\n            }\\n        }\\n\\n        int candies = 0;\\n\\n        for(auto e : nums) candies+=e;\\n\\n        return candies;\\n    }\\n};\\n```\n```JavaScript []\\nconst n = ratings.length;\\n    if (n <= 1) return n;\\n\\n    const nums = new Array(n).fill(1);\\n\\n    // Make sure children with a higher rating get more candy than their left neighbor\\n    for (let i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) {\\n            nums[i] += nums[i - 1];\\n        }\\n    }\\n\\n    // Make sure children with higher rating get more candy than their right neighbor\\n    for (let i = n - 1; i > 0; i--) {\\n        if (ratings[i - 1] > ratings[i]) {\\n            nums[i - 1] = Math.max(nums[i] + 1, nums[i - 1]);\\n        }\\n    }\\n\\n    let candies = 0;\\n\\n    for (const e of nums) {\\n        candies += e;\\n    }\\n\\n    return candies;\\n```\n```C# []\\n int n = ratings.Length;\\n    if (n <= 1) return n;\\n\\n    int[] nums = new int[n];\\n    for (int i = 0; i < n; i++)\\n    {\\n        nums[i] = 1;\\n    }\\n\\n    // Make sure children with a higher rating get more candy than their left neighbor\\n    for (int i = 1; i < n; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1])\\n        {\\n            nums[i] += nums[i - 1];\\n        }\\n    }\\n\\n    // Make sure children with higher rating get more candy than their right neighbor\\n    for (int i = n - 1; i > 0; i--)\\n    {\\n        if (ratings[i - 1] > ratings[i])\\n        {\\n            nums[i - 1] = Math.Max(nums[i] + 1, nums[i - 1]);\\n        }\\n    }\\n\\n    int candies = 0;\\n    foreach (int e in nums)\\n    {\\n        candies += e;\\n    }\\n\\n    return candies;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038055,
                "title": "c-easy-solution",
                "content": "# Intuition\\nWe will approach it using greedy.We wil distribut one candy to each and then according to condition given in que we will increase the required candy.\\n\\n\\n# Approach\\n We will start by declaring two array left_to_right and right_to_left\\nFirst we will travel from left to right fillling our array with the number of candy we are giving to ith child..Now here we need to see the child with more rating should get more candy than their neighbour we satisfied this for left neighbour but we need to check for right neighbour also maybe they have more candy so we need to update it accordingly..You would have used only single array and updated that but creating different array gives more clear idea. We wil travel form right to left and will fill the another array satisfying the condition given in que. After it for each index we will take max from both array as we need to make sure higher rating child get higher candy compared to its both left and rightr neighbour./\\n\\n# Complexity\\n- Time complexity:\\n0(n) where n is size of given ratings\\n\\n- Space complexity:\\n0(n) for two n sized array \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> left_to_right(n,1);\\n        vector<int> right_to_left(n,1);\\n       \\n        for(int i =1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                left_to_right[i] =left_to_right[i-1]+1;\\n            }\\n        }\\n          for(int i =n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                right_to_left[i] =right_to_left[i+1]+1;\\n            }\\n        }\\n\\n        int ans =0;\\n\\n        for(int i =0;i<n;i++){\\n           ans = ans+max(right_to_left[i],left_to_right[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> left_to_right(n,1);\\n        vector<int> right_to_left(n,1);\\n       \\n        for(int i =1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                left_to_right[i] =left_to_right[i-1]+1;\\n            }\\n        }\\n          for(int i =n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                right_to_left[i] =right_to_left[i+1]+1;\\n            }\\n        }\\n\\n        int ans =0;\\n\\n        for(int i =0;i<n;i++){\\n           ans = ans+max(right_to_left[i],left_to_right[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038017,
                "title": "greedy-very-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nApproach is Very Simple:-\\n- Firstly handle Rating[i]>Rating[i+1]\\n- Now handle     Rating[i-1]>Rating[i]\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& arr) {\\n      int n = arr.size(),ans = 0;\\n      vector<int> candies(n,1);\\n\\n      for(int i = 1;i<n;i++)\\n      {\\n        if(arr[i]>arr[i-1])\\n        candies[i] = candies[i-1]+1;\\n      }\\n      for(int i = n-1;i>0;i--)\\n      {\\n        if(arr[i-1]>arr[i] && candies[i-1]<=candies[i])\\n        candies[i-1]  = candies[i]+1;\\n      }\\n      for(auto x : candies) ans+=x;\\n      return  ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& arr) {\\n      int n = arr.size(),ans = 0;\\n      vector<int> candies(n,1);\\n\\n      for(int i = 1;i<n;i++)\\n      {\\n        if(arr[i]>arr[i-1])\\n        candies[i] = candies[i-1]+1;\\n      }\\n      for(int i = n-1;i>0;i--)\\n      {\\n        if(arr[i-1]>arr[i] && candies[i-1]<=candies[i])\\n        candies[i-1]  = candies[i]+1;\\n      }\\n      for(auto x : candies) ans+=x;\\n      return  ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037973,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n=len(ratings)\\n        dp=[1]*n\\n        for i in range(1,n):\\n            if ratings[i]>ratings[i-1]:\\n                dp[i]=dp[i-1]+1\\n\\n        for i in range(n-2,-1,-1):\\n            if ratings[i]>ratings[i+1]:\\n                dp[i]=max(dp[i],dp[i+1]+1)\\n\\n        return sum(dp)        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n=len(ratings)\\n        dp=[1]*n\\n        for i in range(1,n):\\n            if ratings[i]>ratings[i-1]:\\n                dp[i]=dp[i-1]+1\\n\\n        for i in range(n-2,-1,-1):\\n            if ratings[i]>ratings[i+1]:\\n                dp[i]=max(dp[i],dp[i+1]+1)\\n\\n        return sum(dp)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037962,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition and approach discussed in video solution in detail\\nhttps://youtu.be/3-2IBELK-iM\\n\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int sz = ratings.size();\\n        int maxRat = 2 * 10000 + 1;\\n        vector<int> cand(sz, 1);\\n        int minCand = 0;\\n        for(int indx = 0; indx < sz; indx++){\\n           int leftNeigh = (indx - 1) > -1 ? ratings[indx-1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > leftNeigh){\\n              cand[indx] = cand[indx-1] + 1;\\n           }\\n        }\\n        for(int indx = sz-1; indx > -1; indx--){\\n           int rightNeigh =(indx + 1) < sz ? ratings[indx + 1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > rightNeigh){\\n             if(cand[indx] <= cand[indx+1])\\n              cand[indx] = cand[indx+1] + 1;\\n           }\\n        }\\n\\n        minCand = accumulate(cand.begin(), cand.end(), 0);\\n\\n        return minCand; \\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int sz = ratings.length;\\n        int maxRat = 2 * 10000 + 1;\\n        int cand[] = new int[sz];\\n        Arrays.fill(cand, 1);\\n        int minCand = 0;\\n        for(int indx = 0; indx < sz; indx++){\\n           int leftNeigh = (indx - 1) > -1 ? ratings[indx-1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > leftNeigh){\\n              cand[indx] = cand[indx-1] + 1;\\n           }\\n        }\\n        for(int indx = sz-1; indx > -1; indx--){\\n           int rightNeigh =(indx + 1) < sz ? ratings[indx + 1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > rightNeigh){\\n             if(cand[indx] <= cand[indx+1])\\n              cand[indx] = cand[indx+1] + 1;\\n           }\\n        }\\n        for(var c : cand){\\n          minCand += c;\\n        }\\n        return minCand; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int sz = ratings.size();\\n        int maxRat = 2 * 10000 + 1;\\n        vector<int> cand(sz, 1);\\n        int minCand = 0;\\n        for(int indx = 0; indx < sz; indx++){\\n           int leftNeigh = (indx - 1) > -1 ? ratings[indx-1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > leftNeigh){\\n              cand[indx] = cand[indx-1] + 1;\\n           }\\n        }\\n        for(int indx = sz-1; indx > -1; indx--){\\n           int rightNeigh =(indx + 1) < sz ? ratings[indx + 1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > rightNeigh){\\n             if(cand[indx] <= cand[indx+1])\\n              cand[indx] = cand[indx+1] + 1;\\n           }\\n        }\\n\\n        minCand = accumulate(cand.begin(), cand.end(), 0);\\n\\n        return minCand; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int sz = ratings.length;\\n        int maxRat = 2 * 10000 + 1;\\n        int cand[] = new int[sz];\\n        Arrays.fill(cand, 1);\\n        int minCand = 0;\\n        for(int indx = 0; indx < sz; indx++){\\n           int leftNeigh = (indx - 1) > -1 ? ratings[indx-1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > leftNeigh){\\n              cand[indx] = cand[indx-1] + 1;\\n           }\\n        }\\n        for(int indx = sz-1; indx > -1; indx--){\\n           int rightNeigh =(indx + 1) < sz ? ratings[indx + 1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > rightNeigh){\\n             if(cand[indx] <= cand[indx+1])\\n              cand[indx] = cand[indx+1] + 1;\\n           }\\n        }\\n        for(var c : cand){\\n          minCand += c;\\n        }\\n        return minCand; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019202,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(n) + O(n) + O(n), which simplifies to O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for using an extra array left.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n= ratings.size();\\n        vector<int>left(n+1, 1);\\n        for(int i =1; i<n; i++){\\n            if(ratings[i]>ratings[i-1]){\\n                left[i]= left[i-1]+1;\\n\\n            }\\n        }\\n        int right=1;\\n        for(int j=n-2; j>=0; j--){\\n            if(ratings[j]>ratings[j+1]){\\n                right++;\\n                left[j]= max(left[j], right);\\n            }\\n            else{\\n                right=1;\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            sum+= left[i];\\n        }\\n\\nreturn sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n= ratings.size();\\n        vector<int>left(n+1, 1);\\n        for(int i =1; i<n; i++){\\n            if(ratings[i]>ratings[i-1]){\\n                left[i]= left[i-1]+1;\\n\\n            }\\n        }\\n        int right=1;\\n        for(int j=n-2; j>=0; j--){\\n            if(ratings[j]>ratings[j+1]){\\n                right++;\\n                left[j]= max(left[j], right);\\n            }\\n            else{\\n                right=1;\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            sum+= left[i];\\n        }\\n\\nreturn sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797765,
                "title": "c-solution-in-o-n-super-easy-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& r) {\\n        int n=r.size();\\n        vector<int>v(n,1);\\n        for(int j=0;j<n-1;++j)\\n        {\\n            if(r[j]<r[j+1])\\n            v[j+1]=max(v[j+1],v[j]+1);\\n            if(r[n-1-j]<r[n-j-2])\\n            v[n-2-j]=max(v[n-j-2],v[n-1-j]+1);\\n        }\\n        n=0;\\n        for(auto it:v)\\n        n+=it;\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& r) {\\n        int n=r.size();\\n        vector<int>v(n,1);\\n        for(int j=0;j<n-1;++j)\\n        {\\n            if(r[j]<r[j+1])\\n            v[j+1]=max(v[j+1],v[j]+1);\\n            if(r[n-1-j]<r[n-j-2])\\n            v[n-2-j]=max(v[n-j-2],v[n-1-j]+1);\\n        }\\n        n=0;\\n        for(auto it:v)\\n        n+=it;\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620854,
                "title": "easy-approach-in-dart-and-also-in-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nA shorter and easier-to-write solution to the problem of distributing candies to children based on their ratings can be achieved using a single iteration through the ratings array. Here\\'s a simplified approach:\\n1. Initialize the candies array with all elements set to 1, ensuring that each child receives at least one candy.\\n2. Traverse the ratings array from left to right, starting from the second child.\\n3. If the current child\\'s rating is greater than the previous child\\'s rating, assign candies[i] = candies[i - 1] + 1, ensuring the current child receives one more candy than the previous child.\\n4. Traverse the ratings array from right to left, starting from the second-to-last child.\\n5. If the current child\\'s rating is greater than the next child\\'s rating, and their current assigned number of candies (candies[i]) is less than or equal to the next child\\'s candies plus one (candies[i + 1] + 1), update candies[i] to be one more than the next child\\'s candies.\\n6. Calculate and return the sum of all elements in the candies array. This represents the minimum number of candies needed to distribute among the children while meeting the requirements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an array candies of the same length as the ratings array, with all elements set to 1.\\n2. Traverse the ratings array from left to right:\\n   - Compare the current child\\'s rating with its left neighbor\\'s     rating.\\n   - If the current child has a higher rating than its left neighbor, assign candies[i] = candies[i - 1] + 1, ensuring the current child receives one more candy than the left neighbor\\n3. Traverse the ratings array from right to left:\\n   - Compare the current child\\'s rating with its right neighbor\\'s rating\\n   - If the current child has a higher rating than its right neighbor and its assigned number of candies (candies[i]) is less than or equal to its right neighbor\\'s candies plus one (candies[i + 1] + 1), update candies[i] to be one more than its right neighbor\\'s candies.\\n4. Calculate the sum of all elements in the candies array, representing the minimum number of candies needed to distribute among the children.\\n5. Return the sum as the result.\\n```\\nfunction distributeCandies(ratings):\\n    n = length of ratings\\n    candies = array of size n with all elements initialized to 1\\n    \\n    // Traverse from left to right\\n    for i from 1 to n-1 do:\\n        if ratings[i] > ratings[i-1] then:\\n            candies[i] = candies[i-1] + 1\\n            \\n    // Traverse from right to left\\n    for i from n-2 to 0 do:\\n        if ratings[i] > ratings[i+1] and candies[i] <= candies[i+1] + 1 then:\\n            candies[i] = candies[i+1] + 1\\n            \\n    sum = sum of all elements in candies\\n    return sum\\n```\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Dart\\n```\\nclass Solution {\\n  int candy(List<int> ratings) {\\n      int n = ratings.length;\\n      List<int> candies = List<int>.filled(n,1);\\n      for(int i=1;i<n;i++){\\n          if(ratings[i] > ratings[i-1]){\\n              candies[i] = candies[i-1]+1;\\n          }\\n      }\\n      for(int i =n-2;i>=0;i--){\\n          if(ratings[i+1] < ratings[i] && candies[i] <= candies[i+1]){\\n            candies[i] = candies[i+1]+1;\\n          }\\n      }\\n      \\n      int sum = candies.reduce((a,b) => a+b);\\n      return sum;\\n  }\\n}\\n```\\n## TypeScript\\n```\\nlet candies = new Array(ratings.length).fill(1);\\n    for(let i=1;i<ratings.length;i++){\\n        if(ratings[i] > ratings[i-1]){\\n            candies[i] = candies[i-1]+1\\n        }\\n    } \\n\\n    for(let i = ratings.length-2;i>=0;i--){\\n        if(ratings[i] > ratings[i+1] && candies[i] <= candies[i+1]){\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }  \\n    \\n    // console.log(candies)\\n    let sum = candies.reduce((a,b) => a+b);\\n    return sum;\\n```    \\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dart"
                ],
                "code": "```\\nfunction distributeCandies(ratings):\\n    n = length of ratings\\n    candies = array of size n with all elements initialized to 1\\n    \\n    // Traverse from left to right\\n    for i from 1 to n-1 do:\\n        if ratings[i] > ratings[i-1] then:\\n            candies[i] = candies[i-1] + 1\\n            \\n    // Traverse from right to left\\n    for i from n-2 to 0 do:\\n        if ratings[i] > ratings[i+1] and candies[i] <= candies[i+1] + 1 then:\\n            candies[i] = candies[i+1] + 1\\n            \\n    sum = sum of all elements in candies\\n    return sum\\n```\n```\\nclass Solution {\\n  int candy(List<int> ratings) {\\n      int n = ratings.length;\\n      List<int> candies = List<int>.filled(n,1);\\n      for(int i=1;i<n;i++){\\n          if(ratings[i] > ratings[i-1]){\\n              candies[i] = candies[i-1]+1;\\n          }\\n      }\\n      for(int i =n-2;i>=0;i--){\\n          if(ratings[i+1] < ratings[i] && candies[i] <= candies[i+1]){\\n            candies[i] = candies[i+1]+1;\\n          }\\n      }\\n      \\n      int sum = candies.reduce((a,b) => a+b);\\n      return sum;\\n  }\\n}\\n```\n```\\nlet candies = new Array(ratings.length).fill(1);\\n    for(let i=1;i<ratings.length;i++){\\n        if(ratings[i] > ratings[i-1]){\\n            candies[i] = candies[i-1]+1\\n        }\\n    } \\n\\n    for(let i = ratings.length-2;i>=0;i--){\\n        if(ratings[i] > ratings[i+1] && candies[i] <= candies[i+1]){\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }  \\n    \\n    // console.log(candies)\\n    let sum = candies.reduce((a,b) => a+b);\\n    return sum;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584789,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        if(ratings.size()==1){\\n            return 1;\\n        }\\n\\n        else{\\n        int n = ratings.size();\\n\\n        vector<int> cnt;\\n\\n\\n        for(int i = 0 ; i < n ; i++){\\n            cnt.push_back(1);\\n        }\\n        for(int i = 1 ; i < n ; i++){\\n            if(ratings[i] > ratings[i-1]){\\n                cnt[i] = cnt[i-1] + 1;\\n            }\\n        }\\n        for(int i = n-2 ; i >= 0 ; i--){\\n            if(ratings[i] > ratings[i+1] && cnt[i] <= cnt[i+1]){\\n                cnt[i] = cnt[i+1] + 1;\\n            }\\n        }\\n\\n        return accumulate(cnt.begin() , cnt.end() , 0LL);\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        if(ratings.size()==1){\\n            return 1;\\n        }\\n\\n        else{\\n        int n = ratings.size();\\n\\n        vector<int> cnt;\\n\\n\\n        for(int i = 0 ; i < n ; i++){\\n            cnt.push_back(1);\\n        }\\n        for(int i = 1 ; i < n ; i++){\\n            if(ratings[i] > ratings[i-1]){\\n                cnt[i] = cnt[i-1] + 1;\\n            }\\n        }\\n        for(int i = n-2 ; i >= 0 ; i--){\\n            if(ratings[i] > ratings[i+1] && cnt[i] <= cnt[i+1]){\\n                cnt[i] = cnt[i+1] + 1;\\n            }\\n        }\\n\\n        return accumulate(cnt.begin() , cnt.end() , 0LL);\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579951,
                "title": "135-candy-java",
                "content": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        if(ratings.length==1)\\n            return 1;\\n        int candies[]=new int[ratings.length];\\n        Arrays.fill(candies,1);\\n        for(int i=1;i<ratings.length;i++)\\n        {\\n            if(ratings[i]>ratings[i-1]&&candies[i]<=candies[i-1])\\n                candies[i]=candies[i-1]+1;\\n        }\\n        \\n        for(int i=ratings.length-2;i>=0;i--)\\n        {\\n            if(ratings[i]>ratings[i+1]&&candies[i]<=candies[i+1])\\n                candies[i]=candies[i+1]+1;\\n        }\\n        int sum=0;\\n        for(int x:candies)\\n            sum+=x;\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        if(ratings.length==1)\\n            return 1;\\n        int candies[]=new int[ratings.length];\\n        Arrays.fill(candies,1);\\n        for(int i=1;i<ratings.length;i++)\\n        {\\n            if(ratings[i]>ratings[i-1]&&candies[i]<=candies[i-1])\\n                candies[i]=candies[i-1]+1;\\n        }\\n        \\n        for(int i=ratings.length-2;i>=0;i--)\\n        {\\n            if(ratings[i]>ratings[i+1]&&candies[i]<=candies[i+1])\\n                candies[i]=candies[i+1]+1;\\n        }\\n        int sum=0;\\n        for(int x:candies)\\n            sum+=x;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433875,
                "title": "2-array-approach-easy-solution-left-right",
                "content": "\\n# Approach\\n2 Array Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>l2r(n,1);\\n        vector<int>r2l(n,1);\\n        vector<int> ans;\\n        int sum=0;\\n        for(int i=1;i<n;i++){\\n          if(ratings[i]>ratings[i-1]){\\n              l2r[i]+=l2r[i-1];\\n          }\\n }\\n  for(int i=n-2;i>=0;i--){\\n          if(ratings[i]>ratings[i+1]){\\n              r2l[i]+=r2l[i+1];\\n          }\\n }\\n for(int i=0;i<n;i++){\\n     if(l2r[i]>=r2l[i]){\\n         ans.push_back(l2r[i]);\\n     }\\n     else{\\n         ans.push_back(r2l[i]);\\n     }\\n sum=sum+ans[i];\\n }\\nreturn sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>l2r(n,1);\\n        vector<int>r2l(n,1);\\n        vector<int> ans;\\n        int sum=0;\\n        for(int i=1;i<n;i++){\\n          if(ratings[i]>ratings[i-1]){\\n              l2r[i]+=l2r[i-1];\\n          }\\n }\\n  for(int i=n-2;i>=0;i--){\\n          if(ratings[i]>ratings[i+1]){\\n              r2l[i]+=r2l[i+1];\\n          }\\n }\\n for(int i=0;i<n;i++){\\n     if(l2r[i]>=r2l[i]){\\n         ans.push_back(l2r[i]);\\n     }\\n     else{\\n         ans.push_back(r2l[i]);\\n     }\\n sum=sum+ans[i];\\n }\\nreturn sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040094,
                "title": "java-99-2-percent-faster-greedy",
                "content": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int[] nums=new int[ratings.length];\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=1;\\n        }\\n        for(int i=1;i<nums.length;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                nums[i]=nums[i-1]+1;\\n            }\\n        }\\n        for(int i=nums.length-1;i>=1;i--){\\n            if(ratings[i-1]>ratings[i] && nums[i-1]<=nums[i]){\\n                nums[i-1]=nums[i]+1;\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum=sum+nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int[] nums=new int[ratings.length];\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=1;\\n        }\\n        for(int i=1;i<nums.length;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                nums[i]=nums[i-1]+1;\\n            }\\n        }\\n        for(int i=nums.length-1;i>=1;i--){\\n            if(ratings[i-1]>ratings[i] && nums[i-1]<=nums[i]){\\n                nums[i-1]=nums[i]+1;\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum=sum+nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976395,
                "title": "c-short-easy-100-fast",
                "content": "# Please upvote if you like my solution .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int candy(vector<int>& A) {\\n        \\n        int n = A.size();\\n    \\n        vector<int> ans(n, 1);\\n\\n        for(int i=1;i<n;i++) {\\n            if(A[i]>A[i-1]) {       \\n                ans[i] = ans[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i=n-1;i>=1;i--) {\\n\\n            if(A[i-1]>A[i]) {\\n                ans[i-1] = max(ans[i] + 1, ans[i-1]);\\n            }\\n\\n        }\\n\\n        int sum = 0;\\n        \\n    \\n\\n        for(int i=0;i<n;i++) {\\n            sum += ans[i];\\n        }\\n\\n        return sum;\\n    \\n        \\n    }\\n};\\n```\\n\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on Linkedin https://www.linkedin.com/in/kailas-rathod/",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int candy(vector<int>& A) {\\n        \\n        int n = A.size();\\n    \\n        vector<int> ans(n, 1);\\n\\n        for(int i=1;i<n;i++) {\\n            if(A[i]>A[i-1]) {       \\n                ans[i] = ans[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i=n-1;i>=1;i--) {\\n\\n            if(A[i-1]>A[i]) {\\n                ans[i-1] = max(ans[i] + 1, ans[i-1]);\\n            }\\n\\n        }\\n\\n        int sum = 0;\\n        \\n    \\n\\n        for(int i=0;i<n;i++) {\\n            sum += ans[i];\\n        }\\n\\n        return sum;\\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962105,
                "title": "c-two-way-to-solve-easiest-way-ever",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int>left(ratings.size(),1);\\n        for(int i=1;i<ratings.size();++i){\\n            if(ratings[i]>ratings[i-1]){\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        int right=1;\\n        for(int j=ratings.size()-2;j>=0;--j){\\n        if(ratings[j]>ratings[j+1]){\\n            right++;\\n            left[j]=max(left[j],right);\\n            \\n        }\\n        else{\\n            right=1;\\n        }}\\n        //    vector<int>right(ratings.size(),1);\\n        // for(int i=ratings.size()-2;i>=0;--i){\\n        //     if(ratings[i]>ratings[i+1]){\\n        //         right[i]=right[i+1]+1;\\n        //     }\\n        // }\\n        int Total_candies=0;\\n        for(int i=0;i<ratings.size();++i){\\n            Total_candies+=left[i];\\n        }\\n        return Total_candies;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int>left(ratings.size(),1);\\n        for(int i=1;i<ratings.size();++i){\\n            if(ratings[i]>ratings[i-1]){\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n           vector<int>right(ratings.size(),1);\\n        for(int i=ratings.size()-2;i>=0;--i){\\n            if(ratings[i]>ratings[i+1]){\\n                right[i]=right[i+1]+1;\\n            }\\n        }\\n        int Total_candies=0;\\n        for(int i=0;i<ratings.size();++i){\\n            Total_candies+=max(right[i],left[i]);\\n        }\\n        return Total_candies;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int>left(ratings.size(),1);\\n        for(int i=1;i<ratings.size();++i){\\n            if(ratings[i]>ratings[i-1]){\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        int right=1;\\n        for(int j=ratings.size()-2;j>=0;--j){\\n        if(ratings[j]>ratings[j+1]){\\n            right++;\\n            left[j]=max(left[j],right);\\n            \\n        }\\n        else{\\n            right=1;\\n        }}\\n        //    vector<int>right(ratings.size(),1);\\n        // for(int i=ratings.size()-2;i>=0;--i){\\n        //     if(ratings[i]>ratings[i+1]){\\n        //         right[i]=right[i+1]+1;\\n        //     }\\n        // }\\n        int Total_candies=0;\\n        for(int i=0;i<ratings.size();++i){\\n            Total_candies+=left[i];\\n        }\\n        return Total_candies;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int>left(ratings.size(),1);\\n        for(int i=1;i<ratings.size();++i){\\n            if(ratings[i]>ratings[i-1]){\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n           vector<int>right(ratings.size(),1);\\n        for(int i=ratings.size()-2;i>=0;--i){\\n            if(ratings[i]>ratings[i+1]){\\n                right[i]=right[i+1]+1;\\n            }\\n        }\\n        int Total_candies=0;\\n        for(int i=0;i<ratings.size();++i){\\n            Total_candies+=max(right[i],left[i]);\\n        }\\n        return Total_candies;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727637,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int candy(vector<int>& A) {\\n        \\n        int n = A.size();\\n    \\n        vector<int> ans(n, 1);\\n\\n        for(int i=1;i<n;i++) {\\n            if(A[i]>A[i-1]) {       \\n                ans[i] = ans[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i=n-1;i>=1;i--) {\\n\\n            if(A[i-1]>A[i]) {\\n                ans[i-1] = max(ans[i] + 1, ans[i-1]);\\n            }\\n\\n        }\\n\\n        int sum = 0;\\n        \\n    \\n\\n        for(int i=0;i<n;i++) {\\n            sum += ans[i];\\n        }\\n\\n        return sum;\\n    \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int candy(vector<int>& A) {\\n        \\n        int n = A.size();\\n    \\n        vector<int> ans(n, 1);\\n\\n        for(int i=1;i<n;i++) {\\n            if(A[i]>A[i-1]) {       \\n                ans[i] = ans[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i=n-1;i>=1;i--) {\\n\\n            if(A[i-1]>A[i]) {\\n                ans[i-1] = max(ans[i] + 1, ans[i-1]);\\n            }\\n\\n        }\\n\\n        int sum = 0;\\n        \\n    \\n\\n        for(int i=0;i<n;i++) {\\n            sum += ans[i];\\n        }\\n\\n        return sum;\\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701595,
                "title": "java-two-solutions-two-pass",
                "content": "### **Please Upvote** :D\\n##### 1. Greedy approach:\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n\\n        int[] l2r = new int[n], r2l = new int[n];\\n\\t\\t\\n        Arrays.fill(l2r, 1);\\n        Arrays.fill(r2l, 1);\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            if (ratings[i + 1] > ratings[i]) {\\n                l2r[i + 1] = l2r[i] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 1; i > 0; i--) {\\n            if (ratings[i - 1] > ratings[i]) {\\n                r2l[i - 1] = r2l[i] + 1;\\n            }\\n        }\\n\\n        int[] finalArr = new int[n];\\n\\t\\t\\n        for (int i = 0; i < n; i++) {\\n            finalArr[i] = Math.max(l2r[i], r2l[i]);\\n        }\\n\\n        int totalCandies = 0;\\n        for (int i : finalArr) totalCandies += i;\\n\\n        return totalCandies;\\n    }\\n}\\n\\n// TC: 6 * O(n) => O(n)\\n// SC: 3 * O(n) => O(n)\\n```\\n\\n##### 2. Extra space reduced (Two pass):\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n\\n        int[] distribution = new int[n];\\n\\t\\t\\n        Arrays.fill(distribution, 1);\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            if (ratings[i + 1] > ratings[i]) {\\n                distribution[i + 1] = distribution[i] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 1; i > 0; i--) {\\n            if (ratings[i - 1] > ratings[i]) {\\n                if (distribution[i - 1] <= distribution[i]) {\\n                    distribution[i - 1] = distribution[i] + 1;\\n                }\\n            }\\n        }\\n\\n        int totalCandies = 0;\\n        for (int i : distribution) totalCandies += i;\\n\\n        return totalCandies;\\n    }\\n}\\n\\n// TC: 4 * O(n) => O(n)\\n// SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n\\n        int[] l2r = new int[n], r2l = new int[n];\\n\\t\\t\\n        Arrays.fill(l2r, 1);\\n        Arrays.fill(r2l, 1);\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            if (ratings[i + 1] > ratings[i]) {\\n                l2r[i + 1] = l2r[i] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 1; i > 0; i--) {\\n            if (ratings[i - 1] > ratings[i]) {\\n                r2l[i - 1] = r2l[i] + 1;\\n            }\\n        }\\n\\n        int[] finalArr = new int[n];\\n\\t\\t\\n        for (int i = 0; i < n; i++) {\\n            finalArr[i] = Math.max(l2r[i], r2l[i]);\\n        }\\n\\n        int totalCandies = 0;\\n        for (int i : finalArr) totalCandies += i;\\n\\n        return totalCandies;\\n    }\\n}\\n\\n// TC: 6 * O(n) => O(n)\\n// SC: 3 * O(n) => O(n)\\n```\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n\\n        int[] distribution = new int[n];\\n\\t\\t\\n        Arrays.fill(distribution, 1);\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            if (ratings[i + 1] > ratings[i]) {\\n                distribution[i + 1] = distribution[i] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 1; i > 0; i--) {\\n            if (ratings[i - 1] > ratings[i]) {\\n                if (distribution[i - 1] <= distribution[i]) {\\n                    distribution[i - 1] = distribution[i] + 1;\\n                }\\n            }\\n        }\\n\\n        int totalCandies = 0;\\n        for (int i : distribution) totalCandies += i;\\n\\n        return totalCandies;\\n    }\\n}\\n\\n// TC: 4 * O(n) => O(n)\\n// SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2405865,
                "title": "c-o-n-time-o-1-space-99-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& a) {\\n        int indexOfLatestLocalMax = 0;\\n        int ans = 1;\\n        int latestLocalMaxCandies = 1;\\n        int currCandies=1;\\n        int offSetCandies;\\n        for(int i=1;i<a.size();i++) {\\n            if (a[i] >= a[i-1]) {\\n                currCandies = a[i] == a[i-1] ? 1 : currCandies + 1;\\n                ans += currCandies;\\n                latestLocalMaxCandies = currCandies;\\n                indexOfLatestLocalMax = i;\\n            } else {\\n                currCandies = 1;\\n                offSetCandies = i - indexOfLatestLocalMax;\\n                if (offSetCandies < latestLocalMaxCandies) {\\n                    offSetCandies -= 1;\\n                }\\n                ans += currCandies + offSetCandies;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& a) {\\n        int indexOfLatestLocalMax = 0;\\n        int ans = 1;\\n        int latestLocalMaxCandies = 1;\\n        int currCandies=1;\\n        int offSetCandies;\\n        for(int i=1;i<a.size();i++) {\\n            if (a[i] >= a[i-1]) {\\n                currCandies = a[i] == a[i-1] ? 1 : currCandies + 1;\\n                ans += currCandies;\\n                latestLocalMaxCandies = currCandies;\\n                indexOfLatestLocalMax = i;\\n            } else {\\n                currCandies = 1;\\n                offSetCandies = i - indexOfLatestLocalMax;\\n                if (offSetCandies < latestLocalMaxCandies) {\\n                    offSetCandies -= 1;\\n                }\\n                ans += currCandies + offSetCandies;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252930,
                "title": "34-ms-solution-c-easy-to-understand",
                "content": "\\'\\'\\'\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint candy(vector<int>& arr) {\\n\\t\\t\\tint l=arr.size();\\n\\t\\t\\tint c[l];\\n\\t\\t\\tfor(int i=0;i<l;i++){\\n\\t\\t\\t\\tc[i]=1;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<l-1;i++){\\n\\t\\t\\t\\tif (arr[i+1]>arr[i]){\\n\\t\\t\\t\\t\\tc[i+1]=c[i]+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint s=c[l-1];\\n\\t\\t\\tfor(int i=l-1;i>0;i--){\\n\\t\\t\\t\\tif ((arr[i-1]>arr[i])&&(c[i-1]<=c[i])){\\n\\t\\t\\t\\t\\tc[i-1]=c[i]+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ts=s+c[i-1];\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn s;\\n\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint candy(vector<int>& arr) {\\n\\t\\t\\tint l=arr.size();\\n\\t\\t\\tint c[l];\\n\\t\\t\\tfor(int i=0;i<l;i++){\\n\\t\\t\\t\\tc[i]=1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2242600,
                "title": "java-o-n-time-space-complexity",
                "content": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n= ratings.length;\\n        int candies=0;\\n        int[] left= new int[n];\\n        int[] right=new int[n];\\n        \\n        Arrays.fill(left,1);\\n        Arrays.fill(right,1);\\n        \\n        for(int i =1; i<n; i++){\\n            if(ratings[i]>ratings[i-1]) left[i]=left[i-1]+1;\\n        }\\n        \\n        for(int i =n-2; i>=0; i--){\\n            if(ratings[i]>ratings[i+1]) right[i]=right[i+1]+1;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            candies= candies+Math.max(left[i],right[i]);\\n        }\\n        \\n        return candies;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n= ratings.length;\\n        int candies=0;\\n        int[] left= new int[n];\\n        int[] right=new int[n];\\n        \\n        Arrays.fill(left,1);\\n        Arrays.fill(right,1);\\n        \\n        for(int i =1; i<n; i++){\\n            if(ratings[i]>ratings[i-1]) left[i]=left[i-1]+1;\\n        }\\n        \\n        for(int i =n-2; i>=0; i--){\\n            if(ratings[i]>ratings[i+1]) right[i]=right[i+1]+1;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            candies= candies+Math.max(left[i],right[i]);\\n        }\\n        \\n        return candies;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238317,
                "title": "struggled-with-it-solved-it-and-tried-to-explain-it",
                "content": "Every sequence of numbers in this multiverse can be somehow generalized as a group of following sequence :\\n\\n![image](https://assets.leetcode.com/users/images/571888c5-c40e-4928-a943-504b6b1cfbf6_1656963258.6447163.png)\\n\\na climb of length ***a*** and a descent of length ***b*** where ***a, b*** can be from 0 till any value. i.e even monotonus sequences follow this. Even straight line is a group of above sequence with ***a, b = 0***. \\n\\nThe value of ***a, b*** can be different for different sequences in a group, ofcourse.\\n\\nSo let us go through each such sequence:\\n* \\tThe candies of the climb would be ***1 + 2 + 3 + 4 +...... + a    i.e. (a x (a+1))/2*** , we can start with 1 as the first element in the climb is smaller than both its neighbours.\\n* \\tThe same goes with the descent\\n* \\tand for the peak it would be max(a, b) + 1 as we know it has to be greater than both its neigbours candies values\\n\\n\\n\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        \\n        ans = 0\\n        i = 0\\n        n = len(ratings)\\n        left = 0\\n        right = 0\\n        it = 0\\n        while i<n-1:\\n            #climb\\n            while i < n-1 and ratings[i] < ratings[i+1]:\\n                left +=1\\n                i+=1\\n            #descent\\n            while i  <n-1 and ratings[i] > ratings[i+1]:\\n                right +=1\\n                i+=1\\n                \\n\\t\\t\\t#candies\\n            ans = ans +  (left*(left+1)//2 + right*(right+1)//2) + max(left, right) + 1\\n            \\n\\t\\t\\t# the painful plateu part where the values are same like x, x, x, x. \\n\\t\\t\\t#Apart from the last one and first one for all x we could give 1 candy \\n\\t\\t\\t#and 1st one and last one are just part of different sequences \\n\\t\\t\\t#so we dont have to care about them.\\n            p = 0\\n        \\n            while i < n-1 and ratings[i] == ratings[i+1]:\\n                p += 1\\n                i+=1\\n    \\n            ans += p\\n            \\n            left = 0\\n            right = 0\\n\\t\\t\\t\\n\\t\\t\\t#every junction of two sequences would be double counted due to which\\n\\t\\t\\t#we can add all the junctions and remove the double counting see the\\n\\t\\t\\t#diagram below to see the double counting junction\\n\\t\\t\\t\\n            it+=1\\n        \\n        \\n        return ans-it+1\\n                \\n                \\n            \\n````\\n\\n![image](https://assets.leetcode.com/users/images/fcce1e1b-ce9e-4958-b628-970c130f9c63_1656963978.974529.png)\\n\\n\\n**Time complexity would be linear and space complexity would be constant**\\n\\n**This problem really felt difficult and a lot of cases needed to be handled and thought about but is really a fun problem to solve and learn from**\\n\\nThank you \\uD83D\\uDE09\\u270C\\uFE0F",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        \\n        ans = 0\\n        i = 0\\n        n = len(ratings)\\n        left = 0\\n        right = 0\\n        it = 0\\n        while i<n-1:\\n            #climb\\n            while i < n-1 and ratings[i] < ratings[i+1]:\\n                left +=1\\n                i+=1\\n            #descent\\n            while i  <n-1 and ratings[i] > ratings[i+1]:\\n                right +=1\\n                i+=1\\n                \\n\\t\\t\\t#candies\\n            ans = ans +  (left*(left+1)//2 + right*(right+1)//2) + max(left, right) + 1\\n            \\n\\t\\t\\t# the painful plateu part where the values are same like x, x, x, x. \\n\\t\\t\\t#Apart from the last one and first one for all x we could give 1 candy \\n\\t\\t\\t#and 1st one and last one are just part of different sequences \\n\\t\\t\\t#so we dont have to care about them.\\n            p = 0\\n        \\n            while i < n-1 and ratings[i] == ratings[i+1]:\\n                p += 1\\n                i+=1\\n    \\n            ans += p\\n            \\n            left = 0\\n            right = 0\\n\\t\\t\\t\\n\\t\\t\\t#every junction of two sequences would be double counted due to which\\n\\t\\t\\t#we can add all the junctions and remove the double counting see the\\n\\t\\t\\t#diagram below to see the double counting junction\\n\\t\\t\\t\\n            it+=1\\n        \\n        \\n        return ans-it+1\\n                \\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237812,
                "title": "c-o-n-space-o-n-time-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& a) {\\n        int n=a.size();\\n        vector<int> ans(n,1);\\n        if(n==1)\\n        {\\n            return 1; // if there is only one element then answer will always be 1.\\n        }\\n        for(int i=1;i<n;i++) // considering i-1 and i index from left to right\\n        {\\n            if(a[i]>a[i-1] and ans[i-1]>=ans[i])\\n            {\\n                ans[i]=ans[i-1]+1;\\n            }\\n            \\n            if(a[i-1]>a[i] and ans[i]>=a[i-1])\\n            {\\n                ans[i-1]=ans[i]+1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--) //considering i and i+1 index from  right to left\\n        {\\n            if(a[i]>a[i+1] and ans[i+1]>=ans[i])\\n            {\\n                ans[i]=ans[i+1]+1;\\n            }\\n            if(a[i+1]>a[i] and ans[i]>=a[i+1])\\n            {\\n                ans[i+1]=ans[i]+1;\\n            }\\n        }\\n        int sum=0;\\n        for(auto x: ans)\\n        {\\n            sum+=x;\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int candy(vector<int>& a) {\\n        int n=a.size();\\n        vector<int> ans(n,1);\\n        if(n==1)\\n        {\\n            return 1; // if there is only one element then answer will always be 1.\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2237477,
                "title": "c-very-simple-o-n-time",
                "content": "```\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> lefttoright(n, -1);\\n        vector<int> righttoleft(n, -1);\\n        vector<int> ans(n, -1);\\n        int res = 0;\\n        lefttoright[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i-1]) {\\n                lefttoright[i] = lefttoright[i-1]+1;\\n            } else {\\n                lefttoright[i] = 1;\\n            }\\n        }\\n        righttoleft[n-1] = 1;\\n        for (int i = n-2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i+1]) {\\n                righttoleft[i] = righttoleft[i+1] + 1;\\n            } else {\\n                righttoleft[i] = 1;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = max(lefttoright[i], righttoleft[i]);\\n            res += ans[i];\\n        }\\n        return res;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> lefttoright(n, -1);\\n        vector<int> righttoleft(n, -1);\\n        vector<int> ans(n, -1);\\n        int res = 0;\\n        lefttoright[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i-1]) {\\n                lefttoright[i] = lefttoright[i-1]+1;\\n            } else {\\n                lefttoright[i] = 1;\\n            }\\n        }\\n        righttoleft[n-1] = 1;\\n        for (int i = n-2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i+1]) {\\n                righttoleft[i] = righttoleft[i+1] + 1;\\n            } else {\\n                righttoleft[i] = 1;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = max(lefttoright[i], righttoleft[i]);\\n            res += ans[i];\\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1631504,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1798500,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1890028,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1564922,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1565662,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 2055303,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 2046203,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1566480,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1570291,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1568954,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1631504,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1798500,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1890028,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1564922,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1565662,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 2055303,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 2046203,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1566480,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1570291,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1568954,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1568952,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 1567883,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 2055648,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 1756142,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 1566239,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 2055694,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 1566457,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 2055384,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 2055304,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 2055291,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 1968326,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 1968139,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 1571291,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 2056404,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 2056021,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 2055393,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 1980587,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 1927921,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 1571292,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 1568955,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 2056186,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 2056104,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 2055947,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 2055867,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 2055503,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 2055496,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 1957668,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 1922920,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 1914263,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 1856636,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 1716445,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 1571289,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 1571290,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 1733697,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 1571287,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 1571288,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 2072078,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 2066897,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 2061625,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 2059743,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 2057852,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056713,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056595,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056578,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056533,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056493,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056485,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056469,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056432,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056422,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056382,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056327,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056318,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056315,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056293,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056279,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056240,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056224,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056220,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056159,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056122,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2056013,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2056005,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2055989,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2055961,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2055910,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2055906,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2055890,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2055882,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2055881,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2055863,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055862,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055846,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055837,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055757,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055721,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055716,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055689,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055680,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055658,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055639,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055629,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055620,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055575,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055573,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055552,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055551,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055546,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055533,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055498,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055495,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055481,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055474,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055468,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055464,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055378,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055363,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055325,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055324,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055272,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2053577,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2052251,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2048369,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2044715,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2040266,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2038699,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2032295,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2013753,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2008738,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2000594,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 1993462,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1992595,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1990592,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1983190,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1959773,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1957016,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1955646,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1954632,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1935964,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1930264,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1923261,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1921648,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1917501,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1917348,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1915249,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1913837,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1913297,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1900216,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1878409,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1868469,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1859191,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 1764545,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 1756354,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 1749431,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 1745986,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 1745516,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 1715052,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 1706741,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 1568953,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 2064421,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            }
        ]
    }
]