[
    {
        "title": "Longest Mountain in Array",
        "question_content": "You may recall that an array arr is a mountain array if and only if:\n\n\tarr.length >= 3\n\tThere exists some index i (0-indexed) with 0 < i < arr.length - 1 such that:\n\t\n\t\tarr[0] < arr[1] < ... < arr[i - 1] < arr[i]\n\t\tarr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n\t\n\t\n\nGiven an integer array arr, return the length of the longest subarray, which is a mountain. Return 0 if there is no mountain subarray.\n&nbsp;\nExample 1:\n\nInput: arr = [2,1,4,7,3,2,5]\nOutput: 5\nExplanation: The largest mountain is [1,4,7,3,2] which has length 5.\n\nExample 2:\n\nInput: arr = [2,2,2]\nOutput: 0\nExplanation: There is no mountain.\n\n&nbsp;\nConstraints:\n\n\t1 <= arr.length <= 104\n\t0 <= arr[i] <= 104\n\n&nbsp;\nFollow up:\n\n\tCan you solve it using only one pass?\n\tCan you solve it in O(1) space?",
        "solutions": [
            {
                "id": 135593,
                "title": "c-java-python-1-pass-and-o-1-space",
                "content": "**Intuition**:\\nWe have already many 2-pass or 3-pass problems, like 821. Shortest Distance to a Character.\\nThey have almost the same idea.\\nOne forward pass and one backward pass.\\nMaybe another pass to get the final result, or you can merge it in one previous pass.\\n\\n**Explanation**:\\nIn this problem, we take one forward pass to count up hill length (to every point).\\nWe take another backward pass to count down hill length (from every point).\\nFinally a pass to find max(up[i] + down[i] + 1) where up[i] and down[i] should be positives.\\n\\n\\n**Time Complexity**:\\nO(N)\\n\\n**C++:**\\n```\\n    int longestMountain(vector<int> A) {\\n        int N = A.size(), res = 0;\\n        vector<int> up(N, 0), down(N, 0);\\n        for (int i = N - 2; i >= 0; --i) if (A[i] > A[i + 1]) down[i] = down[i + 1] + 1;\\n        for (int i = 0; i < N; ++i) {\\n            if (i > 0 && A[i] > A[i - 1]) up[i] = up[i - 1] + 1;\\n            if (up[i] && down[i]) res = max(res, up[i] + down[i] + 1);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int longestMountain(int[] A) {\\n        int N = A.length, res = 0;\\n        int[] up = new int[N], down = new int[N];\\n        for (int i = N - 2; i >= 0; --i) if (A[i] > A[i + 1]) down[i] = down[i + 1] + 1;\\n        for (int i = 0; i < N; ++i) {\\n            if (i > 0 && A[i] > A[i - 1]) up[i] = up[i - 1] + 1;\\n            if (up[i] > 0 && down[i] > 0) res = Math.max(res, up[i] + down[i] + 1);\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def longestMountain(self, A):\\n        up, down = [0] * len(A), [0] * len(A)\\n        for i in range(1, len(A)):\\n            if A[i] > A[i - 1]: up[i] = up[i - 1] + 1\\n        for i in range(len(A) - 1)[::-1]:\\n            if A[i] > A[i + 1]: down[i] = down[i + 1] + 1\\n        return max([u + d + 1 for u, d in zip(up, down) if u and d] or [0])\\n```\\n\\n**Follow up**\\n\\nCan you solve this problem with only one pass?\\nCan you solve this problem in O(1) space?\\n\\nIn this solution, I count up length and down length.\\nBoth up and down length are clear to 0 when `A[i - 1] == A[i]` or `down > 0 && A[i - 1] < A[i]`.\\n\\n**C++:**\\n```\\n    int longestMountain(vector<int> A) {\\n        int res = 0, up = 0, down = 0;\\n        for (int i = 1; i < A.size(); ++i) {\\n            if (down && A[i - 1] < A[i] || A[i - 1] == A[i]) up = down = 0;\\n            up += A[i - 1] < A[i];\\n            down += A[i - 1] > A[i];\\n            if (up && down) res = max(res, up + down + 1);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int longestMountain(int[] A) {\\n        int res = 0, up = 0, down = 0;\\n        for (int i = 1; i < A.length; ++i) {\\n            if (down > 0 && A[i - 1] < A[i] || A[i - 1] == A[i]) up = down = 0;\\n            if (A[i - 1] < A[i]) up++;\\n            if (A[i - 1] > A[i]) down++;\\n            if (up > 0 && down > 0 && up + down + 1 > res) res = up + down + 1;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def longestMountain(self, A):\\n        res = up = down = 0\\n        for i in range(1, len(A)):\\n            if down and A[i - 1] < A[i] or A[i - 1] == A[i]: up = down = 0\\n            up += A[i - 1] < A[i]\\n            down += A[i - 1] > A[i]\\n            if up and down: res = max(res, up + down + 1)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    int longestMountain(vector<int> A) {\\n        int N = A.size(), res = 0;\\n        vector<int> up(N, 0), down(N, 0);\\n        for (int i = N - 2; i >= 0; --i) if (A[i] > A[i + 1]) down[i] = down[i + 1] + 1;\\n        for (int i = 0; i < N; ++i) {\\n            if (i > 0 && A[i] > A[i - 1]) up[i] = up[i - 1] + 1;\\n            if (up[i] && down[i]) res = max(res, up[i] + down[i] + 1);\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int longestMountain(int[] A) {\\n        int N = A.length, res = 0;\\n        int[] up = new int[N], down = new int[N];\\n        for (int i = N - 2; i >= 0; --i) if (A[i] > A[i + 1]) down[i] = down[i + 1] + 1;\\n        for (int i = 0; i < N; ++i) {\\n            if (i > 0 && A[i] > A[i - 1]) up[i] = up[i - 1] + 1;\\n            if (up[i] > 0 && down[i] > 0) res = Math.max(res, up[i] + down[i] + 1);\\n        }\\n        return res;\\n    }\\n```\n```\\n    def longestMountain(self, A):\\n        up, down = [0] * len(A), [0] * len(A)\\n        for i in range(1, len(A)):\\n            if A[i] > A[i - 1]: up[i] = up[i - 1] + 1\\n        for i in range(len(A) - 1)[::-1]:\\n            if A[i] > A[i + 1]: down[i] = down[i + 1] + 1\\n        return max([u + d + 1 for u, d in zip(up, down) if u and d] or [0])\\n```\n```\\n    int longestMountain(vector<int> A) {\\n        int res = 0, up = 0, down = 0;\\n        for (int i = 1; i < A.size(); ++i) {\\n            if (down && A[i - 1] < A[i] || A[i - 1] == A[i]) up = down = 0;\\n            up += A[i - 1] < A[i];\\n            down += A[i - 1] > A[i];\\n            if (up && down) res = max(res, up + down + 1);\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int longestMountain(int[] A) {\\n        int res = 0, up = 0, down = 0;\\n        for (int i = 1; i < A.length; ++i) {\\n            if (down > 0 && A[i - 1] < A[i] || A[i - 1] == A[i]) up = down = 0;\\n            if (A[i - 1] < A[i]) up++;\\n            if (A[i - 1] > A[i]) down++;\\n            if (up > 0 && down > 0 && up + down + 1 > res) res = up + down + 1;\\n        }\\n        return res;\\n    }\\n```\n```\\n    def longestMountain(self, A):\\n        res = up = down = 0\\n        for i in range(1, len(A)):\\n            if down and A[i - 1] < A[i] or A[i - 1] == A[i]: up = down = 0\\n            up += A[i - 1] < A[i]\\n            down += A[i - 1] > A[i]\\n            if up and down: res = max(res, up + down + 1)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 165667,
                "title": "1-pass-java-two-point-solution",
                "content": "```\\npublic int longestMountain(int[] A) {\\n        int n=A.length;\\n        if(n<3)return 0;\\n        \\n        int left=0;int right;int max=0;\\n        \\n        while(left<n-2){\\n            //skip decending and equal array\\n            while(left<n-1 && A[left]>=A[left+1]){\\n                left++;\\n            }\\n            right=left+1;\\n            //mountain up\\n            while(right<n-1 && A[right]<A[right+1]){\\n                right++;\\n            }\\n            //mountain down\\n            while(right<n-1 && A[right]>A[right+1]){\\n                right++;\\n                //update the max value\\n                max=Math.max(max,right-left+1);\\n            }\\n            left=right;\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int longestMountain(int[] A) {\\n        int n=A.length;\\n        if(n<3)return 0;\\n        \\n        int left=0;int right;int max=0;\\n        \\n        while(left<n-2){\\n            //skip decending and equal array\\n            while(left<n-1 && A[left]>=A[left+1]){\\n                left++;\\n            }\\n            right=left+1;\\n            //mountain up\\n            while(right<n-1 && A[right]<A[right+1]){\\n                right++;\\n            }\\n            //mountain down\\n            while(right<n-1 && A[right]>A[right+1]){\\n                right++;\\n                //update the max value\\n                max=Math.max(max,right-left+1);\\n            }\\n            left=right;\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 271110,
                "title": "easy-to-understand-code-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int maxLength = 0;\\n        int i = 1;\\n        \\n        while (i < A.size()) {\\n            int increasing = 0, decreasing = 0;\\n            \\n            while(i < A.size() && A[i - 1] < A[i]) i++, increasing++;\\n            while(i < A.size() && A[i - 1] > A[i]) i++, decreasing++;\\n            \\n            if (increasing > 0 && decreasing > 0) maxLength = max(maxLength, increasing + decreasing + 1);\\n            \\n            while(i < A.size() && A[i - 1] == A[i]) i++;\\n        }\\n        return maxLength;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int maxLength = 0;\\n        int i = 1;\\n        \\n        while (i < A.size()) {\\n            int increasing = 0, decreasing = 0;\\n            \\n            while(i < A.size() && A[i - 1] < A[i]) i++, increasing++;\\n            while(i < A.size() && A[i - 1] > A[i]) i++, decreasing++;\\n            \\n            if (increasing > 0 && decreasing > 0) maxLength = max(maxLength, increasing + decreasing + 1);\\n            \\n            while(i < A.size() && A[i - 1] == A[i]) i++;\\n        }\\n        return maxLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 135631,
                "title": "python-7-lines-concise-o-n-time-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, A, res = 0):\\n        for i in range(1, len(A) - 1):\\n            if A[i + 1] < A[i] > A[i - 1]:\\n                l = r = i\\n                while l and A[l] > A[l - 1]: l -= 1\\n                while r + 1 < len(A) and A[r] > A[r + 1]: r += 1\\n                if r - l + 1 > res: res = r - l + 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A, res = 0):\\n        for i in range(1, len(A) - 1):\\n            if A[i + 1] < A[i] > A[i - 1]:\\n                l = r = i\\n                while l and A[l] > A[l - 1]: l -= 1\\n                while r + 1 < len(A) and A[r] > A[r + 1]: r += 1\\n                if r - l + 1 > res: res = r - l + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215470,
                "title": "c-easy-solution-with-comments-and-algorithm",
                "content": "\\nREMEMBER TO UPVOTE THE ANSWER\\n\\nTime Complexity O(n)\\nSpace Complexity O(1)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        // 1. IDENTIFY PEAKS\\n        // 2. TRAVERSE BACKWARDS WHILE PREVIOUS ELEMENT -\\n        // - IS SMALLER THAT CURRENT (i.e. GO TO THE START ROOT OF THE MOUNTAIN)\\n        // 3. TRAVERSE FORWARD WHILE NEXT ELEMENT IS SMALLER THAN CURRENT \\n        // (i.e. GO TO THE END ROOT OF THE MOUNTAIN)\\n        // 4 . ADD THEM TO CALCULATE THE MOUNTAIN LENGTH\\n        int max_length = 0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if((arr[i] > arr[i-1]) && (arr[i] > arr[i+1])) //PEAK CONDITION\\n            {\\n                int start_root = i;\\n                int end_root = i;\\n                while( start_root>0 && arr[start_root] > arr[start_root-1])\\n                {\\n                    start_root--; //getting start root\\n                    \\n                }\\n                while( end_root<n-1 && arr[end_root] > arr[end_root+1] )\\n                {\\n                    end_root++; //getting end root\\n                }\\n                max_length = max(max_length,(end_root-start_root+1));\\n                i = end_root;\\n            }\\n        }\\n        return max_length;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        // 1. IDENTIFY PEAKS\\n        // 2. TRAVERSE BACKWARDS WHILE PREVIOUS ELEMENT -\\n        // - IS SMALLER THAT CURRENT (i.e. GO TO THE START ROOT OF THE MOUNTAIN)\\n        // 3. TRAVERSE FORWARD WHILE NEXT ELEMENT IS SMALLER THAN CURRENT \\n        // (i.e. GO TO THE END ROOT OF THE MOUNTAIN)\\n        // 4 . ADD THEM TO CALCULATE THE MOUNTAIN LENGTH\\n        int max_length = 0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if((arr[i] > arr[i-1]) && (arr[i] > arr[i+1])) //PEAK CONDITION\\n            {\\n                int start_root = i;\\n                int end_root = i;\\n                while( start_root>0 && arr[start_root] > arr[start_root-1])\\n                {\\n                    start_root--; //getting start root\\n                    \\n                }\\n                while( end_root<n-1 && arr[end_root] > arr[end_root+1] )\\n                {\\n                    end_root++; //getting end root\\n                }\\n                max_length = max(max_length,(end_root-start_root+1));\\n                i = end_root;\\n            }\\n        }\\n        return max_length;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937652,
                "title": "python-one-pass-o-1-space-explained",
                "content": "Let us traverse our numbers and keep two variables: `state` and `length`, where:\\n1. `state` is current state of our mountain: it is `0` in the beginning and also means that we can not start our mountain from given index. `state` equal to `1` means, that we are on increasing phase of our mountain and `state` equal `2` means, that we are on decreasing phase of our mountain.\\n2. `length` is current length of mountain built so far.\\n\\nNow, we need to carefully look at our states and see what we need to do in one or another situation:\\n1. If `state` is equal to `0` or `1` and next element is more than current, it means we can continue to build increasing phase of mountain: so, we put `state` equal to `1` and increase `length` by `1`.\\n2. If `state` is equal to `2` and next element is more then curren, it means, that previous mountain just finished and we are currently buildind next mountain, for examle in `0,1,0,2,0`: first mountain is `0,1,0` and second is `0,2,0`. In this case we already build `2` elements of new mountain (mountains have `1` common element), so we put `length = 2` and `state = 1`.\\n3. If `state` is equal to `1` or `2` and next element is less than current, it means that we are on the decreasing phase of mountain: we put `state = 2` and also increase `length` by `1`. Note, that only here we need to update `max_len`, because our mountain is legible on this stage.\\n4. Finally, if we have some other option: it is either next element is equal to current, or we have state `0` and next element is less than previous, we need put our `state` and `length` to values as we just started.\\n\\n**Complexity**: time complexity is `O(n)`, we make one pass over data, space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def longestMountain(self, A):\\n        n, max_len = len(A), 0\\n        state, length = 0, 1\\n        for i in range(n-1):\\n            if state in [0, 1] and A[i+1] > A[i]:\\n                state, length = 1, length + 1\\n            elif state == 2 and A[i+1] > A[i]:\\n                state, length = 1, 2\\n            elif state in [1, 2] and A[i+1] < A[i]:\\n                state, length = 2, length + 1\\n                max_len = max(length, max_len)\\n            else:\\n                state, length = 0, 1\\n                \\n        return max_len\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A):\\n        n, max_len = len(A), 0\\n        state, length = 0, 1\\n        for i in range(n-1):\\n            if state in [0, 1] and A[i+1] > A[i]:\\n                state, length = 1, length + 1\\n            elif state == 2 and A[i+1] > A[i]:\\n                state, length = 1, 2\\n            elif state in [1, 2] and A[i+1] < A[i]:\\n                state, length = 2, length + 1\\n                max_len = max(length, max_len)\\n            else:\\n                state, length = 0, 1\\n                \\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244213,
                "title": "java-find-peak-and-stretch-easy-to-understand-o-2n",
                "content": "\\n```\\n\\npublic int longestMountain(int[] A) {\\n        if( A == null || A.length <3) \\n            return 0; \\n        int ans = 0; \\n        for(int i = 1; i < A.length - 1; i++ ) {\\n            if(A[i] > A[i-1] && A[i] > A[i+1]) {  // i is a peak\\n                int left = i -1;    // find leftmost of the peak\\n                while(left > 0 && A[left-1] < A[left])\\n                    left--;\\n                \\n                int right= i+1;  // find rightmost of the peak\\n                while(right < A.length - 1 && A[right + 1] < A[right])\\n                    right++;\\n                \\n                ans = Math.max(ans, right - left +1);  // get the width using left and rightmost\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic int longestMountain(int[] A) {\\n        if( A == null || A.length <3) \\n            return 0; \\n        int ans = 0; \\n        for(int i = 1; i < A.length - 1; i++ ) {\\n            if(A[i] > A[i-1] && A[i] > A[i+1]) {  // i is a peak\\n                int left = i -1;    // find leftmost of the peak\\n                while(left > 0 && A[left-1] < A[left])\\n                    left--;\\n                \\n                int right= i+1;  // find rightmost of the peak\\n                while(right < A.length - 1 && A[right + 1] < A[right])\\n                    right++;\\n                \\n                ans = Math.max(ans, right - left +1);  // get the width using left and rightmost\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1494992,
                "title": "easy-to-understand-c-o-n-time-o-1-space-beats-98-code-with-explanation",
                "content": "***If you like my approach,Please upvote this***\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        int i=1;\\n        int upper,lower;\\n        \\n        while(i<n)\\n       {    upper=0;lower=0;                  //Each time after traversing one mountain or not,we have to set upper & lower to 0\\n            while(i<n && arr[i-1]==arr[i])    //   for flat array,where elements are equal\\n              i++;                            //This also handles when we get same adjacent elements\\n            while(i<n && arr[i-1]<arr[i])     //Increasing part of mountain\\n            {  upper++;i++;\\n                \\n            }\\n                    \\n            \\n           while(i<n && arr[i-1]>arr[i])    //Decreasing part of mountain \\n           {\\n               lower++;\\n               i++;    \\n           } \\n          if(upper && lower)       //Mountain only exists if we have both incresing part and decreasing part adjacently\\n           { ans=max(ans,lower+upper+1);\\n           }\\n        \\n        }\\n        \\n        return ans;\\n     \\n    }\\n};\\n```\\n***Another Variation if we need to choose Subsequence not subarray***\\n***                                                                                                                         ***\\n***                                                                                                                         ***\\n```\\n class Solution\\n public:\\n   int longestMountain(vector<int>&arr){          //        This is valid if we are choosing subsequence not subarray.   //  \\n        vector<int> LIS(n,1);\\n        vector<int> LDS(n,1);\\n        for(int i=0;i<n;i++)\\n        {                                   //This is for longest increasing subsequence\\n            for(int j=i-1;j>=0;j--) \\n            {    if(arr[i]>arr[j] && LIS[j]+1>LIS[i])\\n                    LIS[i]=LIS[j]+1;\\n                \\n            }\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {                                     // This is for longest decreasing subsequence from start or Longest increasing from end \\n            for(int j=i+1;j<n;j++)\\n            {    if(arr[i]>arr[j] && LDS[j]+1>LDS[i])\\n                    LDS[i]=LDS[j]+1;\\n                \\n            }\\n        }\\n        int maxx=0;\\n        for(int i=0;i<n;i++)\\n        {  if(LIS[i]>1 && LDS[i]>1)\\n              maxx=max(maxx,LIS[i]+LDS[i]-1);    \\n        }\\n        if(maxx<3)                               // When length is less than 3 means no valid mountain \\n            return -1;\\n        return maxx;\\n  \\n  }\\n  };\\n  ```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        int i=1;\\n        int upper,lower;\\n        \\n        while(i<n)\\n       {    upper=0;lower=0;                  //Each time after traversing one mountain or not,we have to set upper & lower to 0\\n            while(i<n && arr[i-1]==arr[i])    //   for flat array,where elements are equal\\n              i++;                            //This also handles when we get same adjacent elements\\n            while(i<n && arr[i-1]<arr[i])     //Increasing part of mountain\\n            {  upper++;i++;\\n                \\n            }\\n                    \\n            \\n           while(i<n && arr[i-1]>arr[i])    //Decreasing part of mountain \\n           {\\n               lower++;\\n               i++;    \\n           } \\n          if(upper && lower)       //Mountain only exists if we have both incresing part and decreasing part adjacently\\n           { ans=max(ans,lower+upper+1);\\n           }\\n        \\n        }\\n        \\n        return ans;\\n     \\n    }\\n};\\n```\n```\\n class Solution\\n public:\\n   int longestMountain(vector<int>&arr){          //        This is valid if we are choosing subsequence not subarray.   //  \\n        vector<int> LIS(n,1);\\n        vector<int> LDS(n,1);\\n        for(int i=0;i<n;i++)\\n        {                                   //This is for longest increasing subsequence\\n            for(int j=i-1;j>=0;j--) \\n            {    if(arr[i]>arr[j] && LIS[j]+1>LIS[i])\\n                    LIS[i]=LIS[j]+1;\\n                \\n            }\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {                                     // This is for longest decreasing subsequence from start or Longest increasing from end \\n            for(int j=i+1;j<n;j++)\\n            {    if(arr[i]>arr[j] && LDS[j]+1>LDS[i])\\n                    LDS[i]=LDS[j]+1;\\n                \\n            }\\n        }\\n        int maxx=0;\\n        for(int i=0;i<n;i++)\\n        {  if(LIS[i]>1 && LDS[i]>1)\\n              maxx=max(maxx,LIS[i]+LDS[i]-1);    \\n        }\\n        if(maxx<3)                               // When length is less than 3 means no valid mountain \\n            return -1;\\n        return maxx;\\n  \\n  }\\n  };\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 937617,
                "title": "java-short-one-pass-o-n-time-o-1-space-with-comments",
                "content": "```\\n\\tpublic int longestMountain(int[] A) {\\n        int max = 0, inc = 0, dec = 0;\\n        \\n        for(int i=1; i<A.length; i++){\\n            if(A[i] > A[i-1]){       // Current number greater than the previous\\n                if(dec > 0) inc = 0; // Reset inc if we had a decreasing sequence until the previous\\n\\t\\t\\t\\tinc++;               // Increment inc\\n                dec = 0;             // Reset dec\\n            }\\n            else if(A[i] < A[i-1]){  // Current number smaller than the previous\\n                if(inc > 0){         // No need to do anything if we did not have an increasing sequence\\n                    dec++;           // Increment dec\\n                    max = Math.max(max, inc + dec + 1);  // Determine max for the current mountain\\n                }\\n            }\\n            else inc = dec = 0;      // Current number same as the previous, reset inc and dec\\n        }\\n        \\n        return max;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int longestMountain(int[] A) {\\n        int max = 0, inc = 0, dec = 0;\\n        \\n        for(int i=1; i<A.length; i++){\\n            if(A[i] > A[i-1]){       // Current number greater than the previous\\n                if(dec > 0) inc = 0; // Reset inc if we had a decreasing sequence until the previous\\n\\t\\t\\t\\tinc++;               // Increment inc\\n                dec = 0;             // Reset dec\\n            }\\n            else if(A[i] < A[i-1]){  // Current number smaller than the previous\\n                if(inc > 0){         // No need to do anything if we did not have an increasing sequence\\n                    dec++;           // Increment dec\\n                    max = Math.max(max, inc + dec + 1);  // Determine max for the current mountain\\n                }\\n            }\\n            else inc = dec = 0;      // Current number same as the previous, reset inc and dec\\n        }\\n        \\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 637837,
                "title": "java-3-passes-o-n",
                "content": "`left[i]` means the length of the left part of the mountain whose peak is a[i]\\n`right[i]` means the length of the right part of the mountain whose peak is a[i]\\nIf `left[i]` or `right[i]` is 0, this means that a[i] can\\'t be the peak.\\nThen just traversing again to get the longest mountain length;\\n```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int[] left = new int[a.length]; \\n        for (int i = 0 ; i < a.length; i++) {\\n            if (i != 0) {\\n                if (a[i] > a[i - 1]) {\\n                    left[i] = left[i - 1] + 1;\\n                }\\n            }\\n        }\\n        int[] right = new int[a.length];\\n        for (int i = a.length - 1; i >= 0 ; i--) {\\n            if (i != a.length - 1) {\\n                if (a[i] > a[i + 1]) {\\n                    right[i] = right[i + 1] + 1;\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0 ; i < a.length ; i++) {\\n            if (left[i] != 0 && right[i] != 0) {\\n                max = Math.max(left[i] + right[i] + 1, max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int[] left = new int[a.length]; \\n        for (int i = 0 ; i < a.length; i++) {\\n            if (i != 0) {\\n                if (a[i] > a[i - 1]) {\\n                    left[i] = left[i - 1] + 1;\\n                }\\n            }\\n        }\\n        int[] right = new int[a.length];\\n        for (int i = a.length - 1; i >= 0 ; i--) {\\n            if (i != a.length - 1) {\\n                if (a[i] > a[i + 1]) {\\n                    right[i] = right[i + 1] + 1;\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0 ; i < a.length ; i++) {\\n            if (left[i] != 0 && right[i] != 0) {\\n                max = Math.max(left[i] + right[i] + 1, max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937743,
                "title": "python-3-explained-solution-video-code",
                "content": "[](https://www.youtube.com/watch?v=FpO3fY-1mj8)\\nhttps://www.youtube.com/watch?v=FpO3fY-1mj8\\n```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        res = 0\\n        \\n        for indx in range(1, len(A) - 1):\\n            if A[indx - 1] < A[indx] > A[indx + 1]:\\n                \\n                l = r = indx\\n                \\n                while l > 0 and A[l] > A[l - 1]:\\n                    l -= 1\\n                \\n                while r + 1 < len(A) and A[r] > A[r + 1]:\\n                    r += 1\\n                \\n                res = max(res, (r - l + 1))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        res = 0\\n        \\n        for indx in range(1, len(A) - 1):\\n            if A[indx - 1] < A[indx] > A[indx + 1]:\\n                \\n                l = r = indx\\n                \\n                while l > 0 and A[l] > A[l - 1]:\\n                    l -= 1\\n                \\n                while r + 1 < len(A) and A[r] > A[r + 1]:\\n                    r += 1\\n                \\n                res = max(res, (r - l + 1))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419003,
                "title": "easy-to-understand-c-solution-20ms-beats-91",
                "content": "Runtime: 20 ms, faster than 91.45% of C++ online submissions for Longest Mountain in Array.\\nMemory Usage: 9.9 MB, less than 100.00% of C++ online submissions for Longest Mountain in Array.\\n\\n```\\nint longestMountain(vector<int>& A) {\\n        \\n        if(A.size() == 0)\\n            return 0;\\n        \\n        int maxLen = 0; \\n        for(int i=1; i<A.size()-1; i++)\\n        {\\n            if(A[i] > A[i+1] && A[i] > A[i-1])\\n            {\\n                int left = i-1;\\n                int right = i+1;\\n                \\n                while(left > 0 && A[left-1] < A[left])\\n                    left--;\\n                while(right < A.size()-1 && A[right+1] < A[right])\\n                    right++;\\n                maxLen = max(maxLen, right-left+1);\\n            }\\n        }\\n        return maxLen;\\n    }",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "Runtime: 20 ms, faster than 91.45% of C++ online submissions for Longest Mountain in Array.\\nMemory Usage: 9.9 MB, less than 100.00% of C++ online submissions for Longest Mountain in Array.\\n\\n```\\nint longestMountain(vector<int>& A) {\\n        \\n        if(A.size() == 0)\\n            return 0;\\n        \\n        int maxLen = 0; \\n        for(int i=1; i<A.size()-1; i++)\\n        {\\n            if(A[i] > A[i+1] && A[i] > A[i-1])\\n            {\\n                int left = i-1;\\n                int right = i+1;\\n                \\n                while(left > 0 && A[left-1] < A[left])\\n                    left--;\\n                while(right < A.size()-1 && A[right+1] < A[right])\\n                    right++;\\n                maxLen = max(maxLen, right-left+1);\\n            }\\n        }\\n        return maxLen;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1107624,
                "title": "6-liner-c-peak-valley-approach",
                "content": "```\\nint longestMountain(vector<int>& arr) {\\n        \\n        int maxl = 0, i = 1;\\n        \\n        while(i < arr.size()) {\\n            \\n            int peak = 0, valley = 0;\\n            while(i < arr.size() && arr[i] > arr[i - 1]) peak++, i++;\\n            while(i < arr.size() && arr[i] < arr[i - 1]) valley++, i++;\\n            if(peak > 0 && valley > 0) maxl = max(maxl, peak + valley + 1);\\n            else if(!peak && !valley) i++;\\n        }\\n        return maxl;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint longestMountain(vector<int>& arr) {\\n        \\n        int maxl = 0, i = 1;\\n        \\n        while(i < arr.size()) {\\n            \\n            int peak = 0, valley = 0;\\n            while(i < arr.size() && arr[i] > arr[i - 1]) peak++, i++;\\n            while(i < arr.size() && arr[i] < arr[i - 1]) valley++, i++;\\n            if(peak > 0 && valley > 0) maxl = max(maxl, peak + valley + 1);\\n            else if(!peak && !valley) i++;\\n        }\\n        return maxl;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 135612,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        if (A.length < 3) return 0;\\n        int[] increase = new int[A.length];\\n        int[] decrease = new int[A.length];\\n        Arrays.fill(increase, 1);\\n        Arrays.fill(decrease, 1);\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] > A[i-1]) increase[i] = increase[i-1]+1;\\n        }\\n       \\n        \\n        for (int i = A.length-2; i >= 0; i--) {\\n            if (A[i] > A[i+1]) decrease[i] = decrease[i+1]+1;\\n        }\\n       \\n        int res = Integer.MIN_VALUE;\\n        for (int i = 1; i < A.length - 1; i++) {\\n            if (A[i] > A[i-1] && A[i] > A[i+1]) {\\n                res = Math.max(res, increase[i-1] + decrease[i+1] + 1);\\n            }\\n        }\\n        return res == Integer.MIN_VALUE ? 0 : res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        if (A.length < 3) return 0;\\n        int[] increase = new int[A.length];\\n        int[] decrease = new int[A.length];\\n        Arrays.fill(increase, 1);\\n        Arrays.fill(decrease, 1);\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] > A[i-1]) increase[i] = increase[i-1]+1;\\n        }\\n       \\n        \\n        for (int i = A.length-2; i >= 0; i--) {\\n            if (A[i] > A[i+1]) decrease[i] = decrease[i+1]+1;\\n        }\\n       \\n        int res = Integer.MIN_VALUE;\\n        for (int i = 1; i < A.length - 1; i++) {\\n            if (A[i] > A[i-1] && A[i] > A[i+1]) {\\n                res = Math.max(res, increase[i-1] + decrease[i+1] + 1);\\n            }\\n        }\\n        return res == Integer.MIN_VALUE ? 0 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945774,
                "title": "c-linear-solution-explained-100-time-50-space",
                "content": "Nice one I took my time to polish a bit and I had fun thinking about how to optimise reducing the amount of conditions/states we would have to consider.\\n\\nTo solve it, first of all let\\'s get equipped with a few variables:\\n* `res` will store the value of the maximum mountain found so far;\\n* `curr` is the value of the ongoing mountain length;\\n* `len` is the length of the initial input;\\n* `isMountain` and `isDescending` are 2 booleans to store the state, precisely in the guise their name implies.\\n\\nWe will then start looping from index `i == 1` across the whole vector and:\\n* if we are descending we will:\\n\\t* check if we need to reset our range - if either `isDescending` was `true` or `isMountain` was `false` and, in that case, we:\\n\\t\\t* set `isDescending` to `false`;\\n\\t\\t* set `isMountain` to `true`;\\n\\t\\t* reset `curr` to `1` (note: not to `0`, since we count both extremes of the range in its length);\\n\\t* in any case, we increment `curr` by one step;\\n* if we are in a mountain already and only in that case, we will:\\n\\t* if we are descending we will:\\n\\t\\t* flag `isDescending` as `true`;\\n\\t\\t* update `res` to be the maximum between its current value and the incremented value of `curr`;\\n\\t* if instead we reached a plataue, we reset `isMountain` (which in turn will trigger other variables resetting as soon as we start ascending again and only in that case).\\n\\nOnce we are done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // support variables\\n        int res = 0, curr = 0, len = arr.size();\\n        bool isMountain = false, isDescending = false;\\n        for (int i = 1; i < len; i++) {\\n            // checking if we are climbing\\n            if (arr[i] > arr[i - 1]) {\\n                // reset conditions: either we were descending or we were\\n                // not yet in a mountain\\n                if (isDescending || !isMountain) {\\n                    isDescending = false;\\n                    isMountain = true;\\n                    curr = 1;\\n                }\\n                curr++;\\n            }\\n            // checking if we are already in a mountain\\n            else if (isMountain) {\\n                // if we start descending\\n                if  (arr[i] < arr[i - 1]) {\\n                    isDescending = true;\\n                    res = max(++curr, res);\\n                }\\n                // if we reach a plateau\\n                else if (arr[i] == arr[i - 1]) isMountain = false;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nSlightly optimised version (I gained 4ms on average running this) in which we update `res` only when either we begin ascending again or we finished the loop while still descending:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // support variables\\n        int res = 0, curr = 0, len = arr.size();\\n        bool isMountain = false, isDescending = false;\\n        for (int i = 1; i < len; i++) {\\n            // checking if we are climbing\\n            if (arr[i] > arr[i - 1]) {\\n                // reset conditions: either we were descending or we were\\n                // not yet in a mountain\\n                if (isDescending || !isMountain) {\\n                    if (isDescending) res = max(curr, res);\\n                    isDescending = false;\\n                    isMountain = true;\\n                    curr = 1;\\n                }\\n                curr++;\\n            }\\n            // checking if we are already in a mountain\\n            else if (isMountain) {\\n                // if we start descending\\n                if  (arr[i] < arr[i - 1]) {\\n                    isDescending = true;\\n                    curr++;\\n                }\\n                // if we reach a plateau\\n                else if (arr[i] == arr[i - 1]) {\\n                    isMountain = false;\\n                }\\n            }\\n        }\\n        if (isDescending) res = max(curr, res);\\n        return res;\\n    }\\n};\\n```\\n\\nThe first version of my code, which for some reason I have not completely clarified went much slower, taking about double time:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        if (!arr.size()) return 0;\\n        int res = 0, prev = arr[0], len = arr.size() - 1, minPos = -2, maxPos = -1;\\n        for (int i = 0, n; i < len; i++) {\\n            n = arr[i];\\n            // checking for a new min\\n            if (minPos < maxPos && n < arr[i + 1]) {\\n                // updating res if we already met a max\\n                if (maxPos > -1) res = max(res, i - minPos + 1);\\n                minPos = i;\\n                maxPos = -1;\\n            }\\n            // checking for a new max, only after having met a min\\n            else if (n > arr[i + 1] && minPos > maxPos) maxPos = i;\\n            // checking if we encountered a plateau\\n            else if (n == arr[i + 1]) {\\n                // we update res only if we already encountered a max after the last min\\n                // followed by at least another decreasing number\\n                if (minPos < maxPos && minPos > -2 && maxPos > -1) res = max(res, i - minPos + 1);\\n                minPos = -2;\\n                maxPos = -1;\\n            }\\n        }\\n        // one final check to update res with the distance between minPos and the last index\\n        // provided we have encountered a local maximum before\\n        if (maxPos > -1 && arr[len - 1] > arr[len]) res = max(res, len - minPos + 1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // support variables\\n        int res = 0, curr = 0, len = arr.size();\\n        bool isMountain = false, isDescending = false;\\n        for (int i = 1; i < len; i++) {\\n            // checking if we are climbing\\n            if (arr[i] > arr[i - 1]) {\\n                // reset conditions: either we were descending or we were\\n                // not yet in a mountain\\n                if (isDescending || !isMountain) {\\n                    isDescending = false;\\n                    isMountain = true;\\n                    curr = 1;\\n                }\\n                curr++;\\n            }\\n            // checking if we are already in a mountain\\n            else if (isMountain) {\\n                // if we start descending\\n                if  (arr[i] < arr[i - 1]) {\\n                    isDescending = true;\\n                    res = max(++curr, res);\\n                }\\n                // if we reach a plateau\\n                else if (arr[i] == arr[i - 1]) isMountain = false;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // support variables\\n        int res = 0, curr = 0, len = arr.size();\\n        bool isMountain = false, isDescending = false;\\n        for (int i = 1; i < len; i++) {\\n            // checking if we are climbing\\n            if (arr[i] > arr[i - 1]) {\\n                // reset conditions: either we were descending or we were\\n                // not yet in a mountain\\n                if (isDescending || !isMountain) {\\n                    if (isDescending) res = max(curr, res);\\n                    isDescending = false;\\n                    isMountain = true;\\n                    curr = 1;\\n                }\\n                curr++;\\n            }\\n            // checking if we are already in a mountain\\n            else if (isMountain) {\\n                // if we start descending\\n                if  (arr[i] < arr[i - 1]) {\\n                    isDescending = true;\\n                    curr++;\\n                }\\n                // if we reach a plateau\\n                else if (arr[i] == arr[i - 1]) {\\n                    isMountain = false;\\n                }\\n            }\\n        }\\n        if (isDescending) res = max(curr, res);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        if (!arr.size()) return 0;\\n        int res = 0, prev = arr[0], len = arr.size() - 1, minPos = -2, maxPos = -1;\\n        for (int i = 0, n; i < len; i++) {\\n            n = arr[i];\\n            // checking for a new min\\n            if (minPos < maxPos && n < arr[i + 1]) {\\n                // updating res if we already met a max\\n                if (maxPos > -1) res = max(res, i - minPos + 1);\\n                minPos = i;\\n                maxPos = -1;\\n            }\\n            // checking for a new max, only after having met a min\\n            else if (n > arr[i + 1] && minPos > maxPos) maxPos = i;\\n            // checking if we encountered a plateau\\n            else if (n == arr[i + 1]) {\\n                // we update res only if we already encountered a max after the last min\\n                // followed by at least another decreasing number\\n                if (minPos < maxPos && minPos > -2 && maxPos > -1) res = max(res, i - minPos + 1);\\n                minPos = -2;\\n                maxPos = -1;\\n            }\\n        }\\n        // one final check to update res with the distance between minPos and the last index\\n        // provided we have encountered a local maximum before\\n        if (maxPos > -1 && arr[len - 1] > arr[len]) res = max(res, len - minPos + 1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937951,
                "title": "c-dp-simplification-from-2pass-to-1-pass",
                "content": "```\\nclass Solution {// DP: two pass\\npublic://Time/Space: O(N); O(N)\\n    int longestMountain(vector<int>& A) {\\n        const int N = A.size();\\n        vector<int> ups(N, 0), downs(N, 0);\\n        for(int i = 1; i < N; i++) if(A[i] > A[i-1]) ups[i] = ups[i-1]+1;\\n        int ans = 0;\\n        for(int i = N - 1; i >= 0; i--){\\n            if(i < N - 1 && A[i] > A[i+1]) downs[i] = downs[i+1]+1;\\n            if(ups[i] && downs[i]) ans = max(ans, ups[i] + downs[i] + 1);            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIllustration with Example 1: \\n[2,1,4,7,3,2,5]\\n[1,4,7,3,2] \\n\\n\\nIn this solution, accumulate latest up length and down length.\\nBoth up and down length are reset to 0 when \\ni) A[i - 1] == A[i], which means we are in plateau\\nor\\nii) down > 0 && A[i - 1] < A[i], which means a new up trend begin like the middle point of \\'M\\'\\n\\n\\n```\\nclass Solution { // DP\\uFF1A One Pass\\npublic:// Time/Space: O(N); O(1)\\n    int longestMountain(vector<int>& A) {\\n        int ans = 0, up = 0, down = 0;\\n        for(int i = 1; i < A.size(); i++){\\n            if(down && A[i-1]<A[i] || A[i-1] == A[i]) up = down = 0;\\n            up += A[i-1] < A[i];\\n            down += A[i-1] > A[i];\\n            if(up && down) ans = max(ans, up + down + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nReferece\\n[1]: https://leetcode.com/problems/longest-mountain-in-array/discuss/135593/C%2B%2BJavaPython-1-pass-and-O(1)-space\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {// DP: two pass\\npublic://Time/Space: O(N); O(N)\\n    int longestMountain(vector<int>& A) {\\n        const int N = A.size();\\n        vector<int> ups(N, 0), downs(N, 0);\\n        for(int i = 1; i < N; i++) if(A[i] > A[i-1]) ups[i] = ups[i-1]+1;\\n        int ans = 0;\\n        for(int i = N - 1; i >= 0; i--){\\n            if(i < N - 1 && A[i] > A[i+1]) downs[i] = downs[i+1]+1;\\n            if(ups[i] && downs[i]) ans = max(ans, ups[i] + downs[i] + 1);            \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution { // DP\\uFF1A One Pass\\npublic:// Time/Space: O(N); O(1)\\n    int longestMountain(vector<int>& A) {\\n        int ans = 0, up = 0, down = 0;\\n        for(int i = 1; i < A.size(); i++){\\n            if(down && A[i-1]<A[i] || A[i-1] == A[i]) up = down = 0;\\n            up += A[i-1] < A[i];\\n            down += A[i-1] > A[i];\\n            if(up && down) ans = max(ans, up + down + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 406481,
                "title": "java-b-f-one-pass-dp-solutions-with-explanations-easy-understand",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/longest-mountain-in-array/)\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n## Problem\\n\\n> Let\\'s call any (contiguous) subarray B (of A) a mountain if the following properties hold:\\n\\n- B.length >= 3\\n- There exists some `0 < i < B.length - 1` such that `B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]`\\n\\n(Note that B could be any subarray of A, including the entire array A.)\\n\\n> Given an array A of integers, return the length of the longest mountain. \\n\\n> Return `0` if there is no mountain.\\n\\n**Note:** \\n\\n- 0 <= A.length <= 10000\\n  - Indicate that `O(N^2)` is not okay.\\n- 0 <= A[i] <= 10000\\n\\n**Example:** \\n\\n```java\\nInput: [2,2,2] or [1,2,2]\\nOutput: 0\\nExplanation: There is no mountain.\\n\\nInput: [1,2,3]\\nOutput: 0\\n\\nInput: [2,1,4,7,3,2,5]\\n          --------- 5\\nOutput: 5\\nExplanation: The largest mountain is [1,4,7,3,2] which has length 5.\\n\\nInput: [2,1,4,7,3,2,3,7,6,5,1]\\n          --------- 5\\n                  ----------- 6\\nOutput: 6\\n```\\n\\n**Follow up:** \\n\\n- Can you solve it using only one pass?\\n- Can you solve it in O(1) space?\\n\\n\\n## Analysis\\n\\n### Brute-Force\\n\\nFor an array of size `n`, we compute the mountain lengths for every subarray from size at least `3` to `n`.\\n\\n**Note:** Be very careful about the index update.\\n\\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int maxLen = 0;\\n  for (int len = 3; len <= n; ++len) {\\n    for (int i = 0; i + len - 1 < n; ++i) {\\n      int end = i + len - 1;\\n      maxLen = Math.max(maxLen, mountainLen(A, i, end));\\n    }\\n  }\\n  return maxLen;\\n}\\n```\\n\\nIn terms of the mountain length calculation (the mountain should start from the first element), check out the examples in comments. The following code is similar to the one-pointer solution.\\n\\n```java\\nprivate int mountainLen(int[] A, int lo, int hi) {\\n  int n = hi - lo + 1;\\n  if (n < 3) {\\n    return 0;\\n  }\\n  // 5 4 3 2 1    -> no mountain\\n  //   i\\n  // 1 2 3 4 5    -> no mountain\\n  //   i       i\\n  // 1 2 3 2 1    -> returns i = n\\n  //   i   i   i\\n  // 1 2 3 2 1 2  -> returns i = n - 1 (not includes the last element)\\n  //   i   i   i \\n  int i = lo + 1;\\n  while (i <= hi && A[i - 1] < A[i]) {\\n    ++i;\\n  }\\n  if (i == lo + 1 || i == hi + 1) return 0; // no mountain\\n  // i now points to the first element that A[i - 1] > A[i]\\n  while (i <= hi && A[i - 1] > A[i]) {\\n    ++i;\\n  }\\n  return i - lo;\\n}\\n```\\n\\n**Time:** `O(N^3)` (unacceptable)\\n**Space:** `O(1)`\\n\\n\\n\\n### One-Pass (one pointer)\\n\\nBy observation of the example below, we can actually go through the array and get the maximum mountain length in one pass.\\n\\n```java\\n 0 1 2 3 4 5 6 7 8 9 10\\n[2,1,4,7,3,2,3,7,6,5,1]\\n   --------- 5\\n           ----------- 6\\n```\\n\\nIn order to do that, we have to simulate the `going-up` and `going-down` processes in order. For example, while going up, the start point is at `1`, the peek is at `3`, and the end point is at `5`. We cannot go further, so we have a mountain of length 5. We do that for the following mountain until we reach the end of the array.\\n\\nThe idea is not difficult, but the implementation is because of index manipulation and special/corner cases. Try to come up with some small examples and get some invariants.\\n\\n**Note:** \\n\\n- Since we check elements at `A[i]` and `A[i + 1]`, the condition is `i < n - 1`.\\n- Record the starting point in each process, reconstruct a new mountain if `i` does not move at all (which means invalidity).\\n- Go through your code for cases: `[1,2,2]`, `[2]`, `[1,2,3]`, `[3,2,1]`.\\n\\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int maxLen = 0;\\n  int i = 0;\\n  while (i < n - 1) {\\n    int upStart = i;\\n    // Go up\\n    while (i < n - 1 && A[i] < A[i + 1]) ++i;\\n    if (i == upStart) { // does not move\\n      ++i; continue;\\n    } // i stops the peek\\n    // Go down\\n    int downStart = i;\\n    while (i < n - 1 && A[i] > A[i + 1]) ++i;\\n    if (i == downStart) {\\n      ++i; continue;\\n    } // i stops at the last in the subarray\\n    // Update length\\n    int len = i - upStart + 1;\\n    maxLen = Math.max(maxLen, len);\\n  }\\n  return maxLen;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(1)`\\n\\n\\n\\n### DP\\n\\nUse extra two arrays `inc[]` and `dec[]` to store information we need and then go through the array.\\n\\n- **inc[i]**: The maximum increasing length for the subarray ending at `i`. (constructed from left)\\n  - For example: `[1,2,3]` the `inc[i] = [0,1,2]`.\\n- **dec[i]**: The maximum decreasing length for the subarray starting at `i`. (constructed from right)\\n- Both `inc[]` and `dec[]` are initialized with `0`.\\n\\nThen we go through the array from `1` to `n - 1` for each possible peak. We calculate the peak only when `inc[i]` and `dec[i]` are both non-zero.\\n\\n**Note:** The length is `inc[i] + dec[i] + 1`.\\n\\n```java\\n// inc[] and inc[] are initialized with 0\\nindex    0   1   2   3   4   5   6   7   8   9   10\\n------------------------------------------------------\\n         2   1   4   7   3   2   3   7   6   5   1\\ninc[i]   0   0   1   2   0   0   1   2   0   0   0\\ndec[i]   0   0   0   2   1   0   0   3   2   1   0\\n------------------------------------------------------\\nlen          0   0 4+1=5 0   0   0 5+1=6 0   0   0\\n```\\n\\nHere is the code:\\n\\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int[] inc = new int[n]; // init with 0\\n  int[] dec = new int[n]; \\n  for (int i = 1, j = n - 2; i < n; ++i, --j) {\\n    if (A[i - 1] < A[i]) inc[i] = inc[i - 1] + 1;\\n    if (A[j] > A[j + 1]) dec[j] = dec[j + 1] + 1;\\n    // otherwise, keep it 0\\n  }\\n  // for each possible peak\\n  int maxLen = 0;\\n  for (int i = 1; i < n - 1; ++i) {\\n    if (inc[i] > 0 && dec[i] > 0) {\\n      maxLen = Math.max(maxLen, inc[i] + dec[i] + 1);\\n    }\\n  }\\n  return maxLen;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(N)`",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nInput: [2,2,2] or [1,2,2]\\nOutput: 0\\nExplanation: There is no mountain.\\n\\nInput: [1,2,3]\\nOutput: 0\\n\\nInput: [2,1,4,7,3,2,5]\\n          --------- 5\\nOutput: 5\\nExplanation: The largest mountain is [1,4,7,3,2] which has length 5.\\n\\nInput: [2,1,4,7,3,2,3,7,6,5,1]\\n          --------- 5\\n                  ----------- 6\\nOutput: 6\\n```\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int maxLen = 0;\\n  for (int len = 3; len <= n; ++len) {\\n    for (int i = 0; i + len - 1 < n; ++i) {\\n      int end = i + len - 1;\\n      maxLen = Math.max(maxLen, mountainLen(A, i, end));\\n    }\\n  }\\n  return maxLen;\\n}\\n```\n```java\\nprivate int mountainLen(int[] A, int lo, int hi) {\\n  int n = hi - lo + 1;\\n  if (n < 3) {\\n    return 0;\\n  }\\n  // 5 4 3 2 1    -> no mountain\\n  //   i\\n  // 1 2 3 4 5    -> no mountain\\n  //   i       i\\n  // 1 2 3 2 1    -> returns i = n\\n  //   i   i   i\\n  // 1 2 3 2 1 2  -> returns i = n - 1 (not includes the last element)\\n  //   i   i   i \\n  int i = lo + 1;\\n  while (i <= hi && A[i - 1] < A[i]) {\\n    ++i;\\n  }\\n  if (i == lo + 1 || i == hi + 1) return 0; // no mountain\\n  // i now points to the first element that A[i - 1] > A[i]\\n  while (i <= hi && A[i - 1] > A[i]) {\\n    ++i;\\n  }\\n  return i - lo;\\n}\\n```\n```java\\n 0 1 2 3 4 5 6 7 8 9 10\\n[2,1,4,7,3,2,3,7,6,5,1]\\n   --------- 5\\n           ----------- 6\\n```\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int maxLen = 0;\\n  int i = 0;\\n  while (i < n - 1) {\\n    int upStart = i;\\n    // Go up\\n    while (i < n - 1 && A[i] < A[i + 1]) ++i;\\n    if (i == upStart) { // does not move\\n      ++i; continue;\\n    } // i stops the peek\\n    // Go down\\n    int downStart = i;\\n    while (i < n - 1 && A[i] > A[i + 1]) ++i;\\n    if (i == downStart) {\\n      ++i; continue;\\n    } // i stops at the last in the subarray\\n    // Update length\\n    int len = i - upStart + 1;\\n    maxLen = Math.max(maxLen, len);\\n  }\\n  return maxLen;\\n}\\n```\n```java\\n// inc[] and inc[] are initialized with 0\\nindex    0   1   2   3   4   5   6   7   8   9   10\\n------------------------------------------------------\\n         2   1   4   7   3   2   3   7   6   5   1\\ninc[i]   0   0   1   2   0   0   1   2   0   0   0\\ndec[i]   0   0   0   2   1   0   0   3   2   1   0\\n------------------------------------------------------\\nlen          0   0 4+1=5 0   0   0 5+1=6 0   0   0\\n```\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int[] inc = new int[n]; // init with 0\\n  int[] dec = new int[n]; \\n  for (int i = 1, j = n - 2; i < n; ++i, --j) {\\n    if (A[i - 1] < A[i]) inc[i] = inc[i - 1] + 1;\\n    if (A[j] > A[j + 1]) dec[j] = dec[j + 1] + 1;\\n    // otherwise, keep it 0\\n  }\\n  // for each possible peak\\n  int maxLen = 0;\\n  for (int i = 1; i < n - 1; ++i) {\\n    if (inc[i] > 0 && dec[i] > 0) {\\n      maxLen = Math.max(maxLen, inc[i] + dec[i] + 1);\\n    }\\n  }\\n  return maxLen;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022776,
                "title": "java-100-faster-one-pass",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int max = 0;\\n        \\n        for(int i = 1; i < arr.length-1; i++) {\\n            if(arr[i-1] < arr[i] && arr[i] > arr[i+1]) {\\n                int left = i-1;\\n                int right = i+1;\\n                \\n                while(left > 0 && arr[left-1] < arr[left]) left--;\\n                while(right < arr.length-1 && arr[right] > arr[right+1]) right++;\\n                \\n                max = Math.max(max, right-left+1);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int max = 0;\\n        \\n        for(int i = 1; i < arr.length-1; i++) {\\n            if(arr[i-1] < arr[i] && arr[i] > arr[i+1]) {\\n                int left = i-1;\\n                int right = i+1;\\n                \\n                while(left > 0 && arr[left-1] < arr[left]) left--;\\n                while(right < arr.length-1 && arr[right] > arr[right+1]) right++;\\n                \\n                max = Math.max(max, right-left+1);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938030,
                "title": "longest-mountain-in-array-java",
                "content": "```\\nclass Solution \\n{\\n    /* First scan the array for peaks (i.e. a value where the previous and next value are both \\n     * lower.)  Once a peak is found scan foreword and back to determine how wide this particular\\n     * peak is.  Return the max of the values found.\\n     */\\n    \\n    public int longestMountain(int[] A) \\n    {\\n        int     ret = 0;\\n        int     n   = A.length - 1; \\n        \\n        for( int i = 1; i < n; i++ )\\n        {\\n            if( A[ i - 1 ] < A[ i ] && A[ i ] > A[ i + 1 ] )\\n            {\\n                int     l = i;\\n                \\n                while( l > 0 && A[ l - 1 ] < A[ l ] )       l--;\\n                while( i < n && A[ i + 1 ] < A[ i ] )       i++;\\n                \\n                ret = Math.max( ret, i - l + 1 );\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    /* First scan the array for peaks (i.e. a value where the previous and next value are both \\n     * lower.)  Once a peak is found scan foreword and back to determine how wide this particular\\n     * peak is.  Return the max of the values found.\\n     */\\n    \\n    public int longestMountain(int[] A) \\n    {\\n        int     ret = 0;\\n        int     n   = A.length - 1; \\n        \\n        for( int i = 1; i < n; i++ )\\n        {\\n            if( A[ i - 1 ] < A[ i ] && A[ i ] > A[ i + 1 ] )\\n            {\\n                int     l = i;\\n                \\n                while( l > 0 && A[ l - 1 ] < A[ l ] )       l--;\\n                while( i < n && A[ i + 1 ] < A[ i ] )       i++;\\n                \\n                ret = Math.max( ret, i - l + 1 );\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150136,
                "title": "simple-o-n-one-pass-o-1-space-java-ac-solution-beats-99-05",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int longestMountain = 0;\\n        for (int i = 1; i < A.length-1; i++) {\\n            if (A[i-1] < A[i] && A[i+1] < A[i]) {\\n                int l = i-1;\\n                int r = i+1;\\n                while(l > 0 && A[l-1] < A[l]) {\\n                    l--;\\n                }\\n                while(r < A.length-1 && A[r+1] < A[r]) {\\n                    r++;\\n                }\\n                longestMountain = Math.max(longestMountain, (r - l + 1));\\n            }\\n        }\\n        return longestMountain;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int longestMountain = 0;\\n        for (int i = 1; i < A.length-1; i++) {\\n            if (A[i-1] < A[i] && A[i+1] < A[i]) {\\n                int l = i-1;\\n                int r = i+1;\\n                while(l > 0 && A[l-1] < A[l]) {\\n                    l--;\\n                }\\n                while(r < A.length-1 && A[r+1] < A[r]) {\\n                    r++;\\n                }\\n                longestMountain = Math.max(longestMountain, (r - l + 1));\\n            }\\n        }\\n        return longestMountain;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937867,
                "title": "longest-mountain-in-array-c-explained",
                "content": "The question is very similar to https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ , I highly recommend you to solve first and give a try to this question before going though the solution.\\n\\nThe idea is simple, since a mountain has a rise(slope or upper_tail) and a fall(descent or lower_tail), we keep track of it.\\n\\nNote that if a mountain exists , it should definietly have a non zero upper_tail and a lower_tail.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int result = 0;\\n        int lower_tail, upper_tail;\\n        \\n        for(int i = 0 ; i < A.size();){\\n            lower_tail = upper_tail = 0;\\n            while(i + 1 < A.size() && A[i] < A[i + 1]){\\n                upper_tail++;\\n                i++;\\n            }\\n             while(upper_tail > 0 && i + 1 < A.size() && A[i] > A[i + 1]){\\n                lower_tail++;\\n                i++;\\n            }\\n            if(lower_tail > 0 && upper_tail > 0)\\n                result = max(result, lower_tail + upper_tail + 1);\\n            else if(lower_tail == 0)\\n                i++;\\n        }\\n        return result;\\n    }\\n};\\n```\\nThank you, Have a nice day",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int result = 0;\\n        int lower_tail, upper_tail;\\n        \\n        for(int i = 0 ; i < A.size();){\\n            lower_tail = upper_tail = 0;\\n            while(i + 1 < A.size() && A[i] < A[i + 1]){\\n                upper_tail++;\\n                i++;\\n            }\\n             while(upper_tail > 0 && i + 1 < A.size() && A[i] > A[i + 1]){\\n                lower_tail++;\\n                i++;\\n            }\\n            if(lower_tail > 0 && upper_tail > 0)\\n                result = max(result, lower_tail + upper_tail + 1);\\n            else if(lower_tail == 0)\\n                i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937588,
                "title": "c-one-pass-in-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) \\n    {\\n        int i,n=a.size(),res,l,h,ind,maxi=0;\\n        if(n==0) return 0;\\n        for(i=1;i<n-1;i++)\\n        {\\n            if(a[i-1]<a[i] && a[i]>a[i+1])\\n            {\\n                l=i-1; h=i+1;\\n                while(l>0 && a[l]>a[l-1]) l--;\\n                while(h<n-1 && a[h]>a[h+1]) h++;\\n                maxi=max(maxi,h-l+1);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) \\n    {\\n        int i,n=a.size(),res,l,h,ind,maxi=0;\\n        if(n==0) return 0;\\n        for(i=1;i<n-1;i++)\\n        {\\n            if(a[i-1]<a[i] && a[i]>a[i+1])\\n            {\\n                l=i-1; h=i+1;\\n                while(l>0 && a[l]>a[l-1]) l--;\\n                while(h<n-1 && a[h]>a[h+1]) h++;\\n                maxi=max(maxi,h-l+1);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304129,
                "title": "c-fastest-solution-o-n-tc-sc-lis",
                "content": "TC: O(n)\\nSC: O(n)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>left(n,1),right(n,1);\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[i-1])\\n                left[i]=left[i-1]+1;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]>nums[i+1])\\n                right[i]=right[i+1]+1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(left[i]>1 && right[i]>1)ans=max(ans,left[i]+right[i]-1);\\n                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>left(n,1),right(n,1);\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[i-1])\\n                left[i]=left[i-1]+1;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]>nums[i+1])\\n                right[i]=right[i+1]+1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(left[i]>1 && right[i]>1)ans=max(ans,left[i]+right[i]-1);\\n                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272599,
                "title": "c-java-python-very-easy-to-understand-one-pass-o-1-space-o-n-time",
                "content": "I would suggest a dry run on an example in order to better understand the code.\\n\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int maxMountain = 0, n = arr.size(), idx = 1, up = 0, down = 0;\\n        while (idx < n) {\\n            while(idx < n && arr[idx - 1] == arr[idx])\\n                ++idx;\\n            // start looking further in array for a possible mountain\\n            up = 0;\\n            while(idx < n && arr[idx - 1] < arr[idx])\\n                ++up, ++idx;\\n            down = 0;\\n            while(idx < n && arr[idx - 1] > arr[idx])\\n                ++down, ++idx;\\n            if(up && down)  \\n                // + 1 as we do add the peak itself\\n                maxMountain = max(maxMountain, up + down + 1);\\n        }\\n        return maxMountain;\\n    }\\n};\\n```\\n\\nJava: \\n\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int maxMountain = 0, idx = 1, up = 0, down = 0, n = arr.length;\\n        while(idx < n) {\\n            while(idx < n && arr[idx - 1] == arr[idx])\\n                ++idx;\\n            up = 0;\\n            while(idx < n && arr[idx - 1] < arr[idx]) {\\n                ++up;\\n                ++idx;\\n            }\\n            down = 0;\\n            while(idx < n && arr[idx - 1] > arr[idx]) {\\n                ++down;\\n                ++idx;\\n            }\\n            if(up > 0 && down > 0)\\n                maxMountain = Math.max(maxMountain, up + down + 1);\\n        }\\n        return maxMountain;\\n    }\\n}\\n```\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        idx = 1\\n        up = 0\\n        down = 0\\n        maxMountain = 0\\n        \\n        while idx < n:\\n            while idx < n and arr[idx - 1] == arr[idx]:\\n                idx += 1\\n            up = 0\\n            while idx < n and arr[idx - 1] < arr[idx]:\\n                up += 1\\n                idx += 1\\n            down = 0\\n            while idx < n and arr[idx - 1] > arr[idx]:\\n                down += 1\\n                idx += 1\\n            if up > 0 and down > 0:\\n                maxMountain = max(maxMountain, up + down + 1)\\n                \\n        return \\n```\\n\\nThanks for reading, an upvote would be appreciated! ^_^",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int maxMountain = 0, n = arr.size(), idx = 1, up = 0, down = 0;\\n        while (idx < n) {\\n            while(idx < n && arr[idx - 1] == arr[idx])\\n                ++idx;\\n            // start looking further in array for a possible mountain\\n            up = 0;\\n            while(idx < n && arr[idx - 1] < arr[idx])\\n                ++up, ++idx;\\n            down = 0;\\n            while(idx < n && arr[idx - 1] > arr[idx])\\n                ++down, ++idx;\\n            if(up && down)  \\n                // + 1 as we do add the peak itself\\n                maxMountain = max(maxMountain, up + down + 1);\\n        }\\n        return maxMountain;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int maxMountain = 0, idx = 1, up = 0, down = 0, n = arr.length;\\n        while(idx < n) {\\n            while(idx < n && arr[idx - 1] == arr[idx])\\n                ++idx;\\n            up = 0;\\n            while(idx < n && arr[idx - 1] < arr[idx]) {\\n                ++up;\\n                ++idx;\\n            }\\n            down = 0;\\n            while(idx < n && arr[idx - 1] > arr[idx]) {\\n                ++down;\\n                ++idx;\\n            }\\n            if(up > 0 && down > 0)\\n                maxMountain = Math.max(maxMountain, up + down + 1);\\n        }\\n        return maxMountain;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        idx = 1\\n        up = 0\\n        down = 0\\n        maxMountain = 0\\n        \\n        while idx < n:\\n            while idx < n and arr[idx - 1] == arr[idx]:\\n                idx += 1\\n            up = 0\\n            while idx < n and arr[idx - 1] < arr[idx]:\\n                up += 1\\n                idx += 1\\n            down = 0\\n            while idx < n and arr[idx - 1] > arr[idx]:\\n                down += 1\\n                idx += 1\\n            if up > 0 and down > 0:\\n                maxMountain = max(maxMountain, up + down + 1)\\n                \\n        return \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990230,
                "title": "java-two-pointers-o-n",
                "content": "For each qualified peak, i.e. greater than its left and right element, expand from it to left and right to find the mountain length\\n\\nEach number is visited at most twice because numbers on the slope of a mountain will never be visited twice (as points on the slope doesn\\'t qualify as a peak). Only points on the end of a mountain could be visited twice, since it could be part of the mountain on its left and the mountain on its right.\\n\\n```\\npublic int longestMountain(int[] arr) {\\n    if(arr.length < 3){\\n        return 0;\\n    }\\n    int longest = 0;\\n    for(int i = 1; i < arr.length - 1; i++){\\n        if(arr[i] > arr[i - 1] && arr[i] > arr[i + 1]){\\n            int left = i;\\n            int right = i;\\n            while(left > 0 && arr[left - 1] < arr[left]){\\n                left--;\\n            }\\n            while(right < arr.length - 1 && arr[right + 1] < arr[right]){\\n                right++;\\n            }\\n            longest = Math.max(right - left + 1, longest);\\n        }\\n    }\\n    return longest;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic int longestMountain(int[] arr) {\\n    if(arr.length < 3){\\n        return 0;\\n    }\\n    int longest = 0;\\n    for(int i = 1; i < arr.length - 1; i++){\\n        if(arr[i] > arr[i - 1] && arr[i] > arr[i + 1]){\\n            int left = i;\\n            int right = i;\\n            while(left > 0 && arr[left - 1] < arr[left]){\\n                left--;\\n            }\\n            while(right < arr.length - 1 && arr[right + 1] < arr[right]){\\n                right++;\\n            }\\n            longest = Math.max(right - left + 1, longest);\\n        }\\n    }\\n    return longest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1436584,
                "title": "c-solution-o-n-easy-to-understand",
                "content": "```\\n// Time Complexity : O(N)\\n// Space Complexity : O(1)\\nclass Solution\\n{\\npublic:\\n    int longestMountain(vector<int> &arr)\\n    {\\n        int i = 1, n = arr.size(), max_mnt = 0;\\n        while (i < n)\\n        {\\n            int upper = 0, down = 0;\\n            while (i < n && arr[i] == arr[i - 1])\\n            {\\n                i++;\\n            }\\n\\n            // Going Up on Mountain\\n            while (i < n && arr[i] > arr[i - 1])\\n            {\\n                i++, upper++;\\n            }\\n\\n            // Going down on Mountain\\n            while (i < n && arr[i] < arr[i - 1])\\n            {\\n                down++, i++;\\n            }\\n\\n            if (upper && down)\\n            {\\n                max_mnt = max(max_mnt, upper + down + 1);\\n            }\\n        }\\n\\n        return max_mnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Time Complexity : O(N)\\n// Space Complexity : O(1)\\nclass Solution\\n{\\npublic:\\n    int longestMountain(vector<int> &arr)\\n    {\\n        int i = 1, n = arr.size(), max_mnt = 0;\\n        while (i < n)\\n        {\\n            int upper = 0, down = 0;\\n            while (i < n && arr[i] == arr[i - 1])\\n            {\\n                i++;\\n            }\\n\\n            // Going Up on Mountain\\n            while (i < n && arr[i] > arr[i - 1])\\n            {\\n                i++, upper++;\\n            }\\n\\n            // Going down on Mountain\\n            while (i < n && arr[i] < arr[i - 1])\\n            {\\n                down++, i++;\\n            }\\n\\n            if (upper && down)\\n            {\\n                max_mnt = max(max_mnt, upper + down + 1);\\n            }\\n        }\\n\\n        return max_mnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283245,
                "title": "python-easy-to-understand-o-n-time-o-1-space",
                "content": "**Explanation:**\\nLets divide the problem into 2 parts:\\n1. Finding the peak value of the mountain\\n2. Finding the length of the mountain\\n\\n**1. Find peak value:**\\n*  A value is considered as a peak if the elements adjacent to the peak is strictly less than it\\n*  Keep on iterating through the list until a peak value is found\\n\\n**2. Find length of the mountain**\\n* Once we find the peak value, Iterate through left and right elements to find the length of mountain\\n* Increase rightindex/Decrease left index until the subsequent values are strictly less\\n* Current length of mountain = right index - left index -1\\n* compare it with max_length and assign if max_length<current length\\n\\nIterate through all the elements until list is exhausted to find the max length of the mountain\\n```\\n\\tmaxlength = 0\\n        i = 1\\n        while(i<len(arr)-1):\\n            peak = arr[i]>arr[i-1] and arr[i]>arr[i+1]\\n            if not peak:\\n                i += 1\\n                continue\\n\\n            leftidx = i-2\\n            while(leftidx >= 0 and arr[leftidx]<arr[leftidx+1]):\\n                leftidx -= 1\\n\\n            rightidx = i+2\\n            while(rightidx < len(arr) and arr[rightidx]<arr[rightidx-1]):\\n                rightidx += 1\\n\\n            length = rightidx-leftidx-1\\n            if(length>maxlength):\\n                maxlength = length\\n            i = rightidx\\n        return maxlength\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\n\\tmaxlength = 0\\n        i = 1\\n        while(i<len(arr)-1):\\n            peak = arr[i]>arr[i-1] and arr[i]>arr[i+1]\\n            if not peak:\\n                i += 1\\n                continue\\n\\n            leftidx = i-2\\n            while(leftidx >= 0 and arr[leftidx]<arr[leftidx+1]):\\n                leftidx -= 1\\n\\n            rightidx = i+2\\n            while(rightidx < len(arr) and arr[rightidx]<arr[rightidx-1]):\\n                rightidx += 1\\n\\n            length = rightidx-leftidx-1\\n            if(length>maxlength):\\n                maxlength = length\\n            i = rightidx\\n        return maxlength\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 943750,
                "title": "java-very-simple-solution",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {        \\n        int longest = 0;\\n        int startIndex = 0;\\n        int endIndex = arr.length - 1;\\n                \\n        for(int i = 1; i < endIndex; i++) {\\n            int topIndex = i;\\n            int leftIndex = i - 1;\\n            int rightIndex = i + 1;\\n            \\n            if(arr[leftIndex] >= arr[topIndex] || arr[rightIndex] >= arr[topIndex]) {\\n                continue;\\n            }\\n            \\n            while(leftIndex != startIndex && arr[leftIndex] > arr[leftIndex - 1]) {\\n                leftIndex--;\\n            }\\n            \\n            while(rightIndex != endIndex && arr[rightIndex] > arr[rightIndex + 1]) {\\n                rightIndex++;\\n            }\\n            \\n            longest = Math.max(longest, rightIndex - leftIndex + 1);\\n        }\\n        \\n        return longest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {        \\n        int longest = 0;\\n        int startIndex = 0;\\n        int endIndex = arr.length - 1;\\n                \\n        for(int i = 1; i < endIndex; i++) {\\n            int topIndex = i;\\n            int leftIndex = i - 1;\\n            int rightIndex = i + 1;\\n            \\n            if(arr[leftIndex] >= arr[topIndex] || arr[rightIndex] >= arr[topIndex]) {\\n                continue;\\n            }\\n            \\n            while(leftIndex != startIndex && arr[leftIndex] > arr[leftIndex - 1]) {\\n                leftIndex--;\\n            }\\n            \\n            while(rightIndex != endIndex && arr[rightIndex] > arr[rightIndex + 1]) {\\n                rightIndex++;\\n            }\\n            \\n            longest = Math.max(longest, rightIndex - leftIndex + 1);\\n        }\\n        \\n        return longest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812564,
                "title": "python-time-o-n-space-o-1-faster-than-97-76-easy-to-understand-with-comments",
                "content": "![image](https://assets.leetcode.com/users/images/38ae550e-6c35-4a14-a449-ac0786dc2092_1646215938.7846613.png)\\n```\\n# time = O(N)/Space = O(1)\\nclass Solution(object):\\n    def longestMountain(self, arr):\\n        longestHeight = 0\\n        currHeight = 0\\n        \\n        # negelect very first and very last element as an not be peak at any cost\\n        currIdx = 1\\n        while currIdx < len(arr) -1:\\n            # search for peak \\n            isPeak = arr[currIdx] > arr[currIdx -1] and arr[currIdx] > arr[currIdx + 1]\\n            if not isPeak:\\n                #if not peak then continue\\n                currIdx += 1\\n                continue\\n            # if we found peak - now time to expand to left and right to measure height\\n            # start with second adjacent from left and right\\n            leftIdx = currIdx - 2\\n            rightIdx = currIdx + 2\\n            # check bounds\\n            while leftIdx >= 0 and arr[leftIdx] < arr[leftIdx + 1]:\\n                leftIdx -= 1\\n                \\n            while rightIdx < len(arr) and arr[rightIdx] < arr[rightIdx - 1]:\\n                rightIdx += 1\\n            # calculate current height    \\n            currHeight = rightIdx - leftIdx - 1 \\n            longestHeight = max(longestHeight, currHeight)\\n            \\n            currIdx =  rightIdx\\n        return longestHeight\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n# time = O(N)/Space = O(1)\\nclass Solution(object):\\n    def longestMountain(self, arr):\\n        longestHeight = 0\\n        currHeight = 0\\n        \\n        # negelect very first and very last element as an not be peak at any cost\\n        currIdx = 1\\n        while currIdx < len(arr) -1:\\n            # search for peak \\n            isPeak = arr[currIdx] > arr[currIdx -1] and arr[currIdx] > arr[currIdx + 1]\\n            if not isPeak:\\n                #if not peak then continue\\n                currIdx += 1\\n                continue\\n            # if we found peak - now time to expand to left and right to measure height\\n            # start with second adjacent from left and right\\n            leftIdx = currIdx - 2\\n            rightIdx = currIdx + 2\\n            # check bounds\\n            while leftIdx >= 0 and arr[leftIdx] < arr[leftIdx + 1]:\\n                leftIdx -= 1\\n                \\n            while rightIdx < len(arr) and arr[rightIdx] < arr[rightIdx - 1]:\\n                rightIdx += 1\\n            # calculate current height    \\n            currHeight = rightIdx - leftIdx - 1 \\n            longestHeight = max(longestHeight, currHeight)\\n            \\n            currIdx =  rightIdx\\n        return longestHeight\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234414,
                "title": "12-lines-c-o-n-dry-run",
                "content": "To understand the code just do dry run believe me just do dry run you will get the code at once otherwise just comment down below will help you to understand (^_^).\\n\\nDry run for these test cases to understand :\\n1. [2,1,4,7,3,2,5]\\n2. [1,2,3,4,5,6,7,8,9]\\n3. [2,3,1,2,3,4,5,6]\\n\\nThese cases are enough for u to understand the logic.\\n\\n``` \\n    int longestMountain(vector<int>& A) {\\n        int res = 0, count = 1; bool flag = 0;\\n        for(int i=1; i<A.size(); i++){\\n            if(A[i] > A[i-1]){\\n                if(flag == 1) flag = 0, count = 1;\\n                count++;\\n            }\\n            else if(count >= 2 and A[i] < A[i-1]){\\n                flag = 1;  count++;\\n                res = max(res, count);\\n            }\\n            else count = 1;\\n        }\\n        return res;\\n    }\\n```\\n\\nIf you liked it do click on the UPVOTE icon.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "``` \\n    int longestMountain(vector<int>& A) {\\n        int res = 0, count = 1; bool flag = 0;\\n        for(int i=1; i<A.size(); i++){\\n            if(A[i] > A[i-1]){\\n                if(flag == 1) flag = 0, count = 1;\\n                count++;\\n            }\\n            else if(count >= 2 and A[i] < A[i-1]){\\n                flag = 1;  count++;\\n                res = max(res, count);\\n            }\\n            else count = 1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 937825,
                "title": "easy-to-understand-java-solution-beats-100",
                "content": "The logic behind this solution was very simple. We just need to traverse the array for uphill (ascending order) and downhill (descending order).  \\n\\n\\t//go uphill\\n\\twhile(i<A.length && A[i-1]<A[i]){\\n\\t\\tupHill=true;\\n\\t\\ti++;\\n\\t}\\n\\t//go downhill\\n\\twhile(i<A.length && A[i-1]>A[i]){\\n\\t\\tdownHill=true;\\n\\t\\ti++;\\n\\t}\\n\\n\\nIf we found both uphill and downhill, then get the total length from the start of uphill till now and update the maximum mountain.\\n\\n\\tif(upHill && downHill){\\n\\t\\t//only update when mountain size was equal or greater than 3\\n\\t\\tif(i-start>=3)result = Math.max(i-start,result);\\n\\t}\\n\\nIn case there was no uphill and/or downhill or either, then it wasn\\'t mountain (obviously). Then we just need to ensure that it neither be plain surface (same value). Then, just keep moving\\n\\n\\twhile(i<A.length && A[i-1]==A[i])i++;\\n\\nHere is complete solution with comment.\\n\\n```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        if(A==null || A.length<3) return result;\\n        int i = 1;\\n        int start = 0;\\n        boolean upHill = false;\\n        boolean downHill = false;\\n        while(i<A.length){\\n            start = i-1;\\n            //go uphill\\n            while(i<A.length && A[i-1]<A[i]){\\n                upHill=true;\\n                i++;\\n            }\\n            //go downhill\\n            while(i<A.length && A[i-1]>A[i]){\\n                downHill=true;\\n                i++;\\n            }\\n\\t\\t\\t\\n            //if found uphill and downhill then there was mountain \\n            if(upHill && downHill){\\n                //only update when mountain size was equal or greater than 3\\n                if(i-start>=3)result = Math.max(i-start,result);\\n            }else{\\n                //if there was no mountain, then ensuring it\\'s not plain surface\\n                while(i<A.length && A[i-1]==A[i])i++;\\n            }\\n            \\n            //update uphill and downhill for next iteration.\\n            upHill = false;\\n            downHill = false;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nCode Analysis :\\n\\n\\tTime complexity : O(n)\\n\\tSpace complexity : O(1)\\n\\nAny comments or suggestion are welcome. :)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        if(A==null || A.length<3) return result;\\n        int i = 1;\\n        int start = 0;\\n        boolean upHill = false;\\n        boolean downHill = false;\\n        while(i<A.length){\\n            start = i-1;\\n            //go uphill\\n            while(i<A.length && A[i-1]<A[i]){\\n                upHill=true;\\n                i++;\\n            }\\n            //go downhill\\n            while(i<A.length && A[i-1]>A[i]){\\n                downHill=true;\\n                i++;\\n            }\\n\\t\\t\\t\\n            //if found uphill and downhill then there was mountain \\n            if(upHill && downHill){\\n                //only update when mountain size was equal or greater than 3\\n                if(i-start>=3)result = Math.max(i-start,result);\\n            }else{\\n                //if there was no mountain, then ensuring it\\'s not plain surface\\n                while(i<A.length && A[i-1]==A[i])i++;\\n            }\\n            \\n            //update uphill and downhill for next iteration.\\n            upHill = false;\\n            downHill = false;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895623,
                "title": "python-solution-0-n-o-1-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        if len(A) < 3:\\n            return 0\\n        \\n        start = 0 # Ground from where the uphill starts.\\n        _maxPeak = 0\\n        reachedPeak = False\\n        for i in range(1, len(A)-1):\\n            # The uphill starts only if the current ground height is lower to the next ground height.\\n            # This condition is met at both the left side of the peak and the right side of the peak hence the variable reachedPeak to check if the peek has been reached.\\n            if A[i-1] >= A[i] <= A[i+1]:\\n                # if peak had been reached then we are now on the right side of the ground. We need to calucalte the lenght of the mountain.\\n                if reachedPeak:\\n                    reachedPeak = False\\n                    _maxPeak = max(_maxPeak, i - start + 1)\\n                start = i\\n            \\n            # Peak condition.\\n            elif A[i-1] < A[i] > A[i+1]:\\n                reachedPeak = True\\n        \\n        # This is to check if there is only downhill after the peak has been reached.\\n        if reachedPeak:\\n            _maxPeak = max(_maxPeak, len(A) - start)\\n        return _maxPeak\\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        if len(A) < 3:\\n            return 0\\n        \\n        start = 0 # Ground from where the uphill starts.\\n        _maxPeak = 0\\n        reachedPeak = False\\n        for i in range(1, len(A)-1):\\n            # The uphill starts only if the current ground height is lower to the next ground height.\\n            # This condition is met at both the left side of the peak and the right side of the peak hence the variable reachedPeak to check if the peek has been reached.\\n            if A[i-1] >= A[i] <= A[i+1]:\\n                # if peak had been reached then we are now on the right side of the ground. We need to calucalte the lenght of the mountain.\\n                if reachedPeak:\\n                    reachedPeak = False\\n                    _maxPeak = max(_maxPeak, i - start + 1)\\n                start = i\\n            \\n            # Peak condition.\\n            elif A[i-1] < A[i] > A[i+1]:\\n                reachedPeak = True\\n        \\n        # This is to check if there is only downhill after the peak has been reached.\\n        if reachedPeak:\\n            _maxPeak = max(_maxPeak, len(A) - start)\\n        return _maxPeak\\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 364764,
                "title": "count-points-of-the-mountain-on-both-up-and-down-slope-python",
                "content": "Keep counting points that form up and down slope. Reset when new mountain or flat is found. Record longest mountain for each point.\\n\\n```\\n    def longestMountain(self, A):\\n        increase, decrease, longest_mountain = 0, 0, 0\\n\\n        for i in range(len(A)):\\n            previous, current = A[i-1] if i > 0 else A[i], A[i]\\n \\n            if current == previous or (current > previous and decrease > 0):  \\n                increase, decrease = 1, 0  # reset when flat or new mountain is found\\n\\n            if current < previous: decrease += 1\\n            elif current > previous: increase += 1\\n            \\n            if increase > 1 and decrease > 0:\\n                longest_mountain = max(longest_mountain, increase + decrease)\\n\\n        return longest_mountain \\n```",
                "solutionTags": [],
                "code": "```\\n    def longestMountain(self, A):\\n        increase, decrease, longest_mountain = 0, 0, 0\\n\\n        for i in range(len(A)):\\n            previous, current = A[i-1] if i > 0 else A[i], A[i]\\n \\n            if current == previous or (current > previous and decrease > 0):  \\n                increase, decrease = 1, 0  # reset when flat or new mountain is found\\n\\n            if current < previous: decrease += 1\\n            elif current > previous: increase += 1\\n            \\n            if increase > 1 and decrease > 0:\\n                longest_mountain = max(longest_mountain, increase + decrease)\\n\\n        return longest_mountain \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 190888,
                "title": "one-pass-javascript-solution-without-nested-loops-o-n-time-o-1-space",
                "content": "Uses `dir` to track the trajectory of the \"terrain\", accounting for \"plateaus\" in the values (`1` is an incline, `0` is a plateau, `-1` is a decline). \\n```\\nvar longestMountain = function(A) {\\n    let longest = 0, start = 0, dir = 0\\n    \\n    // Note the <= here because we are doing comparisons with the previous value. Could swap it and do comparisons with the next value, but it\\'s more or less the same idea.\\n    for(var i = 0; i <= A.length; i++) {\\n        let val = A[i], prev = A[i-1]\\n        \\n        // On a decline and we\\'ve either reached the end, a plateau, or an incline\\n        if (dir === -1 && (i === A.length || !(val < prev))) {            \\n            longest = Math.max(i - start, longest)\\n            start = i - 1\\n            dir = val !== undefined && val > prev ? 1 : 0\\n        } else if (dir === 1 && val < prev) { // On an incline and we\\'ve crossed over the peak\\n            dir = -1\\n        } else if (val === prev) { // A plateau (in the case where we\\'re either on an incline or already a plateau\\n          dir = 0  \\n        } else if (val > prev && dir !== 1) { // Reached an incline when we weren\\'t already on one, so lets try to start a mountain\\n            start = i - 1\\n            dir = 1\\n        }\\n    }\\n    \\n    return longest\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar longestMountain = function(A) {\\n    let longest = 0, start = 0, dir = 0\\n    \\n    // Note the <= here because we are doing comparisons with the previous value. Could swap it and do comparisons with the next value, but it\\'s more or less the same idea.\\n    for(var i = 0; i <= A.length; i++) {\\n        let val = A[i], prev = A[i-1]\\n        \\n        // On a decline and we\\'ve either reached the end, a plateau, or an incline\\n        if (dir === -1 && (i === A.length || !(val < prev))) {            \\n            longest = Math.max(i - start, longest)\\n            start = i - 1\\n            dir = val !== undefined && val > prev ? 1 : 0\\n        } else if (dir === 1 && val < prev) { // On an incline and we\\'ve crossed over the peak\\n            dir = -1\\n        } else if (val === prev) { // A plateau (in the case where we\\'re either on an incline or already a plateau\\n          dir = 0  \\n        } else if (val > prev && dir !== 1) { // Reached an incline when we weren\\'t already on one, so lets try to start a mountain\\n            start = i - 1\\n            dir = 1\\n        }\\n    }\\n    \\n    return longest\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 135632,
                "title": "easy-to-understand-find-peaks-and-then-find-max-length-mountain-o-n",
                "content": "**Peak** - A value which is greater than neighboring values. A[i]>A[i-1] and A[i]>A[i+1] for i>0\\nAfter finding all such peaks we go left and right from each peak till the following condition holds - \\nTo the left - A[i-m] .... A[i-2] < A[i-1] < A[i]\\nTo the right - A[i] > A[i+1] > A[i+2] ... A[i+n]\\nLength of the mountain at each peak = m+n+1\\nIn the end we return the mountain with maximum length.\\n\\n**Time Complexity** - \\nFor each peak we are moving in left and right direction which might look like that the algorithm has non-linear complexity. But, the execution is in fact linear. Consider the following example - \\n\\nA = [1,2,1,3,4,6,2,1]\\nPeaks at positions = [1,5]\\nFirst we will go left from peak at index 1 and farthest we can go is till index 0\\nThen we will go right from peak at index 1 and farthest we can go is till index 2 because after index 2 it again starts increasing i.e. A[2]<A[3].\\nSimilarly, we will go left and right from peak at position 5 and we will go till index 3 on left and 7 on right.\\n\\nWhile going left and right from all the peaks none of the indexes are traveresed multiple times  which means we will at most traverse whole array again  (when all mountains share the saddle point). Hence we can say we traversed the array at most 2 times (Finding peaks + Going left and right from each peak = N+N) i.e. 2N which means the algorithm runs in O(N) time complexity.\\n\\n**Space complexity** - \\nFor storing peaks we will need O(N) space.\\nOptimization - We can go left and right as soon as we find a peak and then in the end we return the maximum length.\\n\\n```\\nclass Solution(object):\\n    def longestMountain(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"        \\n        peaks = []\\n        t = len(A)\\n        if t==0:\\n            return 0\\n        \\n        for i in xrange(1,t-1):\\n            if A[i-1]<A[i]>A[i+1]:\\n                peaks.append(i)\\n               \\n        maxLen = -1\\n        for i in peaks:        \\n            curLen=1\\n            j=i\\n            while j>0 and A[j-1]<A[j]:        \\n                j-=1\\n            curLen+=(i-j)\\n            \\n            j=i\\n            while j<t-1 and A[j+1]<A[j]:\\n                j+=1\\n            curLen+=(j-i)\\n            \\n            maxLen = max(curLen, maxLen)\\n        \\n        if maxLen==-1:\\n            return 0\\n        \\n        return maxLen\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestMountain(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"        \\n        peaks = []\\n        t = len(A)\\n        if t==0:\\n            return 0\\n        \\n        for i in xrange(1,t-1):\\n            if A[i-1]<A[i]>A[i+1]:\\n                peaks.append(i)\\n               \\n        maxLen = -1\\n        for i in peaks:        \\n            curLen=1\\n            j=i\\n            while j>0 and A[j-1]<A[j]:        \\n                j-=1\\n            curLen+=(i-j)\\n            \\n            j=i\\n            while j<t-1 and A[j+1]<A[j]:\\n                j+=1\\n            curLen+=(j-i)\\n            \\n            maxLen = max(curLen, maxLen)\\n        \\n        if maxLen==-1:\\n            return 0\\n        \\n        return maxLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629255,
                "title": "one-pass-solution-with-o-n-time-and-o-1-space",
                "content": "# Intuition\\nso the intution is  we have to form a mountain(which means that it should be a subarray which is strictly increasing and then strictly decreasing).\\n\\n# Approach\\nwe make variables like -->\\n. res--> stores the result to be return \\n\\n. answer--> temporary answer(which is temporay mountain length).\\n\\n. wasInc--> when we are goin down the hill it helps us to know that had we gone up_hill in this contiguous subarray. if we are on the down_hill side , we will update our res only if wasInc==true.\\n\\n. wasIncAndNowDcr--> help us when we are on the up_hill side , this tells that if we are comming from the down_hill side or not...if we are coming from the down hill side then we will have to do a fresh start in search of mountain...else we can continue on the up_hill side as it is as we have not seen down hill side in the contigous subarray\\n\\n**IMPORTANT**\\nwe have to do a fresh start if we encounter a case where (arr[i]==arr[i-1]) as we have to consider the case of strictly increasing or strictly decreasing..\\nif you still have any doubts do let me khow in the comment section.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n=arr.size(),res=0,answer=0;\\n        bool wasInc=false;\\n        bool wasIncAndNowDcr=false;\\n        for(int i=1;i<n;i++){\\n            if(arr[i] > arr[i-1]){\\n                if(wasIncAndNowDcr==true){\\n                    answer=0;\\n                    wasIncAndNowDcr=false;\\n                }\\n                answer++;\\n                wasInc=true;\\n            } \\n            else if(arr[i] < arr[i-1] && (wasInc || wasIncAndNowDcr)){\\n                answer++;\\n                wasIncAndNowDcr=true;\\n                res=max(res,answer+1);\\n            }\\n            else if(arr[i]==arr[i-1]){\\n                answer=0;\\n                wasIncAndNowDcr=false;\\n                wasInc=false;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n=arr.size(),res=0,answer=0;\\n        bool wasInc=false;\\n        bool wasIncAndNowDcr=false;\\n        for(int i=1;i<n;i++){\\n            if(arr[i] > arr[i-1]){\\n                if(wasIncAndNowDcr==true){\\n                    answer=0;\\n                    wasIncAndNowDcr=false;\\n                }\\n                answer++;\\n                wasInc=true;\\n            } \\n            else if(arr[i] < arr[i-1] && (wasInc || wasIncAndNowDcr)){\\n                answer++;\\n                wasIncAndNowDcr=true;\\n                res=max(res,answer+1);\\n            }\\n            else if(arr[i]==arr[i-1]){\\n                answer=0;\\n                wasIncAndNowDcr=false;\\n                wasInc=false;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491500,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size(),ans=0,count;\\n        vector<int>peaks;\\n        for(int i=1;i<(n-1);i++){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){\\n                peaks.push_back(i);\\n            }\\n        }\\n        int m = peaks.size();\\n        for(int i=0;i<m;i++){\\n            count = 1;\\n            for(int j=peaks[i];j>0;j--){\\n                if(arr[j]>arr[j-1]){\\n                    count++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            for(int j=peaks[i];j<(n-1);j++){\\n                if(arr[j]>arr[j+1]){\\n                    count++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(ans<count){\\n                ans = count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        longest_mountain = 0\\n        cur_mountain = 0\\n        NOTHING = 0\\n        GOING_UP = 1\\n        GOING_DOWN_AFTER_PEAK = 2\\n        state = NOTHING\\n        prev = arr[0]\\n        for a in arr[1:]:\\n            if a > prev:\\n                if state in (NOTHING, GOING_DOWN_AFTER_PEAK):\\n                    state = GOING_UP\\n                    cur_mountain = 1\\n                cur_mountain += 1\\n            elif a < prev:\\n                if state == GOING_UP:\\n                    state = GOING_DOWN_AFTER_PEAK\\n                if state == GOING_DOWN_AFTER_PEAK:\\n                    cur_mountain += 1\\n                    longest_mountain = max(cur_mountain, longest_mountain)\\n            elif a == prev:\\n                state = NOTHING\\n                cur_mountain = 0\\n            prev = a\\n        return longest_mountain\\n```\\n\\n```Java []\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int maxLength = 0, i = 0;\\n        boolean uphill = false, downhill = false;\\n        while (i < arr.length - 1) {\\n            if (arr[i] < arr[i + 1]) {\\n                int start = i;\\n                while (i < arr.length - 1 && arr[i] < arr[i + 1]) {\\n                    i++;\\n                    uphill = true;\\n                }\\n                while (i < arr.length - 1 && arr[i] > arr[i + 1]) {\\n                    i++;\\n                    downhill = true;\\n                }\\n                if (uphill && downhill) {\\n                    maxLength = Math.max(maxLength, i - start + 1);\\n                }\\n                uphill = downhill = false;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return maxLength;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size(),ans=0,count;\\n        vector<int>peaks;\\n        for(int i=1;i<(n-1);i++){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){\\n                peaks.push_back(i);\\n            }\\n        }\\n        int m = peaks.size();\\n        for(int i=0;i<m;i++){\\n            count = 1;\\n            for(int j=peaks[i];j>0;j--){\\n                if(arr[j]>arr[j-1]){\\n                    count++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            for(int j=peaks[i];j<(n-1);j++){\\n                if(arr[j]>arr[j+1]){\\n                    count++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(ans<count){\\n                ans = count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        longest_mountain = 0\\n        cur_mountain = 0\\n        NOTHING = 0\\n        GOING_UP = 1\\n        GOING_DOWN_AFTER_PEAK = 2\\n        state = NOTHING\\n        prev = arr[0]\\n        for a in arr[1:]:\\n            if a > prev:\\n                if state in (NOTHING, GOING_DOWN_AFTER_PEAK):\\n                    state = GOING_UP\\n                    cur_mountain = 1\\n                cur_mountain += 1\\n            elif a < prev:\\n                if state == GOING_UP:\\n                    state = GOING_DOWN_AFTER_PEAK\\n                if state == GOING_DOWN_AFTER_PEAK:\\n                    cur_mountain += 1\\n                    longest_mountain = max(cur_mountain, longest_mountain)\\n            elif a == prev:\\n                state = NOTHING\\n                cur_mountain = 0\\n            prev = a\\n        return longest_mountain\\n```\n```Java []\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int maxLength = 0, i = 0;\\n        boolean uphill = false, downhill = false;\\n        while (i < arr.length - 1) {\\n            if (arr[i] < arr[i + 1]) {\\n                int start = i;\\n                while (i < arr.length - 1 && arr[i] < arr[i + 1]) {\\n                    i++;\\n                    uphill = true;\\n                }\\n                while (i < arr.length - 1 && arr[i] > arr[i + 1]) {\\n                    i++;\\n                    downhill = true;\\n                }\\n                if (uphill && downhill) {\\n                    maxLength = Math.max(maxLength, i - start + 1);\\n                }\\n                uphill = downhill = false;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284831,
                "title": "c-longest-bitonic-sequence-lis-pattern-dp-striver",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1), dp2(n, 1);\\n        int ans = 0;\\n        for (int ind=1; ind<n; ind++) {\\n            if (arr[ind] > arr[ind-1]) {\\n                dp[ind] = 1 + dp[ind-1];\\n            }\\n        }\\n        for (int ind=n-2; ind>=0; ind--) {\\n            if (arr[ind] > arr[ind+1]) {\\n                dp2[ind] = 1 + dp2[ind+1];\\n            }\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (dp[i] > 1 && dp2[i] > 1) {\\n                ans = max(dp[i] + dp2[i] - 1, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1), dp2(n, 1);\\n        int ans = 0;\\n        for (int ind=1; ind<n; ind++) {\\n            if (arr[ind] > arr[ind-1]) {\\n                dp[ind] = 1 + dp[ind-1];\\n            }\\n        }\\n        for (int ind=n-2; ind>=0; ind--) {\\n            if (arr[ind] > arr[ind+1]) {\\n                dp2[ind] = 1 + dp2[ind+1];\\n            }\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (dp[i] > 1 && dp2[i] > 1) {\\n                ans = max(dp[i] + dp2[i] - 1, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768573,
                "title": "linear-time-constant-space-c-solution-with-explanation",
                "content": "# Intuition\\nWe just need to find the pattern of mountains.\\n\\n# Approach\\nFirst, find the length of the arr and see if the size if indeed > 3. Now after checking that start with index 0 and inside this for loop, we will go on traversing i, if we have a mountain patter. Hence, if arr[i+1]>arr[i], this is the condition essential for uphill, so we start counting left and also increment i. After we have reached a point that arr[i+1] is no longer > arr[i], meaning there can be 2 conditions arr[i+1]==arr[i] or arr[i+1]<arr[i]. Second condition is basically the start of downhill, I will discuss the first condition later. As we start going downhill, just increment rigth and i too. Now if right!=0 meaning that our bike never went downhill (meaning the first condition where arr[i+1] was arr[i]), we cant consider this as our answer as we ONLY have a mountain if both left and right are >0. So if right!=0, then count the answer, which is maximum of current answer and left+right+1. Why +1? because, notice that left and right are basically lenght of 2 arms of peak, we need to count peak in our answer too (through dry run we can see that left is still 1 when we process arr[1]>arr[0]). \\nNow, dont forget to do i-- here, as this will mean that we start from the next index, but it can happen that we need to start counting from current index and we are doing i++ anyways at the end of the loop, so do i--.\\nAtlast return the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n), some would be confused as there is while inside a for, but notice that in both the loops we just operate on i, hence, even if the while loop has incremented i, for loop will start from that point in future.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int ans = 0;\\n        int n = arr.size();\\n        if(n<3)\\n            return 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(i+1<n && arr[i+1]>arr[i])\\n            {\\n                int left=0, right=0;\\n                while(i+1<n and arr[i+1]>arr[i])\\n                {\\n                    left++;\\n                    i++;\\n                }\\n                while(i+1<n and arr[i+1]<arr[i])\\n                {\\n                    right++;\\n                    i++;\\n                }\\n                if(right!=0){\\n                    ans = max(ans, right+left+1);\\n                    i--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int ans = 0;\\n        int n = arr.size();\\n        if(n<3)\\n            return 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(i+1<n && arr[i+1]>arr[i])\\n            {\\n                int left=0, right=0;\\n                while(i+1<n and arr[i+1]>arr[i])\\n                {\\n                    left++;\\n                    i++;\\n                }\\n                while(i+1<n and arr[i+1]<arr[i])\\n                {\\n                    right++;\\n                    i++;\\n                }\\n                if(right!=0){\\n                    ans = max(ans, right+left+1);\\n                    i--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340405,
                "title": "c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n  int ans=0;\\n    int longestMountain(vector<int>& arr) {\\n     int n=arr.size();\\n      for(int i=1;i<n-1;i++)\\n      {\\n       if((arr[i] > arr[i-1]) && (arr[i] > arr[i+1])) // condition for mountain\\n            {\\n                int left = i;\\n                int right = i;\\n                while( left>0 && arr[left] > arr[left-1]) left--; // for left movement\\n               while( right<n-1 && arr[right] > arr[right+1] )right++;// for right movement\\n              ans = max(ans,(right-left+1));\\n            }\\n     }return ans;\\n    }\\n \\n};\\n```\\n\\nat then end if you are here then you really liked my solution , other solution can be :-\\nintution :- traverse loop from 1 to n-1 and check for every element if it is mountain or not ,if yes then count no. which is smaller \\nin derection of left applying condtn arr[i]>arr[i-1]\\nand vice versa for right side  , than simply add them \\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int ans=0;\\n    int longestMountain(vector<int>& arr) {\\n     int n=arr.size();\\n      for(int i=1;i<n-1;i++)\\n      {\\n       if((arr[i] > arr[i-1]) && (arr[i] > arr[i+1])) // condition for mountain\\n            {\\n                int left = i;\\n                int right = i;\\n                while( left>0 && arr[left] > arr[left-1]) left--; // for left movement\\n               while( right<n-1 && arr[right] > arr[right+1] )right++;// for right movement\\n              ans = max(ans,(right-left+1));\\n            }\\n     }return ans;\\n    }\\n \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113840,
                "title": "c-commented-solution-two-pointer-approach-easy-to-understand-solution",
                "content": "**PLEASE UPVOTE IF YOU LIKE APPROACH AND COMMENT IF YOU HAVE ANY QUESTION**\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) \\n    {\\n        int maxlength = 0;\\n            \\n        if(a.size() == 0)  return 0;\\n            \\n            for(int i = 1; i < a.size()-1; i++)\\n            {\\n                    if(a[i] > a[i-1] && a[i] > a[i+1])\\n                            //finding out the middle element or peak in an array/mountain.\\n                    {      \\n                            int left = i-1; //initialize left pointer towards left of peak \\n                     \\n                            int right = i+1; // initialize right pointer towards right to peak.\\n                            \\n                            while(left > 0 && a[left-1] < a[left] )\\n                                    // if next left is smaller then current left move forward;\\n                                    left--;\\n                            \\n                            while(right < a.size()-1 && a[right+1] < a[right])\\n                                    // if next right is smaller then current right move forward\\n                                    right++;\\n                            \\n                            maxlength = max(maxlength, right - left+1);\\n                            //return the maximum length between two pointers right and left.\\n                    }\\n            }\\n            \\n            return maxlength;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) \\n    {\\n        int maxlength = 0;\\n            \\n        if(a.size() == 0)  return 0;\\n            \\n            for(int i = 1; i < a.size()-1; i++)\\n            {\\n                    if(a[i] > a[i-1] && a[i] > a[i+1])\\n                            //finding out the middle element or peak in an array/mountain.\\n                    {      \\n                            int left = i-1; //initialize left pointer towards left of peak \\n                     \\n                            int right = i+1; // initialize right pointer towards right to peak.\\n                            \\n                            while(left > 0 && a[left-1] < a[left] )\\n                                    // if next left is smaller then current left move forward;\\n                                    left--;\\n                            \\n                            while(right < a.size()-1 && a[right+1] < a[right])\\n                                    // if next right is smaller then current right move forward\\n                                    right++;\\n                            \\n                            maxlength = max(maxlength, right - left+1);\\n                            //return the maximum length between two pointers right and left.\\n                    }\\n            }\\n            \\n            return maxlength;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884695,
                "title": "o-n-forward-traversal-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n       int s = 0;\\n       int maxA = 0;\\n        \\n       bool foundPeak = false;\\n        \\n       for (int i = 0; i < arr.size(); i++) {\\n           int prev = i - 1 < 0 ? arr[i] : arr[i - 1];\\n           int curr = arr[i];\\n           int next = i + 1 >= arr.size() ? arr[i] : arr[i + 1];\\n           \\n           if (foundPeak) {\\n               maxA = max(maxA, i - s + 1);\\n           }\\n           \\n           if ((next > curr and prev >= curr) or (prev > curr and next >= curr)) {\\n               s = i;\\n               foundPeak = false;\\n           }\\n           \\n           if (prev < curr and next < curr) {\\n               foundPeak = true;\\n           }\\n       }\\n       return maxA;\\n    }  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n       int s = 0;\\n       int maxA = 0;\\n        \\n       bool foundPeak = false;\\n        \\n       for (int i = 0; i < arr.size(); i++) {\\n           int prev = i - 1 < 0 ? arr[i] : arr[i - 1];\\n           int curr = arr[i];\\n           int next = i + 1 >= arr.size() ? arr[i] : arr[i + 1];\\n           \\n           if (foundPeak) {\\n               maxA = max(maxA, i - s + 1);\\n           }\\n           \\n           if ((next > curr and prev >= curr) or (prev > curr and next >= curr)) {\\n               s = i;\\n               foundPeak = false;\\n           }\\n           \\n           if (prev < curr and next < curr) {\\n               foundPeak = true;\\n           }\\n       }\\n       return maxA;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837098,
                "title": "python3-one-pass-o-1-auxiliary-space",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        increasing = False\\n        increased = False\\n        mx = -math.inf\\n        curr = -math.inf\\n        for i in range(1, len(arr)):\\n            if arr[i] > arr[i-1]:\\n                if increasing:\\n                    curr += 1\\n                    increased = True\\n                else:\\n                    mx = max(curr, mx)\\n                    curr = 2\\n                    increased = True\\n                    increasing = True\\n            elif arr[i] < arr[i-1]:\\n                if increasing:\\n                    increasing = False\\n                curr += 1\\n            else:\\n                if increased and not increasing:\\n                    mx = max(mx, curr)\\n                curr = -math.inf\\n                increased = False\\n                increasing = False\\n        if not increasing and increased:\\n            mx = max(mx, curr)\\n        return 0 if mx == -math.inf else mx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        increasing = False\\n        increased = False\\n        mx = -math.inf\\n        curr = -math.inf\\n        for i in range(1, len(arr)):\\n            if arr[i] > arr[i-1]:\\n                if increasing:\\n                    curr += 1\\n                    increased = True\\n                else:\\n                    mx = max(curr, mx)\\n                    curr = 2\\n                    increased = True\\n                    increasing = True\\n            elif arr[i] < arr[i-1]:\\n                if increasing:\\n                    increasing = False\\n                curr += 1\\n            else:\\n                if increased and not increasing:\\n                    mx = max(mx, curr)\\n                curr = -math.inf\\n                increased = False\\n                increasing = False\\n        if not increasing and increased:\\n            mx = max(mx, curr)\\n        return 0 if mx == -math.inf else mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782728,
                "title": "longest-mountain-in-array",
                "content": "class Solution {\\npublic:\\n\\n    int longestMountain(vector<int>& arr)  \\n\\t{\\n        int i = 0, u = 0, d = 0, ml = 0;\\n        int n=arr.size();\\n    while (i < n)\\n    {\\n         u=0;\\n         d=0;\\n        while (i < n - 1 && arr[i] < arr[i + 1])\\n        {\\n            i++;\\n            u++;\\n        }\\n        while (i < n - 1 && arr[i] > arr[i + 1] && u)\\n        {\\n            i++;\\n            d++;\\n        }\\n        if (u && d)\\n            ml = max(ml, u + d + 1);\\n        else\\n            i++;\\n    }\\n        return ml;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int longestMountain(vector<int>& arr)  \\n\\t{\\n        int i = 0, u = 0, d = 0, ml = 0;\\n        int n=arr.size();\\n    while (i < n)\\n    {\\n         u=0;\\n         d=0;\\n        while (i < n - 1 && arr[i] < arr[i + 1])\\n        {\\n            i++;\\n            u++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1718783,
                "title": "python-2-approaches-complexity",
                "content": "\\t# Two Passes - Forward and Backward\\n\\t# Time: O(n)\\n\\t# Space: O(n)\\n\\tclass Solution:\\n\\t\\tdef longestMountain(self, arr: List[int]) -> int:\\n\\t\\t\\tupSide = [0]*len(arr)\\n\\t\\t\\tdownSide = [0]*len(arr)\\n\\t\\t\\tfor i in range(1, len(arr)):\\n\\t\\t\\t\\tif arr[i] > arr[i-1]:\\n\\t\\t\\t\\t\\tupSide[i] = upSide[i-1]+1\\n\\t\\t\\tfor i in range(len(arr)-1)[::-1]:\\n\\t\\t\\t\\tif arr[i] > arr[i+1]:\\n\\t\\t\\t\\t\\tdownSide[i] = downSide[i+1]+1\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i, j in zip(upSide, downSide):\\n\\t\\t\\t\\tif i and j:\\n\\t\\t\\t\\t\\tres = max(res, i+j+1)\\n\\t\\t\\treturn res\\n\\n\\t# One Pass - Only Forward\\n\\t# Time: O(n)\\n\\t# Space: O(1)\\n\\tclass Solution:\\n\\t\\tdef longestMountain(self, arr: List[int]) -> int:\\n\\t\\t\\tup=0\\n\\t\\t\\tdown=0\\n\\t\\t\\tres=0\\n\\t\\t\\tfor i in range(1, len(arr)):\\n\\t\\t\\t\\tif down and arr[i]>arr[i-1] or arr[i-1]==arr[i]:\\n\\t\\t\\t\\t\\tup=down=0\\n\\t\\t\\t\\tup+=arr[i]>arr[i-1]\\n\\t\\t\\t\\tdown+=arr[i]<arr[i-1]\\n\\t\\t\\t\\tif up and down:\\n\\t\\t\\t\\t\\tres=max(res, up+down+1)\\n\\t\\t\\treturn res\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t# Two Passes - Forward and Backward\\n\\t# Time: O(n)\\n\\t# Space: O(n)\\n\\tclass Solution:\\n\\t\\tdef longestMountain(self, arr: List[int]) -> int:\\n\\t\\t\\tupSide = [0]*len(arr)\\n\\t\\t\\tdownSide = [0]*len(arr)\\n\\t\\t\\tfor i in range(1, len(arr)):\\n\\t\\t\\t\\tif arr[i] > arr[i-1]:\\n\\t\\t\\t\\t\\tupSide[i] = upSide[i-1]+1\\n\\t\\t\\tfor i in range(len(arr)-1)[::-1]:\\n\\t\\t\\t\\tif arr[i] > arr[i+1]:\\n\\t\\t\\t\\t\\tdownSide[i] = downSide[i+1]+1\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i, j in zip(upSide, downSide):\\n\\t\\t\\t\\tif i and j:\\n\\t\\t\\t\\t\\tres = max(res, i+j+1)\\n\\t\\t\\treturn res\\n\\n\\t# One Pass - Only Forward\\n\\t# Time: O(n)\\n\\t# Space: O(1)\\n\\tclass Solution:\\n\\t\\tdef longestMountain(self, arr: List[int]) -> int:\\n\\t\\t\\tup=0\\n\\t\\t\\tdown=0\\n\\t\\t\\tres=0\\n\\t\\t\\tfor i in range(1, len(arr)):\\n\\t\\t\\t\\tif down and arr[i]>arr[i-1] or arr[i-1]==arr[i]:\\n\\t\\t\\t\\t\\tup=down=0\\n\\t\\t\\t\\tup+=arr[i]>arr[i-1]\\n\\t\\t\\t\\tdown+=arr[i]<arr[i-1]\\n\\t\\t\\t\\tif up and down:\\n\\t\\t\\t\\t\\tres=max(res, up+down+1)\\n\\t\\t\\treturn res\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "codeTag": "Java"
            },
            {
                "id": 1697387,
                "title": "c-dynamic-programming-faster-than-96-online-submission",
                "content": "```\\n int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1){\\n            return 0;\\n        }\\n        int ans=0;\\n        vector<int>lis(n,1);\\n        vector<int>lds(n,1);\\n        //for lis\\n        for(int i=1;i<n;i++){\\n            if(arr[i]>arr[i-1]){\\n                lis[i]=lis[i-1]+1;\\n            }\\n        }\\n        //for lds\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]){\\n                lds[i]=lds[i+1]+1;\\n            }\\n        }\\n        // cout<<\"LIS \"<<endl;\\n        // for(auto it:lis){\\n        //     cout<<it<<\" \";\\n        // }\\n        //  cout<<\"LDS \"<<endl;\\n        // for(auto it:lds){\\n        //     cout<<it<<\" \";\\n        // }\\n        for(int i=1;i<n-1;i++){\\n            if(lis[i]==1||lds[i]==1){\\n                continue;\\n            }\\n            int temp=abs(lis[i]+lds[i]-1);\\n            ans=max(ans,temp);\\n        }\\n        return ans==1?0:ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1){\\n            return 0;\\n        }\\n        int ans=0;\\n        vector<int>lis(n,1);\\n        vector<int>lds(n,1);\\n        //for lis\\n        for(int i=1;i<n;i++){\\n            if(arr[i]>arr[i-1]){\\n                lis[i]=lis[i-1]+1;\\n            }\\n        }\\n        //for lds\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]){\\n                lds[i]=lds[i+1]+1;\\n            }\\n        }\\n        // cout<<\"LIS \"<<endl;\\n        // for(auto it:lis){\\n        //     cout<<it<<\" \";\\n        // }\\n        //  cout<<\"LDS \"<<endl;\\n        // for(auto it:lds){\\n        //     cout<<it<<\" \";\\n        // }\\n        for(int i=1;i<n-1;i++){\\n            if(lis[i]==1||lds[i]==1){\\n                continue;\\n            }\\n            int temp=abs(lis[i]+lds[i]-1);\\n            ans=max(ans,temp);\\n        }\\n        return ans==1?0:ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1691796,
                "title": "c-simple-and-short-o-n-time-complexity",
                "content": "```\\nint longestMountain(vector<int>& arr) {\\n        int ans = 0, upLength = 0, downLength = 0;\\n\\t\\t\\n        for(int i = 1; i < arr.size(); i++)\\n        {\\n            if(arr[i - 1] == arr[i] || downLength && arr[i - 1] < arr[i])\\n                upLength = downLength = 0;\\n            \\n            upLength += arr[i - 1] < arr[i];\\n            downLength += arr[i - 1] > arr[i];\\n\\n            if(upLength && downLength)\\n                ans = max(ans, upLength + downLength + 1);\\n        }\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint longestMountain(vector<int>& arr) {\\n        int ans = 0, upLength = 0, downLength = 0;\\n\\t\\t\\n        for(int i = 1; i < arr.size(); i++)\\n        {\\n            if(arr[i - 1] == arr[i] || downLength && arr[i - 1] < arr[i])\\n                upLength = downLength = 0;\\n            \\n            upLength += arr[i - 1] < arr[i];\\n            downLength += arr[i - 1] > arr[i];\\n\\n            if(upLength && downLength)\\n                ans = max(ans, upLength + downLength + 1);\\n        }\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1668119,
                "title": "c-o-n-o-1-100-fast-easy-soln",
                "content": "```\\n int longestMountain(vector<int>& a) {\\n        int i,ans=0,c=0,n=a.size();\\n        for(i=1;i<n;i++)\\n        {\\n            if(a[i]==a[i-1])  //If nos are same then we skip it\\n                c=0;            \\n            else if(a[i]>a[i-1]) //if next>prev we increase the count\\n                c++;\\n            //Else we first calculate count of next<prev and update the final ans\\n            else if(c>0)           \\n            {\\n                    while(i<n and a[i]<a[i-1])\\n                    {\\n                        c++; i++;\\n                    }\\n                    ans = max(ans,c+1);\\n                    c=0 ;i--;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int longestMountain(vector<int>& a) {\\n        int i,ans=0,c=0,n=a.size();\\n        for(i=1;i<n;i++)\\n        {\\n            if(a[i]==a[i-1])  //If nos are same then we skip it\\n                c=0;            \\n            else if(a[i]>a[i-1]) //if next>prev we increase the count\\n                c++;\\n            //Else we first calculate count of next<prev and update the final ans\\n            else if(c>0)           \\n            {\\n                    while(i<n and a[i]<a[i-1])\\n                    {\\n                        c++; i++;\\n                    }\\n                    ans = max(ans,c+1);\\n                    c=0 ;i--;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1468928,
                "title": "java-faster-than-100-do-checkout-for-detailed-explanation",
                "content": "**Do vote up if you like it :)**\\nTC : O(N), SC : O(1)\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        \\n        int i = 0, start = -1, end = -1;\\n        boolean peak = false, valley = false;\\n        int largestMountain = 0;\\n        \\n        while(i < arr.length - 1){ \\n            //You expect a continous increase and then a continous decrease\\n            if(arr[i] < arr[i + 1]){                \\n                start = i;\\n                peak = true;\\n                \\n                //Continous increase\\n                while(i < arr.length - 1 && arr[i] < arr[i + 1]){\\n                    i++;\\n                }\\n                \\n                //Continous decrease\\n                while(i < arr.length - 1 && arr[i] > arr[i + 1]){\\n                    valley = true;\\n                    i++;\\n                    end = i;\\n                }\\n                \\n                //If there is continous increase and continous decrease then only it\\'s a mountain\\n                if(peak && valley) largestMountain = Math.max(largestMountain, end - start + 1);\\n                //NOTE: If all the elements would be continously increasing then also it\\'s not a mountain\\n                 \\n                peak = false; valley = false;\\n            }\\n            \\n            //Not a mountain if :\\n            //elements are not strictly increasing(parallel surface)\\n            //or decreasing continously\\n            else i++;\\n        }\\n        return largestMountain;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        \\n        int i = 0, start = -1, end = -1;\\n        boolean peak = false, valley = false;\\n        int largestMountain = 0;\\n        \\n        while(i < arr.length - 1){ \\n            //You expect a continous increase and then a continous decrease\\n            if(arr[i] < arr[i + 1]){                \\n                start = i;\\n                peak = true;\\n                \\n                //Continous increase\\n                while(i < arr.length - 1 && arr[i] < arr[i + 1]){\\n                    i++;\\n                }\\n                \\n                //Continous decrease\\n                while(i < arr.length - 1 && arr[i] > arr[i + 1]){\\n                    valley = true;\\n                    i++;\\n                    end = i;\\n                }\\n                \\n                //If there is continous increase and continous decrease then only it\\'s a mountain\\n                if(peak && valley) largestMountain = Math.max(largestMountain, end - start + 1);\\n                //NOTE: If all the elements would be continously increasing then also it\\'s not a mountain\\n                 \\n                peak = false; valley = false;\\n            }\\n            \\n            //Not a mountain if :\\n            //elements are not strictly increasing(parallel surface)\\n            //or decreasing continously\\n            else i++;\\n        }\\n        return largestMountain;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401310,
                "title": "java-array-single-pass-t-c-o-n-s-c-o-1",
                "content": "\\n    public int longestMountain(int[] arr) {\\n\\n\\t\\tint len = arr.length, up = 0, down = 0, omax = 0;\\n\\t\\tboolean flag = false;\\n\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tif (arr[i] > arr[i - 1]) {\\n\\t\\t\\t\\tif (flag) {\\n\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\tup = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tup++;\\n                down = 0;\\n\\t\\t\\t} else if (arr[i] < arr[i - 1]) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\tif (up == 0)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tdown++;\\n\\t\\t\\t\\tif (up + down + 1 > omax)\\n\\t\\t\\t\\t\\tomax = up + down + 1;\\n\\t\\t\\t} else {\\n                up = 0;\\n                down = 0;\\n            }\\n\\t\\t}\\n\\n\\t\\treturn omax;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    public int longestMountain(int[] arr) {\\n\\n\\t\\tint len = arr.length, up = 0, down = 0, omax = 0;\\n\\t\\tboolean flag = false;\\n\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tif (arr[i] > arr[i - 1]) {\\n\\t\\t\\t\\tif (flag) {\\n\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\tup = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tup++;\\n                down = 0;\\n\\t\\t\\t} else if (arr[i] < arr[i - 1]) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\tif (up == 0)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tdown++;\\n\\t\\t\\t\\tif (up + down + 1 > omax)\\n\\t\\t\\t\\t\\tomax = up + down + 1;\\n\\t\\t\\t} else {\\n                up = 0;\\n                down = 0;\\n            }\\n\\t\\t}\\n\\n\\t\\treturn omax;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1271001,
                "title": "easy-to-understand-with-explanation-c-0-n-find-peak-and-stretch-left-and-right",
                "content": "You have to find the Peak ie (arr[i-1] < arr[i] && arr[i] > arr[i+1]) of the mountain , then just traverse to left side and right side to find the length. \\nCompare with maxlen  for every peak.\\n0(n+n) ~ 0(n)\\n\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        int maxLen = 0;\\n        \\n        if(n<3){\\n            return maxLen;\\n        }\\n        \\n        for(int i=1;i<n-1;i++){\\n            \\n            if(arr[i-1] < arr[i] && arr[i] > arr[i+1]) {\\n                \\n                int lidx = i,ridx=i;\\n                int len = 1;\\n                \\n                while(lidx > 0 && arr[lidx] > arr[lidx-1]){\\n                    len++; lidx--;\\n                }\\n                while(ridx+1 < n && arr[ridx] > arr[ridx+1]){\\n                    len++; ridx++;\\n                }\\n                maxLen = max(maxLen,len);\\n            } \\n        }\\n        return maxLen;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        int maxLen = 0;\\n        \\n        if(n<3){\\n            return maxLen;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1248472,
                "title": "easy-c-solution-o-n",
                "content": "int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int mountain_length =0;\\n        \\n        if(n<3) return 0;     // base case\\n        \\n        for(int i=1;i<n-1; ){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){    //To find peak of mountain\\n                int count = 1;\\n                int j = i;\\n                while(j>=1 && arr[j]>arr[j-1]){       // calculating backword length\\n                    j--;\\n                    count++;\\n                }\\n                while(i<n-1 && arr[i]>arr[i+1]){      // calculating forword length\\n                    i++;\\n                    count++;\\n                }\\n                 mountain_length = max(mountain_length,count);\\n            }else{\\n                i++;\\n            }\\n        }\\n        return mountain_length;\\n    }\\n};",
                "solutionTags": [],
                "code": "int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int mountain_length =0;\\n        \\n        if(n<3) return 0;     // base case\\n        \\n        for(int i=1;i<n-1; ){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){    //To find peak of mountain\\n                int count = 1;\\n                int j = i;\\n                while(j>=1 && arr[j]>arr[j-1]){       // calculating backword length\\n                    j--;\\n                    count++;\\n                }\\n                while(i<n-1 && arr[i]>arr[i+1]){      // calculating forword length\\n                    i++;\\n                    count++;\\n                }\\n                 mountain_length = max(mountain_length,count);\\n            }else{\\n                i++;\\n            }\\n        }\\n        return mountain_length;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1236452,
                "title": "c-1-pass-o-1-space-esay-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int max_cnt = 0;\\n        for(int i = 1; i < arr.size() - 1; i++){\\n            if(arr[i] > arr[i-1] and arr[i] > arr[i+1]){\\n                //go backward\\n                int j = i-1, cnt = 3;\\n                while(j-1 >= 0 and arr[j-1] < arr[j]){\\n                    cnt++;\\n                    j--;\\n                }\\n                //go forward\\n                int k = i+1;\\n                while( k + 1 < arr.size() and arr[k+1] < arr[k]){\\n                    cnt++;\\n                    k++;\\n                }\\n                max_cnt = max(max_cnt, cnt);\\n            }\\n        }\\n        return max_cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int max_cnt = 0;\\n        for(int i = 1; i < arr.size() - 1; i++){\\n            if(arr[i] > arr[i-1] and arr[i] > arr[i+1]){\\n                //go backward\\n                int j = i-1, cnt = 3;\\n                while(j-1 >= 0 and arr[j-1] < arr[j]){\\n                    cnt++;\\n                    j--;\\n                }\\n                //go forward\\n                int k = i+1;\\n                while( k + 1 < arr.size() and arr[k+1] < arr[k]){\\n                    cnt++;\\n                    k++;\\n                }\\n                max_cnt = max(max_cnt, cnt);\\n            }\\n        }\\n        return max_cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027675,
                "title": "c-simple-dp-apporach-with-runtime-96-40",
                "content": "**Bitonic Sequence Approach**\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& elements) {\\n        int size=elements.size();\\n        vector<int> lis(size);\\n        lis[0]=1;\\n        \\n        for(int i=1;i<size;i++){\\n            int maxyet=0;\\n            if(elements[i-1]<elements[i]){\\n                maxyet=max(maxyet,lis[i-1]);\\n            }\\n            lis[i]=maxyet+1;\\n        }\\n        \\n        vector<int> ldp(size);\\n        ldp[size-1]=1;\\n        \\n        for(int i=size-2;i>=0;i--){\\n            if(elements[i+1]<elements[i]){\\n                ldp[i]=max(ldp[i],ldp[i+1]);\\n            }\\n            ldp[i]+=1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<size;i++){\\n            if(lis[i]>1 && ldp[i]>1){\\n                ans=max(ans,(lis[i]+ldp[i]-1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& elements) {\\n        int size=elements.size();\\n        vector<int> lis(size);\\n        lis[0]=1;\\n        \\n        for(int i=1;i<size;i++){\\n            int maxyet=0;\\n            if(elements[i-1]<elements[i]){\\n                maxyet=max(maxyet,lis[i-1]);\\n            }\\n            lis[i]=maxyet+1;\\n        }\\n        \\n        vector<int> ldp(size);\\n        ldp[size-1]=1;\\n        \\n        for(int i=size-2;i>=0;i--){\\n            if(elements[i+1]<elements[i]){\\n                ldp[i]=max(ldp[i],ldp[i+1]);\\n            }\\n            ldp[i]+=1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<size;i++){\\n            if(lis[i]>1 && ldp[i]>1){\\n                ans=max(ans,(lis[i]+ldp[i]-1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938288,
                "title": "c-single-loop-o-n-time-o-1-space-explained-code-and-cases-in-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        // base case - mountain must be greater than 3, so there is no mountain\\n        if(A.size() < 3)\\n            return 0;\\n        \\n        int longestMountain = 1;        // current largest mountain in our list\\n        int previousNumber = A[0];      // current number we are looking at\\n        int currentMountain = 1;        // current size of our mountain \\n        bool isAscending = true;        // determine if we are ascending or descending in the mountain\\n        \\n        // There are potentially 4 cases that can occur within this problem\\n            // 1. We are ascending and we keep ascending - increment mountain and continue\\n            // 2. We are ascending, but the current number is smaller than previous - now we descend\\n                // 2a. Ascending, smaller number, but the current mountain is too small or the same\\n                // height, we do not swap to descending but instead reset the height\\n            // 3. We are descending and we keep descending - increment mountain and continue\\n            // 4. We are descending, but the current number is larger than previous - reset\\n            // to set our loop to the current (in case the tailend of this mountain is the start \\n            // to a bigger mountain i.e. [{4, 6, {3}, 4, 5, 7, 5, 3, 2}])\\n        \\n        for(int x = 1; x < A.size(); ++x)\\n        {\\n            if(isAscending)\\n            {\\n                // if the number is larger, then keep ascending\\n                if(A[x] > previousNumber)\\n                {\\n                    ++currentMountain;\\n                }\\n                else\\n                {\\n                    // if the number is smaller, and the current mountain is large enough\\n                    // to start a descent, and the previous number is not the same number,\\n                    // i.e. [2, 2, 2], then begin our descent (!ascending)\\n                    if(currentMountain >= 2 && A[x] != previousNumber)\\n                    {\\n                        isAscending = false;\\n                        ++currentMountain;\\n                        longestMountain = max(currentMountain, longestMountain);\\n                    }\\n                    else\\n                    {\\n                        // either the mountain is too small to descend, or we hit the same\\n                        // height so we never really ascended, so reset to height of 1\\n                        currentMountain = 1;\\n                    }\\n                }\\n                \\n                // move our previous pointer forward \\n                previousNumber = A[x];\\n            }\\n            else\\n            {\\n                // if the number is smaller, then keep descending\\n                if(A[x] < previousNumber)\\n                {\\n                    ++currentMountain;\\n                }\\n                else\\n                {\\n                    // if the number is larger, then we have reached the end of the descent\\n                    // and have finished this mountain, so reset to ascend, set the current height\\n                    // to 1 and move our current loop iterator back in case the end of this mountain\\n                    // is the start to a larger mountain\\n                    isAscending = true;\\n                    currentMountain = 1;\\n                    x--;\\n                }\\n                \\n                // set our max longest mountain each descent in case it grows to our current max\\n                longestMountain = max(currentMountain, longestMountain);\\n                \\n                // move our previous pointer forward\\n                previousNumber = A[x];\\n            }\\n        }\\n        \\n        // if our longest mountain is larger than or equal to 3 (valid mountain)\\n        // then return it\\'s height, else simply return 0 (no valid mountain)\\n        return longestMountain >= 3 ? longestMountain : 0; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        // base case - mountain must be greater than 3, so there is no mountain\\n        if(A.size() < 3)\\n            return 0;\\n        \\n        int longestMountain = 1;        // current largest mountain in our list\\n        int previousNumber = A[0];      // current number we are looking at\\n        int currentMountain = 1;        // current size of our mountain \\n        bool isAscending = true;        // determine if we are ascending or descending in the mountain\\n        \\n        // There are potentially 4 cases that can occur within this problem\\n            // 1. We are ascending and we keep ascending - increment mountain and continue\\n            // 2. We are ascending, but the current number is smaller than previous - now we descend\\n                // 2a. Ascending, smaller number, but the current mountain is too small or the same\\n                // height, we do not swap to descending but instead reset the height\\n            // 3. We are descending and we keep descending - increment mountain and continue\\n            // 4. We are descending, but the current number is larger than previous - reset\\n            // to set our loop to the current (in case the tailend of this mountain is the start \\n            // to a bigger mountain i.e. [{4, 6, {3}, 4, 5, 7, 5, 3, 2}])\\n        \\n        for(int x = 1; x < A.size(); ++x)\\n        {\\n            if(isAscending)\\n            {\\n                // if the number is larger, then keep ascending\\n                if(A[x] > previousNumber)\\n                {\\n                    ++currentMountain;\\n                }\\n                else\\n                {\\n                    // if the number is smaller, and the current mountain is large enough\\n                    // to start a descent, and the previous number is not the same number,\\n                    // i.e. [2, 2, 2], then begin our descent (!ascending)\\n                    if(currentMountain >= 2 && A[x] != previousNumber)\\n                    {\\n                        isAscending = false;\\n                        ++currentMountain;\\n                        longestMountain = max(currentMountain, longestMountain);\\n                    }\\n                    else\\n                    {\\n                        // either the mountain is too small to descend, or we hit the same\\n                        // height so we never really ascended, so reset to height of 1\\n                        currentMountain = 1;\\n                    }\\n                }\\n                \\n                // move our previous pointer forward \\n                previousNumber = A[x];\\n            }\\n            else\\n            {\\n                // if the number is smaller, then keep descending\\n                if(A[x] < previousNumber)\\n                {\\n                    ++currentMountain;\\n                }\\n                else\\n                {\\n                    // if the number is larger, then we have reached the end of the descent\\n                    // and have finished this mountain, so reset to ascend, set the current height\\n                    // to 1 and move our current loop iterator back in case the end of this mountain\\n                    // is the start to a larger mountain\\n                    isAscending = true;\\n                    currentMountain = 1;\\n                    x--;\\n                }\\n                \\n                // set our max longest mountain each descent in case it grows to our current max\\n                longestMountain = max(currentMountain, longestMountain);\\n                \\n                // move our previous pointer forward\\n                previousNumber = A[x];\\n            }\\n        }\\n        \\n        // if our longest mountain is larger than or equal to 3 (valid mountain)\\n        // then return it\\'s height, else simply return 0 (no valid mountain)\\n        return longestMountain >= 3 ? longestMountain : 0; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937703,
                "title": "python-remember-our-state-o-1",
                "content": "We need to remember what state we are in. It\\'s either plato, ascend or descend.\\n```\\ndef longestMountain(self, A: List[int]) -> int:\\n\\tif len(A) < 3: return 0\\n\\tmaxrange = 0\\n\\tleft = 0\\n\\tmode = \\'plato\\'\\n\\n\\tfor i in range(1, len(A)):\\n\\t\\tif A[i] == A[i-1]: mode = \\'plato\\'\\n\\t\\telif A[i] > A[i-1]:\\n\\t\\t\\tif mode in [\\'plato\\', \\'descend\\']:\\n\\t\\t\\t\\tleft = i - 1\\n\\t\\t\\t\\tmode = \\'ascend\\'\\n\\t\\telif mode in [\\'ascend\\', \\'descend\\']:\\n\\t\\t\\tmaxrange = max(maxrange, i + 1 - left)\\n\\t\\t\\tmode = \\'descend\\'\\n\\n\\treturn maxrange\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef longestMountain(self, A: List[int]) -> int:\\n\\tif len(A) < 3: return 0\\n\\tmaxrange = 0\\n\\tleft = 0\\n\\tmode = \\'plato\\'\\n\\n\\tfor i in range(1, len(A)):\\n\\t\\tif A[i] == A[i-1]: mode = \\'plato\\'\\n\\t\\telif A[i] > A[i-1]:\\n\\t\\t\\tif mode in [\\'plato\\', \\'descend\\']:\\n\\t\\t\\t\\tleft = i - 1\\n\\t\\t\\t\\tmode = \\'ascend\\'\\n\\t\\telif mode in [\\'ascend\\', \\'descend\\']:\\n\\t\\t\\tmaxrange = max(maxrange, i + 1 - left)\\n\\t\\t\\tmode = \\'descend\\'\\n\\n\\treturn maxrange\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 937660,
                "title": "c-two-solutions-o-n-time-o-n-o-1-space",
                "content": "**Approach 1**\\nThe idea is simple, we can maintain an `left[]` and `right[]` array to keep track of `How many elements are smaller than left[i] and right[i]`, going from left and right respectively.\\n\\nThen, we can simple iterate over the array and keep track of `possible peak` of mountain i.e we can check `from index=1 to index = arr.size()-2` which of the elements are `greater than both left and right elements from it`. \\n\\n**Solution 1**\\nTime complexity : O(N)\\nSpace Complexity: O(N)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        if(A.size() < 3){ //mountain cannot exist\\n            return 0;\\n        }\\n        \\n        vector<int> left(A.size(), 0);\\n        vector<int> right(A.size(), 0);\\n        //Build Left \\n        for(int i=1;i<A.size();i++){\\n            if(A[i] > A[i-1]){ \\n                left[i] = left[i-1] + 1;\\n            }\\n        }\\n        //Build Right\\n        for(int i=A.size()-2;i>=0;i--){\\n            if(A[i] > A[i+1]){\\n                right[i] = right[i+1] + 1;\\n            }\\n        }\\n        \\n        int mountain = 0;\\n        \\n        for(int i=1;i<A.size()-1;i++){\\n            if(A[i] > A[i-1] && A[i] > A[i+1]){ //Keep track of the highest peak\\n                mountain = max(mountain, left[i]+right[i]+1);\\n            }\\n        }\\n        \\n        return mountain;\\n    }\\n};\\n```\\n\\n**Approach 2 (Follow up)**\\nHere, we can observe from Solution 1 that we should only keep track of `possible peak` that occurs while traversing the array. This can be done by `expanding the size of mountain from a peak`. So, we can keep track of `peak` while traversing the array then we can expand on the peak and store the maximum of all those sizes.\\n\\n**Solution 2**\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        if(A.size() < 3){\\n            return 0;\\n        }\\n\\t\\t\\n        int mountain = 0;\\n        \\n        for(int i=1;i<A.size()-1;i++){\\n            if(A[i] > A[i-1] && A[i] > A[i+1]){ //Possible Peak\\n                \\n\\t\\t\\t\\t//Expanding on left\\n\\t\\t\\t\\tint j = i-1;\\n                int left = 0;\\n                int prev = A[i];\\n                while(j >= 0 && A[j] < prev){\\n                    prev = A[j];\\n                    j--;\\n                    left++;\\n                }\\n\\t\\t\\t\\t\\n                //Expanding on right\\n\\t\\t\\t\\tj = i+1;\\n                prev = A[i];\\n                int right = 0;\\n                while(j < A.size() && A[j] <  prev){\\n                    prev = A[j];\\n                    j++;\\n                    right++;\\n                }\\n                \\n\\t\\t\\t\\t//Store maximum in \\'mountain\\'\\n                mountain = max(mountain, left+right+1);\\n            }\\n        }\\n        \\n        return mountain;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        if(A.size() < 3){ //mountain cannot exist\\n            return 0;\\n        }\\n        \\n        vector<int> left(A.size(), 0);\\n        vector<int> right(A.size(), 0);\\n        //Build Left \\n        for(int i=1;i<A.size();i++){\\n            if(A[i] > A[i-1]){ \\n                left[i] = left[i-1] + 1;\\n            }\\n        }\\n        //Build Right\\n        for(int i=A.size()-2;i>=0;i--){\\n            if(A[i] > A[i+1]){\\n                right[i] = right[i+1] + 1;\\n            }\\n        }\\n        \\n        int mountain = 0;\\n        \\n        for(int i=1;i<A.size()-1;i++){\\n            if(A[i] > A[i-1] && A[i] > A[i+1]){ //Keep track of the highest peak\\n                mountain = max(mountain, left[i]+right[i]+1);\\n            }\\n        }\\n        \\n        return mountain;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        if(A.size() < 3){\\n            return 0;\\n        }\\n\\t\\t\\n        int mountain = 0;\\n        \\n        for(int i=1;i<A.size()-1;i++){\\n            if(A[i] > A[i-1] && A[i] > A[i+1]){ //Possible Peak\\n                \\n\\t\\t\\t\\t//Expanding on left\\n\\t\\t\\t\\tint j = i-1;\\n                int left = 0;\\n                int prev = A[i];\\n                while(j >= 0 && A[j] < prev){\\n                    prev = A[j];\\n                    j--;\\n                    left++;\\n                }\\n\\t\\t\\t\\t\\n                //Expanding on right\\n\\t\\t\\t\\tj = i+1;\\n                prev = A[i];\\n                int right = 0;\\n                while(j < A.size() && A[j] <  prev){\\n                    prev = A[j];\\n                    j++;\\n                    right++;\\n                }\\n                \\n\\t\\t\\t\\t//Store maximum in \\'mountain\\'\\n                mountain = max(mountain, left+right+1);\\n            }\\n        }\\n        \\n        return mountain;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937620,
                "title": "java-one-pass-o-n-easy-to-understand",
                "content": "```\\npublic int longestMountain(int[] A) {\\n\\tint result = 0, currentLength = 0;\\n\\tBoolean isIncreasing = null;\\n\\tfor(int i=1;i<A.length;i++)\\n\\t\\tif(A[i-1] < A[i]) {\\n\\t\\t\\tif(isIncreasing == null || !isIncreasing) {\\n\\t\\t\\t\\tisIncreasing = true;\\n\\t\\t\\t\\tcurrentLength = 1;\\n\\t\\t\\t}\\n\\t\\t\\tcurrentLength++;\\n\\t\\t} else if(A[i-1] > A[i] && isIncreasing != null) {\\n\\t\\t\\tisIncreasing = false;\\n\\t\\t\\tcurrentLength++;\\n\\t\\t\\tresult = Math.max(result, currentLength);\\n\\t\\t} else isIncreasing = null;\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int longestMountain(int[] A) {\\n\\tint result = 0, currentLength = 0;\\n\\tBoolean isIncreasing = null;\\n\\tfor(int i=1;i<A.length;i++)\\n\\t\\tif(A[i-1] < A[i]) {\\n\\t\\t\\tif(isIncreasing == null || !isIncreasing) {\\n\\t\\t\\t\\tisIncreasing = true;\\n\\t\\t\\t\\tcurrentLength = 1;\\n\\t\\t\\t}\\n\\t\\t\\tcurrentLength++;\\n\\t\\t} else if(A[i-1] > A[i] && isIncreasing != null) {\\n\\t\\t\\tisIncreasing = false;\\n\\t\\t\\tcurrentLength++;\\n\\t\\t\\tresult = Math.max(result, currentLength);\\n\\t\\t} else isIncreasing = null;\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 791031,
                "title": "845-longest-mountain-in-array",
                "content": "This question can be done by finding a peak at every point where there is possibility of a peak.\\nPossibility means that previous element is smaller than current element and next is also smaller than current element.At that point we will check the length of the left part and right part and return left+right+1.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\n//  We\\'ll check the left length and the right length and return 1+left+right which will give the length of the mountain.   \\n    int getPeaklength(vector<int> v,int i)\\n    {\\n        int j=i;\\n        int left_length=0,right_length=0;\\n        while(j-1>=0)\\n        {\\n            if(v[j-1]<v[j])\\n                ++left_length;\\n            else\\n                break;\\n            --j;\\n        }\\n        if(left_length==0)\\n            return 0;\\n        while(i+1<v.size())\\n        {\\n            if(v[i+1]<v[i])\\n                ++right_length; \\n            else\\n                break;\\n            ++i;\\n        }\\n        if(right_length==0)\\n            return 0;\\n        return left_length+right_length+1;\\n    }\\n    \\n    int longestMountain(vector<int>& A) {\\n        if(A.size()<3)\\n            return 0;\\n        int max_len=0;\\n        for(int i=1;i<A.size()-1;++i)\\n        {\\n//          If the left part is smaller and right is also smaller then there is a probability  for a peak.We\\'ll check it \\n            if(A[i+1]<A[i] && A[i-1]<A[i])\\n            {\\n                int cur_length=getPeaklength(A,i);\\n                max_len=max(cur_length,max_len);\\n            }\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n//  We\\'ll check the left length and the right length and return 1+left+right which will give the length of the mountain.   \\n    int getPeaklength(vector<int> v,int i)\\n    {\\n        int j=i;\\n        int left_length=0,right_length=0;\\n        while(j-1>=0)\\n        {\\n            if(v[j-1]<v[j])\\n                ++left_length;\\n            else\\n                break;\\n            --j;\\n        }\\n        if(left_length==0)\\n            return 0;\\n        while(i+1<v.size())\\n        {\\n            if(v[i+1]<v[i])\\n                ++right_length; \\n            else\\n                break;\\n            ++i;\\n        }\\n        if(right_length==0)\\n            return 0;\\n        return left_length+right_length+1;\\n    }\\n    \\n    int longestMountain(vector<int>& A) {\\n        if(A.size()<3)\\n            return 0;\\n        int max_len=0;\\n        for(int i=1;i<A.size()-1;++i)\\n        {\\n//          If the left part is smaller and right is also smaller then there is a probability  for a peak.We\\'ll check it \\n            if(A[i+1]<A[i] && A[i-1]<A[i])\\n            {\\n                int cur_length=getPeaklength(A,i);\\n                max_len=max(cur_length,max_len);\\n            }\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568903,
                "title": "simple-c-solution-with-explanation",
                "content": "1. A point can be a mountain peak, if its left value is lower and right is higher.\\n2. When such point is encountered, we traverse in both direction and find out the length.\\n3. once traverse is done, we update the max_len of mountain.\\n4. Now we can directly jump to right index to check again the peak condition.\\n\\nEach point will be traversed max 2 times. so Time = O(n)\\n\\n```\\n    int longestMountain(vector<int>& arr) {        \\n        int len = arr.size();        \\n        if(len < 3)\\n        {\\n            return 0;\\n        }        \\n        int max_len = 0;\\n        int i = 1;\\n        while(i < len-1)\\n        {\\n            // this is a mountain peak\\n            if(arr[i] > arr[i-1] && arr[i] > arr[i+1])\\n            {\\n                int low = i-1, high = i+1;                \\n                while(low >= 0 && arr[low] < arr[low+1])\\n                {\\n                    low--;\\n                }                            \\n                while(high < len && arr[high] < arr[high-1])\\n                {\\n                    high++;\\n                }                            \\n                max_len = max(max_len, high-low-1);\\n                i = high;\\n            }\\n            else\\n            {\\n                i++;\\n            }                        \\n        }        \\n        return max_len;        \\n    }\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int longestMountain(vector<int>& arr) {        \\n        int len = arr.size();        \\n        if(len < 3)\\n        {\\n            return 0;\\n        }        \\n        int max_len = 0;\\n        int i = 1;\\n        while(i < len-1)\\n        {\\n            // this is a mountain peak\\n            if(arr[i] > arr[i-1] && arr[i] > arr[i+1])\\n            {\\n                int low = i-1, high = i+1;                \\n                while(low >= 0 && arr[low] < arr[low+1])\\n                {\\n                    low--;\\n                }                            \\n                while(high < len && arr[high] < arr[high-1])\\n                {\\n                    high++;\\n                }                            \\n                max_len = max(max_len, high-low-1);\\n                i = high;\\n            }\\n            else\\n            {\\n                i++;\\n            }                        \\n        }        \\n        return max_len;        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540621,
                "title": "java-dp-solution-o-n-time-and-o-n-memory",
                "content": "1. An int array leftIncr: leftIncr[i] denotes length of consecutive increasing subarray and A[i] is not included.\\n2. An int array rightDecr: rightDecr[i] denotes the length of consecutive decreasing subarray starts from A[i + 1];\\n3. The longest mountain array = max of ```leftIncr[i] + rightDecr[i] + 1```. \\n```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int[] leftIncr = new int[A.length];\\n        int[] rightDecr = new int[A.length];\\n        \\n        for(int i = 1; i < A.length; ++i) {\\n            if(A[i] > A[i - 1]) {\\n                leftIncr[i] = leftIncr[i - 1] + 1;\\n            }\\n            if(A[A.length - 1 - i] > A[A.length - i]) {\\n                rightDecr[A.length - 1 - i] = rightDecr[A.length - i] + 1;\\n            }\\n        }\\n        \\n        int max = 0;\\n        for(int i = 1; i < A.length - 1; ++i) {\\n            if(leftIncr[i] > 0 && rightDecr[i] > 0) {\\n                max = Math.max(max, leftIncr[i] + rightDecr[i] + 1);\\n            }\\n        }\\n        \\n        return max;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```leftIncr[i] + rightDecr[i] + 1```\n```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int[] leftIncr = new int[A.length];\\n        int[] rightDecr = new int[A.length];\\n        \\n        for(int i = 1; i < A.length; ++i) {\\n            if(A[i] > A[i - 1]) {\\n                leftIncr[i] = leftIncr[i - 1] + 1;\\n            }\\n            if(A[A.length - 1 - i] > A[A.length - i]) {\\n                rightDecr[A.length - 1 - i] = rightDecr[A.length - i] + 1;\\n            }\\n        }\\n        \\n        int max = 0;\\n        for(int i = 1; i < A.length - 1; ++i) {\\n            if(leftIncr[i] > 0 && rightDecr[i] > 0) {\\n                max = Math.max(max, leftIncr[i] + rightDecr[i] + 1);\\n            }\\n        }\\n        \\n        return max;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484070,
                "title": "the-good-the-bad-and-the-ugly",
                "content": "All solutions use only one loop. I\\'ve pushed a value in the vector, but I pop it back at the end. This could be avoided with additional checks so I did it just for lulz.\\n\\n**Solution 1** (two auxillary variables)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        if (A.size() < 3)\\n            return 0;        \\n        A.push_back(A.back());\\n        int v=0, m=0;\\n        \\n        for (int i=1; i<A.size(); ++i)\\n        {\\n            if ((A[i-1] <= A[i] && A[i] >= A[i+1]) && !(A[i-1] < A[i] && A[i] > A[i+1]))\\n                v=i+1;\\n                \\n            if (A[i-1] >= A[i]  && A[i] <= A[i+1])\\n            {\\n                if (i>v && A[v+1] > A[v])\\n                    m = max(i-v+1, m);\\n                v = i;\\n            }\\n        }     \\n\\t\\tA.pop_back();\\n        return m;\\n       }\\n};\\n```\\n**Solution 2**(three auxillary variables)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        if (A.size() < 3)\\n            return 0;        \\n        A.push_back(10001);\\n\\t\\tint p = 0, v = 0, m = 0;\\n\\t\\t\\n        for (int i=1; i<A.size()-1; ++i)\\n        {\\n            p = A[i-1] < A[i] && A[i] > A[i+1] ? i : p;\\n            if (A[i-1] >= A[i] && A[i] <= A[i+1])\\n            {\\n                if (v < p)\\n                    m = max(i - v + 1, m);\\n                v = i;\\n            }\\n        }\\n\\t\\tA.pop_back();\\n        return m;\\n\\t }\\n};\\n```\\n**Solution 3** (two auxillary variables + flag)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        int p = 0, m = 0;\\n        bool asc = true;\\n                \\n        for (int i=1; i<A.size(); ++i)\\n        {\\n            if (i == p+1 && A[i] <= A[i-1])\\n                p++;\\n            else if (asc) \\n            {\\n                if (A[i] == A[i-1]) \\n                    p=i;\\n                else if (A[i] < A[i-1])                  \\n                    asc = false; \\n            }\\n            else if (A[i] >= A[i-1])\\n            {\\n                asc = true;\\n                m = max(i-p, m);\\n                p = (A[i] >  A[i-1]) ? i-1: i;\\n            }\\n        }\\n            \\n        if (!asc) m = max(int(A.size())-p, m);     \\n        return m;\\n\\t }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        if (A.size() < 3)\\n            return 0;        \\n        A.push_back(A.back());\\n        int v=0, m=0;\\n        \\n        for (int i=1; i<A.size(); ++i)\\n        {\\n            if ((A[i-1] <= A[i] && A[i] >= A[i+1]) && !(A[i-1] < A[i] && A[i] > A[i+1]))\\n                v=i+1;\\n                \\n            if (A[i-1] >= A[i]  && A[i] <= A[i+1])\\n            {\\n                if (i>v && A[v+1] > A[v])\\n                    m = max(i-v+1, m);\\n                v = i;\\n            }\\n        }     \\n\\t\\tA.pop_back();\\n        return m;\\n       }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        if (A.size() < 3)\\n            return 0;        \\n        A.push_back(10001);\\n\\t\\tint p = 0, v = 0, m = 0;\\n\\t\\t\\n        for (int i=1; i<A.size()-1; ++i)\\n        {\\n            p = A[i-1] < A[i] && A[i] > A[i+1] ? i : p;\\n            if (A[i-1] >= A[i] && A[i] <= A[i+1])\\n            {\\n                if (v < p)\\n                    m = max(i - v + 1, m);\\n                v = i;\\n            }\\n        }\\n\\t\\tA.pop_back();\\n        return m;\\n\\t }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        int p = 0, m = 0;\\n        bool asc = true;\\n                \\n        for (int i=1; i<A.size(); ++i)\\n        {\\n            if (i == p+1 && A[i] <= A[i-1])\\n                p++;\\n            else if (asc) \\n            {\\n                if (A[i] == A[i-1]) \\n                    p=i;\\n                else if (A[i] < A[i-1])                  \\n                    asc = false; \\n            }\\n            else if (A[i] >= A[i-1])\\n            {\\n                asc = true;\\n                m = max(i-p, m);\\n                p = (A[i] >  A[i-1]) ? i-1: i;\\n            }\\n        }\\n            \\n        if (!asc) m = max(int(A.size())-p, m);     \\n        return m;\\n\\t }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285499,
                "title": "java-dp-o-n-easier-to-understand",
                "content": "let\\'s create 2 dp arrays ,\\none for counting length of mountain up from the left side,\\nthe other same purpose from the right side.\\nCodes are a little too much , but this is a very easy way to come up during interview.\\n```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        int n = A.length;//n stands for array length\\n        \\n        if(n>0){\\n            \\n         int[] left = new int[n];\\n         int[] right = new int[n];\\n         left[0]=0;\\n         right[n-1]=0;\\n            \\n         for(int i = 1;i<n;i++){\\n            if(A[i]>A[i-1]){\\n                left[i]=left[i-1]+1;\\n            }else{\\n                left[i]=0;\\n            }\\n         }\\n        \\n         for(int j = n-2;j>-1;j--){\\n            if(A[j]>A[j+1]){\\n                right[j]=right[j+1]+1;\\n            }else{\\n                right[j]=0;\\n            }\\n         }\\n        \\n        \\n         for(int k = 0;k<n;k++){\\n          if(left[k]>0 && right[k]>0){\\n            result = Math.max(result,left[k]+right[k]+1);      \\n          }   \\n         }\\n            \\n        }\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        int n = A.length;//n stands for array length\\n        \\n        if(n>0){\\n            \\n         int[] left = new int[n];\\n         int[] right = new int[n];\\n         left[0]=0;\\n         right[n-1]=0;\\n            \\n         for(int i = 1;i<n;i++){\\n            if(A[i]>A[i-1]){\\n                left[i]=left[i-1]+1;\\n            }else{\\n                left[i]=0;\\n            }\\n         }\\n        \\n         for(int j = n-2;j>-1;j--){\\n            if(A[j]>A[j+1]){\\n                right[j]=right[j+1]+1;\\n            }else{\\n                right[j]=0;\\n            }\\n         }\\n        \\n        \\n         for(int k = 0;k<n;k++){\\n          if(left[k]>0 && right[k]>0){\\n            result = Math.max(result,left[k]+right[k]+1);      \\n          }   \\n         }\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285145,
                "title": "java-intuitive-solution-go-uphill-and-downhill",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int res = 0;\\n        for(int i = 1; i < A.length; ){\\n            if(A[i] > A[i - 1]){\\n                int j = i;\\n                \\n                //go uphill\\n                while(j < A.length && A[j] > A[j - 1]){\\n                    j++;\\n                }\\n                \\n                if(j == A.length)\\n                    break;\\n                if(A[j] == A[j - 1]){\\n                    i = j + 1;\\n                    continue;\\n                }\\t\\t\\t\\t\\t\\n                \\n                //go downhill\\n                while(j < A.length && A[j] < A[j - 1]){\\n                    j++;\\n                }\\n                \\n                if(j - i > 1)\\n                    res = Math.max(res, j - i + 1);\\n                \\n                i = j;\\n            } else \\n                i++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nThanks fan_zh for point out the duplicate numbers senario.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int res = 0;\\n        for(int i = 1; i < A.length; ){\\n            if(A[i] > A[i - 1]){\\n                int j = i;\\n                \\n                //go uphill\\n                while(j < A.length && A[j] > A[j - 1]){\\n                    j++;\\n                }\\n                \\n                if(j == A.length)\\n                    break;\\n                if(A[j] == A[j - 1]){\\n                    i = j + 1;\\n                    continue;\\n                }\\t\\t\\t\\t\\t\\n                \\n                //go downhill\\n                while(j < A.length && A[j] < A[j - 1]){\\n                    j++;\\n                }\\n                \\n                if(j - i > 1)\\n                    res = Math.max(res, j - i + 1);\\n                \\n                i = j;\\n            } else \\n                i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239625,
                "title": "1-pass-solution-easy-to-understand",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int i = 0;\\n        int start = 0;\\n        int peak = 0;\\n        int end = 0;\\n        int answer = 0;\\n        while(i + 1 < A.size())\\n        {\\n            // go to local min\\n            while(i + 1 < A.size() && A[i] > A[i + 1])\\n            {\\n                i++;\\n            }\\n            // record starting index\\n            start = i;\\n            // going up\\n            while(i + 1 < A.size() && A[i] < A[i + 1])\\n            {\\n                i++;\\n            }\\n            // record peak index\\n            peak = i;\\n            // going down\\n            while(i + 1 < A.size() && A[i] > A[i + 1])\\n            {\\n                i++;\\n            }\\n            //record end index\\n            end = i;\\n            // if start, peak, end, have different index, there is a mountain\\n            if(start != peak && peak != end)\\n            {\\n                answer = max(answer, i + 1 - start);\\n            }\\n            // if is flat, move one step\\n            if(i + 1 < A.size() && A[i] == A[i + 1])\\n            {\\n                i++;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int i = 0;\\n        int start = 0;\\n        int peak = 0;\\n        int end = 0;\\n        int answer = 0;\\n        while(i + 1 < A.size())\\n        {\\n            // go to local min\\n            while(i + 1 < A.size() && A[i] > A[i + 1])\\n            {\\n                i++;\\n            }\\n            // record starting index\\n            start = i;\\n            // going up\\n            while(i + 1 < A.size() && A[i] < A[i + 1])\\n            {\\n                i++;\\n            }\\n            // record peak index\\n            peak = i;\\n            // going down\\n            while(i + 1 < A.size() && A[i] > A[i + 1])\\n            {\\n                i++;\\n            }\\n            //record end index\\n            end = i;\\n            // if start, peak, end, have different index, there is a mountain\\n            if(start != peak && peak != end)\\n            {\\n                answer = max(answer, i + 1 - start);\\n            }\\n            // if is flat, move one step\\n            if(i + 1 < A.size() && A[i] == A[i + 1])\\n            {\\n                i++;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148674,
                "title": "c-one-pass-with-comments",
                "content": "```\\n    int longestMountain(vector<int>& A) {\\n        int s = 0, p = -1, res = 0, n = A.size();\\n        for (int i = 1; i < n; i++) {\\n            if (p != -1) {\\n                // if we are tracking peak and it goes down then update result\\n                // if it does not go down, then reset peak\\n                if (A[i] < A[i-1]) res = max(i-s+1, res);\\n                else p = -1;\\n            }\\n            if ((i < n-1 && A[i] < A[i+1]) && A[i] <= A[i-1]) {\\n                // find starting point of next mountain\\n                s = i;\\n            }\\n            if ((A[i-1] < A[i]) && (i < n-1 && A[i] > A[i+1])) {\\n                // find peak\\n                p = i;\\n            }            \\n        }\\n        return res;\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n    int longestMountain(vector<int>& A) {\\n        int s = 0, p = -1, res = 0, n = A.size();\\n        for (int i = 1; i < n; i++) {\\n            if (p != -1) {\\n                // if we are tracking peak and it goes down then update result\\n                // if it does not go down, then reset peak\\n                if (A[i] < A[i-1]) res = max(i-s+1, res);\\n                else p = -1;\\n            }\\n            if ((i < n-1 && A[i] < A[i+1]) && A[i] <= A[i-1]) {\\n                // find starting point of next mountain\\n                s = i;\\n            }\\n            if ((A[i-1] < A[i]) && (i < n-1 && A[i] > A[i+1])) {\\n                // find peak\\n                p = i;\\n            }            \\n        }\\n        return res;\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 135623,
                "title": "kt-js-py3-cpp-mountain-peak",
                "content": "Let each index `k` be the candidate \"peak\" of the mountain.  Let `i` be the index used to traverse the left-downslope of the mountain and let `j` be the index used to traverse the right-downslope of the mountain.  If both `i` and `j` are able to go downwards starting from the peak `k`, then a mountain has been found.  Return the longest mountain from `i..j` inclusive as the `best` answer.\\n\\n---\\n\\n**Runtime:** O(N<sup>2</sup>)\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun longestMountain(A: IntArray): Int {\\n        var best = 0\\n        var N = A.size\\n        for (k in 1 until N - 1) {\\n            var i = k\\n            var j = k\\n            while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n            while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n            if (i < k && k < j)\\n                best = Math.max(best, j - i + 1)  // +1 for i..j inclusive\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet longestMountain = (A, best = 0) => {\\n    let N = A.length;\\n    for (let k = 1; k + 1 < N; ++k) {\\n        let i = k,\\n            j = k;\\n        while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n        while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n        if (i < k && k < j)\\n            best = Math.max(best, j - i + 1);  // +1 for i..j inclusive\\n    }\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def longestMountain(self, A: List[int], best = 0) -> int:\\n        N = len(A)\\n        for k in range(1, N - 1):\\n            i = k\\n            j = k\\n            while 0 <= i - 1 and A[i - 1] < A[i]: i -= 1\\n            while j + 1 < N  and A[j] > A[j + 1]: j += 1\\n            if i < k < j:\\n                best = max(best, j - i + 1)  # +1 for i..j inclusive\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int longestMountain(VI& A, int best = 0) {\\n        int N = A.size();\\n        for (auto k{ 1 }; k + 1 < N; ++k) {\\n            auto i = k,\\n                 j = k;\\n            while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n            while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n            if (i < k && k < j)\\n                best = max(best, j - i + 1);  // +1 for i..j inclusive\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun longestMountain(A: IntArray): Int {\\n        var best = 0\\n        var N = A.size\\n        for (k in 1 until N - 1) {\\n            var i = k\\n            var j = k\\n            while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n            while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n            if (i < k && k < j)\\n                best = Math.max(best, j - i + 1)  // +1 for i..j inclusive\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nlet longestMountain = (A, best = 0) => {\\n    let N = A.length;\\n    for (let k = 1; k + 1 < N; ++k) {\\n        let i = k,\\n            j = k;\\n        while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n        while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n        if (i < k && k < j)\\n            best = Math.max(best, j - i + 1);  // +1 for i..j inclusive\\n    }\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def longestMountain(self, A: List[int], best = 0) -> int:\\n        N = len(A)\\n        for k in range(1, N - 1):\\n            i = k\\n            j = k\\n            while 0 <= i - 1 and A[i - 1] < A[i]: i -= 1\\n            while j + 1 < N  and A[j] > A[j + 1]: j += 1\\n            if i < k < j:\\n                best = max(best, j - i + 1)  # +1 for i..j inclusive\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int longestMountain(VI& A, int best = 0) {\\n        int N = A.size();\\n        for (auto k{ 1 }; k + 1 < N; ++k) {\\n            auto i = k,\\n                 j = k;\\n            while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n            while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n            if (i < k && k < j)\\n                best = max(best, j - i + 1);  // +1 for i..j inclusive\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066684,
                "title": "java-easy-one-pass-solution-o-1-memory",
                "content": "```java\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int up = 0, down = 0, result = 0;\\n\\n        for(int i = 1; i < arr.length; ++i) {\\n            if((down > 0 && arr[i - 1] < arr[i]) || arr[i - 1] == arr[i])\\n                up = down = 0;\\n            if(arr[i - 1] < arr[i])\\n                up++;\\n            if(arr[i - 1] > arr[i])\\n                down++;\\n            if(down > 0 && up > 0 && up + down + 1 > result)\\n                result = up + down + 1;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int up = 0, down = 0, result = 0;\\n\\n        for(int i = 1; i < arr.length; ++i) {\\n            if((down > 0 && arr[i - 1] < arr[i]) || arr[i - 1] == arr[i])\\n                up = down = 0;\\n            if(arr[i - 1] < arr[i])\\n                up++;\\n            if(arr[i - 1] > arr[i])\\n                down++;\\n            if(down > 0 && up > 0 && up + down + 1 > result)\\n                result = up + down + 1;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041553,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static int helper(int arr[], int idx){\\n        int ans = 0;\\n\\n        int i = idx-1;\\n        int a = arr[idx];\\n        while(i>=0 && arr[i]<a){\\n            ans++;\\n            a=arr[i];\\n            i--;\\n        }\\n        \\n        i=idx+1;\\n        a=arr[idx];\\n\\n        while(i<arr.length && arr[i]<a){\\n            ans++;\\n            a=arr[i];\\n            i++;\\n        }\\n\\n        return ans+1;\\n    }\\n    public int longestMountain(int[] arr) {\\n        int n = arr.length;\\n\\n        int max = 0;\\n\\n        for(int i=1; i<n-1; i++){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){\\n                max = Math.max(max,helper(arr,i));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static int helper(int arr[], int idx){\\n        int ans = 0;\\n\\n        int i = idx-1;\\n        int a = arr[idx];\\n        while(i>=0 && arr[i]<a){\\n            ans++;\\n            a=arr[i];\\n            i--;\\n        }\\n        \\n        i=idx+1;\\n        a=arr[idx];\\n\\n        while(i<arr.length && arr[i]<a){\\n            ans++;\\n            a=arr[i];\\n            i++;\\n        }\\n\\n        return ans+1;\\n    }\\n    public int longestMountain(int[] arr) {\\n        int n = arr.length;\\n\\n        int max = 0;\\n\\n        for(int i=1; i<n-1; i++){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){\\n                max = Math.max(max,helper(arr,i));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759339,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\nWe have an array `arr` where two consecutive elements can be either one of these:-\\n1. `arr[i] > arr[i-1]`\\n2. `arr[i] < arr[i-1]`\\n3. `arr[i] == arr[i-1]` `Apparently arr[i] not a part of the mountain array`\\nLooking at our question carefully, we can say for cases with `arr.size() < 3` would  have no mountain array. Whenever the array is increasing first(i.e. 1st condition holds first) there is a possibility of having the required array.But we can\\'t be assured until we encounter 2nd condition at least once. This is the primary logic behind.\\n\\n# Approach\\nWe initialise two variables to check when our array is strictly increasing or strictly decreasing. Next we check the cases where the monotonocity is broken.Cases where 3rd condition mentioned in intuition hold will just be ignored and thus we approach the maximum length of mountain we can encounter.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n// no mountain exists\\n        if(n < 3) return 0;\\n        int ans = 0,temp = 0,checkinc = 0, checkdec = 0;\\n        for(int  i = 1; i < n; i++){\\n            if(arr[i] > arr[i-1]){\\n// the end of the mountain\\n                if(checkdec == 1){\\n                    ans = max(temp,ans);\\n                    checkdec = 0;\\n                    checkinc = 1;\\n                    temp = 2;\\n                }\\n                else{\\n// the start of a new mountain\\n                    if(checkinc == 0){\\n                    temp =2;\\n                    checkinc = 1;\\n                    }\\n//add to the existing mountain\\n                    else\\n                    temp++;\\n                }\\n            }\\n            else if(arr[i] < arr[i-1]){\\n// the peak of the mountain\\n                if(checkinc == 1){\\n                    if(checkdec == 0)\\n                    checkdec =1;\\n//add to the existing mountain\\n                    temp++;\\n                }\\n//no mountain\\n                else{\\n                temp = 0;\\n                checkdec = 0;\\n                checkinc = 0;\\n            }\\n            }\\n            else{\\n// the end of the mountain\\n                if(checkinc == 1 && checkdec == 1)\\n                 ans = max(temp,ans);\\n// no mountain exists here\\n                 checkinc = 0;\\n                 checkdec = 0;\\n                 temp = 0;\\n            }\\n        }\\n// the end of the mountain\\n        if(checkinc == 1 && checkdec == 1)\\n        ans = max(temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n// no mountain exists\\n        if(n < 3) return 0;\\n        int ans = 0,temp = 0,checkinc = 0, checkdec = 0;\\n        for(int  i = 1; i < n; i++){\\n            if(arr[i] > arr[i-1]){\\n// the end of the mountain\\n                if(checkdec == 1){\\n                    ans = max(temp,ans);\\n                    checkdec = 0;\\n                    checkinc = 1;\\n                    temp = 2;\\n                }\\n                else{\\n// the start of a new mountain\\n                    if(checkinc == 0){\\n                    temp =2;\\n                    checkinc = 1;\\n                    }\\n//add to the existing mountain\\n                    else\\n                    temp++;\\n                }\\n            }\\n            else if(arr[i] < arr[i-1]){\\n// the peak of the mountain\\n                if(checkinc == 1){\\n                    if(checkdec == 0)\\n                    checkdec =1;\\n//add to the existing mountain\\n                    temp++;\\n                }\\n//no mountain\\n                else{\\n                temp = 0;\\n                checkdec = 0;\\n                checkinc = 0;\\n            }\\n            }\\n            else{\\n// the end of the mountain\\n                if(checkinc == 1 && checkdec == 1)\\n                 ans = max(temp,ans);\\n// no mountain exists here\\n                 checkinc = 0;\\n                 checkdec = 0;\\n                 temp = 0;\\n            }\\n        }\\n// the end of the mountain\\n        if(checkinc == 1 && checkdec == 1)\\n        ans = max(temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626219,
                "title": "longest-bitonic-subsequence-dynamic-programming-c",
                "content": "# Approach :\\nTo solve this problem, we can start by observing that a mountain sequence is essentially a combination of an increasing subsequence followed by a decreasing subsequence. Therefore, we can utilize the concept of the Longest Increasing Subsequence (LIS) to find the longest mountain sequence.\\n\\nWe can maintain two dynamic programming arrays: dp and dp2. The dp array will store the length of the increasing subsequence ending at each index, similar to the LIS problem. The dp2 array will store the length of the decreasing subsequence starting at each index.\\n\\nWe can iterate over the array arr twice. In the first iteration, we calculate the length of the increasing subsequence ending at each index and store it in the dp array. We compare each element with its previous element and if it is greater, we can extend the increasing subsequence length. In the second iteration (reversed), we calculate the length of the decreasing subsequence starting at each index and store it in the dp2 array. We compare each element with its next element and if it is greater, we can extend the decreasing subsequence length.\\n\\nFinally, we iterate over each index and check if both the increasing and decreasing subsequences have lengths greater than 1. If this condition is met at a particular index, we calculate the length of the mountain sequence by summing the lengths of the corresponding subsequences and subtracting 1 (to avoid counting the same element twice). We update a variable ans to keep track of the maximum length found.\\n\\nAt the end of the iteration, we return the value stored in ans, which represents the maximum length of a valid mountain sequence in the input array arr.\\n\\nIn summary, we utilize the concept of the Longest Increasing Subsequence (LIS) to find the longest mountain sequence. By maintaining two dynamic programming arrays and iterating over the array twice, we can calculate the lengths of the increasing and decreasing subsequences. Finally, we find the maximum length of a mountain sequence by summing the lengths of the corresponding subsequences at each index and subtracting 1.\\n\\n**[Link to the detailed Longest Bitonic Subsequence approach](https://takeuforward.org/data-structure/longest-bitonic-subsequence-dp-46/)**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : The time complexity of the given solution is $$O(n)$$, where n is the size of the input array arr. This is because we iterate over the array twice, performing constant-time operations for each element.\\nIn the first iteration, we calculate the length of the increasing subsequence ending at each index. This requires comparing each element with its previous element, resulting in n-1 comparisons. Therefore, the time complexity of this step is $$O(n)$$.\\nIn the second iteration (reversed), we calculate the length of the decreasing subsequence starting at each index. This also requires comparing each element with its next element, resulting in n-1 comparisons. Hence, the time complexity of this step is also $$O(n)$$.\\nFinally, we iterate over each index to find the maximum length of a mountain sequence. This operation takes constant time for each index, resulting in $$O(n)$$ time complexity.\\nOverall, the time complexity of the solution is $$O(n)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : The space complexity of the solution is $$O(n)$$ as well. We use two additional arrays, dp and dp2, to store the lengths of the increasing and decreasing subsequences, respectively. Both arrays have a length of n, which is the same as the input array arr. Therefore, the space complexity is linear in terms of the input size.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code :\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1); // dp[i] stores the length of the increasing subsequence ending at index i\\n        vector<int> dp2(n, 1); // dp2[i] stores the length of the decreasing subsequence starting at index i\\n        int ans = 0; // Variable to store the maximum length of a mountain sequence\\n\\n        // Calculate the length of the increasing subsequence ending at each index\\n        for (int ind = 1; ind < n; ind++) {\\n            if (arr[ind] > arr[ind - 1]) {\\n                // If the element at the current index is greater than the previous element,\\n                // we can extend the increasing subsequence. Increment dp[ind] by 1.\\n                dp[ind] = 1 + dp[ind - 1];\\n            }\\n        }\\n\\n        // Calculate the length of the decreasing subsequence starting at each index\\n        for (int ind = n - 2; ind >= 0; ind--) {\\n            if (arr[ind] > arr[ind + 1]) {\\n                // If the element at the current index is greater than the next element,\\n                // we can extend the decreasing subsequence. Increment dp2[ind] by 1.\\n                dp2[ind] = 1 + dp2[ind + 1];\\n            }\\n        }\\n\\n        // Iterate over each index and find the maximum length of a mountain sequence\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] > 1 && dp2[i] > 1) {\\n                // If both the increasing and decreasing subsequences have lengths greater than 1 at index i,\\n                // calculate the length of the mountain sequence by summing the lengths of the subsequences\\n                // and subtracting 1 (to avoid counting the same element twice). Update the ans variable.\\n                ans = max(dp[i] + dp2[i] - 1, ans);\\n            }\\n        }\\n\\n        return ans; // Return the maximum length of a mountain sequence\\n    }\\n};\\n```\\n---\\n\\n**PLEASE UPVOTE IF YOU LIKED THE SOLUTION :)**\\n\\n![ezgif.com-optimize.gif](https://assets.leetcode.com/users/images/c7837255-5339-41d8-b699-1dff126e8726_1686500536.441457.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1); // dp[i] stores the length of the increasing subsequence ending at index i\\n        vector<int> dp2(n, 1); // dp2[i] stores the length of the decreasing subsequence starting at index i\\n        int ans = 0; // Variable to store the maximum length of a mountain sequence\\n\\n        // Calculate the length of the increasing subsequence ending at each index\\n        for (int ind = 1; ind < n; ind++) {\\n            if (arr[ind] > arr[ind - 1]) {\\n                // If the element at the current index is greater than the previous element,\\n                // we can extend the increasing subsequence. Increment dp[ind] by 1.\\n                dp[ind] = 1 + dp[ind - 1];\\n            }\\n        }\\n\\n        // Calculate the length of the decreasing subsequence starting at each index\\n        for (int ind = n - 2; ind >= 0; ind--) {\\n            if (arr[ind] > arr[ind + 1]) {\\n                // If the element at the current index is greater than the next element,\\n                // we can extend the decreasing subsequence. Increment dp2[ind] by 1.\\n                dp2[ind] = 1 + dp2[ind + 1];\\n            }\\n        }\\n\\n        // Iterate over each index and find the maximum length of a mountain sequence\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] > 1 && dp2[i] > 1) {\\n                // If both the increasing and decreasing subsequences have lengths greater than 1 at index i,\\n                // calculate the length of the mountain sequence by summing the lengths of the subsequences\\n                // and subtracting 1 (to avoid counting the same element twice). Update the ans variable.\\n                ans = max(dp[i] + dp2[i] - 1, ans);\\n            }\\n        }\\n\\n        return ans; // Return the maximum length of a mountain sequence\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462560,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int n=arr.length;\\n        int dp1[]=new int[n];\\n        int dp2[]=new int[n];\\n        Arrays.fill(dp1,1);\\n        Arrays.fill(dp2,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i-1]<arr[i])\\n                dp1[i]=dp1[i-1]+1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(arr[i+1]<arr[i])\\n                dp2[i]=dp2[i+1]+1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            System.out.println(dp1[i]+\" \"+dp2[i]);\\n            if(dp1[i]>1 && dp2[i]>1)\\n                max=(int)Math.max(max,dp1[i]+dp2[i]-1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int n=arr.length;\\n        int dp1[]=new int[n];\\n        int dp2[]=new int[n];\\n        Arrays.fill(dp1,1);\\n        Arrays.fill(dp2,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i-1]<arr[i])\\n                dp1[i]=dp1[i-1]+1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(arr[i+1]<arr[i])\\n                dp2[i]=dp2[i+1]+1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            System.out.println(dp1[i]+\" \"+dp2[i]);\\n            if(dp1[i]>1 && dp2[i]>1)\\n                max=(int)Math.max(max,dp1[i]+dp2[i]-1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161657,
                "title": "prefix-and-suffix-sum-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int prefix[10001],suffix[10001];\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        map<int,int> mp;\\n        for(auto it:arr) mp[it]++;\\n        if(mp.size()==1) return 0;\\n        int n=arr.size();\\n       int ckt=1;\\n        prefix[0]=ckt;\\n        for(int i=1;i<n;i++){\\n          if(arr[i-1]<arr[i]){\\n              ckt++;\\n          }\\n        else ckt=1;\\n          prefix[i]=ckt;\\n        }\\n        // similarly for suffix\\n        ckt=1;\\n        suffix[n-1]=ckt;\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]) ckt++;\\n            else ckt=1;\\n            suffix[i]=ckt;\\n        }\\n        for(int i=0;i<n;i++){\\n            cout<<prefix[i]<<\" \";\\n        }\\n        cout<<endl;\\n        for(int i=0;i<n;i++){\\n            cout<<suffix[i]<<\" \";\\n        }\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            int sum=prefix[i]+suffix[i]-1;\\n            if(prefix[i]!=1 && suffix[i]!=1) maxi=max(maxi,sum);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    int prefix[10001],suffix[10001];\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        map<int,int> mp;\\n        for(auto it:arr) mp[it]++;\\n        if(mp.size()==1) return 0;\\n        int n=arr.size();\\n       int ckt=1;\\n        prefix[0]=ckt;\\n        for(int i=1;i<n;i++){\\n          if(arr[i-1]<arr[i]){\\n              ckt++;\\n          }\\n        else ckt=1;\\n          prefix[i]=ckt;\\n        }\\n        // similarly for suffix\\n        ckt=1;\\n        suffix[n-1]=ckt;\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]) ckt++;\\n            else ckt=1;\\n            suffix[i]=ckt;\\n        }\\n        for(int i=0;i<n;i++){\\n            cout<<prefix[i]<<\" \";\\n        }\\n        cout<<endl;\\n        for(int i=0;i<n;i++){\\n            cout<<suffix[i]<<\" \";\\n        }\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            int sum=prefix[i]+suffix[i]-1;\\n            if(prefix[i]!=1 && suffix[i]!=1) maxi=max(maxi,sum);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3047278,
                "title": "two-python-solution-with-o-n-time-o-n-space-and-second-with-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        # n = len(arr)\\n        # incre, decre = [0]* n, [0]*n\\n\\n        # for i in range(1, n):\\n        #     if arr[i] > arr[i-1]:\\n        #         incre[i] = incre[i-1] + 1\\n\\n        # for i in range(n-1)[::-1]:\\n        #     if arr[i] > arr[i+1]:\\n        #         decre[i] = decre[i+1] + 1\\n        # maxi = 0   \\n        # for i in range(1, n):\\n        #     if incre[i] and decre[i]:\\n        #         maxi = max(maxi, incre[i] + decre[i] + 1)\\n        # return maxi\\n        # if len(arr) < 3:\\n        #     return 0\\n\\n        # In constant O(1) space\\n        incre,decre,ans = 0,0,0\\n        for i in range(1, len(arr)):\\n            if (decre and arr[i-1] < arr[i]) or arr[i-1] == arr[i]:\\n                incre,decre = 0, 0\\n            incre += arr[i-1] < arr[i]\\n            decre += arr[i-1] > arr[i]\\n\\n            if incre  and decre:\\n                ans = max(ans, incre + decre + 1)\\n        return ans    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        # n = len(arr)\\n        # incre, decre = [0]* n, [0]*n\\n\\n        # for i in range(1, n):\\n        #     if arr[i] > arr[i-1]:\\n        #         incre[i] = incre[i-1] + 1\\n\\n        # for i in range(n-1)[::-1]:\\n        #     if arr[i] > arr[i+1]:\\n        #         decre[i] = decre[i+1] + 1\\n        # maxi = 0   \\n        # for i in range(1, n):\\n        #     if incre[i] and decre[i]:\\n        #         maxi = max(maxi, incre[i] + decre[i] + 1)\\n        # return maxi\\n        # if len(arr) < 3:\\n        #     return 0\\n\\n        # In constant O(1) space\\n        incre,decre,ans = 0,0,0\\n        for i in range(1, len(arr)):\\n            if (decre and arr[i-1] < arr[i]) or arr[i-1] == arr[i]:\\n                incre,decre = 0, 0\\n            incre += arr[i-1] < arr[i]\\n            decre += arr[i-1] > arr[i]\\n\\n            if incre  and decre:\\n                ans = max(ans, incre + decre + 1)\\n        return ans    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883947,
                "title": "java-without-using-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int n = arr.length;\\n        \\n        int ans= 0;\\n        for(int i =1;i<n-1;){\\n            if(arr[i-1]<arr[i] && arr[i]>arr[i+1]){\\n                int j=i;\\n                int count = 1;\\n                 while( j>0 && arr[j] > arr[j-1] ){ \\n// if your condition is  arr[j] > arr[j-1] && j>0,\\n// it\\'ll throw error cz it, first check code which \\n//are in first, so then arr[j-1] try to find and \\n//check the condition, so it\\'ll throw error \\n                    j--;\\n                    count++;\\n                }\\n                while( i < n-1 && arr[i] > arr[i+1] ){\\n                    i++;\\n                    count++;\\n                }\\n                ans = Math.max(count,ans);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int n = arr.length;\\n        \\n        int ans= 0;\\n        for(int i =1;i<n-1;){\\n            if(arr[i-1]<arr[i] && arr[i]>arr[i+1]){\\n                int j=i;\\n                int count = 1;\\n                 while( j>0 && arr[j] > arr[j-1] ){ \\n// if your condition is  arr[j] > arr[j-1] && j>0,\\n// it\\'ll throw error cz it, first check code which \\n//are in first, so then arr[j-1] try to find and \\n//check the condition, so it\\'ll throw error \\n                    j--;\\n                    count++;\\n                }\\n                while( i < n-1 && arr[i] > arr[i+1] ){\\n                    i++;\\n                    count++;\\n                }\\n                ans = Math.max(count,ans);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610920,
                "title": "c-fastest-submission-tc-o-n-sc-o-1-dp",
                "content": "TC: O(N)\\nSC: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        int i=0;\\n        int maxi=0;\\n        \\n        while(i<n){\\n            \\n            int up=1;\\n            //upside\\n            while(i+1<n && arr[i]<arr[i+1]){\\n                i++;\\n                up++;\\n            }\\n            \\n            int down=0;\\n            //downside\\n            while(i+1<n && arr[i]>arr[i+1]){\\n                i++;\\n                down++;\\n            }\\n            \\n\\t\\t\\t//check for valid mountain array\\n            if(up>1 && down >0){\\n                maxi= maxi < up + down ? up+down : maxi;\\n                    \\n            }\\n    \\t/*\\n\\t        if there is  down means the break point will be at arr[i] <= arr[i+1] in this case arr[i] \\n\\t\\t\\tcan be part of new mountrain array in upside so we will miss one element in further \\n\\t\\t\\tcreation . thats why if(down!=0) we will again start from same index i, else we can take\\n\\t\\t\\tnew i+1\\n\\t\\t*/\\n            if(down==0)\\n                i++;\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        int i=0;\\n        int maxi=0;\\n        \\n        while(i<n){\\n            \\n            int up=1;\\n            //upside\\n            while(i+1<n && arr[i]<arr[i+1]){\\n                i++;\\n                up++;\\n            }\\n            \\n            int down=0;\\n            //downside\\n            while(i+1<n && arr[i]>arr[i+1]){\\n                i++;\\n                down++;\\n            }\\n            \\n\\t\\t\\t//check for valid mountain array\\n            if(up>1 && down >0){\\n                maxi= maxi < up + down ? up+down : maxi;\\n                    \\n            }\\n    \\t/*\\n\\t        if there is  down means the break point will be at arr[i] <= arr[i+1] in this case arr[i] \\n\\t\\t\\tcan be part of new mountrain array in upside so we will miss one element in further \\n\\t\\t\\tcreation . thats why if(down!=0) we will again start from same index i, else we can take\\n\\t\\t\\tnew i+1\\n\\t\\t*/\\n            if(down==0)\\n                i++;\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588163,
                "title": "scan-left-then-right",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        \\n        int n = a.size();\\n        int i=1;\\n        \\n        int res = 0;\\n        while(i<n)\\n        {\\n            while(i<n && a[i]==a[i-1])\\n                i++;\\n            \\n            int up=0;\\n            while(i<n && a[i]>a[i-1]){\\n                up++;\\n                i++;\\n            }\\n            \\n            int down=0;\\n            while(i<n && a[i]<a[i-1])\\n            {\\n                down++;\\n                i++;    \\n            }\\n            \\n            if(down && up)\\n            {\\n                res = max(res,up+down+1);\\n            }\\n            \\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        \\n        int n = a.size();\\n        int i=1;\\n        \\n        int res = 0;\\n        while(i<n)\\n        {\\n            while(i<n && a[i]==a[i-1])\\n                i++;\\n            \\n            int up=0;\\n            while(i<n && a[i]>a[i-1]){\\n                up++;\\n                i++;\\n            }\\n            \\n            int down=0;\\n            while(i<n && a[i]<a[i-1])\\n            {\\n                down++;\\n                i++;    \\n            }\\n            \\n            if(down && up)\\n            {\\n                res = max(res,up+down+1);\\n            }\\n            \\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549874,
                "title": "python-easy-to-understand-dp",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        dp = [0] * len(arr)\\n        for i in range(1, len(arr)):\\n            if arr[i] > arr[i-1]:\\n                dp[i] = dp[i-1] + 1\\n        print(dp)\\n        dp2 = [0] * len(arr)\\n        for i in range(len(arr)-2, -1, -1):\\n            if arr[i] > arr[i+1]:\\n                dp2[i] = dp2[i+1] + 1\\n        print(dp2)\\n        res = 0\\n        for i in range(len(arr)):\\n            if dp[i] > 0 and dp2[i] > 0:\\n                res = max(res, dp[i] + dp2[i] + 1)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        dp = [0] * len(arr)\\n        for i in range(1, len(arr)):\\n            if arr[i] > arr[i-1]:\\n                dp[i] = dp[i-1] + 1\\n        print(dp)\\n        dp2 = [0] * len(arr)\\n        for i in range(len(arr)-2, -1, -1):\\n            if arr[i] > arr[i+1]:\\n                dp2[i] = dp2[i+1] + 1\\n        print(dp2)\\n        res = 0\\n        for i in range(len(arr)):\\n            if dp[i] > 0 and dp2[i] > 0:\\n                res = max(res, dp[i] + dp2[i] + 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522458,
                "title": "c-easy-short-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/8b9f5a80-42ca-4be7-b3d2-568d3395eeb9_1662187875.807191.png)\\n\\n**T->O(n) &&& S->O(n)**\\n\\n***This question is the extension of longest Bitonic/Mountain subsequence. In that we compare with all the prevoius elements and store the max on dp[i] but since we want a consecutive Subsequence that we just have compare with the last element. Rest of the code is same as finding the longest mountain subsequence!***\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint longestMountain(vector<int>& arr) {\\n\\t\\t\\tint n=arr.size();\\n\\t\\t\\tvector<int> dp1(n,1),dp2(n,1),sum(n,0);\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tif(arr[i]>arr[i-1] && 1+dp1[i-1]>dp1[i]) dp1[i]=1+dp1[i-1];\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=n-2;i>=0;i--){\\n\\t\\t\\t\\tif(arr[i]>arr[i+1] && 1+dp2[i+1]>dp2[i]) dp2[i]=1+dp2[i+1];\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(dp1[i]!=1 && dp2[i]!=1) sum[i]=dp1[i]+dp2[i];\\n\\t\\t\\t}  \\n\\t\\t\\tint ans=*max_element(sum.begin(),sum.end());\\n\\t\\t\\tif(ans) ans-=1;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint longestMountain(vector<int>& arr) {\\n\\t\\t\\tint n=arr.size();\\n\\t\\t\\tvector<int> dp1(n,1),dp2(n,1),sum(n,0);\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tif(arr[i]>arr[i-1] && 1+dp1[i-1]>dp1[i]) dp1[i]=1+dp1[i-1];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2509007,
                "title": "java-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        // if (arr.length < 3) return 0;\\n\\n        int maxLength = 0, i = 0;\\n        boolean uphill = false, downhill = false;\\n\\n        while (i < arr.length - 1) {\\n            if (arr[i] < arr[i + 1]) {\\n                int start = i;\\n\\n                while (i < arr.length - 1 && arr[i] < arr[i + 1]) {\\n                    i++;\\n                    uphill = true;\\n                }\\n\\n                while (i < arr.length - 1 && arr[i] > arr[i + 1]) {\\n                    i++;\\n                    downhill = true;\\n                }\\n\\n                if (uphill && downhill) {\\n                    maxLength = Math.max(maxLength, i - start + 1);\\n                }\\n\\n                uphill = downhill = false;\\n\\t\\t\\t\\t\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        // if (arr.length < 3) return 0;\\n\\n        int maxLength = 0, i = 0;\\n        boolean uphill = false, downhill = false;\\n\\n        while (i < arr.length - 1) {\\n            if (arr[i] < arr[i + 1]) {\\n                int start = i;\\n\\n                while (i < arr.length - 1 && arr[i] < arr[i + 1]) {\\n                    i++;\\n                    uphill = true;\\n                }\\n\\n                while (i < arr.length - 1 && arr[i] > arr[i + 1]) {\\n                    i++;\\n                    downhill = true;\\n                }\\n\\n                if (uphill && downhill) {\\n                    maxLength = Math.max(maxLength, i - start + 1);\\n                }\\n\\n                uphill = downhill = false;\\n\\t\\t\\t\\t\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461948,
                "title": "python-2-pass-dp-solution",
                "content": "```\\ndp1 is the forward increasing subarry ending at index i (left of mountain)\\ndp2 is the backward increasing subarry ending at index i (right of mountain)\\nThe length of moutain as peak at index i is dp1[i]+dp2[i]-1\\n```\\n\\n```\\ndef longestMountain(self, nums: List[int]) -> int:\\n\\tdp1 = [1]+[0]*(len(nums)-1)\\n\\tfor i in range(1, len(nums)):\\n\\t\\tif nums[i-1]<nums[i]:\\n\\t\\t\\tdp1[i] = dp1[i-1]+1\\n\\t\\telse:\\n\\t\\t\\tdp1[i] = 1\\n\\tdp2 = [0]*(len(nums)-1)+[1]\\n\\tfor i in range(len(nums)-2, -1, -1):\\n\\t\\tif nums[i]>nums[i+1]:\\n\\t\\t\\tdp2[i] = dp2[i+1]+1\\n\\t\\telse:\\n\\t\\t\\tdp2[i] = 1\\n\\tans = max([dp1[i]+dp2[i]-1 for i in range(1, len(nums)-1) if dp1[i]>1 and dp2[i]>1] or [0]) \\n\\treturn ans if ans>=3 else 0\\n```",
                "solutionTags": [],
                "code": "```\\ndp1 is the forward increasing subarry ending at index i (left of mountain)\\ndp2 is the backward increasing subarry ending at index i (right of mountain)\\nThe length of moutain as peak at index i is dp1[i]+dp2[i]-1\\n```\n```\\ndef longestMountain(self, nums: List[int]) -> int:\\n\\tdp1 = [1]+[0]*(len(nums)-1)\\n\\tfor i in range(1, len(nums)):\\n\\t\\tif nums[i-1]<nums[i]:\\n\\t\\t\\tdp1[i] = dp1[i-1]+1\\n\\t\\telse:\\n\\t\\t\\tdp1[i] = 1\\n\\tdp2 = [0]*(len(nums)-1)+[1]\\n\\tfor i in range(len(nums)-2, -1, -1):\\n\\t\\tif nums[i]>nums[i+1]:\\n\\t\\t\\tdp2[i] = dp2[i+1]+1\\n\\t\\telse:\\n\\t\\t\\tdp2[i] = 1\\n\\tans = max([dp1[i]+dp2[i]-1 for i in range(1, len(nums)-1) if dp1[i]>1 and dp2[i]>1] or [0]) \\n\\treturn ans if ans>=3 else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2452384,
                "title": "c-highly-commented-code-o-n-time-and-o-1-space",
                "content": "For complexity analysis and other stuff, go [here](https://garmadon.notion.site/Longest-Bitonic-Subarray-76cd76ecd7464f4da5c1d61382d8c1e8).\\n\\n```\\n//works successfully on leetcode!\\n\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n\\n    //constraint given in the question\\n    if(arr.size() < 3)\\n        return 0;\\n        \\n    //start travelling from the beginning of the array\\n    int traveller = 0;\\n    int mountainStart, mountainPeak, mountainLength=0; //answer will be 0 when no mountain exists\\n\\n    //travel till the end of the array\\n    while(traveller < arr.size())\\n    {\\n        //set the starting point of the current mountain \\n        mountainStart = traveller;\\n\\n        //climb the mountain (if an ascending slope exists)\\n        while(traveller + 1 < arr.size() and arr.at(traveller) < arr.at(traveller+1))\\n        {\\n            traveller++;\\n        }\\n\\n        //if there was a descending slope, the traveller would be standing at the same place\\n        //hence start travelling from the next step\\n        if(traveller == mountainStart)\\n        {\\n            traveller++;\\n            continue;\\n        }\\n\\n        //traveller is now standing on the mountain peak\\n        mountainPeak = traveller;\\n\\n        //climb down the mountain (if an descending slope exists)\\n        while(traveller + 1 < arr.size() and arr.at(traveller) > arr.at(traveller+1))\\n        {\\n            traveller++;\\n        }\\n\\n        //if it\\'s a plain surface the traveller must not have moved\\n        //so take one step ahead and start finding the mountain again\\n        if(traveller == mountainPeak)\\n        {\\n            traveller++;\\n            continue;\\n        }\\n\\n        //Find the longest mountain throughout the trip\\n        mountainLength = max(mountainLength, traveller - mountainStart + 1);\\n    }\\n\\n    return mountainLength;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//works successfully on leetcode!\\n\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n\\n    //constraint given in the question\\n    if(arr.size() < 3)\\n        return 0;\\n        \\n    //start travelling from the beginning of the array\\n    int traveller = 0;\\n    int mountainStart, mountainPeak, mountainLength=0; //answer will be 0 when no mountain exists\\n\\n    //travel till the end of the array\\n    while(traveller < arr.size())\\n    {\\n        //set the starting point of the current mountain \\n        mountainStart = traveller;\\n\\n        //climb the mountain (if an ascending slope exists)\\n        while(traveller + 1 < arr.size() and arr.at(traveller) < arr.at(traveller+1))\\n        {\\n            traveller++;\\n        }\\n\\n        //if there was a descending slope, the traveller would be standing at the same place\\n        //hence start travelling from the next step\\n        if(traveller == mountainStart)\\n        {\\n            traveller++;\\n            continue;\\n        }\\n\\n        //traveller is now standing on the mountain peak\\n        mountainPeak = traveller;\\n\\n        //climb down the mountain (if an descending slope exists)\\n        while(traveller + 1 < arr.size() and arr.at(traveller) > arr.at(traveller+1))\\n        {\\n            traveller++;\\n        }\\n\\n        //if it\\'s a plain surface the traveller must not have moved\\n        //so take one step ahead and start finding the mountain again\\n        if(traveller == mountainPeak)\\n        {\\n            traveller++;\\n            continue;\\n        }\\n\\n        //Find the longest mountain throughout the trip\\n        mountainLength = max(mountainLength, traveller - mountainStart + 1);\\n    }\\n\\n    return mountainLength;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430580,
                "title": "one-pass-o-1-space-jugad",
                "content": "```\\nint longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n<3) return 0;\\n        int longest = 0;\\n        bool check = false;\\n        int len = 0;\\n        if(arr[1]>arr[0])   check = true;\\n        for(int i=0;i<n;i++) {\\n            if(i!=0&&arr[i]==arr[i-1])   {\\n                check = false;\\n                len = 0;\\n            }\\n            if(i!=0&&i!=n-1&&arr[i-1]>=arr[i]&&arr[i+1]>=arr[i]) {\\n                len++;\\n                longest = max(longest,len);\\n                len = 1;\\n                check = true;\\n            }\\n            else if(check)  len++;\\n            \\n        }\\n        if(arr[n-1]<arr[n-2])   longest = max(longest,len);\\n        return longest>=3?longest:0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n<3) return 0;\\n        int longest = 0;\\n        bool check = false;\\n        int len = 0;\\n        if(arr[1]>arr[0])   check = true;\\n        for(int i=0;i<n;i++) {\\n            if(i!=0&&arr[i]==arr[i-1])   {\\n                check = false;\\n                len = 0;\\n            }\\n            if(i!=0&&i!=n-1&&arr[i-1]>=arr[i]&&arr[i+1]>=arr[i]) {\\n                len++;\\n                longest = max(longest,len);\\n                len = 1;\\n                check = true;\\n            }\\n            else if(check)  len++;\\n            \\n        }\\n        if(arr[n-1]<arr[n-2])   longest = max(longest,len);\\n        return longest>=3?longest:0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2421729,
                "title": "java-one-pass-tc-o-n-sc-o-1-2-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        \\n        int maxLen = 0, count = 1; //coz we included 1st element\\n        boolean inc = false, dsc = false; //maintain if we first increased and then decreased\\n        \\n        int i = 1;\\n        \\n        while (i < arr.length) {\\n            \\n            inc = false; dsc = false;\\n            count = 1;\\n \\n            //increasing\\n            while (i < arr.length && arr[i] > arr[i-1]) {\\n                count++;\\n                i++;\\n                inc = true;\\n            }\\n            \\n            //decreasing, we will calculate only when we have increased flg is true\\n            while (inc && i < arr.length && arr[i] < arr[i-1]) {\\n                count++;\\n                i++;\\n                dsc = true;\\n            }\\n            \\n            //if values increased and decreased\\n            if (inc && dsc) {\\n                maxLen = Math.max(maxLen, count);\\n                count= 1;\\n                \\n            }else i++;\\n            \\n        }\\n        return maxLen>=3 ? maxLen : 0;     \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        \\n        int maxLen = 0, count = 1; //coz we included 1st element\\n        boolean inc = false, dsc = false; //maintain if we first increased and then decreased\\n        \\n        int i = 1;\\n        \\n        while (i < arr.length) {\\n            \\n            inc = false; dsc = false;\\n            count = 1;\\n \\n            //increasing\\n            while (i < arr.length && arr[i] > arr[i-1]) {\\n                count++;\\n                i++;\\n                inc = true;\\n            }\\n            \\n            //decreasing, we will calculate only when we have increased flg is true\\n            while (inc && i < arr.length && arr[i] < arr[i-1]) {\\n                count++;\\n                i++;\\n                dsc = true;\\n            }\\n            \\n            //if values increased and decreased\\n            if (inc && dsc) {\\n                maxLen = Math.max(maxLen, count);\\n                count= 1;\\n                \\n            }else i++;\\n            \\n        }\\n        return maxLen>=3 ? maxLen : 0;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323939,
                "title": "c-easy-to-understand",
                "content": "```\\nint longestMountain(vector<int>& arr) {\\n       \\n        int n = arr.size();\\n        int i=1, lgst=0;\\n        \\n        while(i<n-1){\\n            \\n            if(arr[i] > arr[i-1] and arr[i] > arr[i+1]){ //peak found\\n                \\n                int j = i, cnt = 1;\\n                \\n                while(j>0 and arr[j-1] < arr[j]) cnt++, j--; //ele on left of peak\\n                \\n                while(i<n-1 and arr[i] > arr[i+1]) i++, cnt++; //ele on right of peak\\n                \\n                lgst = max(lgst, cnt);\\n            }\\n            else \\n                i++;      \\n        }\\n        \\n        return lgst; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint longestMountain(vector<int>& arr) {\\n       \\n        int n = arr.size();\\n        int i=1, lgst=0;\\n        \\n        while(i<n-1){\\n            \\n            if(arr[i] > arr[i-1] and arr[i] > arr[i+1]){ //peak found\\n                \\n                int j = i, cnt = 1;\\n                \\n                while(j>0 and arr[j-1] < arr[j]) cnt++, j--; //ele on left of peak\\n                \\n                while(i<n-1 and arr[i] > arr[i+1]) i++, cnt++; //ele on right of peak\\n                \\n                lgst = max(lgst, cnt);\\n            }\\n            else \\n                i++;      \\n        }\\n        \\n        return lgst; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2309853,
                "title": "c-solution-dp",
                "content": "```\\n   int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>left(n,1),right(n,1);\\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]<arr[i]){\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]){\\n                right[i]=right[i+1]+1;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(left[i]>1 && right[i]>1){\\n                ans = max(ans,right[i]+left[i]-1);\\n            }\\n        }\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n   int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>left(n,1),right(n,1);\\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]<arr[i]){\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]){\\n                right[i]=right[i+1]+1;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(left[i]>1 && right[i]>1){\\n                ans = max(ans,right[i]+left[i]-1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2307197,
                "title": "java-3-ms-easy-to-understand-code",
                "content": "class Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        if(A==null || A.length<3) return result;\\n        int i = 1;\\n        int start = 0;\\n        boolean upHill = false;\\n        boolean downHill = false;\\n        while(i<A.length){\\n            start = i-1;\\n            //go uphill\\n            while(i<A.length && A[i-1]<A[i]){\\n                upHill=true;\\n                i++;\\n            }\\n            //go downhill\\n            while(i<A.length && A[i-1]>A[i]){\\n                downHill=true;\\n                i++;\\n            }\\n\\t\\t\\t\\n            //if found uphill and downhill then there was mountain \\n            if(upHill && downHill){\\n                //only update when mountain size was equal or greater than 3\\n                if(i-start>=3)result = Math.max(i-start,result);\\n            }else{\\n                //if there was no mountain, then ensuring it\\'s not plain surface\\n                while(i<A.length && A[i-1]==A[i])i++;\\n            }\\n            \\n            //update uphill and downhill for next iteration.\\n            upHill = false;\\n            downHill = false;\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        if(A==null || A.length<3) return result;\\n        int i = 1;\\n        int start = 0;\\n        boolean upHill = false;\\n        boolean downHill = false;\\n        while(i<A.length){\\n            start = i-1;\\n            //go uphill\\n            while(i<A.length && A[i-1]<A[i]){\\n                upHill=true;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2289642,
                "title": "simple-c-code-o-n",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> LISFront(n,1);\\n        vector<int> LISBack(n,1);\\n        int i = 1, j = n-2;\\n        for(int i = 1; i < n; i++)\\n        {\\n            int snd = 1;\\n            if(nums[i-1]< nums[i])\\n            {\\n                snd = max(snd, LISFront[i-1]+1);\\n            }\\n            LISFront[i] = snd;\\n            snd = 1;\\n            if(nums[j+1] < nums[j])\\n            {\\n                snd = max(snd, LISBack[j+1]+1);\\n            }\\n            LISBack[j] = snd;\\n            j--;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(LISBack[i] == 1 || LISFront[i] == 1) continue;\\n            ans = max(ans, LISBack[i]+LISFront[i]-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> LISFront(n,1);\\n        vector<int> LISBack(n,1);\\n        int i = 1, j = n-2;\\n        for(int i = 1; i < n; i++)\\n        {\\n            int snd = 1;\\n            if(nums[i-1]< nums[i])\\n            {\\n                snd = max(snd, LISFront[i-1]+1);\\n            }\\n            LISFront[i] = snd;\\n            snd = 1;\\n            if(nums[j+1] < nums[j])\\n            {\\n                snd = max(snd, LISBack[j+1]+1);\\n            }\\n            LISBack[j] = snd;\\n            j--;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(LISBack[i] == 1 || LISFront[i] == 1) continue;\\n            ans = max(ans, LISBack[i]+LISFront[i]-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247437,
                "title": "c-simple-solution-time-o-n-space-o-1-beats-99",
                "content": "```\\n    int longestMountain(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        int ans = 0, cnt = 0;\\n        for (int l = 1; l < n - 1; l++)\\n        {\\n            if (arr[l] > arr[l - 1] && arr[l] > arr[l + 1])\\n            {\\n\\n                int j = l - 1, k = l + 1;\\n                cnt = 3;\\n                while (j - 1 >= 0 && arr[j] > arr[j - 1])\\n                    j--, cnt++;\\n                while (k + 1 < n && arr[k] > arr[k + 1])\\n                    k++, cnt++;\\n                ans = max(ans, cnt);\\n                l=k-1;\\n            }\\n          \\n        }\\n\\n        ans = max(ans, cnt);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    int longestMountain(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        int ans = 0, cnt = 0;\\n        for (int l = 1; l < n - 1; l++)\\n        {\\n            if (arr[l] > arr[l - 1] && arr[l] > arr[l + 1])\\n            {\\n\\n                int j = l - 1, k = l + 1;\\n                cnt = 3;\\n                while (j - 1 >= 0 && arr[j] > arr[j - 1])\\n                    j--, cnt++;\\n                while (k + 1 < n && arr[k] > arr[k + 1])\\n                    k++, cnt++;\\n                ans = max(ans, cnt);\\n                l=k-1;\\n            }\\n          \\n        }\\n\\n        ans = max(ans, cnt);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246185,
                "title": "c-simple-colution-prefix-suffic-technique",
                "content": "```\\n int longestMountain(vector<int>& arr) {\\n        \\n        int i,j,maxi=0,n=arr.size();\\n        int inc[n],dec[n];\\n        inc[0] = 0;\\n        dec[n-1] = 0;\\n        for(i=1;i<n;i++)\\n        {\\n            if(arr[i]>arr[i-1])\\n            {\\n                inc[i]  = inc[i-1] + 1;\\n            }\\n            else{\\n                inc[i]  = 0;\\n            }\\n        }\\n        for(i=n-2;i>=0;i--)\\n        {\\n            if(arr[i]>arr[i+1])\\n            {\\n                dec[i] = dec[i+1] + 1;\\n            }\\n            else{\\n                dec[i] = 0;\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(inc[i]!=0 && dec[i]!=0)\\n            {\\n                maxi = max(maxi,inc[i] + dec[i]+1);\\n            }\\n           \\n        }\\n        if(maxi<3)\\n        {\\n            return 0;\\n        }\\n        else{\\n            \\n            return maxi;\\n        }\\n",
                "solutionTags": [
                    "Suffix Array"
                ],
                "code": "```\\n int longestMountain(vector<int>& arr) {\\n        \\n        int i,j,maxi=0,n=arr.size();\\n        int inc[n],dec[n];\\n        inc[0] = 0;\\n        dec[n-1] = 0;\\n        for(i=1;i<n;i++)\\n        {\\n            if(arr[i]>arr[i-1])\\n            {\\n                inc[i]  = inc[i-1] + 1;\\n            }\\n            else{\\n                inc[i]  = 0;\\n            }\\n        }\\n        for(i=n-2;i>=0;i--)\\n        {\\n            if(arr[i]>arr[i+1])\\n            {\\n                dec[i] = dec[i+1] + 1;\\n            }\\n            else{\\n                dec[i] = 0;\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(inc[i]!=0 && dec[i]!=0)\\n            {\\n                maxi = max(maxi,inc[i] + dec[i]+1);\\n            }\\n           \\n        }\\n        if(maxi<3)\\n        {\\n            return 0;\\n        }\\n        else{\\n            \\n            return maxi;\\n        }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2069011,
                "title": "easy-c-commented-o-n-solution-in-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // ic 1 means we are looking for increasing sequence ic 0 means we are looking for decreasing sequence\\n        \\n// intially we want increasing sequence starting form i=0\\n        int ic=1,l=1,a=0;          \\n        for(int i=1;i<arr.size();i++){\\n            if(arr[i]>arr[i-1]){   // numbers in increasing sequence\\n                if(ic==1)l++;   // if we were looking for incresing then we found another number to add to our answer\\n                else{\\n                    \\n/*\\n\\n\\n         /\\\\\\n        /  \\\\  /\\n            \\\\/\\n             this point here marks the end of mountain\\n             what this means is that we were hoping this number to be less than the previous  one\\n\\t\\t\\t but we found it greater than the prevoius one. \\n\\t\\t\\t this marks the end of our  current mountain and start of new mountain\\n*/\\n                  a=max(a,l); \\n                    l=2;\\n                    ic=1;\\n                }\\n            }else if(arr[i]<arr[i-1]){\\n                if(ic==0)l++,a=max(a,l);\\n                else{\\n/*\\n\\n\\n          /\\\\\\n         /  this point here marks the peak of the mountain.\\n            we wanted to continue going up hill but instead we found a slope.\\n            this makes this a mountain we check if this suitable( max ) answer and then we continue hoping to go downhill.\\n            \\n            \\\\                                               /\\\\\\n              this is not a peak                           this is a peak\\n                            we need atleast 3 numbers including current one \\n*/     \\n                    \\n                    \\n                    \\n                    if(l>1)l++,ic=0,a=max(a,l);\\n                    else l=1,ic=1;\\n                     \\n                }\\n            }else{\\n                l=1;\\n                ic=1;\\n            }\\n            \\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // ic 1 means we are looking for increasing sequence ic 0 means we are looking for decreasing sequence\\n        \\n// intially we want increasing sequence starting form i=0\\n        int ic=1,l=1,a=0;          \\n        for(int i=1;i<arr.size();i++){\\n            if(arr[i]>arr[i-1]){   // numbers in increasing sequence\\n                if(ic==1)l++;   // if we were looking for incresing then we found another number to add to our answer\\n                else{\\n                    \\n/*\\n\\n\\n         /\\\\\\n        /  \\\\  /\\n            \\\\/\\n             this point here marks the end of mountain\\n             what this means is that we were hoping this number to be less than the previous  one\\n\\t\\t\\t but we found it greater than the prevoius one. \\n\\t\\t\\t this marks the end of our  current mountain and start of new mountain\\n*/\\n                  a=max(a,l); \\n                    l=2;\\n                    ic=1;\\n                }\\n            }else if(arr[i]<arr[i-1]){\\n                if(ic==0)l++,a=max(a,l);\\n                else{\\n/*\\n\\n\\n          /\\\\\\n         /  this point here marks the peak of the mountain.\\n            we wanted to continue going up hill but instead we found a slope.\\n            this makes this a mountain we check if this suitable( max ) answer and then we continue hoping to go downhill.\\n            \\n            \\\\                                               /\\\\\\n              this is not a peak                           this is a peak\\n                            we need atleast 3 numbers including current one \\n*/     \\n                    \\n                    \\n                    \\n                    if(l>1)l++,ic=0,a=max(a,l);\\n                    else l=1,ic=1;\\n                     \\n                }\\n            }else{\\n                l=1;\\n                ic=1;\\n            }\\n            \\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007291,
                "title": "preprocessing-left-and-right-monotonicity-simple",
                "content": "```\\nint longestMountain(vector<int>& arr) {\\n    int n = arr.size();\\n    vector<int>left_inc(n, 0);\\n    vector<int>right_inc(n, 0);\\n    int ans = INT_MIN;\\n    \\n    for(int i=1;i<n;i++)\\n        if(arr[i] > arr[i-1])\\n            left_inc[i] = 1 + left_inc[i-1];\\n    \\n    for(int i=(n-2);i>=0;i--)\\n        if(arr[i] > arr[i+1])\\n            right_inc[i] = 1 + right_inc[i+1];        \\n    \\n    for(int i=0;i<n;i++)\\n        if(left_inc[i]>0 && right_inc[i]>0)\\n            ans = max(ans, (left_inc[i]+right_inc[i]));\\n    \\n    if(ans!=INT_MIN)\\n        return ans+1;\\n    else\\n        return 0;\\n    \\n}",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint longestMountain(vector<int>& arr) {\\n    int n = arr.size();\\n    vector<int>left_inc(n, 0);\\n    vector<int>right_inc(n, 0);\\n    int ans = INT_MIN;\\n    \\n    for(int i=1;i<n;i++)\\n        if(arr[i] > arr[i-1])\\n            left_inc[i] = 1 + left_inc[i-1];\\n    \\n    for(int i=(n-2);i>=0;i--)\\n        if(arr[i] > arr[i+1])\\n            right_inc[i] = 1 + right_inc[i+1];        \\n    \\n    for(int i=0;i<n;i++)\\n        if(left_inc[i]>0 && right_inc[i]>0)\\n            ans = max(ans, (left_inc[i]+right_inc[i]));\\n    \\n    if(ans!=INT_MIN)\\n        return ans+1;\\n    else\\n        return 0;\\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1971664,
                "title": "c-very-easy-simple-solution",
                "content": "\\tpublic:\\n\\t\\tint longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        vector<int>left_inc(n, 0);\\n        vector<int>right_inc(n, 0);\\n        int ans = INT_MIN;\\n        \\n        for(int i=1;i<n;i++)\\n            if(arr[i] > arr[i-1])\\n                left_inc[i] = 1 + left_inc[i-1];\\n        \\n        for(int i=(n-2);i>=0;i--)\\n            if(arr[i] > arr[i+1])\\n                right_inc[i] = 1 + right_inc[i+1];\\n        \\n        for(int i=0;i<n;i++)\\n            if(left_inc[i]>0 && right_inc[i]>0)\\n                ans = max(ans, (left_inc[i]+right_inc[i]));\\n        \\n        if(ans!=INT_MIN)\\n            return ans+1;\\n        else\\n            return 0;\\n        \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tpublic:\\n\\t\\tint longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        vector<int>left_inc(n, 0);\\n        vector<int>right_inc(n, 0);\\n        int ans = INT_MIN;\\n        \\n        for(int i=1;i<n;i++)\\n            if(arr[i] > arr[i-1])\\n                left_inc[i] = 1 + left_inc[i-1];\\n        \\n        for(int i=(n-2);i>=0;i--)\\n            if(arr[i] > arr[i+1])\\n                right_inc[i] = 1 + right_inc[i+1];\\n        \\n        for(int i=0;i<n;i++)\\n            if(left_inc[i]>0 && right_inc[i]>0)\\n                ans = max(ans, (left_inc[i]+right_inc[i]));\\n        \\n        if(ans!=INT_MIN)\\n            return ans+1;\\n        else\\n            return 0;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1956860,
                "title": "java-1-pass-o-1-space-easy-to-understand",
                "content": "We will look for the peak and will expand to both sides from there till we reach bottom of the mountain. Once a mountain has been found, look for the peak of the next moutain and expand from there and so on.\\n\\n```\\n public int longestMountain(int[] arr) {\\n        int longest = 0; // longest Mountain\\n        for (int i = 1; i < arr.length - 1; ) {\\n            if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) { // peak of the current mountain starts from here. Will expand from here to both side just like HIMALAYAS\\n                int k = i - 1;\\n                int j = i + 1;\\n                while (k > 0 && arr[k] > arr[k - 1]) {\\n                    k--;\\n                }\\n                // reached left bottom of the mountain\\n                while (j < arr.length - 1 && arr[j] > arr[j + 1]) {\\n                    j++;\\n                }\\n                // reached right bottom of the mountain\\n                longest = Math.max(longest, j - k + 1); // compare current mountain length with the longest\\n                i = j + 1;  // look for next moutain peak from two index after the right bottom of the current mountain\\n            } else\\n                i++;\\n        }\\n        return longest;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int longestMountain(int[] arr) {\\n        int longest = 0; // longest Mountain\\n        for (int i = 1; i < arr.length - 1; ) {\\n            if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) { // peak of the current mountain starts from here. Will expand from here to both side just like HIMALAYAS\\n                int k = i - 1;\\n                int j = i + 1;\\n                while (k > 0 && arr[k] > arr[k - 1]) {\\n                    k--;\\n                }\\n                // reached left bottom of the mountain\\n                while (j < arr.length - 1 && arr[j] > arr[j + 1]) {\\n                    j++;\\n                }\\n                // reached right bottom of the mountain\\n                longest = Math.max(longest, j - k + 1); // compare current mountain length with the longest\\n                i = j + 1;  // look for next moutain peak from two index after the right bottom of the current mountain\\n            } else\\n                i++;\\n        }\\n        return longest;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903129,
                "title": "longest-mountain-in-array",
                "content": "```\\n**# CHECK FOR THE ELEMENT WHICH IS GREATER THAN FROM IT\\'S RIGHT AND LEFT BOTH. (NUMS[I-1]<NUMS[I] && NUMS[I]>NUMS[I+1])\\n# IF THIS CONDITION IS CORRECT CHECK ALL ITS LEFT TILL THEY FOLLOW DECREASING ORDER \\n# SIMILIARLY CHECK ALL IT\\'S RIGHT TILL THEY FOLLOW DECREASING ORDER AS WELL.\\n# AFTER GETTING THE INDEX\\'S TILL THEY ARE FOLLOWING DECREASING ORDER FROM LEFT AND RIGHT\\n# (CONSIDERING BOUNDRY SHOULD NOT VOILETED) =>FIND MAX IF ANY MOUNTAIN HAS BEEN FOUND BEFORE AND NOW. ANS=MAX(ANS,RIGHT-LEFT+1)\\n# THANK YOU.\\n# PLEASE UPVOTE IF YOU FIND IT HELPFUL**\\n```\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int res=0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i-1]<nums[i] && nums[i]>nums[i+1])\\n            {\\n                int j=i;\\n                int k=i;\\n                while(j>0)\\n                {\\n                    if(nums[j]>nums[j-1])\\n                        j--;\\n                    else\\n                        break;\\n                }\\n                while(k<n-1)\\n                {\\n                    if(nums[k]>nums[k+1])\\n                        k++;\\n                    else\\n                        break;\\n                }\\n                res=max(res,k-j+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n**# CHECK FOR THE ELEMENT WHICH IS GREATER THAN FROM IT\\'S RIGHT AND LEFT BOTH. (NUMS[I-1]<NUMS[I] && NUMS[I]>NUMS[I+1])\\n# IF THIS CONDITION IS CORRECT CHECK ALL ITS LEFT TILL THEY FOLLOW DECREASING ORDER \\n# SIMILIARLY CHECK ALL IT\\'S RIGHT TILL THEY FOLLOW DECREASING ORDER AS WELL.\\n# AFTER GETTING THE INDEX\\'S TILL THEY ARE FOLLOWING DECREASING ORDER FROM LEFT AND RIGHT\\n# (CONSIDERING BOUNDRY SHOULD NOT VOILETED) =>FIND MAX IF ANY MOUNTAIN HAS BEEN FOUND BEFORE AND NOW. ANS=MAX(ANS,RIGHT-LEFT+1)\\n# THANK YOU.\\n# PLEASE UPVOTE IF YOU FIND IT HELPFUL**\\n```\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int res=0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i-1]<nums[i] && nums[i]>nums[i+1])\\n            {\\n                int j=i;\\n                int k=i;\\n                while(j>0)\\n                {\\n                    if(nums[j]>nums[j-1])\\n                        j--;\\n                    else\\n                        break;\\n                }\\n                while(k<n-1)\\n                {\\n                    if(nums[k]>nums[k+1])\\n                        k++;\\n                    else\\n                        break;\\n                }\\n                res=max(res,k-j+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819288,
                "title": "c-easy-implementation",
                "content": "```\\n int longestMountain(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n        int res=0;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(arr[i]>arr[i-1]&&arr[i]>arr[i+1])\\n            {\\n                int start=i;\\n                int end=i;\\n                \\n                while(start>0&&arr[start]>arr[start-1])\\n                    start--;\\n                while(end<n-1&&arr[end]>arr[end+1])\\n                    end++;\\n                res=max(res, end-start+1);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int longestMountain(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n        int res=0;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(arr[i]>arr[i-1]&&arr[i]>arr[i+1])\\n            {\\n                int start=i;\\n                int end=i;\\n                \\n                while(start>0&&arr[start]>arr[start-1])\\n                    start--;\\n                while(end<n-1&&arr[end]>arr[end+1])\\n                    end++;\\n                res=max(res, end-start+1);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1816679,
                "title": "java-two-solutions-with-extra-space-using-array-and-without-extra-space-using-two-pointers",
                "content": "```\\n// brute force\\n// from each index find the longest decreasing sequence starting from that index toward left , and find the longest  continuous  decreasing sequence starting from that index to the right, TC O(n) , space complexity O(n)\\n//Runtime: 3 ms, faster than 73.85% of Java online submissions for Longest Mountain in Array.\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length < 3){\\n            return 0;\\n        }\\n        int n = arr.length;\\n        int[] decr = new int[n];\\n        // no decreasing number from the 0-index\\n        decr[0] = 0;\\n        int count = 0;\\n        for(int i=1; i< n ; i++){\\n            if(arr[i] <= arr[i-1]){\\n\\t\\t\\t  // this mean there can not be  continuous decreasing sequence  starting from this i-th index\\n                count =0;\\n                decr[i] = 0;\\n                continue;\\n            }\\n             count++;\\n            decr[i] = count;\\n        }\\n        \\n        count = 0;\\n        int res = Integer.MIN_VALUE;\\n        for(int i=n-2; i>=0  ; i--){\\n            if(arr[i] <= arr[i+1]){\\n\\t\\t\\t//  this mean there can not be  continuous increasing sequence  starting from this i-th index\\n                count =0;\\n                continue;\\n            }\\n            count++;\\n            if(decr[i] >0){\\n\\t\\t\\t// update res only if there was at least one decreasing number , add 1 to cover the number at i-th index it self\\n              res = Math.max(res, count + decr[i]+1); \\n            }\\n        \\n        }\\n        \\n        return Math.max(res, 0);\\n    }\\n}\\n```\\n\\n// solution without extra space\\n// the idea is to find all the continuous increasing sequence from the i-th index  untill we reach the peak element for the sequence, after we found the peak element , we just need to count all the continous decreasing sequence starting from the peak element, we just need to be sure that at least we have 2 elements, TC O(n) since each element will be visited at most two times, and SC O(1)\\n```\\n\\n//Runtime: 2 ms, faster than 94.44% of Java online submissions for Longest Mountain in Array.\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length < 3){\\n            return 0;\\n        }\\n        int res = 0,  left = 0;\\n        int i =0;\\n        while( i< arr.length){\\n            int incr = 0;\\n            while( i + 1 < arr.length && arr[i] < arr[i+1]){\\n                incr++;\\n                i++;\\n            }\\n            if(incr == 0){\\n                i++;\\n                continue;\\n            }\\n            int decr = 0;\\n            while( i + 1 < arr.length && arr[i] > arr[i+1]){\\n                decr++;\\n                i++;\\n            }\\n            if(decr == 0){\\n                continue;\\n            }\\n\\n            res = Math.max(res, incr + decr + 1);\\n\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n// brute force\\n// from each index find the longest decreasing sequence starting from that index toward left , and find the longest  continuous  decreasing sequence starting from that index to the right, TC O(n) , space complexity O(n)\\n//Runtime: 3 ms, faster than 73.85% of Java online submissions for Longest Mountain in Array.\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length < 3){\\n            return 0;\\n        }\\n        int n = arr.length;\\n        int[] decr = new int[n];\\n        // no decreasing number from the 0-index\\n        decr[0] = 0;\\n        int count = 0;\\n        for(int i=1; i< n ; i++){\\n            if(arr[i] <= arr[i-1]){\\n\\t\\t\\t  // this mean there can not be  continuous decreasing sequence  starting from this i-th index\\n                count =0;\\n                decr[i] = 0;\\n                continue;\\n            }\\n             count++;\\n            decr[i] = count;\\n        }\\n        \\n        count = 0;\\n        int res = Integer.MIN_VALUE;\\n        for(int i=n-2; i>=0  ; i--){\\n            if(arr[i] <= arr[i+1]){\\n\\t\\t\\t//  this mean there can not be  continuous increasing sequence  starting from this i-th index\\n                count =0;\\n                continue;\\n            }\\n            count++;\\n            if(decr[i] >0){\\n\\t\\t\\t// update res only if there was at least one decreasing number , add 1 to cover the number at i-th index it self\\n              res = Math.max(res, count + decr[i]+1); \\n            }\\n        \\n        }\\n        \\n        return Math.max(res, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792146,
                "title": "easy-beginners-friendly-approach-java",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int largest = 0;\\n        int n=a.length;\\n        for(int i=1;i<n-1;){\\n            //for founding the peaks\\n            if(a[i]>a[i-1] && a[i]>a[i+1]){\\n                int count =1;\\n                int j=i;\\n                //for count in the backwards\\n                while(j>=1 && a[j]>a[j-1]){\\n                    j--;\\n                    count++;\\n                }\\n                 //for count in the forwards\\n                while(i<n-1 && a[i]>a[i+1]){\\n                    i++;\\n                    count++;\\n                }\\n                //checking if it is the largest peak;\\n                largest = Math.max(largest,count);\\n            }\\n            else\\n                i++;\\n        }\\n        return largest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int largest = 0;\\n        int n=a.length;\\n        for(int i=1;i<n-1;){\\n            //for founding the peaks\\n            if(a[i]>a[i-1] && a[i]>a[i+1]){\\n                int count =1;\\n                int j=i;\\n                //for count in the backwards\\n                while(j>=1 && a[j]>a[j-1]){\\n                    j--;\\n                    count++;\\n                }\\n                 //for count in the forwards\\n                while(i<n-1 && a[i]>a[i+1]){\\n                    i++;\\n                    count++;\\n                }\\n                //checking if it is the largest peak;\\n                largest = Math.max(largest,count);\\n            }\\n            else\\n                i++;\\n        }\\n        return largest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785329,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        int largest=0;\\n        for(int i=1;i<=n-2;){\\n            if(arr[i]>arr[i-1] and arr[i]>arr[i+1]){\\n                \\n                int cnt=1;\\n                int j=i;\\n                \\n                //backward count\\n                while(j>=1 and arr[j]>arr[j-1]){\\n                    cnt++;\\n                    j--;\\n                }\\n                \\n                //forward direction\\n                \\n                while(i<=n-2 and arr[i]>arr[i+1]){\\n                    cnt++;\\n                    i++;\\n                }\\n                \\n                 largest=max(largest,cnt);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return largest;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        int largest=0;\\n        for(int i=1;i<=n-2;){\\n            if(arr[i]>arr[i-1] and arr[i]>arr[i+1]){\\n                \\n                int cnt=1;\\n                int j=i;\\n                \\n                //backward count\\n                while(j>=1 and arr[j]>arr[j-1]){\\n                    cnt++;\\n                    j--;\\n                }\\n                \\n                //forward direction\\n                \\n                while(i<=n-2 and arr[i]>arr[i+1]){\\n                    cnt++;\\n                    i++;\\n                }\\n                \\n                 largest=max(largest,cnt);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return largest;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745280,
                "title": "c-o-n-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int i = 0, j = 0, ans = 0, x = 1;\\n        while(j<n)\\n        {\\n            if(j<n-1 && arr[j]<arr[j+1])\\n            {\\n               while(j<n-1 && arr[j] < arr[j+1])\\n               {\\n                    x++;\\n                    j++;\\n               }\\n                int y = x;\\n               while(j<n-1 && arr[j] > arr[j+1])\\n               {\\n                   x++;\\n                   j++;\\n               }\\n                if(y == x)\\n                    x = 0;\\n            }\\n            else\\n                 j++;\\n           ans = max(ans, x);\\n           x = 1;\\n        }\\n        return ans == 1?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int i = 0, j = 0, ans = 0, x = 1;\\n        while(j<n)\\n        {\\n            if(j<n-1 && arr[j]<arr[j+1])\\n            {\\n               while(j<n-1 && arr[j] < arr[j+1])\\n               {\\n                    x++;\\n                    j++;\\n               }\\n                int y = x;\\n               while(j<n-1 && arr[j] > arr[j+1])\\n               {\\n                   x++;\\n                   j++;\\n               }\\n                if(y == x)\\n                    x = 0;\\n            }\\n            else\\n                 j++;\\n           ans = max(ans, x);\\n           x = 1;\\n        }\\n        return ans == 1?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727552,
                "title": "simple-java-solution-100-faster",
                "content": "**Upvote if you Got It** \\uD83D\\uDE42 \\nclass Solution {\\n\\n    public int longestMountain(int[] arr) {\\n        int s = 0;\\n        for(int i=1;i<arr.length-1;i++) {\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]) {\\n                int j=i,tem=1;\\n                while(j>0 && arr[j]>arr[j-1]){\\n                    j--;tem++;\\n                }\\n                j=i;\\n                while(j<arr.length-1 && arr[j]>arr[j+1]) {\\n                    j++;tem++;\\n                }\\n                s=Math.max(s,tem);\\n                i=j;\\n            }\\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int longestMountain(int[] arr) {\\n        int s = 0;\\n        for(int i=1;i<arr.length-1;i++) {\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]) {\\n                int j=i,tem=1;\\n                while(j>0 && arr[j]>arr[j-1]){\\n                    j--;tem++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1715077,
                "title": "c-1-pass-o-1-space-two-pointer-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int low{0},res{0};\\n        for(int i=1;i<nums.size(); )\\n        {\\n            bool increasing{false},decreasing{false};\\n            while(i<nums.size() and nums[i]>nums[i-1] ) \\n            {\\n                increasing=true;\\n                i++;\\n            }\\n            while(i<nums.size() and nums[i]<nums[i-1] and increasing)\\n            {\\n                decreasing=true;\\n                i++;\\n            }\\n            if(increasing and decreasing)\\n            {\\n                res=max(res,(i-1)-low+1);\\n                low=i-1;\\n            }\\n            else\\n            {\\n                low=i;\\n                i++;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int low{0},res{0};\\n        for(int i=1;i<nums.size(); )\\n        {\\n            bool increasing{false},decreasing{false};\\n            while(i<nums.size() and nums[i]>nums[i-1] ) \\n            {\\n                increasing=true;\\n                i++;\\n            }\\n            while(i<nums.size() and nums[i]<nums[i-1] and increasing)\\n            {\\n                decreasing=true;\\n                i++;\\n            }\\n            if(increasing and decreasing)\\n            {\\n                res=max(res,(i-1)-low+1);\\n                low=i-1;\\n            }\\n            else\\n            {\\n                low=i;\\n                i++;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677513,
                "title": "python-o-n-time-o-1-space-solution-no-shortcuts-direct-solution",
                "content": "I am open to other solutions also. Kindly comment your ideas and PoVs. Thank you!\\n```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        maxlen = 0\\n        n = len( arr)\\n        maxi = 0\\n        tp = 0\\n        incFlag = 0\\n        decFlag = 0\\n        if n < 3:\\n            return 0\\n\\n        for i in range (2,n):\\n            prev = arr[i-1]    \\n            prevprev = arr[i-2]    \\n            # print( tp)\\n            if prevprev < prev and prev < arr[i]:\\n                if tp == 0:\\n                    tp = 2\\n                tp += 1\\n                incFlag = 1\\n            elif decFlag != 1 and prevprev < prev and prev > arr[i]:\\n                if incFlag == 0:\\n                    incFlag = 1\\n                    tp += 2\\n                tp += 1\\n                decFlag = 1\\n                # if incFlag == 1 and decFlag == 1:\\n                maxlen = max( maxlen, tp)\\n            elif incFlag == 1 and decFlag == 1 and prevprev > prev and prev > arr[i]:\\n                tp += 1\\n                # decFlag = 1\\n                # if incFlag == 1 and decFlag == 1:\\n                maxlen = max( maxlen, tp)\\n            else:\\n                incFlag = 0\\n                decFlag = 0\\n                tp = 0\\n            print( tp)\\n        return maxlen\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        maxlen = 0\\n        n = len( arr)\\n        maxi = 0\\n        tp = 0\\n        incFlag = 0\\n        decFlag = 0\\n        if n < 3:\\n            return 0\\n\\n        for i in range (2,n):\\n            prev = arr[i-1]    \\n            prevprev = arr[i-2]    \\n            # print( tp)\\n            if prevprev < prev and prev < arr[i]:\\n                if tp == 0:\\n                    tp = 2\\n                tp += 1\\n                incFlag = 1\\n            elif decFlag != 1 and prevprev < prev and prev > arr[i]:\\n                if incFlag == 0:\\n                    incFlag = 1\\n                    tp += 2\\n                tp += 1\\n                decFlag = 1\\n                # if incFlag == 1 and decFlag == 1:\\n                maxlen = max( maxlen, tp)\\n            elif incFlag == 1 and decFlag == 1 and prevprev > prev and prev > arr[i]:\\n                tp += 1\\n                # decFlag = 1\\n                # if incFlag == 1 and decFlag == 1:\\n                maxlen = max( maxlen, tp)\\n            else:\\n                incFlag = 0\\n                decFlag = 0\\n                tp = 0\\n            print( tp)\\n        return maxlen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672869,
                "title": "longest-mountain-in-array-c-code-without-dp-easy-approach",
                "content": "\\n\\n\\n\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int count,j,mx=0,n=arr.size();\\n        bool flag;\\n        for(int i=1;i<n;i++){\\n            j=i;\\n            count=1;\\n            flag=false;\\n            \\n            //increasing sequence\\n            while(j<n && arr[j]>arr[j-1]){\\n                count++;\\n                j++;\\n            }\\n            \\n            //decreasing sequence\\n            while(i!=j && j<n && arr[j]<arr[j-1]){\\n                count++;\\n                j++;\\n                flag=true;\\n            }\\n            \\n            //length is max or not\\n            if(i!=j && flag && count>=3){\\n                mx=max(mx,count);\\n                j--;\\n            }\\n            \\n            i=j;\\n        }\\n        return mx;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int count,j,mx=0,n=arr.size();\\n        bool flag;\\n        for(int i=1;i<n;i++){\\n            j=i;\\n            count=1;\\n            flag=false;\\n            \\n            //increasing sequence\\n            while(j<n && arr[j]>arr[j-1]){\\n                count++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1642862,
                "title": "clean-and-clearly-understandable-java-solution",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int res = 0;\\n        if(arr.length < 2) return 0;\\n        for(int i=1; i<arr.length-1;i++){\\n            boolean isPeak = false;\\n            if(arr[i] > arr[i-1] && arr[i] > arr[i+1]){\\n                isPeak = true;\\n            }\\n            if(isPeak){   \\n                int j =i-1;\\n                int currPeak = 1;\\n                while(j>=0 && arr[j+1]>arr[j]){\\n                    currPeak++;\\n                    j--;\\n                }\\n                j=i+1;\\n                while(j<arr.length && arr[j-1] > arr[j]){\\n                    currPeak++;\\n                    j++;\\n                }\\n                 res = Math.max(currPeak,res);\\n            }  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int res = 0;\\n        if(arr.length < 2) return 0;\\n        for(int i=1; i<arr.length-1;i++){\\n            boolean isPeak = false;\\n            if(arr[i] > arr[i-1] && arr[i] > arr[i+1]){\\n                isPeak = true;\\n            }\\n            if(isPeak){   \\n                int j =i-1;\\n                int currPeak = 1;\\n                while(j>=0 && arr[j+1]>arr[j]){\\n                    currPeak++;\\n                    j--;\\n                }\\n                j=i+1;\\n                while(j<arr.length && arr[j-1] > arr[j]){\\n                    currPeak++;\\n                    j++;\\n                }\\n                 res = Math.max(currPeak,res);\\n            }  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511677,
                "title": "java-o-n-pre-compute",
                "content": "1. For each index precompute number of contiguous minimum numbers on left and right side.\\n2. For each index i calcuate ans=left[i] + 1 + right[i] => if left[i] and right[i] is > 0.\\n\\n```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int n=a.length;\\n        int[] left=new int[n];\\n        for(int i=1; i<n; i++)\\n        {\\n            if(a[i]>a[i-1])\\n            {\\n                left[i]=left[i-1]+1;\\n            }\\n            else if(a[i]<a[i-1])\\n            {\\n                left[i]=0;\\n            }\\n        }\\n        int[] right=new int[n];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(a[i]>a[i+1])\\n            {\\n                right[i]=right[i+1]+1;\\n            }\\n            else if(a[i]<a[i+1])\\n            {\\n                right[i]=0;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(left[i]>0 && right[i]>0)\\n            {\\n                ans=Math.max(ans, left[i]+right[i]+1);   \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int n=a.length;\\n        int[] left=new int[n];\\n        for(int i=1; i<n; i++)\\n        {\\n            if(a[i]>a[i-1])\\n            {\\n                left[i]=left[i-1]+1;\\n            }\\n            else if(a[i]<a[i-1])\\n            {\\n                left[i]=0;\\n            }\\n        }\\n        int[] right=new int[n];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(a[i]>a[i+1])\\n            {\\n                right[i]=right[i+1]+1;\\n            }\\n            else if(a[i]<a[i+1])\\n            {\\n                right[i]=0;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(left[i]>0 && right[i]>0)\\n            {\\n                ans=Math.max(ans, left[i]+right[i]+1);   \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505656,
                "title": "prefix-suffix-array-simple-solution",
                "content": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        vector<int> pre(n,1);\\n        vector<int> suf(n,1);\\n\\n        int sol = INT_MIN;\\n\\n        for(int i=1;i<n;i++){\\n            \\n            if(nums[i-1]<nums[i]){\\n                \\n                pre[i]=pre[i-1]+1;\\n            }\\n        }\\n\\n        \\n        for(int i=n-2;i>=0;i--){\\n            \\n            if(nums[i+1]<nums[i]){\\n                \\n                suf[i]=suf[i+1]+1;\\n            }\\n            \\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(pre[i] > 1 && suf[i] > 1)\\n            {\\n                sol = max(sol , pre[i] + suf[i]-1);\\n            }\\n           \\n        }\\n        \\n        \\n        if(sol==INT_MIN){\\n            return 0;\\n        }\\n        \\n        else{\\n            return sol;\\n        }\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Suffix Array"
                ],
                "code": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        vector<int> pre(n,1);\\n        vector<int> suf(n,1);\\n\\n        int sol = INT_MIN;\\n\\n        for(int i=1;i<n;i++){\\n            \\n            if(nums[i-1]<nums[i]){\\n                \\n                pre[i]=pre[i-1]+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1504390,
                "title": "c-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        vector<int> dp(arr.size());\\n           vector<int> dp1(arr.size());\\n    \\n        for(int i=1;i<arr.size()-1;i++){\\n            if(arr[i-1]<arr[i]){\\n                dp[i]=dp[i-1]+1;\\n            }\\n        }\\n         for(int i=arr.size()-2;i>=1;i--){\\n            if(arr[i+1]<arr[i]){\\n                dp1[i]=dp1[i+1]+1;\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<dp.size();i++){\\n            if(dp[i]!=0&&dp1[i]!=0){\\n                ans=max(ans,dp[i]+dp1[i]+1);\\n            }\\n        }\\n        return ((ans==INT_MIN)?0:ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        vector<int> dp(arr.size());\\n           vector<int> dp1(arr.size());\\n    \\n        for(int i=1;i<arr.size()-1;i++){\\n            if(arr[i-1]<arr[i]){\\n                dp[i]=dp[i-1]+1;\\n            }\\n        }\\n         for(int i=arr.size()-2;i>=1;i--){\\n            if(arr[i+1]<arr[i]){\\n                dp1[i]=dp1[i+1]+1;\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<dp.size();i++){\\n            if(dp[i]!=0&&dp1[i]!=0){\\n                ans=max(ans,dp[i]+dp1[i]+1);\\n            }\\n        }\\n        return ((ans==INT_MIN)?0:ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426271,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int start = 0;\\n        int res = 0;\\n        \\n        while(start < arr.size())\\n        {\\n            int end = start; // init end to be the same position as start\\n            bool walked_up = false;\\n            bool walked_down = false;\\n            while(end + 1 < arr.size() && arr[end + 1] > arr[end]) // we can walk up if the next value is greater\\n            {\\n                walked_up = true; // we actually walked up.\\n                end++;\\n            }\\n            while(end + 1 < arr.size() && arr[end + 1] < arr[end]) // now we walk down\\n            {\\n                walked_down = true; // we actually walked down\\n                end++;\\n            }\\n            if (walked_up && walked_down) // it is only a valid mountain if we walked up and down.\\n            {\\n                res = max(res, end - start + 1);\\n            }\\n            start = max(end, start + 1); // the next index we look at is either the end of a mountain, or simply the next index.\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int start = 0;\\n        int res = 0;\\n        \\n        while(start < arr.size())\\n        {\\n            int end = start; // init end to be the same position as start\\n            bool walked_up = false;\\n            bool walked_down = false;\\n            while(end + 1 < arr.size() && arr[end + 1] > arr[end]) // we can walk up if the next value is greater\\n            {\\n                walked_up = true; // we actually walked up.\\n                end++;\\n            }\\n            while(end + 1 < arr.size() && arr[end + 1] < arr[end]) // now we walk down\\n            {\\n                walked_down = true; // we actually walked down\\n                end++;\\n            }\\n            if (walked_up && walked_down) // it is only a valid mountain if we walked up and down.\\n            {\\n                res = max(res, end - start + 1);\\n            }\\n            start = max(end, start + 1); // the next index we look at is either the end of a mountain, or simply the next index.\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419207,
                "title": "one-pass-93-speed",
                "content": "![image](https://assets.leetcode.com/users/images/d36ec6e4-bac9-427e-b67c-95b779bd8d16_1629623535.5961733.png)\\n```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        len_mountain = slope = 0\\n        start = -1\\n        arr.append(arr[-1])    # to trigger len_mountain check in the loop\\n        for i, (a, b) in enumerate(zip(arr, arr[1:])):\\n            if b > a:\\n                if slope < 1:\\n                    if slope == -1 and start > -1:\\n                        len_mountain = max(len_mountain, i + 1 - start)\\n                    start = i\\n                    slope = 1\\n            elif b < a:\\n                if slope == 1:\\n                    slope = -1\\n            else:\\n                if slope == -1:\\n                    if start > -1:\\n                        len_mountain = max(len_mountain, i + 1 - start)\\n                slope = 0\\n                start = -1\\n        return len_mountain\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        len_mountain = slope = 0\\n        start = -1\\n        arr.append(arr[-1])    # to trigger len_mountain check in the loop\\n        for i, (a, b) in enumerate(zip(arr, arr[1:])):\\n            if b > a:\\n                if slope < 1:\\n                    if slope == -1 and start > -1:\\n                        len_mountain = max(len_mountain, i + 1 - start)\\n                    start = i\\n                    slope = 1\\n            elif b < a:\\n                if slope == 1:\\n                    slope = -1\\n            else:\\n                if slope == -1:\\n                    if start > -1:\\n                        len_mountain = max(len_mountain, i + 1 - start)\\n                slope = 0\\n                start = -1\\n        return len_mountain\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409639,
                "title": "c-one-pass-o-n-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n<3) return 0;\\n        int lm = 0, m = 0;\\n        bool gu = false; // going up flag\\n        for(int i = 0; i < n-1; i++) {\\n            if(arr[i]<arr[i+1] && (gu || m==0)) { // going up the mountain at end of array\\n                m++;\\n                gu = true;\\n            } else if(arr[i]>arr[i+1] && (gu || m>0)) { // going down the mountain\\n                m++;\\n                gu = false;\\n                if(i==n-2) lm = max(lm,m); // end of mountain\\n            } else if(arr[i]<arr[i+1] && !gu && m>0) { // end of current mountain and start of probable new mountain\\n                lm = max(lm,m);\\n                m = 1;\\n                gu = true;\\n            } else { // interruption in current mountain (equal values)\\n                if(!gu) lm = max(lm,m); // counted as a mountain if descent had started\\n                m = 0;\\n                gu = false;\\n            }\\n        }\\n        return lm>=2 ? lm+1 : 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n<3) return 0;\\n        int lm = 0, m = 0;\\n        bool gu = false; // going up flag\\n        for(int i = 0; i < n-1; i++) {\\n            if(arr[i]<arr[i+1] && (gu || m==0)) { // going up the mountain at end of array\\n                m++;\\n                gu = true;\\n            } else if(arr[i]>arr[i+1] && (gu || m>0)) { // going down the mountain\\n                m++;\\n                gu = false;\\n                if(i==n-2) lm = max(lm,m); // end of mountain\\n            } else if(arr[i]<arr[i+1] && !gu && m>0) { // end of current mountain and start of probable new mountain\\n                lm = max(lm,m);\\n                m = 1;\\n                gu = true;\\n            } else { // interruption in current mountain (equal values)\\n                if(!gu) lm = max(lm,m); // counted as a mountain if descent had started\\n                m = 0;\\n                gu = false;\\n            }\\n        }\\n        return lm>=2 ? lm+1 : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382513,
                "title": "c-solution-12-ms-96-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    /* The logic behind this is until finding the peak value the array should be in \\n       strictly increasing order and after finding the peak the values should be in \\n       strictly decreasing order \\n    */\\n       int longestMountain(vector<int>& arr) {\\n        int start=0,end=1;\\n        int max_val=0;\\n        bool peak_found=false;\\n        while(end<arr.size()){\\n            if(arr[end]>arr[end-1] && !peak_found){\\n                if(end+1<arr.size() && arr[end]>arr[end+1]){ // checking for peak value\\n                   peak_found=true; \\n                }\\n            }\\n            else if(arr[end]<=arr[end-1] && !peak_found){\\n                start=end; // if value in decreasing order before finding peak shift start to end\\n            }\\n            else if(arr[end]>=arr[end-1] && peak_found){\\n                max_val=max(max_val,end-start);//if value in increasing order after finding the peak  calculate the maxlength shift start to end-1                                                          \\n                start=end-1;\\n                peak_found=false;\\n                continue;\\n            }\\n            end++;\\n        }``\\n        if(peak_found){\\n            max_val=max(max_val,end-start);\\n        }\\n        return max_val;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    /* The logic behind this is until finding the peak value the array should be in \\n       strictly increasing order and after finding the peak the values should be in \\n       strictly decreasing order \\n    */\\n       int longestMountain(vector<int>& arr) {\\n        int start=0,end=1;\\n        int max_val=0;\\n        bool peak_found=false;\\n        while(end<arr.size()){\\n            if(arr[end]>arr[end-1] && !peak_found){\\n                if(end+1<arr.size() && arr[end]>arr[end+1]){ // checking for peak value\\n                   peak_found=true; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1356525,
                "title": "sum-of-lis-and-lds",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        \\n        lis=[0]*len(arr)\\n        \\n        for i in range(1,len(arr)):\\n            if arr[i-1]<arr[i]:\\n                lis[i]=lis[i-1]+1\\n            else:\\n                lis[i]=0\\n        \\n        lds=[0]*len(arr)\\n        \\n        for i in  range(len(arr)-2,-1,-1):\\n            if arr[i+1]<arr[i]:\\n                lds[i]=lds[i+1]+1\\n            else:\\n                lds[i]=0\\n        ans=0\\n        for i in range(1,len(arr)-1):\\n            if lis[i]!=0 and lds[i]!=0:\\n                ans=max(ans,lds[i]+lis[i])\\n        #print(lis)\\n        #print(lds)\\n        return ans+1 if ans!=0 else 0\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        \\n        lis=[0]*len(arr)\\n        \\n        for i in range(1,len(arr)):\\n            if arr[i-1]<arr[i]:\\n                lis[i]=lis[i-1]+1\\n            else:\\n                lis[i]=0\\n        \\n        lds=[0]*len(arr)\\n        \\n        for i in  range(len(arr)-2,-1,-1):\\n            if arr[i+1]<arr[i]:\\n                lds[i]=lds[i+1]+1\\n            else:\\n                lds[i]=0\\n        ans=0\\n        for i in range(1,len(arr)-1):\\n            if lis[i]!=0 and lds[i]!=0:\\n                ans=max(ans,lds[i]+lis[i])\\n        #print(lis)\\n        #print(lds)\\n        return ans+1 if ans!=0 else 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355415,
                "title": "java-single-pass",
                "content": "```\\npublic static int longestMountain(int[] arr) {\\n    int maxPeakLength = 0;\\n\\n\\tint i = 1;\\n\\twhile (i < arr.length) {\\n\\t\\t// Go on increasing(till mountain)\\n\\t\\tint increasingLength = increase(i, arr);\\n\\t\\tif (increasingLength == 0) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\ti = i + increasingLength;\\n\\t\\t\\n\\t\\t// Go on decreasing\\n\\t\\tint decreasingLength = decrease(i, arr);\\n\\t\\tif (decreasingLength == 0) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\ti = i + decreasingLength;\\n\\n\\t\\t// Added 1 because peak number is not counted in both increasingLength/decreasingLength.\\n\\t\\tint peakLength = increasingLength + decreasingLength + 1;\\n\\t\\tif (peakLength > maxPeakLength) {\\n\\t\\t\\tmaxPeakLength = peakLength;\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxPeakLength;\\n}\\n\\npublic static int increase(int index, int[] arr) {\\n\\tint initialValue = index;\\n\\twhile (index < arr.length && arr[index - 1] < arr[index]) {\\n\\t\\tindex++;\\n\\t}\\n\\n\\treturn index - initialValue;\\n}\\n\\npublic static int decrease(int index, int[] arr) {\\n\\tint initialValue = index;\\n\\twhile (index < arr.length && arr[index - 1] > arr[index]) {\\n\\t\\tindex++;\\n\\t}\\n\\n\\treturn index - initialValue;\\n}\\n```\\n\\nTime Complexity: O(n)",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic static int longestMountain(int[] arr) {\\n    int maxPeakLength = 0;\\n\\n\\tint i = 1;\\n\\twhile (i < arr.length) {\\n\\t\\t// Go on increasing(till mountain)\\n\\t\\tint increasingLength = increase(i, arr);\\n\\t\\tif (increasingLength == 0) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\ti = i + increasingLength;\\n\\t\\t\\n\\t\\t// Go on decreasing\\n\\t\\tint decreasingLength = decrease(i, arr);\\n\\t\\tif (decreasingLength == 0) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\ti = i + decreasingLength;\\n\\n\\t\\t// Added 1 because peak number is not counted in both increasingLength/decreasingLength.\\n\\t\\tint peakLength = increasingLength + decreasingLength + 1;\\n\\t\\tif (peakLength > maxPeakLength) {\\n\\t\\t\\tmaxPeakLength = peakLength;\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxPeakLength;\\n}\\n\\npublic static int increase(int index, int[] arr) {\\n\\tint initialValue = index;\\n\\twhile (index < arr.length && arr[index - 1] < arr[index]) {\\n\\t\\tindex++;\\n\\t}\\n\\n\\treturn index - initialValue;\\n}\\n\\npublic static int decrease(int index, int[] arr) {\\n\\tint initialValue = index;\\n\\twhile (index < arr.length && arr[index - 1] > arr[index]) {\\n\\t\\tindex++;\\n\\t}\\n\\n\\treturn index - initialValue;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1275264,
                "title": "python3-solution-with-no-if-operators-just-for-fun",
                "content": "```\\nclass State:\\n    def __init__(self):\\n        self.best = self.up = self.down = 0\\n        self.process_value = self.process_first\\n        self.process_up = self.process_just_up\\n        self.process_down = self.process_just_down\\n    def process_eq(self):\\n        self.up = self.down = 0\\n        self.process_up = self.process_just_up\\n        self.process_down = self.process_just_down\\n    def process_down_then_up(self):\\n        self.up = 1\\n        self.down = 0        \\n        self.process_down = self.process_up_then_down\\n        self.process_up = self.process_just_up\\n    def process_just_up(self):\\n        self.up += 1\\n        self.process_down = self.process_up_then_down\\n    def process_up_then_down(self):\\n        self.down += 1\\n        self.best = max(self.best, self.up+self.down+1)\\n        self.process_up = self.process_down_then_up\\n    def process_just_down(self):\\n        pass\\n    def process_first(self, v):\\n        self.prev = v\\n        self.process_value = self.process_next\\n    def process_next(self, v):\\n        p =  self.prev\\n        self.prev = v\\n        [self.process_down,self.process_eq,self.process_up][int(v>p)+1-int(v<p)]()\\n    def get_result(self):\\n        return self.best\\n        \\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        S = State()\\n        for v in arr: S.process_value(v)\\n        return S.get_result()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass State:\\n    def __init__(self):\\n        self.best = self.up = self.down = 0\\n        self.process_value = self.process_first\\n        self.process_up = self.process_just_up\\n        self.process_down = self.process_just_down\\n    def process_eq(self):\\n        self.up = self.down = 0\\n        self.process_up = self.process_just_up\\n        self.process_down = self.process_just_down\\n    def process_down_then_up(self):\\n        self.up = 1\\n        self.down = 0        \\n        self.process_down = self.process_up_then_down\\n        self.process_up = self.process_just_up\\n    def process_just_up(self):\\n        self.up += 1\\n        self.process_down = self.process_up_then_down\\n    def process_up_then_down(self):\\n        self.down += 1\\n        self.best = max(self.best, self.up+self.down+1)\\n        self.process_up = self.process_down_then_up\\n    def process_just_down(self):\\n        pass\\n    def process_first(self, v):\\n        self.prev = v\\n        self.process_value = self.process_next\\n    def process_next(self, v):\\n        p =  self.prev\\n        self.prev = v\\n        [self.process_down,self.process_eq,self.process_up][int(v>p)+1-int(v<p)]()\\n    def get_result(self):\\n        return self.best\\n        \\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        S = State()\\n        for v in arr: S.process_value(v)\\n        return S.get_result()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265918,
                "title": "cpp-time-o-n-space-o-1-single-pass-exactly-n-operations",
                "content": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        if(arr.size()<3)\\n            return 0;\\n        //find all the peak\\n        int left =1;\\n        int max =0;\\n        for(int i=1;i<arr.size()-1;){\\n            //skip 1st downhill/plateau\\n            if(i==1)\\n            while(i<=arr.size()-1 && arr[i]<=arr[i-1]){\\n                i++;\\n            }\\n            //check if  peak and count downhill\\n            if(i<arr.size()-1 && arr[i]>arr[i-1]&&arr[i]>arr[i+1]){\\n                int right =0;\\n                i++;\\n                while(i<=arr.size()-1 &&arr[i]<arr[i-1]){\\n                    right++;\\n                    i++;\\n                }\\n                if(max<left+right+1)\\n                    max = left+right+1;\\n                //reset left\\n                left =1;  \\n            }\\n            //check uphill till peak\\n            else{\\n                if(i<=arr.size()-1 && arr[i]>arr[i-1])\\n                left++;\\n                else\\n                    left =1;// reset for plateau\\n                i++;\\n            }\\n        }\\n        return max;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        if(arr.size()<3)\\n            return 0;\\n        //find all the peak\\n        int left =1;\\n        int max =0;\\n        for(int i=1;i<arr.size()-1;){\\n            //skip 1st downhill/plateau\\n            if(i==1)\\n            while(i<=arr.size()-1 && arr[i]<=arr[i-1]){\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1220179,
                "title": "c-time-o-n-space-o-1-modular-solution-proper-naming",
                "content": "```\\nclass Solution {\\npublic:\\n    int goLeft(int idx, vector<int>& arr, int n){\\n        int cc = 0;\\n        while(idx-1>=0 and arr[idx]>arr[idx-1])\\n            cc++,idx--;\\n        return cc;\\n    }\\n\\t\\n    int goRight(int idx, vector<int>& arr, int n){\\n        int cc = 0;\\n        while(idx+1<n and arr[idx]>arr[idx+1])\\n            cc++,idx++;\\n        return cc;\\n    }\\n\\t\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int ans = 0;\\n        for(int i=1; i<n-1; i++){\\n            int left = goLeft(i, arr, n);\\n            int right = goRight(i, arr, n);\\n            if(left>0 and right>0)\\n                ans = max(ans, left+right+1);\\n            i+=right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int goLeft(int idx, vector<int>& arr, int n){\\n        int cc = 0;\\n        while(idx-1>=0 and arr[idx]>arr[idx-1])\\n            cc++,idx--;\\n        return cc;\\n    }\\n\\t\\n    int goRight(int idx, vector<int>& arr, int n){\\n        int cc = 0;\\n        while(idx+1<n and arr[idx]>arr[idx+1])\\n            cc++,idx++;\\n        return cc;\\n    }\\n\\t\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int ans = 0;\\n        for(int i=1; i<n-1; i++){\\n            int left = goLeft(i, arr, n);\\n            int right = goRight(i, arr, n);\\n            if(left>0 and right>0)\\n                ans = max(ans, left+right+1);\\n            i+=right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195315,
                "title": "java-1ms-beats-100",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n\\n        int res = 0, start, j;\\n        boolean up=false,down=false;\\n\\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i] > arr[i - 1]) {\\n                start = i - 1;\\n                j = i-1;\\n\\n                while ((start + 1) < arr.length && arr[start] < arr[start + 1]) {\\n                    start++;\\n                    up = true;\\n                }\\n\\n                while ((start + 1) < arr.length && arr[start] > arr[start + 1]) {\\n                    start++;\\n                    down = true;\\n                }\\n\\n                if (up && down) {\\n                    res = Math.max(res, start - j + 1);\\n                }\\n                i = start;\\n                up = false;\\n                down = false;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n\\n        int res = 0, start, j;\\n        boolean up=false,down=false;\\n\\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i] > arr[i - 1]) {\\n                start = i - 1;\\n                j = i-1;\\n\\n                while ((start + 1) < arr.length && arr[start] < arr[start + 1]) {\\n                    start++;\\n                    up = true;\\n                }\\n\\n                while ((start + 1) < arr.length && arr[start] > arr[start + 1]) {\\n                    start++;\\n                    down = true;\\n                }\\n\\n                if (up && down) {\\n                    res = Math.max(res, start - j + 1);\\n                }\\n                i = start;\\n                up = false;\\n                down = false;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181214,
                "title": "c-one-pass-space-complexity-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int j = 0;\\n        int i = 0;\\n        int n = arr.size();\\n        int ans = 0;\\n        while(j<n)\\n        {\\n            j = i;\\n            if(j+1<n && arr[j+1]>arr[j])\\n            {\\n                while(j+1<n && arr[j+1]>arr[j])\\n                {\\n                    j++;\\n                }\\n                if(j+1<n && arr[j]>arr[j+1])\\n                {\\n                    while(j+1<n && arr[j]>arr[j+1])\\n                    {\\n                        j++;\\n                    }\\n                    ans = max(ans,j-i+1);\\n                }\\n            }\\n            i = max(i+1,j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int j = 0;\\n        int i = 0;\\n        int n = arr.size();\\n        int ans = 0;\\n        while(j<n)\\n        {\\n            j = i;\\n            if(j+1<n && arr[j+1]>arr[j])\\n            {\\n                while(j+1<n && arr[j+1]>arr[j])\\n                {\\n                    j++;\\n                }\\n                if(j+1<n && arr[j]>arr[j+1])\\n                {\\n                    while(j+1<n && arr[j]>arr[j+1])\\n                    {\\n                        j++;\\n                    }\\n                    ans = max(ans,j-i+1);\\n                }\\n            }\\n            i = max(i+1,j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176112,
                "title": "one-pass-space-complexity-o-1",
                "content": "A simple solution to keep track of rising and going down with a boolean flag and solving it using in one single pass\\nThere are three scenarios which can happen when we are traversing the array\\n\\n```\\n\\npublic int longestMountain(int[] arr) {\\n\\tint max = 0;\\n\\n\\tint increaseStart = Integer.MAX_VALUE;\\n\\tboolean increase = false;\\n\\n\\tfor (int i = 1; i < arr.length; i++) {\\n\\t\\tif (arr[i] >= arr[i - 1] && !increase) { //Mountain has started to ascend. Hence we need to mark the mountain start with variables increaseStart.\\n\\t\\t\\tincreaseStart = i - 1;\\n\\t\\t\\tincrease = true;\\n\\t\\t}\\n\\t\\tif (arr[i] == arr[i - 1]) {\\n\\t\\t\\tincreaseStart = Integer.MAX_VALUE;//If the mountain remains flat then ignore the previous mountain start, as by definition it has to be strictly increasing.\\n\\t\\t\\tincrease = false;\\n\\t\\t}\\n\\n\\t\\tif (arr[i] < arr[i - 1]) {\\n\\t\\t\\tincrease = false; //The mountain is decending hence continously mark our mountain length and check with our max.\\n\\t\\t\\tmax = Math.max(max, i - increaseStart + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn max;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic int longestMountain(int[] arr) {\\n\\tint max = 0;\\n\\n\\tint increaseStart = Integer.MAX_VALUE;\\n\\tboolean increase = false;\\n\\n\\tfor (int i = 1; i < arr.length; i++) {\\n\\t\\tif (arr[i] >= arr[i - 1] && !increase) { //Mountain has started to ascend. Hence we need to mark the mountain start with variables increaseStart.\\n\\t\\t\\tincreaseStart = i - 1;\\n\\t\\t\\tincrease = true;\\n\\t\\t}\\n\\t\\tif (arr[i] == arr[i - 1]) {\\n\\t\\t\\tincreaseStart = Integer.MAX_VALUE;//If the mountain remains flat then ignore the previous mountain start, as by definition it has to be strictly increasing.\\n\\t\\t\\tincrease = false;\\n\\t\\t}\\n\\n\\t\\tif (arr[i] < arr[i - 1]) {\\n\\t\\t\\tincrease = false; //The mountain is decending hence continously mark our mountain length and check with our max.\\n\\t\\t\\tmax = Math.max(max, i - increaseStart + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1123097,
                "title": "java-two-pointers-one-pass",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if (arr == null || arr.length == 0) return 0;\\n        int max = 0;\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            int left = i, right = i;\\n            if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {\\n                left--;\\n                right++;\\n                while (left >= 1 && arr[left] > arr[left - 1]) left--;\\n                while (right < arr.length - 1 && arr[right] > arr[right + 1]) right++;\\n                max = Math.max(max, right - left + 1);\\n            }\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int longestMountain(int[] arr) {\\n        if (arr == null || arr.length == 0) return 0;\\n        int max = 0;\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            int left = i, right = i;\\n            if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {\\n                left--;\\n                right++;\\n                while (left >= 1 && arr[left] > arr[left - 1]) left--;\\n                while (right < arr.length - 1 && arr[right] > arr[right + 1]) right++;\\n                max = Math.max(max, right - left + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1085155,
                "title": "java-linear-scan-o-n",
                "content": "The first approach came to mind immediately is expand from center, which will go to O(n^2).\\nAfter sumbitting I realized that there has to be an O(n) solution.\\n## Linear Scan, O(n)\\nI view a mountain as left-top-right.\\n```\\n    public int longestMountain(int[] arr) {\\n        int ans = 0;\\n        int left = 0;\\n        while (left < arr.length - 2) {\\n            int top = left;\\n            while (top + 1 < arr.length && arr[top + 1] > arr[top]) top++;\\n            int right = top;\\n            while (right + 1 < arr.length && arr[right + 1] < arr[right]) right++;\\n            if (left < top && top < right) ans = Math.max(ans, right - left + 1);\\n            left = Math.max(left + 1, right);\\n        }\\n        return ans;\\n    }\\n```\\n\\n## Expand From Center, O(n^2)\\n```\\n    public int longestMountain(int[] arr) {\\n        int ans = 0;\\n        for (int i = 0; i < arr.length; i++) ans = Math.max(ans, expandFromCenter(i, arr));\\n        return ans;\\n    }\\n\\n    private int expandFromCenter(int center, int[] a) {\\n        int left = center;\\n        int right = center;\\n        while (left - 1 >= 0 && a[left - 1] < a[left]) left--;\\n        while (right + 1 < a.length && a[right + 1] < a[right]) right++;\\n        return left == center || right == center ? 0 : right - left + 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestMountain(int[] arr) {\\n        int ans = 0;\\n        int left = 0;\\n        while (left < arr.length - 2) {\\n            int top = left;\\n            while (top + 1 < arr.length && arr[top + 1] > arr[top]) top++;\\n            int right = top;\\n            while (right + 1 < arr.length && arr[right + 1] < arr[right]) right++;\\n            if (left < top && top < right) ans = Math.max(ans, right - left + 1);\\n            left = Math.max(left + 1, right);\\n        }\\n        return ans;\\n    }\\n```\n```\\n    public int longestMountain(int[] arr) {\\n        int ans = 0;\\n        for (int i = 0; i < arr.length; i++) ans = Math.max(ans, expandFromCenter(i, arr));\\n        return ans;\\n    }\\n\\n    private int expandFromCenter(int center, int[] a) {\\n        int left = center;\\n        int right = center;\\n        while (left - 1 >= 0 && a[left - 1] < a[left]) left--;\\n        while (right + 1 < a.length && a[right + 1] < a[right]) right++;\\n        return left == center || right == center ? 0 : right - left + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 974108,
                "title": "python3-1-pass-o-1-space-solution-longest-mountain-in-array",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        ans, start = 0, None\\n        for i in range(1, len(A)):\\n            if A[i] > A[i-1] and (i == 1 or A[i-1] <= A[i-2]):\\n                start = i - 1\\n            elif A[i] == A[i-1]:\\n                start = None \\n            elif A[i] < A[i-1] and start is not None:\\n                ans = max(ans, i - start + 1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        ans, start = 0, None\\n        for i in range(1, len(A)):\\n            if A[i] > A[i-1] and (i == 1 or A[i-1] <= A[i-2]):\\n                start = i - 1\\n            elif A[i] == A[i-1]:\\n                start = None \\n            elif A[i] < A[i-1] and start is not None:\\n                ans = max(ans, i - start + 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955919,
                "title": "beats-99-41-of-people-c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int max=0,i=0;\\n        while(i<arr.size()-1){\\n           // cout<<i<<\" \";\\n            int x=i;\\n            bool a=true,b=true;\\n            while(x<arr.size()-1){\\n                if(arr[x]>=arr[x+1])\\n                    break;\\n                a=false;\\n                x++;\\n            }\\n            if(!a){\\n                while(x<arr.size()-1){\\n                    if(arr[x]<=arr[x+1])\\n                        break;\\n                    x++;\\n                    b=false;\\n                }\\n            }\\n            else\\n                x++;\\n            if(!b){\\n                   max = max<(x-i+1)?(x-i+1):max;\\n            }\\n            i=x;\\n \\n        }\\n        return max;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int max=0,i=0;\\n        while(i<arr.size()-1){\\n           // cout<<i<<\" \";\\n            int x=i;\\n            bool a=true,b=true;\\n            while(x<arr.size()-1){\\n                if(arr[x]>=arr[x+1])\\n                    break;\\n                a=false;\\n                x++;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 954738,
                "title": "java-dp-solution-by-traversing-from-both-ends-with-explanation",
                "content": "Step 1 : Create a dp1 array and store Length of increasing substring moving left to right.\\nStep 2 : Create a dp2 array and store Length of increasing substring moving right to left.\\nStep 3 : Find the Mountain combining both dp arrays.\\n\\nFeel free to ask questions.\\n\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length<3){\\n            return 0;\\n        }\\n        int dp1[] = new int[arr.length];\\n        int dp2[] = new int[arr.length];\\n        \\n        dp1[0]=0;\\n        for(int i=1; i<dp1.length; i++){\\n            if(arr[i]>arr[i-1]){\\n                dp1[i] = dp1[i-1] +1;\\n            }    \\n            else{\\n                dp1[i] = 0;\\n            }\\n        }\\n        dp2[dp2.length-1] = 0;\\n        \\n        for(int j=dp2.length-2; j>=0; j--){\\n            if(arr[j]>arr[j+1]){\\n                dp2[j]=dp2[j+1] + 1; \\n            }else{\\n                dp2[j] = 0;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(dp1[i]>0 && dp2[i]>0){\\n            {  \\n                ans = Math.max(ans, dp1[i] + dp2[i] + 1);\\n            }\\n          }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length<3){\\n            return 0;\\n        }\\n        int dp1[] = new int[arr.length];\\n        int dp2[] = new int[arr.length];\\n        \\n        dp1[0]=0;\\n        for(int i=1; i<dp1.length; i++){\\n            if(arr[i]>arr[i-1]){\\n                dp1[i] = dp1[i-1] +1;\\n            }    \\n            else{\\n                dp1[i] = 0;\\n            }\\n        }\\n        dp2[dp2.length-1] = 0;\\n        \\n        for(int j=dp2.length-2; j>=0; j--){\\n            if(arr[j]>arr[j+1]){\\n                dp2[j]=dp2[j+1] + 1; \\n            }else{\\n                dp2[j] = 0;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(dp1[i]>0 && dp2[i]>0){\\n            {  \\n                ans = Math.max(ans, dp1[i] + dp2[i] + 1);\\n            }\\n          }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947350,
                "title": "javascript-o-n-time-o-1-space-straight-forward-approach",
                "content": "```\\nfunction longestPeak(array) {\\n\\tlet maxLength = 0\\n\\tfor(let i = 1; i < array.length; i++) {\\n\\t\\tconst isPeak = array[i] > array[i - 1] && array[i] > array[i + 1]\\n    if(!isPeak) {\\n      continue\\n    }\\n\\n     let left = i - 1,\\n        right = i + 1;\\n    while(left >= 0 && array[left] > array[left - 1]) {\\n      left--\\n    }\\n\\n    while(right < array.length && array[right] > array[right + 1]) {\\n      right++\\n    }\\n\\n    maxLength = Math.max(maxLength, right - left + 1)\\n\\t\\t\\n\\t}\\n\\n  return maxLength\\n}",
                "solutionTags": [],
                "code": "```\\nfunction longestPeak(array) {\\n\\tlet maxLength = 0\\n\\tfor(let i = 1; i < array.length; i++) {\\n\\t\\tconst isPeak = array[i] > array[i - 1] && array[i] > array[i + 1]\\n    if(!isPeak) {\\n      continue\\n    }\\n\\n     let left = i - 1,\\n        right = i + 1;\\n    while(left >= 0 && array[left] > array[left - 1]) {\\n      left--\\n    }\\n\\n    while(right < array.length && array[right] > array[right + 1]) {\\n      right++\\n    }\\n\\n    maxLength = Math.max(maxLength, right - left + 1)\\n\\t\\t\\n\\t}\\n\\n  return maxLength\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 939845,
                "title": "java-one-pass-with-o-1-space",
                "content": "```\\n public int longestMountain(int[] A) {\\n        if (A == null || A.length == 0) return 0;\\n        int up = 0, down = 0, maxLen = 0;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] > A[i - 1]) {\\n                if (down != 0) {\\n                    down = 0;\\n                    up = 0;\\n                }\\n                up++;\\n            } else if (A[i] < A[i - 1]) {\\n                if (up != 0) {\\n                    down++;\\n                    maxLen = Math.max(maxLen, down + up + 1);\\n                }\\n            } else {\\n                up = 0;\\n                down = 0;\\n            }\\n        }\\n        return maxLen;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int longestMountain(int[] A) {\\n        if (A == null || A.length == 0) return 0;\\n        int up = 0, down = 0, maxLen = 0;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] > A[i - 1]) {\\n                if (down != 0) {\\n                    down = 0;\\n                    up = 0;\\n                }\\n                up++;\\n            } else if (A[i] < A[i - 1]) {\\n                if (up != 0) {\\n                    down++;\\n                    maxLen = Math.max(maxLen, down + up + 1);\\n                }\\n            } else {\\n                up = 0;\\n                down = 0;\\n            }\\n        }\\n        return maxLen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 938967,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int ans=0;\\n        \\n        int i=0;\\n        while(i<A.size())\\n        {\\n            int j=i+1;\\n            int temp_ans=0;\\n            \\n            while(j<A.size() && A[j]>A[j-1])\\n            {\\n                j++;\\n                temp_ans++;\\n            }\\n            \\n            if(j==i+1 || j==A.size())\\n            {\\n                i=j;\\n                continue;\\n            }\\n            int k = j;\\n            while(j<A.size() && A[j]<A[j-1])\\n            {\\n                temp_ans++;\\n                j++;\\n            }\\n            if(j==k)\\n            {\\n                i=j;\\n                continue;\\n            }\\n            ans = max(ans,temp_ans+1);\\n            i=j-1;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int ans=0;\\n        \\n        int i=0;\\n        while(i<A.size())\\n        {\\n            int j=i+1;\\n            int temp_ans=0;\\n            \\n            while(j<A.size() && A[j]>A[j-1])\\n            {\\n                j++;\\n                temp_ans++;\\n            }\\n            \\n            if(j==i+1 || j==A.size())\\n            {\\n                i=j;\\n                continue;\\n            }\\n            int k = j;\\n            while(j<A.size() && A[j]<A[j-1])\\n            {\\n                temp_ans++;\\n                j++;\\n            }\\n            if(j==k)\\n            {\\n                i=j;\\n                continue;\\n            }\\n            ans = max(ans,temp_ans+1);\\n            i=j-1;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938770,
                "title": "python3-solution-with-comment",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        res, n = 0, len(A)\\n\\t\\t\\n        if n < 3:  return 0\\n        \\n        for i in range(1, n-1):\\n\\t\\t\\t\\n\\t\\t\\t#if we find the peak, we start to count the length\\n            if A[i - 1] < A[i] > A[i + 1]:\\n\\t\\t\\t\\n\\t\\t\\t\\t#set up the left and right pointer\\n                l, r = i, i\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#left part and right part\\n                lcur, rcur = 0, 0\\n                \\n\\t\\t\\t\\t#count the length of left part\\n                while l != 0:\\n                    if A[l-1] < A[l]:\\n                        lcur += 1\\n                        l -= 1\\n                    else: \\n                        break\\n\\n\\t\\t\\t\\t#count the length of right part\\n                while r != n - 1:\\n                    if A[r] > A[r + 1]:\\n                        rcur += 1\\n                        r += 1\\n                    else: \\n                        break\\n                 \\n\\t\\t\\t\\t#do not forget to add the peak, so here the total length = (left part + right part + 1)\\n                res = max(res, lcur + rcur + 1)\\n        \\n        return res \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        res, n = 0, len(A)\\n\\t\\t\\n        if n < 3:  return 0\\n        \\n        for i in range(1, n-1):\\n\\t\\t\\t\\n\\t\\t\\t#if we find the peak, we start to count the length\\n            if A[i - 1] < A[i] > A[i + 1]:\\n\\t\\t\\t\\n\\t\\t\\t\\t#set up the left and right pointer\\n                l, r = i, i\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#left part and right part\\n                lcur, rcur = 0, 0\\n                \\n\\t\\t\\t\\t#count the length of left part\\n                while l != 0:\\n                    if A[l-1] < A[l]:\\n                        lcur += 1\\n                        l -= 1\\n                    else: \\n                        break\\n\\n\\t\\t\\t\\t#count the length of right part\\n                while r != n - 1:\\n                    if A[r] > A[r + 1]:\\n                        rcur += 1\\n                        r += 1\\n                    else: \\n                        break\\n                 \\n\\t\\t\\t\\t#do not forget to add the peak, so here the total length = (left part + right part + 1)\\n                res = max(res, lcur + rcur + 1)\\n        \\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 938498,
                "title": "longest-mountain-in-array-python-3",
                "content": "```\\n    def longestMountain(self, A: List[int]) -> int:\\n        lsize = 1\\n        rsize = 0\\n        mtnsize = 0\\n\\n        for idx in range(1, len(A)):\\n            if A[idx] > A[idx-1]:\\n                if rsize > 0:\\n                    mtnsize = max(mtnsize, lsize+rsize)\\n                    lsize = 1\\n                    rsize = 0\\n                lsize += 1\\n            elif lsize > 1 and A[idx] < A[idx-1]:\\n                rsize += 1\\n            else:\\n                if lsize > 1 and rsize >= 1:\\n                    mtnsize = max(mtnsize, lsize+rsize)\\n                lsize = 1\\n                rsize = 0\\n                    \\n        return max(mtnsize, lsize + rsize) if rsize > 0 else mtnsize\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def longestMountain(self, A: List[int]) -> int:\\n        lsize = 1\\n        rsize = 0\\n        mtnsize = 0\\n\\n        for idx in range(1, len(A)):\\n            if A[idx] > A[idx-1]:\\n                if rsize > 0:\\n                    mtnsize = max(mtnsize, lsize+rsize)\\n                    lsize = 1\\n                    rsize = 0\\n                lsize += 1\\n            elif lsize > 1 and A[idx] < A[idx-1]:\\n                rsize += 1\\n            else:\\n                if lsize > 1 and rsize >= 1:\\n                    mtnsize = max(mtnsize, lsize+rsize)\\n                lsize = 1\\n                rsize = 0\\n                    \\n        return max(mtnsize, lsize + rsize) if rsize > 0 else mtnsize\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 938198,
                "title": "java-clean-easy-to-understand-o-n-two-pass-solution",
                "content": "The idea is to check  if current index is a peak of mountain and then stretch to left and right to find the length of indexes included in this mountain.\\n**Upvote** if helpful :) \\n\\n``` \\npublic int longestMountain(int[] a) {\\n        int ans =0;\\n        if(a.length<3)\\n            return 0;\\n       for(int i=1;i<a.length-1;i++){\\n           if(a[i] > a[i-1] && a[i] > a[i+1]){  // Check if this index is a peak \\n             int left = leftDownHillLength(a,i-1);\\n             int right = rightDownHillLength(a,i+1);\\n             ans = Math.max(ans, 1+left+right);    \\n           }   \\n       }\\n       return ans; \\n    }\\n    \\n    \\n    public int leftDownHillLength(int[] a, int i){\\n        int count=0;\\n        while(i>=0 && a[i] < a[i+1]){\\n            count++;\\n            i--;\\n        }\\n        return count;\\n    }\\n    \\n    public int rightDownHillLength(int[] a, int i){\\n        int count=0;\\n        int n=a.length-1;\\n        while(i<=n && a[i-1] > a[i]){\\n            count++;\\n            i++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The idea is to check  if current index is a peak of mountain and then stretch to left and right to find the length of indexes included in this mountain.\\n**Upvote** if helpful :) \\n\\n``` \\npublic int longestMountain(int[] a) {\\n        int ans =0;\\n        if(a.length<3)\\n            return 0;\\n       for(int i=1;i<a.length-1;i++){\\n           if(a[i] > a[i-1] && a[i] > a[i+1]){  // Check if this index is a peak \\n             int left = leftDownHillLength(a,i-1);\\n             int right = rightDownHillLength(a,i+1);\\n             ans = Math.max(ans, 1+left+right);    \\n           }   \\n       }\\n       return ans; \\n    }\\n    \\n    \\n    public int leftDownHillLength(int[] a, int i){\\n        int count=0;\\n        while(i>=0 && a[i] < a[i+1]){\\n            count++;\\n            i--;\\n        }\\n        return count;\\n    }\\n    \\n    public int rightDownHillLength(int[] a, int i){\\n        int count=0;\\n        int n=a.length-1;\\n        while(i<=n && a[i-1] > a[i]){\\n            count++;\\n            i++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 938147,
                "title": "c-real-one-pass-no-extra-while-s",
                "content": "I see most solutions that claim to be one-pass contain actually a \"while\" inside the main \"for\". While complexity is still O(n) I think the code is more difficult to follow than this solution.\\nThe idea is very similar to this python solution which contains a nice explanation: https://leetcode.com/explore/featured/card/november-leetcoding-challenge/566/week-3-november-15th-november-21st/3533/discuss/937652/Python-one-pass-O(1)-space-explained\\n\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int ans = 0;\\n        for (int i = 1, left = 0, status = \\'flat\\'; i < A.size(); i++) {\\n            if (A[i] > A[i - 1]) {\\n                if (status == \\'desc\\' || status == \\'flat\\') left = i - 1, status = \\'asc\\';\\n            } else if (A[i] < A[i - 1]) {\\n                if (status == \\'asc\\' || status == \\'desc\\') ans = max(ans, i - left + 1), status = \\'desc\\';\\n            } else {\\n                status = \\'flat\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int ans = 0;\\n        for (int i = 1, left = 0, status = \\'flat\\'; i < A.size(); i++) {\\n            if (A[i] > A[i - 1]) {\\n                if (status == \\'desc\\' || status == \\'flat\\') left = i - 1, status = \\'asc\\';\\n            } else if (A[i] < A[i - 1]) {\\n                if (status == \\'asc\\' || status == \\'desc\\') ans = max(ans, i - left + 1), status = \\'desc\\';\\n            } else {\\n                status = \\'flat\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937955,
                "title": "easier-solution-faster-than-92-28-python-with-complete-explanation",
                "content": "Runtime: **156 ms**, faster than **92.28%** of Python3 online submissions. \\n\\n**Complete Explanation of code through comments**\\n```\\nclass Solution:\\n    def longestMountain(self, a: List[int]) -> int:\\n        n = len(a) \\n        ind = 0 \\n        max_dist = 0\\n        flag = False # to determine whether the array ends with upwards hill or downwards hill \\n        while ind < n-1:\\n            if a[ind] < a[ind+1]: #check whether its the starting point of mountain\\n                start = ind\\n                # loops till the peak of the mountain\\n                while ind<n-1 and a[ind]<a[ind+1]: \\n                    ind+=1 \\n                    flag = False\\n                # loops from the peak to the ending of the hill \\n                while ind<n-1 and a[ind]>a[ind+1]:\\n                    ind+=1 \\n                    flag = True\\n                if flag: # incase of termination of array check whether the hill is downwards\\n                    dist = ind-start+1 \\n                    max_dist = max(max_dist, dist) #compare\\n            else:\\n                ind+=1\\n        return max_dist        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, a: List[int]) -> int:\\n        n = len(a) \\n        ind = 0 \\n        max_dist = 0\\n        flag = False # to determine whether the array ends with upwards hill or downwards hill \\n        while ind < n-1:\\n            if a[ind] < a[ind+1]: #check whether its the starting point of mountain\\n                start = ind\\n                # loops till the peak of the mountain\\n                while ind<n-1 and a[ind]<a[ind+1]: \\n                    ind+=1 \\n                    flag = False\\n                # loops from the peak to the ending of the hill \\n                while ind<n-1 and a[ind]>a[ind+1]:\\n                    ind+=1 \\n                    flag = True\\n                if flag: # incase of termination of array check whether the hill is downwards\\n                    dist = ind-start+1 \\n                    max_dist = max(max_dist, dist) #compare\\n            else:\\n                ind+=1\\n        return max_dist        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 937918,
                "title": "longestmountain-python3-one-pass-o-1-space",
                "content": "```python\\nclass Solution:\\n    def longestMountain(self, A: [int]) -> int:\\n        ret, cur, up = 0, 1, True\\n        for i in range(len(A) - 1):\\n            if A[i+1] == A[i]:\\n                ret, cur, up = max(cur, ret) if not up else ret, 1, True\\n                continue\\n            if up:\\n                cur += 1 if A[i+1] > A[i] else 0\\n                if cur <= 1:\\n                    continue\\n                if A[i+1] < A[i]:\\n                    cur, up = cur + 1, False\\n                    continue\\n            else:\\n                if A[i+1] > A[i]:\\n                    ret, cur, up = max(cur, ret), 1, True\\n                cur += 1\\n        return ret if (ret := max(ret, cur) if not up else ret) >= 3 else 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def longestMountain(self, A: [int]) -> int:\\n        ret, cur, up = 0, 1, True\\n        for i in range(len(A) - 1):\\n            if A[i+1] == A[i]:\\n                ret, cur, up = max(cur, ret) if not up else ret, 1, True\\n                continue\\n            if up:\\n                cur += 1 if A[i+1] > A[i] else 0\\n                if cur <= 1:\\n                    continue\\n                if A[i+1] < A[i]:\\n                    cur, up = cur + 1, False\\n                    continue\\n            else:\\n                if A[i+1] > A[i]:\\n                    ret, cur, up = max(cur, ret), 1, True\\n                cur += 1\\n        return ret if (ret := max(ret, cur) if not up else ret) >= 3 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937906,
                "title": "java-using-direction-variable-o-n-tc-o-1-space",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length == 0) return 0;\\n        \\n        int max = 0;\\n        \\n        int currMax = 0;\\n        int prev = arr[0];\\n        \\n        int dir = 0;\\n        \\n        for(int i = 1; i < arr.length; i++){\\n            if(dir == -1 && (prev < arr[i] || prev == arr[i])){\\n                max = Math.max(max, currMax+1);\\n                currMax = 0;\\n            }\\n            \\n            if(prev == arr[i]){\\n                dir = 0;\\n                currMax = 0;\\n            }\\n            \\n            if(prev < arr[i]){\\n                dir = 1;\\n                currMax++;\\n            }\\n            \\n            if(dir != 0 && prev > arr[i]){\\n                dir = -1;\\n                currMax++;\\n            }\\n            \\n            prev = arr[i];\\n        }\\n        \\n        if(dir == -1){\\n            max = Math.max(max, currMax+1);\\n        }\\n        \\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length == 0) return 0;\\n        \\n        int max = 0;\\n        \\n        int currMax = 0;\\n        int prev = arr[0];\\n        \\n        int dir = 0;\\n        \\n        for(int i = 1; i < arr.length; i++){\\n            if(dir == -1 && (prev < arr[i] || prev == arr[i])){\\n                max = Math.max(max, currMax+1);\\n                currMax = 0;\\n            }\\n            \\n            if(prev == arr[i]){\\n                dir = 0;\\n                currMax = 0;\\n            }\\n            \\n            if(prev < arr[i]){\\n                dir = 1;\\n                currMax++;\\n            }\\n            \\n            if(dir != 0 && prev > arr[i]){\\n                dir = -1;\\n                currMax++;\\n            }\\n            \\n            prev = arr[i];\\n        }\\n        \\n        if(dir == -1){\\n            max = Math.max(max, currMax+1);\\n        }\\n        \\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937853,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn longest_mountain(a: Vec<i32>) -> i32 {\\n        let mut answer = 0;\\n        let mut i = 1;\\n        while i < a.len() {\\n            let (mut inc, mut dec) = (0, 0);\\n            while i < a.len() && a[i - 1] < a[i] {\\n                i += 1;\\n                inc += 1;\\n            }\\n            while i < a.len() && a[i - 1] > a[i] {\\n                i += 1;\\n                dec += 1;\\n            }\\n            if inc > 0 && dec > 0 {\\n                answer = std::cmp::max(answer, inc + dec + 1);\\n            }\\n            while i < a.len() && a[i - 1] == a[i] {\\n                i += 1;\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn longest_mountain(a: Vec<i32>) -> i32 {\\n        let mut answer = 0;\\n        let mut i = 1;\\n        while i < a.len() {\\n            let (mut inc, mut dec) = (0, 0);\\n            while i < a.len() && a[i - 1] < a[i] {\\n                i += 1;\\n                inc += 1;\\n            }\\n            while i < a.len() && a[i - 1] > a[i] {\\n                i += 1;\\n                dec += 1;\\n            }\\n            if inc > 0 && dec > 0 {\\n                answer = std::cmp::max(answer, inc + dec + 1);\\n            }\\n            while i < a.len() && a[i - 1] == a[i] {\\n                i += 1;\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 937818,
                "title": "java-find-peak-and-move-down",
                "content": "If you liked my solution, **please upvote my post**\\n\\n```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n\\t\\t// peak chould be at least 3 points\\n        if (A == null || A.length <= 2) return 0;\\n        \\n        int max = 0;\\n\\t\\t// starting from second and finishing pre-last\\n        for (int i = 1; i < A.length - 1; i++) {\\n            if (isPeak(i, A)) {\\n                int l = i - 1;\\n                int r = i + 1;\\n                int count = 3;\\n\\t\\t\\t\\t// move to left and count length\\n                while (l > 0) {\\n                    if (A[l] > A[l - 1]) {\\n                        l--;\\n                        count++;\\n                        continue;\\n                    }\\n                    break;\\n                }\\n\\t\\t\\t\\t// move to right and count length\\n                while (r < A.length - 1) {\\n                    if (A[r] > A[r + 1]) {\\n                        r++;\\n                        count++;\\n                        continue;\\n                    }\\n                    break;\\n                }\\n                max = Math.max(max, count);\\n                // not to check right side of the mountain again on the peak\\n                i = r;\\n            }\\n        }\\n        return max;\\n    }\\n\\t// check condition if point is peak\\n    private boolean isPeak(int i, int[] A) {\\n        return A[i - 1] < A[i] && A[i + 1] < A[i];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n\\t\\t// peak chould be at least 3 points\\n        if (A == null || A.length <= 2) return 0;\\n        \\n        int max = 0;\\n\\t\\t// starting from second and finishing pre-last\\n        for (int i = 1; i < A.length - 1; i++) {\\n            if (isPeak(i, A)) {\\n                int l = i - 1;\\n                int r = i + 1;\\n                int count = 3;\\n\\t\\t\\t\\t// move to left and count length\\n                while (l > 0) {\\n                    if (A[l] > A[l - 1]) {\\n                        l--;\\n                        count++;\\n                        continue;\\n                    }\\n                    break;\\n                }\\n\\t\\t\\t\\t// move to right and count length\\n                while (r < A.length - 1) {\\n                    if (A[r] > A[r + 1]) {\\n                        r++;\\n                        count++;\\n                        continue;\\n                    }\\n                    break;\\n                }\\n                max = Math.max(max, count);\\n                // not to check right side of the mountain again on the peak\\n                i = r;\\n            }\\n        }\\n        return max;\\n    }\\n\\t// check condition if point is peak\\n    private boolean isPeak(int i, int[] A) {\\n        return A[i - 1] < A[i] && A[i + 1] < A[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937774,
                "title": "longest-mountain-in-array-o-n-time-o-1-space-java",
                "content": "```\\npublic int longestMountain(int[] A) {\\n        int res = 0;\\n        int iCount = 0;\\n        int dCount = 0;\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (dCount > 0 && A[i] < A[i + 1] || A[i] == A[i + 1]) {\\n                iCount = dCount = 0;\\n            }\\n            if (A[i] < A[i + 1]) {\\n                iCount++;\\n            }\\n            if (A[i] > A[i + 1]) {\\n                dCount++;\\n            }\\n            if (iCount > 0 && dCount > 0 ){\\n              res = Math.max(res, iCount + dCount + 1);  \\n            } \\n        }\\n        return res;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\npublic int longestMountain(int[] A) {\\n        int res = 0;\\n        int iCount = 0;\\n        int dCount = 0;\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (dCount > 0 && A[i] < A[i + 1] || A[i] == A[i + 1]) {\\n                iCount = dCount = 0;\\n            }\\n            if (A[i] < A[i + 1]) {\\n                iCount++;\\n            }\\n            if (A[i] > A[i + 1]) {\\n                dCount++;\\n            }\\n            if (iCount > 0 && dCount > 0 ){\\n              res = Math.max(res, iCount + dCount + 1);  \\n            } \\n        }\\n        return res;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 937734,
                "title": "java-easy-one-pass-solution-o-1-space",
                "content": "```\\n   public int longestMountain(int[] nums) {\\n        int len = nums.length;\\n        if(len <= 2) return 0;\\n        int left = 1;\\n        int res = 0;\\n        while(left < len){\\n            if(nums[left] <= nums[left - 1]){\\n                left++;\\n                continue;\\n            }\\n            int cur = left - 1;\\n            while(left < len && nums[left] > nums[left - 1]){\\n                left++;\\n            }\\n            boolean isMountain = false;\\n            while(left < len && nums[left] < nums[left - 1]){\\n                isMountain = true;\\n                left++;\\n            }\\n            if(isMountain) res = Math.max(left - cur, res);       \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n   public int longestMountain(int[] nums) {\\n        int len = nums.length;\\n        if(len <= 2) return 0;\\n        int left = 1;\\n        int res = 0;\\n        while(left < len){\\n            if(nums[left] <= nums[left - 1]){\\n                left++;\\n                continue;\\n            }\\n            int cur = left - 1;\\n            while(left < len && nums[left] > nums[left - 1]){\\n                left++;\\n            }\\n            boolean isMountain = false;\\n            while(left < len && nums[left] < nums[left - 1]){\\n                isMountain = true;\\n                left++;\\n            }\\n            if(isMountain) res = Math.max(left - cur, res);       \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 937687,
                "title": "longest-mountain-in-array-with-constrain-and-without-constrain-both-solutions",
                "content": "Without the constraints. dp solution\\n\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        if(!A.size()) return 0;\\n        int ans = 0;\\n        vector<int> forw(A.size(), 0), back(A.size(), 0);\\n        for(int i=1;i<A.size();i++) if(A[i] > A[i-1]) back[i] = 1 + back[i-1];\\n        for(int i=A.size()-2;i>=0;i--) if(A[i] > A[i+1]) forw[i] = 1 + forw[i+1];\\n        for(int i=1;i<A.size()-1;i++){\\n            if(back[i] > 0 && forw[i] > 0) ans = max(ans, back[i] + forw[i] +1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nWith constraint O(1) space and 1 traversal solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int increasing(vector<int>& A, int index){\\n        for(;index<A.size()-1;index++) if(A[index+1] <= A[index]) break;\\n        return index;\\n    }\\n    int decreasing(vector<int>& A, int index){\\n        for(;index<A.size()-1;index++) if(A[index+1] >= A[index]) break;\\n        return index;\\n    }\\n    int longestMountain(vector<int>& A) {\\n        int i = 0;\\n        int ans = 0;\\n        bool up = true;\\n        int increasingElements = 0;\\n        int newIndex = 0;\\n        while(i<A.size()){\\n            if(up){\\n                newIndex = increasing(A, i);\\n                increasingElements = newIndex - i;\\n                if(increasingElements) up^=1;\\n                else newIndex++;\\n            } else{\\n                newIndex = decreasing(A, i);\\n                if((newIndex - i)) ans = max(ans, (newIndex - i + increasingElements +1));\\n                increasingElements = 0;\\n                up^=1;\\n            }\\n            i = newIndex;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        if(!A.size()) return 0;\\n        int ans = 0;\\n        vector<int> forw(A.size(), 0), back(A.size(), 0);\\n        for(int i=1;i<A.size();i++) if(A[i] > A[i-1]) back[i] = 1 + back[i-1];\\n        for(int i=A.size()-2;i>=0;i--) if(A[i] > A[i+1]) forw[i] = 1 + forw[i+1];\\n        for(int i=1;i<A.size()-1;i++){\\n            if(back[i] > 0 && forw[i] > 0) ans = max(ans, back[i] + forw[i] +1);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int increasing(vector<int>& A, int index){\\n        for(;index<A.size()-1;index++) if(A[index+1] <= A[index]) break;\\n        return index;\\n    }\\n    int decreasing(vector<int>& A, int index){\\n        for(;index<A.size()-1;index++) if(A[index+1] >= A[index]) break;\\n        return index;\\n    }\\n    int longestMountain(vector<int>& A) {\\n        int i = 0;\\n        int ans = 0;\\n        bool up = true;\\n        int increasingElements = 0;\\n        int newIndex = 0;\\n        while(i<A.size()){\\n            if(up){\\n                newIndex = increasing(A, i);\\n                increasingElements = newIndex - i;\\n                if(increasingElements) up^=1;\\n                else newIndex++;\\n            } else{\\n                newIndex = decreasing(A, i);\\n                if((newIndex - i)) ans = max(ans, (newIndex - i + increasingElements +1));\\n                increasingElements = 0;\\n                up^=1;\\n            }\\n            i = newIndex;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 932167,
                "title": "not-the-shortest-but-intuitive-one-single-pass-o-n",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int end=0,begin=0;\\n        int maxm = Integer.MIN_VALUE;\\n        //find the first rising point\\n        while(begin < a.length-1 &&  a[begin]>=a[begin+1]){\\n            begin++;\\n        }\\n        end = begin;\\n        //To handle if list of duplicates only\\n        if(end>=a.length-1)\\n            return 0;\\n        //Variables to check if mountain condition satisfied\\n        boolean up = false, down=false;\\n        while(end < a.length-1){\\n            up=false;down=false;\\n            // time to check a mountain\\n            if(a[end] < a[end+1]){\\n               while(end<a.length-1 && a[end]<a[end+1]) {end++;up=true;}\\n               while(end<a.length-1  && a[end]>a[end+1]) {end++;down=true;}\\n               if(up==true && down==true){\\n                   maxm = Math.max(maxm,end-begin+1);\\n                    up=false;down=false;\\n                }\\n                begin=end;\\n            }\\n            else{\\n                end++;\\n                begin++;\\n            }\\n        }\\n         if(up==true && down==true){\\n              maxm=Math.max(maxm,end-begin+1);\\n         }\\n        return (maxm == Integer.MIN_VALUE || maxm<3)?0 : maxm;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int end=0,begin=0;\\n        int maxm = Integer.MIN_VALUE;\\n        //find the first rising point\\n        while(begin < a.length-1 &&  a[begin]>=a[begin+1]){\\n            begin++;\\n        }\\n        end = begin;\\n        //To handle if list of duplicates only\\n        if(end>=a.length-1)\\n            return 0;\\n        //Variables to check if mountain condition satisfied\\n        boolean up = false, down=false;\\n        while(end < a.length-1){\\n            up=false;down=false;\\n            // time to check a mountain\\n            if(a[end] < a[end+1]){\\n               while(end<a.length-1 && a[end]<a[end+1]) {end++;up=true;}\\n               while(end<a.length-1  && a[end]>a[end+1]) {end++;down=true;}\\n               if(up==true && down==true){\\n                   maxm = Math.max(maxm,end-begin+1);\\n                    up=false;down=false;\\n                }\\n                begin=end;\\n            }\\n            else{\\n                end++;\\n                begin++;\\n            }\\n        }\\n         if(up==true && down==true){\\n              maxm=Math.max(maxm,end-begin+1);\\n         }\\n        return (maxm == Integer.MIN_VALUE || maxm<3)?0 : maxm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887801,
                "title": "1-pass-python-o-1-space",
                "content": "```class Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        j,k=0,0\\n        ans=0\\n        for i in range(1,len(A)):\\n            if(A[i]-A[i-1]>0):\\n                if(k>0):\\n                    ans=max(ans,j+k+1)\\n                    j=1\\n                    k=0\\n                else:\\n                    j+=1\\n            elif(A[i]-A[i-1]<0):\\n                if(j>0):\\n                    k+=1\\n            else:\\n                if(k!=0 and j!=0):\\n                    ans=max(ans,j+k+1)\\n                j=0\\n                k=0\\n        if(k!=0 and j!=0):\\n            ans=max(ans,j+k+1)\\n        return ans\\n",
                "solutionTags": [],
                "code": "```class Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        j,k=0,0\\n        ans=0\\n        for i in range(1,len(A)):\\n            if(A[i]-A[i-1]>0):\\n                if(k>0):\\n                    ans=max(ans,j+k+1)\\n                    j=1\\n                    k=0\\n                else:\\n                    j+=1\\n            elif(A[i]-A[i-1]<0):\\n                if(j>0):\\n                    k+=1\\n            else:\\n                if(k!=0 and j!=0):\\n                    ans=max(ans,j+k+1)\\n                j=0\\n                k=0\\n        if(k!=0 and j!=0):\\n            ans=max(ans,j+k+1)\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 881817,
                "title": "simple-c-approach-91-5",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int n=A.size(); \\n        if(n==0)return 0;\\n        int inc[n];\\n        int dec[n];\\n        //inc[i] stores length of increasing subarray till index i;\\n        inc[0]=1;\\n        for(int i=1;i<n;i++){\\n            inc[i]=A[i]>A[i-1]?inc[i-1]+1:1;\\n        }\\n          //dec[i] stores the length of decreasing subarray starting at index i\\n        dec[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            dec[i]=A[i]>A[i+1]?dec[i+1]+1:1;\\n        }\\n        \\n        int len=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(dec[i]>1 && inc[i]>1 && len<dec[i]+inc[i]-1) len=inc[i]+dec[i]-1;\\n        }\\n        \\n        cout<<len<<endl;\\n        return len<3?0:len;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int n=A.size(); \\n        if(n==0)return 0;\\n        int inc[n];\\n        int dec[n];\\n        //inc[i] stores length of increasing subarray till index i;\\n        inc[0]=1;\\n        for(int i=1;i<n;i++){\\n            inc[i]=A[i]>A[i-1]?inc[i-1]+1:1;\\n        }\\n          //dec[i] stores the length of decreasing subarray starting at index i\\n        dec[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            dec[i]=A[i]>A[i+1]?dec[i+1]+1:1;\\n        }\\n        \\n        int len=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(dec[i]>1 && inc[i]>1 && len<dec[i]+inc[i]-1) len=inc[i]+dec[i]-1;\\n        }\\n        \\n        cout<<len<<endl;\\n        return len<3?0:len;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 857132,
                "title": "naive-c-1-pass-and-o-1-space",
                "content": "```\\npublic class Solution {\\n    public int LongestMountain(int[] A) {\\n        var max = 0;\\n        var up = 0;\\n        var mountainLength = 0;\\n        \\n        for(var i = 1; i < A.Length; i++)\\n        {\\n            if(A[i] > A[i-1])\\n            {\\n                mountainLength = ++up;\\n                continue;\\n            }\\n            if(A[i] < A[i-1])\\n            {\\n                if(mountainLength == 0)\\n                    continue;\\n                mountainLength++;\\n            }\\n            else{\\n                mountainLength = 0;\\n            }\\n            up = 0;\\n            max = Math.Max(max, mountainLength > 0 && up == 0 ? mountainLength + 1 : 0);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LongestMountain(int[] A) {\\n        var max = 0;\\n        var up = 0;\\n        var mountainLength = 0;\\n        \\n        for(var i = 1; i < A.Length; i++)\\n        {\\n            if(A[i] > A[i-1])\\n            {\\n                mountainLength = ++up;\\n                continue;\\n            }\\n            if(A[i] < A[i-1])\\n            {\\n                if(mountainLength == 0)\\n                    continue;\\n                mountainLength++;\\n            }\\n            else{\\n                mountainLength = 0;\\n            }\\n            up = 0;\\n            max = Math.Max(max, mountainLength > 0 && up == 0 ? mountainLength + 1 : 0);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852833,
                "title": "c-solution-one-pass-two-pointer",
                "content": "Runtime: 40 ms, faster than 86.10% of C++ online submissions for Longest Mountain in Array.\\nMemory Usage: 18.5 MB, less than 75.29% of C++ online submissions for Longest Mountain in Array.\\n\\nhttps://leetcode.com/problems/longest-mountain-in-array/discuss/773237/C++-Two-pointer-solution\\n\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n\\n        int n = A.size();\\n        if(n<3) return 0;\\n        \\n        int maxL = 0;\\n        int i = 0;\\n        int up = 0;\\n        int down = 0;\\n        while(i<n)\\n        {\\n            // track the up and down scenario  in the mountain\\n            up = 0; down = 0;\\n            \\n            // check if we can go up and count up length\\n            while(i<n-1 && A[i]<A[i+1])i++,up++;\\n            \\n            // check if we can go down and also check if up is valid and count down length\\n            while(i<n-1 && A[i]>A[i+1] && up)i++,down++;\\n            \\n            // if there is a up and down then count length as up+down+1 (including peek)\\n            if(up && down)\\n                maxL  = max(maxL,up + down + 1);\\n            else\\n                i++;\\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n\\n        int n = A.size();\\n        if(n<3) return 0;\\n        \\n        int maxL = 0;\\n        int i = 0;\\n        int up = 0;\\n        int down = 0;\\n        while(i<n)\\n        {\\n            // track the up and down scenario  in the mountain\\n            up = 0; down = 0;\\n            \\n            // check if we can go up and count up length\\n            while(i<n-1 && A[i]<A[i+1])i++,up++;\\n            \\n            // check if we can go down and also check if up is valid and count down length\\n            while(i<n-1 && A[i]>A[i+1] && up)i++,down++;\\n            \\n            // if there is a up and down then count length as up+down+1 (including peek)\\n            if(up && down)\\n                maxL  = max(maxL,up + down + 1);\\n            else\\n                i++;\\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 830281,
                "title": "java-bitonic",
                "content": "public int longestMountain(int[] A) {\\n        //extension of bitonic array \\n        \\n    /*  2  1  4  7  3  2  5\\n        0  0  1  2  0  0  1 //increasing from left to right pass(khud se start kru ya purane k saath add hu)\\n                          \\n        1  0  0  2  1  0  0//increasing from right to left\\n        \\n        2  -  2  5  2  -  - //add both+1 */\\n            \\n      int[] lefttoright=new int[A.length];\\n      int[] righttoleft=new int[A.length];\\n        int max=0;\\n        for(int start=1;start<=A.length-1;start++){\\n            if(A[start]>A[start-1]){\\n            lefttoright[start]=lefttoright[start-1]+1;\\n            }else{\\n                lefttoright[start]=0;\\n            }\\n        }\\n        for(int end=A.length-2;end>=0;end--){\\n           if(A[end]>A[end+1]){\\n                righttoleft[end]=righttoleft[end+1]+1;\\n            }else{\\n                righttoleft[end]=0;\\n            } \\n        }\\n        //calculate max(sum)+1 (Now include element if only it increasing from both side)\\n        for(int s=0;s<A.length;s++){\\n            if(lefttoright[s]>0 && righttoleft[s]>0){\\n            int ans=lefttoright[s]+righttoleft[s]+1;\\n            max=Math.max(ans,max);\\n            }\\n        }\\n    return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "public int longestMountain(int[] A) {\\n        //extension of bitonic array \\n        \\n    /*  2  1  4  7  3  2  5\\n        0  0  1  2  0  0  1 //increasing from left to right pass(khud se start kru ya purane k saath add hu)\\n                          \\n        1  0  0  2  1  0  0//increasing from right to left\\n        \\n        2  -  2  5  2  -  - //add both+1 */\\n            \\n      int[] lefttoright=new int[A.length];\\n      int[] righttoleft=new int[A.length];\\n        int max=0;\\n        for(int start=1;start<=A.length-1;start++){\\n            if(A[start]>A[start-1]){\\n            lefttoright[start]=lefttoright[start-1]+1;\\n            }else{\\n                lefttoright[start]=0;\\n            }\\n        }\\n        for(int end=A.length-2;end>=0;end--){\\n           if(A[end]>A[end+1]){\\n                righttoleft[end]=righttoleft[end+1]+1;\\n            }else{\\n                righttoleft[end]=0;\\n            } \\n        }\\n        //calculate max(sum)+1 (Now include element if only it increasing from both side)\\n        for(int s=0;s<A.length;s++){\\n            if(lefttoright[s]>0 && righttoleft[s]>0){\\n            int ans=lefttoright[s]+righttoleft[s]+1;\\n            max=Math.max(ans,max);\\n            }\\n        }\\n    return max;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 796410,
                "title": "well-commented-c-code-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        int n=a.size();\\n        int i=0,start=0,top=-1,len=0;\\n        while(i<n-1)\\n        {\\n            while(i<n-1 and a[i]>=a[i+1]) i++,start++;  //checking where the hill starts\\n            if(i==n-1) break;   //if hill doesn\\'t start eg. 2 2 2\\n            while(i<n-1 and a[i]<a[i+1]) i++,top=i; //incrementing untill we find a hill top\\n            while(i<n-1 and a[i]>a[i+1]) i++;   //going downhill after finding a top\\n            if(top<i) len = max(len,i-start+1); //checking if a value exists after hill top\\n            start=i;    //staring from this position for the next hill\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        int n=a.size();\\n        int i=0,start=0,top=-1,len=0;\\n        while(i<n-1)\\n        {\\n            while(i<n-1 and a[i]>=a[i+1]) i++,start++;  //checking where the hill starts\\n            if(i==n-1) break;   //if hill doesn\\'t start eg. 2 2 2\\n            while(i<n-1 and a[i]<a[i+1]) i++,top=i; //incrementing untill we find a hill top\\n            while(i<n-1 and a[i]>a[i+1]) i++;   //going downhill after finding a top\\n            if(top<i) len = max(len,i-start+1); //checking if a value exists after hill top\\n            start=i;    //staring from this position for the next hill\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796409,
                "title": "c-1-pass-solution-o-n-time-o-1-space-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        int n=a.size();int i=0,start=0,top=-1,len=0;\\n        while(i<n)\\n        {   //find the start of mountain\\n            while(i<n-1 and a[i]>=a[i+1]) i++,start++;\\n            if(i==n-1) break;\\n            //see if the peak is really the peak\\n            while(i<n-1 and a[i]<a[i+1]) i++,top=i;\\n            //find the end of mountain\\n            while(i<n-1 and a[i]>a[i+1]) i++;\\n            //calculate the total length\\n            if(top<i) len=max(len,i-start+1);\\n            start=i;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        int n=a.size();int i=0,start=0,top=-1,len=0;\\n        while(i<n)\\n        {   //find the start of mountain\\n            while(i<n-1 and a[i]>=a[i+1]) i++,start++;\\n            if(i==n-1) break;\\n            //see if the peak is really the peak\\n            while(i<n-1 and a[i]<a[i+1]) i++,top=i;\\n            //find the end of mountain\\n            while(i<n-1 and a[i]>a[i+1]) i++;\\n            //calculate the total length\\n            if(top<i) len=max(len,i-start+1);\\n            start=i;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760497,
                "title": "detailed-explanation-with-java-o-n-time-and-o-1-space",
                "content": "\\n```\\n public int longestMountain(int[] array) {\\n        int longestLength = 0;\\n        int i = 1;\\n        while(i < array.length - 1){\\n            boolean isPeak = array[i - 1] < array[i] && array[i] > array[i + 1];\\n            \\n            if(!isPeak){\\n                i++;\\n                continue;\\n            }\\n            \\n            int leftIdx = i - 2;\\n            while(leftIdx >=0 && array[leftIdx] < array[leftIdx + 1]){\\n                leftIdx--;\\n            }\\n            \\n            int rightIdx = i + 2;\\n            while(rightIdx < array.length && array[rightIdx - 1] > array[rightIdx]){\\n                rightIdx++;\\n            }\\n            \\n            int currentLength = rightIdx - leftIdx - 1;\\n            if(currentLength > longestLength){\\n                longestLength = currentLength;\\n            }\\n            i = rightIdx;\\n        }\\n        return longestLength;\\n    }\\n```\\n\\n\\n**Intuition**:\\nFirst you have to know if a number is a peak. Once you know the peak you need to expand to its both directions and calulate its length along the way. Keep updating the length by comparing it with length of other peaks and choose the longest length.\\n\\n\\n**Algorithm**:\\nSo we first have to know if the current number is the peak. Start traversing the array from left to right. If a current value satisfies the peak condition then store the boolean result in a variable call it \\'isPeak\\'. Note that traversal will start from the second element, because it doesnt make sense to check if the first element is a peak, because it cant be, according to the definition of a peak.\\n\\nCondition: array[ i - 1 ] < array[ i ] && array[ i ] > array[ i + 1 ]\\n\\nThe reason to use a boolean variable is just for simplying the code. Otherwise you can directly write a peak condition inside the if construct.\\n\\nLets move on, \\n\\nIf the current value is not a peak then we dont do anything in this iteration, simply increment the iterator \\'i\\' and just continue with the search for a peak on to the next element.\\n\\nIf we have the peak:\\nThen we have to expand to the right and left, so long as we have strictly decreasing integers in either directions.\\n\\n**Lets expand to the left first:**\\nWe already know the left( i - 1 ) of the current element (i) is smaller. So we dont have to check that again. We start from i - 2. Hence we define a variable leftIdx initialized to i - 2\\n\\nNow we iterate through the left part backwords. As long as our leftIdx is in the bounds and array[leftIdx] < array[leftIdx + 1] . Keep decrementing the leftIdx. So that we can keep checking all values to the left. At the end leftIdx, will hold the index of the element from where the peak began.\\n\\n\\n**Lets expand to the right now:**\\nWe already know that the right ( i + 1 ) of the current element ( i ) is greater. So we dont have to check that again. We start from i + 2\\n\\nNow iterate through the right part forwards. As long as our rightIdx is in the bounds and array[ rightIdx - 1 ]  >  array[ i ]. Keep increamenting the rightIdx.  So that we can keep checking all values to the right. At the end rightIdx, will hold the index of the element to where the peak ends.\\n\\nNow get the currentPeakLength by doing rightIdx - leftIdx - 1 \\nAnd compare it with the longestPeakLength,  and return the longest amongst them.\\n\\n\\nTo increment the iteration variable i, do this:\\ni = rightIdx\\n\\nWhy it works ?. The rightIdx holds the location of a and end of a peak. All the element between a peak and this rightIdx, were in a strictly decreasing manner. So it doesnt make a sense to check values before the rightIdx.\\n\\n\\n**Complexity Analysis**\\n\\nTime: O(n), How many times do we visit every element in the array ? There are few cases to consider. Lets say you have strictly increasing or strictly decreasing or a flat array. Then there is no peak. In all these three cases you visit each element once. But when we find a peak, we have to expand to left and right. There can be multiple peaks to expand. All these expansion is also a visit. So in this case too we are visiting each element for once at least. And then we visit every element at most 2-3 times. It converges to O(N)\\n\\n*Please correct me if you find that I misunderstood something in the explaination*",
                "solutionTags": [],
                "code": "```\\n public int longestMountain(int[] array) {\\n        int longestLength = 0;\\n        int i = 1;\\n        while(i < array.length - 1){\\n            boolean isPeak = array[i - 1] < array[i] && array[i] > array[i + 1];\\n            \\n            if(!isPeak){\\n                i++;\\n                continue;\\n            }\\n            \\n            int leftIdx = i - 2;\\n            while(leftIdx >=0 && array[leftIdx] < array[leftIdx + 1]){\\n                leftIdx--;\\n            }\\n            \\n            int rightIdx = i + 2;\\n            while(rightIdx < array.length && array[rightIdx - 1] > array[rightIdx]){\\n                rightIdx++;\\n            }\\n            \\n            int currentLength = rightIdx - leftIdx - 1;\\n            if(currentLength > longestLength){\\n                longestLength = currentLength;\\n            }\\n            i = rightIdx;\\n        }\\n        return longestLength;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 749845,
                "title": "python-3-explanation",
                "content": "* Iterate through `A` and look for a mountain \\'peak\\', that is, where the numbers **either side of the current number** are less than the current number.\\n* Once we find a peak, we set two pointers `left` and `right` to start from the current index `i`.\\n\\t* These two pointers will \\'descend\\' down the mountain until either:\\n\\t1. They go out of range of `A`.\\n\\t2. The downward slope of the mountain stops.\\n* Once we have gotten to the base of the current mountain spanning outwards from index `i`, we find the `mountainLength` by taking the difference of `right` and `left` and add one to count the peak as well.\\n```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        if len(A) < 3:\\n            return 0\\n        \\n        longestMountain = 0\\n\\n        for i in range(1, len(A) - 1):\\n            # Index i denotes a \\'peak\\' in the mountain.\\n            if A[i - 1] < A[i] > A[i + 1]:\\n                left = right = i\\n                \\n                # Traverse left and down the mountain from i until there is no longer a downwards slope.\\n                while left > 0 and A[left - 1] < A[left]:\\n                    left -= 1\\n                                \\n                # Traverse right and down the mountain from i until there is no longer a downwards slope.\\n                while right + 1 < len(A) and A[right + 1] < A[right]:\\n                    right += 1\\n                    \\n                # The length of the mountain will be the distance from left and right (+ 1 to factor in the peak).\\n                mountainLength = right - left + 1\\n                longestMountain = max(longestMountain, mountainLength)\\n        \\n        return longestMountain\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        if len(A) < 3:\\n            return 0\\n        \\n        longestMountain = 0\\n\\n        for i in range(1, len(A) - 1):\\n            # Index i denotes a \\'peak\\' in the mountain.\\n            if A[i - 1] < A[i] > A[i + 1]:\\n                left = right = i\\n                \\n                # Traverse left and down the mountain from i until there is no longer a downwards slope.\\n                while left > 0 and A[left - 1] < A[left]:\\n                    left -= 1\\n                                \\n                # Traverse right and down the mountain from i until there is no longer a downwards slope.\\n                while right + 1 < len(A) and A[right + 1] < A[right]:\\n                    right += 1\\n                    \\n                # The length of the mountain will be the distance from left and right (+ 1 to factor in the peak).\\n                mountainLength = right - left + 1\\n                longestMountain = max(longestMountain, mountainLength)\\n        \\n        return longestMountain\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1773841,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1737004,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1801992,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1970341,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1959957,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1950953,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1861077,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Length of a Concatenated String with Unique Characters",
        "question_content": "<p>You are given an array of strings <code>arr</code>. A string <code>s</code> is formed by the <strong>concatenation</strong> of a <strong>subsequence</strong> of <code>arr</code> that has <strong>unique characters</strong>.</p>\n\n<p>Return <em>the <strong>maximum</strong> possible length</em> of <code>s</code>.</p>\n\n<p>A <strong>subsequence</strong> is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> All the valid concatenations are:\n- &quot;&quot;\n- &quot;un&quot;\n- &quot;iq&quot;\n- &quot;ue&quot;\n- &quot;uniq&quot; (&quot;un&quot; + &quot;iq&quot;)\n- &quot;ique&quot; (&quot;iq&quot; + &quot;ue&quot;)\nMaximum length is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [&quot;cha&quot;,&quot;r&quot;,&quot;act&quot;,&quot;ers&quot;]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Possible longest valid concatenations are &quot;chaers&quot; (&quot;cha&quot; + &quot;ers&quot;) and &quot;acters&quot; (&quot;act&quot; + &quot;ers&quot;).\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;]\n<strong>Output:</strong> 26\n<strong>Explanation:</strong> The only string in arr has all 26 characters.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 16</code></li>\n\t<li><code>1 &lt;= arr[i].length &lt;= 26</code></li>\n\t<li><code>arr[i]</code> contains only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 414172,
                "title": "python-c-java-set-solution",
                "content": "## **Explanation**\\n\\n0. Initial the result `res` to include the case of empty string `\"\"`.\\n`res` include all possible combinations we find during we iterate the input.\\n\\n1. Itearte the the input strings,\\nbut skip the word that have duplicate characters.\\nThe examples is kind of misleading,\\nbut the input string can have duplicate characters,\\nno need to considerate these strings.\\n\\n3. For each string,\\nwe check if it\\'s conflit with the combination that we found.\\nIf they have intersection of characters, we skip it.\\nIf not, we append this new combination to result.\\n\\n4. return the maximum length from all combinations.\\n<br>\\n\\n**Python:**\\n```python\\n    def maxLength(self, A):\\n        dp = [set()]\\n        for a in A:\\n            if len(set(a)) < len(a): continue\\n            a = set(a)\\n            for c in dp[:]:\\n                if a & c: continue\\n                dp.append(a | c)\\n        return max(len(a) for a in dp)\\n```\\n**C++**\\nbased on @savvadia\\n```C++\\n    int maxLength(vector<string>& A) {\\n        vector<bitset<26>> dp = {bitset<26>()};\\n        int res = 0;\\n        for (auto& s : A) {\\n            bitset<26> a;\\n            for (char c : s)\\n                a.set(c - \\'a\\');\\n            int n = a.count();\\n            if (n < s.size()) continue;\\n\\n            for (int i = dp.size() - 1; i >= 0; --i) {\\n                bitset c = dp[i];\\n                if ((c & a).any()) continue;\\n                dp.push_back(c | a);\\n                res = max(res, (int)c.count() + n);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Java**\\n```java\\n    public int maxLength(List<String> A) {\\n        List<Integer> dp = new ArrayList<>();\\n        dp.add(0);\\n        int res = 0;\\n        for (String s : A) {\\n            int a = 0, dup = 0;\\n            for (char c : s.toCharArray()) {\\n                dup |= a & (1 << (c - \\'a\\'));\\n                a |= 1 << (c - \\'a\\');\\n            }\\n            if (dup > 0) continue;\\n            for (int i = dp.size() - 1; i >= 0; --i) {\\n                if ((dp.get(i) & a) > 0) continue;\\n                dp.add(dp.get(i) | a);\\n                res = Math.max(res, Integer.bitCount(dp.get(i) | a));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```python\\n    def maxLength(self, A):\\n        dp = [set()]\\n        for a in A:\\n            if len(set(a)) < len(a): continue\\n            a = set(a)\\n            for c in dp[:]:\\n                if a & c: continue\\n                dp.append(a | c)\\n        return max(len(a) for a in dp)\\n```\n```C++\\n    int maxLength(vector<string>& A) {\\n        vector<bitset<26>> dp = {bitset<26>()};\\n        int res = 0;\\n        for (auto& s : A) {\\n            bitset<26> a;\\n            for (char c : s)\\n                a.set(c - \\'a\\');\\n            int n = a.count();\\n            if (n < s.size()) continue;\\n\\n            for (int i = dp.size() - 1; i >= 0; --i) {\\n                bitset c = dp[i];\\n                if ((c & a).any()) continue;\\n                dp.push_back(c | a);\\n                res = max(res, (int)c.count() + n);\\n            }\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int maxLength(List<String> A) {\\n        List<Integer> dp = new ArrayList<>();\\n        dp.add(0);\\n        int res = 0;\\n        for (String s : A) {\\n            int a = 0, dup = 0;\\n            for (char c : s.toCharArray()) {\\n                dup |= a & (1 << (c - \\'a\\'));\\n                a |= 1 << (c - \\'a\\');\\n            }\\n            if (dup > 0) continue;\\n            for (int i = dp.size() - 1; i >= 0; --i) {\\n                if ((dp.get(i) & a) > 0) continue;\\n                dp.add(dp.get(i) | a);\\n                res = Math.max(res, Integer.bitCount(dp.get(i) | a));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 414180,
                "title": "clean-java-javascript-dfs-solution",
                "content": "I think you can optimize a bit by adding memory to it. Time was limited during the contest, I didn\\'t have time to optimized it.\\n\\n```\\nclass Solution {\\n    private int result = 0;\\n\\n    public int maxLength(List<String> arr) {\\n        if (arr == null || arr.size() == 0) {\\n            return 0;\\n        }\\n\\n        dfs(arr, \"\", 0);\\n\\n        return result;\\n    }\\n\\n    private void dfs(List<String> arr, String path, int idx) {\\n        boolean isUniqueChar = isUniqueChars(path);\\n        \\n        if (isUniqueChar) {\\n            result = Math.max(path.length(), result);\\n        }\\n\\n        if (idx == arr.size() || !isUniqueChar) {\\n            return;\\n        }\\n        \\n        for (int i = idx; i < arr.size(); i++) {\\n            dfs(arr, path + arr.get(i), i + 1);\\n        }\\n    }\\n\\n    private boolean isUniqueChars(String s) {\\n        Set<Character> set = new HashSet<>();\\n\\n        for (char c : s.toCharArray()) {\\n            if (set.contains(c)) {\\n                return false;\\n            }\\n            set.add(c);\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n\\nJavaScript solution using memorization DFS from @jitendra8911 in the comment.\\n\\n```\\nvar maxLength = function(arr) {\\n    let maxLen = 0;\\n    let listOfStrs = [];\\n    arr = arr.filter(isUnique);\\n    let mem = {};\\n    maxLen = dfs(arr, \"\", 0, maxLen, mem);\\n    \\n    return maxLen;\\n};\\n\\nfunction dfs(arr, path, i, maxLen, mem) {\\n    if (mem[path]) return mem[path];\\n    let pathIsUnique = isUnique(path);\\n    if (pathIsUnique) {\\n        maxLen = Math.max(path.length, maxLen);\\n    } \\n    if (i === arr.length || !pathIsUnique) {\\n        mem[path] = maxLen;\\n        return maxLen;\\n    }\\n    for (let j = i; j < arr.length; j++) {\\n        maxLen = dfs(arr, path + arr[j], j + 1, maxLen, mem);\\n    }\\n\\n\\n    mem[path] = maxLen;\\n    return maxLen;\\n}\\n\\nfunction isUnique(str) {\\n    const map = {}\\n    for (let i = 0; i < str.length; i++) {\\n        if (map[str[i]]) return false;\\n        map[str[i]] = 1;\\n    }\\n    \\n    return true;\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int result = 0;\\n\\n    public int maxLength(List<String> arr) {\\n        if (arr == null || arr.size() == 0) {\\n            return 0;\\n        }\\n\\n        dfs(arr, \"\", 0);\\n\\n        return result;\\n    }\\n\\n    private void dfs(List<String> arr, String path, int idx) {\\n        boolean isUniqueChar = isUniqueChars(path);\\n        \\n        if (isUniqueChar) {\\n            result = Math.max(path.length(), result);\\n        }\\n\\n        if (idx == arr.size() || !isUniqueChar) {\\n            return;\\n        }\\n        \\n        for (int i = idx; i < arr.size(); i++) {\\n            dfs(arr, path + arr.get(i), i + 1);\\n        }\\n    }\\n\\n    private boolean isUniqueChars(String s) {\\n        Set<Character> set = new HashSet<>();\\n\\n        for (char c : s.toCharArray()) {\\n            if (set.contains(c)) {\\n                return false;\\n            }\\n            set.add(c);\\n        }\\n        return true;\\n    }\\n}\\n\\n```\n```\\nvar maxLength = function(arr) {\\n    let maxLen = 0;\\n    let listOfStrs = [];\\n    arr = arr.filter(isUnique);\\n    let mem = {};\\n    maxLen = dfs(arr, \"\", 0, maxLen, mem);\\n    \\n    return maxLen;\\n};\\n\\nfunction dfs(arr, path, i, maxLen, mem) {\\n    if (mem[path]) return mem[path];\\n    let pathIsUnique = isUnique(path);\\n    if (pathIsUnique) {\\n        maxLen = Math.max(path.length, maxLen);\\n    } \\n    if (i === arr.length || !pathIsUnique) {\\n        mem[path] = maxLen;\\n        return maxLen;\\n    }\\n    for (let j = i; j < arr.length; j++) {\\n        maxLen = dfs(arr, path + arr[j], j + 1, maxLen, mem);\\n    }\\n\\n\\n    mem[path] = maxLen;\\n    return maxLen;\\n}\\n\\nfunction isUnique(str) {\\n    const map = {}\\n    for (let i = 0; i < str.length; i++) {\\n        if (map[str[i]]) return false;\\n        map[str[i]] = 1;\\n    }\\n    \\n    return true;\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414806,
                "title": "c-dfs-clean-and-concise-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr, string str = \"\", int index = 0) {\\n\\t    //Use set to check if the string contains all unique characters\\n        unordered_set<char>s(str.begin(), str.end());\\n        if (s.size() != ((int)str.length())) \\n            return 0;\\n        \\n        int ret = str.length();\\n        for (int i = index; i < arr.size(); i++)\\n            ret = max(ret, maxLength(arr, str+arr[i], i+1));\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr, string str = \"\", int index = 0) {\\n\\t    //Use set to check if the string contains all unique characters\\n        unordered_set<char>s(str.begin(), str.end());\\n        if (s.size() != ((int)str.length())) \\n            return 0;\\n        \\n        int ret = str.length();\\n        for (int i = index; i < arr.size(); i++)\\n            ret = max(ret, maxLength(arr, str+arr[i], i+1));\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737493,
                "title": "python-c-java-rust-0-ms-bit-set-operations-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs bit & set operations. Time complexity is exponential: **O(expN)**. Space complexity is exponential: **O(expN)**. \\n\\n| **Language** | [**Python**](https://leetcode.com/submissions/detail/828975733/) | [**C++**](https://leetcode.com/submissions/detail/828974283/) | [**Java**](https://leetcode.com/submissions/detail/829255644/) | [**Rust**](https://leetcode.com/submissions/detail/828985984/) | \\n|---|---|---|---|---|\\n| **Runtime** | **78 ms (98.70%)** | **0 ms (100.00%)** | **10 ms (90.18%)** | **0 ms (100.00%)** |\\n| **Memory** | **51.9 MB  (11.15%)** | **9.7 MB (74.27%)** | **42.1 MB  (88.06%)** | **2.2 MB  (33.33%)** |\\n\\n<iframe src=\"https://leetcode.com/playground/75txHQDx/shared\" frameBorder=\"0\" width=\"800\" height=\"660\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs bit & set operations. Time complexity is exponential: **O(expN)**. Space complexity is exponential: **O(expN)**. \\n\\n| **Language** | [**Python**](https://leetcode.com/submissions/detail/828975733/) | [**C++**](https://leetcode.com/submissions/detail/828974283/) | [**Java**](https://leetcode.com/submissions/detail/829255644/) | [**Rust**](https://leetcode.com/submissions/detail/828985984/) | \\n|---|---|---|---|---|\\n| **Runtime** | **78 ms (98.70%)** | **0 ms (100.00%)** | **10 ms (90.18%)** | **0 ms (100.00%)** |\\n| **Memory** | **51.9 MB  (11.15%)** | **9.7 MB (74.27%)** | **42.1 MB  (88.06%)** | **2.2 MB  (33.33%)** |\\n\\n<iframe src=\"https://leetcode.com/playground/75txHQDx/shared\" frameBorder=\"0\" width=\"800\" height=\"660\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1478384,
                "title": "c-python-simple-bitmasking-clean-concise",
                "content": "**Idea**\\n- The idea is that we try all possible subset of `arr` by using Bitmasking, same with **[78. Subsets](https://leetcode.com/problems/subsets/)**.\\n- Let `mask` represent the appearance of `arr[i]`, ith bit of mask = 1 means there exists `arr[i]`.\\n- There are total `2^n` bitmasking states: `0..000`, `0..001`, `0..010`, ..., `1..111`.\\n- For each subsets of `arr`, we check if it can form a valid string? If we can form then we update the maximum length so far.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        n = len(arr)\\n        ans = 0\\n        for mask in range(1 << n):\\n            seen = set()\\n            isValid = True\\n            strSize = 0\\n            for i in range(n):\\n                if (mask >> i) & 1 == 0: continue\\n                for c in arr[i]:\\n                    if c in seen:   # If c is already existed then it\\'s invalid subsequence.\\n                        isValid = False\\n                        break\\n                    seen.add(c)  # mark as character `c` is already seen\\n                    strSize += 1\\n                if not isValid: break  # prune when there is a duplicate\\n            if isValid and strSize > ans:\\n                ans = strSize\\n        return ans\\n```\\n\\n**C++**\\n```c++\\nclass Solution { // 36 ms, faster than 66.95%\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n = arr.size(), allMask = 1 << n, ans = 0;\\n        for (int mask = 0; mask < allMask; ++mask) {\\n            int strSize = 0;\\n            int seen = 0; // the mask to check duplicate chars when forming string\\n            bool isValid = true;\\n            for (int i = 0; i < n; ++i) {\\n                if (((mask >> i) & 1) == 0) continue;\\n                for (char c : arr[i]) {\\n                    int j = c - \\'a\\';\\n                    if ((seen >> j) & 1) { // If c is already existed then it\\'s invalid subsequence.\\n                        isValid = false;\\n                        break;\\n                    }\\n                    seen = seen | (1 << j); // mark as character `c` is already seen\\n                    strSize += 1;\\n                }\\n                if (!isValid) break; //  prune when there is a duplicate\\n            }\\n            if (isValid && strSize > ans) ans = strSize;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nComplexity:\\n- Time: `O(2^n * (26 + n))`, where `n <= 16` is length of `arr` array.\\n\\t- There is `2^n` bitmask states.\\n\\t- There are up to 26 distinct characters we can form.\\n- Space: `O(26)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        n = len(arr)\\n        ans = 0\\n        for mask in range(1 << n):\\n            seen = set()\\n            isValid = True\\n            strSize = 0\\n            for i in range(n):\\n                if (mask >> i) & 1 == 0: continue\\n                for c in arr[i]:\\n                    if c in seen:   # If c is already existed then it\\'s invalid subsequence.\\n                        isValid = False\\n                        break\\n                    seen.add(c)  # mark as character `c` is already seen\\n                    strSize += 1\\n                if not isValid: break  # prune when there is a duplicate\\n            if isValid and strSize > ans:\\n                ans = strSize\\n        return ans\\n```\n```c++\\nclass Solution { // 36 ms, faster than 66.95%\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n = arr.size(), allMask = 1 << n, ans = 0;\\n        for (int mask = 0; mask < allMask; ++mask) {\\n            int strSize = 0;\\n            int seen = 0; // the mask to check duplicate chars when forming string\\n            bool isValid = true;\\n            for (int i = 0; i < n; ++i) {\\n                if (((mask >> i) & 1) == 0) continue;\\n                for (char c : arr[i]) {\\n                    int j = c - \\'a\\';\\n                    if ((seen >> j) & 1) { // If c is already existed then it\\'s invalid subsequence.\\n                        isValid = false;\\n                        break;\\n                    }\\n                    seen = seen | (1 << j); // mark as character `c` is already seen\\n                    strSize += 1;\\n                }\\n                if (!isValid) break; //  prune when there is a duplicate\\n            }\\n            if (isValid && strSize > ans) ans = strSize;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737457,
                "title": "java-clean-easy-to-understand-backtracking",
                "content": "```\\nPlease upvote if you find it helpful\\n```\\n```\\nclass Solution {\\n    int max =0;\\n    public int maxLength(List<String> arr) {\\n        backTrack(arr,\"\",0);\\n        return max;\\n    }\\n    \\n    private void backTrack(List<String> arr, String current, int start){\\n        if(max<current.length())\\n            max =current.length();\\n        for(int i=start; i<arr.size();i++){\\n            if(!isValid(current,arr.get(i))) continue;\\n            backTrack(arr,current+arr.get(i),i+1);\\n        }\\n    }\\n    \\n    private boolean isValid(String currentString, String newString){\\n        int[] array = new int[26];\\n        for(int i=0;i<newString.length();i++){\\n            if(++array[newString.charAt(i)-\\'a\\'] == 2) return false;  //to handle if the newString has duplicates then it\\'s not valid\\n            if(currentString.contains(newString.charAt(i)+\"\")) // check if the currentString contains each char from newString\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nPlease upvote if you find it helpful\\n```\n```\\nclass Solution {\\n    int max =0;\\n    public int maxLength(List<String> arr) {\\n        backTrack(arr,\"\",0);\\n        return max;\\n    }\\n    \\n    private void backTrack(List<String> arr, String current, int start){\\n        if(max<current.length())\\n            max =current.length();\\n        for(int i=start; i<arr.size();i++){\\n            if(!isValid(current,arr.get(i))) continue;\\n            backTrack(arr,current+arr.get(i),i+1);\\n        }\\n    }\\n    \\n    private boolean isValid(String currentString, String newString){\\n        int[] array = new int[26];\\n        for(int i=0;i<newString.length();i++){\\n            if(++array[newString.charAt(i)-\\'a\\'] == 2) return false;  //to handle if the newString has duplicates then it\\'s not valid\\n            if(currentString.contains(newString.charAt(i)+\"\")) // check if the currentString contains each char from newString\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631245,
                "title": "python-3-easy-code-intutive-solution",
                "content": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        \\n        uniqELements = [\\'\\']\\n        maximum = 0\\n        for i in range(len(arr)):\\n            sz = len(uniqELements)\\n            for j in range(sz):\\n                x=arr[i]+uniqELements[j]\\n                if (len(x)==len(set(x))):\\n                    uniqELements.append(x)\\n                    maximum = max(maximum,len(x))\\n        #print(uniqELements)\\n        return maximum\\n\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        \\n        uniqELements = [\\'\\']\\n        maximum = 0\\n        for i in range(len(arr)):\\n            sz = len(uniqELements)\\n            for j in range(sz):\\n                x=arr[i]+uniqELements[j]\\n                if (len(x)==len(set(x))):\\n                    uniqELements.append(x)\\n                    maximum = max(maximum,len(x))\\n        #print(uniqELements)\\n        return maximum\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 513327,
                "title": "simple-backtracking-solution",
                "content": "```\\nclass Solution {\\n    int max = 0;\\n    public int maxLength(List<String> arr) {\\n        dfs(0, arr, \"\");\\n        return max;\\n    }\\n    \\n    public void dfs(int start, List<String> arr, String str){\\n        if(!isUnique(str)){\\n            return;\\n        }\\n        max = Math.max(max, str.length());\\n        \\n        for(int i=start; i<arr.size();i++){\\n            String s = arr.get(i);\\n            dfs(i+1, arr, str + s);\\n        }\\n    }\\n    \\n    public static boolean isUnique(String s){\\n        Set<Character> set = new HashSet<Character>();\\n        \\n        for(char ch: s.toCharArray()){\\n            if(set.contains(ch)){\\n                return false;\\n            }\\n            set.add(ch);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int maxLength(List<String> arr) {\\n        dfs(0, arr, \"\");\\n        return max;\\n    }\\n    \\n    public void dfs(int start, List<String> arr, String str){\\n        if(!isUnique(str)){\\n            return;\\n        }\\n        max = Math.max(max, str.length());\\n        \\n        for(int i=start; i<arr.size();i++){\\n            String s = arr.get(i);\\n            dfs(i+1, arr, str + s);\\n        }\\n    }\\n    \\n    public static boolean isUnique(String s){\\n        Set<Character> set = new HashSet<Character>();\\n        \\n        for(char ch: s.toCharArray()){\\n            if(set.contains(ch)){\\n                return false;\\n            }\\n            set.add(ch);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782788,
                "title": "explained-my-c-solution-using-backtracking",
                "content": "```\\nclass Solution {\\n    int len{0};\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        checkLen(\"\", arr, 0);\\n        return len;\\n    }\\n    \\n    void checkLen(string str, vector<string> &arr, int itr) {\\n        if (!isUnique(str)) return;\\n        if (str.size() > len) len = str.size();\\n        for (int i = itr; i < arr.size(); i++)\\n            checkLen(str+arr[i], arr, i+1);\\n    }\\n    \\n    bool isUnique(string word) {\\n        set<char> st;\\n        for (auto ele : word) {\\n            if (st.find(ele) != st.end()) return false;\\n            st.insert(ele);\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nthe logic behind solution is straight-forward, for each possible combination of two or more (given) array elements check if \\n\\t1. all the elements are unique.\\n\\t2. the length is longest",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int len{0};\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        checkLen(\"\", arr, 0);\\n        return len;\\n    }\\n    \\n    void checkLen(string str, vector<string> &arr, int itr) {\\n        if (!isUnique(str)) return;\\n        if (str.size() > len) len = str.size();\\n        for (int i = itr; i < arr.size(); i++)\\n            checkLen(str+arr[i], arr, i+1);\\n    }\\n    \\n    bool isUnique(string word) {\\n        set<char> st;\\n        for (auto ele : word) {\\n            if (st.find(ele) != st.end()) return false;\\n            st.insert(ele);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478456,
                "title": "python-dp-on-subsets-explained",
                "content": "This problem is medium, not hard, because given constraints it is possible to do just bruteforce solution: check for every one of `2^16` subsets if concatenation have all different symbols. However we can do better.\\n\\nFirst of all, number of letters in alphabet is not big: only `26`, so we can use the idea of bitmask: encode every word with number. For example for word `dab`, we can use mask `1011` (we start from end).\\n\\n1. First of all, we take only words with different letters, and remove all others.\\n2. Next step is for every word evaluate its mask and also number of letters. We keep tuple. For example `d[1<<i] = (1011, 3)` for word `dab`, where `i` is index of this word. Why we use `1<<i`, not just `i`? You will see it later.\\n3. `dp(m)` is maximum answer we can have if we use bitmask of **words indexes** `m`. Notice, it is another bitmask, not what we discussed previously. For example, if we have `arr = [ab, cd, ef, gh]`, then `m = 1011` means that we take `ab, cd, gh` as our solution. `dp(m)` will return two values: bitmask of used letters and number of used letters.\\n4. How we can find `dp(m)`? If `m == 0`, we return `(0, 0)`. Next we find the last `1` in our `m`, usint `m & (m-1)` trick. Then we check if `m_last & d[m - prev][0] != 0`. If it is the case, it means that we have some letters repeated, so we return `(0, -10000)` in this case where `-10000` represents minus infinity. In the opposite case we return `(m_last | d[m - prev][0], bits_last + d[m - prev][1])`, because we need to turn on bits `d[m - prev][0]` in mask `m_last` and number of bits is ` bits_last + d[m - prev][1]`. Notice that we can keep in fact only one value and evaluate the second on flight, but it will not be true `O(1)`.\\n5. In the end we just check all masks `dp(x)` and return one with the biggest number of letters on.\\n\\n#### Complexity\\nIt is `O(2^n)` for time and `O(2^n)` for space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxLength(self, arr):\\n        arr = [word for word in arr if len(set(word)) == len(word)]\\n        \\n        d = {}\\n        for i, word in enumerate(arr):\\n            d[1<<i] = (sum(1<<(ord(w) - 97) for w in word), len(word))\\n\\n        @lru_cache(None)\\n        def dp(m):\\n            if m == 0: return (0, 0)\\n            prev = m & (m - 1)\\n            m_last, bits_last = dp(prev)\\n            if m_last & d[m - prev][0] != 0: return (0, -10000)\\n            return (m_last | d[m - prev][0], bits_last + d[m - prev][1])\\n        \\n        return max(dp(x)[1] for x in range(1<<len(arr)))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maxLength(self, arr):\\n        arr = [word for word in arr if len(set(word)) == len(word)]\\n        \\n        d = {}\\n        for i, word in enumerate(arr):\\n            d[1<<i] = (sum(1<<(ord(w) - 97) for w in word), len(word))\\n\\n        @lru_cache(None)\\n        def dp(m):\\n            if m == 0: return (0, 0)\\n            prev = m & (m - 1)\\n            m_last, bits_last = dp(prev)\\n            if m_last & d[m - prev][0] != 0: return (0, -10000)\\n            return (m_last | d[m - prev][0], bits_last + d[m - prev][1])\\n        \\n        return max(dp(x)[1] for x in range(1<<len(arr)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737783,
                "title": "python-s-simple-and-easy-to-understand-solution-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        n = len(arr)\\n        res = [\"\"]\\n        op = 0\\n        \\n        for word in arr:\\n            for r in res:\\n                newRes = r+word\\n                if len(newRes)!=len(set(newRes)): continue\\n                res.append(newRes)\\n                op = max(op, len(newRes))\\n        return op\\n```\\n**Visit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation:  https://www.python-techs.com/**\\n\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        n = len(arr)\\n        res = [\"\"]\\n        op = 0\\n        \\n        for word in arr:\\n            for r in res:\\n                newRes = r+word\\n                if len(newRes)!=len(set(newRes)): continue\\n                res.append(newRes)\\n                op = max(op, len(newRes))\\n        return op\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478666,
                "title": "two-approach-well-explained-97-faster",
                "content": "## IDEA:\\nSince Constraint is very less we can use O(n^2).\\n\\n### Using Recurssion :\\n*In this we will store each unique lenght substring separetly and will compare with all the possible permutation.*\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def maxLength(self,arr):\\n        \\n        unique = [\\'\\']\\n        res = 0\\n        for i in range(len(arr)):\\n            for j in range(len(unique)):\\n                local = arr[i]+unique[j]\\n                if len(local)==len(set(local)):\\n                    unique.append(local)\\n                    res=max(res,len(local))\\n        \\n        return res\\n        \\n\\n### Using Backtracking :\\n*In this we will join all coming strings with the present one and every time measure the length of formed **unique** substring.*\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tres = 0 \\n\\t\\tdef maxLength(self,arr):\\n\\t\\t\\tself.backtrack(arr,0,\"\")\\n\\t\\t\\treturn self.res\\n\\n\\t\\tdef backtrack(self,arr,ind,local):\\n\\t\\t\\tif len(local)!=len(set(local)):\\n\\t\\t\\t\\treturn\\n\\t\\t\\t\\t\\n\\t\\t\\tself.res = max(self.res,len(local))\\n\\t\\t\\tfor i in range(ind,len(arr)):\\n\\t\\t\\t\\tself.backtrack(arr,i+1,local+arr[i])\\n\\n#### Thanks and **Upvote** if you got any help or like the solutions !!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "## IDEA:\\nSince Constraint is very less we can use O(n^2).\\n\\n### Using Recurssion :\\n*In this we will store each unique lenght substring separetly and will compare with all the possible permutation.*\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def maxLength(self,arr):\\n        \\n        unique = [\\'\\']\\n        res = 0\\n        for i in range(len(arr)):\\n            for j in range(len(unique)):\\n                local = arr[i]+unique[j]\\n                if len(local)==len(set(local)):\\n                    unique.append(local)\\n                    res=max(res,len(local))\\n        \\n        return res\\n        \\n\\n### Using Backtracking :\\n*In this we will join all coming strings with the present one and every time measure the length of formed **unique** substring.*\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tres = 0 \\n\\t\\tdef maxLength(self,arr):\\n\\t\\t\\tself.backtrack(arr,0,\"\")\\n\\t\\t\\treturn self.res\\n\\n\\t\\tdef backtrack(self,arr,ind,local):\\n\\t\\t\\tif len(local)!=len(set(local)):\\n\\t\\t\\t\\treturn\\n\\t\\t\\t\\t\\n\\t\\t\\tself.res = max(self.res,len(local))\\n\\t\\t\\tfor i in range(ind,len(arr)):\\n\\t\\t\\t\\tself.backtrack(arr,i+1,local+arr[i])\\n\\n#### Thanks and **Upvote** if you got any help or like the solutions !!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 2737644,
                "title": "c-backtracking-easy-to-understand",
                "content": "* ***Backtracking***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxi = 0;\\n    \\n    // function for checking uniqueness of the string\\n    \\n    bool is_unique(string& str)\\n    {\\n        int n = str.size();\\n        \\n        // mp will store the count of all the characters in string\\n        \\n        vector<int> mp(26, 0);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[str[i] - \\'a\\']++;\\n            \\n            // if we found duplicates return false\\n            \\n            if(mp[str[i] - \\'a\\'] > 1)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void helper(vector<string>& arr, int i, int n, string curr)\\n    {\\n        // if we have got duplicate int our result then simply return\\n        \\n        if(is_unique(curr) == false)\\n            return;\\n        \\n        // base case\\n        \\n        if(i == n)\\n        {\\n            // update maxi\\n            \\n            if(curr.size() > maxi)\\n            {\\n                int size = curr.size();\\n                \\n                maxi = max(maxi, size);\\n            }\\n            \\n            return;\\n        }\\n        \\n        // we have two options either include the curr string or exclude\\n        \\n        // include the curr string\\n        \\n        helper(arr, i + 1, n, curr + arr[i]);\\n        \\n        // exclude the curr string\\n        \\n        helper(arr, i + 1, n, curr);\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        // call helper function\\n        \\n        helper(arr, 0, n, \"\");\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxi = 0;\\n    \\n    // function for checking uniqueness of the string\\n    \\n    bool is_unique(string& str)\\n    {\\n        int n = str.size();\\n        \\n        // mp will store the count of all the characters in string\\n        \\n        vector<int> mp(26, 0);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[str[i] - \\'a\\']++;\\n            \\n            // if we found duplicates return false\\n            \\n            if(mp[str[i] - \\'a\\'] > 1)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void helper(vector<string>& arr, int i, int n, string curr)\\n    {\\n        // if we have got duplicate int our result then simply return\\n        \\n        if(is_unique(curr) == false)\\n            return;\\n        \\n        // base case\\n        \\n        if(i == n)\\n        {\\n            // update maxi\\n            \\n            if(curr.size() > maxi)\\n            {\\n                int size = curr.size();\\n                \\n                maxi = max(maxi, size);\\n            }\\n            \\n            return;\\n        }\\n        \\n        // we have two options either include the curr string or exclude\\n        \\n        // include the curr string\\n        \\n        helper(arr, i + 1, n, curr + arr[i]);\\n        \\n        // exclude the curr string\\n        \\n        helper(arr, i + 1, n, curr);\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        // call helper function\\n        \\n        helper(arr, 0, n, \"\");\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737382,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n// BIT MANIPULATION SOLUTION\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int maxlength=0;\\n        int n=arr.size();\\n        int nos=pow(2,n)-1;\\n        for(int num=0;num<=nos;num++)\\n        {\\n            vector<string> temp;\\n            for(int i=0;i<n;i++)\\n            {\\n                int bit=(num&(1<<i));\\n                if(bit) temp.push_back(arr[i]);\\n            }\\n            string s1=\"\";\\n            for(int i=0;i<temp.size();i++)\\n            {\\n                s1+=temp[i];\\n            }\\n            int freq[26]={0};\\n            for(int i=0;i<s1.size();i++)\\n            {\\n                freq[s1[i]-\\'a\\']++;\\n            }\\n            int cnt=0;\\n            for(int i=0;i<26;i++)\\n            {\\n                if(freq[i]==1)\\n                {\\n                    cnt++;\\n                }\\n                else if(freq[i]>1)\\n                {\\n                    cnt=0;\\n                    break;\\n                }\\n            }\\n            maxlength=max(maxlength,cnt);            \\n        }\\n        return maxlength;\\n    }\\n};\\n```\\n```\\n//BACKTRACKING SOLUTION\\nclass Solution {\\npublic:\\n    void fun(int idx,vector<string>& arr,vector<string>& temp,int& maxlength)\\n    {\\n        if(idx==arr.size())\\n        {\\n            string s1=\"\";\\n            for(int i=0;i<temp.size();i++)\\n            {\\n                s1+=temp[i];\\n            }\\n            int freq[26]={0};\\n            for(int i=0;i<s1.size();i++)\\n            {\\n                freq[s1[i]-\\'a\\']++;\\n            }\\n            int cnt=0;\\n            for(int i=0;i<26;i++)\\n            {\\n                if(freq[i]==1)\\n                {\\n                    cnt++;\\n                }\\n                else if(freq[i]>1)\\n                {\\n                    cnt=0;\\n                    return;\\n                }\\n            }\\n            maxlength=max(maxlength,cnt);\\n            return;\\n        }\\n        temp.push_back(arr[idx]);\\n        fun(idx+1,arr,temp,maxlength);\\n        temp.pop_back();\\n        fun(idx+1,arr,temp,maxlength);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<string> temp;\\n        int maxlength=0;\\n        fun(0,arr,temp,maxlength);\\n        return maxlength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\n// BIT MANIPULATION SOLUTION\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int maxlength=0;\\n        int n=arr.size();\\n        int nos=pow(2,n)-1;\\n        for(int num=0;num<=nos;num++)\\n        {\\n            vector<string> temp;\\n            for(int i=0;i<n;i++)\\n            {\\n                int bit=(num&(1<<i));\\n                if(bit) temp.push_back(arr[i]);\\n            }\\n            string s1=\"\";\\n            for(int i=0;i<temp.size();i++)\\n            {\\n                s1+=temp[i];\\n            }\\n            int freq[26]={0};\\n            for(int i=0;i<s1.size();i++)\\n            {\\n                freq[s1[i]-\\'a\\']++;\\n            }\\n            int cnt=0;\\n            for(int i=0;i<26;i++)\\n            {\\n                if(freq[i]==1)\\n                {\\n                    cnt++;\\n                }\\n                else if(freq[i]>1)\\n                {\\n                    cnt=0;\\n                    break;\\n                }\\n            }\\n            maxlength=max(maxlength,cnt);            \\n        }\\n        return maxlength;\\n    }\\n};\\n```\n```\\n//BACKTRACKING SOLUTION\\nclass Solution {\\npublic:\\n    void fun(int idx,vector<string>& arr,vector<string>& temp,int& maxlength)\\n    {\\n        if(idx==arr.size())\\n        {\\n            string s1=\"\";\\n            for(int i=0;i<temp.size();i++)\\n            {\\n                s1+=temp[i];\\n            }\\n            int freq[26]={0};\\n            for(int i=0;i<s1.size();i++)\\n            {\\n                freq[s1[i]-\\'a\\']++;\\n            }\\n            int cnt=0;\\n            for(int i=0;i<26;i++)\\n            {\\n                if(freq[i]==1)\\n                {\\n                    cnt++;\\n                }\\n                else if(freq[i]>1)\\n                {\\n                    cnt=0;\\n                    return;\\n                }\\n            }\\n            maxlength=max(maxlength,cnt);\\n            return;\\n        }\\n        temp.push_back(arr[idx]);\\n        fun(idx+1,arr,temp,maxlength);\\n        temp.pop_back();\\n        fun(idx+1,arr,temp,maxlength);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<string> temp;\\n        int maxlength=0;\\n        fun(0,arr,temp,maxlength);\\n        return maxlength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 469555,
                "title": "javascript-simple-solution-15-lines",
                "content": "Beat 75%, not the most optimal but simple enough.\\n\\n```\\n/**\\n * @param {string[]} arr\\n * @return {number}\\n */\\nvar maxLength = function (arr) {\\n    let res = 0;\\n\\n    let solve = (start, curr) => {\\n        if (curr.length !== new Set(curr.split(\\'\\')).size) {\\n            return;\\n        }\\n        \\n        res = Math.max(res, curr.length);\\n\\n        for (let i = start; i < arr.length; i++) {\\n            solve(i + 1, `${curr}${arr[i]}`);\\n        }\\n    }\\n\\n    solve(0, \\'\\');\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} arr\\n * @return {number}\\n */\\nvar maxLength = function (arr) {\\n    let res = 0;\\n\\n    let solve = (start, curr) => {\\n        if (curr.length !== new Set(curr.split(\\'\\')).size) {\\n            return;\\n        }\\n        \\n        res = Math.max(res, curr.length);\\n\\n        for (let i = start; i < arr.length; i++) {\\n            solve(i + 1, `${curr}${arr[i]}`);\\n        }\\n    }\\n\\n    solve(0, \\'\\');\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1478533,
                "title": "c-very-easy-backtracking-sol-4ms-runtime",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    //Used to map characters\\n    int m[26];\\n    \\n    //Storing ans globally\\n    int ans=0;\\n    \\n    void fun(vector<string>& v,int st,int n)\\n    {\\n        //Used to store temp ans upto index st in vector v.\\n        int res=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            //If any character appears more than 1 time, just return and try next possibilities\\n            if(m[i]>1)return;\\n            if(m[i]==1)res++;\\n        }\\n        \\n        //Updating ans\\n        ans=max(ans,res);\\n        for(int i=st;i<n;i++)\\n        {\\n            //Including string v[i] and then calling the function again with starting index as i+1.\\n            for(char ch:v[i])m[ch-\\'a\\']++;\\n            fun(v,i+1,n);\\n            //After the function call excluding string v[i]\\n            for(char ch:v[i])m[ch-\\'a\\']--;\\n        }\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        memset(m,0,sizeof(m));\\n        ans=0;\\n        fun(arr,0,arr.size());\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote if ypu like the Sol.**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //Used to map characters\\n    int m[26];\\n    \\n    //Storing ans globally\\n    int ans=0;\\n    \\n    void fun(vector<string>& v,int st,int n)\\n    {\\n        //Used to store temp ans upto index st in vector v.\\n        int res=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            //If any character appears more than 1 time, just return and try next possibilities\\n            if(m[i]>1)return;\\n            if(m[i]==1)res++;\\n        }\\n        \\n        //Updating ans\\n        ans=max(ans,res);\\n        for(int i=st;i<n;i++)\\n        {\\n            //Including string v[i] and then calling the function again with starting index as i+1.\\n            for(char ch:v[i])m[ch-\\'a\\']++;\\n            fun(v,i+1,n);\\n            //After the function call excluding string v[i]\\n            for(char ch:v[i])m[ch-\\'a\\']--;\\n        }\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        memset(m,0,sizeof(m));\\n        ans=0;\\n        fun(arr,0,arr.size());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696020,
                "title": "a-really-easy-java-dfs-solution",
                "content": "First step: build a function to check a string if is a unique string-----> isUnique();\\nSecond step:think the backtrack step, **can it be optimized by memo array/map ? my answer is no.** Because this is a top-bottom way, which means we have to detect the answer one by one, and the previous temporary answers are not exactly useful for the next ones in later computation.\\n\\nFor example:\\n[un,iq,ue]: un\\'s answer is 2, and we can simply compute it by un.length(), there does not need a map or array to memo it...\\n\\nIf you want to use memo, I guess you may need to compute it bottom-up, which likes DP answer...\\n\\nStep 3: to write the dfs and backtrack procedures:\\n1.when index is equal to the length, then return.\\n2.After that, we check the current string cur and adding the next one to it, one by one, which is str, then continue to dfs it.\\n3. we get the maximum result ,and return it.\\n\\n\\n```\\nclass Solution {    \\n    public int maxLength(List<String> arr) {\\n        return helper(arr,0,\"\");\\n    }\\n    \\n    private int helper(List<String> arr,int index,String cur){        \\n        if(index==arr.size()){\\n            return cur.length();\\n        }     \\n        \\n        int res=cur.length();\\n        for(int i=index;i<arr.size();i++){\\n            String str=cur+arr.get(i);           \\n            if(isUnique(str)){\\n                res=Math.max(res,helper(arr,i+1,str)); \\n            }\\n            \\n        }\\n        return res;\\n    }\\n    \\n    private boolean isUnique(String s){\\n        Set<Character> set=new HashSet<>();\\n        for(char c:s.toCharArray()){\\n            if(!set.add(c)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {    \\n    public int maxLength(List<String> arr) {\\n        return helper(arr,0,\"\");\\n    }\\n    \\n    private int helper(List<String> arr,int index,String cur){        \\n        if(index==arr.size()){\\n            return cur.length();\\n        }     \\n        \\n        int res=cur.length();\\n        for(int i=index;i<arr.size();i++){\\n            String str=cur+arr.get(i);           \\n            if(isUnique(str)){\\n                res=Math.max(res,helper(arr,i+1,str)); \\n            }\\n            \\n        }\\n        return res;\\n    }\\n    \\n    private boolean isUnique(String s){\\n        Set<Character> set=new HashSet<>();\\n        for(char c:s.toCharArray()){\\n            if(!set.add(c)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318567,
                "title": "c-backtracking-hashing-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool isunique(string &s)\\n    {\\n        vector<int> v(26,0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(v[s[i]-\\'a\\']==1)\\n            {\\n                return false;\\n            }\\n            v[s[i]-\\'a\\']++;\\n        }\\n        return true;\\n    }\\n    void backtrack(vector<string>& arr,int idx,string curr_s)\\n    {\\n\\n        \\n        if(!isunique(curr_s))\\n            return;\\n        int temp=curr_s.size();\\n        ans=max(ans,temp);\\n        if(idx>=arr.size())\\n            return;\\n            \\n        \\n        backtrack(arr,idx+1,curr_s+arr[idx]);\\n        backtrack(arr,idx+1,curr_s);\\n            \\n    }\\n    int maxLength(vector<string>& arr) \\n    {\\n        backtrack(arr,0,\"\");\\n        return ans;\\n        \\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    int ans=0;\\n    bool isunique(string &s)\\n    {\\n        vector<int> v(26,0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(v[s[i]-\\'a\\']==1)\\n            {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 895232,
                "title": "python-dfs-solution-with-explaination",
                "content": "Think in terms of graph. \\nINPUT: [\"cha\", \"r\", \"act\", \"ers\"]\\n\\nMake a graph for paths starting from each word in input\\n\\n\\n```\\n1.           \"cha\"\\n\\t\\t\\t/  |  \\\\\\n\\t     \"r\" \"act\" \"ers\"\\n\\t\\t /\\\\     \\\\\\n\\t\"act\" \"ers\" \"ers\"\\n\\t\\n\\tPATHS (sub-sequences): \\n\\tcha            - No Duplicates OK : max_len = 3\\n\\tcha-r          - No Duplicates OK: max_len = 4\\n\\tcha-r-act      - Duplicate char \\'a\\' NOTOK\\n\\tcha-r-ers      - Duplicate char \\'r\\' NOTOK\\n\\tcha-act        - Duplicate char \\'a\\' NOTOK\\n\\tcha-act-ers    - Duplicate char \\'a\\',\\'c\\' NOTOK\\n\\tcha-ers        - No Duplicates OK: max_len = 6\\n```\\t\\t \\n\\nSimilarly for other paths starting with \"r\", \"act\", \"ers\"\\n```\\n2.\\t      \"r\"\\n\\t\\t  /  \\\\\\n\\t  \"act\"   \"ers\"\\n\\t  /\\n\\t  \"ers\"\\n```\\n\\n\\n```\\n3.\\t  \"act\"\\n\\t    |\\n\\t  \"ers\"\\n```\\n\\n```\\n4.\\t  \"ers\"\\n\\t  \\n```\\n\\n\\nSo, basically you just have to dfs on all words and treat them as starting word of a subsequence.\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.max_len = 0\\n        \\n    def dfs(self, arr, curr_subseq, idx):\\n        # return if duplicate characters\\n        if len(curr_subseq) != len(set(curr_subseq)):\\n            return\\n        \\n        # update max_len if  curr_subseq is maximal\\n        self.max_len = max(len(curr_subseq), self.max_len)\\n        \\n        # dfs on next subseq(s) starting from curr_subseq\\n        for i in range(idx, len(arr)):\\n            self.dfs(arr, curr_subseq+arr[i], i+1)\\n\\n    def maxLength(self, arr: List[str]) -> int:\\n        if not arr:\\n            return 0        \\n        \\n        self.dfs(arr, \"\", 0)\\n        \\n        return self.max_len\\n\\n    \\n\\n```",
                "solutionTags": [],
                "code": "```\\n1.           \"cha\"\\n\\t\\t\\t/  |  \\\\\\n\\t     \"r\" \"act\" \"ers\"\\n\\t\\t /\\\\     \\\\\\n\\t\"act\" \"ers\" \"ers\"\\n\\t\\n\\tPATHS (sub-sequences): \\n\\tcha            - No Duplicates OK : max_len = 3\\n\\tcha-r          - No Duplicates OK: max_len = 4\\n\\tcha-r-act      - Duplicate char \\'a\\' NOTOK\\n\\tcha-r-ers      - Duplicate char \\'r\\' NOTOK\\n\\tcha-act        - Duplicate char \\'a\\' NOTOK\\n\\tcha-act-ers    - Duplicate char \\'a\\',\\'c\\' NOTOK\\n\\tcha-ers        - No Duplicates OK: max_len = 6\\n```\n```\\n2.\\t      \"r\"\\n\\t\\t  /  \\\\\\n\\t  \"act\"   \"ers\"\\n\\t  /\\n\\t  \"ers\"\\n```\n```\\n3.\\t  \"act\"\\n\\t    |\\n\\t  \"ers\"\\n```\n```\\n4.\\t  \"ers\"\\n\\t  \\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.max_len = 0\\n        \\n    def dfs(self, arr, curr_subseq, idx):\\n        # return if duplicate characters\\n        if len(curr_subseq) != len(set(curr_subseq)):\\n            return\\n        \\n        # update max_len if  curr_subseq is maximal\\n        self.max_len = max(len(curr_subseq), self.max_len)\\n        \\n        # dfs on next subseq(s) starting from curr_subseq\\n        for i in range(idx, len(arr)):\\n            self.dfs(arr, curr_subseq+arr[i], i+1)\\n\\n    def maxLength(self, arr: List[str]) -> int:\\n        if not arr:\\n            return 0        \\n        \\n        self.dfs(arr, \"\", 0)\\n        \\n        return self.max_len\\n\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738434,
                "title": "shortest-recursive-solution-super-clear",
                "content": "Please upvote if you like it:\\n```csharp\\npublic int MaxLength(IList<string> arr, int i = 0, string s = \"\")\\n{\\n\\tif (s.Distinct().Count() < s.Length) return 0;\\n\\n\\tif (arr.Count == i) return s.Length;\\n\\n\\treturn Math.Max(\\n\\t\\tMaxLength(arr, i + 1, s),\\n\\t\\tMaxLength(arr, i + 1, s + arr[i])\\n\\t);\\n}\\n```\\n\\nAnd of course, we can put it all on one line, although we really shouldn\\'t:\\n```csharp\\npublic int MaxLength(IList<string> arr, int i = 0, string s = \"\") =>\\n\\ts.Distinct().Count() < s.Length ? 0 : arr.Count == i ? s.Length : Math.Max(MaxLength(arr, i + 1, s), MaxLength(arr, i + 1, s + arr[i]));\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```csharp\\npublic int MaxLength(IList<string> arr, int i = 0, string s = \"\")\\n{\\n\\tif (s.Distinct().Count() < s.Length) return 0;\\n\\n\\tif (arr.Count == i) return s.Length;\\n\\n\\treturn Math.Max(\\n\\t\\tMaxLength(arr, i + 1, s),\\n\\t\\tMaxLength(arr, i + 1, s + arr[i])\\n\\t);\\n}\\n```\n```csharp\\npublic int MaxLength(IList<string> arr, int i = 0, string s = \"\") =>\\n\\ts.Distinct().Count() < s.Length ? 0 : arr.Count == i ? s.Length : Math.Max(MaxLength(arr, i + 1, s), MaxLength(arr, i + 1, s + arr[i]));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738251,
                "title": "python-elegant-short-dp",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n^2)\\n    Memory: O(n^2)\\n    \"\"\"\\n\\n    def maxLength(self, sequences: List[str]) -> int:\\n        dp = [set()]\\n\\n        for seq in sequences:\\n            chars = set(seq)\\n\\n            if len(chars) < len(seq):\\n                continue\\n\\n            dp.extend(chars | other for other in dp if not (chars & other))\\n\\n        return max(map(len, dp))\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n^2)\\n    Memory: O(n^2)\\n    \"\"\"\\n\\n    def maxLength(self, sequences: List[str]) -> int:\\n        dp = [set()]\\n\\n        for seq in sequences:\\n            chars = set(seq)\\n\\n            if len(chars) < len(seq):\\n                continue\\n\\n            dp.extend(chars | other for other in dp if not (chars & other))\\n\\n        return max(map(len, dp))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737648,
                "title": "java-recursion",
                "content": "Steps:\\n1. This is a standard **Take** and **Not take** Recursion Problem.\\n2. At each instance when the index reaches the list size, we need to check whether the **soFar** string formed is Valid or not(Check its Uniqueness);\\n3. Return the Max of Take and Not Take.\\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return solve(arr, 0, \"\");\\n    }\\n    \\n    \\n    public int solve(List<String> arr, int i, String soFar)\\n    {\\n        if(i == arr.size())\\n        {\\n            if(isValid(soFar))\\n            {\\n                return soFar.length();\\n            }\\n            return 0;\\n        }\\n        \\n        int size1 = solve(arr, i+1, soFar);\\n        int size2 = solve(arr, i+1, soFar+arr.get(i));\\n        \\n        return Math.max(size1, size2);\\n\\n    }\\n    \\n    \\n    public boolean isValid(String s)\\n    {\\n        int[] freq = new int[26];\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            int val = s.charAt(i) - \\'a\\';\\n            freq[val]++;\\n            \\n            if(freq[val]>1)\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return solve(arr, 0, \"\");\\n    }\\n    \\n    \\n    public int solve(List<String> arr, int i, String soFar)\\n    {\\n        if(i == arr.size())\\n        {\\n            if(isValid(soFar))\\n            {\\n                return soFar.length();\\n            }\\n            return 0;\\n        }\\n        \\n        int size1 = solve(arr, i+1, soFar);\\n        int size2 = solve(arr, i+1, soFar+arr.get(i));\\n        \\n        return Math.max(size1, size2);\\n\\n    }\\n    \\n    \\n    public boolean isValid(String s)\\n    {\\n        int[] freq = new int[26];\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            int val = s.charAt(i) - \\'a\\';\\n            freq[val]++;\\n            \\n            if(freq[val]>1)\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637935,
                "title": "java-share-my-2-ms-solution-with-bitmap",
                "content": "The intuition is that since we only care about 26 letters, we can simply use an integer as a set.\\nIf we take bitwise and between two integers, we will get 0 if there is no duplicate.\\nAlso, we can just use bitwise OR to combine the previous strings. \\nBy this trick, we can avoid string add operation as well as faster inquiry for if all characters in current string is unique. \\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        int n = arr.size();\\n        int[] ans = new int[1];\\n        int[][] bitMap = new int[n][2];\\n        for (int i = 0; i < n; ++i) {\\n            int a = 0;\\n            for (char ch: arr.get(i).toCharArray()) {\\n                int bit = ch - \\'a\\';\\n                if (((a >> bit) & 1) == 1) {\\n                    a = 0;\\n                    break;\\n                }\\n                a |= (1 << bit);\\n            }\\n            bitMap[i][0] = a;\\n            bitMap[i][1] = a == 0 ? 0 : arr.get(i).length();\\n        }\\n        dfs(arr, bitMap, ans, 0, 0, 0);\\n        return ans[0];\\n    }\\n    \\n    private void dfs(List<String> arr, int[][] bitMap, int[] ans, int start, int curLen, int curBit) {\\n        if (ans[0] < curLen) ans[0] = curLen;\\n        for (int i = start; i < arr.size(); ++i) {\\n            if ((curBit & bitMap[i][0]) != 0) continue;\\n            dfs(arr, bitMap, ans, i + 1, curLen + bitMap[i][1], curBit | bitMap[i][0]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        int n = arr.size();\\n        int[] ans = new int[1];\\n        int[][] bitMap = new int[n][2];\\n        for (int i = 0; i < n; ++i) {\\n            int a = 0;\\n            for (char ch: arr.get(i).toCharArray()) {\\n                int bit = ch - \\'a\\';\\n                if (((a >> bit) & 1) == 1) {\\n                    a = 0;\\n                    break;\\n                }\\n                a |= (1 << bit);\\n            }\\n            bitMap[i][0] = a;\\n            bitMap[i][1] = a == 0 ? 0 : arr.get(i).length();\\n        }\\n        dfs(arr, bitMap, ans, 0, 0, 0);\\n        return ans[0];\\n    }\\n    \\n    private void dfs(List<String> arr, int[][] bitMap, int[] ans, int start, int curLen, int curBit) {\\n        if (ans[0] < curLen) ans[0] = curLen;\\n        for (int i = start; i < arr.size(); ++i) {\\n            if ((curBit & bitMap[i][0]) != 0) continue;\\n            dfs(arr, bitMap, ans, i + 1, curLen + bitMap[i][1], curBit | bitMap[i][0]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808791,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef maxLength(self, arr: List[str]) -> int:\\n\\t\\t\\ts = [\"\"]\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in arr:\\n\\t\\t\\t\\tif len(set(i)) == len(i):\\n\\t\\t\\t\\t\\tfor j in s[:]:\\n\\t\\t\\t\\t\\t\\tif len(i) + len(j) == len(set(i + j)):\\n\\t\\t\\t\\t\\t\\t\\ts.append(i + j)\\n\\t\\t\\t\\t\\t\\t\\tif len(i + j) > res:\\n\\t\\t\\t\\t\\t\\t\\t\\tres = len(i + j)\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maxLength(self, arr: List[str]) -> int:\\n\\t\\t\\ts = [\"\"]\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in arr:\\n\\t\\t\\t\\tif len(set(i)) == len(i):\\n\\t\\t\\t\\t\\tfor j in s[:]:\\n\\t\\t\\t\\t\\t\\tif len(i) + len(j) == len(set(i + j)):\\n\\t\\t\\t\\t\\t\\t\\ts.append(i + j)\\n\\t\\t\\t\\t\\t\\t\\tif len(i + j) > res:\\n\\t\\t\\t\\t\\t\\t\\t\\tres = len(i + j)\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2741390,
                "title": "clean-easy-recursive-solution-fully-explained-with-comments",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    int ans = 0;\\t//to calculate the length of the final target string \\n    string temp = \"\";\\n    /*we are using global variable to maintain states of the string used in recursive dfs\\n    WHY? because passing string copies in the recursive calls takes space and memory which can lead to TLE, hence\\n    we\\'re avoiding that by pushing on nd popping off the global string as required to explore all states\\n                                 DONT WORRY...explained below*/\\n\\n    void dfs(int i, vector<string> &arr)\\n    {\\n        if (i == arr.size())\\n        {\\n            /*BASE case, read this after reading below the recursive calls*/\\n            /*after all exploration we hav reached the end of the vector of strings, no new strings to add, hence we check the length of\\n            our final target string satisfying all criteria which we got this path of exploration\\n            we will get different target strings due to different paths of recursive exploration, we store the maximum of all target strings*/\\n            if (ans < temp.size()) ans = temp.size();\\n            return;\\t// we return coz no more strings in vector of strings to add\\n        }\\n        /*say we are standing at i\\'th index of vector of string....means we are standing at some string which \\n        we can add to our temp string*/\\n\\n        /*now there can be 2 possibilties, we can add the i\\'th string or not add move to the i+1\\'th string in recursive call\\n        let us explore both, starting with add case */\\n\\n        /*but lets check wether such addition is valid or not and then we add*/\\n        if (check(temp + arr[i]))\\n        {\\n            /*so now we add, that to our temp string and use that for later recursive calls, but wait we should save\\n            state of temp, WHY? I\\'ll explain do it now*/\\n            string t = temp;\\n            temp += arr[i];\\n            dfs(i + 1, arr);\\t//using new temp for exploration in the recursive calls\\n            /*now we have returned from the recursive exploration, so now we have to explore the not add case, where we dont consider the i\\'th string\\n            but we need the old temp string for that exploration, not the new temp we used for add case...hence we reassign temp to its old value \\n            and use it for not add case */\\n            temp = t;\\n        }\\n        dfs(i + 1, arr);\\t//exploring not add case\\n    }\\n\\t\\n\\tbool check(string s)\\n    {\\n        /*say we concat two strings as per question....but we need to check wether that new string  is valid or     \\n        not, hence we use a vector to maintain frequency of the alphabets, anytime we encounter a character already\\n        having frequncy 1, means we have previously encountered, hence return false */\\n        vector<int> hash(26, 0);\\n        for (auto &i: s) if (hash[i - \\'a\\']++) return false;\\n        return true;\\t//otherwise its valid string\\n    }\\n\\t\\n    int maxLength(vector<string> &arr)\\n    {\\n       \\t//recursive call to explore all possibilities of addition to the global empty string temp\\n        dfs(0, arr);\\n        return ans;\\t//after the call, our answer is stored in ans variable\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    int ans = 0;\\t//to calculate the length of the final target string \\n    string temp = \"\";\\n    /*we are using global variable to maintain states of the string used in recursive dfs\\n    WHY? because passing string copies in the recursive calls takes space and memory which can lead to TLE, hence\\n    we\\'re avoiding that by pushing on nd popping off the global string as required to explore all states\\n                                 DONT WORRY...explained below*/\\n\\n    void dfs(int i, vector<string> &arr)\\n    {\\n        if (i == arr.size())\\n        {\\n            /*BASE case, read this after reading below the recursive calls*/\\n            /*after all exploration we hav reached the end of the vector of strings, no new strings to add, hence we check the length of\\n            our final target string satisfying all criteria which we got this path of exploration\\n            we will get different target strings due to different paths of recursive exploration, we store the maximum of all target strings*/\\n            if (ans < temp.size()) ans = temp.size();\\n            return;\\t// we return coz no more strings in vector of strings to add\\n        }\\n        /*say we are standing at i\\'th index of vector of string....means we are standing at some string which \\n        we can add to our temp string*/\\n\\n        /*now there can be 2 possibilties, we can add the i\\'th string or not add move to the i+1\\'th string in recursive call\\n        let us explore both, starting with add case */\\n\\n        /*but lets check wether such addition is valid or not and then we add*/\\n        if (check(temp + arr[i]))\\n        {\\n            /*so now we add, that to our temp string and use that for later recursive calls, but wait we should save\\n            state of temp, WHY? I\\'ll explain do it now*/\\n            string t = temp;\\n            temp += arr[i];\\n            dfs(i + 1, arr);\\t//using new temp for exploration in the recursive calls\\n            /*now we have returned from the recursive exploration, so now we have to explore the not add case, where we dont consider the i\\'th string\\n            but we need the old temp string for that exploration, not the new temp we used for add case...hence we reassign temp to its old value \\n            and use it for not add case */\\n            temp = t;\\n        }\\n        dfs(i + 1, arr);\\t//exploring not add case\\n    }\\n\\t\\n\\tbool check(string s)\\n    {\\n        /*say we concat two strings as per question....but we need to check wether that new string  is valid or     \\n        not, hence we use a vector to maintain frequency of the alphabets, anytime we encounter a character already\\n        having frequncy 1, means we have previously encountered, hence return false */\\n        vector<int> hash(26, 0);\\n        for (auto &i: s) if (hash[i - \\'a\\']++) return false;\\n        return true;\\t//otherwise its valid string\\n    }\\n\\t\\n    int maxLength(vector<string> &arr)\\n    {\\n       \\t//recursive call to explore all possibilities of addition to the global empty string temp\\n        dfs(0, arr);\\n        return ans;\\t//after the call, our answer is stored in ans variable\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738368,
                "title": "c-bit-manipulation-fast-0ms-clean-code",
                "content": "Time permitting I\\'ll write up some other solutions for this problem as well, e.g. backtracking would be a common approach to take.\\n\\n# Approach 1: bitmasking and generating valid subsets (0ms)\\n\\nWe are turn the input array into bitmasks. Each character ```\\'a\\' ... \\'z\\'``` gets it\\'s own bit. With that we can quickly check with ```and``` if there is a conflict and then expand the match with ```or```. Once we have bitmasks for each element in ```arr``` we are expanding the set of possible solutions and then just look for the largest one.\\n\\n```cpp\\n    static int maxLength(const vector<string>& arr) {\\n        // Turn |arr| into bitmasks.\\n        vector<int> bms;\\n        bms.reserve(arr.size());\\n        for (const string& a : arr) {\\n            const int m = bitmask(a);\\n            if (m != -1) bms.push_back(m);\\n        }\\n        \\n        // Expand the bitmasks if there is no conflict.\\n        vector<int> as;\\n        for (int bm : bms) {\\n            int as_size = as.size();\\n            for (int i = 0; i < as_size; ++i)\\n                if (!(as[i] & bm)) as.push_back(as[i] | bm);\\n            as.push_back(bm);\\n        }\\n        \\n        // Look for the bitmask with the most bits set.\\n        int ans = 0;\\n        for (int a : as) ans = max(ans, __builtin_popcount(a));\\n        return ans;\\n    }\\n    \\n    // Turns |a| into a bitmask for each character present.\\n    //   Returns -1 if the characters are not unique.\\n    static int bitmask(const string& a) {\\n        int ans = 0;\\n        for (char ch : a) {\\n            const int mask = 1 << (ch - \\'a\\');\\n            if (ans & mask) return -1;\\n            ans |= mask;\\n        }\\n        return ans;\\n    }\\n```\\n\\nPicking up an idea from @stanislav-iablokov\\'s solution to make the conversion into a bitmask shorter, we end up this:\\n\\n```cpp\\n    static int maxLength(const vector<string>& arr) {\\n        // Turn |arr| into bitmasks.\\n        vector<int> bms;\\n        bms.reserve(arr.size());\\n        for (const string& a : arr) {\\n            int m = 0;\\n            for (char ch : a) m |= 1 << (ch - \\'a\\');\\n            // Are all the characters in |a| unique?\\n            if (__builtin_popcount(m) == size(a))\\n                bms.push_back(m);\\n        }\\n        \\n        // Expand the bitmasks if there is no conflict.\\n        vector<int> as;\\n        for (int bm : bms) {\\n            int as_size = as.size();\\n            for (int i = 0; i < as_size; ++i)\\n                if (!(as[i] & bm)) as.push_back(as[i] | bm);\\n            as.push_back(bm);\\n        }\\n        \\n        // Look for the bitmask with the most bits set.\\n        int ans = 0;\\n        for (int a : as) ans = max(ans, __builtin_popcount(a));\\n        return ans;\\n    }\\n```\\n\\nOther thing I like about @stanislav-iablokov\\'s solution is how it handles iterating over the existing part of all combinations while expanding it, instead of:\\n\\n```cpp\\n            int as_size = as.size();\\n            for (int i = 0; i < as_size; ++i)\\n                if (!(as[i] & bm)) as.push_back(as[i] | bm);\\n```\\n\\nIt does:\\n\\n```cpp\\n            for (int i = size(as) - 1; i >= 0; --i)\\n                if (!(as[i] & bm)) as.push_back(as[i] | bm);\\n```\\n\\nIt avoids the temporary variable and the order in which we look at the elements doens\\'t matter anyway.\\n\\nTODO(heder): We could consider an early exit if ```__builtin_popcount(x) == 26```, as we can not improve further.\\n\\n**Complexity Analsysis**\\nIf $$n$$ is the size of ```arr``` then the \\n  * Time complexity is $$O(2^n)$$ as we potentially creating the full powerset of ```arr```, and the same is true for the\\n  * Space complexity which is also $$O(2^n)$$.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\'a\\' ... \\'z\\'```\n```and```\n```or```\n```arr```\n```cpp\\n    static int maxLength(const vector<string>& arr) {\\n        // Turn |arr| into bitmasks.\\n        vector<int> bms;\\n        bms.reserve(arr.size());\\n        for (const string& a : arr) {\\n            const int m = bitmask(a);\\n            if (m != -1) bms.push_back(m);\\n        }\\n        \\n        // Expand the bitmasks if there is no conflict.\\n        vector<int> as;\\n        for (int bm : bms) {\\n            int as_size = as.size();\\n            for (int i = 0; i < as_size; ++i)\\n                if (!(as[i] & bm)) as.push_back(as[i] | bm);\\n            as.push_back(bm);\\n        }\\n        \\n        // Look for the bitmask with the most bits set.\\n        int ans = 0;\\n        for (int a : as) ans = max(ans, __builtin_popcount(a));\\n        return ans;\\n    }\\n    \\n    // Turns |a| into a bitmask for each character present.\\n    //   Returns -1 if the characters are not unique.\\n    static int bitmask(const string& a) {\\n        int ans = 0;\\n        for (char ch : a) {\\n            const int mask = 1 << (ch - \\'a\\');\\n            if (ans & mask) return -1;\\n            ans |= mask;\\n        }\\n        return ans;\\n    }\\n```\n```cpp\\n    static int maxLength(const vector<string>& arr) {\\n        // Turn |arr| into bitmasks.\\n        vector<int> bms;\\n        bms.reserve(arr.size());\\n        for (const string& a : arr) {\\n            int m = 0;\\n            for (char ch : a) m |= 1 << (ch - \\'a\\');\\n            // Are all the characters in |a| unique?\\n            if (__builtin_popcount(m) == size(a))\\n                bms.push_back(m);\\n        }\\n        \\n        // Expand the bitmasks if there is no conflict.\\n        vector<int> as;\\n        for (int bm : bms) {\\n            int as_size = as.size();\\n            for (int i = 0; i < as_size; ++i)\\n                if (!(as[i] & bm)) as.push_back(as[i] | bm);\\n            as.push_back(bm);\\n        }\\n        \\n        // Look for the bitmask with the most bits set.\\n        int ans = 0;\\n        for (int a : as) ans = max(ans, __builtin_popcount(a));\\n        return ans;\\n    }\\n```\n```cpp\\n            int as_size = as.size();\\n            for (int i = 0; i < as_size; ++i)\\n                if (!(as[i] & bm)) as.push_back(as[i] | bm);\\n```\n```cpp\\n            for (int i = size(as) - 1; i >= 0; --i)\\n                if (!(as[i] & bm)) as.push_back(as[i] | bm);\\n```\n```__builtin_popcount(x) == 26```\n```arr```\n```arr```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738068,
                "title": "python-simple-solution-iterate-over-all-possible-valid-combinations-beats-88",
                "content": "EDIT: We can add ```if len(string ) == len(set(string)): ```  after ``` for string in arr:``` to save some extra computations by discarding the parts which have duplicate letters. Thanks for @RezaTalebzadeh for pointing that out!\\n\\n```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        sz, combinedWords, maxLength = len(arr), [\\'\\'], 0\\n        # Iterate over every string present in arr\\n        for string in arr:\\n            # combinedWords contains all possible combinations of the strings present in arr\\n            # combinedWords array is incrementally built upon by adding the current string\\n            # in arr to all the present combinations already present in combinedWords\\n            for word in combinedWords:\\n                # add the present string to present combination\\n                resultantWord = word + string\\n                # if the combination contains duplicates, discard it\\n                if len(resultantWord) != len(set(resultantWord)):\\n                    continue\\n                # append the new combination in the list of combinations\\n                combinedWords.append(resultantWord)\\n                # update the maximum length\\n                maxLength = max(maxLength, len(resultantWord))\\n        return maxLength\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```if len(string ) == len(set(string)): ```\n``` for string in arr:```\n```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        sz, combinedWords, maxLength = len(arr), [\\'\\'], 0\\n        # Iterate over every string present in arr\\n        for string in arr:\\n            # combinedWords contains all possible combinations of the strings present in arr\\n            # combinedWords array is incrementally built upon by adding the current string\\n            # in arr to all the present combinations already present in combinedWords\\n            for word in combinedWords:\\n                # add the present string to present combination\\n                resultantWord = word + string\\n                # if the combination contains duplicates, discard it\\n                if len(resultantWord) != len(set(resultantWord)):\\n                    continue\\n                # append the new combination in the list of combinations\\n                combinedWords.append(resultantWord)\\n                # update the maximum length\\n                maxLength = max(maxLength, len(resultantWord))\\n        return maxLength\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950304,
                "title": "java-solution-81-faster",
                "content": "**One of Microsoft\\'s most asked question**\\n\\n**Upvote if u like the post**\\n```\\n\\n// create a list to store all the combination of word formed by concatenation, also include the string of arr\\n\\n// Before adding a string in the list check if the string has unique characters or not \\n\\n// Keep track of the maxLength concatenated string added in the list\\n\\nclass Solution {\\n    \\n    // check duplicacy\\n    \\n    private boolean checkUnique(String x)\\n    {\\n        int[] fq=new int[26];\\n        \\n        for(char c:x.toCharArray())\\n        {\\n            if(++fq[c-\\'a\\']>1)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    public int maxLength(List<String> arr) \\n    {\\n        List<String> list=new ArrayList<>();\\n        int ans=0;\\n        for(String str:arr)\\n        {\\n            List<String> tmp=new ArrayList<>();\\n            if(!checkUnique(str))\\n                continue;\\n            tmp.add(str); // store all combination of strings formed\\n            ans=Math.max(ans,str.length());\\n            for(String s:list)\\n            {\\n                String cur=s+str;  // combination\\n                if(checkUnique(cur))\\n                {\\n                    tmp.add(cur);\\n                    ans=Math.max(ans,cur.length());\\n                }\\n            }\\n            list.addAll(tmp);  // Main list  \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\n// create a list to store all the combination of word formed by concatenation, also include the string of arr\\n\\n// Before adding a string in the list check if the string has unique characters or not \\n\\n// Keep track of the maxLength concatenated string added in the list\\n\\nclass Solution {\\n    \\n    // check duplicacy\\n    \\n    private boolean checkUnique(String x)\\n    {\\n        int[] fq=new int[26];\\n        \\n        for(char c:x.toCharArray())\\n        {\\n            if(++fq[c-\\'a\\']>1)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    public int maxLength(List<String> arr) \\n    {\\n        List<String> list=new ArrayList<>();\\n        int ans=0;\\n        for(String str:arr)\\n        {\\n            List<String> tmp=new ArrayList<>();\\n            if(!checkUnique(str))\\n                continue;\\n            tmp.add(str); // store all combination of strings formed\\n            ans=Math.max(ans,str.length());\\n            for(String s:list)\\n            {\\n                String cur=s+str;  // combination\\n                if(checkUnique(cur))\\n                {\\n                    tmp.add(cur);\\n                    ans=Math.max(ans,cur.length());\\n                }\\n            }\\n            list.addAll(tmp);  // Main list  \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479346,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int maxUniqueChar(string s) {  // CHECKER FUNCTION\\n        int count[26] = {0};\\n        for(int i = 0; i < s.size(); i++)\\n            if(count[s[i] - \\'a\\']++ > 0) return 0;\\n        return s.size();\\n    }\\n    \\n    void solve(vector<string> &arr, int index, string curr, int &ans) {\\n        if(index == arr.size()) {            // BASE CONDITION\\n            if(maxUniqueChar(curr) > ans) {\\n            ans = curr.size();\\n            }\\n            return;\\n        }\\n        solve(arr, index+1, curr, ans); \\n        solve(arr, index+1, curr+arr[index], ans);\\n    }\\n    \\n    int maxLength(vector<string> &arr) {\\n        int ans = 0;\\n        solve(arr, 0, \"\", ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxUniqueChar(string s) {  // CHECKER FUNCTION\\n        int count[26] = {0};\\n        for(int i = 0; i < s.size(); i++)\\n            if(count[s[i] - \\'a\\']++ > 0) return 0;\\n        return s.size();\\n    }\\n    \\n    void solve(vector<string> &arr, int index, string curr, int &ans) {\\n        if(index == arr.size()) {            // BASE CONDITION\\n            if(maxUniqueChar(curr) > ans) {\\n            ans = curr.size();\\n            }\\n            return;\\n        }\\n        solve(arr, index+1, curr, ans); \\n        solve(arr, index+1, curr+arr[index], ans);\\n    }\\n    \\n    int maxLength(vector<string> &arr) {\\n        int ans = 0;\\n        solve(arr, 0, \"\", ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478746,
                "title": "100-faster-0ms-c-solution-with-explanation",
                "content": "* we need to consider alphabets to be set bits in an integer\\n* if a word contains \\'a\\' then first bit would be set ....001 similarly if a word contains both \\'a\\' and \\'b\\' then the integer would be .....011\\n* so I pushed all the integers formed in the vector v\\n* recursively checking whether I can include that particular integer\\n* so if all the bits are different in two integers then **(a^b == a|b)** so we can include that else proceed to next number\\n```\\nvector<int>v;\\nint n;\\nint ans;\\nvoid check(int ind,int cur)\\n{\\n    if(ind==n)\\n    {\\n        return ;\\n    }\\n    if((cur^v[ind])==(cur|v[ind]))\\n    {\\n        // cout<<\"hi\";\\n        ans = max(ans,__builtin_popcount(cur|v[ind]));\\n        check(ind+1,cur|v[ind]);\\n    }\\n    check(ind+1,cur);\\n}\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        v = {};\\n        ans = 0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int cur = 0;\\n            for(int j=0;j<arr[i].size();j++)\\n            {\\n                if((cur>>(arr[i][j]-\\'a\\'))&1)\\n                {\\n                    cur=0;\\n                    break;\\n                }\\n                else\\n                {\\n                    cur = cur|(1<<(arr[i][j]-\\'a\\'));\\n                }\\n            }\\n            if(cur)\\n            {\\n                // cout<<cur<<\" \";\\n                v.push_back(cur);\\n            }\\n        }\\n        n = v.size();\\n        if(n==0)\\n        {\\n            return 0;\\n        }\\n        check(0,0);\\n        \\n        // cout<<\"here\"<<(133&131072);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvector<int>v;\\nint n;\\nint ans;\\nvoid check(int ind,int cur)\\n{\\n    if(ind==n)\\n    {\\n        return ;\\n    }\\n    if((cur^v[ind])==(cur|v[ind]))\\n    {\\n        // cout<<\"hi\";\\n        ans = max(ans,__builtin_popcount(cur|v[ind]));\\n        check(ind+1,cur|v[ind]);\\n    }\\n    check(ind+1,cur);\\n}\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        v = {};\\n        ans = 0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int cur = 0;\\n            for(int j=0;j<arr[i].size();j++)\\n            {\\n                if((cur>>(arr[i][j]-\\'a\\'))&1)\\n                {\\n                    cur=0;\\n                    break;\\n                }\\n                else\\n                {\\n                    cur = cur|(1<<(arr[i][j]-\\'a\\'));\\n                }\\n            }\\n            if(cur)\\n            {\\n                // cout<<cur<<\" \";\\n                v.push_back(cur);\\n            }\\n        }\\n        n = v.size();\\n        if(n==0)\\n        {\\n            return 0;\\n        }\\n        check(0,0);\\n        \\n        // cout<<\"here\"<<(133&131072);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 546637,
                "title": "java-simple-dfs",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n    public int maxLength(List<String> arr) {\\n        dfs(arr, 0, \"\");\\n        return res;\\n    }\\n    \\n    private void dfs(List<String> l, int idx, String s) {\\n        if (unique(s)) res = Math.max(res, s.length());\\n        else return;\\n        for (int i = idx; i < l.size(); i++) {  // start with idx;\\n            if (unique(l.get(i))) dfs(l, i + 1, s + l.get(i));\\n        }\\n    }\\n    \\n    private boolean unique(String s) {\\n        int[] cnt = new int[26];\\n        for (char c : s.toCharArray()) {\\n            if (++cnt[c - \\'a\\'] > 1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\nref: https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/discuss/414180/Clean-JavaJavaScript-DFS-solution",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int maxLength(List<String> arr) {\\n        dfs(arr, 0, \"\");\\n        return res;\\n    }\\n    \\n    private void dfs(List<String> l, int idx, String s) {\\n        if (unique(s)) res = Math.max(res, s.length());\\n        else return;\\n        for (int i = idx; i < l.size(); i++) {  // start with idx;\\n            if (unique(l.get(i))) dfs(l, i + 1, s + l.get(i));\\n        }\\n    }\\n    \\n    private boolean unique(String s) {\\n        int[] cnt = new int[26];\\n        for (char c : s.toCharArray()) {\\n            if (++cnt[c - \\'a\\'] > 1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497943,
                "title": "backtracking-concise-and-clean-for-interviews",
                "content": "\\t  private int maxLen = 0;\\n\\n\\t  public int maxLength(List<String> arr) {\\n\\t\\tmaxLen = 0;\\n\\n\\t\\tSet<Character> set = new HashSet<>();\\n\\t\\thelper(set, arr, 0);\\n\\n\\t\\treturn maxLen;\\n\\t  }\\n\\n\\t  private void helper(Set<Character> set, List<String> arr, int index) {\\n\\t\\tif (index == arr.size()) {\\n\\t\\t  return;\\n\\t\\t}\\n\\n\\t\\tchar[] s = arr.get(index).toCharArray();\\n\\n\\t\\tboolean unique = true;\\n\\n\\t\\tSet<Character> chars = new HashSet<>();\\n\\t\\tfor (char ch : s) {\\n\\t\\t  if (chars.contains(ch) || set.contains(ch)) {\\n\\t\\t\\tunique = false;\\n\\t\\t\\tbreak;\\n\\t\\t  }\\n\\n\\t\\t  chars.add(ch);\\n\\t\\t}\\n\\n\\t\\thelper(set, arr, index + 1);\\n\\n\\t\\tif (unique) {\\n\\t\\t  maxLen = Math.max(maxLen, set.size() + s.length);\\n\\n\\t\\t  set.addAll(chars);\\n\\t\\t  helper(set, arr, index + 1);\\n\\t\\t  set.removeAll(chars);\\n\\t\\t}\\n\\t  }",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "\\t  private int maxLen = 0;\\n\\n\\t  public int maxLength(List<String> arr) {\\n\\t\\tmaxLen = 0;\\n\\n\\t\\tSet<Character> set = new HashSet<>();\\n\\t\\thelper(set, arr, 0);\\n\\n\\t\\treturn maxLen;\\n\\t  }\\n\\n\\t  private void helper(Set<Character> set, List<String> arr, int index) {\\n\\t\\tif (index == arr.size()) {\\n\\t\\t  return;\\n\\t\\t}\\n\\n\\t\\tchar[] s = arr.get(index).toCharArray();\\n\\n\\t\\tboolean unique = true;\\n\\n\\t\\tSet<Character> chars = new HashSet<>();\\n\\t\\tfor (char ch : s) {\\n\\t\\t  if (chars.contains(ch) || set.contains(ch)) {\\n\\t\\t\\tunique = false;\\n\\t\\t\\tbreak;\\n\\t\\t  }\\n\\n\\t\\t  chars.add(ch);\\n\\t\\t}\\n\\n\\t\\thelper(set, arr, index + 1);\\n\\n\\t\\tif (unique) {\\n\\t\\t  maxLen = Math.max(maxLen, set.size() + s.length);\\n\\n\\t\\t  set.addAll(chars);\\n\\t\\t  helper(set, arr, index + 1);\\n\\t\\t  set.removeAll(chars);\\n\\t\\t}\\n\\t  }",
                "codeTag": "Unknown"
            },
            {
                "id": 3099091,
                "title": "c-backtracking-recursion-approach-very-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple approach is backtracking ,to generate all the combinations like subsets of array.The only thing here is to compare strings just check if they contain duplicates or their combination has duplicate if yes return ,if not the keep adding them in chain to make answer maximum as possible.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo just do a simple recursion and egenearte all the combiantions possible and return if duplicate found (beacuse that will not lead to the answer,WE DONT WANT DUPLICATE CONCATENATION)\\n# Complexity\\n- Time complexity:$$O(n*n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$ Don\\'t take the recursive stack that is $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int ans=0;\\n   bool isUnique(string s){\\n       set<char>st;\\n       for(auto x:s)st.insert(x);\\n       if(s.size()==st.size())return true;\\n       return false;\\n   }\\n   void backtrack(vector<string>&arr,string temp,int start){\\n        if(!isUnique(temp) )return ;\\n        ans=max(ans,(int)temp.size());\\n         for(int i=start;i<arr.size();i++)\\n          backtrack(arr,temp+arr[i],i+1);\\n           \\n   }\\n    int maxLength(vector<string>& arr) {\\n        string s=\"\";\\n        backtrack(arr,s,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int ans=0;\\n   bool isUnique(string s){\\n       set<char>st;\\n       for(auto x:s)st.insert(x);\\n       if(s.size()==st.size())return true;\\n       return false;\\n   }\\n   void backtrack(vector<string>&arr,string temp,int start){\\n        if(!isUnique(temp) )return ;\\n        ans=max(ans,(int)temp.size());\\n         for(int i=start;i<arr.size();i++)\\n          backtrack(arr,temp+arr[i],i+1);\\n           \\n   }\\n    int maxLength(vector<string>& arr) {\\n        string s=\"\";\\n        backtrack(arr,s,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738276,
                "title": "c-use-recursion-easy-to-understand",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    \\n    bool check(string &a, string &b)\\n    {\\n        vector<int> vis(26, 0);\\n        for(auto it:a)\\n            vis[it-\\'a\\']++;\\n        \\n\\t\\t//comparing each char of string a with every char of string b\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(vis[a[i]-\\'a\\'] > 1) return false; //check whether string a contains duplicate characters\\n            for(int j=0; j<b.size(); j++)\\n            {\\n                if(a[i]==b[j]) return false; //check whether string a and b have same characters\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int f(int i, vector<string>& arr, string str)\\n    {\\n        if(i==0)\\n        {\\n            if(check(arr[0], str))\\n                return arr[0].size();\\n            return 0;\\n        }\\n        \\n        int take=0, not_take=0;\\n        \\n        not_take = 0 + f(i-1, arr, str);\\n        \\n        if(check(arr[i], str))\\n            take = arr[i].size() + f(i-1, arr, str+arr[i]);\\n        \\n        return max(not_take, take);\\n    }\\n    \\n    int maxLength(vector<string>& arr) \\n    {\\n        return f(arr.size()-1, arr, \"\");\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    \\n    bool check(string &a, string &b)\\n    {\\n        vector<int> vis(26, 0);\\n        for(auto it:a)\\n            vis[it-\\'a\\']++;\\n        \\n\\t\\t//comparing each char of string a with every char of string b\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(vis[a[i]-\\'a\\'] > 1) return false; //check whether string a contains duplicate characters\\n            for(int j=0; j<b.size(); j++)\\n            {\\n                if(a[i]==b[j]) return false; //check whether string a and b have same characters\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int f(int i, vector<string>& arr, string str)\\n    {\\n        if(i==0)\\n        {\\n            if(check(arr[0], str))\\n                return arr[0].size();\\n            return 0;\\n        }\\n        \\n        int take=0, not_take=0;\\n        \\n        not_take = 0 + f(i-1, arr, str);\\n        \\n        if(check(arr[i], str))\\n            take = arr[i].size() + f(i-1, arr, str+arr[i]);\\n        \\n        return max(not_take, take);\\n    }\\n    \\n    int maxLength(vector<string>& arr) \\n    {\\n        return f(arr.size()-1, arr, \"\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737788,
                "title": "c-bit-manipulation-10ms-well-commented-easy-solution",
                "content": "Upvote if you find this helpful. Comment if you have any doubts. \\n```\\nclass Solution {\\npublic:\\n    int solve(vector<string> &arr,int i,int vis){\\n        if(i==arr.size()){\\n            return 0 ;\\n        }\\n        int n1 = solve(arr,i+1,vis);\\n        int n2 = INT_MIN;\\n        bool flag = 0;\\n        for(int j = 0;j<arr[i].size();j++){\\n            // check if any of the character in ith string is already in the ans using bit manipulation\\n            if((vis & (1<<(arr[i][j]-\\'a\\'))) == (1<<(arr[i][j]-\\'a\\'))){\\n                flag=1;\\n                break;\\n            }\\n            // we include the particular alphabet in the ans\\n            else{\\n                vis |= (1<<(arr[i][j]-\\'a\\'));\\n            }\\n        }\\n        // if any of the ith string character is already in the ans, we cannot include that string\\n        if(flag){\\n            return n1;\\n        }\\n        // if no characters of ith string are in the ans, we take maximum of including and not including it and return max\\n        \\n        n2 = arr[i].size()+solve(arr,i+1,vis);\\n        return max(n1,n2);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        return solve(arr,0,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<string> &arr,int i,int vis){\\n        if(i==arr.size()){\\n            return 0 ;\\n        }\\n        int n1 = solve(arr,i+1,vis);\\n        int n2 = INT_MIN;\\n        bool flag = 0;\\n        for(int j = 0;j<arr[i].size();j++){\\n            // check if any of the character in ith string is already in the ans using bit manipulation\\n            if((vis & (1<<(arr[i][j]-\\'a\\'))) == (1<<(arr[i][j]-\\'a\\'))){\\n                flag=1;\\n                break;\\n            }\\n            // we include the particular alphabet in the ans\\n            else{\\n                vis |= (1<<(arr[i][j]-\\'a\\'));\\n            }\\n        }\\n        // if any of the ith string character is already in the ans, we cannot include that string\\n        if(flag){\\n            return n1;\\n        }\\n        // if no characters of ith string are in the ans, we take maximum of including and not including it and return max\\n        \\n        n2 = arr[i].size()+solve(arr,i+1,vis);\\n        return max(n1,n2);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        return solve(arr,0,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475426,
                "title": "java-simple-backtracking-using-sets-with-explanation",
                "content": "In a real interview, I would have asked for clarification: \"Can a certain string contain duplicate characters by itself?\". They should have made it clear in the sample test cases or in the description. I\\'d like to point out that in this problem, duplicate characters are allowed in input strings. For example, [\"aa\",\"bc\",\"ac\"] is a valid input.\\n\\nThe time complexity will be **O(2^n)** because I choose or not choose each string for every previous choice.\\nThe space complexity will be **O(n)** because I will keep a set of all string characters, and the longest set at any point will contain atmost 26 characters (constant).\\n\\n```\\nclass Solution {\\n        List<Set<Character>> sets = new ArrayList<>();\\n        int maxLength = 0;\\n    public int maxLength(List<String> arr) {\\n        // to make sure that terms with existing letters are not considered\\n        // keep track of seen letters\\n        // because all need to be unique, use a set\\n        // if two sets are disjoint, then combine them, or not\\n        for(String a : arr){\\n            Set<Character> curr = new HashSet<>();\\n            for(char c : a.toCharArray()){\\n                curr.add(c);\\n            }\\n            sets.add(curr);\\n        }\\n        tryConcatenations(arr, 0, new HashSet<>());\\n        \\n        return maxLength;\\n    }\\n    \\n    private void tryConcatenations(List<String> arr, int index, Set<Character> currentSet){\\n        // update maxLength to current if greater\\n\\t\\t// if any string is added, this recursive function will always be called with i+1 as index\\n\\t\\t// so, maxlength will always be updated whenever a new set of characters is added to the result\\n        maxLength = Math.max(maxLength, currentSet.size());\\n        \\n        for(int i = index; i < arr.size(); i++){\\n            // check if the string itself contains repeated characters\\n            if(arr.get(i).length() != sets.get(i).size())\\n                continue;\\n            // take this string and split its characters (done in global \"sets\")\\n            // if there is any character in current sequence then don\\'t add\\n            boolean repeats = false;\\n            for(char c : sets.get(i)){\\n                if(currentSet.contains(c)){\\n                    repeats = true;\\n                    break;\\n                }\\n            }\\n            // if unique characters then proceed\\n            if(!repeats){\\n                Set<Character> nextSet = new HashSet<>(currentSet);\\n                nextSet.addAll(sets.get(i));\\n\\t\\t\\t\\t// calling the function with the current string added\\n                tryConcatenations(arr, i+1, nextSet);\\n            }\\n        }\\n        // the case where the current string is not added will be considered in all further iterations of this loop\\n    }\\n}\\n```\\n**Please upvote if you found the solution helpful.**",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n        List<Set<Character>> sets = new ArrayList<>();\\n        int maxLength = 0;\\n    public int maxLength(List<String> arr) {\\n        // to make sure that terms with existing letters are not considered\\n        // keep track of seen letters\\n        // because all need to be unique, use a set\\n        // if two sets are disjoint, then combine them, or not\\n        for(String a : arr){\\n            Set<Character> curr = new HashSet<>();\\n            for(char c : a.toCharArray()){\\n                curr.add(c);\\n            }\\n            sets.add(curr);\\n        }\\n        tryConcatenations(arr, 0, new HashSet<>());\\n        \\n        return maxLength;\\n    }\\n    \\n    private void tryConcatenations(List<String> arr, int index, Set<Character> currentSet){\\n        // update maxLength to current if greater\\n\\t\\t// if any string is added, this recursive function will always be called with i+1 as index\\n\\t\\t// so, maxlength will always be updated whenever a new set of characters is added to the result\\n        maxLength = Math.max(maxLength, currentSet.size());\\n        \\n        for(int i = index; i < arr.size(); i++){\\n            // check if the string itself contains repeated characters\\n            if(arr.get(i).length() != sets.get(i).size())\\n                continue;\\n            // take this string and split its characters (done in global \"sets\")\\n            // if there is any character in current sequence then don\\'t add\\n            boolean repeats = false;\\n            for(char c : sets.get(i)){\\n                if(currentSet.contains(c)){\\n                    repeats = true;\\n                    break;\\n                }\\n            }\\n            // if unique characters then proceed\\n            if(!repeats){\\n                Set<Character> nextSet = new HashSet<>(currentSet);\\n                nextSet.addAll(sets.get(i));\\n\\t\\t\\t\\t// calling the function with the current string added\\n                tryConcatenations(arr, i+1, nextSet);\\n            }\\n        }\\n        // the case where the current string is not added will be considered in all further iterations of this loop\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128271,
                "title": "swift-solution",
                "content": "```swift\\nclass Solution {\\n    func maxLength(_ arr: [String]) -> Int {\\n        var map = [String: Set<Character>](), ans = 0\\n        for str in arr {\\n            let chars = Set<Character>(str)\\n            if chars.count == str.count {\\n                for (key, existedChars) in map {\\n                    if existedChars.intersection(chars).isEmpty {\\n                        let str = \"\"  + key  + str\\n                        map[str] = existedChars.union(chars)\\n                        ans = max(ans, str.count)\\n                    }\\n                }\\n                map[str] = chars\\n                ans = max(ans, str.count)\\n                if ans == 26 { return 26 }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxLength(_ arr: [String]) -> Int {\\n        var map = [String: Set<Character>](), ans = 0\\n        for str in arr {\\n            let chars = Set<Character>(str)\\n            if chars.count == str.count {\\n                for (key, existedChars) in map {\\n                    if existedChars.intersection(chars).isEmpty {\\n                        let str = \"\"  + key  + str\\n                        map[str] = existedChars.union(chars)\\n                        ans = max(ans, str.count)\\n                    }\\n                }\\n                map[str] = chars\\n                ans = max(ans, str.count)\\n                if ans == 26 { return 26 }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885317,
                "title": "python-really-simple-backtracking-solution",
                "content": "\\t\\tdef maxLength(self, arr):\\n\\t\\t\\tself.maximum = 0\\n\\n\\t\\t\\tdef backtrack(start,array,s):\\n\\t\\t\\t\\tif len(s)==len(set(s)):\\n\\t\\t\\t\\t\\tself.maximum = max(self.maximum,len(s))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tfor i in range(start,len(array)):\\n\\t\\t\\t\\t\\tbacktrack(i+1,array,s + array[i])\\n\\n\\t\\t\\tbacktrack(0,arr,\"\")\\n\\t\\t\\treturn self.maximum\\n\\t\\t\\t\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "\\t\\tdef maxLength(self, arr):\\n\\t\\t\\tself.maximum = 0\\n\\n\\t\\t\\tdef backtrack(start,array,s):\\n\\t\\t\\t\\tif len(s)==len(set(s)):\\n\\t\\t\\t\\t\\tself.maximum = max(self.maximum,len(s))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tfor i in range(start,len(array)):\\n\\t\\t\\t\\t\\tbacktrack(i+1,array,s + array[i])\\n\\n\\t\\t\\tbacktrack(0,arr,\"\")\\n\\t\\t\\treturn self.maximum\\n\\t\\t\\t\\n",
                "codeTag": "Python3"
            },
            {
                "id": 540096,
                "title": "c-100-time-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxlen = 0;\\n    void backtrack(vector<int>& maskArr, vector<int>& sizeArr, int mask, int len, int pos) {\\n      if (pos == maskArr.size()) {\\n        maxlen = max(len, maxlen);\\n        return;\\n      }\\n      backtrack(maskArr, sizeArr, mask, len, pos + 1);\\n      if ((mask & maskArr[pos]) == 0) {\\n        backtrack(maskArr, sizeArr, mask | maskArr[pos], len + sizeArr[pos], pos + 1);\\n      }\\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        vector<int> maskArr;\\n        vector<int> sizeArr;\\n        int i;\\n        for (i = 0; i < arr.size(); i++) {\\n            string s = arr[i];\\n            int mask = 0;\\n            for (char c : s) {\\n                if (mask & (1 << (c - \\'a\\'))){\\n                    mask = -1;\\n                    break;\\n                }\\n                mask |= (1 << (c - \\'a\\'));\\n            }\\n            if (mask == -1)\\n                continue;\\n            maskArr.push_back(mask);\\n            sizeArr.push_back(s.size());\\n        }\\n        backtrack(maskArr, sizeArr, 0, 0, 0);\\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxlen = 0;\\n    void backtrack(vector<int>& maskArr, vector<int>& sizeArr, int mask, int len, int pos) {\\n      if (pos == maskArr.size()) {\\n        maxlen = max(len, maxlen);\\n        return;\\n      }\\n      backtrack(maskArr, sizeArr, mask, len, pos + 1);\\n      if ((mask & maskArr[pos]) == 0) {\\n        backtrack(maskArr, sizeArr, mask | maskArr[pos], len + sizeArr[pos], pos + 1);\\n      }\\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        vector<int> maskArr;\\n        vector<int> sizeArr;\\n        int i;\\n        for (i = 0; i < arr.size(); i++) {\\n            string s = arr[i];\\n            int mask = 0;\\n            for (char c : s) {\\n                if (mask & (1 << (c - \\'a\\'))){\\n                    mask = -1;\\n                    break;\\n                }\\n                mask |= (1 << (c - \\'a\\'));\\n            }\\n            if (mask == -1)\\n                continue;\\n            maskArr.push_back(mask);\\n            sizeArr.push_back(s.size());\\n        }\\n        backtrack(maskArr, sizeArr, 0, 0, 0);\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775767,
                "title": "easy-java-solution-recursion-backtracking",
                "content": "```\\n1. First Approach :- BruteForce Approach\\nStep1 :- generate all subsequences\\nstep2 :- check each subsequences has unique character or not\\nstep3 :- maintain max variable for length of each subsequence which has unique character\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        List<String> temp = new ArrayList();\\n        List<String> store = new ArrayList();\\n        getSubsequence(arr,0,store,temp);\\n\\n        return maxLen(store,0);\\n    }\\n    void getSubsequence(List<String> arr, int index,List<String> store,List<String> temp){\\n        if(index==arr.size()){\\n            String sum = \"\";\\n            for(String s:temp){\\n                sum+=s;\\n            }\\n            store.add(sum);\\n            return;\\n        }\\n        //include\\n        temp.add(arr.get(index));\\n        getSubsequence(arr,index+1,store,temp);\\n        \\n        //exclude\\n        temp.remove(temp.size()-1);\\n        getSubsequence(arr,index+1,store,temp);\\n        \\n    }\\n    int maxLen(List<String> store, int max){\\n        int map[] = new int[26];\\n         for(int i=0; i<store.size(); i++){\\n            if(getMax(store.get(i),map)){\\n                String p = store.get(i);\\n                max = Math.max(max,p.length());\\n            }\\n        }\\n        return max;\\n    }\\n    boolean getMax(String string, int[] map){\\n        map = new int[26];\\n        for(int i=0; i<string.length(); i++){\\n            if(map[string.charAt(i)-\\'a\\']==1)return false;\\n            else\\n                map[string.charAt(i)-\\'a\\'] = 1;\\n        }\\n        return true;\\n    }\\n}\\nT.C :- 2^n(for generating subsequences) * k(max length of subsequence i.e. loop for adding each string e.g. un+iq+ue)  + 2^n(checking each subsequnce for unique character) * k(max length of subsequence)\\n      \\n2. Second Approach :- removing extra O(2^n * k) we are not first generating all subsequence this time\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        \\n        int visited[] = new int[26];\\n        return helper(arr,visited,0,0);\\n    }\\n    \\n    boolean checking(int[] visited, String CurrentString)\\n    {\\n        \\n        //self check for current string having repeated character or not\\n        int[] self = new int[26];\\n        for(int i=0; i<CurrentString.length(); i++)\\n        {\\n            if(self[CurrentString.charAt(i)-\\'a\\']==1)\\n                return false;\\n            self[CurrentString.charAt(i)-\\'a\\'] = 1;\\n        }\\n        \\n        //for checking character of Current string is present in previous String or not\\n        for(int i=0; i<CurrentString.length(); i++)\\n        {\\n            if(visited[CurrentString.charAt(i)-\\'a\\']==1)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    int helper(List<String> arr,int[] visited,int index,int length)\\n    {\\n          if(index==arr.size())\\n            return length;\\n        \\n        String CurrentString = arr.get(index);\\n        \\n//checking current string each character is previously contained or not if contain simply call for next string\\n        if(!checking(visited,CurrentString))\\n            return helper(arr,visited,index+1,length);\\n//if current string\\'s characters are not previously visited we have two option 1.pick this string for calculating length 2. not pick \\n        else{\\n            \\n            //include\\n            //first of all mark 1 in visited array for each character\\n            for(int i=0; i<CurrentString.length(); i++)\\n            {\\n                visited[CurrentString.charAt(i)-\\'a\\'] = 1;\\n            }\\n            //add that current string length into length\\n            length +=CurrentString.length();\\n            //call recursion for remaining task\\n            int ans1 = helper(arr,visited,index+1,length);\\n            \\n            //exclude\\n            //undo all changes we made\\n            for(int i=0; i<CurrentString.length(); i++)\\n            {\\n                visited[CurrentString.charAt(i)-\\'a\\'] = 0;\\n            }\\n            length-=CurrentString.length();\\n            int ans2 = helper(arr,visited,index+1,length);\\n            \\n            return Math.max(ans1,ans2);\\n            \\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n1. First Approach :- BruteForce Approach\\nStep1 :- generate all subsequences\\nstep2 :- check each subsequences has unique character or not\\nstep3 :- maintain max variable for length of each subsequence which has unique character\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        List<String> temp = new ArrayList();\\n        List<String> store = new ArrayList();\\n        getSubsequence(arr,0,store,temp);\\n\\n        return maxLen(store,0);\\n    }\\n    void getSubsequence(List<String> arr, int index,List<String> store,List<String> temp){\\n        if(index==arr.size()){\\n            String sum = \"\";\\n            for(String s:temp){\\n                sum+=s;\\n            }\\n            store.add(sum);\\n            return;\\n        }\\n        //include\\n        temp.add(arr.get(index));\\n        getSubsequence(arr,index+1,store,temp);\\n        \\n        //exclude\\n        temp.remove(temp.size()-1);\\n        getSubsequence(arr,index+1,store,temp);\\n        \\n    }\\n    int maxLen(List<String> store, int max){\\n        int map[] = new int[26];\\n         for(int i=0; i<store.size(); i++){\\n            if(getMax(store.get(i),map)){\\n                String p = store.get(i);\\n                max = Math.max(max,p.length());\\n            }\\n        }\\n        return max;\\n    }\\n    boolean getMax(String string, int[] map){\\n        map = new int[26];\\n        for(int i=0; i<string.length(); i++){\\n            if(map[string.charAt(i)-\\'a\\']==1)return false;\\n            else\\n                map[string.charAt(i)-\\'a\\'] = 1;\\n        }\\n        return true;\\n    }\\n}\\nT.C :- 2^n(for generating subsequences) * k(max length of subsequence i.e. loop for adding each string e.g. un+iq+ue)  + 2^n(checking each subsequnce for unique character) * k(max length of subsequence)\\n      \\n2. Second Approach :- removing extra O(2^n * k) we are not first generating all subsequence this time\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        \\n        int visited[] = new int[26];\\n        return helper(arr,visited,0,0);\\n    }\\n    \\n    boolean checking(int[] visited, String CurrentString)\\n    {\\n        \\n        //self check for current string having repeated character or not\\n        int[] self = new int[26];\\n        for(int i=0; i<CurrentString.length(); i++)\\n        {\\n            if(self[CurrentString.charAt(i)-\\'a\\']==1)\\n                return false;\\n            self[CurrentString.charAt(i)-\\'a\\'] = 1;\\n        }\\n        \\n        //for checking character of Current string is present in previous String or not\\n        for(int i=0; i<CurrentString.length(); i++)\\n        {\\n            if(visited[CurrentString.charAt(i)-\\'a\\']==1)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    int helper(List<String> arr,int[] visited,int index,int length)\\n    {\\n          if(index==arr.size())\\n            return length;\\n        \\n        String CurrentString = arr.get(index);\\n        \\n//checking current string each character is previously contained or not if contain simply call for next string\\n        if(!checking(visited,CurrentString))\\n            return helper(arr,visited,index+1,length);\\n//if current string\\'s characters are not previously visited we have two option 1.pick this string for calculating length 2. not pick \\n        else{\\n            \\n            //include\\n            //first of all mark 1 in visited array for each character\\n            for(int i=0; i<CurrentString.length(); i++)\\n            {\\n                visited[CurrentString.charAt(i)-\\'a\\'] = 1;\\n            }\\n            //add that current string length into length\\n            length +=CurrentString.length();\\n            //call recursion for remaining task\\n            int ans1 = helper(arr,visited,index+1,length);\\n            \\n            //exclude\\n            //undo all changes we made\\n            for(int i=0; i<CurrentString.length(); i++)\\n            {\\n                visited[CurrentString.charAt(i)-\\'a\\'] = 0;\\n            }\\n            length-=CurrentString.length();\\n            int ans2 = helper(arr,visited,index+1,length);\\n            \\n            return Math.max(ans1,ans2);\\n            \\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738530,
                "title": "c-recursion-easy-solution-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool compare(vector<int> &selected,string &currString){\\n        vector<int> selfCheck(26,0);\\n        for(int i=0;i<currString.size();i++){\\n            if(selfCheck[currString[i] - \\'a\\'] == 1) return false;\\n            selfCheck[currString[i] - \\'a\\'] = 1;\\n        }\\n        for(int i=0;i<currString.size();i++){\\n            if(selected[currString[i]-\\'a\\'] == 1) return false;\\n        }\\n        return true;\\n    }\\n    int f(int i,vector<string> &arr,vector<int> &selected,int len){\\n        if(i == arr.size()){\\n            return len;\\n        }\\n        string currString = arr[i];\\n        if(compare(selected,currString) == false){\\n            return f(i+1,arr,selected,len);\\n        }\\n        else\\n        {\\n            //pick\\n            for(int j=0;j<currString.size();j++){\\n                selected[currString[j]-\\'a\\'] = 1;\\n            }\\n            len += currString.size();\\n            int op1 = f(i+1,arr,selected,len);\\n            \\n            //skip\\n            for(int j=0;j<currString.size();j++){\\n                selected[currString[j]-\\'a\\'] = 0;\\n            }\\n            len -= currString.size();\\n            int op2 = f(i+1,arr,selected,len);\\n            \\n            return max(op1,op2);\\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<int> selected(26,0);\\n        return f(0,arr,selected,0);\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool compare(vector<int> &selected,string &currString){\\n        vector<int> selfCheck(26,0);\\n        for(int i=0;i<currString.size();i++){\\n            if(selfCheck[currString[i] - \\'a\\'] == 1) return false;\\n            selfCheck[currString[i] - \\'a\\'] = 1;\\n        }\\n        for(int i=0;i<currString.size();i++){\\n            if(selected[currString[i]-\\'a\\'] == 1) return false;\\n        }\\n        return true;\\n    }\\n    int f(int i,vector<string> &arr,vector<int> &selected,int len){\\n        if(i == arr.size()){\\n            return len;\\n        }\\n        string currString = arr[i];\\n        if(compare(selected,currString) == false){\\n            return f(i+1,arr,selected,len);\\n        }\\n        else\\n        {\\n            //pick\\n            for(int j=0;j<currString.size();j++){\\n                selected[currString[j]-\\'a\\'] = 1;\\n            }\\n            len += currString.size();\\n            int op1 = f(i+1,arr,selected,len);\\n            \\n            //skip\\n            for(int j=0;j<currString.size();j++){\\n                selected[currString[j]-\\'a\\'] = 0;\\n            }\\n            len -= currString.size();\\n            int op2 = f(i+1,arr,selected,len);\\n            \\n            return max(op1,op2);\\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<int> selected(26,0);\\n        return f(0,arr,selected,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738388,
                "title": "java-easy-to-read-code-explained",
                "content": "The code is self explanatory and written modular in functions.\\n\\n# Intuition\\n1. Sanitize input for duplicate words and bad words (word that contains duplicate characters)\\n2. Backtrack and find the largest possible solution\\n\\nWe can expand the backtrack search only if adding the word at the current index `i` doesn\\'t cause a duplicate letter to appear. This is done efficiently by casting the strings `s1` and `s2` to sets and checking the intersection.\\n\\n# Code\\n```\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        // Remove duplicate words and words with duplicate letters\\n        List<String> sanitizedArr = Set.copyOf(arr)\\n                        .stream()\\n                        .filter(this::wordWithDuplicateLetter)\\n                        .toList();\\n\\n        return maxLengthBacktrack(sanitizedArr, 0, \"\");\\n    }\\n\\n    private boolean wordWithDuplicateLetter(String s) {\\n        int[] letter = new int[26];\\n        for (char chr : s.toCharArray()) {\\n            letter[chr - \\'a\\']++;\\n            if (letter[chr - \\'a\\'] > 1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int maxLengthBacktrack(List<String> source, int index, String runningConcatenation) {\\n        if (index == source.size()) {\\n            return runningConcatenation.length();\\n        }\\n\\n        int maxLength = 1;\\n\\n        // Option 1: don\\'t concatenate\\n        maxLength = Math.max(maxLength, maxLengthBacktrack(source, index + 1, runningConcatenation));\\n\\n        // Option 2: concatenate if you can\\n        String currentWord = source.get(index);\\n        if (!hasSharedCharacters(runningConcatenation.toString(), currentWord)) {\\n            maxLength = Math.max(maxLength, maxLengthBacktrack(source, index + 1, runningConcatenation + currentWord));\\n        }\\n\\n        return maxLength;\\n    }\\n\\n    /**\\n     * We want to make this operation O(|S1| + |S2|) and not O(|S1|*|S2|) therefore working with sets is easier as it is O(1) lookup\\n     */\\n    private boolean hasSharedCharacters(String s1, String s2) {\\n        Set<String> setS1 = s1.chars().boxed().map(Character::toString).collect(Collectors.toSet());\\n        Set<String> setS2 = s2.chars().boxed().map(Character::toString).collect(Collectors.toSet());\\n        return setS1\\n                .stream()\\n                .anyMatch(setS2::contains);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        // Remove duplicate words and words with duplicate letters\\n        List<String> sanitizedArr = Set.copyOf(arr)\\n                        .stream()\\n                        .filter(this::wordWithDuplicateLetter)\\n                        .toList();\\n\\n        return maxLengthBacktrack(sanitizedArr, 0, \"\");\\n    }\\n\\n    private boolean wordWithDuplicateLetter(String s) {\\n        int[] letter = new int[26];\\n        for (char chr : s.toCharArray()) {\\n            letter[chr - \\'a\\']++;\\n            if (letter[chr - \\'a\\'] > 1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int maxLengthBacktrack(List<String> source, int index, String runningConcatenation) {\\n        if (index == source.size()) {\\n            return runningConcatenation.length();\\n        }\\n\\n        int maxLength = 1;\\n\\n        // Option 1: don\\'t concatenate\\n        maxLength = Math.max(maxLength, maxLengthBacktrack(source, index + 1, runningConcatenation));\\n\\n        // Option 2: concatenate if you can\\n        String currentWord = source.get(index);\\n        if (!hasSharedCharacters(runningConcatenation.toString(), currentWord)) {\\n            maxLength = Math.max(maxLength, maxLengthBacktrack(source, index + 1, runningConcatenation + currentWord));\\n        }\\n\\n        return maxLength;\\n    }\\n\\n    /**\\n     * We want to make this operation O(|S1| + |S2|) and not O(|S1|*|S2|) therefore working with sets is easier as it is O(1) lookup\\n     */\\n    private boolean hasSharedCharacters(String s1, String s2) {\\n        Set<String> setS1 = s1.chars().boxed().map(Character::toString).collect(Collectors.toSet());\\n        Set<String> setS2 = s2.chars().boxed().map(Character::toString).collect(Collectors.toSet());\\n        return setS1\\n                .stream()\\n                .anyMatch(setS2::contains);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737338,
                "title": "daily-leetcoding-challenge-october-day-24",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1916333,
                "title": "c-backtracking-bitmasking",
                "content": "Since ther number of letters are all lower case i.e. only 26 letters, we can mask these letters with the help of an integer and find out if there is any letter in the string which is being previously used. If the answer is true we will not use that string and look for another string.\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int ans = 0;\\n    //valid finds out if the letters in the current string are used before or not \\n    bool valid(int &mask, string s)\\n\\t{\\n        for(auto x: s)\\n\\t\\t{\\n\\t\\t\\t//if we find ther letter is being used we will return false\\n            if(mask&(1<<(x - \\'a\\'))) return false;\\n\\t\\t\\t//since we are using call by refrece for mask we are simultaneously calculating the new mask\\n            mask=mask|(1<<(x-\\'a\\'));\\n        }\\n        return true;\\n    }\\n    \\n    void rec(vector<string>& arr, int idx, int mask, int length)\\n\\t{\\n\\t\\t//checking if we have encountered a larger string\\n        ans = max(length, ans);\\n\\t\\t\\n        if(idx >= arr.size()) return;\\n\\t\\t\\n        for(int i = idx; i < arr.size(); i++)\\n\\t\\t{\\n            int nmask = mask;\\n\\t\\t\\t//if the string is a valid string we will use that string and calculate further\\n            if(valid(nmask, arr[i]))\\n\\t\\t\\t{\\n                rec(arr, i+1, nmask, length+arr[i].size());\\n\\t\\t\\t}\\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        rec(arr, 0, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int ans = 0;\\n    //valid finds out if the letters in the current string are used before or not \\n    bool valid(int &mask, string s)\\n\\t{\\n        for(auto x: s)\\n\\t\\t{\\n\\t\\t\\t//if we find ther letter is being used we will return false\\n            if(mask&(1<<(x - \\'a\\'))) return false;\\n\\t\\t\\t//since we are using call by refrece for mask we are simultaneously calculating the new mask\\n            mask=mask|(1<<(x-\\'a\\'));\\n        }\\n        return true;\\n    }\\n    \\n    void rec(vector<string>& arr, int idx, int mask, int length)\\n\\t{\\n\\t\\t//checking if we have encountered a larger string\\n        ans = max(length, ans);\\n\\t\\t\\n        if(idx >= arr.size()) return;\\n\\t\\t\\n        for(int i = idx; i < arr.size(); i++)\\n\\t\\t{\\n            int nmask = mask;\\n\\t\\t\\t//if the string is a valid string we will use that string and calculate further\\n            if(valid(nmask, arr[i]))\\n\\t\\t\\t{\\n                rec(arr, i+1, nmask, length+arr[i].size());\\n\\t\\t\\t}\\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        rec(arr, 0, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375290,
                "title": "javascript-solution-backtracking-approach",
                "content": "```\\nvar maxLength = function(arr) {\\n    const n = arr.length;\\n    let maxLen = 0;\\n    \\n    backtrack(0, \"\");\\n    \\n    return maxLen;\\n    \\n    function backtrack(start, prevStr) {\\n        maxLen = Math.max(maxLen, prevStr.length);\\n        \\n        if (start === n) return; \\n        \\n        for (let i = start; i < n; i++) {\\n            const word = arr[i];\\n            \\n            if (isUnique(prevStr + word)) backtrack(i + 1, prevStr + word);\\n        }\\n    }\\n    \\n    function isUnique(str) {\\n        let bits = 0 | 0;\\n\\n        for (const char of str) {\\n            const index = char.charCodeAt(0) - 97;\\n            \\n            if (bits & (1 << index)) return false;\\n            bits |= (1 << index);\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar maxLength = function(arr) {\\n    const n = arr.length;\\n    let maxLen = 0;\\n    \\n    backtrack(0, \"\");\\n    \\n    return maxLen;\\n    \\n    function backtrack(start, prevStr) {\\n        maxLen = Math.max(maxLen, prevStr.length);\\n        \\n        if (start === n) return; \\n        \\n        for (let i = start; i < n; i++) {\\n            const word = arr[i];\\n            \\n            if (isUnique(prevStr + word)) backtrack(i + 1, prevStr + word);\\n        }\\n    }\\n    \\n    function isUnique(str) {\\n        let bits = 0 | 0;\\n\\n        for (const char of str) {\\n            const index = char.charCodeAt(0) - 97;\\n            \\n            if (bits & (1 << index)) return false;\\n            bits |= (1 << index);\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 692435,
                "title": "worst-to-best-all-solutions-368ms-to-4-ms-c",
                "content": "368 ms sol\\n====================\\n\\tinline int max(int a,int b)\\n\\t{\\n\\t\\treturn (a>b)?a:b;\\n\\t}\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tunsigned int maxVal;\\n\\t\\tbool checkunique(string& str)\\n\\t\\t{\\n\\t\\t\\tvector<int> vec(26, 0);\\n\\t\\t\\tfor (int i = 0; str[i] != \\'\\\\0\\'; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (vec[str[i] - \\'a\\'] == 1)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tvec[str[i] - \\'a\\'] = 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tint maxLength(vector<string>& arr) {\\n\\t\\t\\tmaxVal = 0;\\n\\t\\t\\tint loop_count = pow(2, arr.size());\\n\\t\\t\\tstring str;\\n\\t\\t\\tint idx = 0,j,flag;\\n\\t\\t\\tbool vec[26];\\n\\t\\t\\tfor (int i = 1; i < loop_count; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tidx = 0;\\n\\t\\t\\t\\tstr = \"\";\\n\\t\\t\\t\\tj = i;\\n\\t\\t\\t\\tflag = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < 26; k++)\\n\\t\\t\\t\\t\\tvec[k] = 0;\\n\\t\\t\\t\\twhile (j)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (j & 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tstr += arr[idx];\\n\\t\\t\\t\\t\\t\\tfor (int k = 0; arr[idx][k]; k++)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif (vec[arr[idx][k] - \\'a\\'])\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tvec[arr[idx][k] - \\'a\\'] = 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t\\tj >>= 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (flag == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmaxVal = max(maxVal, str.size());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxVal;\\n\\t\\t}\\n\\t};\\n\\n76 ms Sol\\n============\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxVal;\\n\\t\\tbool checkunique(string& str)\\n\\t\\t{\\n\\t\\t\\tvector<int> vec(26, 0);\\n\\t\\t\\tfor (int i = 0; str[i] != \\'\\\\0\\'; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (vec[str[i] - \\'a\\'] == 1)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tvec[str[i] - \\'a\\'] = 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tvoid fun(vector<string>& arr, int idx, string str)\\n\\t\\t{\\n\\t\\t\\tif (maxVal < str.size())\\n\\t\\t\\t\\tmaxVal = str.size();\\n\\t\\t\\tif (idx == arr.size())\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tstring str_included = str + arr[idx];\\n\\t\\t\\tif (checkunique(str_included))\\n\\t\\t\\t{\\n\\t\\t\\t\\tfun(arr, idx+1, str_included);\\n\\t\\t\\t}\\n\\t\\t\\t// not include\\n\\t\\t\\tfun(arr, idx + 1, str);\\n\\t\\t}\\n\\t\\tint maxLength(vector<string>& arr) {\\n\\t\\t\\tmaxVal = 0;\\n\\t\\t\\tint sz = arr.size();\\n\\t\\t\\tvector<string> new_arr;\\n\\t\\t\\tfor (int i = 0; i < sz; i++)\\n\\t\\t\\t\\tif (checkunique(arr[i]))\\n\\t\\t\\t\\t\\tnew_arr.push_back(arr[i]);\\n\\t\\t\\tfun(new_arr, 0, \"\");\\n\\t\\t\\treturn maxVal;\\n\\t\\t}\\n\\t};\\n\\t\\n52 ms Sol\\n=============\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxVal;\\n\\t\\tbool checkunique(string & str)\\n\\t\\t{\\n\\t\\t\\tvector<int> vec(26,0);\\n\\t\\t\\tfor(int i = 0 ; str[i]!= \\'\\\\0\\' ; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[str[i]-\\'a\\'] ==1)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tvec[str[i]-\\'a\\'] =1;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tvoid fun(vector<string>&arr,int idx,string str)\\n\\t\\t{\\n\\t\\t\\tif(!checkunique(str))\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tif(maxVal < str.size())\\n\\t\\t\\t\\tmaxVal = str.size();\\n\\n\\t\\t\\tfor(int i = idx+1 ; i < arr.size() ; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfun(arr,i,str+arr[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxLength(vector<string>& arr) {\\n\\t\\t\\tmaxVal = 0;\\n\\t\\t\\t//string str = arr[0];\\n\\t\\t\\tfor(int i = 0 ; i < arr.size() ; i++)\\n\\t\\t\\t\\tfun(arr,i,arr[i]);\\n\\t\\t\\treturn maxVal;\\n\\t\\t}\\n\\t};\\n28 ms Sol (whole iterative)\\n================\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tunsigned int maxVal;\\n\\t\\tint maxLength(vector<string>& arr) {\\n\\t\\t\\tmaxVal = 0;\\n\\t\\t\\tint sz = arr.size();\\n\\t\\t\\tint loop_count = pow(2, arr.size());\\n\\t\\t\\tstring str;\\n\\t\\t\\tint idx = 0,j,flag;\\n\\n\\t\\t\\tvector<int> encoded_arr(sz, 0);\\n\\t\\t\\tfor (int i = 0; i < sz; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; arr[i][j]; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint bit_val = (1 << (arr[i][j] - \\'a\\'));\\n\\t\\t\\t\\t\\tif ((encoded_arr[i] & bit_val) != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tencoded_arr[i] = -1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tencoded_arr[i] |= bit_val;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 1; i < loop_count; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tidx = 0;\\n\\t\\t\\t\\tint curr_sz = 0;\\n\\t\\t\\t\\tj = i;\\n\\t\\t\\t\\tflag = 0;\\n\\t\\t\\t\\tint encoded_local = 0;\\n\\t\\t\\t\\twhile (j)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (j & 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcurr_sz += arr[idx].size();\\n\\t\\t\\t\\t\\t\\tif (encoded_arr[idx] == -1 || encoded_local & encoded_arr[idx])\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tencoded_local |= encoded_arr[idx];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t\\tj >>= 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (flag == 0 && maxVal < curr_sz)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmaxVal = curr_sz;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxVal;\\n\\t\\t}\\n\\t};\\n4 ms Sol\\n==========\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxVal;\\n\\t\\tvoid fun(vector<string>& arr, int idx, int curr_sz, vector<int>& encoded_arr, int encoded_val)\\n\\t\\t{\\n\\t\\t\\tif (maxVal < curr_sz)\\n\\t\\t\\t\\tmaxVal = curr_sz;\\n\\t\\t\\tif (idx == arr.size())\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint new_sz = curr_sz + arr[idx].size();\\n\\t\\t\\tif (encoded_arr[idx] != -1 && (encoded_val & encoded_arr[idx]) == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfun(arr, idx + 1, new_sz, encoded_arr, encoded_val | encoded_arr[idx]);\\n\\t\\t\\t}\\n\\t\\t\\t// not include\\n\\t\\t\\tfun(arr, idx + 1, curr_sz, encoded_arr, encoded_val);\\n\\t\\t}\\n\\t\\tint maxLength(vector<string>& arr) {\\n\\t\\t\\tmaxVal = 0;\\n\\t\\t\\tint sz = arr.size();\\n\\n\\t\\t\\tvector<int> encoded_arr(sz, 0);\\n\\t\\t\\tfor (int i = 0; i < sz; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; arr[i][j]; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint bit_val = (1 << (arr[i][j] - \\'a\\'));\\n\\t\\t\\t\\t\\tif ((encoded_arr[i] & bit_val) != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tencoded_arr[i] = -1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tencoded_arr[i] |= bit_val;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfun(arr, 0, 0, encoded_arr, 0);\\n\\t\\t\\treturn maxVal;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tunsigned int maxVal;\\n\\t\\tbool checkunique(string& str)\\n\\t\\t{\\n\\t\\t\\tvector<int> vec(26, 0);\\n\\t\\t\\tfor (int i = 0; str[i] != \\'\\\\0\\'; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (vec[str[i] - \\'a\\'] == 1)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tvec[str[i] - \\'a\\'] = 1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 560423,
                "title": "java-dfs",
                "content": "```\\n\\nint max = Integer.MIN_VALUE;\\n    \\n    public int maxLength(List<String> arr) {\\n        \\n        dfs(arr,\"\",0);\\n        \\n        return max;\\n    }\\n    \\n    public void dfs(List<String> arr,String res,int index){\\n        \\n        if(unique(res)){\\n            max=Math.max(max,res.length());\\n        }\\n        else{\\n            return;\\n        }\\n        \\n        for(int i=index;i<arr.size();i++){\\n            dfs(arr,res+arr.get(i),i+1);\\n        }\\n    }\\n    \\n    \\n    public boolean unique(String res){\\n        char[] ch = new char[128];\\n        \\n        for(int i=0;i<res.length();i++){\\n            ++ch[res.charAt(i)];\\n            if(ch[res.charAt(i)]>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\nint max = Integer.MIN_VALUE;\\n    \\n    public int maxLength(List<String> arr) {\\n        \\n        dfs(arr,\"\",0);\\n        \\n        return max;\\n    }\\n    \\n    public void dfs(List<String> arr,String res,int index){\\n        \\n        if(unique(res)){\\n            max=Math.max(max,res.length());\\n        }\\n        else{\\n            return;\\n        }\\n        \\n        for(int i=index;i<arr.size();i++){\\n            dfs(arr,res+arr.get(i),i+1);\\n        }\\n    }\\n    \\n    \\n    public boolean unique(String res){\\n        char[] ch = new char[128];\\n        \\n        for(int i=0;i<res.length();i++){\\n            ++ch[res.charAt(i)];\\n            if(ch[res.charAt(i)]>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 436428,
                "title": "python-backtracking-solution-beats-100",
                "content": "```\\nclass Solution(object):\\n    def __init__(self):\\n        self.high = 0\\n        \\n    def maxLength(self, arr):\\n        self.backtrack([],0, arr)\\n        return self.high\\n    \\n    def backtrack(self,res, start, arr):\\n        self.high = max(self.high, len(\"\".join(res)))\\n        \\n        for i in range(start, len(arr)):\\n            res.append(arr[i])\\n            temp = \"\".join(res)\\n            if len(set(temp)) == len(temp):\\n                self.backtrack(res, i+1, arr )\\n            res.pop()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def __init__(self):\\n        self.high = 0\\n        \\n    def maxLength(self, arr):\\n        self.backtrack([],0, arr)\\n        return self.high\\n    \\n    def backtrack(self,res, start, arr):\\n        self.high = max(self.high, len(\"\".join(res)))\\n        \\n        for i in range(start, len(arr)):\\n            res.append(arr[i])\\n            temp = \"\".join(res)\\n            if len(set(temp)) == len(temp):\\n                self.backtrack(res, i+1, arr )\\n            res.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737867,
                "title": "java-simple-code-easy-understanding",
                "content": "Technique used here taking or not taking the particular string on the basis of some conditions.\\n```\\nclass Solution {\\n    int ans = 0;\\n    public int maxLength(List<String> arr) {\\n        HashSet<Character> hs = new HashSet<>();    // storing unique characters in it\\n        helper(arr, 0, 0, hs);\\n        return ans;\\n    }\\n    \\n    public int helper(List<String> arr, int idx, int count, HashSet<Character> hs){  // count variable store the length of unique concatenated string\\n        if(idx == arr.size()){\\n            return count;\\n        }\\n        for(int i = idx; i < arr.size(); i++){\\n            boolean flag = true;\\n            HashSet<Character> temp = new HashSet<>();\\n            for(int j = 0; j < arr.get(i).length(); j++){\\n                if(hs.contains(arr.get(i).charAt(j))){                 // if the ith string has any character which occured before in previous string then made flag false and break the loop\\n                    flag = false;\\n                    break;\\n                }\\n                temp.add(arr.get(i).charAt(j));              // here we are adding all characters in different hashset to check that any character in ith string occured 2 or more times or not.\\n                \\n            }\\n            if(flag == true && temp.size() == arr.get(i).length()){   // if ith string does not contains any character which occured before and in ith string also does not have any character which occured 2 or more times.\\n                for(int j = 0; j < arr.get(i).length(); j++){\\n                    hs.add(arr.get(i).charAt(j));\\n                }\\n                ans = Math.max(ans, helper(arr, i + 1, count + arr.get(i).length(), hs));  // if ith string  does not contains any same character then add the length of ith string in count and move to the next string \\n                for(int j = 0; j < arr.get(i).length(); j++){\\n                    hs.remove(arr.get(i).charAt(j));      // in back tracking remove those characters which we have added before\\n                }\\n            }else{\\n                ans = Math.max(ans, helper(arr, i + 1, count, hs));    // if ith string containing any same character then we move on to the next index without including the ith string.\\n            }\\n            \\n        }\\n        return ans;   // return maximum concatenated unique character string\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int maxLength(List<String> arr) {\\n        HashSet<Character> hs = new HashSet<>();    // storing unique characters in it\\n        helper(arr, 0, 0, hs);\\n        return ans;\\n    }\\n    \\n    public int helper(List<String> arr, int idx, int count, HashSet<Character> hs){  // count variable store the length of unique concatenated string\\n        if(idx == arr.size()){\\n            return count;\\n        }\\n        for(int i = idx; i < arr.size(); i++){\\n            boolean flag = true;\\n            HashSet<Character> temp = new HashSet<>();\\n            for(int j = 0; j < arr.get(i).length(); j++){\\n                if(hs.contains(arr.get(i).charAt(j))){                 // if the ith string has any character which occured before in previous string then made flag false and break the loop\\n                    flag = false;\\n                    break;\\n                }\\n                temp.add(arr.get(i).charAt(j));              // here we are adding all characters in different hashset to check that any character in ith string occured 2 or more times or not.\\n                \\n            }\\n            if(flag == true && temp.size() == arr.get(i).length()){   // if ith string does not contains any character which occured before and in ith string also does not have any character which occured 2 or more times.\\n                for(int j = 0; j < arr.get(i).length(); j++){\\n                    hs.add(arr.get(i).charAt(j));\\n                }\\n                ans = Math.max(ans, helper(arr, i + 1, count + arr.get(i).length(), hs));  // if ith string  does not contains any same character then add the length of ith string in count and move to the next string \\n                for(int j = 0; j < arr.get(i).length(); j++){\\n                    hs.remove(arr.get(i).charAt(j));      // in back tracking remove those characters which we have added before\\n                }\\n            }else{\\n                ans = Math.max(ans, helper(arr, i + 1, count, hs));    // if ith string containing any same character then we move on to the next index without including the ith string.\\n            }\\n            \\n        }\\n        return ans;   // return maximum concatenated unique character string\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737442,
                "title": "java-solution-super-easy-1-ms-runtime-upvote-if-helpful",
                "content": "# Looking for Contribution in Hacktoberfest\\n## You are welcomed to contribute in my Repos:-\\n# GITHUB LINK --> [Yaduttam95](https://github.com/Yaduttam95)\\n# All PRs are getting accepted...\\n\\n# Please upvote if Helpful\\n```\\nclass Solution {\\n    public int solve(String strs[], int no, int a[], int index, int c) {\\n        if(index==c)\\n            return 0;\\n        int x=no & a[index];\\n        if(x==0)        \\n            return Math.max(strs[index].length()+solve(strs,no^a[index],a,index+1,c),solve(strs,no,a,index+1,c));\\n        else\\n            return solve(strs,no,a,index+1,c);\\n    }\\n    public int maxLength(List<String> arr) {\\n        int a[]=new int[arr.size()];int c=0;String strs[]=new String[a.length];\\n        for(String s:arr) {\\n            int x=0,fl=0;\\n            for(char ch:s.toCharArray()) \\n            {\\n                int z=x|(1<<(ch-96));\\n                if(x==z)\\n                {\\n                    fl=1;break;                \\n                }\\n                x=z;\\n            }\\n            if(fl==0)\\n            {\\n                a[c]=x;\\n                strs[c++]=s;\\n            }\\n        }\\n        return solve(strs,0,a,0,c);\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7a44dbe0-7232-440d-99cc-d17f06ddf9ec_1666495619.2304356.png)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int solve(String strs[], int no, int a[], int index, int c) {\\n        if(index==c)\\n            return 0;\\n        int x=no & a[index];\\n        if(x==0)        \\n            return Math.max(strs[index].length()+solve(strs,no^a[index],a,index+1,c),solve(strs,no,a,index+1,c));\\n        else\\n            return solve(strs,no,a,index+1,c);\\n    }\\n    public int maxLength(List<String> arr) {\\n        int a[]=new int[arr.size()];int c=0;String strs[]=new String[a.length];\\n        for(String s:arr) {\\n            int x=0,fl=0;\\n            for(char ch:s.toCharArray()) \\n            {\\n                int z=x|(1<<(ch-96));\\n                if(x==z)\\n                {\\n                    fl=1;break;                \\n                }\\n                x=z;\\n            }\\n            if(fl==0)\\n            {\\n                a[c]=x;\\n                strs[c++]=s;\\n            }\\n        }\\n        return solve(strs,0,a,0,c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160080,
                "title": "python-easy-to-read-and-understand-recursion",
                "content": "```\\nclass Solution:\\n    def solve(self, words, index, word):\\n        if len(word) != len(set(word)):\\n            return\\n        self.ans = max(self.ans, len(word))\\n        if index == len(words):\\n            return\\n        for i in range(index, len(words)):\\n            self.solve(words, i+1, word+words[i])\\n    \\n    def maxLength(self, arr: List[str]) -> int:\\n        self.ans = 0\\n        self.solve(arr, 0, \\'\\')\\n        return self.ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self, words, index, word):\\n        if len(word) != len(set(word)):\\n            return\\n        self.ans = max(self.ans, len(word))\\n        if index == len(words):\\n            return\\n        for i in range(index, len(words)):\\n            self.solve(words, i+1, word+words[i])\\n    \\n    def maxLength(self, arr: List[str]) -> int:\\n        self.ans = 0\\n        self.solve(arr, 0, \\'\\')\\n        return self.ans",
                "codeTag": "Java"
            },
            {
                "id": 1686938,
                "title": "c-clean-and-precise-code-83-29-faster-and-98-13-less-memory-usage",
                "content": "```\\nint sol=0;\\n    void solve(vector<string>& arr, vector<int>& count, int i, int &ans)\\n    {\\n        if(i==arr.size())\\n        {\\n            sol=max(sol, ans);\\n            return;\\n        }\\n        //recursive without adding string\\n        solve(arr, count, i+1, ans);\\n        \\n        //adding string\\n        for(int k=0; k<arr[i].length(); k++)\\n        {\\n            if(count[arr[i][k]-\\'a\\']>0)\\n            {\\n                //deleting the previous added elements from count\\n                for(int j=0; j<k; j++)\\n                    count[arr[i][j]-\\'a\\']--;\\n                return;\\n            }\\n            count[arr[i][k]-\\'a\\']++;\\n        }\\n        ans+=arr[i].length();\\n        \\n        //recursive with added string\\n        solve(arr, count, i+1, ans);\\n        \\n        //backtracking\\n        ans-=arr[i].length();\\n        for(int k=0; k<arr[i].length(); k++)\\n        {\\n            count[arr[i][k]-\\'a\\']--;\\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        sol=0;\\n        int ans=0;\\n        //vector to store count of elements\\n        vector<int> count(26, 0);\\n        solve(arr, count, 0, ans);\\n        return sol;\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nint sol=0;\\n    void solve(vector<string>& arr, vector<int>& count, int i, int &ans)\\n    {\\n        if(i==arr.size())\\n        {\\n            sol=max(sol, ans);\\n            return;\\n        }\\n        //recursive without adding string\\n        solve(arr, count, i+1, ans);\\n        \\n        //adding string\\n        for(int k=0; k<arr[i].length(); k++)\\n        {\\n            if(count[arr[i][k]-\\'a\\']>0)\\n            {\\n                //deleting the previous added elements from count\\n                for(int j=0; j<k; j++)\\n                    count[arr[i][j]-\\'a\\']--;\\n                return;\\n            }\\n            count[arr[i][k]-\\'a\\']++;\\n        }\\n        ans+=arr[i].length();\\n        \\n        //recursive with added string\\n        solve(arr, count, i+1, ans);\\n        \\n        //backtracking\\n        ans-=arr[i].length();\\n        for(int k=0; k<arr[i].length(); k++)\\n        {\\n            count[arr[i][k]-\\'a\\']--;\\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        sol=0;\\n        int ans=0;\\n        //vector to store count of elements\\n        vector<int> count(26, 0);\\n        solve(arr, count, 0, ans);\\n        return sol;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1021128,
                "title": "python-dfs-explained-w-comments",
                "content": "```\\ndef maxLength(self, arr):\\n\\t# Check if the concatenated-string has unique characters or not\\n\\tdef isValid(s):\\n\\t\\tunique = [False]*26\\n\\t\\tfor i in range(len(s)):\\n\\t\\t\\tif not unique[ord(s[i])-ord(\\'a\\')]: unique[ord(s[i])-ord(\\'a\\')] = True\\n\\t\\t\\telse: return False\\n\\t\\treturn True\\n\\n\\t# Do a DFS on all the individual array elements\\n\\tdef dfs(path, l, r):\\n\\t\\t# If path has non-zero length then that means this is a potential solution\\n\\t\\tif path:\\n\\t\\t\\tself.ans = max(self.ans, len(path))\\n\\n\\t\\tfor i in range(l ,r):\\n\\t\\t\\tif isValid(path+arr[i]):\\n\\t\\t\\t\\tdfs(path+arr[i], i+1, r)\\n\\n\\tself.ans = float(\\'-inf\\')\\n\\tdfs(\"\", 0, len(arr))\\n\\n\\treturn self.ans if self.ans != float(\\'-inf\\') else 0\\n```\\n\\n**A smal note**: If you are new to backtracking questions, this can be a good question for you to practice. This questions is one solid implementation of a very common pattern which you will find in a lot of backtracking questions. I was not good at backtracking because I couldn\\'t think what should be done for such type of questions. Answer is, to find a template -- everyone has a unqiue one in their mind. You will get one imprinted too if you practice.",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\ndef maxLength(self, arr):\\n\\t# Check if the concatenated-string has unique characters or not\\n\\tdef isValid(s):\\n\\t\\tunique = [False]*26\\n\\t\\tfor i in range(len(s)):\\n\\t\\t\\tif not unique[ord(s[i])-ord(\\'a\\')]: unique[ord(s[i])-ord(\\'a\\')] = True\\n\\t\\t\\telse: return False\\n\\t\\treturn True\\n\\n\\t# Do a DFS on all the individual array elements\\n\\tdef dfs(path, l, r):\\n\\t\\t# If path has non-zero length then that means this is a potential solution\\n\\t\\tif path:\\n\\t\\t\\tself.ans = max(self.ans, len(path))\\n\\n\\t\\tfor i in range(l ,r):\\n\\t\\t\\tif isValid(path+arr[i]):\\n\\t\\t\\t\\tdfs(path+arr[i], i+1, r)\\n\\n\\tself.ans = float(\\'-inf\\')\\n\\tdfs(\"\", 0, len(arr))\\n\\n\\treturn self.ans if self.ans != float(\\'-inf\\') else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 972089,
                "title": "c-dfs-bit-masking-o-2-n-trick-to-find-duplicate-characters-with-xor-and-or",
                "content": "*Observation*\\n**If two binary representations do not contain any common bit then their XOR should be equal to their OR**\\n\\n```\\nExample\\n10101 and 01010 \\nXOR and OR are both equal [11111] , say we have 101 and 100 then its clear that XOR !=OR \\n```\\n\\n**CODE**\\n```\\n    int ans=0;\\n    void dfs(string curr,int index,vector<string> &arr,int bit){\\n        if(index==arr.size()) { \\n            ans=max(ans,(int)curr.length()); return; \\n        }\\n        dfs(curr,index+1,arr,bit); //we dont include the current string\\n        int mask=0;\\n        for(auto x:arr[index]) {\\n            if((mask&(1<<(x-\\'a\\')))!=0) return; //checks duplicates within the string like [\"aa\",\"xyx\"]\\n            mask|=1<<(x-\\'a\\');\\n        }\\n        if((mask^bit)==(mask|bit)){\\n            dfs(curr+arr[index],index+1,arr,mask|bit); //we choose the string \\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        dfs(\"\",0,arr,0);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nExample\\n10101 and 01010 \\nXOR and OR are both equal [11111] , say we have 101 and 100 then its clear that XOR !=OR \\n```\n```\\n    int ans=0;\\n    void dfs(string curr,int index,vector<string> &arr,int bit){\\n        if(index==arr.size()) { \\n            ans=max(ans,(int)curr.length()); return; \\n        }\\n        dfs(curr,index+1,arr,bit); //we dont include the current string\\n        int mask=0;\\n        for(auto x:arr[index]) {\\n            if((mask&(1<<(x-\\'a\\')))!=0) return; //checks duplicates within the string like [\"aa\",\"xyx\"]\\n            mask|=1<<(x-\\'a\\');\\n        }\\n        if((mask^bit)==(mask|bit)){\\n            dfs(curr+arr[index],index+1,arr,mask|bit); //we choose the string \\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        dfs(\"\",0,arr,0);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 687348,
                "title": "java-backtracking-simple-easy-understanding",
                "content": "Github link please start the repo :  https://github.com/chiranjeevisaride/leetcode/blob/master/1239.%20Maximum%20Length%20of%20a%20Concatenated%20String%20with%20Unique%20Characters.java\\nTime - O(n*2^n) Space: O(n)\\n\\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        int[] result = new int[1];\\n        getMaxLength(0, arr, \"\", result); \\n        return result[0];\\n    }\\n    \\n    public void getMaxLength(int index, List<String> arr, String currentStr, int[] maxLenth) {\\n        if(index == arr.size()) {\\n            if(uniqueCharCount(currentStr) > maxLenth[0])\\n                maxLenth[0] = currentStr.length();\\n            return;\\n        }\\n       \\n        getMaxLength(index + 1, arr, currentStr + arr.get(index), maxLenth);\\n        getMaxLength(index + 1, arr, currentStr, maxLenth);\\n    }\\n    \\n    public int uniqueCharCount(String currentStr) {\\n      int[] count = new int[26];\\n        for(char c : currentStr.toCharArray()) \\n            if(count[ c - \\'a\\']++ > 0) return -1;\\n           return currentStr.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        int[] result = new int[1];\\n        getMaxLength(0, arr, \"\", result); \\n        return result[0];\\n    }\\n    \\n    public void getMaxLength(int index, List<String> arr, String currentStr, int[] maxLenth) {\\n        if(index == arr.size()) {\\n            if(uniqueCharCount(currentStr) > maxLenth[0])\\n                maxLenth[0] = currentStr.length();\\n            return;\\n        }\\n       \\n        getMaxLength(index + 1, arr, currentStr + arr.get(index), maxLenth);\\n        getMaxLength(index + 1, arr, currentStr, maxLenth);\\n    }\\n    \\n    public int uniqueCharCount(String currentStr) {\\n      int[] count = new int[26];\\n        for(char c : currentStr.toCharArray()) \\n            if(count[ c - \\'a\\']++ > 0) return -1;\\n           return currentStr.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685942,
                "title": "python-short-dp-solution",
                "content": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        dp=[\\'\\']\\n        res=0\\n        for s in arr:\\n            for prev in dp:\\n                if len(set(s+prev))==len(s)+len(prev):\\n                    dp.append(s+prev)\\n                    res=max(len(s+prev),res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        dp=[\\'\\']\\n        res=0\\n        for s in arr:\\n            for prev in dp:\\n                if len(set(s+prev))==len(s)+len(prev):\\n                    dp.append(s+prev)\\n                    res=max(len(s+prev),res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502458,
                "title": "python3-backtracking",
                "content": "\\n```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        \"\"\"\\n        []\\n        un                              iq           ue    \\n        iq              ue(duplicate)\\n        ue(duplicate)\\n        we don\\'t want to going deep after we already find a duplicate\\n        \"\"\"\\n        self.output = 0\\n        self.backtracking([],arr,0)\\n        return self.output\\n    def backtracking(self,subset,arr,start):\\n        concatenate = \\'\\'.join(subset)\\n        #print(start,concatenate)\\n        if len(concatenate) == len(set(concatenate)):\\n            self.output = max(self.output, len(concatenate))\\n        for i in range(start,len(arr)):\\n            if len(concatenate) > len(set(concatenate)):\\n                break\\n            subset.append(arr[i])\\n            self.backtracking(subset,arr,i+1)\\n            subset.pop()\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        \"\"\"\\n        []\\n        un                              iq           ue    \\n        iq              ue(duplicate)\\n        ue(duplicate)\\n        we don\\'t want to going deep after we already find a duplicate\\n        \"\"\"\\n        self.output = 0\\n        self.backtracking([],arr,0)\\n        return self.output\\n    def backtracking(self,subset,arr,start):\\n        concatenate = \\'\\'.join(subset)\\n        #print(start,concatenate)\\n        if len(concatenate) == len(set(concatenate)):\\n            self.output = max(self.output, len(concatenate))\\n        for i in range(start,len(arr)):\\n            if len(concatenate) > len(set(concatenate)):\\n                break\\n            subset.append(arr[i])\\n            self.backtracking(subset,arr,i+1)\\n            subset.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743241,
                "title": "java-complex-but-understandable-solution",
                "content": "```\\nclass Solution {\\n  public int maxLength(List<String> arr) {\\n        List<Integer> result = new ArrayList<>();\\n    result.add(0);\\n    int res = 0;\\n    for (String s : arr) {\\n      int a = 0, dup = 0;\\n      for (char c : s.toCharArray()) {\\n        dup |= a & (1 << (c - \\'a\\'));\\n        a |= 1 << (c - \\'a\\');\\n      }\\n      if (dup > 0)    continue;\\n      for (int i = result.size() - 1; i >= 0; i--) {\\n        if ((result.get(i) & a) > 0) continue;\\n        result.add(result.get(i) | a);\\n        res = Math.max(res, Integer.bitCount(result.get(i) | a));\\n      }\\n    }\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int maxLength(List<String> arr) {\\n        List<Integer> result = new ArrayList<>();\\n    result.add(0);\\n    int res = 0;\\n    for (String s : arr) {\\n      int a = 0, dup = 0;\\n      for (char c : s.toCharArray()) {\\n        dup |= a & (1 << (c - \\'a\\'));\\n        a |= 1 << (c - \\'a\\');\\n      }\\n      if (dup > 0)    continue;\\n      for (int i = result.size() - 1; i >= 0; i--) {\\n        if ((result.get(i) & a) > 0) continue;\\n        result.add(result.get(i) | a);\\n        res = Math.max(res, Integer.bitCount(result.get(i) | a));\\n      }\\n    }\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739985,
                "title": "very-very-easy-solution-no-dp-only-map",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // GYAAN LEARNT BY US..\\n\\t\\n    // ZARURI NHI H KI HUM DP ME HI VALUE STORE KARVAAYE.. HUM USKI JAGAH MAP BHI USE KAR SKTE HAI .. \\n    // 2->  TLE REMOVE KARNE KI TRY KARO ..HAR STEP PAR .. JAIESE ISH QUESTIONS ME PEHLE HI CHECK KARVA LIYA KI WHTHER IT WAS VALID OR NOT .. IT HELP IN DECRING THE TIME COMPLEXITY \\n    \\n    // AND WE CANNOT USE DP IN VOID FUCNTIONS \\n    // IF QUESTIONS IF OF DP ..THEN DONT TRY TO DO IT IN VOID FUNCTIONS \\n    \\n    \\n    int maxi=0;\\n    bool check(string &s1, string &s2){\\n        string s= s1+s2;\\n        map<char, int>m;\\n        \\n        for(int i=0;i<s.length();i++){\\n            m[s[i]]++;\\n            if(m[s[i]]>1){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    int solve(int i , string s, vector<string>&arr, unordered_map<string, int>&mp){\\n        \\n        \\n        if(i>=arr.size()){\\n            \\n            int size= s.size();\\n            if(maxi<size){\\n                maxi=size;\\n            }\\n            return maxi;\\n            \\n        }\\n        \\n        \\n        if(mp.find(s) != mp.end()) return mp[s];\\n        \\n        int notTake= solve(i+1,s, arr, mp);\\n        \\n        int take=-1;\\n        if(check(s,arr[i])){\\n            take=solve(i+1, s+arr[i],arr,mp);\\n        }\\n        \\n        return max(take, notTake);\\n    }\\n    \\n    \\n    int maxLength(vector<string>& arr) {\\n        string s=\"\";\\n        \\n       \\n        unordered_map<string, int>mp;\\n        return solve(0, s, arr,mp);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // GYAAN LEARNT BY US..\\n\\t\\n    // ZARURI NHI H KI HUM DP ME HI VALUE STORE KARVAAYE.. HUM USKI JAGAH MAP BHI USE KAR SKTE HAI .. \\n    // 2->  TLE REMOVE KARNE KI TRY KARO ..HAR STEP PAR .. JAIESE ISH QUESTIONS ME PEHLE HI CHECK KARVA LIYA KI WHTHER IT WAS VALID OR NOT .. IT HELP IN DECRING THE TIME COMPLEXITY \\n    \\n    // AND WE CANNOT USE DP IN VOID FUCNTIONS \\n    // IF QUESTIONS IF OF DP ..THEN DONT TRY TO DO IT IN VOID FUNCTIONS \\n    \\n    \\n    int maxi=0;\\n    bool check(string &s1, string &s2){\\n        string s= s1+s2;\\n        map<char, int>m;\\n        \\n        for(int i=0;i<s.length();i++){\\n            m[s[i]]++;\\n            if(m[s[i]]>1){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    int solve(int i , string s, vector<string>&arr, unordered_map<string, int>&mp){\\n        \\n        \\n        if(i>=arr.size()){\\n            \\n            int size= s.size();\\n            if(maxi<size){\\n                maxi=size;\\n            }\\n            return maxi;\\n            \\n        }\\n        \\n        \\n        if(mp.find(s) != mp.end()) return mp[s];\\n        \\n        int notTake= solve(i+1,s, arr, mp);\\n        \\n        int take=-1;\\n        if(check(s,arr[i])){\\n            take=solve(i+1, s+arr[i],arr,mp);\\n        }\\n        \\n        return max(take, notTake);\\n    }\\n    \\n    \\n    int maxLength(vector<string>& arr) {\\n        string s=\"\";\\n        \\n       \\n        unordered_map<string, int>mp;\\n        return solve(0, s, arr,mp);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739599,
                "title": "simple-java-solution-recursion-backtracking",
                "content": "```\\nIF YOU LIKE THE SOLUTION PLEASE UPVOTE IT\\n```\\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return solve(arr,\"\",0);\\n    }\\n    \\n    private int solve(List<String> arr,String ans,int ind){\\n        \\n        if(ind==arr.size()){\\n            return ans.length();\\n        };\\n        \\n        char alphabet[]=new char[26];\\n        \\n        for(int i=0;i<ans.length();i++){\\n            alphabet[ans.charAt(i)-\\'a\\']++;\\n            if(alphabet[ans.charAt(i)-\\'a\\']>1) return 0;\\n        }\\n        \\n        int finalans=ans.length();\\n        \\n        for(int i=ind;i<arr.size();i++){\\n            String str=arr.get(i);\\n            \\n            boolean check=true;\\n            char temp_alphabet[]=new char[26];\\n            for(int j=0;j<str.length();j++){\\n                if(alphabet[str.charAt(j)-\\'a\\']>0 || temp_alphabet[str.charAt(j)-\\'a\\']>0){\\n                    check=false;\\n                    break;\\n                }\\n                temp_alphabet[str.charAt(j)-\\'a\\']++;\\n                \\n            }\\n            \\n            if(check){\\n                ans+=str;\\n                // System.out.println(ans);\\n                finalans=Math.max(finalans,solve(arr,ans,i+1));\\n                ans=ans.substring(0,(ans.length()-str.length()));\\n            }\\n            \\n        }\\n        return finalans;\\n        \\n        \\n        \\n    }\\n}\\n```\\n\\t",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nIF YOU LIKE THE SOLUTION PLEASE UPVOTE IT\\n```\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return solve(arr,\"\",0);\\n    }\\n    \\n    private int solve(List<String> arr,String ans,int ind){\\n        \\n        if(ind==arr.size()){\\n            return ans.length();\\n        };\\n        \\n        char alphabet[]=new char[26];\\n        \\n        for(int i=0;i<ans.length();i++){\\n            alphabet[ans.charAt(i)-\\'a\\']++;\\n            if(alphabet[ans.charAt(i)-\\'a\\']>1) return 0;\\n        }\\n        \\n        int finalans=ans.length();\\n        \\n        for(int i=ind;i<arr.size();i++){\\n            String str=arr.get(i);\\n            \\n            boolean check=true;\\n            char temp_alphabet[]=new char[26];\\n            for(int j=0;j<str.length();j++){\\n                if(alphabet[str.charAt(j)-\\'a\\']>0 || temp_alphabet[str.charAt(j)-\\'a\\']>0){\\n                    check=false;\\n                    break;\\n                }\\n                temp_alphabet[str.charAt(j)-\\'a\\']++;\\n                \\n            }\\n            \\n            if(check){\\n                ans+=str;\\n                // System.out.println(ans);\\n                finalans=Math.max(finalans,solve(arr,ans,i+1));\\n                ans=ans.substring(0,(ans.length()-str.length()));\\n            }\\n            \\n        }\\n        return finalans;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739345,
                "title": "easy-c-solution-90-faster-90-space",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string>&arr, vector<int>&taken, int pos, int &ans){\\n        if(pos==arr.size()){\\n            ans = max(ans, accumulate(taken.begin(),taken.end(),0));\\n            return ;\\n        }\\n        \\n        solve(arr,taken,pos+1,ans);\\n        \\n        int i=0;\\n        for(; i<arr[pos].size(); ++i){\\n            if(taken[arr[pos][i]-\\'a\\']) break;\\n            ++taken[arr[pos][i]-\\'a\\'];\\n        }\\n        \\n        if(i<arr[pos].size()){\\n           for(--i; i>=0; --i) --taken[arr[pos][i]-\\'a\\'];\\n            return;\\n        }\\n        \\n        solve(arr,taken,pos+1,ans);\\n        \\n        for(auto a:arr[pos])\\n            --taken[a-\\'a\\'];\\n    }\\n    int maxLength(vector<string>& arr) {\\n        int ans=0;\\n        vector<int> taken(26,0);\\n        solve(arr,taken,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string>&arr, vector<int>&taken, int pos, int &ans){\\n        if(pos==arr.size()){\\n            ans = max(ans, accumulate(taken.begin(),taken.end(),0));\\n            return ;\\n        }\\n        \\n        solve(arr,taken,pos+1,ans);\\n        \\n        int i=0;\\n        for(; i<arr[pos].size(); ++i){\\n            if(taken[arr[pos][i]-\\'a\\']) break;\\n            ++taken[arr[pos][i]-\\'a\\'];\\n        }\\n        \\n        if(i<arr[pos].size()){\\n           for(--i; i>=0; --i) --taken[arr[pos][i]-\\'a\\'];\\n            return;\\n        }\\n        \\n        solve(arr,taken,pos+1,ans);\\n        \\n        for(auto a:arr[pos])\\n            --taken[a-\\'a\\'];\\n    }\\n    int maxLength(vector<string>& arr) {\\n        int ans=0;\\n        vector<int> taken(26,0);\\n        solve(arr,taken,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738242,
                "title": "rust-iterative-dfs-with-comments",
                "content": "Build bitsets of all strings that do not contain duplicate characters. Perform a DFS to find the union of non-overlapping bitsets with the highest bit count.\\n\\nImplementation details:\\n* I like early returns when possible, so the body of the `filter_map` becomes a little bulkier than computing the bitset as the full union first and then checking if the number of bits of the bitset is equal to the string length.\\n* I prefer iterative solutions over recursion, and in this case it is pretty straight-forward. We split the search tree into one branch that includes the current set (`sets[i]`) if we can (if we can\\'t, we don\\'t branch, and that prunes the search), and one branch that doesn\\'t.\\n\\n```\\nimpl Solution {\\n    pub fn max_length(arr: Vec<String>) -> i32 {\\n        let sets = arr.into_iter().filter_map(|s| {\\n            let mut bitset = 0;\\n            for bm in s.bytes().map(|b| 1 << (b - b\\'a\\')) {\\n                if bitset & bm != 0 {\\n                    return None;\\n                } else {\\n                    bitset |= bm;\\n                }\\n            }\\n            Some(bitset)\\n        }).collect::<Vec<_>>();\\n\\n        let mut stack = vec![(0_i32, 0)];\\n        let mut rez = 0;\\n\\n        while let Some((bitset, i)) = stack.pop() {\\n            if i == sets.len() {\\n                rez = rez.max(bitset.count_ones());\\n            } else {\\n                if bitset & sets[i] == 0 {\\n                    stack.push((bitset | sets[i], i + 1));\\n                }\\n                stack.push((bitset, i + 1));\\n            }\\n        }\\n        rez as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_length(arr: Vec<String>) -> i32 {\\n        let sets = arr.into_iter().filter_map(|s| {\\n            let mut bitset = 0;\\n            for bm in s.bytes().map(|b| 1 << (b - b\\'a\\')) {\\n                if bitset & bm != 0 {\\n                    return None;\\n                } else {\\n                    bitset |= bm;\\n                }\\n            }\\n            Some(bitset)\\n        }).collect::<Vec<_>>();\\n\\n        let mut stack = vec![(0_i32, 0)];\\n        let mut rez = 0;\\n\\n        while let Some((bitset, i)) = stack.pop() {\\n            if i == sets.len() {\\n                rez = rez.max(bitset.count_ones());\\n            } else {\\n                if bitset & sets[i] == 0 {\\n                    stack.push((bitset | sets[i], i + 1));\\n                }\\n                stack.push((bitset, i + 1));\\n            }\\n        }\\n        rez as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738013,
                "title": "c-recursion-memo-simple",
                "content": "```\\n//YOUTUBE VIDEO : https://www.youtube.com/watch?v=MqMvkrkerIY\\nclass Solution {\\npublic:\\n    bool hasCommon(string &s1, string& s2) {\\n        int arr[26] = {0};\\n        \\n        for(char &ch : s1) {\\n            if(arr[ch-\\'a\\'] > 0)\\n                return true;\\n            arr[ch-\\'a\\']++;\\n        }\\n        \\n        for(char &ch : s2) {\\n            if(arr[ch-\\'a\\'] > 0)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    unordered_map<string, int> mp;\\n    \\n    int solve(int idx, vector<string>& arr, string temp, int n) {\\n        if(idx >= n)\\n            return temp.length();\\n        \\n        if(mp.find(temp) != mp.end())\\n            return mp[temp];\\n        \\n        int include = 0;\\n        int exclude = 0;\\n        if(hasCommon(arr[idx], temp)) {\\n            exclude = solve(idx+1, arr, temp, n);\\n        } else {\\n            exclude = solve(idx+1, arr, temp, n);\\n            temp += arr[idx];\\n            include = solve(idx+1, arr, temp, n);\\n        }\\n        \\n        return mp[temp] = max(include, exclude);\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        string temp = \"\";\\n        mp.clear();\\n        int n = arr.size();\\n        \\n        return solve(0, arr, temp, n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//YOUTUBE VIDEO : https://www.youtube.com/watch?v=MqMvkrkerIY\\nclass Solution {\\npublic:\\n    bool hasCommon(string &s1, string& s2) {\\n        int arr[26] = {0};\\n        \\n        for(char &ch : s1) {\\n            if(arr[ch-\\'a\\'] > 0)\\n                return true;\\n            arr[ch-\\'a\\']++;\\n        }\\n        \\n        for(char &ch : s2) {\\n            if(arr[ch-\\'a\\'] > 0)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    unordered_map<string, int> mp;\\n    \\n    int solve(int idx, vector<string>& arr, string temp, int n) {\\n        if(idx >= n)\\n            return temp.length();\\n        \\n        if(mp.find(temp) != mp.end())\\n            return mp[temp];\\n        \\n        int include = 0;\\n        int exclude = 0;\\n        if(hasCommon(arr[idx], temp)) {\\n            exclude = solve(idx+1, arr, temp, n);\\n        } else {\\n            exclude = solve(idx+1, arr, temp, n);\\n            temp += arr[idx];\\n            include = solve(idx+1, arr, temp, n);\\n        }\\n        \\n        return mp[temp] = max(include, exclude);\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        string temp = \"\";\\n        mp.clear();\\n        int n = arr.size();\\n        \\n        return solve(0, arr, temp, n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737986,
                "title": "easy-solution-in-c-o-1-sc-bit-manupulation",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int maxi=0;\\n    bool checkRepeat(string s){\\n        int check=0;\\n        for(auto it:s){\\n            int i=it-\\'a\\';\\n            if((check & 1<<i))\\n                return true;\\n            check^=1<<i;\\n        }\\n        return false;\\n    }\\n    void maxPossibleLength(int ind,int size,string s,vector<string>& arr){\\n        if(checkRepeat(s))\\n            return;\\n        if(ind==size){\\n            int n=s.size();\\n            maxi=max(maxi,n);\\n            return;\\n        }\\n        maxPossibleLength(ind+1,size,s+arr[ind],arr);\\n        maxPossibleLength(ind+1,size,s,arr);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        int size=arr.size();\\n        maxPossibleLength(0,size,\"\",arr);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi=0;\\n    bool checkRepeat(string s){\\n        int check=0;\\n        for(auto it:s){\\n            int i=it-\\'a\\';\\n            if((check & 1<<i))\\n                return true;\\n            check^=1<<i;\\n        }\\n        return false;\\n    }\\n    void maxPossibleLength(int ind,int size,string s,vector<string>& arr){\\n        if(checkRepeat(s))\\n            return;\\n        if(ind==size){\\n            int n=s.size();\\n            maxi=max(maxi,n);\\n            return;\\n        }\\n        maxPossibleLength(ind+1,size,s+arr[ind],arr);\\n        maxPossibleLength(ind+1,size,s,arr);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        int size=arr.size();\\n        maxPossibleLength(0,size,\"\",arr);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737599,
                "title": "c-easy-solution-using-set-explained-with-comments-backtracking",
                "content": "# C++ Code:\\n\\n```\\nclass Solution {\\npublic:\\n    /* app 1: using hashset & bakctracking\\n    \\n    use backtracking to try all possible combn of string that we can form\\n    input str can also have dup letters\\n    for each str. that we add to our ans,make sure all chars are unique\\n    else, skip that string (not add that str to our ans)\\n    */\\n    bool unique(string &ans){\\n        unordered_set<char> st;\\n        for(char ch: ans){\\n            //dup char exists in ans string\\n            if(st.find(ch) != st.end()){\\n                return false;\\n            }\\n            st.insert(ch);\\n        }\\n        return true;\\n    }\\n    \\n    int f(int idx,vector<string>& arr,string ans){\\n        //check if ans contains unique chars or not\\n        if(unique(ans) == false){\\n            return 0;  //skip adding this \"str\" to ans..return and stop;\\n        }\\n        \\n        int res = ans.length(); //cur. length of our \"ans\" string\\n        for(int i=idx; i<arr.size(); i++){\\n            //fun call on termination implicitly backtrack or removes the added str arr[i]\\n            res = max(res, f(i+1,arr,ans + arr[i]));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        return f(0,arr,\"\");\\n    }\\n};\\n```\\n\\ncomment and let me know if you understood the solution!!\\u2705\\u2705\\n**Please Upvote if this post been any help to you!**\\uD83D\\uDE80\\uD83D\\uDE80\\nHappy Diwali & happy coding :)\\uD83D\\uDE0A\\uD83D\\uDE0A",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /* app 1: using hashset & bakctracking\\n    \\n    use backtracking to try all possible combn of string that we can form\\n    input str can also have dup letters\\n    for each str. that we add to our ans,make sure all chars are unique\\n    else, skip that string (not add that str to our ans)\\n    */\\n    bool unique(string &ans){\\n        unordered_set<char> st;\\n        for(char ch: ans){\\n            //dup char exists in ans string\\n            if(st.find(ch) != st.end()){\\n                return false;\\n            }\\n            st.insert(ch);\\n        }\\n        return true;\\n    }\\n    \\n    int f(int idx,vector<string>& arr,string ans){\\n        //check if ans contains unique chars or not\\n        if(unique(ans) == false){\\n            return 0;  //skip adding this \"str\" to ans..return and stop;\\n        }\\n        \\n        int res = ans.length(); //cur. length of our \"ans\" string\\n        for(int i=idx; i<arr.size(); i++){\\n            //fun call on termination implicitly backtrack or removes the added str arr[i]\\n            res = max(res, f(i+1,arr,ans + arr[i]));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        return f(0,arr,\"\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737461,
                "title": "javascript-using-new-set-unoptimised-solution",
                "content": "Idea is to create all possible combination and calculate the max string which is having all unique characters in it without messing up the **order**\\n\\nCode:\\n```\\n/**\\n * @param {string[]} arr\\n * @return {number}\\n */\\nvar maxLength = function(arr) {\\n    const set = new Set([\\'\\']);\\n    let max = 0;\\n    let str;\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        const values = [...set.values()];\\n        \\n        for(let j = 0; j < values.length; j++) {     \\n            str = `${values[j]}${arr[i]}`;\\n            set.add(str);\\n            let newStr = [...new Set(str).values()].join(\\'\\');\\n            \\n            if (str === newStr) {\\n                max = Math.max(str.length, max);    \\n            }            \\n        }\\n    }\\n    \\n    return max;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} arr\\n * @return {number}\\n */\\nvar maxLength = function(arr) {\\n    const set = new Set([\\'\\']);\\n    let max = 0;\\n    let str;\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        const values = [...set.values()];\\n        \\n        for(let j = 0; j < values.length; j++) {     \\n            str = `${values[j]}${arr[i]}`;\\n            set.add(str);\\n            let newStr = [...new Set(str).values()].join(\\'\\');\\n            \\n            if (str === newStr) {\\n                max = Math.max(str.length, max);    \\n            }            \\n        }\\n    }\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2737436,
                "title": "easy-java-solution-100-faster",
                "content": "# Looking for Contribution in Hacktoberfest\\n## You are welcomed to contribute in my Repos:-\\n# GITHUB LINK --> [Yaduttam95](https://github.com/Yaduttam95)\\n# All PRs are getting accepted...\\n\\n# Please upvote if Helpful\\n```\\nclass Solution {\\n    public int solve(String strs[], int no, int a[], int index, int c) {\\n        if(index==c)\\n            return 0;\\n        int x=no & a[index];\\n        if(x==0)        \\n            return Math.max(strs[index].length()+solve(strs,no^a[index],a,index+1,c),solve(strs,no,a,index+1,c));\\n        else\\n            return solve(strs,no,a,index+1,c);\\n    }\\n    public int maxLength(List<String> arr) {\\n        int a[]=new int[arr.size()];int c=0;String strs[]=new String[a.length];\\n        for(String s:arr) {\\n            int x=0,fl=0;\\n            for(char ch:s.toCharArray()) \\n            {\\n                int z=x|(1<<(ch-96));\\n                if(x==z)\\n                {\\n                    fl=1;break;                \\n                }\\n                x=z;\\n            }\\n            if(fl==0)\\n            {\\n                a[c]=x;\\n                strs[c++]=s;\\n            }\\n        }\\n        return solve(strs,0,a,0,c);\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7a44dbe0-7232-440d-99cc-d17f06ddf9ec_1666495619.2304356.png)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int solve(String strs[], int no, int a[], int index, int c) {\\n        if(index==c)\\n            return 0;\\n        int x=no & a[index];\\n        if(x==0)        \\n            return Math.max(strs[index].length()+solve(strs,no^a[index],a,index+1,c),solve(strs,no,a,index+1,c));\\n        else\\n            return solve(strs,no,a,index+1,c);\\n    }\\n    public int maxLength(List<String> arr) {\\n        int a[]=new int[arr.size()];int c=0;String strs[]=new String[a.length];\\n        for(String s:arr) {\\n            int x=0,fl=0;\\n            for(char ch:s.toCharArray()) \\n            {\\n                int z=x|(1<<(ch-96));\\n                if(x==z)\\n                {\\n                    fl=1;break;                \\n                }\\n                x=z;\\n            }\\n            if(fl==0)\\n            {\\n                a[c]=x;\\n                strs[c++]=s;\\n            }\\n        }\\n        return solve(strs,0,a,0,c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440232,
                "title": "c-simple-c-code-98-time-92-space",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int n;\\n    int dfs(vector<int> &bitidx, vector<string>& arr, int idx, int bitmaps)\\n    {\\n        if(idx == n)\\n            return 0;\\n        int val = dfs(bitidx, arr, idx+1, bitmaps);\\n        if(bitidx[idx] != -1 && !(bitidx[idx]&bitmaps))\\n        {\\n            int k = arr[idx].size() + dfs(bitidx, arr, idx+1, bitmaps|bitidx[idx]);\\n            val = max(k, val);\\n        }\\n        return val;\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        n = arr.size();\\n        vector<int> bitidx(n,0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(char &ch : arr[i])\\n            {\\n                if(bitidx[i] & (1 << (ch-\\'a\\')))\\n                {\\n                    bitidx[i] = -1;\\n                    break;\\n                }\\n                else\\n                {\\n                    bitidx[i] = bitidx[i] | (1 << (ch-\\'a\\'));\\n                }\\n            }\\n        }\\n        return dfs(bitidx, arr, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    int dfs(vector<int> &bitidx, vector<string>& arr, int idx, int bitmaps)\\n    {\\n        if(idx == n)\\n            return 0;\\n        int val = dfs(bitidx, arr, idx+1, bitmaps);\\n        if(bitidx[idx] != -1 && !(bitidx[idx]&bitmaps))\\n        {\\n            int k = arr[idx].size() + dfs(bitidx, arr, idx+1, bitmaps|bitidx[idx]);\\n            val = max(k, val);\\n        }\\n        return val;\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        n = arr.size();\\n        vector<int> bitidx(n,0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(char &ch : arr[i])\\n            {\\n                if(bitidx[i] & (1 << (ch-\\'a\\')))\\n                {\\n                    bitidx[i] = -1;\\n                    break;\\n                }\\n                else\\n                {\\n                    bitidx[i] = bitidx[i] | (1 << (ch-\\'a\\'));\\n                }\\n            }\\n        }\\n        return dfs(bitidx, arr, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255645,
                "title": "easy-c-backtracking-solution-for-beginners-with-comments",
                "content": "This solution runs on same path as generating all the subsequences of a string with only condition of having all unique characters. \\n\\n```\\nint ans=INT_MIN;    //global answer variable\\n    \\n    bool unique(string s)         //function to find unique characters in a string\\n    {\\n        vector<int>freq(26);     // 26 size for all lowercase alphabets\\n        \\n        for(auto x:s)            // counting frequency of each character in the string.\\n        {\\n            freq[x-\\'a\\']++;       //  if x==\\'b\\'  then x-\\'a\\' will increase the value of freq[1];\\n        }\\n        \\n        for(auto x: freq)\\n        {\\n            if(x>1)                  // if frequency of any alphabet is > 1 then return false.\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n        void backtrack(vector<string>&arr,string s,int j)  \\n        {\\n            if(j==arr.size())\\n            {\\n                if(unique(s))                         //if string contains all unique characters then we\\'ll store the maximum length of the string in ans variable\\n                ans= max(ans,(int)s.size());\\n        \\n                return;\\n            }\\n        \\n        \\n            backtrack(arr,s,j+1);       // not including the current arr[j].\\n            \\n            if(unique(s))                  // only including arr[j] if it contains all unique characters.\\n            {\\n                s+=arr[j];\\n                backtrack(arr,s,j+1);  // call for the next step\\n            }\\n        }\\n    \\n    int maxLength(vector<string>& arr) {\\n        \\n        backtrack(arr,\"\",0);     //function call \\n        \\n        return ans;\\n    }\\n```\\n\\nUpvote if you really find this helpful. Thankyou \\uD83D\\uDE00\\uD83D\\uDE00.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint ans=INT_MIN;    //global answer variable\\n    \\n    bool unique(string s)         //function to find unique characters in a string\\n    {\\n        vector<int>freq(26);     // 26 size for all lowercase alphabets\\n        \\n        for(auto x:s)            // counting frequency of each character in the string.\\n        {\\n            freq[x-\\'a\\']++;       //  if x==\\'b\\'  then x-\\'a\\' will increase the value of freq[1];\\n        }\\n        \\n        for(auto x: freq)\\n        {\\n            if(x>1)                  // if frequency of any alphabet is > 1 then return false.\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n        void backtrack(vector<string>&arr,string s,int j)  \\n        {\\n            if(j==arr.size())\\n            {\\n                if(unique(s))                         //if string contains all unique characters then we\\'ll store the maximum length of the string in ans variable\\n                ans= max(ans,(int)s.size());\\n        \\n                return;\\n            }\\n        \\n        \\n            backtrack(arr,s,j+1);       // not including the current arr[j].\\n            \\n            if(unique(s))                  // only including arr[j] if it contains all unique characters.\\n            {\\n                s+=arr[j];\\n                backtrack(arr,s,j+1);  // call for the next step\\n            }\\n        }\\n    \\n    int maxLength(vector<string>& arr) {\\n        \\n        backtrack(arr,\"\",0);     //function call \\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2222821,
                "title": "c-simple-backtracking-solution-explained",
                "content": "* Note that the input string can have duplicate characters too\\n\\t* example: arr = [\"accd\"]\\n* take an empty string\\n* start adding strings from the array\\n* if the resulting string is unique \\n\\t* then update the ans(ans = max length that can be obtained)\\n\\t* append next string\\n* if not backtrack\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int ans = 0;\\n    bool isUnique(string s)\\n    {\\n        set<char> st(s.begin(), s.end());\\n        return (st.size() == s.length());\\n    }\\n    void solve(int index, string s, vector<string> &arr)\\n    {\\n        if (!isUnique(s))\\n            return;\\n        ans = max(ans, (int)s.length());\\n        for (int i = index; i < arr.size(); i++)\\n        {\\n            solve(i + 1, s + arr[i], arr);\\n        }\\n    }\\n    int maxLength(vector<string> &arr)\\n    {\\n        solve(0, \"\", arr);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int ans = 0;\\n    bool isUnique(string s)\\n    {\\n        set<char> st(s.begin(), s.end());\\n        return (st.size() == s.length());\\n    }\\n    void solve(int index, string s, vector<string> &arr)\\n    {\\n        if (!isUnique(s))\\n            return;\\n        ans = max(ans, (int)s.length());\\n        for (int i = index; i < arr.size(); i++)\\n        {\\n            solve(i + 1, s + arr[i], arr);\\n        }\\n    }\\n    int maxLength(vector<string> &arr)\\n    {\\n        solve(0, \"\", arr);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482790,
                "title": "c-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    int maxLength(vector<string>& arr) \\n    {\\n        vector<bitset<26>> m; \\n        int res=0;\\n        for(auto& s : arr)\\n        {\\n            bitset<26> bits;\\n            for(char c:s) bits.set(c-\\'a\\');\\n            int n = bits.count();\\n            if(n != s.size()) continue;\\n            for(int i=m.size()-1; i>=0; i--) \\n            {\\n                auto& b = m[i];\\n                if((b & bits).any())\\n                    continue;\\n                res = max<int>(res, b.count() + n);\\n                m.push_back(b | bits);\\n            }\\n            m.push_back(bits);\\n            res=max<int>(res, n);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    int maxLength(vector<string>& arr) \\n    {\\n        vector<bitset<26>> m; \\n        int res=0;\\n        for(auto& s : arr)\\n        {\\n            bitset<26> bits;\\n            for(char c:s) bits.set(c-\\'a\\');\\n            int n = bits.count();\\n            if(n != s.size()) continue;\\n            for(int i=m.size()-1; i>=0; i--) \\n            {\\n                auto& b = m[i];\\n                if((b & bits).any())\\n                    continue;\\n                res = max<int>(res, b.count() + n);\\n                m.push_back(b | bits);\\n            }\\n            m.push_back(bits);\\n            res=max<int>(res, n);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480103,
                "title": "simple-and-brief-c-solution-using-recursive",
                "content": "```\\nbool checkDupChar(char * s){\\n    int count[26] = {0};\\n    for(int i = 0; i<strlen(s); i++)\\n    {\\n        if(count[s[i] - \\'a\\'] > 0) return false;\\n        count[s[i] - \\'a\\']++;\\n    }\\n    return true;\\n}\\n\\nvoid helper(char ** arr, int arrSize, int idx, char * s, int * out){\\n    if(checkDupChar(s)) *out = *out > strlen(s) ? *out : strlen(s);\\n    if(idx == arrSize) return;\\n    char * temp = malloc(strlen(s)+strlen(arr[idx])+1);\\n    sprintf(temp, \"%s%s\", s, arr[idx]);\\n    helper(arr, arrSize, idx + 1, s, out);\\n    helper(arr, arrSize, idx + 1, temp, out);\\n}\\n\\nint maxLength(char ** arr, int arrSize){\\n    int result = 0;\\n    helper(arr, arrSize, 0, \"\", &result);\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkDupChar(char * s){\\n    int count[26] = {0};\\n    for(int i = 0; i<strlen(s); i++)\\n    {\\n        if(count[s[i] - \\'a\\'] > 0) return false;\\n        count[s[i] - \\'a\\']++;\\n    }\\n    return true;\\n}\\n\\nvoid helper(char ** arr, int arrSize, int idx, char * s, int * out){\\n    if(checkDupChar(s)) *out = *out > strlen(s) ? *out : strlen(s);\\n    if(idx == arrSize) return;\\n    char * temp = malloc(strlen(s)+strlen(arr[idx])+1);\\n    sprintf(temp, \"%s%s\", s, arr[idx]);\\n    helper(arr, arrSize, idx + 1, s, out);\\n    helper(arr, arrSize, idx + 1, temp, out);\\n}\\n\\nint maxLength(char ** arr, int arrSize){\\n    int result = 0;\\n    helper(arr, arrSize, 0, \"\", &result);\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479768,
                "title": "c-bitwise-maps-backtracking-dfs-solution-explained-100-time-95-space",
                "content": "Nice problem about combinations with a specific rule; and we know this kind of problems (at least for the relatively small amount of strings provided to us) can be tackled using a DFS approach; a backtracking on and on top of that, to avoid duplicate effort, we will also use a support array with bitmasks to tell us what characters are used in each string.\\n\\nTo do so, we will declare at class level a few support variables:\\n* `bits` is a pointer to the array we will create containing all the bitmasks equivalent to the provided strings;\\n* `pos`  will be the pointer we will use to write on `bits` and ultimately also the value of its size - initially set to `0`;\\n* `res` will be our usual accumulator variable, storing the longest combination found so far, with initial value of `0`;\\n* `curr` and `currBits` will store the values of our current string length and its composed bitmaks, respectively - both again pre-set to `0`.\\n\\nIn the main function, we will first of all initialise `bits` to be an appropriately sized array and the we will parse each string `s` in `arr` and:\\n* declare `bit` with initial value of `0` and `tmp` to help us in our parsing computations;\\n* for each character `c` in `s`, we will:\\n\\t* compute `tmp` as the `1` raised to the `c - \\'a\\'`th power of `2`, using bitwise shifting;\\n\\t* check if `bit & tmp`, which means we have already encountered a character like `c` in `s`, in which case we will:\\n\\t\\t* reset `bit` to `0`;\\n\\t\\t* `break` out of the inner loop;\\n\\t* alternatively, we will add `tmp` to `bit` with a binary OR;\\n* finally, we will write `bit` into `bits` and move `pos` forward.\\n\\nWe can now move the action to our helper function dfs`, that we will call passing just `arr` (as a reference, of course).\\n\\nThis helper function will also take an extra parameter, `start`, that we will default to `0` and:\\n* check first of all if we already encountered the maximum obtainable value (`26`), in which case no point in continuining and we can stop the call here with a `return`;\\n* alternatively it will update `res` to be the maximum between its current value and `curr`;\\n* another end case to consider now is when `start == pos`, meaning we are done parsing and we can just `return` (a bit reduntant given the following loop, but I just find it cleaner);\\n* we will then loop with `i` from `start` to `pos` (excluded) and:\\n\\t* check if `bits[i]` is not `0` and if we can add the `i`th string to `curr`, not having duplicate characters (ie: `(currBit & bits[i]) == 0`) and, if so:\\n\\t\\t* increase `curr` by `arr[i].size()`\\n\\t\\t* add the bit flags in `bits[i]` to `currBit`;\\n\\t\\t* call the function recursively, passing `arr` again and `i + 1` as a second parameter (ie: we will try to check all the possible permutations with other strings after the `start`th one);\\n\\t\\t* decrease `curr` by `arr[i].size()`\\n\\t\\t* remove the bit flags in `bits[i]` to `currBit`.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\n    // support variables\\n    int *bits, pos = 0, res = 0, curr = 0, currBit = 0;\\n    void dfs(vector<string>& arr, int start = 0) {\\n        // end case: max value achieved\\n        if (res == 26) return;\\n        res = max(res, curr);\\n        // end case: no more combinations to check\\n        if (start == pos) {\\n            return;\\n        }\\n        for (int i = start; i < pos; i++) {\\n            if (bits[i] && (currBit & bits[i]) == 0) {\\n                // updating curr and currBits\\n                curr += arr[i].size();\\n                currBit ^= bits[i];\\n                dfs(arr, i + 1);\\n                // backtracking curr\\n                curr -= arr[i].size();\\n                currBit ^= bits[i];\\n            }\\n            \\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        // preparing bits\\n        bits = new int[arr.size()];\\n        for (auto &s: arr) {\\n            int bit = 0, tmp;\\n            for (char c: s) {\\n                // updating the new bit flag\\n                tmp = 1 << (c - \\'a\\');\\n                // checking if s has duplicate words\\n                if (bit & tmp) {\\n                    bit = 0;\\n                    break;\\n                }\\n                bit |= tmp;\\n            }\\n            // writing bit into bits, if we found no duplicates\\n            bits[pos++] = bit;\\n        }\\n        // comparing strings\\n        dfs(arr);\\n        return res;\\n    }\\n};\\n```\\n\\nAlternative version, removing words with duplicated characters from both `arr` and `bits`:\\n\\n```cpp\\nclass Solution {\\n    // support variables\\n    int *bits, pos = 0, res = 0, curr = 0, currBit = 0;\\n    void dfs(vector<string>& arr, int start = 0) {\\n        // end case: max value achieved\\n        if (res == 26) return;\\n        res = max(res, curr);\\n        // end case: no more combinations to check\\n        if (start == pos) {\\n            return;\\n        }\\n        for (int i = start; i < pos; i++) {\\n            if ((currBit & bits[i]) == 0) {\\n                // updating curr and currBits\\n                curr += arr[i].size();\\n                currBit ^= bits[i];\\n                dfs(arr, i + 1);\\n                // backtracking curr\\n                curr -= arr[i].size();\\n                currBit ^= bits[i];\\n            }\\n            \\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        // preparing bits\\n        bits = new int[arr.size()];\\n        for (auto &s: arr) {\\n            int bit = 0, tmp;\\n            for (char c: s) {\\n                // updating the new bit flag\\n                tmp = 1 << (c - \\'a\\');\\n                // checking if s has duplicate words\\n                if (bit & tmp) {\\n                    bit = 0;\\n                    break;\\n                }\\n                bit |= tmp;\\n            }\\n            // writing bit into bits, if we found no duplicates\\n            bits[pos++] = bit;\\n        }\\n        // moving strings with duplicate characters past pos\\n        pos--;\\n        for (int i = 0; i <= pos; i++) {\\n            if (bits[i]) continue;\\n            swap(arr[i], arr[pos]);\\n            swap(bits[i--], bits[pos--]);\\n        }\\n        pos++;\\n        // comparing strings\\n        dfs(arr);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\n    // support variables\\n    int *bits, pos = 0, res = 0, curr = 0, currBit = 0;\\n    void dfs(vector<string>& arr, int start = 0) {\\n        // end case: max value achieved\\n        if (res == 26) return;\\n        res = max(res, curr);\\n        // end case: no more combinations to check\\n        if (start == pos) {\\n            return;\\n        }\\n        for (int i = start; i < pos; i++) {\\n            if (bits[i] && (currBit & bits[i]) == 0) {\\n                // updating curr and currBits\\n                curr += arr[i].size();\\n                currBit ^= bits[i];\\n                dfs(arr, i + 1);\\n                // backtracking curr\\n                curr -= arr[i].size();\\n                currBit ^= bits[i];\\n            }\\n            \\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        // preparing bits\\n        bits = new int[arr.size()];\\n        for (auto &s: arr) {\\n            int bit = 0, tmp;\\n            for (char c: s) {\\n                // updating the new bit flag\\n                tmp = 1 << (c - \\'a\\');\\n                // checking if s has duplicate words\\n                if (bit & tmp) {\\n                    bit = 0;\\n                    break;\\n                }\\n                bit |= tmp;\\n            }\\n            // writing bit into bits, if we found no duplicates\\n            bits[pos++] = bit;\\n        }\\n        // comparing strings\\n        dfs(arr);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    // support variables\\n    int *bits, pos = 0, res = 0, curr = 0, currBit = 0;\\n    void dfs(vector<string>& arr, int start = 0) {\\n        // end case: max value achieved\\n        if (res == 26) return;\\n        res = max(res, curr);\\n        // end case: no more combinations to check\\n        if (start == pos) {\\n            return;\\n        }\\n        for (int i = start; i < pos; i++) {\\n            if ((currBit & bits[i]) == 0) {\\n                // updating curr and currBits\\n                curr += arr[i].size();\\n                currBit ^= bits[i];\\n                dfs(arr, i + 1);\\n                // backtracking curr\\n                curr -= arr[i].size();\\n                currBit ^= bits[i];\\n            }\\n            \\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        // preparing bits\\n        bits = new int[arr.size()];\\n        for (auto &s: arr) {\\n            int bit = 0, tmp;\\n            for (char c: s) {\\n                // updating the new bit flag\\n                tmp = 1 << (c - \\'a\\');\\n                // checking if s has duplicate words\\n                if (bit & tmp) {\\n                    bit = 0;\\n                    break;\\n                }\\n                bit |= tmp;\\n            }\\n            // writing bit into bits, if we found no duplicates\\n            bits[pos++] = bit;\\n        }\\n        // moving strings with duplicate characters past pos\\n        pos--;\\n        for (int i = 0; i <= pos; i++) {\\n            if (bits[i]) continue;\\n            swap(arr[i], arr[pos]);\\n            swap(bits[i--], bits[pos--]);\\n        }\\n        pos++;\\n        // comparing strings\\n        dfs(arr);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479299,
                "title": "javascript-95-dp",
                "content": "Posting solutions for all dailies.\\n\\n```\\nconst maxLength = arr => {\\n  let res = 0;\\n\\n  const dp = (idx, cur) => {\\n    res = Math.max(res, cur.length);\\n    for (let i = idx; i < arr.length; i++) {\\n      ((cur+arr[i]).length === new Set([...cur,...arr[i]]).size) && \\n        dp(i + 1, cur + arr[i]);\\n    }\\n  }\\n\\n  dp(0, \\'\\');\\n  return res;\\n};\\n```\\n\\nAlternate method to check for duplicates.  Including because it\\'s a more versatile approach and can be used \\nto determine which chars are duplicates if modified, etc.  Not necessary for this problem though.\\n```\\nconst maxLength = arr => {\\n  let res = 0;\\n\\n  const dp = (idx, cur) => {\\n    res = Math.max(res, cur.length);\\n    \\n    for (let i = idx; i < arr.length; i++) {\\n      \\n      const unique = !!([...cur, ...arr[i]].reduce((set, char) => {\\n        if (!set || set.has(char)) return false;\\n        return set.add(char)\\n      }, new Set())); \\n      \\n      if (unique) dp(i + 1, cur + arr[i]);\\n    }\\n  }\\n\\n  dp(0, \\'\\');\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxLength = arr => {\\n  let res = 0;\\n\\n  const dp = (idx, cur) => {\\n    res = Math.max(res, cur.length);\\n    for (let i = idx; i < arr.length; i++) {\\n      ((cur+arr[i]).length === new Set([...cur,...arr[i]]).size) && \\n        dp(i + 1, cur + arr[i]);\\n    }\\n  }\\n\\n  dp(0, \\'\\');\\n  return res;\\n};\\n```\n```\\nconst maxLength = arr => {\\n  let res = 0;\\n\\n  const dp = (idx, cur) => {\\n    res = Math.max(res, cur.length);\\n    \\n    for (let i = idx; i < arr.length; i++) {\\n      \\n      const unique = !!([...cur, ...arr[i]].reduce((set, char) => {\\n        if (!set || set.has(char)) return false;\\n        return set.add(char)\\n      }, new Set())); \\n      \\n      if (unique) dp(i + 1, cur + arr[i]);\\n    }\\n  }\\n\\n  dp(0, \\'\\');\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1478675,
                "title": "java-solution-using-maintaining-list-and-size",
                "content": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        \\n        List<String> resultSet = new ArrayList<>();\\n        resultSet.add(\"\");\\n        int len = 0;\\n        \\n        for(String str : arr){\\n            \\n            List<String> tempList = new ArrayList<>();\\n            \\n            for(String res : resultSet){\\n                String tempStr = res + str;\\n                \\n                if(isUnique(tempStr)){\\n                    tempList.add(tempStr);\\n                    len = Math.max(len, tempStr.length());\\n                }\\n            }\\n            \\n            resultSet.addAll(tempList); // adding tempList contents to resultSet\\n        }\\n        return len;\\n    }\\n    \\n    public boolean isUnique(String str){\\n        if(str.length()>26) return false;\\n        \\n        int[] freq = new int[26];\\n        \\n        for(int i=0;i<str.length();i++){\\n            char ch = str.charAt(i);\\n            freq[ch-\\'a\\']++;\\n            \\n            if(freq[ch-\\'a\\']>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        \\n        List<String> resultSet = new ArrayList<>();\\n        resultSet.add(\"\");\\n        int len = 0;\\n        \\n        for(String str : arr){\\n            \\n            List<String> tempList = new ArrayList<>();\\n            \\n            for(String res : resultSet){\\n                String tempStr = res + str;\\n                \\n                if(isUnique(tempStr)){\\n                    tempList.add(tempStr);\\n                    len = Math.max(len, tempStr.length());\\n                }\\n            }\\n            \\n            resultSet.addAll(tempList); // adding tempList contents to resultSet\\n        }\\n        return len;\\n    }\\n    \\n    public boolean isUnique(String str){\\n        if(str.length()>26) return false;\\n        \\n        int[] freq = new int[26];\\n        \\n        for(int i=0;i<str.length();i++){\\n            char ch = str.charAt(i);\\n            freq[ch-\\'a\\']++;\\n            \\n            if(freq[ch-\\'a\\']>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478572,
                "title": "javascript-recursive-solution-simple-and-commented",
                "content": "```\\n/**\\n * @param {string[]} arr\\n * @return {number}\\n */\\nvar maxLength = function(arr) {\\n  return recurse(0, \\'\\', arr);\\n};\\n\\nfunction recurse(index, string, arr) {\\n  // termination condition\\n  \\n  // if we reached the last element of the array\\n  // we check if we have a valid string, return its length if yes,\\n  // otherwise zero\\n  if(index === arr.length) {\\n    return isValid(string) ? string.length : 0;\\n  }\\n  \\n  // We can either pick the current word in the array, or we can leave it\\n  // so there are two recursion path. We return then one that gives us the max\\n  // value\\n  let pick = recurse(index + 1, string + arr[index], arr);\\n  let notPick = recurse(index + 1, string, arr);\\n  \\n  return Math.max(pick, notPick);\\n}\\n\\nfunction isValid(string) {\\n  let hash = {};\\n  for(let char of string) {\\n    if(hash[char]) {\\n      return false;\\n    }\\n    hash[char] = true;\\n  }\\n  return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {string[]} arr\\n * @return {number}\\n */\\nvar maxLength = function(arr) {\\n  return recurse(0, \\'\\', arr);\\n};\\n\\nfunction recurse(index, string, arr) {\\n  // termination condition\\n  \\n  // if we reached the last element of the array\\n  // we check if we have a valid string, return its length if yes,\\n  // otherwise zero\\n  if(index === arr.length) {\\n    return isValid(string) ? string.length : 0;\\n  }\\n  \\n  // We can either pick the current word in the array, or we can leave it\\n  // so there are two recursion path. We return then one that gives us the max\\n  // value\\n  let pick = recurse(index + 1, string + arr[index], arr);\\n  let notPick = recurse(index + 1, string, arr);\\n  \\n  return Math.max(pick, notPick);\\n}\\n\\nfunction isValid(string) {\\n  let hash = {};\\n  for(let char of string) {\\n    if(hash[char]) {\\n      return false;\\n    }\\n    hash[char] = true;\\n  }\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1364598,
                "title": "c-solution-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxUniqueChar(string s){\\n        int count[26] = {0};\\n        for(int i = 0; i < s.size(); i++)\\n            if(count[s[i] - \\'a\\']++ > 0) return -1;\\n        \\n        return s.size();\\n    }\\n    void solve(vector<string>& arr, int index, string curr, vector<int>&ans){\\n        if(index == arr.size() && maxUniqueChar(curr) > ans[0]){\\n            ans[0] = curr.size();\\n            return;\\n        }\\n        if(index == arr.size()) return;\\n        \\n        solve(arr, index+1, curr, ans);\\n        solve(arr, index+1, curr+arr[index], ans);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<int>ans(1);\\n        solve(arr, 0, \"\", ans);\\n        return ans[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxUniqueChar(string s){\\n        int count[26] = {0};\\n        for(int i = 0; i < s.size(); i++)\\n            if(count[s[i] - \\'a\\']++ > 0) return -1;\\n        \\n        return s.size();\\n    }\\n    void solve(vector<string>& arr, int index, string curr, vector<int>&ans){\\n        if(index == arr.size() && maxUniqueChar(curr) > ans[0]){\\n            ans[0] = curr.size();\\n            return;\\n        }\\n        if(index == arr.size()) return;\\n        \\n        solve(arr, index+1, curr, ans);\\n        solve(arr, index+1, curr+arr[index], ans);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<int>ans(1);\\n        solve(arr, 0, \"\", ans);\\n        return ans[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312449,
                "title": "easy-backtracking-solution-c",
                "content": "```\\nclass Solution {\\n    int max{0};\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        findmax(\"\",arr,0);\\n        return max;\\n    }\\n    \\n    void findmax(string str,vector<string> &arr,int itr){\\n        if(!checkUnique(str)) return;\\n        \\n        if(str.size() > max) max = str.size();\\n       \\n        for(int i = itr;i<arr.size();i++){\\n        findmax(str + arr[i],arr,i+1);\\n       }\\n    }\\n    \\n    bool checkUnique(string word){\\n          set<char> st;\\n        for (auto ele : word) {\\n            if (st.find(ele) != st.end()) return false;\\n            st.insert(ele);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max{0};\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        findmax(\"\",arr,0);\\n        return max;\\n    }\\n    \\n    void findmax(string str,vector<string> &arr,int itr){\\n        if(!checkUnique(str)) return;\\n        \\n        if(str.size() > max) max = str.size();\\n       \\n        for(int i = itr;i<arr.size();i++){\\n        findmax(str + arr[i],arr,i+1);\\n       }\\n    }\\n    \\n    bool checkUnique(string word){\\n          set<char> st;\\n        for (auto ele : word) {\\n            if (st.find(ele) != st.end()) return false;\\n            st.insert(ele);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165688,
                "title": "simple-python-dfs-code",
                "content": "An easy optimization to make with this DFS traversal is to return once your path is no longer unique. \\n```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        self.max_length = 0\\n        def traverse(i, path):\\n            if len(path) == len(set(path)):\\n                self.max_length = max(self.max_length, len(path))\\n            else:\\n                return\\n        \\n            for j in range(i, len(arr)):\\n                traverse(j, path + arr[j])\\n                \\n        traverse(0, \"\")\\n        return self.max_length\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        self.max_length = 0\\n        def traverse(i, path):\\n            if len(path) == len(set(path)):\\n                self.max_length = max(self.max_length, len(path))\\n            else:\\n                return\\n        \\n            for j in range(i, len(arr)):\\n                traverse(j, path + arr[j])\\n                \\n        traverse(0, \"\")\\n        return self.max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121206,
                "title": "c-recursion",
                "content": "The idea is to compute all of the combinationations. and to find out if they are unique or not.\\n\\n1. In order to understand if a string if unique or not we can use a set ( I used hashset, we can use any other represntation)\\n2. In order to compute all combinationation we use.. recursion... if you think of for loops.. how many of those do you need...? we don\\'t know ... so we use recurssion...\\n3. in the recurs=sion we have the option to take a gives string or not... that\\'s it.\\n\\n\\n```\\npublic class Solution {\\n    public int MaxLength(IList<string> arr) \\n    {\\n       return MaxUnique(arr, 0, \"\");\\n    }\\n    \\n    private int MaxUnique(IList<string> arr, int index, string curr)\\n    {\\n        if(index == arr.Count)\\n        {\\n            return IsUnique(curr);\\n        }\\n        if(IsUnique(curr)==-1)\\n        {\\n            return -1;\\n        }\\n        int res = MaxUnique(arr, index+1, curr);        \\n        int res2 = MaxUnique(arr, index+1, curr+arr[index]);\\n        return Math.Max(res, res2);\\n        \\n    }\\n    \\n     \\n    private int IsUnique(string str)\\n    {\\n        HashSet<char> set = new HashSet<char>();\\n        foreach(var c in str)\\n        {\\n            if(set.Contains(c))\\n            {\\n                return -1;\\n            }\\n            set.Add(c);\\n        }\\n        return str.Length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxLength(IList<string> arr) \\n    {\\n       return MaxUnique(arr, 0, \"\");\\n    }\\n    \\n    private int MaxUnique(IList<string> arr, int index, string curr)\\n    {\\n        if(index == arr.Count)\\n        {\\n            return IsUnique(curr);\\n        }\\n        if(IsUnique(curr)==-1)\\n        {\\n            return -1;\\n        }\\n        int res = MaxUnique(arr, index+1, curr);        \\n        int res2 = MaxUnique(arr, index+1, curr+arr[index]);\\n        return Math.Max(res, res2);\\n        \\n    }\\n    \\n     \\n    private int IsUnique(string str)\\n    {\\n        HashSet<char> set = new HashSet<char>();\\n        foreach(var c in str)\\n        {\\n            if(set.Contains(c))\\n            {\\n                return -1;\\n            }\\n            set.Add(c);\\n        }\\n        return str.Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979910,
                "title": "python-clear-way-to-understand-the-time-complexity-o-2-n",
                "content": "**Intuition**\\nAt each recursion stack, you need to check for 2 things:\\n1. If there is a duplicate within the word.\\n2. If the index reached the end of the array.\\n\\ta. Update max length.\\n\\nThen, split into 2 branches:\\n1. Append the current index\\'s word.\\n2. Don\\'t append the current index\\'s word.\\n\\nYou can easily see that at each recursion stack, there are 2 additional recursion calls happening, so the complexity naturally becomes 2^N.\\n\\n```\\n    def maxLength(self, arr: List[str]) -> int:\\n        length = 0\\n        \\n        def recurse(index, word):\\n            if len(set(word)) != len(word):\\n                return\\n            \\n            if index == len(arr):\\n                nonlocal length\\n                length = max(length, len(word))\\n                return\\n            \\n            recurse(index + 1, word + arr[index])\\n            recurse(index + 1, word)\\n        \\n        recurse(0, \\'\\')\\n        return length\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def maxLength(self, arr: List[str]) -> int:\\n        length = 0\\n        \\n        def recurse(index, word):\\n            if len(set(word)) != len(word):\\n                return\\n            \\n            if index == len(arr):\\n                nonlocal length\\n                length = max(length, len(word))\\n                return\\n            \\n            recurse(index + 1, word + arr[index])\\n            recurse(index + 1, word)\\n        \\n        recurse(0, \\'\\')\\n        return length\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 919959,
                "title": "python-dp-40ms-beats-99-33",
                "content": "\\tclass Solution:\\n\\t\\tdef maxLength(self, arr: List[str]) -> int:\\n\\n\\t\\t\\tarr = [s for s in arr if len(set(s)) == len(s)] # remove wrong elements\\n\\t\\t\\tarr = tuple(sorted(arr)) # use tuple to make it hashable\\n\\t\\t\\t\\n\\t\\t\\t@functools.lru_cache(None)\\n\\t\\t\\tdef intesect(s1, s2):\\n\\t\\t\\t\\treturn not not set(s1).intersection(set(s2))\\n\\n\\t\\t\\t@functools.lru_cache(None)\\n\\t\\t\\tdef dp(arr):\\n\\t\\t\\t\\tif len(arr) == 0: return 0\\n\\t\\t\\t\\t# with/without arr[0]\\n\\t\\t\\t\\twt_arr0 = tuple([arr[i] for i in range(1, len(arr)) if not intesect(arr[i],arr[0]) ])\\n\\t\\t\\t\\two_arr0 = tuple(arr[1:])\\n\\t\\t\\t\\treturn max(len(arr[0]) + dp(wt_arr0), dp(wo_arr0))\\n\\n\\t\\t\\treturn dp(arr)\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maxLength(self, arr: List[str]) -> int:\\n\\n\\t\\t\\tarr = [s for s in arr if len(set(s)) == len(s)] # remove wrong elements\\n\\t\\t\\tarr = tuple(sorted(arr)) # use tuple to make it hashable\\n\\t\\t\\t\\n\\t\\t\\t@functools.lru_cache(None)\\n\\t\\t\\tdef intesect(s1, s2):\\n\\t\\t\\t\\treturn not not set(s1).intersection(set(s2))\\n\\n\\t\\t\\t@functools.lru_cache(None)\\n\\t\\t\\tdef dp(arr):\\n\\t\\t\\t\\tif len(arr) == 0: return 0\\n\\t\\t\\t\\t# with/without arr[0]\\n\\t\\t\\t\\twt_arr0 = tuple([arr[i] for i in range(1, len(arr)) if not intesect(arr[i],arr[0]) ])\\n\\t\\t\\t\\two_arr0 = tuple(arr[1:])\\n\\t\\t\\t\\treturn max(len(arr[0]) + dp(wt_arr0), dp(wo_arr0))\\n\\n\\t\\t\\treturn dp(arr)\\n",
                "codeTag": "Java"
            },
            {
                "id": 879390,
                "title": "c-8ms-faster-than-91-35-using-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int Bitset[256];\\n    int maxLength(vector<string>& arr) {\\n        \\n        Bitset[0]=0;\\n\\t\\t// This is a way to count the bits via lookup table\\n\\t\\t// refer https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetTable\\n        for(int i = 0;i<256;i++)\\n            Bitset[i]= (i&1)+Bitset[i/2];\\n       vector<int> a(arr.size());\\n\\t   \\n\\t   //IDEA :- The effort is towards finding the maximum size of the string which can be made by unique characters\\n\\t   // by using the strings in the array.\\n\\t   // Lets say each character is represented by a bit in a 32 bit number (you will be using 26 characters( as a-z))\\n\\t   // so a string \"un\" is represented by setting the bits 20th bit and 13th bit in a number\\n\\t   // similarly \"iq\" will be represented by setting 8th bit and 16th bit\\n\\t   // Note : I am staring from 0th bit\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n            int k = 0;\\n            for(int j = 0;j<arr[i].size();j++)\\n            {\\n\\t\\t\\t//Bit of k is set as per Each letter of the string \\n                k|=(1<<(arr[i][j]-\\'a\\'));\\n                a[i]=k;\\n            }\\n\\t\\t\\t//This following step is essential to check whether letters are repeated within a string or not\\n\\t\\t\\t// If unique letters then no of bits set should be equal to the size of the string\\n            if(countbits(a[i])!=arr[i].size())\\n                a[i]=0;\\n        }\\n        int maxm=0;\\n        int temp = 0;\\n\\t\\t// Here it is a simple combination helper function\\n        helper(a,0,temp,maxm);\\n        return maxm;\\n    }\\n    \\n    void helper(vector<int>& arr, int i,int& temp, int& maxm)\\n    {\\n        if(i>arr.size()-1)\\n            return;\\n        int c = temp;\\n        if((temp&arr[i]) == 0) //This condition will be satisfied if both of the strings ANDed don\\'t have same bits set\\n        {\\n            c|=arr[i]; // As unique characters so safe to OR or join \\n            maxm=max(countbits(c),maxm); // check the length\\n            helper(arr,i+1,c,maxm); // this is the call to helper again including the present string\\n        }\\n        //The following is the call to helper without including the current string \\n        helper(arr,i+1,temp,maxm);\\n    }\\n    \\n\\t//Function to count bits using the look up table populated in the beginning of maxLength()\\n    int countbits(int c)\\n    {\\n\\t// Bitset[c&0xff] - calculating no of bits set in 0-7 bits\\n\\t// Bitset[(c>>8)&0xff] - calculating no of bits set in lower 8-15 bits\\n\\t// similarly the rest as i am shifting by 8 bits \\n        return (Bitset[c&0xff] + Bitset[(c>>8)&0xff] + Bitset[(c>>16)&0xff] + Bitset[c>>24]);\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int Bitset[256];\\n    int maxLength(vector<string>& arr) {\\n        \\n        Bitset[0]=0;\\n\\t\\t// This is a way to count the bits via lookup table\\n\\t\\t// refer https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetTable\\n        for(int i = 0;i<256;i++)\\n            Bitset[i]= (i&1)+Bitset[i/2];\\n       vector<int> a(arr.size());\\n\\t   \\n\\t   //IDEA :- The effort is towards finding the maximum size of the string which can be made by unique characters\\n\\t   // by using the strings in the array.\\n\\t   // Lets say each character is represented by a bit in a 32 bit number (you will be using 26 characters( as a-z))\\n\\t   // so a string \"un\" is represented by setting the bits 20th bit and 13th bit in a number\\n\\t   // similarly \"iq\" will be represented by setting 8th bit and 16th bit\\n\\t   // Note : I am staring from 0th bit\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n            int k = 0;\\n            for(int j = 0;j<arr[i].size();j++)\\n            {\\n\\t\\t\\t//Bit of k is set as per Each letter of the string \\n                k|=(1<<(arr[i][j]-\\'a\\'));\\n                a[i]=k;\\n            }\\n\\t\\t\\t//This following step is essential to check whether letters are repeated within a string or not\\n\\t\\t\\t// If unique letters then no of bits set should be equal to the size of the string\\n            if(countbits(a[i])!=arr[i].size())\\n                a[i]=0;\\n        }\\n        int maxm=0;\\n        int temp = 0;\\n\\t\\t// Here it is a simple combination helper function\\n        helper(a,0,temp,maxm);\\n        return maxm;\\n    }\\n    \\n    void helper(vector<int>& arr, int i,int& temp, int& maxm)\\n    {\\n        if(i>arr.size()-1)\\n            return;\\n        int c = temp;\\n        if((temp&arr[i]) == 0) //This condition will be satisfied if both of the strings ANDed don\\'t have same bits set\\n        {\\n            c|=arr[i]; // As unique characters so safe to OR or join \\n            maxm=max(countbits(c),maxm); // check the length\\n            helper(arr,i+1,c,maxm); // this is the call to helper again including the present string\\n        }\\n        //The following is the call to helper without including the current string \\n        helper(arr,i+1,temp,maxm);\\n    }\\n    \\n\\t//Function to count bits using the look up table populated in the beginning of maxLength()\\n    int countbits(int c)\\n    {\\n\\t// Bitset[c&0xff] - calculating no of bits set in 0-7 bits\\n\\t// Bitset[(c>>8)&0xff] - calculating no of bits set in lower 8-15 bits\\n\\t// similarly the rest as i am shifting by 8 bits \\n        return (Bitset[c&0xff] + Bitset[(c>>8)&0xff] + Bitset[(c>>16)&0xff] + Bitset[c>>24]);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838743,
                "title": "c-easy-to-understand-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string a,string b)\\n    {\\n        unordered_set<char> map;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(map.find(a[i])!=map.end())\\n                return false;\\n            map.insert(a[i]);\\n        }\\n        for(int i=0;i<b.length();i++)\\n        {\\n            if(map.find(b[i])!=map.end())\\n                return false;\\n        }\\n        return true;\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<string> ans;\\n        ans.push_back(\"\");\\n        int res=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int n=ans.size();\\n            for(int j=0;j<n;j++)\\n            {\\n                if(check(arr[i],ans[j]))\\n                {\\n                    ans.push_back(arr[i]+ans[j]);\\n                    res=max(res,(int)(arr[i].length()+ans[j].length()));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string a,string b)\\n    {\\n        unordered_set<char> map;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(map.find(a[i])!=map.end())\\n                return false;\\n            map.insert(a[i]);\\n        }\\n        for(int i=0;i<b.length();i++)\\n        {\\n            if(map.find(b[i])!=map.end())\\n                return false;\\n        }\\n        return true;\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<string> ans;\\n        ans.push_back(\"\");\\n        int res=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int n=ans.size();\\n            for(int j=0;j<n;j++)\\n            {\\n                if(check(arr[i],ans[j]))\\n                {\\n                    ans.push_back(arr[i]+ans[j]);\\n                    res=max(res,(int)(arr[i].length()+ans[j].length()));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 766200,
                "title": "python-144-ms-dfs-very-easy-to-understand",
                "content": "Code is concise and very easy.\\n\\n```\\nclass Solution:\\n    maximum_concat = 0\\n    \\n    def maxLength(self, arr: List[str]) -> int:\\n        def is_unique_concat(concat):\\n            if not concat: return True\\n            return len(concat) == len(set(concat))\\n        \\n        def create_concatenation(cur_concat = \"\", arr_loc_index = 0):  \\n            self.maximum_concat = max(self.maximum_concat, len(cur_concat))\\n            \\n            if arr_loc_index == len(arr):\\n                return\\n            \\n            if is_unique_concat(cur_concat + arr[arr_loc_index]):\\n                create_concatenation(cur_concat + arr[arr_loc_index], arr_loc_index + 1)\\n            create_concatenation(cur_concat, arr_loc_index + 1)\\n            \\n        create_concatenation()\\n        return self.maximum_concat\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    maximum_concat = 0\\n    \\n    def maxLength(self, arr: List[str]) -> int:\\n        def is_unique_concat(concat):\\n            if not concat: return True\\n            return len(concat) == len(set(concat))\\n        \\n        def create_concatenation(cur_concat = \"\", arr_loc_index = 0):  \\n            self.maximum_concat = max(self.maximum_concat, len(cur_concat))\\n            \\n            if arr_loc_index == len(arr):\\n                return\\n            \\n            if is_unique_concat(cur_concat + arr[arr_loc_index]):\\n                create_concatenation(cur_concat + arr[arr_loc_index], arr_loc_index + 1)\\n            create_concatenation(cur_concat, arr_loc_index + 1)\\n            \\n        create_concatenation()\\n        return self.maximum_concat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558589,
                "title": "go-golang-0ms-solutions",
                "content": ">Runtime: 4 ms, faster than 58.82% of Go online submissions for Maximum Length of a Concatenated String with Unique Characters.\\nMemory Usage: 2 MB, less than 100.00% of Go online submissions for Maximum Length of a Concatenated String with Unique Characters.\\n\\n```go\\nfunc maxLength(arr []string) int {\\n    if len(arr) == 1 { return len(arr[0]) }\\n    max := 0\\n    dfs(arr, 0, \"\", &max)\\n    return max\\n}\\n\\nfunc dfs(arr []string, index int, cur string, max *int) {\\n    if index == len(arr) && uniqueCharCount(cur) > *max { *max = len(cur); return }\\n    if index == len(arr) { return }\\n    if uniqueCharCount(cur) == - 1 { return }\\n    dfs(arr, index + 1, cur + arr[index], max)\\n    dfs(arr, index + 1, cur, max)\\n}\\n\\nfunc uniqueCharCount(s string) int {\\n    chars := make([]int, 26)\\n    for _, c := range s {\\n        if chars[c - \\'a\\'] == 1 { return -1 }\\n        chars[c - \\'a\\']++\\n    }\\n    return len(s)\\n}\\n```\\n\\n>Runtime: 0 ms, faster than 100.00% of Go online submissions for Maximum Length of a Concatenated String with Unique Characters.\\nMemory Usage: 2 MB, less than 100.00% of Go online submissions for Maximum Length of a Concatenated String with Unique Characters.\\n\\n```go\\nfunc maxLength(arr []string) int {\\n    c := []uint32{}\\n    max := 0\\n    for _, s := range arr {\\n        var mask uint32\\n        for _, c := range s {\\n            mask = mask | 1 << (c - \\'a\\')\\n        }\\n        if len(s) != bits.OnesCount32(mask) { continue }\\n        c = append(c, mask)\\n    }\\n    dfs(c, 0, 0, &max)\\n    return max\\n}\\n\\nfunc dfs(c []uint32, index int, mask uint32, max *int) {\\n    *max = Max(*max, bits.OnesCount32(mask))\\n    for i := index; i < len(c); i++ {\\n        if mask & c[i] == 0 {\\n            dfs(c, i + 1, mask | c[i], max)\\n        }\\n    }\\n    return\\n}\\n\\nfunc Max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc maxLength(arr []string) int {\\n    if len(arr) == 1 { return len(arr[0]) }\\n    max := 0\\n    dfs(arr, 0, \"\", &max)\\n    return max\\n}\\n\\nfunc dfs(arr []string, index int, cur string, max *int) {\\n    if index == len(arr) && uniqueCharCount(cur) > *max { *max = len(cur); return }\\n    if index == len(arr) { return }\\n    if uniqueCharCount(cur) == - 1 { return }\\n    dfs(arr, index + 1, cur + arr[index], max)\\n    dfs(arr, index + 1, cur, max)\\n}\\n\\nfunc uniqueCharCount(s string) int {\\n    chars := make([]int, 26)\\n    for _, c := range s {\\n        if chars[c - \\'a\\'] == 1 { return -1 }\\n        chars[c - \\'a\\']++\\n    }\\n    return len(s)\\n}\\n```\n```go\\nfunc maxLength(arr []string) int {\\n    c := []uint32{}\\n    max := 0\\n    for _, s := range arr {\\n        var mask uint32\\n        for _, c := range s {\\n            mask = mask | 1 << (c - \\'a\\')\\n        }\\n        if len(s) != bits.OnesCount32(mask) { continue }\\n        c = append(c, mask)\\n    }\\n    dfs(c, 0, 0, &max)\\n    return max\\n}\\n\\nfunc dfs(c []uint32, index int, mask uint32, max *int) {\\n    *max = Max(*max, bits.OnesCount32(mask))\\n    for i := index; i < len(c); i++ {\\n        if mask & c[i] == 0 {\\n            dfs(c, i + 1, mask | c[i], max)\\n        }\\n    }\\n    return\\n}\\n\\nfunc Max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442238,
                "title": "simple-java-backtracking-solution",
                "content": "\\tint max = 0;\\n    public int maxLength(List<String> arr) {\\n        int[] count = new int[256];\\n        backtracking(arr,count,0,\"\");\\n        return max;\\n    }\\n    \\n    private void backtracking(List<String> arr, int[] count, int index, String str){\\n        if(index == count.length) return;\\n        for(int i = index; i < arr.size(); i++){\\n            char[] array = arr.get(i).toCharArray();\\n            boolean foundDuplicate = false;\\n            for(int k = 0; k < array.length; k++){\\n                char c = array[k];\\n                if(count[(int)c] == 1){\\n                    for(int j = 0; j < k; j++){\\n                        count[(int)(array[j])]--;\\n                    }\\n                    foundDuplicate = true;\\n                    break;\\n                }\\n                count[(int)c]++;\\n            }\\n            if(!foundDuplicate){\\n                max = Math.max(max,str.length()+array.length);\\n                backtracking(arr,count,i+1,str+arr.get(i));\\n                for(char c : array){\\n                    count[(int)c]--;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "\\tint max = 0;\\n    public int maxLength(List<String> arr) {\\n        int[] count = new int[256];\\n        backtracking(arr,count,0,\"\");\\n        return max;\\n    }\\n    \\n    private void backtracking(List<String> arr, int[] count, int index, String str){\\n        if(index == count.length) return;\\n        for(int i = index; i < arr.size(); i++){\\n            char[] array = arr.get(i).toCharArray();\\n            boolean foundDuplicate = false;\\n            for(int k = 0; k < array.length; k++){\\n                char c = array[k];\\n                if(count[(int)c] == 1){\\n                    for(int j = 0; j < k; j++){\\n                        count[(int)(array[j])]--;\\n                    }\\n                    foundDuplicate = true;\\n                    break;\\n                }\\n                count[(int)c]++;\\n            }\\n            if(!foundDuplicate){\\n                max = Math.max(max,str.length()+array.length);\\n                backtracking(arr,count,i+1,str+arr.get(i));\\n                for(char c : array){\\n                    count[(int)c]--;\\n                }\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 414208,
                "title": "java-solution-explained-with-comment",
                "content": "```\\npublic static int maxLength(List<String> arr) {\\n        int len = 0;\\n        for (int i = 0; i < arr.size(); i++) { // this loop check whether i\\'th string itself has repeating char\\n            HashSet<Character> seen = new HashSet<>();\\n            boolean has = true;\\n            for (char c : arr.get(i).toCharArray()) {\\n                if (seen.contains(c)) {\\n                    has = false;\\n                    break;\\n                }\\n                seen.add(c);\\n            }\\n            if (!has)// if it\\'s has repeating char continue to next i\\n                continue;\\n\\n            len = Math.max(len, seen.size());\\n            for (int j = 0; j < arr.size(); j++) { // this loop check with all other strings in arr\\n                has = true;\\n                if (i == j) continue;\\n                HashSet<Character> data = new HashSet<>();\\n                for (char c : arr.get(j).toCharArray()) {\\n                    if (seen.contains(c) || data.contains(c)) {\\n                        has = false;\\n                        break;\\n                    }\\n                    data.add(c);\\n                }\\n                if (has) { // if everthing is diff then concat it to i\\'th string\\n                    seen.addAll(data);\\n                }\\n                len = Math.max(len, seen.size());// always check if there is update in it \\n            }\\n       \\n```\\n\\nHope you will understand :P",
                "solutionTags": [],
                "code": "```\\npublic static int maxLength(List<String> arr) {\\n        int len = 0;\\n        for (int i = 0; i < arr.size(); i++) { // this loop check whether i\\'th string itself has repeating char\\n            HashSet<Character> seen = new HashSet<>();\\n            boolean has = true;\\n            for (char c : arr.get(i).toCharArray()) {\\n                if (seen.contains(c)) {\\n                    has = false;\\n                    break;\\n                }\\n                seen.add(c);\\n            }\\n            if (!has)// if it\\'s has repeating char continue to next i\\n                continue;\\n\\n            len = Math.max(len, seen.size());\\n            for (int j = 0; j < arr.size(); j++) { // this loop check with all other strings in arr\\n                has = true;\\n                if (i == j) continue;\\n                HashSet<Character> data = new HashSet<>();\\n                for (char c : arr.get(j).toCharArray()) {\\n                    if (seen.contains(c) || data.contains(c)) {\\n                        has = false;\\n                        break;\\n                    }\\n                    data.add(c);\\n                }\\n                if (has) { // if everthing is diff then concat it to i\\'th string\\n                    seen.addAll(data);\\n                }\\n                len = Math.max(len, seen.size());// always check if there is update in it \\n            }\\n       \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018220,
                "title": "239-maximum-length-of-a-concatenated-string-with-unique-characters-medium",
                "content": "# Maximum Length of a Concatenated String with Unique Characters\\n\\nThis repository contains a C++ solution to find the maximum length of a string that can be formed by concatenating non-duplicate strings from a given vector of strings.\\n\\n## Approach\\n\\nThe approach employed in this solution involves recursive exploration of all possible combinations of strings from the input vector `arr`. The primary steps of the approach are as follows:\\n\\n1. Define a recursive function `solve` that takes three parameters:\\n   - `arr`: The vector of strings.\\n   - `i`: The index of the string in `arr` that we are currently looking at.\\n   - `mask`: A bitmask that represents the characters that have been added to the current string. If the 0-th bit in the mask is set, it means that \"a\" has been added to the current string.\\n\\n2. In the `solve` function, check for base cases:\\n   - If the index `i` exceeds the size of the input vector `arr`, return 0.\\n\\n3. Skip concatenating the current string (`arr[i]`) and recursively call `solve` with the next index `i+1` and the same `mask`. This is done to calculate the maximum length without including the current string.\\n\\n4. Use a bitmask `mask` to keep track of characters that have been added to the current string. Check whether any character in `arr[i]` is present in the current string by using bitwise operations. If any existing character\\'s bit is set, return the result without adding `arr[i]` to the current string.\\n\\n5. Maintain a character mask `curMask` to prevent concatenation if `arr[i]` itself has duplicate characters. After checking for duplicate characters, update the `mask` to include all the bits set in `curMask` to indicate that these characters are part of the current string.\\n\\n6. Make a recursive call to `solve` with the updated `mask` and the length of `arr[i]` added to the current result.\\n\\n7. The `maxLength` function serves as the entry point, initializing the `solve` function with the input vector `arr`, starting at index 0, and with an initial `mask` of 0.\\n\\n## Intuition\\n\\nThe intuition behind this approach is to explore all possible combinations of strings from the input vector `arr` while keeping track of characters that have been added to the current string using a bitmask. By avoiding concatenation when duplicate characters are encountered and considering both scenarios (concatenation and skipping) for each string, the code identifies the maximum length of a unique character string that can be formed.\\n\\n## Complexity Analysis\\n\\n- Time Complexity: The code explores all possible combinations of strings from the vector `arr`, resulting in a worst-case time complexity of O(2^n), where \\'n\\' is the number of strings in the input vector `arr`. Dynamic programming techniques could be applied to improve the time complexity.\\n- Space Complexity: The space complexity is O(n), where \\'n\\' is the number of characters in the input vector `arr`. This space is used for the recursion call stack and the `mask` and `curMask` variables.\\n\\n## Usage\\n\\nTo find the maximum length of a string that can be formed by concatenating non-duplicate strings from a vector of strings, use the `maxLength` function by providing your input vector `arr`.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<string> &arr, int i, int mask) {\\n        int n = arr.size();\\n        if (i >= n){\\n            return 0;\\n        }\\n\\n        int curRes = solve(arr, i+1, mask);\\n\\t\\tint curMask = 0;\\n        for (char &c: arr[i]) {\\n            if (mask & (1 << (c - \\'a\\'))){\\n                return curRes;\\n            }\\n            \\n            if (curMask & (1 << (c - \\'a\\'))){\\n                return curRes;\\n            }\\n            \\n            curMask |= (1 << (c - \\'a\\'));\\n        }\\n        mask |= curMask;\\n        curRes = max(curRes, (int) arr[i].length() + solve(arr, i+1, mask));\\n        return curRes;\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        return solve(arr, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<string> &arr, int i, int mask) {\\n        int n = arr.size();\\n        if (i >= n){\\n            return 0;\\n        }\\n\\n        int curRes = solve(arr, i+1, mask);\\n\\t\\tint curMask = 0;\\n        for (char &c: arr[i]) {\\n            if (mask & (1 << (c - \\'a\\'))){\\n                return curRes;\\n            }\\n            \\n            if (curMask & (1 << (c - \\'a\\'))){\\n                return curRes;\\n            }\\n            \\n            curMask |= (1 << (c - \\'a\\'));\\n        }\\n        mask |= curMask;\\n        curRes = max(curRes, (int) arr[i].length() + solve(arr, i+1, mask));\\n        return curRes;\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        return solve(arr, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337903,
                "title": "backtracking-approach-2-ways",
                "content": "# Code\\n```java []\\n    public int maxLength(List<String> arr) {\\n        int select[] = new int[26];\\n        return solve(0,0,select,arr);\\n    }\\n    int solve(int p,int len,int select[],List<String> arr){\\n        if(p==arr.size()) return len;\\n        if(isValid(arr.get(p),select)){\\n            String str =arr.get(p);\\n            len+=str.length();\\n            markOne(str,select);\\n            int l1= solve(p+1,len,select,arr);\\n            markZero(str,select);\\n            len-=str.length();\\n            int l2=solve(p+1,len,select,arr);\\n            return Math.max(l1,l2);\\n        }else return solve(p+1,len,select,arr);\\n    }\\n    void markOne(String s,int select[]){\\n        for(char c:s.toCharArray()) select[c-\\'a\\']=1;\\n    }\\n    void markZero(String s,int select[]){\\n        for(char v:s.toCharArray()) select[v-\\'a\\']=0;\\n    }\\n    boolean isValid(String s,int fre[]){\\n        if(s.length()>26) return false;\\n        boolean c[] = new boolean[26];\\n        for(char ch:s.toCharArray()){\\n            if(c[ch-\\'a\\']) return false;\\n            if(fre[ch-\\'a\\']==1) return false;\\n            c[ch-\\'a\\']=true;\\n        }return true;\\n    }\\n```\\n```java [2]\\npublic int maxLength1(List<String> arr) {\\n        HashSet<String> A = new HashSet<String>();\\n        A.add(\"\");\\n        for (String s : arr) {\\n            if (!isUnique(s)) continue;\\n            HashSet<String> t = new HashSet<String>();\\n            for (String c : A) {\\n                String temp = c + s;\\n                if (isUnique(temp)) t.add(temp);\\n            }\\n            A.addAll(t);\\n        }\\n       return A.stream().max(Comparator.comparing(String::length)).get().length();\\n    }\\n boolean isUnique(String st) {\\n        if (st.length() > 26) return false;\\n        boolean A[] = new boolean[26];\\n        for(char c:st.toCharArray()){\\n            if(A[c-\\'a\\']) return false;\\n            A[c-\\'a\\']=true;\\n        }return true;\\n    }\\n```\\n\\n\\n# Complexity\\n- Time complexity: o(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![meme2.png](https://assets.leetcode.com/users/images/c6d0d334-f51e-4eaa-bd6b-4e3dcb34d33c_1679716889.1266408.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Backtracking"
                ],
                "code": "```java []\\n    public int maxLength(List<String> arr) {\\n        int select[] = new int[26];\\n        return solve(0,0,select,arr);\\n    }\\n    int solve(int p,int len,int select[],List<String> arr){\\n        if(p==arr.size()) return len;\\n        if(isValid(arr.get(p),select)){\\n            String str =arr.get(p);\\n            len+=str.length();\\n            markOne(str,select);\\n            int l1= solve(p+1,len,select,arr);\\n            markZero(str,select);\\n            len-=str.length();\\n            int l2=solve(p+1,len,select,arr);\\n            return Math.max(l1,l2);\\n        }else return solve(p+1,len,select,arr);\\n    }\\n    void markOne(String s,int select[]){\\n        for(char c:s.toCharArray()) select[c-\\'a\\']=1;\\n    }\\n    void markZero(String s,int select[]){\\n        for(char v:s.toCharArray()) select[v-\\'a\\']=0;\\n    }\\n    boolean isValid(String s,int fre[]){\\n        if(s.length()>26) return false;\\n        boolean c[] = new boolean[26];\\n        for(char ch:s.toCharArray()){\\n            if(c[ch-\\'a\\']) return false;\\n            if(fre[ch-\\'a\\']==1) return false;\\n            c[ch-\\'a\\']=true;\\n        }return true;\\n    }\\n```\n```java [2]\\npublic int maxLength1(List<String> arr) {\\n        HashSet<String> A = new HashSet<String>();\\n        A.add(\"\");\\n        for (String s : arr) {\\n            if (!isUnique(s)) continue;\\n            HashSet<String> t = new HashSet<String>();\\n            for (String c : A) {\\n                String temp = c + s;\\n                if (isUnique(temp)) t.add(temp);\\n            }\\n            A.addAll(t);\\n        }\\n       return A.stream().max(Comparator.comparing(String::length)).get().length();\\n    }\\n boolean isUnique(String st) {\\n        if (st.length() > 26) return false;\\n        boolean A[] = new boolean[26];\\n        for(char c:st.toCharArray()){\\n            if(A[c-\\'a\\']) return false;\\n            A[c-\\'a\\']=true;\\n        }return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2983439,
                "title": "simple-self-explanatory-code",
                "content": "# Complexity\\n- Time complexity: O(2 ^ n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int max = 0;\\n    public int maxLength(List<String> arr) {\\n        rec(arr, 0, \"\");\\n        return max;\\n    }\\n    private void rec (List<String> arr, int idx, String cur) {\\n        if (idx == arr.size()){\\n            if(cur.length() > max && uniqueCharacters(cur)) {\\n                max = cur.length();\\n            }\\n            return;\\n        }\\n        rec(arr, idx + 1, cur);\\n        rec(arr, idx + 1, cur + arr.get(idx));\\n    }\\n    private boolean uniqueCharacters(String cur) {\\n        int[] res = new int[26];\\n        for (char c : cur.toCharArray()) {\\n            if (res[c - \\'a\\'] > 0) {\\n                return false;\\n            }\\n            res[c - \\'a\\']++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int maxLength(List<String> arr) {\\n        rec(arr, 0, \"\");\\n        return max;\\n    }\\n    private void rec (List<String> arr, int idx, String cur) {\\n        if (idx == arr.size()){\\n            if(cur.length() > max && uniqueCharacters(cur)) {\\n                max = cur.length();\\n            }\\n            return;\\n        }\\n        rec(arr, idx + 1, cur);\\n        rec(arr, idx + 1, cur + arr.get(idx));\\n    }\\n    private boolean uniqueCharacters(String cur) {\\n        int[] res = new int[26];\\n        for (char c : cur.toCharArray()) {\\n            if (res[c - \\'a\\'] > 0) {\\n                return false;\\n            }\\n            res[c - \\'a\\']++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982690,
                "title": "easy-to-understand-brutefore-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    bool check(vector<int> &v){\\n        for(auto &i: v)\\n        if(i>1)return false;\\n    return true;\\n    }\\n    void solve(int s,vector<string> &arr,vector<int> &v,int k){\\n        ans = max(ans,k);\\n        if(s>=arr.size())return;\\n        vector<int> tmp = v;\\n        for(auto &i: arr[s]){\\n            tmp[i-\\'a\\']++;\\n        }\\n        if(check(tmp))\\n            solve(s+1,arr,tmp,k+arr[s].length());\\n        solve(s+1,arr,v,k);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<int> v(26,0);\\n        solve(0,arr,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    bool check(vector<int> &v){\\n        for(auto &i: v)\\n        if(i>1)return false;\\n    return true;\\n    }\\n    void solve(int s,vector<string> &arr,vector<int> &v,int k){\\n        ans = max(ans,k);\\n        if(s>=arr.size())return;\\n        vector<int> tmp = v;\\n        for(auto &i: arr[s]){\\n            tmp[i-\\'a\\']++;\\n        }\\n        if(check(tmp))\\n            solve(s+1,arr,tmp,k+arr[s].length());\\n        solve(s+1,arr,v,k);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<int> v(26,0);\\n        solve(0,arr,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743052,
                "title": "java-easy-to-understand-backtracking-bitmasks",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/backtracking/MaxLengthConcatenation.java",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2741028,
                "title": "c-basic-recursion-explanation",
                "content": "Basic Recursion like how we write subsequence solution.\\nor can say **\"take\"** or **\"not take\"** approach\\n\\n```\\n\\t int ans = -1;\\n     void find(vector<string>& arr,vector<int> &v,int idx){\\n         \\n        if(idx==arr.size()){\\n            int sum=0;\\n            for(auto &i: v) sum+=i;\\n            ans = max(ans,sum);\\n            return;\\n        }\\n        \\n         int flag=1;\\n         for(auto &i: arr[idx]){\\n             v[i-\\'a\\']++;\\n             if(v[i-\\'a\\']>1){ \\n                flag=0;\\n             }\\n         }\\n         if(flag==1) \\n             find(arr,v,idx+1); //  \"take\" only if all char are unique\\n         \\n         for(auto &i: arr[idx]){\\n             v[i-\\'a\\']--;\\n         }\\n\\t\\t \\n         find(arr,v,idx+1); // always have the choice \"not to take\"     \\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        vector<int> s(26,0);\\n        int idx = 0;\\n        find(arr,s,idx);\\n        return ans;\\n    }\\n```\\n\\n**Do upvote it it helps!!**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n\\t int ans = -1;\\n     void find(vector<string>& arr,vector<int> &v,int idx){\\n         \\n        if(idx==arr.size()){\\n            int sum=0;\\n            for(auto &i: v) sum+=i;\\n            ans = max(ans,sum);\\n            return;\\n        }\\n        \\n         int flag=1;\\n         for(auto &i: arr[idx]){\\n             v[i-\\'a\\']++;\\n             if(v[i-\\'a\\']>1){ \\n                flag=0;\\n             }\\n         }\\n         if(flag==1) \\n             find(arr,v,idx+1); //  \"take\" only if all char are unique\\n         \\n         for(auto &i: arr[idx]){\\n             v[i-\\'a\\']--;\\n         }\\n\\t\\t \\n         find(arr,v,idx+1); // always have the choice \"not to take\"     \\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        vector<int> s(26,0);\\n        int idx = 0;\\n        find(arr,s,idx);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2740898,
                "title": "c-backtracking-bit-masking-explained-5ms",
                "content": "```\\nclass Solution {\\npublic:\\n    // i: arr[i] we are currently looking at\\n\\t// mask: Bitmask that represents all the characters that have been added to the current string\\n\\t// If 0-th bit in mask is set, it means that we have added \"a\" in the current string\\n    int solve(vector<string> &arr, int i, int mask) {\\n        int n = arr.size();\\n        \\n        if (i >= n)\\n            return 0;\\n        \\n        // Skip concatenating arr[i]\\n        int curRes = solve(arr, i+1, mask)\\n\\t\\t\\n\\t\\t// Mask to keep track of the characters that are present in arr[i]\\n\\t\\tint curMask = 0;\\n        \\n        // Check whether any character in arr[i] is present in current string, i.e. \\n\\t\\t// Check whether (arr[i]-\\'a\\')-th bit is set in mask\\n        // If any existing character\\'s bit is set, it means that we cannot concatenate arr[i]\\n        // to the given string and so return curRes only which contains the result of skipping arr[i]\\n        // Also, use curMask to maintain the characters in arr[i] that have been seen.\\n\\t\\t// It is possible that arr[i] itself has duplicate characters in which case, we will not be able to concatenate arr[i]\\n        // So check whether (c-\\'a\\')-th bit is set in curMask and after that set the (c-\\'a\\')-th bit in curMask\\n        for (char &c: arr[i]) {\\n            if (mask & (1 << (c - \\'a\\')))\\n                return curRes;\\n            \\n            if (curMask & (1 << (c - \\'a\\')))\\n                return curRes;\\n            \\n            curMask |= (1 << (c - \\'a\\'));\\n        }\\n        \\n        // All the bits that were set in curMask will be now set in mask, \\n\\t\\t// in order to add all characters of arr[i] to the current string\\n        mask |= curMask;\\n        \\n        // We make a call to i+1 with the updated mask and arr[i]\\'s length being added\\n        curRes = max(curRes, (int) arr[i].length() + solve(arr, i+1, mask));\\n        return curRes;\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        return solve(arr, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // i: arr[i] we are currently looking at\\n\\t// mask: Bitmask that represents all the characters that have been added to the current string\\n\\t// If 0-th bit in mask is set, it means that we have added \"a\" in the current string\\n    int solve(vector<string> &arr, int i, int mask) {\\n        int n = arr.size();\\n        \\n        if (i >= n)\\n            return 0;\\n        \\n        // Skip concatenating arr[i]\\n        int curRes = solve(arr, i+1, mask)\\n\\t\\t\\n\\t\\t// Mask to keep track of the characters that are present in arr[i]\\n\\t\\tint curMask = 0;\\n        \\n        // Check whether any character in arr[i] is present in current string, i.e. \\n\\t\\t// Check whether (arr[i]-\\'a\\')-th bit is set in mask\\n        // If any existing character\\'s bit is set, it means that we cannot concatenate arr[i]\\n        // to the given string and so return curRes only which contains the result of skipping arr[i]\\n        // Also, use curMask to maintain the characters in arr[i] that have been seen.\\n\\t\\t// It is possible that arr[i] itself has duplicate characters in which case, we will not be able to concatenate arr[i]\\n        // So check whether (c-\\'a\\')-th bit is set in curMask and after that set the (c-\\'a\\')-th bit in curMask\\n        for (char &c: arr[i]) {\\n            if (mask & (1 << (c - \\'a\\')))\\n                return curRes;\\n            \\n            if (curMask & (1 << (c - \\'a\\')))\\n                return curRes;\\n            \\n            curMask |= (1 << (c - \\'a\\'));\\n        }\\n        \\n        // All the bits that were set in curMask will be now set in mask, \\n\\t\\t// in order to add all characters of arr[i] to the current string\\n        mask |= curMask;\\n        \\n        // We make a call to i+1 with the updated mask and arr[i]\\'s length being added\\n        curRes = max(curRes, (int) arr[i].length() + solve(arr, i+1, mask));\\n        return curRes;\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        return solve(arr, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740035,
                "title": "clique-search",
                "content": "This problem can be reduced into a clique search problem in linear time.\\n\\nG = (V, E) where the vertices are the strings, and edges exist between vertices iff the two strings do not have any common letters.  If a string has a repeating lett er, its vertex removed from the graph.  Each vertex is labeled with the length of the string.\\n\\nThis problem, then, becomes a clique search problem.\\n\\n\\n```\\nstruct Graph<const MAX_SIZE: usize> {\\n    adjmat: [[bool; MAX_SIZE]; MAX_SIZE],\\n    degree: [u8; MAX_SIZE],\\n    word_scores: [u32; MAX_SIZE],\\n    n: usize,\\n}\\n\\nimpl<const MAX_SIZE: usize> Graph<MAX_SIZE> {\\n    pub fn new(arr: Vec<String>) -> Self {\\n        let n = arr.len();\\n        let n = n.min(MAX_SIZE);\\n        let arr: Vec<Option<u32>> = arr.iter().map(|s| {\\n            let mut v = 0;\\n            for c in s.chars() {\\n                let d = c as u8;\\n                let d = d - (\\'a\\' as u8);\\n                let d = 1 << d;\\n                if (v & d) != 0 {\\n                    return None;\\n                }\\n                v |= d;\\n            }\\n            Some(v)\\n        }).collect();\\n\\n        let mut nodes = vec![];\\n        for x in arr.iter() {\\n            match x {\\n                None => {},\\n                Some(x) => {nodes.push(*x);}\\n            }\\n        }\\n        std::mem::drop(&arr);\\n        let mut adjmat = [[false; MAX_SIZE]; MAX_SIZE];\\n\\n        let mut degree = [0; MAX_SIZE];\\n        let mut word_scores = [0; MAX_SIZE];\\n\\n        for i in 0..nodes.len() {\\n            let x = nodes[i];\\n            adjmat[i][i] = true;\\n            degree[i] += 1;\\n            word_scores[i] = x.count_ones();\\n            for j in i+1..nodes.len() {\\n                let y = nodes[j];\\n                if 0 == x & y {\\n                    adjmat[i][j] = true;\\n                    adjmat[j][i] = true;\\n                    degree[i] += 1;\\n                    degree[j] += 1;\\n                }\\n            }\\n        }\\n        Self {\\n            adjmat,\\n            degree,\\n            word_scores,\\n            n\\n        }\\n    }\\n\\n    /// Returns true if node n is connected to each node in clique\\n    fn is_clique(&self, clique: &Vec<u8>, n: usize) -> bool {\\n        if (self.degree[n] as usize) < (1 + clique.len()) {\\n            false\\n        } else {\\n            for &nbor in clique.iter() {\\n                let b = self.adjmat[nbor as usize][n as usize];\\n                if b == false  {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n    }\\n\\n    pub fn search_cliques(&self) -> u32 {\\n        let mut clique = vec![];\\n        let idx = 0;\\n        let cur_score = 0;\\n        self.search_cliques_rec(&mut clique, idx, cur_score)\\n    }\\n\\n    fn search_cliques_rec(&self,\\n        clique: &mut Vec<u8>,\\n        idx: usize,\\n        cur_score: u32) -> u32 {\\n        let mut best = cur_score;\\n        for i in idx..self.n {\\n            let score = self.word_scores[i];\\n            if self.is_clique(&clique, i) {\\n                clique.push(i as u8);\\n                let res = self.search_cliques_rec(clique, i+1, cur_score+score);\\n                if res > best {\\n                    best = res;\\n                }\\n                clique.pop();\\n            }\\n        }\\n        best\\n    }\\n}\\n\\nstruct Solution;\\nimpl Solution {\\n\\n    // each string of arr contains only lowercase English letters\\n    pub fn max_length(arr: Vec<String>) -> i32 {\\n        let graph = Graph::<16>::new(arr);\\n        let k = graph.search_cliques() as i32;\\n        println!(\"{}\", k);\\n        graph.search_cliques() as i32\\n    }\\n}\\n\\n\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn t1() {\\n        assert!(4 == Solution::max_length(vec![\\n            String::from(\"un\"),\\n            String::from(\"iq\"),\\n            String::from(\"ue\"),\\n        ]));\\n    }\\n\\n    #[test]\\n    fn t2() {\\n        assert!(6 == Solution::max_length(vec![\\n            String::from(\"cha\"),\\n            String::from(\"r\"),\\n            String::from(\"act\"),\\n            String::from(\"ers\"),\\n        ]));\\n    }\\n\\n    #[test]\\n    fn t3() {\\n        assert!(26 == Solution::max_length(vec![\\n            String::from(\"abcdefghijklmnopqrstuvwxyz\"),\\n        ]));\\n    }\\n\\n    #[test]\\n    fn t4() {\\n        assert!(0 == Solution::max_length(vec![\\n        ]));\\n    }\\n\\n\\n    #[test]\\n    fn t6() {\\n        assert!(0 == Solution::max_length(vec![String::from(\"aabcdefg\")]));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nstruct Graph<const MAX_SIZE: usize> {\\n    adjmat: [[bool; MAX_SIZE]; MAX_SIZE],\\n    degree: [u8; MAX_SIZE],\\n    word_scores: [u32; MAX_SIZE],\\n    n: usize,\\n}\\n\\nimpl<const MAX_SIZE: usize> Graph<MAX_SIZE> {\\n    pub fn new(arr: Vec<String>) -> Self {\\n        let n = arr.len();\\n        let n = n.min(MAX_SIZE);\\n        let arr: Vec<Option<u32>> = arr.iter().map(|s| {\\n            let mut v = 0;\\n            for c in s.chars() {\\n                let d = c as u8;\\n                let d = d - (\\'a\\' as u8);\\n                let d = 1 << d;\\n                if (v & d) != 0 {\\n                    return None;\\n                }\\n                v |= d;\\n            }\\n            Some(v)\\n        }).collect();\\n\\n        let mut nodes = vec![];\\n        for x in arr.iter() {\\n            match x {\\n                None => {},\\n                Some(x) => {nodes.push(*x);}\\n            }\\n        }\\n        std::mem::drop(&arr);\\n        let mut adjmat = [[false; MAX_SIZE]; MAX_SIZE];\\n\\n        let mut degree = [0; MAX_SIZE];\\n        let mut word_scores = [0; MAX_SIZE];\\n\\n        for i in 0..nodes.len() {\\n            let x = nodes[i];\\n            adjmat[i][i] = true;\\n            degree[i] += 1;\\n            word_scores[i] = x.count_ones();\\n            for j in i+1..nodes.len() {\\n                let y = nodes[j];\\n                if 0 == x & y {\\n                    adjmat[i][j] = true;\\n                    adjmat[j][i] = true;\\n                    degree[i] += 1;\\n                    degree[j] += 1;\\n                }\\n            }\\n        }\\n        Self {\\n            adjmat,\\n            degree,\\n            word_scores,\\n            n\\n        }\\n    }\\n\\n    /// Returns true if node n is connected to each node in clique\\n    fn is_clique(&self, clique: &Vec<u8>, n: usize) -> bool {\\n        if (self.degree[n] as usize) < (1 + clique.len()) {\\n            false\\n        } else {\\n            for &nbor in clique.iter() {\\n                let b = self.adjmat[nbor as usize][n as usize];\\n                if b == false  {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n    }\\n\\n    pub fn search_cliques(&self) -> u32 {\\n        let mut clique = vec![];\\n        let idx = 0;\\n        let cur_score = 0;\\n        self.search_cliques_rec(&mut clique, idx, cur_score)\\n    }\\n\\n    fn search_cliques_rec(&self,\\n        clique: &mut Vec<u8>,\\n        idx: usize,\\n        cur_score: u32) -> u32 {\\n        let mut best = cur_score;\\n        for i in idx..self.n {\\n            let score = self.word_scores[i];\\n            if self.is_clique(&clique, i) {\\n                clique.push(i as u8);\\n                let res = self.search_cliques_rec(clique, i+1, cur_score+score);\\n                if res > best {\\n                    best = res;\\n                }\\n                clique.pop();\\n            }\\n        }\\n        best\\n    }\\n}\\n\\nstruct Solution;\\nimpl Solution {\\n\\n    // each string of arr contains only lowercase English letters\\n    pub fn max_length(arr: Vec<String>) -> i32 {\\n        let graph = Graph::<16>::new(arr);\\n        let k = graph.search_cliques() as i32;\\n        println!(\"{}\", k);\\n        graph.search_cliques() as i32\\n    }\\n}\\n\\n\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn t1() {\\n        assert!(4 == Solution::max_length(vec![\\n            String::from(\"un\"),\\n            String::from(\"iq\"),\\n            String::from(\"ue\"),\\n        ]));\\n    }\\n\\n    #[test]\\n    fn t2() {\\n        assert!(6 == Solution::max_length(vec![\\n            String::from(\"cha\"),\\n            String::from(\"r\"),\\n            String::from(\"act\"),\\n            String::from(\"ers\"),\\n        ]));\\n    }\\n\\n    #[test]\\n    fn t3() {\\n        assert!(26 == Solution::max_length(vec![\\n            String::from(\"abcdefghijklmnopqrstuvwxyz\"),\\n        ]));\\n    }\\n\\n    #[test]\\n    fn t4() {\\n        assert!(0 == Solution::max_length(vec![\\n        ]));\\n    }\\n\\n\\n    #[test]\\n    fn t6() {\\n        assert!(0 == Solution::max_length(vec![String::from(\"aabcdefg\")]));\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2739821,
                "title": "memoization-using-map-as-dp-runtime-136ms-memoization-recursion-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkUnique(string &s){\\n        int hash[26]={0};\\n        for(int i=0; i<s.size(); i++){\\n            hash[s[i]-97]++;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(hash[i]>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int cal(int ind, string s, vector<string> &v, map<string,int> &dp){\\n        if(!checkUnique(s)){\\n            return 0;\\n        }\\n        if(ind<0){\\n            return s.size();\\n        }\\n        \\n        if(dp.find(s)!=dp.end()){\\n            return dp[s];\\n        }\\n        \\n        return dp[s]=max(cal(ind-1,s+v[ind],v,dp),cal(ind-1,s,v,dp));\\n    }\\n\\n    int maxLength(vector<string>& v) {\\n        int n=v.size();\\n        map<string,int> dp;\\n        return cal(n-1,\"\",v,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkUnique(string &s){\\n        int hash[26]={0};\\n        for(int i=0; i<s.size(); i++){\\n            hash[s[i]-97]++;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(hash[i]>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int cal(int ind, string s, vector<string> &v, map<string,int> &dp){\\n        if(!checkUnique(s)){\\n            return 0;\\n        }\\n        if(ind<0){\\n            return s.size();\\n        }\\n        \\n        if(dp.find(s)!=dp.end()){\\n            return dp[s];\\n        }\\n        \\n        return dp[s]=max(cal(ind-1,s+v[ind],v,dp),cal(ind-1,s,v,dp));\\n    }\\n\\n    int maxLength(vector<string>& v) {\\n        int n=v.size();\\n        map<string,int> dp;\\n        return cal(n-1,\"\",v,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738630,
                "title": "go-solution-backtracking-with-recursion",
                "content": "```\\nfunc duplicates(s string) bool {\\n\\tvar (\\n\\t\\tm = make(map[rune]bool)\\n\\t)\\n\\tfor _, r := range s {\\n\\t\\tif m[r] {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tm[r] = true\\n\\t}\\n\\treturn false\\n}\\n\\nfunc backtracking(arr []string, begging int, result string, skip []int, max int) int {\\n\\tfor i := begging; i < len(arr); i++ {\\n\\t\\tif skip[i] == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif !strings.ContainsAny(result, arr[i]) {\\n\\t\\t\\tskip[i] = 1\\n\\t\\t\\tif newMax := len(result) + len(arr[i]); newMax > max {\\n\\t\\t\\t\\tmax = newMax\\n\\t\\t\\t}\\n\\t\\t\\tmax = backtracking(arr, i, result+arr[i], skip, max)\\n\\t\\t\\tskip[i] = 0\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n\\nfunc maxLength(arr []string) int {\\n\\tvar (\\n\\t\\tskip   = make([]int, len(arr))\\n\\t\\tresult string\\n\\t\\tmax    int\\n\\t)\\n\\t// Set duplicates strings to skip\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tif duplicates(arr[i]) {\\n\\t\\t\\tskip[i] = 1\\n\\t\\t}\\n\\t}\\n\\treturn backtracking(arr, 0, result, skip, max)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc duplicates(s string) bool {\\n\\tvar (\\n\\t\\tm = make(map[rune]bool)\\n\\t)\\n\\tfor _, r := range s {\\n\\t\\tif m[r] {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tm[r] = true\\n\\t}\\n\\treturn false\\n}\\n\\nfunc backtracking(arr []string, begging int, result string, skip []int, max int) int {\\n\\tfor i := begging; i < len(arr); i++ {\\n\\t\\tif skip[i] == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif !strings.ContainsAny(result, arr[i]) {\\n\\t\\t\\tskip[i] = 1\\n\\t\\t\\tif newMax := len(result) + len(arr[i]); newMax > max {\\n\\t\\t\\t\\tmax = newMax\\n\\t\\t\\t}\\n\\t\\t\\tmax = backtracking(arr, i, result+arr[i], skip, max)\\n\\t\\t\\tskip[i] = 0\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n\\nfunc maxLength(arr []string) int {\\n\\tvar (\\n\\t\\tskip   = make([]int, len(arr))\\n\\t\\tresult string\\n\\t\\tmax    int\\n\\t)\\n\\t// Set duplicates strings to skip\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tif duplicates(arr[i]) {\\n\\t\\t\\tskip[i] = 1\\n\\t\\t}\\n\\t}\\n\\treturn backtracking(arr, 0, result, skip, max)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738254,
                "title": "java-recursion-solution-7ms-faster-than-93-48",
                "content": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return helper(arr, 0, 0);\\n    }\\n    \\n    public int helper(List<String> arr, int i, int bit){\\n        if(i >= arr.size())\\n            return 0;\\n        \\n        int dupl = 0;\\n        for(char c : arr.get(i).toCharArray()){\\n            int j = c - \\'a\\';\\n            // check for duplicate within string\\n            if((dupl & (1<<j)) > 0) {\\n                return helper(arr, i+1, bit);\\n            }\\n            dupl = dupl | (1<<j);\\n        }\\n        \\n        // check if duplicate with new string and old string\\n        if((bit & dupl) > 0) return helper(arr, i+1, bit);\\n                \\n        return Math.max(helper(arr, i+1, bit), arr.get(i).length() + helper(arr, i+1, bit | dupl));\\n    }\\n}\\n```\\n\\nYou can also add memoization.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return helper(arr, 0, 0);\\n    }\\n    \\n    public int helper(List<String> arr, int i, int bit){\\n        if(i >= arr.size())\\n            return 0;\\n        \\n        int dupl = 0;\\n        for(char c : arr.get(i).toCharArray()){\\n            int j = c - \\'a\\';\\n            // check for duplicate within string\\n            if((dupl & (1<<j)) > 0) {\\n                return helper(arr, i+1, bit);\\n            }\\n            dupl = dupl | (1<<j);\\n        }\\n        \\n        // check if duplicate with new string and old string\\n        if((bit & dupl) > 0) return helper(arr, i+1, bit);\\n                \\n        return Math.max(helper(arr, i+1, bit), arr.get(i).length() + helper(arr, i+1, bit | dupl));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738164,
                "title": "easy-c-recursion-backtracking-with-comments",
                "content": "```\\nclass Solution {\\nprivate:\\n    \\nbool isValid(vector<int> &taken, string &curr){//to check repeated characters using repeatedCheck vector\\n    \\n    vector<int> repeatedCheck(26, 0); \\n    \\n    for(int i=0; i<curr.size(); i++){\\n        // curr[i] - \\'a\\' maps every character to a corresponding index        \\n        if (repeatedCheck[curr[i]-\\'a\\']==1){ \\n            return false ; //has repeated characters\\n        }\\n        repeatedCheck[curr[i]-\\'a\\']=1; //else mark all chars as 1\\n    }\\n\\n    //to check chars have been taken/selected or not    \\n    for(int i=0; i<curr.size(); i++){\\n        //if already selected, we cannot take the current str\\n        if (taken[curr[i]-\\'a\\']==1)\\n            return false;\\n    }\\n    \\n    //if no repeated chars and not selected\\n    return true;\\n}\\n\\n\\nint recursive(int ind, vector<string> &arr, vector<int> &taken, int len){    \\n    if(ind==arr.size()){//base condition\\n        return len;\\n    }\\n\\n    string curr=arr[ind];\\n    if(isValid(taken, curr)==false){    // if not valid -> skip curr str and move to next index\\n        return recursive(ind+1, arr, taken, len) ;\\n    }\\n    else{//2 options -> pick or not pick(skip)\\n        \\n        for(int j=0; j<curr.size(); j++){\\n            taken[curr[j]-\\'a\\']=1; // pick - mark char in selected as taken\\n        }\\n        \\n        len+=curr.size();\\n        int pick=recursive(ind+1, arr, taken, len); //pick \\n\\n        for(int j=0; j<curr.size(); j++){\\n            taken[curr[j]-\\'a\\']=0; //backtrack and mark all chars as not taken\\n        }\\n        \\n        len-=curr.size() ; //not pick        \\n        int notpick=recursive(ind+1, arr, taken, len);\\n\\n        return max(pick, notpick); //longest length\\n    }\\n}\\n\\npublic:\\n    int maxLength(vector<string>& arr) {\\n    vector<int> taken(26, 0); //keep track of chars taken/not taken\\n    return recursive(0, arr, taken, 0);    \\n    }\\n};\\n\\n//TC : O(n*2^N) exponential\\n//where max value of n can be 26\\n//SC : O(N)\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    \\nbool isValid(vector<int> &taken, string &curr){//to check repeated characters using repeatedCheck vector\\n    \\n    vector<int> repeatedCheck(26, 0); \\n    \\n    for(int i=0; i<curr.size(); i++){\\n        // curr[i] - \\'a\\' maps every character to a corresponding index        \\n        if (repeatedCheck[curr[i]-\\'a\\']==1){ \\n            return false ; //has repeated characters\\n        }\\n        repeatedCheck[curr[i]-\\'a\\']=1; //else mark all chars as 1\\n    }\\n\\n    //to check chars have been taken/selected or not    \\n    for(int i=0; i<curr.size(); i++){\\n        //if already selected, we cannot take the current str\\n        if (taken[curr[i]-\\'a\\']==1)\\n            return false;\\n    }\\n    \\n    //if no repeated chars and not selected\\n    return true;\\n}\\n\\n\\nint recursive(int ind, vector<string> &arr, vector<int> &taken, int len){    \\n    if(ind==arr.size()){//base condition\\n        return len;\\n    }\\n\\n    string curr=arr[ind];\\n    if(isValid(taken, curr)==false){    // if not valid -> skip curr str and move to next index\\n        return recursive(ind+1, arr, taken, len) ;\\n    }\\n    else{//2 options -> pick or not pick(skip)\\n        \\n        for(int j=0; j<curr.size(); j++){\\n            taken[curr[j]-\\'a\\']=1; // pick - mark char in selected as taken\\n        }\\n        \\n        len+=curr.size();\\n        int pick=recursive(ind+1, arr, taken, len); //pick \\n\\n        for(int j=0; j<curr.size(); j++){\\n            taken[curr[j]-\\'a\\']=0; //backtrack and mark all chars as not taken\\n        }\\n        \\n        len-=curr.size() ; //not pick        \\n        int notpick=recursive(ind+1, arr, taken, len);\\n\\n        return max(pick, notpick); //longest length\\n    }\\n}\\n\\npublic:\\n    int maxLength(vector<string>& arr) {\\n    vector<int> taken(26, 0); //keep track of chars taken/not taken\\n    return recursive(0, arr, taken, 0);    \\n    }\\n};\\n\\n//TC : O(n*2^N) exponential\\n//where max value of n can be 26\\n//SC : O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738104,
                "title": "java-2-approaches-iterative-recursive",
                "content": "### **Please Upvote** :D\\n##### 1. Iterative approach:\\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        List<String> ans = new ArrayList<>();\\n        ans.add(\"\");\\n\\n        int max = 0;\\n\\n        for (String s : arr) {\\n            if (!checkIfUnique(s)) continue;\\n            List<String> newStrs = new ArrayList<>();\\n\\n            for (String str : ans) {\\n                String temp = str + s;\\n\\t\\t\\t\\t\\n                if (checkIfUnique(temp)) {\\n                    newStrs.add(temp);\\n                    max = Math.max(max, temp.length());\\n                }\\n            }\\n\\t\\t\\t\\n            ans.addAll(newStrs);\\n        }\\n\\n        return max;\\n    }\\n\\n    public boolean checkIfUnique(String s) {\\n        if (s.length() > 26) return false;\\n        int[] freq = new int[26];\\n\\n        for (char c : s.toCharArray()) {\\n            freq[c - \\'a\\']++;\\n            if (freq[c - \\'a\\'] > 1) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n^2 * k), SC: O(n)\\n// n -> size of given input list\\n// k -> size of individula strings in given list\\n```\\n##### 2. Recursive approach:\\n```\\nclass Solution {\\n    int max = 0;\\n    public int maxLength(List<String> arr) {\\n        maxUnique(arr, 0, \"\");\\n        return max;\\n    }\\n\\n    public void maxUnique(List<String> arr, int index, String curr) {\\n        if (index == arr.size() && uniqueCharCount(curr) > max) {\\n            max = curr.length();\\n            return;\\n        }\\n\\n        if (index == arr.size()) return;\\n\\n        maxUnique(arr, index + 1, curr);\\n        maxUnique(arr, index + 1, curr + arr.get(index));\\n    }\\n\\n    public int uniqueCharCount(String s) {\\n        int[] freq = new int[26];\\n\\n        for (char c : s.toCharArray()) {\\n            if (freq[c - \\'a\\']++ > 0) {\\n                return 0;\\n            }\\n        }\\n\\n        return s.length();\\n    }\\n}\\n\\n// TC: O(2^n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        List<String> ans = new ArrayList<>();\\n        ans.add(\"\");\\n\\n        int max = 0;\\n\\n        for (String s : arr) {\\n            if (!checkIfUnique(s)) continue;\\n            List<String> newStrs = new ArrayList<>();\\n\\n            for (String str : ans) {\\n                String temp = str + s;\\n\\t\\t\\t\\t\\n                if (checkIfUnique(temp)) {\\n                    newStrs.add(temp);\\n                    max = Math.max(max, temp.length());\\n                }\\n            }\\n\\t\\t\\t\\n            ans.addAll(newStrs);\\n        }\\n\\n        return max;\\n    }\\n\\n    public boolean checkIfUnique(String s) {\\n        if (s.length() > 26) return false;\\n        int[] freq = new int[26];\\n\\n        for (char c : s.toCharArray()) {\\n            freq[c - \\'a\\']++;\\n            if (freq[c - \\'a\\'] > 1) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n^2 * k), SC: O(n)\\n// n -> size of given input list\\n// k -> size of individula strings in given list\\n```\n```\\nclass Solution {\\n    int max = 0;\\n    public int maxLength(List<String> arr) {\\n        maxUnique(arr, 0, \"\");\\n        return max;\\n    }\\n\\n    public void maxUnique(List<String> arr, int index, String curr) {\\n        if (index == arr.size() && uniqueCharCount(curr) > max) {\\n            max = curr.length();\\n            return;\\n        }\\n\\n        if (index == arr.size()) return;\\n\\n        maxUnique(arr, index + 1, curr);\\n        maxUnique(arr, index + 1, curr + arr.get(index));\\n    }\\n\\n    public int uniqueCharCount(String s) {\\n        int[] freq = new int[26];\\n\\n        for (char c : s.toCharArray()) {\\n            if (freq[c - \\'a\\']++ > 0) {\\n                return 0;\\n            }\\n        }\\n\\n        return s.length();\\n    }\\n}\\n\\n// TC: O(2^n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737996,
                "title": "easy-java-solution",
                "content": "\\nclass Solution {\\n\\n    int maxLen;\\n    public int maxLength(List<String> arr) {\\n        if(arr==null || arr.size()==0) return 0;\\n\\n        helperDFS(arr,\"\",0);\\n        return maxLen;\\n    }\\n\\n    public int helperDFS(List<String> arr, String path , int index){\\n    \\n        if(isStringWithUniqueChar(path))\\n            maxLen=Math.max(maxLen,path.length());\\n\\n        if(index==arr.size() || !isStringWithUniqueChar(path)){\\n            return;\\n        }\\n\\n        for (int i = index; i < arr.size() ; i++) {\\n            helperDFS(arr,path+arr.get(i),i+1);\\n        }\\n        \\n    }\\n\\n\\n    public boolean isStringWithUniqueChar(String s){\\n        int[] freq=new int[26];\\n\\n        for(int i=0;i<s.length();i++)\\n            freq[s.charAt(i)-\\'a\\']++;\\n\\n        for(int i=0;i<freq.length;i++)\\n            if(freq[i]>1) return false;\\n\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    int maxLen;\\n    public int maxLength(List<String> arr) {\\n        if(arr==null || arr.size()==0) return 0;\\n\\n        helperDFS(arr,\"\",0);\\n        return maxLen;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2737650,
                "title": "recursion-simple-pick-and-not-pick-approach",
                "content": "class Solution {\\npublic:\\n    \\n    int solve(int i, vector<string>& arr, string s)\\n    {\\n        if(i == arr.size()) return s.size();\\n        \\n        int pick = 0, x = 0;\\n        for(int j=0; j<arr[i].size(); j++)\\n        {\\n            for(int k =0; k<s.size(); k++)\\n            {\\n                if(s[k] == arr[i][j]) {x++; break;}\\n            }\\n        }\\n        \\n        if(!x) pick = solve(i+1, arr, s+arr[i]);\\n        int not_pick = solve(i+1, arr, s);\\n        \\n        return max(pick , not_pick);\\n    }\\n    \\n    int maxLength(vector<string>& arr)\\n    {\\n        vector<string>arr1;\\n        int n = arr.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            unordered_map<char,int>mp; int x = 0;\\n            for(int j=0; j<arr[i].size();j++)\\n            {\\n                mp[arr[i][j]]++;\\n                if(mp[arr[i][j]] == 2) {x++; break;}\\n            }\\n            if(!x) arr1.push_back(arr[i]);          \\n        }\\n        \\n        return solve(0, arr1, \"\");\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int solve(int i, vector<string>& arr, string s)\\n    {\\n        if(i == arr.size()) return s.size();\\n        \\n        int pick = 0, x = 0;\\n        for(int j=0; j<arr[i].size(); j++)\\n        {\\n            for(int k =0; k<s.size(); k++)\\n            {\\n                if(s[k] == arr[i][j]) {x++; break;}",
                "codeTag": "Java"
            },
            {
                "id": 2558699,
                "title": "c-bitmasks-store-the-wrong-mask",
                "content": "```cpp\\nint maxLength(vector<string>& arr) {\\n        int N = arr.size();\\n        int ans = 0;\\n        vector<int> wrongMask;\\n\\t\\t\\n        // Enumerate every mask\\n        for(int mask = 0; mask < (1 << N); mask++) {\\n            \\n            bool notPossible = false;\\n\\t\\t\\t// We will store wrong masks in this wrongMask vector, if any two string are not valid,\\n\\t\\t\\t// then any mask which contains those two strings will be invalid. (Solves TLE)\\n            for(auto a : wrongMask) {\\n                if(__builtin_popcount(mask & a) > 1) {\\n                    notPossible = true;\\n                    break;\\n                } \\n            }\\n            \\n            if(notPossible) continue;\\n            \\n            unordered_map<char, int> M;\\n            for(int i = 0; i < N; i++) {\\n                if(mask >> i & 1) {\\n                    for(char c : arr[i]) {\\n                        if(M.count(c)) {\\n\\t\\t\\t\\t\\t\\t\\t// If map contains a duplicate character, push this mask in wrongMask\\n\\t\\t\\t\\t\\t\\t\\t// then directly jump to next mask.\\n                            wrongMask.push_back(mask);\\n                            goto nextMask;\\n                        }\\n                        M[c]++;\\n                    }\\n                }\\n            }\\n            ans = max(ans,(int)M.size());\\n            nextMask:;\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```cpp\\nint maxLength(vector<string>& arr) {\\n        int N = arr.size();\\n        int ans = 0;\\n        vector<int> wrongMask;\\n\\t\\t\\n        // Enumerate every mask\\n        for(int mask = 0; mask < (1 << N); mask++) {\\n            \\n            bool notPossible = false;\\n\\t\\t\\t// We will store wrong masks in this wrongMask vector, if any two string are not valid,\\n\\t\\t\\t// then any mask which contains those two strings will be invalid. (Solves TLE)\\n            for(auto a : wrongMask) {\\n                if(__builtin_popcount(mask & a) > 1) {\\n                    notPossible = true;\\n                    break;\\n                } \\n            }\\n            \\n            if(notPossible) continue;\\n            \\n            unordered_map<char, int> M;\\n            for(int i = 0; i < N; i++) {\\n                if(mask >> i & 1) {\\n                    for(char c : arr[i]) {\\n                        if(M.count(c)) {\\n\\t\\t\\t\\t\\t\\t\\t// If map contains a duplicate character, push this mask in wrongMask\\n\\t\\t\\t\\t\\t\\t\\t// then directly jump to next mask.\\n                            wrongMask.push_back(mask);\\n                            goto nextMask;\\n                        }\\n                        M[c]++;\\n                    }\\n                }\\n            }\\n            ans = max(ans,(int)M.size());\\n            nextMask:;\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2371121,
                "title": "very-simple-and-easy-to-understand-c-solution",
                "content": "<b> UP Vote if you like this approach and if you have learnt something\\n\\n```\\n/*\\n1. Create a integer vector, where each integer\\'s bits represent, if a particular char is present or not\\n2. Loop each word in the array and set each bit, create bit map of each word\\n3. Use recursion to add each word with take once and not to take once type dp recursion \\n4. A word can only be taken if its bits are not overlaping with the current string\\'s bit status\\n   - to do this, we need to check if there sum is equal to bit wise andding of them, \\n     if eaual then there is no overlaping, if not equal then there is overlaping\\n5. Also we don\\'t have to take the word which has repeted char ( if we have set it to INT_MAX )\\n6. Finally if i is less then 0, check the size of the s with the ans and take maximum\\n*/\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(vector<int>& v, vector<string>& arr, int i, string s, int status){\\n        if(i < 0) { \\n            ans = max(ans, (int)s.size());\\n        }else{\\n            solve(v, arr, i-1, s, status);\\n            if( (v[i] != INT_MAX ) && ( (v[i] + status) == (v[i] | status)) ){ \\n                solve(v, arr, i-1, s+arr[i], status  | v[i]);\\n            }\\n        }\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        vector<int> v(arr.size());\\n        for(int i= 0; i < arr.size(); ++i){\\n            for(auto c: arr[i]) {\\n                if((v[i] >> (c - \\'a\\'))& 1){ //if already bit is set, then set value to INT_MAX\\n                    v[i] = INT_MAX;\\n                }else{                      // if not set, then set it to 1\\n                    v[i] = v[i] | (1 << (c - \\'a\\'));\\n                }\\n            }\\n        }\\n        string s = \"\";\\n        solve(v, arr, arr.size()-1, s, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\n/*\\n1. Create a integer vector, where each integer\\'s bits represent, if a particular char is present or not\\n2. Loop each word in the array and set each bit, create bit map of each word\\n3. Use recursion to add each word with take once and not to take once type dp recursion \\n4. A word can only be taken if its bits are not overlaping with the current string\\'s bit status\\n   - to do this, we need to check if there sum is equal to bit wise andding of them, \\n     if eaual then there is no overlaping, if not equal then there is overlaping\\n5. Also we don\\'t have to take the word which has repeted char ( if we have set it to INT_MAX )\\n6. Finally if i is less then 0, check the size of the s with the ans and take maximum\\n*/\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(vector<int>& v, vector<string>& arr, int i, string s, int status){\\n        if(i < 0) { \\n            ans = max(ans, (int)s.size());\\n        }else{\\n            solve(v, arr, i-1, s, status);\\n            if( (v[i] != INT_MAX ) && ( (v[i] + status) == (v[i] | status)) ){ \\n                solve(v, arr, i-1, s+arr[i], status  | v[i]);\\n            }\\n        }\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        vector<int> v(arr.size());\\n        for(int i= 0; i < arr.size(); ++i){\\n            for(auto c: arr[i]) {\\n                if((v[i] >> (c - \\'a\\'))& 1){ //if already bit is set, then set value to INT_MAX\\n                    v[i] = INT_MAX;\\n                }else{                      // if not set, then set it to 1\\n                    v[i] = v[i] | (1 << (c - \\'a\\'));\\n                }\\n            }\\n        }\\n        string s = \"\";\\n        solve(v, arr, arr.size()-1, s, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975572,
                "title": "java-recursion",
                "content": "You either select the string or you dont, compute the answer accordingly.\\n```\\nclass Solution {\\n    public int isApplicable(String res){\\n        int[] cnt = new int[26];\\n        for(int i = 0 ; i < res.length() ; i++)\\n            cnt[res.charAt(i) - \\'a\\']++;\\n        for(int i = 0 ; i < 26 ; i++)\\n            if(cnt[i] > 1) return 0;\\n        return res.length();\\n    }\\n    public int solve(List<String> arr , int idx, String res){\\n        if(idx == arr.size()){\\n            return isApplicable(res);\\n        }\\n        \\n        int len  = res.length();\\n        res += (arr.get(idx));\\n        int size1 = solve(arr , idx + 1 , res);\\n        int size2 = solve(arr , idx + 1 , res.substring(0,len));\\n        return Math.max(size1, size2);\\n    }\\n    \\n    public int maxLength(List<String> arr) {\\n        return solve(arr , 0 ,\"\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int isApplicable(String res){\\n        int[] cnt = new int[26];\\n        for(int i = 0 ; i < res.length() ; i++)\\n            cnt[res.charAt(i) - \\'a\\']++;\\n        for(int i = 0 ; i < 26 ; i++)\\n            if(cnt[i] > 1) return 0;\\n        return res.length();\\n    }\\n    public int solve(List<String> arr , int idx, String res){\\n        if(idx == arr.size()){\\n            return isApplicable(res);\\n        }\\n        \\n        int len  = res.length();\\n        res += (arr.get(idx));\\n        int size1 = solve(arr , idx + 1 , res);\\n        int size2 = solve(arr , idx + 1 , res.substring(0,len));\\n        return Math.max(size1, size2);\\n    }\\n    \\n    public int maxLength(List<String> arr) {\\n        return solve(arr , 0 ,\"\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819363,
                "title": "backtracking-clean-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int ans=0;\\n    \\n    void backtrack(int ind, string curr, vector<string>& arr){\\n        if(ind==n){\\n            int v=curr.size();\\n            cout<<curr<<\" \";\\n            ans=max(ans, v);\\n            return;\\n        }\\n        int v=arr[ind].size();\\n        unordered_map<char, int> m;\\n        for(auto &x: curr){\\n            m[x]++;\\n        }\\n        bool f=true; //check if we can add this string to curr\\n        for(auto &x: arr[ind]){\\n            if(m.count(x))\\n            {\\n                f=false;\\n                break;\\n            }\\n            m[x]++;\\n        }\\n        if(f){ //since we can add it, now we have two options - to add it or to not add it\\n            curr+=arr[ind];\\n            backtrack(ind+1, curr, arr);\\n            curr=curr.substr(0, curr.size()-v);\\n            backtrack(ind+1, curr, arr);\\n        }\\n        else{ //we can\\'t add it\\n            backtrack(ind+1, curr, arr);\\n        }\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        n=arr.size();\\n        string curr=\"\";\\n        backtrack(0, curr, arr);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int ans=0;\\n    \\n    void backtrack(int ind, string curr, vector<string>& arr){\\n        if(ind==n){\\n            int v=curr.size();\\n            cout<<curr<<\" \";\\n            ans=max(ans, v);\\n            return;\\n        }\\n        int v=arr[ind].size();\\n        unordered_map<char, int> m;\\n        for(auto &x: curr){\\n            m[x]++;\\n        }\\n        bool f=true; //check if we can add this string to curr\\n        for(auto &x: arr[ind]){\\n            if(m.count(x))\\n            {\\n                f=false;\\n                break;\\n            }\\n            m[x]++;\\n        }\\n        if(f){ //since we can add it, now we have two options - to add it or to not add it\\n            curr+=arr[ind];\\n            backtrack(ind+1, curr, arr);\\n            curr=curr.substr(0, curr.size()-v);\\n            backtrack(ind+1, curr, arr);\\n        }\\n        else{ //we can\\'t add it\\n            backtrack(ind+1, curr, arr);\\n        }\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        n=arr.size();\\n        string curr=\"\";\\n        backtrack(0, curr, arr);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1798498,
                "title": "c-recursive-and-bit-manipulation-solution",
                "content": "DO \\u2B06\\uFE0F UPVOTE IF IT HELPS YOU IN ANYWAY\\n\\nRECURSIVE SOLUTION (In case it gives TLE try passing ans string by reference) :\\n\\n\\tclass Solution {\\n\\t\\t\\t\\t int res=0;\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tbool isunique(string &s){\\n\\t\\t\\t\\t\\tvector<int> v(26,0);\\n\\t\\t\\t\\t\\tfor(auto &it: s){\\n\\t\\t\\t\\t\\t\\tif(v[it-\\'a\\']==0)\\n\\t\\t\\t\\t\\t\\t\\t v[it-\\'a\\']++;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint max(int a,int b){\\n\\t\\t\\t\\t\\treturn (a>b)?a:b;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvoid helper(vector<string> &arr,string ans, int i){\\n\\t\\t\\t\\t\\tif(i==arr.size()){\\n\\t\\t\\t\\t\\t\\tif(isunique(ans)){\\n\\t\\t\\t\\t\\t\\t\\tres=max(res,ans.length());\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\thelper(arr,ans+arr[i],i+1);\\n\\t\\t\\t\\t\\thelper(arr,ans,i+1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint maxLength(vector<string>& arr) {\\n\\t\\t\\t\\t\\t   string ans=\"\";\\n\\t\\t\\t\\t\\t\\thelper(arr,ans,0);\\n\\t\\t\\t\\t\\t  return res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\nOPTIMISED USING BIT MANIPULATION :\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isunique(string &s){\\n\\t\\t\\tvector<int> v(26,0);\\n\\t\\t\\tfor(auto &it: s){\\n\\t\\t\\t\\tif(v[it-\\'a\\']==0)\\n\\t\\t\\t\\t\\t v[it-\\'a\\']++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tint max(int a,int b){\\n\\t\\t\\treturn (a>b)?a:b;\\n\\t\\t}\\n\\t\\tint maxLength(vector<string>& arr) {\\n\\t\\t\\t\\t int res=0;\\n\\n\\t\\t\\t\\tfor(int i=0;i<(1<<arr.size());i++){\\n\\t\\t\\t\\t\\t string ans;\\n\\t\\t\\t\\t\\tfor(int j=0;j<arr.size();j++){\\n\\t\\t\\t\\t\\t\\t\\t  if(i&(1<<j)){\\n\\t\\t\\t\\t\\t\\t\\t\\t  ans+=arr[j];\\n\\t\\t\\t\\t\\t\\t\\t  }    \\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif(isunique(ans)){\\n\\t\\t\\t\\t\\t\\tres=max(res,ans.length());\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t  return res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\t int res=0;\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tbool isunique(string &s){\\n\\t\\t\\t\\t\\tvector<int> v(26,0);\\n\\t\\t\\t\\t\\tfor(auto &it: s){\\n\\t\\t\\t\\t\\t\\tif(v[it-\\'a\\']==0)\\n\\t\\t\\t\\t\\t\\t\\t v[it-\\'a\\']++;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1780983,
                "title": "java-based-queue-approach-easy-and-simple-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public int maxLength(List<String> arr) {\\n\\t\\n        int n = arr.size();\\n\\t\\t\\n        int [] result = new int[1];\\n        \\n        maxLengthUnique(arr,result,0,\"\");\\n\\t\\t\\n        return result[0];\\n    }\\n    \\n    private void maxLengthUnique(List<String> arr,int []result,\\n                                 int index,String current){\\n\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\tint i = 0, n = arr.size();\\n\\t\\t\\n\\t\\t// We use queue to store all the combinations possible!\\n        Queue<String> q = new LinkedList<>();\\n        q.add(\"\");\\n\\t\\t\\n\\t\\t//Loop for all the strings in array.\\n        while(i < n){\\n            int size = q.size();\\n            \\n\\t\\t\\t//Loop till all the elements in Queue are appended with \"\" and the string \\'str\\'\\n            for(int loop = 0;loop < size; loop++){\\n                String temp = q.poll();    // temp = \"\" \\n                String dontConsider = temp; // dontConsider = \"\"\\n                String consider = temp + arr.get(i); // consider = \"un\" --> Aboe 3 steps Repeated till the last element.\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Function call to calculate the unique characters\\n                if(uniqueCharacters(dontConsider) > result[0]){\\n                    result[0] = dontConsider.length();\\n                }\\n\\t\\t\\t\\t// Function call to calculate the unique characters\\n                if(uniqueCharacters(consider) > result[0]){\\n                    result[0] = consider.length();\\n                }\\n\\t\\t\\t\\t// Adding the new strings to our queue again.\\n                q.add(dontConsider);\\n                q.add(consider);\\n            }\\n            i++;\\n        }\\n        \\n    }\\n    \\n    private int uniqueCharacters(String string){\\n        char[] alpha = new char[26];\\n        \\n        for(char character : string.toCharArray())\\n            if(alpha[character - \\'a\\']++ > 0) \\n                return -1;\\n        \\n        return string.length();\\n    } \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int maxLength(List<String> arr) {\\n\\t\\n        int n = arr.size();\\n\\t\\t\\n        int [] result = new int[1];\\n        \\n        maxLengthUnique(arr,result,0,\"\");\\n\\t\\t\\n        return result[0];\\n    }\\n    \\n    private void maxLengthUnique(List<String> arr,int []result,\\n                                 int index,String current){\\n\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\tint i = 0, n = arr.size();\\n\\t\\t\\n\\t\\t// We use queue to store all the combinations possible!\\n        Queue<String> q = new LinkedList<>();\\n        q.add(\"\");\\n\\t\\t\\n\\t\\t//Loop for all the strings in array.\\n        while(i < n){\\n            int size = q.size();\\n            \\n\\t\\t\\t//Loop till all the elements in Queue are appended with \"\" and the string \\'str\\'\\n            for(int loop = 0;loop < size; loop++){\\n                String temp = q.poll();    // temp = \"\" \\n                String dontConsider = temp; // dontConsider = \"\"\\n                String consider = temp + arr.get(i); // consider = \"un\" --> Aboe 3 steps Repeated till the last element.\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Function call to calculate the unique characters\\n                if(uniqueCharacters(dontConsider) > result[0]){\\n                    result[0] = dontConsider.length();\\n                }\\n\\t\\t\\t\\t// Function call to calculate the unique characters\\n                if(uniqueCharacters(consider) > result[0]){\\n                    result[0] = consider.length();\\n                }\\n\\t\\t\\t\\t// Adding the new strings to our queue again.\\n                q.add(dontConsider);\\n                q.add(consider);\\n            }\\n            i++;\\n        }\\n        \\n    }\\n    \\n    private int uniqueCharacters(String string){\\n        char[] alpha = new char[26];\\n        \\n        for(char character : string.toCharArray())\\n            if(alpha[character - \\'a\\']++ > 0) \\n                return -1;\\n        \\n        return string.length();\\n    } \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1743841,
                "title": "easy-solution-using-python3-and-backtracking",
                "content": "\\tclass Solution:\\n\\t\\tdef maxLength(self, arr: List[str]) -> int:\\n\\t\\t\\tself.m = 0\\n\\t\\t\\tdef solve(com,arr):\\n\\t\\t\\t\\tif(len(com) == len(set(com))):\\n\\t\\t\\t\\t\\tself.m = max(self.m,len(com))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\t\\tsolve(com+\"\".join(arr[i]),arr[i+1:])\\n\\t\\t\\tsolve(\"\",arr)\\n\\t\\t\\treturn self.m",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef maxLength(self, arr: List[str]) -> int:\\n\\t\\t\\tself.m = 0\\n\\t\\t\\tdef solve(com,arr):\\n\\t\\t\\t\\tif(len(com) == len(set(com))):\\n\\t\\t\\t\\t\\tself.m = max(self.m,len(com))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\t\\tsolve(com+\"\".join(arr[i]),arr[i+1:])\\n\\t\\t\\tsolve(\"\",arr)\\n\\t\\t\\treturn self.m",
                "codeTag": "Java"
            },
            {
                "id": 1562918,
                "title": "c-easy-backtracking-solution",
                "content": "![image](https://assets.leetcode.com/users/images/65c35f2a-4bac-4c28-aa6e-42bfeb23bc46_1636212918.9591146.png)\\n\\n```\\nclass Solution {\\n    bool isUnique(vector<string>& arr){\\n        vector<bool> visited(26, false);\\n        for(string word : arr){\\n            for(char ch : word){\\n                if(visited[ch - \\'a\\']){\\n                    return false;\\n                }\\n                visited[ch - \\'a\\'] = true;\\n            }\\n        }\\n        return true;\\n    }\\n    void dfs(vector<string>& arr, int index, int n, vector<string>& temp, int& maxLen){\\n        for(int i = index; i < n; i++){\\n            temp.push_back(arr[i]);\\n            if(isUnique(temp)){\\n                int len = 0;\\n                for(string word : temp){\\n                    len += word.size();\\n                }\\n                maxLen = max(maxLen, len);\\n                dfs(arr, i + 1, n, temp, maxLen);\\n            }\\n            temp.pop_back();\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int maxLen = 0;\\n        vector<string> temp;\\n        int n = arr.size();\\n        dfs(arr, 0, n, temp, maxLen);\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isUnique(vector<string>& arr){\\n        vector<bool> visited(26, false);\\n        for(string word : arr){\\n            for(char ch : word){\\n                if(visited[ch - \\'a\\']){\\n                    return false;\\n                }\\n                visited[ch - \\'a\\'] = true;\\n            }\\n        }\\n        return true;\\n    }\\n    void dfs(vector<string>& arr, int index, int n, vector<string>& temp, int& maxLen){\\n        for(int i = index; i < n; i++){\\n            temp.push_back(arr[i]);\\n            if(isUnique(temp)){\\n                int len = 0;\\n                for(string word : temp){\\n                    len += word.size();\\n                }\\n                maxLen = max(maxLen, len);\\n                dfs(arr, i + 1, n, temp, maxLen);\\n            }\\n            temp.pop_back();\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int maxLen = 0;\\n        vector<string> temp;\\n        int n = arr.size();\\n        dfs(arr, 0, n, temp, maxLen);\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562364,
                "title": "c-bit-manipulation-solution-100-faster",
                "content": "# Bit Manipulation Solution\\nReplaced the strings with their corresponding 32-bit integer number where the bits set are the characters in the string using the function `f(x) = x - 97`.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string> &arr) {\\n        vector<int> nums;\\n        for(string &i: arr) {\\n            int num = 0;\\n            bool flag = true;\\n            \\n            for(char &j: i) {\\n                int x = 1 << (j - \\'a\\');\\n                \\n                if(num & x)\\n                    flag = false;\\n                num |= x;\\n            }\\n            \\n            if(flag)\\n                nums.push_back(num);\\n        }\\n        \\n        return solve(nums, 0, 0);\\n    }\\n    \\nprivate:\\n    int solve(vector<int> &nums, int k,  int i) {\\n        int res = __builtin_popcount(k);\\n        for(int j = i; j < nums.size(); j++)\\n            if((k & nums[j]) == 0)\\n                res = max(res, solve(nums, k | nums[j], j + 1));\\n        return res;\\n    }\\n};\\n```\\n\\n**Toss an upvote to your coder :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string> &arr) {\\n        vector<int> nums;\\n        for(string &i: arr) {\\n            int num = 0;\\n            bool flag = true;\\n            \\n            for(char &j: i) {\\n                int x = 1 << (j - \\'a\\');\\n                \\n                if(num & x)\\n                    flag = false;\\n                num |= x;\\n            }\\n            \\n            if(flag)\\n                nums.push_back(num);\\n        }\\n        \\n        return solve(nums, 0, 0);\\n    }\\n    \\nprivate:\\n    int solve(vector<int> &nums, int k,  int i) {\\n        int res = __builtin_popcount(k);\\n        for(int j = i; j < nums.size(); j++)\\n            if((k & nums[j]) == 0)\\n                res = max(res, solve(nums, k | nums[j], j + 1));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480739,
                "title": "kotlin-bit-mask-recursive-and-dp-solutions-with-comments",
                "content": "Recursive Solution: \\n```\\nclass Solution {\\n    fun maxLength(arr: List<String>): Int {\\n        // Transform all strings in arr into map(mask, length)\\n        // e.g. \"abd\" -> (0...01011, 3)\\n        // e.g. \"xzda\" -> (1010...01001, 4)\\n        // e.g. \"aaa\" -> skip\\n        val subs = arr.fold(mutableMapOf<Int, Int>()) { acc, s ->\\n            var mask = 0\\n            s.forEach { c ->\\n                val bit = 1 shl c - \\'a\\'\\n                if (mask and bit == 0) { // Only accept strings without duplicated characters\\n                    mask = mask or bit\\n                } else {\\n                    return@fold acc // Skip strings with duplicated characters\\n                }\\n            }\\n            acc.also { it[mask] = s.length }\\n        }.entries.toList()\\n        \\n        var res = 0\\n        val maxMask = (1 shl 27) - 1\\n        \\n        fun findConcatenationFrom(index: Int, currentMask: Int, currentRes: Int) {\\n            if (index == subs.size || currentMask == maxMask) {\\n                res = maxOf(res, currentRes)\\n                return\\n            }\\n            // Try add subs[index] if no duplicated characters\\n            if (currentMask and subs[index].key == 0) {\\n                findConcatenationFrom(index + 1, currentMask or subs[index].key, currentRes + subs[index].value)\\n            }\\n            // Always try skip subs[index]\\n            findConcatenationFrom(index + 1, currentMask, currentRes)\\n        }\\n        findConcatenationFrom(0, 0, 0)        \\n        \\n        return res\\n    }\\n}\\n```\\n\\nDP Solution:\\n```\\nclass Solution {\\n    fun maxLength(arr: List<String>): Int {\\n        // Transform all strings in arr into map(mask, length)\\n        // e.g. \"abd\" -> (0...01011, 3)\\n        // e.g. \"xzda\" -> (1010...01001, 4)\\n        // e.g. \"aaa\" -> skip\\n        val subs = arr.fold(mutableMapOf<Int, Int>()) { acc, s ->\\n            var mask = 0\\n            s.forEach { c ->\\n                val bit = 1 shl c - \\'a\\'\\n                if (mask and bit == 0) { // Only accept strings without duplicated characters\\n                    mask = mask or bit\\n                } else {\\n                    return@fold acc // Skip strings with duplicated characters\\n                }\\n            }\\n            acc.also { it[mask] = s.length }\\n        }.map { it.key to it.value }.toSet()\\n        \\n        var res = subs.fold(0) { acc, (_, length) -> maxOf(acc, length) } // Init with the max length in subs\\n        val validSubs = mutableSetOf<Pair<Int, Int>>().apply { addAll(subs) } // Init with subs\\n        \\n        subs.forEach { (mask, length) ->\\n            val newValidSubs = mutableSetOf<Pair<Int, Int>>()\\n            validSubs.forEach { // Try concate with all valid sub-sequences we\\'ve met so far\\n                if (it.first and mask == 0) {\\n                    res = maxOf(res, it.second + length)\\n                    newValidSubs.add(it.first or mask to it.second + length)\\n                }\\n            }\\n            validSubs.addAll(newValidSubs) // Add all new valid sub-sequences\\n        }     \\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    fun maxLength(arr: List<String>): Int {\\n        // Transform all strings in arr into map(mask, length)\\n        // e.g. \"abd\" -> (0...01011, 3)\\n        // e.g. \"xzda\" -> (1010...01001, 4)\\n        // e.g. \"aaa\" -> skip\\n        val subs = arr.fold(mutableMapOf<Int, Int>()) { acc, s ->\\n            var mask = 0\\n            s.forEach { c ->\\n                val bit = 1 shl c - \\'a\\'\\n                if (mask and bit == 0) { // Only accept strings without duplicated characters\\n                    mask = mask or bit\\n                } else {\\n                    return@fold acc // Skip strings with duplicated characters\\n                }\\n            }\\n            acc.also { it[mask] = s.length }\\n        }.entries.toList()\\n        \\n        var res = 0\\n        val maxMask = (1 shl 27) - 1\\n        \\n        fun findConcatenationFrom(index: Int, currentMask: Int, currentRes: Int) {\\n            if (index == subs.size || currentMask == maxMask) {\\n                res = maxOf(res, currentRes)\\n                return\\n            }\\n            // Try add subs[index] if no duplicated characters\\n            if (currentMask and subs[index].key == 0) {\\n                findConcatenationFrom(index + 1, currentMask or subs[index].key, currentRes + subs[index].value)\\n            }\\n            // Always try skip subs[index]\\n            findConcatenationFrom(index + 1, currentMask, currentRes)\\n        }\\n        findConcatenationFrom(0, 0, 0)        \\n        \\n        return res\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maxLength(arr: List<String>): Int {\\n        // Transform all strings in arr into map(mask, length)\\n        // e.g. \"abd\" -> (0...01011, 3)\\n        // e.g. \"xzda\" -> (1010...01001, 4)\\n        // e.g. \"aaa\" -> skip\\n        val subs = arr.fold(mutableMapOf<Int, Int>()) { acc, s ->\\n            var mask = 0\\n            s.forEach { c ->\\n                val bit = 1 shl c - \\'a\\'\\n                if (mask and bit == 0) { // Only accept strings without duplicated characters\\n                    mask = mask or bit\\n                } else {\\n                    return@fold acc // Skip strings with duplicated characters\\n                }\\n            }\\n            acc.also { it[mask] = s.length }\\n        }.map { it.key to it.value }.toSet()\\n        \\n        var res = subs.fold(0) { acc, (_, length) -> maxOf(acc, length) } // Init with the max length in subs\\n        val validSubs = mutableSetOf<Pair<Int, Int>>().apply { addAll(subs) } // Init with subs\\n        \\n        subs.forEach { (mask, length) ->\\n            val newValidSubs = mutableSetOf<Pair<Int, Int>>()\\n            validSubs.forEach { // Try concate with all valid sub-sequences we\\'ve met so far\\n                if (it.first and mask == 0) {\\n                    res = maxOf(res, it.second + length)\\n                    newValidSubs.add(it.first or mask to it.second + length)\\n                }\\n            }\\n            validSubs.addAll(newValidSubs) // Add all new valid sub-sequences\\n        }     \\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479786,
                "title": "python3-one-liner-solution-using-a-pseudo-powerset-method",
                "content": "I will preface this by saying that I recognize that one-liners in python are pretty useless and create code that is unreadable. However, it is fun to try and see how much can be packed into one line. Also it helps practice becoming more pythonic.\\n\\nThe method I used to solve this problem is pretty much the same as in #78, subsets. The solutioin can be found by just creating a powerset; however, during the creation of the powerset, only allow a new subset to be created if the letters will be unique:\\n\\n```\\nreturn len(max(reduce(lambda x,y: x+[i+y for i in x if len(i+y)==len(set(i+y))], arr, [\\'\\']), key= lambda x: len(x)))\\n```\\n\\nBreaking down the oneliner into parts--\\nThis creates the powerset, the if statement filters out the sets that would have duplicate letters\\n```\\nreduce(lambda x,y: x+[i+y for i in x if len(i+y)==len(set(i+y))], arr, [\\'\\'])\\n```\\nThis finds the max length subset:\\n```\\nlen(max( (previous line) ), key= lambda x: len(x)))\\n```\\n![image](https://assets.leetcode.com/users/images/65e151e5-22e0-40b1-87b3-27373d7a6b22_1632346807.056603.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nreturn len(max(reduce(lambda x,y: x+[i+y for i in x if len(i+y)==len(set(i+y))], arr, [\\'\\']), key= lambda x: len(x)))\\n```\n```\\nreduce(lambda x,y: x+[i+y for i in x if len(i+y)==len(set(i+y))], arr, [\\'\\'])\\n```\n```\\nlen(max( (previous line) ), key= lambda x: len(x)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479769,
                "title": "java-dfs-beat-98",
                "content": "```\\nclass Solution {\\n    boolean[] forbidden = new boolean[1];\\n    boolean[][] letters = new boolean[1][1];\\n    boolean finished = false;\\n    int result = 0;\\n    int distinctLetters = 0;\\n    public int maxLength(List<String> list) {\\n        forbidden = new boolean[list.size()];\\n        letters = new boolean[list.size()][26];\\n        boolean[] uniqueLetters = new boolean[26];\\n        for (int i = 0; i < list.size(); i++) {\\n            String element = list.get(i);\\n            for (int j = 0; j < element.length(); j++) {\\n                int charIndex = element.charAt(j) - \\'a\\';\\n                if (letters[i][charIndex]) {\\n                    forbidden[i] = true;\\n                }\\n                letters[i][charIndex] = true;\\n                if (!uniqueLetters[charIndex]) {\\n                    uniqueLetters[charIndex] = true;\\n                    distinctLetters++;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < list.size(); i++) {\\n            if (!forbidden[i]) {\\n                boolean[] used = new boolean[26];\\n                char[] curLetters = list.get(i).toCharArray();\\n                for (int j = 0; j < curLetters.length; j++) {\\n                    int charIndex = curLetters[j] - \\'a\\';\\n                    used[charIndex] = true;\\n                }         \\n                dfs(list, used, list.get(i).length());\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(List<String> list, boolean[] used, int size) {\\n        result = Math.max(result, size);\\n        if (size == distinctLetters) {\\n            finished = true;\\n        }\\n        if (finished) return;\\n\\n        for (int i = 0; i < list.size(); i++) {\\n            boolean[] curLetters = letters[i];\\n            if (!forbidden[i] && canVisit(curLetters, used)) {\\n                markAsVisited(curLetters, used);\\n                dfs(list, used, size + list.get(i).length());\\n                removeFromVisited(curLetters, used);\\n            }\\n        }\\n    }\\n\\n     private void markAsVisited(boolean[] curLetters, boolean[] used) {\\n        for (int j = 0; j < 26; j++) {\\n            if (curLetters[j]) {\\n                used[j] = true;\\n            }\\n        }\\n    }\\n    \\n    private void removeFromVisited(boolean[] curLetters, boolean[] used) {\\n        for (int j = 0; j < 26; j++) {\\n            if (curLetters[j]) {\\n                used[j] = false;\\n            }\\n        }\\n    }\\n    \\n    private boolean canVisit(boolean[] curLetters, boolean[] used) {\\n        boolean canVisit = true;\\n        for (int j = 0; j < 26; j++) {\\n            if (curLetters[j] && used[j]) {\\n                canVisit = false;\\n                break;\\n            }\\n        }\\n        return canVisit;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean[] forbidden = new boolean[1];\\n    boolean[][] letters = new boolean[1][1];\\n    boolean finished = false;\\n    int result = 0;\\n    int distinctLetters = 0;\\n    public int maxLength(List<String> list) {\\n        forbidden = new boolean[list.size()];\\n        letters = new boolean[list.size()][26];\\n        boolean[] uniqueLetters = new boolean[26];\\n        for (int i = 0; i < list.size(); i++) {\\n            String element = list.get(i);\\n            for (int j = 0; j < element.length(); j++) {\\n                int charIndex = element.charAt(j) - \\'a\\';\\n                if (letters[i][charIndex]) {\\n                    forbidden[i] = true;\\n                }\\n                letters[i][charIndex] = true;\\n                if (!uniqueLetters[charIndex]) {\\n                    uniqueLetters[charIndex] = true;\\n                    distinctLetters++;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < list.size(); i++) {\\n            if (!forbidden[i]) {\\n                boolean[] used = new boolean[26];\\n                char[] curLetters = list.get(i).toCharArray();\\n                for (int j = 0; j < curLetters.length; j++) {\\n                    int charIndex = curLetters[j] - \\'a\\';\\n                    used[charIndex] = true;\\n                }         \\n                dfs(list, used, list.get(i).length());\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(List<String> list, boolean[] used, int size) {\\n        result = Math.max(result, size);\\n        if (size == distinctLetters) {\\n            finished = true;\\n        }\\n        if (finished) return;\\n\\n        for (int i = 0; i < list.size(); i++) {\\n            boolean[] curLetters = letters[i];\\n            if (!forbidden[i] && canVisit(curLetters, used)) {\\n                markAsVisited(curLetters, used);\\n                dfs(list, used, size + list.get(i).length());\\n                removeFromVisited(curLetters, used);\\n            }\\n        }\\n    }\\n\\n     private void markAsVisited(boolean[] curLetters, boolean[] used) {\\n        for (int j = 0; j < 26; j++) {\\n            if (curLetters[j]) {\\n                used[j] = true;\\n            }\\n        }\\n    }\\n    \\n    private void removeFromVisited(boolean[] curLetters, boolean[] used) {\\n        for (int j = 0; j < 26; j++) {\\n            if (curLetters[j]) {\\n                used[j] = false;\\n            }\\n        }\\n    }\\n    \\n    private boolean canVisit(boolean[] curLetters, boolean[] used) {\\n        boolean canVisit = true;\\n        for (int j = 0; j < 26; j++) {\\n            if (curLetters[j] && used[j]) {\\n                canVisit = false;\\n                break;\\n            }\\n        }\\n        return canVisit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478724,
                "title": "java-bit-manipulation-with-recursion",
                "content": "I think i have a pretty straightforward solution here using a mask to count the character frequency.\\n\\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return findMax(arr, 0, 0);\\n    }\\n    int findMax(List<String> arr, int currentIndex, int mask) {\\n        if(currentIndex == arr.size()) return Integer.bitCount(mask);\\n    \\n\\t\\t// Skip the current item, and analyze the next one\\n        int count = findMax(arr, currentIndex + 1, mask);\\n        \\n\\t\\t// Now look at the current item so far and see if any of the characters in the mask overlap.\\n        var item = arr.get(currentIndex);\\n        \\n        int newMask = mask;\\n        for(var c: item.toCharArray()) {\\n\\t\\t\\t// return the previous count if you see any characters that are present in the map\\n            if((newMask & (1 << c - \\'a\\')) != 0) return count;\\n\\t\\t\\t// otherwise modify the mask and set the appropriate bit for the character index\\n            newMask |= (1 << (c -\\'a\\'));    \\n        }\\n\\t\\t// the max count is the max of both the count determined by skipping the current element, and the count from including the element.\\n        return Math.max(count, findMax(arr, currentIndex + 1, newMask));\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return findMax(arr, 0, 0);\\n    }\\n    int findMax(List<String> arr, int currentIndex, int mask) {\\n        if(currentIndex == arr.size()) return Integer.bitCount(mask);\\n    \\n\\t\\t// Skip the current item, and analyze the next one\\n        int count = findMax(arr, currentIndex + 1, mask);\\n        \\n\\t\\t// Now look at the current item so far and see if any of the characters in the mask overlap.\\n        var item = arr.get(currentIndex);\\n        \\n        int newMask = mask;\\n        for(var c: item.toCharArray()) {\\n\\t\\t\\t// return the previous count if you see any characters that are present in the map\\n            if((newMask & (1 << c - \\'a\\')) != 0) return count;\\n\\t\\t\\t// otherwise modify the mask and set the appropriate bit for the character index\\n            newMask |= (1 << (c -\\'a\\'));    \\n        }\\n\\t\\t// the max count is the max of both the count determined by skipping the current element, and the count from including the element.\\n        return Math.max(count, findMax(arr, currentIndex + 1, newMask));\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478613,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_length(arr: Vec<String>) -> i32 {\\n        let arr = arr\\n            .iter()\\n            .filter_map(|s| {\\n                let u = s.bytes().map(|u| 1 << (u - b\\'a\\')).sum::<u32>();\\n                if u.count_ones() == s.len() as u32 {\\n                    Some(u)\\n                } else {\\n                    None\\n                }\\n            })\\n            .collect::<Vec<_>>();\\n        (0..1 << arr.len())\\n            .filter_map(|i| {\\n                (0..arr.len())\\n                    .filter(|&j| i & 1 << j != 0)\\n                    .try_fold(0, |acc, j| {\\n                        if acc & arr[j] == 0 {\\n                            Some(acc | arr[j])\\n                        } else {\\n                            None\\n                        }\\n                    })\\n                    .map(|u| u.count_ones())\\n            })\\n            .max()\\n            .unwrap() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_length(arr: Vec<String>) -> i32 {\\n        let arr = arr\\n            .iter()\\n            .filter_map(|s| {\\n                let u = s.bytes().map(|u| 1 << (u - b\\'a\\')).sum::<u32>();\\n                if u.count_ones() == s.len() as u32 {\\n                    Some(u)\\n                } else {\\n                    None\\n                }\\n            })\\n            .collect::<Vec<_>>();\\n        (0..1 << arr.len())\\n            .filter_map(|i| {\\n                (0..arr.len())\\n                    .filter(|&j| i & 1 << j != 0)\\n                    .try_fold(0, |acc, j| {\\n                        if acc & arr[j] == 0 {\\n                            Some(acc | arr[j])\\n                        } else {\\n                            None\\n                        }\\n                    })\\n                    .map(|u| u.count_ones())\\n            })\\n            .max()\\n            .unwrap() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352187,
                "title": "4ms-clean-easy-code-c-dfs-no-real-concatenation-maintaining-frequency-array",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<string> &arr, int index, int *freq) {\\n        if(index >= arr.size()) return 0;\\n        \\n        for(char c:arr[index]){ \\n            freq[c-\\'a\\'] += 1;\\n        }\\n        \\n        for(char c:arr[index]){ \\n            if(freq[c-\\'a\\'] > 1) {\\n                for(char c: arr[index]) freq[c-\\'a\\'] -= 1;\\n                return 0;\\n            }\\n        }\\n        \\n        int ans = arr[index].size();\\n        \\n        for(int i=index+1; i<arr.size(); i++) {\\n            ans = max(ans, (int)arr[index].length() + dfs(arr, i, freq));\\n        }\\n        \\n        for(char c: arr[index]) freq[c-\\'a\\'] -= 1;\\n        \\n        return ans;\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        int ans = 0;\\n        for(int i=0; i<arr.size(); i++) {\\n            int freq[26] = {0};\\n            ans = max(ans, dfs(arr, i, freq));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<string> &arr, int index, int *freq) {\\n        if(index >= arr.size()) return 0;\\n        \\n        for(char c:arr[index]){ \\n            freq[c-\\'a\\'] += 1;\\n        }\\n        \\n        for(char c:arr[index]){ \\n            if(freq[c-\\'a\\'] > 1) {\\n                for(char c: arr[index]) freq[c-\\'a\\'] -= 1;\\n                return 0;\\n            }\\n        }\\n        \\n        int ans = arr[index].size();\\n        \\n        for(int i=index+1; i<arr.size(); i++) {\\n            ans = max(ans, (int)arr[index].length() + dfs(arr, i, freq));\\n        }\\n        \\n        for(char c: arr[index]) freq[c-\\'a\\'] -= 1;\\n        \\n        return ans;\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        int ans = 0;\\n        for(int i=0; i<arr.size(); i++) {\\n            int freq[26] = {0};\\n            ans = max(ans, dfs(arr, i, freq));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273162,
                "title": "python-backtracking-with-set",
                "content": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        charSet = [set(s) for s in arr if len(s) == len(set(s))] # obviate duplicates\\n\\n        def dfs(chars, i):\\n            if i == len(charSet):\\n                return len(chars)\\n            if not chars.intersection(charSet[i]): # disjoint\\n                return max(dfs(chars.union(charSet[i]), i + 1), # choose set[i]\\n                           dfs(chars, i + 1)) # not choose set[i]\\n            else:\\n                return dfs(chars, i + 1)\\n            \\n        return dfs(set(), 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        charSet = [set(s) for s in arr if len(s) == len(set(s))] # obviate duplicates\\n\\n        def dfs(chars, i):\\n            if i == len(charSet):\\n                return len(chars)\\n            if not chars.intersection(charSet[i]): # disjoint\\n                return max(dfs(chars.union(charSet[i]), i + 1), # choose set[i]\\n                           dfs(chars, i + 1)) # not choose set[i]\\n            else:\\n                return dfs(chars, i + 1)\\n            \\n        return dfs(set(), 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269888,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    int count=0;\\n    public int maxLength(List<String> a1) {\\n        \\n        count=0;\\n        solve(a1,0,\"\");\\n        return count;\\n    }\\n    public void solve(List<String> s1,int index,String res)\\n    {\\n        if(index==s1.size())\\n        {\\n            if(checkIt(res)==true)\\n            {\\n                count=Math.max(count,res.length());\\n            }                        \\n            return;\\n        }        \\n        solve(s1,index+1,res);\\n        solve(s1,index+1,res+s1.get(index));\\n    }\\n    public boolean checkIt(String res)\\n    {\\n        int []count =new int[26];\\n        for(int i=0;i<res.length();i++)\\n        {\\n            char ch1=res.charAt(i);\\n            count[ch1-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(count[i]>1)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int count=0;\\n    public int maxLength(List<String> a1) {\\n        \\n        count=0;\\n        solve(a1,0,\"\");\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1186501,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        self.max_l = 0\\n        \\n        self.dfs(arr, \\'\\', set(), 0)\\n        \\n        return self.max_l\\n    \\n    def dfs(self, arr, cur_s, visited, idx):\\n        if idx == len(arr):\\n            return \\n        \\n        for i in range(idx, len(arr)):\\n            if i in visited:\\n                continue\\n            if len(cur_s) + len(arr[i]) != len(set(cur_s + arr[i])):\\n                continue\\n            \\n            self.max_l = max(self.max_l, len(cur_s) + len(arr[i]))\\n            \\n            visited.add(i)\\n            self.dfs(arr, cur_s + arr[i], visited, i + 1)\\n            visited.remove(i)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        self.max_l = 0\\n        \\n        self.dfs(arr, \\'\\', set(), 0)\\n        \\n        return self.max_l\\n    \\n    def dfs(self, arr, cur_s, visited, idx):\\n        if idx == len(arr):\\n            return \\n        \\n        for i in range(idx, len(arr)):\\n            if i in visited:\\n                continue\\n            if len(cur_s) + len(arr[i]) != len(set(cur_s + arr[i])):\\n                continue\\n            \\n            self.max_l = max(self.max_l, len(cur_s) + len(arr[i]))\\n            \\n            visited.add(i)\\n            self.dfs(arr, cur_s + arr[i], visited, i + 1)\\n            visited.remove(i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181254,
                "title": "python3-power-set-solution-beats-98",
                "content": "The idea is to generate a power set of input string array but allow only strings with unique characters in it. After that, it is pretty straightforward to find the longest string and return it\\'s length.\\n\\n```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        powerset = [\"\"]\\n        \\n        for word in arr:\\n            powerset += [subset + word for subset in powerset if self.hasUniqueChars(subset + word)]\\n            \\n        return len(max(powerset, key=len))\\n    \\n    def hasUniqueChars(self, word):\\n        return len(word) == len(set(word))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        powerset = [\"\"]\\n        \\n        for word in arr:\\n            powerset += [subset + word for subset in powerset if self.hasUniqueChars(subset + word)]\\n            \\n        return len(max(powerset, key=len))\\n    \\n    def hasUniqueChars(self, word):\\n        return len(word) == len(set(word))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138265,
                "title": "python-with-dp",
                "content": "based on lee215\\'s solution \\n```\\n    def maxLength_concat_str(self, arr: List[str]) -> int:\\n        ## like dynamic programmic, store previous values \\n        dp = [set()]\\n        for str_arr in arr:\\n            ## skip the str that have duplicate characters\\n            if len(set(str_arr)) < len(str_arr):\\n                continue\\n            ## convert str to set, to use python operator & and |\\n            str_arr = set(str_arr)\\n            for str_dp in dp[:]:\\n                ## we could have same strings appear together, skip them\\n                ## any common strings, skip them\\n                ## & Binary AND\\tOperator copies a bit to the result if it exists in both operands\\n                if str_arr & str_dp: \\n                    continue\\n                ## combint both the strings and append to dp\\n                ## | Binary OR\\tIt copies a bit if it exists in either operand.\\n                dp.append(str_arr | str_dp)\\n                print(dp)\\n        return max(len(str_dp) for str_dp in dp)\\n```\\n\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n    def maxLength_concat_str(self, arr: List[str]) -> int:\\n        ## like dynamic programmic, store previous values \\n        dp = [set()]\\n        for str_arr in arr:\\n            ## skip the str that have duplicate characters\\n            if len(set(str_arr)) < len(str_arr):\\n                continue\\n            ## convert str to set, to use python operator & and |\\n            str_arr = set(str_arr)\\n            for str_dp in dp[:]:\\n                ## we could have same strings appear together, skip them\\n                ## any common strings, skip them\\n                ## & Binary AND\\tOperator copies a bit to the result if it exists in both operands\\n                if str_arr & str_dp: \\n                    continue\\n                ## combint both the strings and append to dp\\n                ## | Binary OR\\tIt copies a bit if it exists in either operand.\\n                dp.append(str_arr | str_dp)\\n                print(dp)\\n        return max(len(str_dp) for str_dp in dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1099018,
                "title": "java-backtracking-faster-than-100-and-less-than-96-with-explanation",
                "content": "You can find explanation here: https://www.tipeca.com/learning/leetcode-1239-maximum-length-of-a-concatenated-string-with-unique-characters/\\n\\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        Str[] strs = new Str[arr.size()];\\n        for (int i = 0; i < strs.length; i++) {\\n            strs[i] = new Str(arr.get(i));\\n        }\\n        \\n        int max = 0;\\n        for (int i = 0; i < strs.length; i++) {\\n            max = Math.max(search(strs, i, 0), max);\\n        }\\n        return max;\\n    }\\n    \\n    private int search(Str[] str, int idx, int acc) {\\n        if (idx == str.length) return 0;\\n        if (!str[idx].usable || (acc & str[idx].key) != 0) return 0;\\n        int max = 0;\\n        int key = str[idx].key | acc;\\n        for (int i = idx + 1; i < str.length; i++) {\\n            max = Math.max(search(str, i, key), max);\\n        }\\n        return str[idx].len + max;\\n    }\\n    \\n    class Str {\\n        int key = 0;\\n        int len = 0;\\n        boolean usable = true;\\n        \\n        public Str (String s) {\\n            for (char c : s.toCharArray()) {\\n                int bit = (1 << (c - \\'a\\'));\\n                if ((bit & key) != 0) {\\n                    usable = false;\\n                    break;\\n                }\\n                key = key | (1 << (c - \\'a\\'));\\n            }\\n            len = s.length();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        Str[] strs = new Str[arr.size()];\\n        for (int i = 0; i < strs.length; i++) {\\n            strs[i] = new Str(arr.get(i));\\n        }\\n        \\n        int max = 0;\\n        for (int i = 0; i < strs.length; i++) {\\n            max = Math.max(search(strs, i, 0), max);\\n        }\\n        return max;\\n    }\\n    \\n    private int search(Str[] str, int idx, int acc) {\\n        if (idx == str.length) return 0;\\n        if (!str[idx].usable || (acc & str[idx].key) != 0) return 0;\\n        int max = 0;\\n        int key = str[idx].key | acc;\\n        for (int i = idx + 1; i < str.length; i++) {\\n            max = Math.max(search(str, i, key), max);\\n        }\\n        return str[idx].len + max;\\n    }\\n    \\n    class Str {\\n        int key = 0;\\n        int len = 0;\\n        boolean usable = true;\\n        \\n        public Str (String s) {\\n            for (char c : s.toCharArray()) {\\n                int bit = (1 << (c - \\'a\\'));\\n                if ((bit & key) != 0) {\\n                    usable = false;\\n                    break;\\n                }\\n                key = key | (1 << (c - \\'a\\'));\\n            }\\n            len = s.length();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089007,
                "title": "pure-bit-manipulation-beats-93",
                "content": "\\n```\\n/**\\n * Assuming Integer a and b represent String S and P.\\n * a | b => join String S and P\\n * a & b => 0 means no duplicates between S and P, otherwise there are duplicates.\\n*/\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return maxLen(arr, 0, 0);\\n    }\\n\\n    private int maxLen(List<String> arr, int i, int path) {\\n        if (i == arr.size()) return 0;\\n        int without_i = maxLen(arr, i + 1, path);\\n        String s = arr.get(i);\\n        int bits = str2bits(s.toCharArray());\\n        int with_i = (bits < 0 || (bits & path) > 0) ? 0 : maxLen(arr, i + 1, bits | path) + s.length();; \\n        return Math.max(without_i, with_i);\\n    }\\n\\n    private int str2bits(char[] a) {\\n        int n = 0;\\n        for (int i = 0; n >= 0 && i < a.length; i++) {\\n            int mask = 1 << (a[i] - \\'a\\');\\n            n = (n & mask) > 0 ? -1 : (n | mask);\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Assuming Integer a and b represent String S and P.\\n * a | b => join String S and P\\n * a & b => 0 means no duplicates between S and P, otherwise there are duplicates.\\n*/\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return maxLen(arr, 0, 0);\\n    }\\n\\n    private int maxLen(List<String> arr, int i, int path) {\\n        if (i == arr.size()) return 0;\\n        int without_i = maxLen(arr, i + 1, path);\\n        String s = arr.get(i);\\n        int bits = str2bits(s.toCharArray());\\n        int with_i = (bits < 0 || (bits & path) > 0) ? 0 : maxLen(arr, i + 1, bits | path) + s.length();; \\n        return Math.max(without_i, with_i);\\n    }\\n\\n    private int str2bits(char[] a) {\\n        int n = 0;\\n        for (int i = 0; n >= 0 && i < a.length; i++) {\\n            int mask = 1 << (a[i] - \\'a\\');\\n            n = (n & mask) > 0 ? -1 : (n | mask);\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042827,
                "title": "c-backtracking-solution-using-hashset-functions-overlaps-unionwith-exceptwith",
                "content": "\\n\\n```\\npublic class Solution {\\n    \\n    int max = 0;\\n    \\n    public int MaxLength(IList<string> arr) {\\n        \\n        if(arr == null)            \\n            return 0;\\n        \\n        Backtrack(arr, new HashSet<char>(), 0);\\n        return max;\\n    }\\n    \\n    private void Backtrack(IList<string> arr, HashSet<char> letters, int start)\\n    {        \\n        max = Math.Max(max, letters.Count);\\n        if(start == arr.Count)\\n            return;\\n            \\n        for(int i = start; i < arr.Count; i++)\\n        {\\n            HashSet<char> temp = new HashSet<char>();\\n            temp.UnionWith(arr[i]);\\n                \\n            if(letters.Overlaps(arr[i]) || temp.Count != arr[i].Length)\\n                continue;\\n                        \\n            letters.UnionWith(arr[i]); \\n            Backtrack(arr, letters, i + 1);\\n            letters.ExceptWith(arr[i]);\\n             \\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    int max = 0;\\n    \\n    public int MaxLength(IList<string> arr) {\\n        \\n        if(arr == null)            \\n            return 0;\\n        \\n        Backtrack(arr, new HashSet<char>(), 0);\\n        return max;\\n    }\\n    \\n    private void Backtrack(IList<string> arr, HashSet<char> letters, int start)\\n    {        \\n        max = Math.Max(max, letters.Count);\\n        if(start == arr.Count)\\n            return;\\n            \\n        for(int i = start; i < arr.Count; i++)\\n        {\\n            HashSet<char> temp = new HashSet<char>();\\n            temp.UnionWith(arr[i]);\\n                \\n            if(letters.Overlaps(arr[i]) || temp.Count != arr[i].Length)\\n                continue;\\n                        \\n            letters.UnionWith(arr[i]); \\n            Backtrack(arr, letters, i + 1);\\n            letters.ExceptWith(arr[i]);\\n             \\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042662,
                "title": "c-dfs-two-choices-select-skip",
                "content": "Jan. 30, 2021\\nIt is one of leetcode premium mock onsite algorithm. It is the second one. I do believe that it is important for me to write a working solution instead of thinking optimal solution in terms of time complexity. \\n\\nI will review my solution later. Stay tuned. \\n\\n```\\npublic class Solution {\\n    public int MaxLength(IList<string> arr) {\\n        if(arr == null || arr.Count == 0)\\n            return 0; \\n        \\n        var length = arr.Count; \\n        \\n        // Run DFS \\n        var maxLength = 0 ; \\n        var set = new HashSet<char>(); \\n        \\n        runDFS(arr, 0, set, ref maxLength ); \\n        \\n        return maxLength; \\n    }\\n    \\n    private void runDFS(IList<string> arr, int index, HashSet<char> set, ref int maxLength)\\n    {\\n        if(index >= arr.Count || set.Count == 26)\\n        {\\n            if(set.Count > maxLength)\\n                maxLength = set.Count; \\n            \\n            return; \\n        }\\n        \\n        var current = arr[index];\\n        var currentSet = new HashSet<char>(current);\\n        \\n        currentSet.UnionWith(set);\\n        if(currentSet.Count == current.Length + set.Count)\\n        {\\n            runDFS(arr, index, currentSet, ref maxLength);\\n        }\\n        \\n        // skip the current element\\n        runDFS(arr, index + 1, set, ref maxLength);        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxLength(IList<string> arr) {\\n        if(arr == null || arr.Count == 0)\\n            return 0; \\n        \\n        var length = arr.Count; \\n        \\n        // Run DFS \\n        var maxLength = 0 ; \\n        var set = new HashSet<char>(); \\n        \\n        runDFS(arr, 0, set, ref maxLength ); \\n        \\n        return maxLength; \\n    }\\n    \\n    private void runDFS(IList<string> arr, int index, HashSet<char> set, ref int maxLength)\\n    {\\n        if(index >= arr.Count || set.Count == 26)\\n        {\\n            if(set.Count > maxLength)\\n                maxLength = set.Count; \\n            \\n            return; \\n        }\\n        \\n        var current = arr[index];\\n        var currentSet = new HashSet<char>(current);\\n        \\n        currentSet.UnionWith(set);\\n        if(currentSet.Count == current.Length + set.Count)\\n        {\\n            runDFS(arr, index, currentSet, ref maxLength);\\n        }\\n        \\n        // skip the current element\\n        runDFS(arr, index + 1, set, ref maxLength);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1040284,
                "title": "c-solution-using-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPossibleLen = 0;\\n    void checkCombination(vector<string> arr, int start, string &res) {\\n        if (res.length() > maxPossibleLen)\\n            maxPossibleLen = res.length();\\n        if (start == arr.size())\\n            return;\\n        for (int i = start; i < arr.size(); i++) {\\n            string temp = res + arr[i];\\n            bool mask[27] = {false};\\n            for (char c: res)\\n                mask[c-\\'a\\'] = true;\\n            bool unique_chars = true;\\n            for (char c: arr[i]) {\\n                if (mask[c-\\'a\\']) {\\n                    unique_chars = false;\\n                    break;\\n                }\\n                mask[c-\\'a\\'] = true;\\n            }\\n            if (unique_chars)\\n                checkCombination(arr, i + 1, temp);\\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        string res;\\n        checkCombination(arr, 0, res);\\n        return maxPossibleLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPossibleLen = 0;\\n    void checkCombination(vector<string> arr, int start, string &res) {\\n        if (res.length() > maxPossibleLen)\\n            maxPossibleLen = res.length();\\n        if (start == arr.size())\\n            return;\\n        for (int i = start; i < arr.size(); i++) {\\n            string temp = res + arr[i];\\n            bool mask[27] = {false};\\n            for (char c: res)\\n                mask[c-\\'a\\'] = true;\\n            bool unique_chars = true;\\n            for (char c: arr[i]) {\\n                if (mask[c-\\'a\\']) {\\n                    unique_chars = false;\\n                    break;\\n                }\\n                mask[c-\\'a\\'] = true;\\n            }\\n            if (unique_chars)\\n                checkCombination(arr, i + 1, temp);\\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        string res;\\n        checkCombination(arr, 0, res);\\n        return maxPossibleLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030178,
                "title": "super-simple-code-for-backtracking-python",
                "content": "Super simple code for backtracking.\\n\\n    def maxLength(self, arr: List[str]) -> int:\\n        self.ans = 0\\n        self.helper(arr, \\'\\', 0)\\n        return self.ans\\n    \\n    def helper(self, arr, comb, start):\\n        if len(set(list(comb))) == len(comb): # or len(set(comb)) == len(comb)\\n            self.ans = max(self.ans, len(comb))\\n        else: # has duplicates\\n            return\\n        \\n        for i in range(start, len(arr)):\\n            self.helper(arr, comb + arr[i], i + 1)\\n",
                "solutionTags": [],
                "code": "Super simple code for backtracking.\\n\\n    def maxLength(self, arr: List[str]) -> int:\\n        self.ans = 0\\n        self.helper(arr, \\'\\', 0)\\n        return self.ans\\n    \\n    def helper(self, arr, comb, start):\\n        if len(set(list(comb))) == len(comb): # or len(set(comb)) == len(comb)\\n            self.ans = max(self.ans, len(comb))\\n        else: # has duplicates\\n            return\\n        \\n        for i in range(start, len(arr)):\\n            self.helper(arr, comb + arr[i], i + 1)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 881754,
                "title": "just-a-modified-subset-problem",
                "content": "So my first intuition was to generate all the possible subsets of the given array and then check for the validity mentioned in the question. \\nMeanwhile when i am checking the validity the maxlength is also updated.\\n\\nThis solution is quite easy to understand works like charm.\\n\\n***Please upvote if found helpful***\\n```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        m=0\\n        \\n        def ok(curr):   # checks the validity of the generated subset and updates max length of unique word\\n            nonlocal m\\n            s=[i for i in \"\".join(i for i in curr)]\\n            if len(set(s))==len(s):\\n                m=max(m,len(s))\\n                \\n        def fun(idx,arr,curr):  # generates subsets through recursion\\n            ok(curr.copy())\\n            for i in range(idx,len(arr)):\\n                curr.append(arr[i])\\n                fun(i+1,arr,curr)\\n                curr.pop()        \\n        fun(0,arr,[])\\n        return m\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        m=0\\n        \\n        def ok(curr):   # checks the validity of the generated subset and updates max length of unique word\\n            nonlocal m\\n            s=[i for i in \"\".join(i for i in curr)]\\n            if len(set(s))==len(s):\\n                m=max(m,len(s))\\n                \\n        def fun(idx,arr,curr):  # generates subsets through recursion\\n            ok(curr.copy())\\n            for i in range(idx,len(arr)):\\n                curr.append(arr[i])\\n                fun(i+1,arr,curr)\\n                curr.pop()        \\n        fun(0,arr,[])\\n        return m\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 872596,
                "title": "python-3-3-8-backtracking-set-union-walrus-operator-explanation",
                "content": "I think it\\'s totally reasonable if you don\\'t like or not familiar with Walrus operator (`:=`), but it does help to make the code shorter. Also, it\\'s not too hard to understand.\\n\\n### Explanation\\n- Basic idea is to turn `arr` to `[(set(word), len(word))]` if word has no repeat letter\\n- Then we can use union (`&`) operation to check whether length of set after union is same as the sum of two size\\n\\t- `if (union_len:=len(union:=arr[i][0] | cur_s)) == arr[i][1] + cur_l]`\\n\\t- `if len(arr[i][0] | cur_s) == arr[i][1] + cur_l` same as above\\n- Due to the small data sacle (max length of `arr` is 16), use backtracking to try out all possbilities\\n- Maintain a maximum length with `ans`\\n### Implementation\\n```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        arr = [(s, l) for word in arr if (l:=len(s:=set(word))) == len(word)]\\n        ans, n = 0, len(arr)\\n        def dfs(arr, cur_s, cur_l, idx):\\n            nonlocal ans, n\\n            ans = max(ans, cur_l)\\n            if idx == n: return \\n            [dfs(arr, union, union_len, i+1) for i in range(idx, n) if (union_len:=len(union:=arr[i][0] | cur_s)) == arr[i][1] + cur_l]\\n        dfs(arr, set(), 0, 0)                    \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        arr = [(s, l) for word in arr if (l:=len(s:=set(word))) == len(word)]\\n        ans, n = 0, len(arr)\\n        def dfs(arr, cur_s, cur_l, idx):\\n            nonlocal ans, n\\n            ans = max(ans, cur_l)\\n            if idx == n: return \\n            [dfs(arr, union, union_len, i+1) for i in range(idx, n) if (union_len:=len(union:=arr[i][0] | cur_s)) == arr[i][1] + cur_l]\\n        dfs(arr, set(), 0, 0)                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859260,
                "title": "java-set-backtracking",
                "content": "Use a set to maintain uniqueness.\\nAdd characters of each list element into the set if uniqueness is gauranteed and then recurse to add the subsequent list elements.\\nIf uniqueness is not maintained then don\\'t recurse.\\nBacktrack to see all paths.\\n\\n```\\nclass Solution {\\n    \\n    int answer = 0;\\n    \\n    public int maxLength(List<String> arr) {\\n        maxPossibleLength(arr, new HashSet<>(), 0);\\n        return answer;\\n    }\\n    \\n    public void maxPossibleLength(List<String> arr, Set<Character> set, int start) {\\n\\n        answer = Math.max(answer, set.size());\\n        \\n        for(int i=start; i<arr.size(); i++) {\\n            \\n            boolean duplicatePresent = false;\\n            int clearTill = arr.get(i).length() - 1;\\n            \\n            for(int j=0; j<arr.get(i).length(); j++) {\\n                if(!set.contains(arr.get(i).charAt(j))) {\\n                    set.add(arr.get(i).charAt(j));\\n                } else {\\n                    duplicatePresent = true;\\n                    clearTill = j-1;\\n                    break;\\n                }\\n            }\\n            \\n            if(!duplicatePresent) {\\n                maxPossibleLength(arr, set, i+1);\\n            }\\n            \\n            for(int j=0; j<=clearTill; j++) {\\n                set.remove(arr.get(i).charAt(j));\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int answer = 0;\\n    \\n    public int maxLength(List<String> arr) {\\n        maxPossibleLength(arr, new HashSet<>(), 0);\\n        return answer;\\n    }\\n    \\n    public void maxPossibleLength(List<String> arr, Set<Character> set, int start) {\\n\\n        answer = Math.max(answer, set.size());\\n        \\n        for(int i=start; i<arr.size(); i++) {\\n            \\n            boolean duplicatePresent = false;\\n            int clearTill = arr.get(i).length() - 1;\\n            \\n            for(int j=0; j<arr.get(i).length(); j++) {\\n                if(!set.contains(arr.get(i).charAt(j))) {\\n                    set.add(arr.get(i).charAt(j));\\n                } else {\\n                    duplicatePresent = true;\\n                    clearTill = j-1;\\n                    break;\\n                }\\n            }\\n            \\n            if(!duplicatePresent) {\\n                maxPossibleLength(arr, set, i+1);\\n            }\\n            \\n            for(int j=0; j<=clearTill; j++) {\\n                set.remove(arr.get(i).charAt(j));\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646024,
                "title": "java-straightforward-approach-power-set",
                "content": "```\\n\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        \\n        int total= 1 << arr.size(), max_len= 0;\\n        \\n        for(int i = 0; i < total; i++) {\\n            \\n            HashSet<Character> set= new HashSet<>();\\n            int curr_len= 0;\\n            \\n            for(int j = 0; j < arr.size(); j++) {\\n                \\n                boolean flag= false;\\n                \\n                if((i & (1 << j)) > 0) {\\n                    \\n                    if(curr_len + arr.get(j).length() > 26)\\n                        continue;\\n                    \\n                    for(int k = 0; k < arr.get(j).length(); k++) {\\n                        \\n                        if(set.contains(arr.get(j).charAt(k))) {\\n                            flag= true;\\n                            break;\\n                        }\\n                        set.add(arr.get(j).charAt(k));\\n                        \\n                    }\\n                    \\n                    if(!flag) {\\n                        curr_len += arr.get(j).length();\\n                        max_len= Math.max(curr_len, max_len);\\n                    }\\n                    if(max_len == 26)\\n                        return max_len;\\n                }\\n                \\n            }\\n        }\\n        \\n        return max_len;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        \\n        int total= 1 << arr.size(), max_len= 0;\\n        \\n        for(int i = 0; i < total; i++) {\\n            \\n            HashSet<Character> set= new HashSet<>();\\n            int curr_len= 0;\\n            \\n            for(int j = 0; j < arr.size(); j++) {\\n                \\n                boolean flag= false;\\n                \\n                if((i & (1 << j)) > 0) {\\n                    \\n                    if(curr_len + arr.get(j).length() > 26)\\n                        continue;\\n                    \\n                    for(int k = 0; k < arr.get(j).length(); k++) {\\n                        \\n                        if(set.contains(arr.get(j).charAt(k))) {\\n                            flag= true;\\n                            break;\\n                        }\\n                        set.add(arr.get(j).charAt(k));\\n                        \\n                    }\\n                    \\n                    if(!flag) {\\n                        curr_len += arr.get(j).length();\\n                        max_len= Math.max(curr_len, max_len);\\n                    }\\n                    if(max_len == 26)\\n                        return max_len;\\n                }\\n                \\n            }\\n        }\\n        \\n        return max_len;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638320,
                "title": "java-easy-to-understand-dfs-solution",
                "content": "```\\nclass Solution {\\n    private int ans = 0;\\n    \\n    public int maxLength(List<String> arr) {\\n        Set<Character> visited = new HashSet<>();\\n        for (int i = 0; i < arr.size(); i++) {\\n            dfs(i, arr, visited);\\n            visited.clear();\\n        }\\n        return ans;\\n    }\\n    \\n    private void dfs(int idx, List<String> arr, Set<Character> visited) {\\n        String word = arr.get(idx);\\n        Set<Character> wordSet = new HashSet<>();\\n        for (char c : word.toCharArray()) {\\n            if (visited.contains(c) || wordSet.contains(c)) {\\n                ans = Math.max(ans, visited.size());\\n                return;\\n            } else {\\n                wordSet.add(c);\\n            }\\n        }\\n        visited.addAll(wordSet);\\n        if (idx == arr.size() - 1) {\\n            ans = Math.max(ans, visited.size());\\n        } else {\\n            for (int i = idx + 1; i < arr.size(); i++) {\\n                Set<Character> copy_visited = new HashSet<>(visited);\\n                dfs(i, arr, copy_visited);\\n            } \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int ans = 0;\\n    \\n    public int maxLength(List<String> arr) {\\n        Set<Character> visited = new HashSet<>();\\n        for (int i = 0; i < arr.size(); i++) {\\n            dfs(i, arr, visited);\\n            visited.clear();\\n        }\\n        return ans;\\n    }\\n    \\n    private void dfs(int idx, List<String> arr, Set<Character> visited) {\\n        String word = arr.get(idx);\\n        Set<Character> wordSet = new HashSet<>();\\n        for (char c : word.toCharArray()) {\\n            if (visited.contains(c) || wordSet.contains(c)) {\\n                ans = Math.max(ans, visited.size());\\n                return;\\n            } else {\\n                wordSet.add(c);\\n            }\\n        }\\n        visited.addAll(wordSet);\\n        if (idx == arr.size() - 1) {\\n            ans = Math.max(ans, visited.size());\\n        } else {\\n            for (int i = idx + 1; i < arr.size(); i++) {\\n                Set<Character> copy_visited = new HashSet<>(visited);\\n                dfs(i, arr, copy_visited);\\n            } \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619689,
                "title": "c-solution-using-dfs-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        if (arr.empty()) return 0;\\n        if (arr.size() == 1) return arr[0].size();\\n        int res = 0;\\n        bitset<26> visited(0);\\n        DFS(arr, 0, visited, res);\\n        return res;\\n    }\\nprivate:\\n    void DFS(vector<string>& arr, int start, bitset<26>& visited, int &res) {\\n        for (int i = start; i < arr.size(); ++i) {\\n            bitset<26> tmp = visited;\\n            if (isRepeat(tmp, arr[i])) continue;\\n            res = max(res, (int)tmp.count());\\n            DFS(arr, i + 1, tmp, res);\\n        }\\n    }\\n    bool isRepeat(bitset<26> &visited, string &str) {\\n        for (auto c : str) {\\n            if (visited[c - \\'a\\']) return true;\\n            visited[c - \\'a\\'] = 1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        if (arr.empty()) return 0;\\n        if (arr.size() == 1) return arr[0].size();\\n        int res = 0;\\n        bitset<26> visited(0);\\n        DFS(arr, 0, visited, res);\\n        return res;\\n    }\\nprivate:\\n    void DFS(vector<string>& arr, int start, bitset<26>& visited, int &res) {\\n        for (int i = start; i < arr.size(); ++i) {\\n            bitset<26> tmp = visited;\\n            if (isRepeat(tmp, arr[i])) continue;\\n            res = max(res, (int)tmp.count());\\n            DFS(arr, i + 1, tmp, res);\\n        }\\n    }\\n    bool isRepeat(bitset<26> &visited, string &str) {\\n        for (auto c : str) {\\n            if (visited[c - \\'a\\']) return true;\\n            visited[c - \\'a\\'] = 1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599094,
                "title": "java-backtrack-solution-with-comments",
                "content": "\\tclass Solution {\\n\\t\\tprivate int ans = 0;\\n\\n\\t\\tpublic int maxLength(List<String> arr){\\n\\t\\t\\t// start from each word in arr\\n\\t\\t\\tfor(int i = 0; i < arr.size(); i++)\\n\\t\\t\\t\\thelper(arr, i, 0, new HashMap<>());\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\n\\t\\tprivate void helper(List<String> arr, int index, int res, Map<Character, Integer> used){\\n\\n\\t\\t\\tString cur = arr.get(index);\\n\\t\\t\\t// put all the character in a hashmap\\n\\t\\t\\tfor(int i = 0; i < cur.length(); i++){\\n\\t\\t\\t\\tused.put(cur.charAt(i), used.getOrDefault(cur.charAt(i), 0) + 1);\\n\\t\\t\\t}\\n\\t\\t\\t// if value of certain character > 1, means duplicate\\n\\t\\t\\tfor(int i: used.values()){\\n\\t\\t\\t\\tif(i > 1)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// update result\\n\\t\\t\\tres += cur.length();\\n\\t\\t\\tans = Math.max(ans, res);\\n\\n\\t\\t\\tfor(int i = index + 1; i < arr.size(); i++){\\n\\t\\t\\t\\thelper(arr, i, res, used);\\n\\t\\t\\t\\t// backtrack the hashmap\\n\\t\\t\\t\\tfor(int j = arr.get(i).length() - 1; j >= 0; j--){\\n\\t\\t\\t\\t\\tused.put(arr.get(i).charAt(j), used.get(arr.get(i).charAt(j)) - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\t\\tprivate int ans = 0;\\n\\n\\t\\tpublic int maxLength(List<String> arr){\\n\\t\\t\\t// start from each word in arr\\n\\t\\t\\tfor(int i = 0; i < arr.size(); i++)\\n\\t\\t\\t\\thelper(arr, i, 0, new HashMap<>());\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 590086,
                "title": "javascript-sets-solution",
                "content": "```js\\nconst maxLength = function(strings) {\\n  let max = 0;\\n  let sets = [new Set(\\'\\')];\\n  \\n  strings.forEach(string => {\\n    const current = new Set(string);\\n    if (string.length === current.size)  {\\n    // if the string itself has duplicates, skip\\n      \\n      sets.forEach(set => {\\n        const intersection = [...set].filter(c => current.has(c));\\n        // for currently valid string sets, if the current string does not overlap, push it to the sets\\n        if (intersection.length === 0) {\\n          const newSet = new Set([...current, ...set]);\\n          sets.push(newSet);\\n          max = Math.max(newSet.size, max); \\n        }\\n      });\\n    }\\n  });\\n  \\n  return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nconst maxLength = function(strings) {\\n  let max = 0;\\n  let sets = [new Set(\\'\\')];\\n  \\n  strings.forEach(string => {\\n    const current = new Set(string);\\n    if (string.length === current.size)  {\\n    // if the string itself has duplicates, skip\\n      \\n      sets.forEach(set => {\\n        const intersection = [...set].filter(c => current.has(c));\\n        // for currently valid string sets, if the current string does not overlap, push it to the sets\\n        if (intersection.length === 0) {\\n          const newSet = new Set([...current, ...set]);\\n          sets.push(newSet);\\n          max = Math.max(newSet.size, max); \\n        }\\n      });\\n    }\\n  });\\n  \\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 566389,
                "title": "commented-python-3-solution",
                "content": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        result = [float(\\'-inf\\')]\\n    \\n        self.unique_char(\"\", arr, 0, result)\\n\\n        if not result[0] == float(\\'-inf\\'):\\n            return result[0]\\n        return 0\\n    \\n    \\n    def unique_char(self, cur, arr, index, result):\\n        # End of the array\\n        if index == len(arr):\\n            return\\n\\n        # Iteracting from the current word to the end of the array\\n        for index in range(index,len(arr)):\\n\\n            #If my current word + next word have all unique characters\\n            if len(set(cur + arr[index])) == len(list(cur + arr[index])):    \\n                #I\\'m gonna compare the actual lenth with the previous max\\n                result[0] = max(result[0],len(cur + arr[index]))\\n                # Make a new call with concatenate words\\n                self.unique_char(cur + arr[index], arr, index + 1,result)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        result = [float(\\'-inf\\')]\\n    \\n        self.unique_char(\"\", arr, 0, result)\\n\\n        if not result[0] == float(\\'-inf\\'):\\n            return result[0]\\n        return 0\\n    \\n    \\n    def unique_char(self, cur, arr, index, result):\\n        # End of the array\\n        if index == len(arr):\\n            return\\n\\n        # Iteracting from the current word to the end of the array\\n        for index in range(index,len(arr)):\\n\\n            #If my current word + next word have all unique characters\\n            if len(set(cur + arr[index])) == len(list(cur + arr[index])):    \\n                #I\\'m gonna compare the actual lenth with the previous max\\n                result[0] = max(result[0],len(cur + arr[index]))\\n                # Make a new call with concatenate words\\n                self.unique_char(cur + arr[index], arr, index + 1,result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533011,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int res = 0;\\n        string s = \"\";\\n        for(int i = 0; i < arr.size(); i++)\\n           res = max(res ,backtrack(arr, s, i));\\n        \\n        return res;\\n        \\n    }\\n    \\n    int backtrack(vector<string>& arr, string str,  int start){\\n        \\n        unordered_set<char>s(str.begin(), str.end());\\n        if (s.size() != ((int)str.length())) \\n            return 0;\\n        \\n        int ret = str.length();\\n        for (int i = start; i < arr.size(); i++)\\n            ret = max(ret, backtrack(arr, str+arr[i], i+1));\\n\\n        return ret;\\n    }\\n    \\n};\\n```\\n------------------------------------------------------\\n\\n```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        vector<bitset<26>> bits; \\n        for (auto s : arr) {\\n            bitset<26> a;\\n            for (char c : s) a.set(c - \\'a\\');\\n            if (a.count() == s.size()) bits.push_back(a);\\n        }\\n        return maxLength(bits, bitset<26>(), 0);\\n    }\\n    \\n    int maxLength(vector<bitset<26>>& bits, bitset<26> bs, int index) {\\n        int res = bs.count();\\n        for (int i = index; i < bits.size(); i++) \\n            if ((bits[i] & bs).none()) res = max(res, maxLength(bits, bs | bits[i], i+1));\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int res = 0;\\n        string s = \"\";\\n        for(int i = 0; i < arr.size(); i++)\\n           res = max(res ,backtrack(arr, s, i));\\n        \\n        return res;\\n        \\n    }\\n    \\n    int backtrack(vector<string>& arr, string str,  int start){\\n        \\n        unordered_set<char>s(str.begin(), str.end());\\n        if (s.size() != ((int)str.length())) \\n            return 0;\\n        \\n        int ret = str.length();\\n        for (int i = start; i < arr.size(); i++)\\n            ret = max(ret, backtrack(arr, str+arr[i], i+1));\\n\\n        return ret;\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        vector<bitset<26>> bits; \\n        for (auto s : arr) {\\n            bitset<26> a;\\n            for (char c : s) a.set(c - \\'a\\');\\n            if (a.count() == s.size()) bits.push_back(a);\\n        }\\n        return maxLength(bits, bitset<26>(), 0);\\n    }\\n    \\n    int maxLength(vector<bitset<26>>& bits, bitset<26> bs, int index) {\\n        int res = bs.count();\\n        for (int i = index; i < bits.size(); i++) \\n            if ((bits[i] & bs).none()) res = max(res, maxLength(bits, bs | bits[i], i+1));\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507635,
                "title": "easy-java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    int max = 0;\\n    public int maxLength(List<String> arr) {\\n        if(arr == null || arr.size() == 0) {\\n            return 0;\\n        }\\n        backtrack(arr, 0, \"\");\\n        return max;\\n    }\\n    void backtrack(List<String> arr, int index, String current){\\n        max = Math.max(max, current.length());\\n        if(index == arr.size()) return;\\n        \\n        for(int i = index; i< arr.size();i++){\\n            if(hasNoDuplicates(current+arr.get(i))){\\n                backtrack(arr,i,current+arr.get(i));\\n            }\\n        }\\n    }\\n    /*Function to check if the string has dupliacte characters */\\n    boolean hasNoDuplicates(String s){\\n        boolean[] map = new boolean[26];\\n        for(char ch:s.toCharArray()){\\n            if(map[ch-\\'a\\']){\\n                return false;\\n            }\\n            map[ch-\\'a\\'] = true;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int maxLength(List<String> arr) {\\n        if(arr == null || arr.size() == 0) {\\n            return 0;\\n        }\\n        backtrack(arr, 0, \"\");\\n        return max;\\n    }\\n    void backtrack(List<String> arr, int index, String current){\\n        max = Math.max(max, current.length());\\n        if(index == arr.size()) return;\\n        \\n        for(int i = index; i< arr.size();i++){\\n            if(hasNoDuplicates(current+arr.get(i))){\\n                backtrack(arr,i,current+arr.get(i));\\n            }\\n        }\\n    }\\n    /*Function to check if the string has dupliacte characters */\\n    boolean hasNoDuplicates(String s){\\n        boolean[] map = new boolean[26];\\n        for(char ch:s.toCharArray()){\\n            if(map[ch-\\'a\\']){\\n                return false;\\n            }\\n            map[ch-\\'a\\'] = true;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 473402,
                "title": "c-4ms-dfs-solution-with-bit-manipulation",
                "content": "\\tclass Solution {\\n\\t\\tprivate:\\n\\t\\tint ans=0;\\n\\tpublic:\\n\\t\\tvoid dfs(int index,int mask,vector<int>& cnt){\\n\\t\\t\\tans=max(ans,__builtin_popcount(mask));\\n\\t\\t\\tfor(int i=index;i<cnt.size();i++){\\n\\t\\t\\t\\tif((cnt[i]&mask)==0){//if there is no duplicate character\\n\\t\\t\\t\\t\\tdfs(i+1,cnt[i]|mask,cnt);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxLength(vector<string>& arr) {\\n\\t\\t\\tvector<int> cnt;\\n\\t\\t\\tfor(auto x:arr){\\n\\t\\t\\t\\tint mask=0;\\n\\t\\t\\t\\tfor(auto c:x){\\n\\t\\t\\t\\t\\tmask|=2<<(c-\\'a\\');//change the position of c-\\'a\\' to 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint len=__builtin_popcount(mask);//count number of one bit in mask\\n\\t\\t\\t\\tif(len!=x.size()) continue;//if the string itself has repeated characters, skip\\n\\t\\t\\t\\tcnt.push_back(mask);//push all available string into cnt\\n\\t\\t\\t}\\n\\t\\t\\tdfs(0,0,cnt);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tprivate:\\n\\t\\tint ans=0;\\n\\tpublic:\\n\\t\\tvoid dfs(int index,int mask,vector<int>& cnt){\\n\\t\\t\\tans=max(ans,__builtin_popcount(mask));\\n\\t\\t\\tfor(int i=index;i<cnt.size();i++){\\n\\t\\t\\t\\tif((cnt[i]&mask)==0){//if there is no duplicate character\\n\\t\\t\\t\\t\\tdfs(i+1,cnt[i]|mask,cnt);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 439990,
                "title": "python-beat-75-100ms-solution",
                "content": "```\\ndef maxLength(arr):\\n\\tlst, m = [\"\"], 0\\n\\tfor s in arr:\\n\\t\\tfor i in range(len(lst)):\\n\\t\\t\\tt = s + lst[i]\\n\\t\\t\\tl = len(t)\\n\\t\\t\\tif l == len(set(t)):\\n\\t\\t\\t\\tlst.append(t)\\n\\t\\t\\t\\tm = max(m, l)\\n\\treturn m\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxLength(arr):\\n\\tlst, m = [\"\"], 0\\n\\tfor s in arr:\\n\\t\\tfor i in range(len(lst)):\\n\\t\\t\\tt = s + lst[i]\\n\\t\\t\\tl = len(t)\\n\\t\\t\\tif l == len(set(t)):\\n\\t\\t\\t\\tlst.append(t)\\n\\t\\t\\t\\tm = max(m, l)\\n\\treturn m\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 432902,
                "title": "clean-backtracking-solution-in-java-using-stringbuilder-apis",
                "content": "```\\n\\tprivate int maxLen;\\n    private boolean isUniq(String s) {\\n        HashSet<String> set = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            if (set.contains(String.valueOf(c)))\\n                return false;\\n            set.add(String.valueOf(c));\\n        }\\n        return true;\\n    }\\n    private void explore(List<String> arr, StringBuilder sb, int idx) {\\n        int len = sb.length();\\n        maxLen = Math.max(maxLen, len);\\n        if (idx == arr.size())\\n            return;\\n        for (int i = idx; i < arr.size(); i++) {\\n            sb.append(arr.get(i));\\n            if (isUniq(sb.toString())) {\\n                explore(arr, sb, i + 1);\\n            }\\n            sb.setLength(len);\\n        }\\n    }\\n    public int maxLength(List<String> arr) {\\n        maxLen = Integer.MIN_VALUE;\\n        explore(arr, new StringBuilder(), 0);\\n        return maxLen == Integer.MIN_VALUE? 0 : maxLen;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tprivate int maxLen;\\n    private boolean isUniq(String s) {\\n        HashSet<String> set = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            if (set.contains(String.valueOf(c)))\\n                return false;\\n            set.add(String.valueOf(c));\\n        }\\n        return true;\\n    }\\n    private void explore(List<String> arr, StringBuilder sb, int idx) {\\n        int len = sb.length();\\n        maxLen = Math.max(maxLen, len);\\n        if (idx == arr.size())\\n            return;\\n        for (int i = idx; i < arr.size(); i++) {\\n            sb.append(arr.get(i));\\n            if (isUniq(sb.toString())) {\\n                explore(arr, sb, i + 1);\\n            }\\n            sb.setLength(len);\\n        }\\n    }\\n    public int maxLength(List<String> arr) {\\n        maxLen = Integer.MIN_VALUE;\\n        explore(arr, new StringBuilder(), 0);\\n        return maxLen == Integer.MIN_VALUE? 0 : maxLen;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 421705,
                "title": "python-dfs-dp-bits",
                "content": "```\\n    def maxLength(self, arr: List[str]) -> int:\\n        if not arr: return 0\\n        end_state = (1 << 27) - 1\\n        def get_state(w):\\n            state = 0\\n            for c in w:\\n                idx = ord(c) - ord(\\'a\\')\\n                if state & 1 << idx != 0:\\n                    return end_state\\n                state = state | 1 << idx\\n            return state\\n        states = [get_state(w) for w in arr]\\n\\n\\n        memo = dict()\\n        def recur(i, state):\\n            if state & states[i] != 0: return 0\\n            elif states[i] == end_state: return 0\\n            if (i, state) in memo: return memo[i, state]\\n\\n            state = state | states[i]\\n            if i != len(arr) - 1:\\n                max_value = max(recur(j, state) for j in range(i + 1, len(arr)))\\n            else: max_value = 0\\n            return max_value + len(arr[i])\\n        return max(recur(i, 0) for i in range(len(arr)))\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxLength(self, arr: List[str]) -> int:\\n        if not arr: return 0\\n        end_state = (1 << 27) - 1\\n        def get_state(w):\\n            state = 0\\n            for c in w:\\n                idx = ord(c) - ord(\\'a\\')\\n                if state & 1 << idx != 0:\\n                    return end_state\\n                state = state | 1 << idx\\n            return state\\n        states = [get_state(w) for w in arr]\\n\\n\\n        memo = dict()\\n        def recur(i, state):\\n            if state & states[i] != 0: return 0\\n            elif states[i] == end_state: return 0\\n            if (i, state) in memo: return memo[i, state]\\n\\n            state = state | states[i]\\n            if i != len(arr) - 1:\\n                max_value = max(recur(j, state) for j in range(i + 1, len(arr)))\\n            else: max_value = 0\\n            return max_value + len(arr[i])\\n        return max(recur(i, 0) for i in range(len(arr)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 416367,
                "title": "c-a-solution-with-readable-code-using-dfs",
                "content": "Oct. 25, 2019\\nIt is the algorithm which can be solved using depth first search. I like to practice and also make the code easy to write and readable. \\n\\nHere are highlights:\\n1. Design depth first search and recursive function with four arguments;\\n2. default empty string is considered as a unique string with my defined isUnique function;\\n3. Depth first search algorithm is to go through all possible paths starting from a list from 0 to length - 1; \\n4. isUnique function is implemented to compare a hashSet\\'s count to string\\'s length. \\n\\n**Follow up**\\nI did not come out the solution in weekly contest 160 on Oct. 26, 2019. It is a simple brute force DFS solution. I will look into how to improve performance on weekly contest. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1239_maximujm_length\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n        }\\n\\n        /// <summary>\\n        /// Oct. 29, 2019\\n        /// study code\\n        /// 1239 Maximum length of concatenated string with unique characters\\n        /// My ideal solution is to write a DFS solution which can easily be understandable, \\n        /// and also it can be written in less than 15 minutes. \\n        /// </summary>\\n        /// <param name=\"arr\"></param>\\n        /// <returns></returns>\\n        public int MaxLength(IList<string> arr)\\n        {\\n            var maxLength = 0;\\n\\n            runDFS(arr, ref maxLength, 0, \"\");\\n\\n            return maxLength; \\n        }\\n\\n        private static void runDFS(IList<string> array, ref int maxLength, int index, string path)\\n        {\\n            if (!isUnique(path))\\n            {\\n                return;\\n            }\\n\\n            var current = path.Length;\\n            maxLength = current > maxLength ? current : maxLength;\\n\\n            for (int i = index; i < array.Count; i++)\\n            {\\n                runDFS(array, ref maxLength, i + 1, path + array[i]);\\n            }\\n        }\\n\\n        private static bool isUnique(string path)\\n        {\\n            var hashSet = new HashSet<char>(path);\\n            return path.Length == hashSet.Count(); \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1239_maximujm_length\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n        }\\n\\n        /// <summary>\\n        /// Oct. 29, 2019\\n        /// study code\\n        /// 1239 Maximum length of concatenated string with unique characters\\n        /// My ideal solution is to write a DFS solution which can easily be understandable, \\n        /// and also it can be written in less than 15 minutes. \\n        /// </summary>\\n        /// <param name=\"arr\"></param>\\n        /// <returns></returns>\\n        public int MaxLength(IList<string> arr)\\n        {\\n            var maxLength = 0;\\n\\n            runDFS(arr, ref maxLength, 0, \"\");\\n\\n            return maxLength; \\n        }\\n\\n        private static void runDFS(IList<string> array, ref int maxLength, int index, string path)\\n        {\\n            if (!isUnique(path))\\n            {\\n                return;\\n            }\\n\\n            var current = path.Length;\\n            maxLength = current > maxLength ? current : maxLength;\\n\\n            for (int i = index; i < array.Count; i++)\\n            {\\n                runDFS(array, ref maxLength, i + 1, path + array[i]);\\n            }\\n        }\\n\\n        private static bool isUnique(string path)\\n        {\\n            var hashSet = new HashSet<char>(path);\\n            return path.Length == hashSet.Count(); \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415536,
                "title": "python-backtracking",
                "content": "```python\\ndef maxLength(self, arr: List[str]) -> int:\\n        # time complexity 2 ^ n\\n        # n is the length of arr\\n        # find all the subsets that meet the requirements, i.e. no common characters\\n        # then return the max length\\n        \\n        # back tracking\\n        # keep the curr concatenated string\\n        def backTrack(i, curr):\\n            if i == len(arr):\\n                self.res = max(self.res, len(curr))\\n                return\\n            if len(set(arr[i])) == len(arr[i]):\\n                if all(c not in curr for c in arr[i]):\\n                    backTrack(i + 1, curr + arr[i])\\n                \\n            backTrack(i + 1, curr)\\n        \\n        self.res = 0\\n        backTrack(0, \\'\\')\\n        return self.res",
                "solutionTags": [],
                "code": "```python\\ndef maxLength(self, arr: List[str]) -> int:\\n        # time complexity 2 ^ n\\n        # n is the length of arr\\n        # find all the subsets that meet the requirements, i.e. no common characters\\n        # then return the max length\\n        \\n        # back tracking\\n        # keep the curr concatenated string\\n        def backTrack(i, curr):\\n            if i == len(arr):\\n                self.res = max(self.res, len(curr))\\n                return\\n            if len(set(arr[i])) == len(arr[i]):\\n                if all(c not in curr for c in arr[i]):\\n                    backTrack(i + 1, curr + arr[i])\\n                \\n            backTrack(i + 1, curr)\\n        \\n        self.res = 0\\n        backTrack(0, \\'\\')\\n        return self.res",
                "codeTag": "Python3"
            },
            {
                "id": 414659,
                "title": "bit-mask-dfs-dp-solutions",
                "content": "\\'\\'\\'\\nclass Solution:\\n\\n    # Solution 1 dp\\n    def maxLength(self, arr: List[str]) -> int:\\n        dp=collections.defaultdict(int)\\n        dp[\"\"]=0\\n        for word in arr:\\n            for word2 in list(dp.keys()):\\n                if len(word)!=len(set(word)): break\\n                if len(set(word+word2))==len(word)+len(word2):\\n                    dp[word+word2]=max(dp[word+word2],len(word)+len(word2))\\n        return max(dp.values())\\n    \\n    # Solution 2 bit mask + dfs\\n    def maxLength(self, words) -> int:\\n        memo={}\\n        for word in words:\\n            if len(set(word))!=len(word):\\n                continue\\n            mask=0\\n            for c in word:\\n                mask|=1<<(ord(c)-97)\\n            memo[mask]=max(memo.get(mask,0),len(word))\\n        masks=list(memo.keys())\\n        N=len(masks)\\n        self.ans=0\\n        def dfs(curM,curC,start):\\n            self.ans=max(self.ans,curC)\\n            for i in range(start,N):\\n                if not curM&masks[i]:\\n                    dfs(curM|masks[i],curC+memo[masks[i]],i+1)\\n        dfs(0,0,0)\\n        return self.ans\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    # Solution 1 dp\\n    def maxLength(self, arr: List[str]) -> int:\\n        dp=collections.defaultdict(int)\\n        dp[\"\"]=0\\n        for word in arr:\\n            for word2 in list(dp.keys()):\\n                if len(word)!=len(set(word)): break\\n                if len(set(word+word2))==len(word)+len(word2):\\n                    dp[word+word2]=max(dp[word+word2],len(word)+len(word2))\\n        return max(dp.values())\\n    \\n    # Solution 2 bit mask + dfs\\n    def maxLength(self, words) -> int:\\n        memo={}",
                "codeTag": "Java"
            },
            {
                "id": 414388,
                "title": "python3-4-liner",
                "content": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        bfs = [\\'\\']\\n        for b in filter(lambda x: len(x) == len(set(x)), arr):\\n            bfs += [a + b for a in bfs if not set(a) & set(b)]\\n        return max(map(len, bfs))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        bfs = [\\'\\']\\n        for b in filter(lambda x: len(x) == len(set(x)), arr):\\n            bfs += [a + b for a in bfs if not set(a) & set(b)]\\n        return max(map(len, bfs))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004433,
                "title": "recursive-solution-beginner-friendly-java",
                "content": "# Intuition\\nIf we need to find all possible combinations, we should think of recursion\\n\\n# Approach\\nIt is a classic pick or not pick problem. At every index, we\\'ll either pick it or not pick, and once we reach the end of the input array, we\\'ll check if our concatenated string is valid or not. If it is valid, we\\'ll return the length, and store the maximum valid length with us.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return solve(0, arr, \"\");\\n    }\\n    public int solve(int index, List<String> arr, String input){\\n        if (index == arr.size()){\\n            if (isValid(input)){\\n                return input.length();\\n            }\\n            return 0;\\n        }\\n        int take = solve(index+1, arr, input+arr.get(index));\\n        int notTake = solve(index+1, arr, input);\\n        return Math.max(take, notTake);\\n    }\\n    public boolean isValid(String s){\\n        int [] freq = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            int val = s.charAt(i)-\\'a\\';\\n            freq[val]++;\\n            if (freq[val] > 1)  return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return solve(0, arr, \"\");\\n    }\\n    public int solve(int index, List<String> arr, String input){\\n        if (index == arr.size()){\\n            if (isValid(input)){\\n                return input.length();\\n            }\\n            return 0;\\n        }\\n        int take = solve(index+1, arr, input+arr.get(index));\\n        int notTake = solve(index+1, arr, input);\\n        return Math.max(take, notTake);\\n    }\\n    public boolean isValid(String s){\\n        int [] freq = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            int val = s.charAt(i)-\\'a\\';\\n            freq[val]++;\\n            if (freq[val] > 1)  return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969616,
                "title": "simple-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int maxCount = Integer.MIN_VALUE;\\n    public int maxLength(List<String> arr) {\\n        for (int i = 0; i < arr.size(); i++) {\\n            helper(arr, i, new StringBuilder());\\n        }\\n        return maxCount;\\n    }\\n\\n    private void helper(List<String> arr, int index, StringBuilder str) {\\n        if (index == arr.size()) {\\n            return;\\n        }\\n        int oriLen = str.length();\\n        str.append(arr.get(index));\\n        if (checker(str)) {\\n            maxCount = Math.max(maxCount, str.length());\\n        }\\n        helper(arr, index + 1, str);\\n        str.delete(oriLen, str.length());\\n        if (checker(str)) {\\n            maxCount = Math.max(maxCount, str.length());\\n        }\\n        helper(arr, index + 1, str);\\n    }\\n\\n    private boolean checker(StringBuilder str) {\\n        HashSet<Character> hs = new HashSet<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            if (hs.contains(str.charAt(i))) {\\n                return false;\\n            }\\n            hs.add(str.charAt(i));\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int maxCount = Integer.MIN_VALUE;\\n    public int maxLength(List<String> arr) {\\n        for (int i = 0; i < arr.size(); i++) {\\n            helper(arr, i, new StringBuilder());\\n        }\\n        return maxCount;\\n    }\\n\\n    private void helper(List<String> arr, int index, StringBuilder str) {\\n        if (index == arr.size()) {\\n            return;\\n        }\\n        int oriLen = str.length();\\n        str.append(arr.get(index));\\n        if (checker(str)) {\\n            maxCount = Math.max(maxCount, str.length());\\n        }\\n        helper(arr, index + 1, str);\\n        str.delete(oriLen, str.length());\\n        if (checker(str)) {\\n            maxCount = Math.max(maxCount, str.length());\\n        }\\n        helper(arr, index + 1, str);\\n    }\\n\\n    private boolean checker(StringBuilder str) {\\n        HashSet<Character> hs = new HashSet<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            if (hs.contains(str.charAt(i))) {\\n                return false;\\n            }\\n            hs.add(str.charAt(i));\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566617,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1656950,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1986946,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2016289,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1657239,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1657275,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2066303,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2053419,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2037653,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1955044,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1566617,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1656950,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1986946,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2016289,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1657239,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1657275,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2066303,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2053419,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2037653,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1955044,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the Most Competitive Subsequence",
        "question_content": "<p>Given an integer array <code>nums</code> and a positive integer <code>k</code>, return <em>the most<strong> competitive</strong> subsequence of </em><code>nums</code> <em>of size </em><code>k</code>.</p>\n\n<p>An array&#39;s subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array.</p>\n\n<p>We define that a subsequence <code>a</code> is more <strong>competitive</strong> than a subsequence <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, subsequence <code>a</code> has a number <strong>less</strong> than the corresponding number in <code>b</code>. For example, <code>[1,3,4]</code> is more competitive than <code>[1,3,5]</code> because the first position they differ is at the final number, and <code>4</code> is less than <code>5</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,5,2,6], k = 2\n<strong>Output:</strong> [2,6]\n<strong>Explanation:</strong> Among the set of every possible subsequence: {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most competitive.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,4,3,3,5,4,9,6], k = 4\n<strong>Output:</strong> [2,3,3,4]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 952786,
                "title": "java-c-python-one-pass-stack-solution",
                "content": "# Intuition\\nUse a mono incrasing stack.\\n<br>\\n\\n# Explanation\\nKeep a mono incrasing stackas result.\\nIf current element `a` is smaller then the last element in the stack,\\nwe can replace it to get a smaller sequence.\\n\\nBefore we do this,\\nwe need to check if we still have enough elements after.\\nAfter we pop the last element from `stack`,\\nwe have `stack.size() - 1` in the stack,\\nthere are `A.size() - i` can still be pushed.\\nif `stack.size() - 1 + A.size() - i >= k`, we can pop the stack.\\n\\nThen, is the stack not full with `k` element,\\nwe push `A[i]` into the stack.\\n\\nFinally we return `stack` as the result directly.\\n<br>\\n\\n# Complexity\\nTime `O(n)`\\nSpace `O(k)`\\n<br>\\n\\n# Solution 1: Use stack\\n**Java**\\nby @bush117\\n```java\\npublic int[] mostCompetitive(int[] nums, int k) {\\n    Stack<Integer> stack = new Stack<>();\\n    int[] result = new int[k];\\n    for (int i = 0; i < nums.length; i++) {\\n        while (!stack.empty() && nums[i] < nums[stack.peek()] && nums.length - i + stack.size() > k) {\\n            stack.pop();\\n        }\\n        if (stack.size() < k) {\\n            stack.push(i);\\n        }\\n    }\\n    for (int i = k - 1; i >= 0; i--) {\\n        result[i] = nums[stack.pop()];\\n    }\\n    return result;\\n}\\n```\\n**C++:**\\n```cpp\\n    vector<int> mostCompetitive(vector<int>& A, int k) {\\n        vector<int> stack;\\n        for (int i = 0; i < A.size(); ++i) {\\n            while (!stack.empty() && stack.back() > A[i] && stack.size() - 1 + A.size() - i >= k)\\n                stack.pop_back();\\n            if (stack.size() < k)\\n                stack.push_back(A[i]);\\n        }\\n        return stack;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def mostCompetitive(self, A, k):\\n        stack = []\\n        for i, a in enumerate(A):\\n            while stack and stack[-1] > a and len(stack) - 1 + len(A) - i >= k:\\n                stack.pop()\\n            if len(stack) < k:\\n                stack.append(a)\\n        return stack\\n```\\n<br>\\n\\n# Solution 2: Use array\\n**Java:**\\n```java\\n    public int[] mostCompetitive(int[] A, int k) {\\n        int stack[] = new int[k], n = A.length, j = 0;\\n        for (int i = 0; i < n; ++i) {\\n            while (j > 0 && stack[j - 1] > A[i] && j - 1 + n - i >= k)\\n                j--;\\n            if (j < k)\\n                stack[j++] = A[i];\\n        }\\n        return stack;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    vector<int> mostCompetitive(vector<int>& A, int k) {\\n        vector<int> stack(k);\\n        int j = 0, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            while (j && stack[j - 1] > A[i] && j - 1 + n - i >= k)\\n                j--;\\n            if (j < k)\\n                stack[j++] = A[i];\\n        }\\n        return stack;\\n    }\\n```\\n<br>\\n\\n# More Good Stack Problems\\nHere are some problems that impressed me.\\nGood luck and have fun.\\n\\n- 1673. [Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/discuss/952786/javacpython-one-pass-stack-solution/776191 )\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1130. [Minimum Cost Tree From Leaf Values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space)\\n- 907. [Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/170750/C++JavaPython-Stack-Solution)\\n- 901. [Online Stock Span](https://leetcode.com/problems/online-stock-span/discuss/168311/C++JavaPython-O(1))\\n- 856. [Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/discuss/141777/C++JavaPython-O(1)-Space)\\n- 503. [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice)\\n- 496. Next Greater Element I\\n- 84. Largest Rectangle in Histogram\\n- 42. Trapping Rain Water\\n<br>",
                "solutionTags": [],
                "code": "```java\\npublic int[] mostCompetitive(int[] nums, int k) {\\n    Stack<Integer> stack = new Stack<>();\\n    int[] result = new int[k];\\n    for (int i = 0; i < nums.length; i++) {\\n        while (!stack.empty() && nums[i] < nums[stack.peek()] && nums.length - i + stack.size() > k) {\\n            stack.pop();\\n        }\\n        if (stack.size() < k) {\\n            stack.push(i);\\n        }\\n    }\\n    for (int i = k - 1; i >= 0; i--) {\\n        result[i] = nums[stack.pop()];\\n    }\\n    return result;\\n}\\n```\n```cpp\\n    vector<int> mostCompetitive(vector<int>& A, int k) {\\n        vector<int> stack;\\n        for (int i = 0; i < A.size(); ++i) {\\n            while (!stack.empty() && stack.back() > A[i] && stack.size() - 1 + A.size() - i >= k)\\n                stack.pop_back();\\n            if (stack.size() < k)\\n                stack.push_back(A[i]);\\n        }\\n        return stack;\\n    }\\n```\n```py\\n    def mostCompetitive(self, A, k):\\n        stack = []\\n        for i, a in enumerate(A):\\n            while stack and stack[-1] > a and len(stack) - 1 + len(A) - i >= k:\\n                stack.pop()\\n            if len(stack) < k:\\n                stack.append(a)\\n        return stack\\n```\n```java\\n    public int[] mostCompetitive(int[] A, int k) {\\n        int stack[] = new int[k], n = A.length, j = 0;\\n        for (int i = 0; i < n; ++i) {\\n            while (j > 0 && stack[j - 1] > A[i] && j - 1 + n - i >= k)\\n                j--;\\n            if (j < k)\\n                stack[j++] = A[i];\\n        }\\n        return stack;\\n    }\\n```\n```cpp\\n    vector<int> mostCompetitive(vector<int>& A, int k) {\\n        vector<int> stack(k);\\n        int j = 0, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            while (j && stack[j - 1] > A[i] && j - 1 + n - i >= k)\\n                j--;\\n            if (j < k)\\n                stack[j++] = A[i];\\n        }\\n        return stack;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1027495,
                "title": "python-stack-solution-explained",
                "content": "This is a good problem to apply stack, with the following idea: let us traverse original list number by number and put in into stack: if it happens that new number is less than the top of our stack and if we still can afford to delete one more number, we extract it from stack and put new number. Let me illustrate this on example `[1,4,5,3,2,8,7]` and `k = 4`.\\n\\nFirst, we put `1` into stack, then `4` and then `5`, so far we have `[1, 4, 5]`. Next step we see number `3`, which is less then `5`, so we keep removing elements from stack until we can and put `3`, so we have `[1, 3]` now. Next number is `2`, so we again remove `3` and put `2`, and we have `[1, 2]` in our stack now. At this moment number of attempts we can make is equal to zero, so we just must take all the rest numbers, so finally we have `[1, 2, 8, 7]` in our stack.\\n\\n**Complexity**: both time and space complexity is `O(n)`, where `n` is length of our string, because for each digit it goes in and goes out of stack only once.\\n\\n```\\nclass Solution:\\n    def mostCompetitive(self, nums, k):\\n        attempts = len(nums) - k\\n        stack = []\\n        for num in nums:\\n            while stack and num < stack[-1] and attempts > 0:\\n                stack.pop()\\n                attempts -= 1\\n            stack.append(num)\\n        \\n        return stack[:k]\\n```\\n\\nSee very similar problem **402. Remove K Digits**, where we need to do literally the same.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def mostCompetitive(self, nums, k):\\n        attempts = len(nums) - k\\n        stack = []\\n        for num in nums:\\n            while stack and num < stack[-1] and attempts > 0:\\n                stack.pop()\\n                attempts -= 1\\n            stack.append(num)\\n        \\n        return stack[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027527,
                "title": "c-simple-short-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> stack;\\n        int nums_to_delete = nums.size()-k;\\n        for (int i = 0; i < nums.size(); i++) {\\n            while (!stack.empty() && nums[i] < stack.back() && nums_to_delete) {\\n                stack.pop_back();\\n                nums_to_delete--;\\n            }\\n            stack.push_back(nums[i]);\\n        }\\n        return vector<int>(stack.begin(), stack.begin()+k);\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> stack;\\n        int nums_to_delete = nums.size()-k;\\n        for (int i = 0; i < nums.size(); i++) {\\n            while (!stack.empty() && nums[i] < stack.back() && nums_to_delete) {\\n                stack.pop_back();\\n                nums_to_delete--;\\n            }\\n            stack.push_back(nums[i]);\\n        }\\n        return vector<int>(stack.begin(), stack.begin()+k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952794,
                "title": "java-python-3-1-pass-monotonic-stack-w-14-similar-problems-brief-explanation-and-analysis",
                "content": "**Q & A**\\n\\nQ1: What is the logic for `stk.size() + n - i > k`?\\nA1: In order to put into stack `k` elements, we need to make sure those in the stack (`stk.size()`)  together with the ones that not yet scanned (`n - i`) are more than `k`. Then we can poll out an element from stack but still guarantee to have a `k`-size sequence in it after the traversal of the input array.\\n\\n**End of Q & A**\\n\\n----\\n\\nTry to put into stack the available minimum element from the input array.\\n1. Loop through the input array `nums` and put on the front of the stack the currently available minimum;\\n2.  Whenever there are enough elements in the remaining of the input to form `k`-size sequence, keep checking if the current element is less than the stack end; if yes, keep polling out the stack end; \\n3.  Otherwise, check if the stack has alreay reached the size of `k`; if no, append it to the stack; if yes, ignore it.\\n4.  Upon termination of the loop, the elements in the stack form the required sequence.\\n\\n**Note:** If the size of stack (`stk.size()`) + number of remaining elements (`n - i`) > `k`, then we have at least one more element than enough to form the `k`-size sequence.\\n```java\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        Deque<Integer> stk = new ArrayDeque<>();\\n        for (int i = 0, n = nums.length ; i < n; ++i) {\\n            while (!stk.isEmpty() && stk.peekLast() > nums[i] && stk.size() + n - i > k) {\\n                stk.pollLast();\\n            }\\n            if (stk.size() < k) {\\n                stk.offer(nums[i]);\\n            }\\n        }\\n        return stk.stream().mapToInt(i -> i).toArray();\\n    }\\n```\\n\\n```python\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        stk = []\\n        for i, n in enumerate(nums):\\n            while stk and stk[-1] > n and len(stk) + len(nums) - i > k:\\n                stk.pop()\\n            if len(stk) < k:    \\n                stk.append(n)\\n        return stk    \\n```\\n**Analysis:**\\n\\nTime: O(n), space: O(k), where n = nums.length.\\n\\n----\\n\\nSimilar problems:\\n\\n[42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\\n[84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)\\n[85. Maximal Rectangle](https://leetcode.com/problems/Maximal-Rectangle/description/)\\n[316. Remove Duplicate Letters](https://leetcode.com/problems/remove-duplicate-letters/description/)\\n[321. Create Maximum Number](https://leetcode.com/problems/create-maximum-number/description/)\\n[496. Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/)\\n[503. Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/)\\n[856. Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/)\\n[901. Online Stock Span](leetcode.com/problems/online-stock-span/)\\n[907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/)\\n[1019. Next Greater Node In Linked List](https://leetcode.com/problems/next-greater-node-in-linked-list/discuss/267163/Java-9-liner-O(n)-using-Stack-and-ArrayList)\\n[1130. Minimum Cost Tree From Leaf Values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/)\\n[1425. Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/)\\n[1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/discuss/952794/JavaPython-3-1-pass-Monotonic-Stack-wbrief-explanation-and-analysis.)",
                "solutionTags": [],
                "code": "```java\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        Deque<Integer> stk = new ArrayDeque<>();\\n        for (int i = 0, n = nums.length ; i < n; ++i) {\\n            while (!stk.isEmpty() && stk.peekLast() > nums[i] && stk.size() + n - i > k) {\\n                stk.pollLast();\\n            }\\n            if (stk.size() < k) {\\n                stk.offer(nums[i]);\\n            }\\n        }\\n        return stk.stream().mapToInt(i -> i).toArray();\\n    }\\n```\n```python\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        stk = []\\n        for i, n in enumerate(nums):\\n            while stk and stk[-1] > n and len(stk) + len(nums) - i > k:\\n                stk.pop()\\n            if len(stk) < k:    \\n                stk.append(n)\\n        return stk    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 952934,
                "title": "c-o-n-sliding-window-mono-sequence-in-place-solution",
                "content": "For this question, if you are going the right direction - \\uD83D\\uDE07\\nIf you are going the wrong direction - \\u2620\\uFE0F\\n\\n----\\n\\nWe need to fill k slots.\\nTo fill the first slot, we should pick the smallest number between index [0] ~ [N-k] (inclusive) (we have to preserve at least k-1 numbers for the rest of k-1 slots)\\nFor the *i*th (0-indexed) slot, we should pick the smallest number between index [previous picked index + 1] ~ [N-k+i] (range of the window)\\nWe keep a increasing monotonic queue for the window, and use the smallest number (front of the queue)\\nNote: \\n1. We only need at most k numbers in the queue\\n2. we allow equal numbers in the queue\\n```cpp\\nvector<int> mostCompetitive(vector<int>& nums, int k) {\\n\\tint N = nums.size();\\n\\tdeque<int> q;\\n\\tvector<int> ans;\\n\\tfor (int i = 0; i < N; ++i) {\\n\\t\\twhile (!q.empty() && q.back() > nums[i]) q.pop_back();\\n\\t\\tif (q.size() < k) q.push_back(nums[i]);\\n\\t\\tif (i >= N - k) {\\n\\t\\t\\tans.push_back(q.front());\\n\\t\\t\\tq.pop_front();\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\nWe can actually build the answer directly:\\n\\n```cpp\\nvector<int> mostCompetitive(vector<int>& nums, int k) {\\n    int N = nums.size();\\n    vector<int> ans;\\n    for (int i = 0, numFixed = 0; i < N; ++i) {\\n        while (ans.size() > numFixed && ans.back() > nums[i]) ans.pop_back();\\n        if (ans.size() < k) ans.push_back(nums[i]);\\n        if (i >= N - k) ++numFixed;\\n    }\\n    return ans;\\n}\\n```\\n\\nSince every number is pushed and popped at most  once, time complexity is **O(n)**\\nQueue contains at most k numbers, space complexity is **O(k)**\\n\\n----\\n\\n(Update)\\nWe can even do it in-place:\\nTime: O(n)\\nSpace: **O(1)**\\n```cpp\\nvector<int> mostCompetitive(vector<int>& nums, int k) {\\n    const int N = nums.size();\\n    for (int i = 0, len = 0; i < N; ++i) {\\n        while (len > 0 && N - i + len > k && nums[len-1] > nums[i])\\n            --len;\\n        swap(nums[i], nums[len++]);\\n    }\\n    nums.resize(k);\\n    return nums;\\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> mostCompetitive(vector<int>& nums, int k) {\\n\\tint N = nums.size();\\n\\tdeque<int> q;\\n\\tvector<int> ans;\\n\\tfor (int i = 0; i < N; ++i) {\\n\\t\\twhile (!q.empty() && q.back() > nums[i]) q.pop_back();\\n\\t\\tif (q.size() < k) q.push_back(nums[i]);\\n\\t\\tif (i >= N - k) {\\n\\t\\t\\tans.push_back(q.front());\\n\\t\\t\\tq.pop_front();\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\n```cpp\\nvector<int> mostCompetitive(vector<int>& nums, int k) {\\n    int N = nums.size();\\n    vector<int> ans;\\n    for (int i = 0, numFixed = 0; i < N; ++i) {\\n        while (ans.size() > numFixed && ans.back() > nums[i]) ans.pop_back();\\n        if (ans.size() < k) ans.push_back(nums[i]);\\n        if (i >= N - k) ++numFixed;\\n    }\\n    return ans;\\n}\\n```\n```cpp\\nvector<int> mostCompetitive(vector<int>& nums, int k) {\\n    const int N = nums.size();\\n    for (int i = 0, len = 0; i < N; ++i) {\\n        while (len > 0 && N - i + len > k && nums[len-1] > nums[i])\\n            --len;\\n        swap(nums[i], nums[len++]);\\n    }\\n    nums.resize(k);\\n    return nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1027986,
                "title": "python-3-solutions-min-heap-mono-decreasing-queue-mono-increasing-stack",
                "content": "**Solution 1: Min Heap**\\n```\\nclass Solution(object):\\n    def mostCompetitive(self, nums, k):\\n        minHeap = []\\n        ans = []\\n        skipElement = defaultdict(int)\\n        j = 0\\n        for i, e in enumerate(nums):\\n            heappush(minHeap, (e, i)) # sorted by `e` (element) then `i` (index)\\n            if i >= len(nums) - k:\\n                while skipElement[minHeap[0][0]] > 0: # Discard skip elements of top min heap\\n                    skipElement[minHeap[0][0]] -= 1\\n                    heappop(minHeap)\\n                choose = heappop(minHeap)\\n                ans.append(choose[0])\\n                while j < choose[1]:\\n                    skipElement[nums[j]] += 1\\n                    j += 1\\n                j += 1\\n        return ans\\n```\\nComplexity:\\n- Time: `O(NlogN)`\\n- Space: `O(N)`\\n\\n**Solution 2: Mono Decreasing Queue**\\n```python\\nclass Solution(object):\\n    def mostCompetitive(self, nums, k):\\n        decreaseQ = deque([])\\n        ans = []\\n        for i, e in enumerate(nums):\\n            while decreaseQ and e < decreaseQ[0]: # Remove elements that are larger than new element\\n                decreaseQ.popleft()\\n            decreaseQ.appendleft(e)\\n            if i >= len(nums) - k:\\n                ans.append(decreaseQ.pop())\\n        return ans\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(N)`\\n\\n**Solution 3: Mono Increasing Stack**\\n```python\\nclass Solution(object):\\n    def mostCompetitive(self, nums, k):\\n        stack = []\\n        needDeleteCount = len(nums) - k\\n        for e in nums:\\n            while stack and e < stack[-1] and needDeleteCount > 0:\\n                needDeleteCount -= 1\\n                stack.pop()\\n            stack.append(e)\\n        return stack[:k]\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def mostCompetitive(self, nums, k):\\n        minHeap = []\\n        ans = []\\n        skipElement = defaultdict(int)\\n        j = 0\\n        for i, e in enumerate(nums):\\n            heappush(minHeap, (e, i)) # sorted by `e` (element) then `i` (index)\\n            if i >= len(nums) - k:\\n                while skipElement[minHeap[0][0]] > 0: # Discard skip elements of top min heap\\n                    skipElement[minHeap[0][0]] -= 1\\n                    heappop(minHeap)\\n                choose = heappop(minHeap)\\n                ans.append(choose[0])\\n                while j < choose[1]:\\n                    skipElement[nums[j]] += 1\\n                    j += 1\\n                j += 1\\n        return ans\\n```\n```python\\nclass Solution(object):\\n    def mostCompetitive(self, nums, k):\\n        decreaseQ = deque([])\\n        ans = []\\n        for i, e in enumerate(nums):\\n            while decreaseQ and e < decreaseQ[0]: # Remove elements that are larger than new element\\n                decreaseQ.popleft()\\n            decreaseQ.appendleft(e)\\n            if i >= len(nums) - k:\\n                ans.append(decreaseQ.pop())\\n        return ans\\n```\n```python\\nclass Solution(object):\\n    def mostCompetitive(self, nums, k):\\n        stack = []\\n        needDeleteCount = len(nums) - k\\n        for e in nums:\\n            while stack and e < stack[-1] and needDeleteCount > 0:\\n                needDeleteCount -= 1\\n                stack.pop()\\n            stack.append(e)\\n        return stack[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955147,
                "title": "c-o-n",
                "content": "I thought about monotonically increasing stack, but I could not figure it out. So, I solved it using two stack - one monotonically increasing, and another - with elements to \"pad\" the result to be `k`-sized.\\n\\nLater, I realized that we just need to pad the monotonically increasing stack with elements in the end of the array, if it\\'s size is less than `k`.\\n\\n```cpp\\nvector<int> mostCompetitive(vector<int>& n, int k) {\\n    vector<int> s;\\n    for (auto i = 0; i < n.size(); ++i) {\\n        while (!s.empty() && s.back() > n[i] && s.size() + n.size() - i > k)\\n            s.pop_back();\\n        if (s.size() < k)\\n            s.push_back(n[i]);\\n    }\\n    return s;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> mostCompetitive(vector<int>& n, int k) {\\n    vector<int> s;\\n    for (auto i = 0; i < n.size(); ++i) {\\n        while (!s.empty() && s.back() > n[i] && s.size() + n.size() - i > k)\\n            s.pop_back();\\n        if (s.size() < k)\\n            s.push_back(n[i]);\\n    }\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1029198,
                "title": "c-o-n-solution-with-detailed-explanation",
                "content": "**Intuition**\\n By taking a close look at the following test cases, we can understand the problem better:\\n Consider :\\n1.   [3,5,2,6] and k=2\\nAnswer= [2,6]\\n\\n2.  [3,5,2,6] and k=3\\nAnswer= [3,2,6]\\n\\nIn the first case, our answer began with 2 which was the smallest number available in the array. However, in the second case we could not start our answer with 2 as we need a total of k=3 numbers in the answer. Thus we begin our answer with the smallest number we can find, which **also** has enough numbers after it to contribute to the final answer.\\n\\n**Algorithm**\\nFor each arr[i] we have 2 options: either it will be a part of our ans or it won\\'t be. Thus there\\'s a \\'dilemna\\' we have to resolve for each arr[i].\\nWe shall use a stack, which will at max contain k elements at a time. These will be the elements whose dilemna is unresolved. At the end, this stack will contain our final answer.\\n\\n1. Start traversing the arr. PUSH the arr[i] in the stack if stack.size() < k. We will resolve this pushed arr[i] \\'s dilemna at the time of POP operation (explained next).\\n2. POP **all** the elements whose dilemna is resolved ie they will NOT be a part of the ans. This will be the case when current arr[i] is smaller than stack.top(), and arr[i] **also** has sufficient number of elements after it to form the final answer.\\n3. On following the above steps, at the end our stack will contain the final answer. Convert it to an array and return it.\\n\\n**Complexity**\\nTime Complexity will be O(n) and space complexity will be O(k) as the stack will at max contain k elements.\\n\\t\\n**Follow up**\\nInstead of using a stack and then storing it to vector and returning, we can simply use a vector from the very beginning. Use vector.back() to access \\'top\\' element and vector.pop_back() for popping. At the end simply return this vector we were using like a stack. \\n\\n\\n```\\nvector<int> mostCompetitive(vector<int>& arr, int k){\\n \\n        int n= arr.size();\\n        \\n        stack<int> s;  //stores the elements which have a dilemna. In the end, the elements who remain form the answer.\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            //n-i-1 elements are left in the array after ith index and k-s.size() is the no. of elements still required for our answer\\n            while(!s.empty() && arr[i]<s.top() && (n-i-1 >= k-s.size())){\\n                s.pop();\\n            }\\n            \\n            //push elements if stack has less than k elements (these elements are the ones whose dilemna has not been resolved yet) \\n            if(s.size()<k){\\n                s.push(arr[i]);\\n            }\\n        }\\n        \\n        //stack s contains our answer now, converting to a vector\\n        vector<int> ans;\\n         while(!s.empty()){\\n            ans.push_back(s.top());\\n            s.pop();\\n         }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\t\\n\\t",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "**Intuition**\\n By taking a close look at the following test cases, we can understand the problem better:\\n Consider :\\n1.   [3,5,2,6] and k=2\\nAnswer= [2,6]\\n\\n2.  [3,5,2,6] and k=3\\nAnswer= [3,2,6]\\n\\nIn the first case, our answer began with 2 which was the smallest number available in the array. However, in the second case we could not start our answer with 2 as we need a total of k=3 numbers in the answer. Thus we begin our answer with the smallest number we can find, which **also** has enough numbers after it to contribute to the final answer.\\n\\n**Algorithm**\\nFor each arr[i] we have 2 options: either it will be a part of our ans or it won\\'t be. Thus there\\'s a \\'dilemna\\' we have to resolve for each arr[i].\\nWe shall use a stack, which will at max contain k elements at a time. These will be the elements whose dilemna is unresolved. At the end, this stack will contain our final answer.\\n\\n1. Start traversing the arr. PUSH the arr[i] in the stack if stack.size() < k. We will resolve this pushed arr[i] \\'s dilemna at the time of POP operation (explained next).\\n2. POP **all** the elements whose dilemna is resolved ie they will NOT be a part of the ans. This will be the case when current arr[i] is smaller than stack.top(), and arr[i] **also** has sufficient number of elements after it to form the final answer.\\n3. On following the above steps, at the end our stack will contain the final answer. Convert it to an array and return it.\\n\\n**Complexity**\\nTime Complexity will be O(n) and space complexity will be O(k) as the stack will at max contain k elements.\\n\\t\\n**Follow up**\\nInstead of using a stack and then storing it to vector and returning, we can simply use a vector from the very beginning. Use vector.back() to access \\'top\\' element and vector.pop_back() for popping. At the end simply return this vector we were using like a stack. \\n\\n\\n```\\nvector<int> mostCompetitive(vector<int>& arr, int k){\\n \\n        int n= arr.size();\\n        \\n        stack<int> s;  //stores the elements which have a dilemna. In the end, the elements who remain form the answer.\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            //n-i-1 elements are left in the array after ith index and k-s.size() is the no. of elements still required for our answer\\n            while(!s.empty() && arr[i]<s.top() && (n-i-1 >= k-s.size())){\\n                s.pop();\\n            }\\n            \\n            //push elements if stack has less than k elements (these elements are the ones whose dilemna has not been resolved yet) \\n            if(s.size()<k){\\n                s.push(arr[i]);\\n            }\\n        }\\n        \\n        //stack s contains our answer now, converting to a vector\\n        vector<int> ans;\\n         while(!s.empty()){\\n            ans.push_back(s.top());\\n            s.pop();\\n         }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 952853,
                "title": "easy-peasy-python-solution",
                "content": "\\n```\\ndef mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        st = []\\n        for idx, num in enumerate(nums):\\n            if not st:\\n                st.append(num)\\n            else:\\n                # pop element from st if last element is greater than the current element\\n                # and also I have enough elements left such that I can have list of size k\\n                while st and st[-1] > num and (len(st)-1 + len(nums)-idx >= k):\\n                    st.pop()\\n                if len(st) < k:\\n                    st.append(num)\\n        return st",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n```\\ndef mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        st = []\\n        for idx, num in enumerate(nums):\\n            if not st:\\n                st.append(num)\\n            else:\\n                # pop element from st if last element is greater than the current element\\n                # and also I have enough elements left such that I can have list of size k\\n                while st and st[-1] > num and (len(st)-1 + len(nums)-idx >= k):\\n                    st.pop()\\n                if len(st) < k:\\n                    st.append(num)\\n        return st",
                "codeTag": "Python3"
            },
            {
                "id": 1027544,
                "title": "most-competitive-sequence-c-w-detailed-explanation-priority-queue-and-sliding-window",
                "content": "1. Basically We need to select the sequence with the smallest numbers compared to other sequences\\n2. Lets say N is the size of array and we need to select k elements then we can have \\'k\\' sliding windows on the array each with a size of N-k+1.\\n3. Now we need to select the minimum element in each sliding window with the condition that the elements selected form a sequence and are not out of order\\n4. This will give us the smallest possible sequence of length k.\\nex: [3,4,2,5,7,6,9,8] k = 3 Ans: [2,5,6]\\nsliding window len = 8 - 3 + 1 = 6\\nso there will be 3 sliding windows possible with a length of 6 each\\nWe need to select minimum element from each sliding window and we will finally have a sequence of 3 elements\\n1st sliding window: [3,4,2,5,7,6] - min here: 2\\n2nd sliding window: [4,2,5,7,6,9] - min here: 5 ignoring elements before \\'2\\' (we can\\'t select 4 because it will break the sequence and elements will be out of order)\\n3rd sliding window: [2,5,7,6,9,8] - min here: 6 ignoring elements before \\'5\\'\\n**please upvote if you like it**\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        int len = N - k;\\n        vector<int> res;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n\\t\\t// first sliding window wiht N-k+1 elements\\n        for (int i = 0; i <= len; i++) {\\n            pq.push({nums[i], i});\\n        }\\n        pair<int, int> t = pq.top();\\n        pq.pop();\\n        res.push_back(t.first);\\n        int minIdx = t.second;\\n        for (int i = len+1; i < N; i++) { // rest of the sliding windows with one new element added at a time and ignoring the elements already selected and elements before them\\n            pq.push({nums[i], i});\\n            t = pq.top();\\n            while (t.second < minIdx) { // ignore min elements before current min element index\\n                pq.pop();\\n                t = pq.top();\\n            }\\n            pq.pop();\\n\\t\\t\\t// new minimum element from the current sliding window\\n            res.push_back(t.first);\\n            minIdx = t.second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        int len = N - k;\\n        vector<int> res;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n\\t\\t// first sliding window wiht N-k+1 elements\\n        for (int i = 0; i <= len; i++) {\\n            pq.push({nums[i], i});\\n        }\\n        pair<int, int> t = pq.top();\\n        pq.pop();\\n        res.push_back(t.first);\\n        int minIdx = t.second;\\n        for (int i = len+1; i < N; i++) { // rest of the sliding windows with one new element added at a time and ignoring the elements already selected and elements before them\\n            pq.push({nums[i], i});\\n            t = pq.top();\\n            while (t.second < minIdx) { // ignore min elements before current min element index\\n                pq.pop();\\n                t = pq.top();\\n            }\\n            pq.pop();\\n\\t\\t\\t// new minimum element from the current sliding window\\n            res.push_back(t.first);\\n            minIdx = t.second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147107,
                "title": "python-3-approach-with-detailed-explanation-algorithm-and-dry-run-using-monotonic-stack",
                "content": "# Intuition\\nHere, we take into consideration, the concept that, whether we will have enough surplus elements to add in the result(stack), if we pop/remove the current element from the result(stack).\\n\\n# Approach\\nALGORITHM - \\n    \\n    1. Initialize the \\'stack\\' and a variable \\'stack_len\\' to keep track \\n        of its length.\\n    2. Let \\'n\\' denote the length of the \\'nums\\' array.\\n    3. Start a loop from 0 to n:\\n        a. remove elements from stack and decrement the stack_len by 1\\n            i.     till stack is not empty and \\n            ii.   top element of stack is greater than the current element and\\n            iii.  {Important part} the count of surplus elements in the nums list\\n                  is greater than or equal to the remaining space in the stack, \\n                  i.e. \\'k-stack_len\\'\\n        b. Then check is stack_len < k, then add the element to the stack\\n            and increment the stack_len by 1\\n    4. return stack\\n    \\n\\nDRY RUN - \\n\\n    Let,\\n        nums = [2,4,3,3,5,4,9,1]\\n        k = 4\\n        \\n        Initially,      \\n        \\n        i   stack       stack_len   nums[i]\\n    \\n        0   [ ]          0           2\\n        \\n        While Loop will run till stack!=[], but here, stack==[] so it will come \\n        out of the loop \\n        AND\\n        stack_len (0) < k (4) \\n        so, nums[i] (2) will be added in the stack\\n        \\n        1   [2]         1           4\\n\\n        While Loop will run till stack!=[] and stack.top() > nums[i], \\n        but here, stack_top() (2) < nums[i] (4) so it will come \\n        out of the loop \\n        AND\\n        stack_len (1) < k (4) \\n        so, nums[i] (4) will be added in the stack\\n   \\n        2   [2,4]       2           3\\n\\n        While Loop will run till stack!=[] and stack.top() > nums[i],\\n        as stack.top() (4) > 3 therefore,\\n        {IMPORTANT}\\n            Here, Before removing stack_top() i.e, 4 It will check, if there \\n            are enought surplus elements in the nums array, to fill the \\n            condition of \\'k\\' values by checking the condition:\\n                \\n                n-i-1>=k-stack_len\\n                \\n                here, n = 8, i = 2, k = 4, stack_len = 2\\n                \\n                so, 8-2-1 >= 4-2 ,i.e., 5>=2, It means we have a total of \\n                5 elements in surplus, which can fill the stack, as we only \\n                need 2 more elements to fill the stack\\n                \\n                Therefore, we will pop the element stack.top(), i.e., 4\\n                and Update the stack_len as - \\n                        \\n                    stack_len -= 1\\n                    \\n                Therefore, updated stack_len = 1\\n                    \\n                We keep on doing the same till the above conditions hold True\\n                \\n                \\n        here, after removing 4, stack = [2] and stack_top (2) < nums[i], \\n        therefore it will come out of the loop \\n        AND\\n        stack_len (1) < k (4) \\n        so, nums[i] (3) will be added in the stack       \\n\\n        3   [2,3]       2           3     \\n\\n        While Loop will run till stack!=[] and stack.top() > nums[i], \\n        but here, stack_top() (3) == nums[i] (3) so it will come \\n        out of the loop \\n        AND\\n        stack_len (2) < k (4) \\n        so, nums[i] (3) will be added in the stack\\n        \\n        4   [2,3,3]     3           5\\n\\n        While Loop will run till stack!=[] and stack.top() > nums[i], \\n        but here, stack_top() (3) < nums[i] (5) so it will come \\n        out of the loop \\n        AND\\n        stack_len (3) < k (4) \\n        so, nums[i] (5) will be added in the stack\\n        \\n        5   [2,3,3,5]   4           4\\n\\n        While Loop will run till stack!=[] and stack.top() > nums[i],\\n        as stack.top() (5) > 4 therefore,\\n        {IMPORTANT}\\n            Here, Before removing stack_top() i.e, 5 It will check, if there \\n            are enought surplus elements in the nums array, to fill the \\n            condition of \\'k\\' values by checking the condition:\\n                \\n                n-i-1>=k-stack_len\\n                \\n                here, n = 8, i = 5, k = 4, stack_len = 4\\n                \\n                so, 8-5-1 >= 4-4 ,i.e., 2>=0, It means we have a total of \\n                2 elements in surplus, which can fill the stack, as now we dont\\n                have emought space to just add a new element, i.e., We can only \\n                remove an element, in order to update the result(stack)\\n                \\n                Therefore, we will pop the element stack.top(), i.e., 5\\n                and Update the stack_len as - \\n                        \\n                    stack_len -= 1\\n                    \\n                Therefore, updated stack_len = 3\\n                    \\n                We keep on doing the same till the above conditions hold True\\n                \\n        here, after removing 5, stack = [2,3,3] and stack_top (3) < nums[i] (4), \\n        therefore it will come out of the loop \\n        AND\\n        stack_len (3) < k (4) \\n        so, nums[i] (4) will be added in the stack \\n\\n        6   [2,3,3,4]   4           9\\n\\n        While Loop will run till stack!=[] and stack.top() > nums[i], \\n        but here, stack_top() (4) < nums[i] (9) so it will come \\n        out of the loop \\n        AND\\n        as, stack_len (4) == k (4) \\n        so, nums[i] (9) will NOT be added in the stack\\n\\n        7   [2,3,3,4]   4           1\\n\\n        While Loop will run till stack!=[] and stack.top() > nums[i],\\n        as stack.top() (4) > 1 therefore,\\n        {IMPORTANT}\\n            Here, Before removing stack_top() i.e, 4 It will check, if there \\n            are enought surplus elements in the nums array, to fill the \\n            condition of \\'k\\' values by checking the condition:\\n                \\n                n-i-1>=k-stack_len\\n                \\n                here, n = 8, i = 7, k = 4, stack_len = 4\\n                \\n                so, 8-7-1 >= 4-4 ,i.e., 0==0, It means we don\\'t have more\\n                elements in surplus, which can fill the stack, and also we dont\\n                have emought space to just add a new element, i.e., We can only \\n                remove one element, in order to update the result(stack)\\n                \\n                Therefore, we will pop the element stack.top(), i.e., 4\\n                and Update the stack_len as - \\n                        \\n                    stack_len -= 1\\n                    \\n                Therefore, updated stack_len = 3\\n                    \\n                \\n            Now our stack = [2,3,3], \\n            We will check if stack!=[] and stack.top() (3) > nums[i] (1) \\n            and at the end... \\n                Whether we have enought surplus elements to fill the remaining\\n                space of the result(stack)\\n                as- \\n                        \\n                    n = 8, i = 7, k = 4, stack_len = 3\\n                    \\n                    if n-i-1>=k-stack_len := 8-7-1>=4-3 \\n                        := 0>=1 i.e., This condition is False\\n                        \\n                        It means, We have no more surplus element in the nums\\n                        array, But If we replace the current stack.top(), then \\n                        we will need 1 more element to meet the \\'k\\' elements \\n                        condition. Therefore, We will not remove the current \\n                        stack.top() and come out of the loop\\n                \\n                \\n        here, after removing 4 and after exiting the loop, \\n        stack = [2,3,3] and stack_len = 3 \\n        AND \\n        as, stack_len (3) < k (4) \\n        so, nums[i] (1) will be added in the stack\\n\\n    \\n    Therefore, at the end, The final values will be-\\n    \\n        stack = [2,3,3,1], stack_len = 4\\n        \\n    AND we will return this \\'stack\\' as the result.\\n\\n\\n    In Summary, The flow of Values goes as - \\n    \\n    i   stack           stack_len   nums[i]\\n    \\n    0   [ ]             0           2\\n    1   [2]             1           4\\n    2   [2,4]           2           3\\n    3   [2,3]           2           3\\n    4   [2,3,3]         3           5\\n    5   [2,3,3,5]       4           4\\n    6   [2,3,3,4]       4           9\\n    7   [2,3,3,4]       4           1\\n    \\n    FINAL\\n    \\n    stack = [2,3,3,1]\\n    stack_len = 4\\n\\nEXERCISE -\\n\\n    Try to dry run on the following example, to better understand \\n    the approach.\\n\\n        nums = [9,1,2,5,8,3]\\n        k = 4\\n\\n    It\\'s answer is [1,2,5,3]\\n\\n\\n# Complexity\\n- Time complexity:\\n    I might be wrong, but the Time complexity will be\\n    O(N+k) ~ O(N)\\n    As, The main loop runs in O(N) and , the inner while loop \\n    runs only for some few iterations with worst case of O(k)\\n\\n\\n- Space complexity:\\n    Space complexity, will be \\n    O(k)\\n    As, we are using a stack of length \\'k\\'\\n\\n# Code\\n```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        stack = []\\n        stack_len = 0\\n        n = len(nums)\\n        for i in range(n):\\n            while stack and stack[-1]>nums[i] and n-i-1>=k-stack_len:\\n                stack.pop(-1)\\n                stack_len-=1\\n            if stack_len<k:\\n                stack+=[nums[i]]\\n                stack_len+=1\\n        \\n        return stack\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        stack = []\\n        stack_len = 0\\n        n = len(nums)\\n        for i in range(n):\\n            while stack and stack[-1]>nums[i] and n-i-1>=k-stack_len:\\n                stack.pop(-1)\\n                stack_len-=1\\n            if stack_len<k:\\n                stack+=[nums[i]]\\n                stack_len+=1\\n        \\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027677,
                "title": "java-with-explaination-2-approaches-99-faster",
                "content": "Problem -\\nas mentioned in HINTS we just need to find the k elements in such a way that they are in increasing order with as smallest combination as possible.\\n1. one approach comes to mind is to sort the array and return first k elements. but by doing this we will fail below case ->\\narr=[2,1,4,3],k=2. \\nby above approach answer will be 1,2 but actual answer is [1,3] as we need to leave 2 if we want to start our output array with 1. So, basically we want lexographic order.\\n\\n**Approach 2->**\\n1. one naive approach comes to mind is to maintain a collection of size k and start arranging element in increasing order in that collection. \\n2. for that stack is usefull as we can compare top element (last element) directly in o(1) time.\\n3. so, iterate through the nums array and push element into stack if current element is greater then stack.peek. else if current element is smaller then peek element of stack remove elements from stack till again stack comes in a increasing order to be able to add current item.\\n4. But we need to handle a condition that stack size should be of size k exactly. so in step 3 pop elements from stack if there are still some possiblity left to complete size k along with element peek value check. ie. (stack.size()+ nums.length-i > k) elements_left_in_loop + stack.size. similarly add element to stack only if current stack size <k.\\n5. once loop finishes just start filling output array from k-1 to 0 from stack.pop()\\n```\\n public int[] mostCompetitive(int[] nums, int k) {\\n        int[] op = new int[k];\\n        Deque<Integer> stack = new LinkedList<>();\\n        for(int i=0;i<nums.length;i++) {\\n            while(!stack.isEmpty() && nums[stack.peek()]>nums[i] && nums.length-i+stack.size()>k) {\\n                stack.pop();\\n            }\\n            if(stack.size()<k) {\\n                stack.push(i);            \\n            }\\n        }\\n        for(int i=k-1;i>=0;i--) {\\n             op[i]=nums[stack.pop()];\\n        }\\n        return op;\\n    }\\n```\\n\\nThe above approach can also further modified and we can use output array of size k to behave as stack itself. where we can use j variable to identify stack current size. it will save extra stack memory and also extra loop to fill back array.\\n\\n```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int[] stack = new int[k];\\n        for(int i=0,j=0;i<nums.length;i++) {\\n          while(j>0 && stack[j-1]>nums[i] && j+nums.length-i>k) {\\n              j--;\\n          }\\n          if(j<k) {\\n              stack[j++]=nums[i];\\n          }\\n        }\\n        return stack;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int[] mostCompetitive(int[] nums, int k) {\\n        int[] op = new int[k];\\n        Deque<Integer> stack = new LinkedList<>();\\n        for(int i=0;i<nums.length;i++) {\\n            while(!stack.isEmpty() && nums[stack.peek()]>nums[i] && nums.length-i+stack.size()>k) {\\n                stack.pop();\\n            }\\n            if(stack.size()<k) {\\n                stack.push(i);            \\n            }\\n        }\\n        for(int i=k-1;i>=0;i--) {\\n             op[i]=nums[stack.pop()];\\n        }\\n        return op;\\n    }\\n```\n```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int[] stack = new int[k];\\n        for(int i=0,j=0;i<nums.length;i++) {\\n          while(j>0 && stack[j-1]>nums[i] && j+nums.length-i>k) {\\n              j--;\\n          }\\n          if(j<k) {\\n              stack[j++]=nums[i];\\n          }\\n        }\\n        return stack;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028519,
                "title": "c-no-stack-fastest-solution-to-date-100ms-explained-100-time-55-space",
                "content": "This was a funny one and we are basically asked to work in a way similar to other problems (no spoilers here, but let\\'s say another one has something to do with temperatures) requiring us to use a stack to solve it.\\n\\nBut do we really need a stack? Since I usually avoid using them and prefer to relay on arrays, here that we need to return a vector, I decided to create one already of the right size and then move with my usual stack-like approach, using a pointer.\\n\\nSo, our sole support variables are just going to be that:\\n* `res`, our solution vector;\\n* `resI`, our pointer.\\n\\nWe will then channel all our logic in one main loop, going with `i` from `0` to the full size of `nums`, store for convenience in `len` and then we will:\\n* store the current element in `n`;\\n* keep popping from our stack - that is, just reducing `resI` until our 3 conditions are all `true`:\\n\\t* `resI > 0`;\\n\\t* the amount of elements left in the vector (`len - i`) is still greater than what is missing from `res` (`k - resI`);\\n\\t* and of course, `n` is smaller than the last element stored (`res[resI - 1]`);\\n* if at the end of it `resI < k`, meaning we can still insert any value, we will do so, storing `n` and moving our pointer with `res[resI++] = n`.\\n\\nOnce done, we can just return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        // support variables\\n        int resI = 0;\\n        vector<int> res(k);\\n        for (int i = 0, n, len = nums.size(); i < len; i++) {\\n            n = nums[i];\\n            // popping out of res if we have elements inside,\\n            // we have enough elements left to replenish it and\\n            // of course n is smaller than the last element\\n            while (resI && k - resI < len - i && res[resI - 1] > n) resI--;\\n            // adding n, if we freed space\\n            if (resI < k) res[resI++] = n;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nOverall time:\\n\\n![image](https://assets.leetcode.com/users/images/24986d3d-750c-46a2-870e-9ecc27751dc0_1611273079.713165.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        // support variables\\n        int resI = 0;\\n        vector<int> res(k);\\n        for (int i = 0, n, len = nums.size(); i < len; i++) {\\n            n = nums[i];\\n            // popping out of res if we have elements inside,\\n            // we have enough elements left to replenish it and\\n            // of course n is smaller than the last element\\n            while (resI && k - resI < len - i && res[resI - 1] > n) resI--;\\n            // adding n, if we freed space\\n            if (resI < k) res[resI++] = n;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027764,
                "title": "find-the-most-competitive-subsequence-c-stack-based-solution",
                "content": "Runtime: 188 ms O(n)  {pushed and popped at most once so its O(n)}\\nMemory Usage: 109.6 MB O(k)\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> ans;//we use vector like stack because we must return a vector\\n        for(int i = 0;i < nums.size();i++){\\n            while(!ans.empty() && ans.back() > nums[i] && ans.size() - 1 + nums.size() - i >= k){\\n                ans.pop_back();\\n            }\\n            if(ans.size() < k){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> ans;//we use vector like stack because we must return a vector\\n        for(int i = 0;i < nums.size();i++){\\n            while(!ans.empty() && ans.back() > nums[i] && ans.size() - 1 + nums.size() - i >= k){\\n                ans.pop_back();\\n            }\\n            if(ans.size() < k){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027653,
                "title": "python-clear-cool-solution-o-n-using-stack",
                "content": "\\tclass Solution:\\n\\t\\tdef mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n\\t\\t\\tend = len(nums) - k\\n\\t\\t\\tans = []\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\twhile end and ans and num < ans[-1] :\\n\\t\\t\\t\\t\\tans.pop()\\n\\t\\t\\t\\t\\tend -= 1\\n\\t\\t\\t\\tans.append(num)\\n\\t\\t\\t\\n\\t\\t\\treturn ans[:k]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n\\t\\t\\tend = len(nums) - k\\n\\t\\t\\tans = []\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\twhile end and ans and num < ans[-1] :\\n\\t\\t\\t\\t\\tans.pop()\\n\\t\\t\\t\\t\\tend -= 1\\n\\t\\t\\t\\tans.append(num)\\n\\t\\t\\t\\n\\t\\t\\treturn ans[:k]",
                "codeTag": "Java"
            },
            {
                "id": 1065744,
                "title": "c-o-n-time-explained-with-comments",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        // we just need to find lexicographically smallest subsequence of size k\\n        int n = nums.size(), removed=0;\\n        //as you can observe, the final answer will be an increasing array\\n        // atleast as long as the constraints permit us\\n        // maintaining a stack would be easy\\n        stack<int> st;\\n        for(int i=0;i<n;){\\n            if(st.empty()) st.push(nums[i]),i++;\\n            else{\\n                if(st.top() <= nums[i]) st.push(nums[i]), i++; \\n                // no harm in putting greater element after smaller element;\\n                else{\\n                    //if we encounter lesser element, we immediately eraese greater element from stack if \\n                    //the constraints permit that.\\n                    if(removed< n-k) st.pop(), removed++;\\n                    else st.push(nums[i]),i++ ; //otherwise we simply keep adding the elements\\n                }\\n            }\\n        }\\n        //the following process is just to get the bottom most k elements \\n        //out of the stack and return them in vector\\n        vector<int> ans(st.size());\\n        while(!st.empty()){\\n            ans.push_back(st.top()); st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        vector<int> ans1(k);\\n        for(int i=0;i<k;i++){\\n            ans1[i] = ans[i];\\n        }\\n        return ans1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        // we just need to find lexicographically smallest subsequence of size k\\n        int n = nums.size(), removed=0;\\n        //as you can observe, the final answer will be an increasing array\\n        // atleast as long as the constraints permit us\\n        // maintaining a stack would be easy\\n        stack<int> st;\\n        for(int i=0;i<n;){\\n            if(st.empty()) st.push(nums[i]),i++;\\n            else{\\n                if(st.top() <= nums[i]) st.push(nums[i]), i++; \\n                // no harm in putting greater element after smaller element;\\n                else{\\n                    //if we encounter lesser element, we immediately eraese greater element from stack if \\n                    //the constraints permit that.\\n                    if(removed< n-k) st.pop(), removed++;\\n                    else st.push(nums[i]),i++ ; //otherwise we simply keep adding the elements\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 953711,
                "title": "python3-greedy-o-n",
                "content": "**Approach 1** - stack `O(N)`\\nHere, we maintain an increasing mono-stack. The trick is that there is a capacity constraint of `k`. You are only allowed to pop out of the stack if the sum of elements on stack `len(stack)` and remaining elements in `nums` (`len(nums) - i`) is more than enough for `k`. \\n\\nImplementation (`O(N)` time & `O(N)` space)\\n```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        stack = [] # (increasing) mono-stack \\n        for i, x in enumerate(nums): \\n            while stack and stack[-1] > x and len(stack) + len(nums) - i > k: stack.pop()\\n            if len(stack) < k: stack.append(x)\\n        return stack \\n```\\n\\n**Approach 2** - priority queue `O(NlogN)`\\nThis is my original approach which utilizes priority queue. The idea is similar to that of Approach 1, but the reletive order is managed via a priority queue. \\n\\nImplementation (`O(NlogN)` time & `O(N)` space)\\n```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        ans, pq = [], []\\n        prev = -inf \\n        for i, x in enumerate(nums): \\n            heappush(pq, (x, i))\\n            if i+k >= len(nums): \\n                while pq and pq[0][1] < prev: heappop(pq)\\n                x, prev = heappop(pq)\\n                ans.append(x)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        stack = [] # (increasing) mono-stack \\n        for i, x in enumerate(nums): \\n            while stack and stack[-1] > x and len(stack) + len(nums) - i > k: stack.pop()\\n            if len(stack) < k: stack.append(x)\\n        return stack \\n```\n```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        ans, pq = [], []\\n        prev = -inf \\n        for i, x in enumerate(nums): \\n            heappush(pq, (x, i))\\n            if i+k >= len(nums): \\n                while pq and pq[0][1] < prev: heappop(pq)\\n                x, prev = heappop(pq)\\n                ans.append(x)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 952805,
                "title": "java-one-pass-solution-use-deque-as-stack",
                "content": "We can use a stack to maintain the most competitve subsequence at current state we have. Once we found there is a smaller number we can replace the top element stack, we can do a pop operation until we cannot pop. Then we push the smaller element into the stack and go on. Finally we can have the smallest subsequence with length of k, which is the most competitve subsequence.\\n```\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        if (k == nums.length) {\\n            return nums;\\n        } \\n        int times = nums.length - k;\\n        Deque<Integer> dq = new LinkedList<>();\\n        for (int c : nums) {\\n            while (!dq.isEmpty() && dq.peekLast() > c && times > 0) {\\n                times--;\\n                dq.removeLast();\\n            }\\n            dq.offer(c);\\n        }\\n        \\n        while (times > 0) {\\n            times--;\\n            dq.removeLast();\\n        }\\n        \\n        int[] res = new int[dq.size()];\\n        int i = 0;\\n        while (!dq.isEmpty()) {\\n            res[i++] = dq.remove();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        if (k == nums.length) {\\n            return nums;\\n        } \\n        int times = nums.length - k;\\n        Deque<Integer> dq = new LinkedList<>();\\n        for (int c : nums) {\\n            while (!dq.isEmpty() && dq.peekLast() > c && times > 0) {\\n                times--;\\n                dq.removeLast();\\n            }\\n            dq.offer(c);\\n        }\\n        \\n        while (times > 0) {\\n            times--;\\n            dq.removeLast();\\n        }\\n        \\n        int[] res = new int[dq.size()];\\n        int i = 0;\\n        while (!dq.isEmpty()) {\\n            res[i++] = dq.remove();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952775,
                "title": "kt-js-py3-cpp-monotonic-queue",
                "content": "**Synopsis:**\\n\\nUse a stack `S` as a [monotonic queue](https://medium.com/algorithms-and-leetcode/monotonic-queue-explained-with-leetcode-problems-7db7c530c1d6), ie. only allow monotonically non-descreasing values to remain \"enqueued\" during a linear scan of the input array `A` (violations are popped off the stack).  This strategy results in the greedy consumption of the `K` minimal values of `A` to be placed into the \"most significant\" positions of the answer.\\n    \\n**Notes:**\\n\\n* The monotonic queue invariant is \"relaxed\" if and only if we *must* use the last values of A.  This is expressed as follows: `i + K - |S| < N` where `|S|` is the current cardinality of the monotonic queue, ie. if whatever\\'s left to consider of `A` is needed to fill the queue with `K` elements, then no longer remove elements from the monotonic queue.\\n* The +1 bug `\\uD83D\\uDC1E` occurred because I accidentally submitted with debug prints which caused TLE on large input... oops! \\uD83D\\uDE43\\n\\n---\\n\\n**Contest 217 Screenshare:**\\n\\n![image](https://assets.leetcode.com/users/images/4805ce0c-7942-47f5-994a-b50533c748c1_1606622509.8377178.png)\\n\\nhttps://www.youtube.com/watch?v=9Wwv3qWOlsI\\n\\n---\\n    \\n*Kotlin*\\n```\\nclass Solution {\\n    fun mostCompetitive(A: IntArray, K: Int): IntArray {\\n        var S = Stack<Int>()\\n        var N = A.size\\n        var i = 0\\n        while (i < N)\\n            if (0 < S.size && A[i] < S.peek() && i + K - S.size < N)  // \\uD83D\\uDCC8 maintain monotonic queue invariant\\n                S.pop()\\n            else\\n                S.push(A[i++])\\n        return S.slice(0..K - 1).toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet mostCompetitive = (A, K, S = []) => {\\n    let N = A.length,\\n        i = 0;\\n    while (i < N)\\n        if (S.length && A[i] < S[S.length - 1] && i + K - S.length < N)  // \\uD83D\\uDCC8 maintain monotonic queue invariant\\n            S.pop();\\n        else\\n            S.push(A[i++]);\\n    return S.slice(0, K);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def mostCompetitive(self, A: List[int], K: int) -> List[int]:\\n        S = []\\n        N = len(A)\\n        i = 0\\n        while i < N:\\n            if len(S) and A[i] < S[-1] and i + K - len(S) < N:  # \\uD83D\\uDCC8 maintain monotonic queue invariant\\n                S.pop()\\n            else:\\n                S.append(A[i])\\n                i += 1\\n        return S[:K]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI mostCompetitive(VI& A, int K, VI S = {}) {\\n        int N = A.size(),\\n            i = 0;\\n        while (i < N)\\n            if (!S.empty() && A[i] < S.back() && i + K - S.size() < N)  // \\uD83D\\uDCC8 maintain monotonic queue invariant\\n                S.pop_back();\\n            else\\n                S.push_back(A[i++]);\\n        return { S.begin(), S.begin() + K };\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun mostCompetitive(A: IntArray, K: Int): IntArray {\\n        var S = Stack<Int>()\\n        var N = A.size\\n        var i = 0\\n        while (i < N)\\n            if (0 < S.size && A[i] < S.peek() && i + K - S.size < N)  // \\uD83D\\uDCC8 maintain monotonic queue invariant\\n                S.pop()\\n            else\\n                S.push(A[i++])\\n        return S.slice(0..K - 1).toIntArray()\\n    }\\n}\\n```\n```\\nlet mostCompetitive = (A, K, S = []) => {\\n    let N = A.length,\\n        i = 0;\\n    while (i < N)\\n        if (S.length && A[i] < S[S.length - 1] && i + K - S.length < N)  // \\uD83D\\uDCC8 maintain monotonic queue invariant\\n            S.pop();\\n        else\\n            S.push(A[i++]);\\n    return S.slice(0, K);\\n};\\n```\n```\\nclass Solution:\\n    def mostCompetitive(self, A: List[int], K: int) -> List[int]:\\n        S = []\\n        N = len(A)\\n        i = 0\\n        while i < N:\\n            if len(S) and A[i] < S[-1] and i + K - len(S) < N:  # \\uD83D\\uDCC8 maintain monotonic queue invariant\\n                S.pop()\\n            else:\\n                S.append(A[i])\\n                i += 1\\n        return S[:K]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI mostCompetitive(VI& A, int K, VI S = {}) {\\n        int N = A.size(),\\n            i = 0;\\n        while (i < N)\\n            if (!S.empty() && A[i] < S.back() && i + K - S.size() < N)  // \\uD83D\\uDCC8 maintain monotonic queue invariant\\n                S.pop_back();\\n            else\\n                S.push_back(A[i++]);\\n        return { S.begin(), S.begin() + K };\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652694,
                "title": "python3-1673-find-the-most-competitive-subsequence-t-m-98-95",
                "content": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n\\n        n, ans = len(nums)-k, []\\n\\n        for num in nums:\\n            while n and ans and num < ans[-1]:\\n                ans.pop()\\n                n -= 1            \\n            ans.append(num)\\n\\n        return ans[:k]\\n```\\n[https://leetcode.com/submissions/detail/813765286/](http://)",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n\\n        n, ans = len(nums)-k, []\\n\\n        for num in nums:\\n            while n and ans and num < ans[-1]:\\n                ans.pop()\\n                n -= 1            \\n            ans.append(num)\\n\\n        return ans[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027691,
                "title": "find-the-most-competitive-subsequence-java-stack-solution",
                "content": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int[] res=new int[k];\\n        Stack<Integer> stack=new Stack<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n           \\n            while(!stack.isEmpty() && nums[i]<stack.peek() && nums.length-i+stack.size() > k)\\n                stack.pop();\\n            \\n            if(stack.size()<k )\\n                stack.push(nums[i]);\\n        }\\n        \\n        for(int i=k-1;i>=0;i--)\\n            res[i]=stack.pop();\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int[] res=new int[k];\\n        Stack<Integer> stack=new Stack<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n           \\n            while(!stack.isEmpty() && nums[i]<stack.peek() && nums.length-i+stack.size() > k)\\n                stack.pop();\\n            \\n            if(stack.size()<k )\\n                stack.push(nums[i]);\\n        }\\n        \\n        for(int i=k-1;i>=0;i--)\\n            res[i]=stack.pop();\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952996,
                "title": "golang-stack-min-healp-solutions-with-explanation",
                "content": "My first intuition is to find lexicographical order from provided numbers.\\n\\ne.g. nums = [2, 4, 3, 3, 5, 4, 9, 6], k = 4\\n\\nSelect smallest possible numbers to form a non-decreasing sequences is [2, 3, 3, 4, 6], truncate to size k gets answer [2, 3, 3, 4].\\n\\nBut the problem is, best non-decreasing subsequences might not fit into k size, take nums = [8, 9, 5, 6, 7, 4, 5], k = 3 as an example.\\n\\nSmallest non-decreasing subsequences is [4, 5], which is not enough for form answer with size 3.\\n\\nThe trick is to use another vairable `toRemove`, denotes how many numbers can be removed. The reason to use this is because, lexicographical order means select smallest possible, and if one number is smaller than the other, afterwards numbers don\\'t care.\\n\\nIf previous smallest numbers are selected still not satisfies size k, then remaining numbers should be all selected to form answer.\\n\\nTo find smallest non-decreasing sequences, `stack` can be used: poping nuber larger than next number until no numbers should be popped. Take nums = [2, 4, 3, 3, 5, 4, 9, 6], k = 4 as an example.\\n\\n```\\n1. [2, 4, 3, 3, 5, 4, 9, 6]\\n    ^\\n    stack: [2]\\n\\n2. [2, 4, 3, 3, 5, 4, 9, 6]\\n       ^\\n   4 > last number of stack (2), pushing\\n   stack: [2, 4]\\n\\n3. [2, 4, 3, 3, 5, 4, 9, 6]\\n          ^\\n   3 < last number of stack (4), poping\\n   3 > last number of stack (2), pushing\\n   stack: [2, 3]\\n\\n4. [2, 4, 3, 3, 5, 4, 9, 6]\\n             ^\\n   3 == last number of stack (3), pushing\\n   stack: [2, 3, 3]\\n\\n5. [2, 4, 3, 3, 5, 4, 9, 6]\\n                ^\\n   5 > last number of stack (3), pushing\\n   stack: [2, 3, 3, 5]\\n\\n6. [2, 4, 3, 3, 5, 4, 9, 6]\\n                   ^\\n   4 < last number of stack (5), poping\\n   4 > last number of stack (3), pushing\\n   stack: [2, 3, 3, 4]\\n\\n7. [2, 4, 3, 3, 5, 4, 9, 6]\\n                      ^\\n   9 > last number of stack (4), pushing\\n   stack: [2, 3, 3, 4, 9]\\n\\n8. [2, 4, 3, 3, 5, 4, 9, 6]\\n                         ^\\n   6 < last number of stack (9), poping\\n   6 > last number of stack (4), pushing\\n   stack: [2, 3, 3, 4, 6]\\n```\\n\\nTime complexity to use stack to solve this problem is O(n)\\n\\n```golang\\nfunc mostCompetitive(nums []int, k int) []int {\\n    size := len(nums)\\n    toRemove := size-k\\n    stack := make([]int, 0)\\n\\n    for i := range nums {\\n        for len(stack) > 0 && toRemove > 0 && stack[len(stack)-1] > nums[i] {\\n            toRemove--\\n            stack = stack[:len(stack)-1]\\n        }\\n\\n        stack = append(stack, nums[i])\\n    }\\n\\n    return stack[:k]\\n}\\n```\\n\\nAnother solution is to solve by selecting smallest possible from min-heap. To make sure there are enough numbers to form answer, pushing `size-k+1` numbers into min-heap, each time select smallest from heap and push next remaining number.\\n\\nThe reason this works is because, every iteration selects one number and pushing next number from `nums`, and there will guarantee enough numbers to select.\\n\\n```golang\\ntype MinHeap [][]int\\n\\nfunc (h MinHeap) Len() int { return len(h) }\\n\\n// same number, smaller index first\\nfunc (h MinHeap) Less(i, j int) bool {\\n\\tif h[i][0] == h[j][0] {\\n\\t\\treturn h[i][1] < h[j][1]\\n\\t}\\n\\treturn h[i][0] < h[j][0]\\n}\\n\\nfunc (h MinHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\\nfunc (h MinHeap) Peek() []int   { return h[0] }\\n\\nfunc (h *MinHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.([]int))\\n}\\n\\nfunc (h *MinHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc mostCompetitive1(nums []int, k int) []int {\\n\\tsize := len(nums)\\n\\n\\th := &MinHeap{}\\n\\theap.Init(h)\\n\\n\\t// push size-k numbers into heap, make sure selecting\\n\\t// from smallest, and at least remaining numbers are\\n\\t// sufficient to form answers with k remaining numbers\\n\\tvar i int\\n\\tfor i = 0; i <= size-k; i++ {\\n\\t\\theap.Push(h, []int{nums[i], i})\\n\\t}\\n\\n\\tans := make([]int, 0)\\n\\tprev := -1\\n\\n\\tfor len(ans) < k {\\n\\t\\t// remove numbers before selected ones\\n\\t\\t// because smallest is selected, all previous\\n\\t\\t// larger should be removed\\n\\t\\tfor h.Len() > 0 && h.Peek()[1] < prev {\\n\\t\\t\\theap.Pop(h)\\n\\t\\t}\\n\\n\\t\\tp := heap.Pop(h).([]int)\\n\\n\\t\\tif i < size {\\n\\t\\t\\theap.Push(h, []int{nums[i], i})\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t\\tans = append(ans, p[0])\\n\\t\\tprev = p[1]\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n1. [2, 4, 3, 3, 5, 4, 9, 6]\\n    ^\\n    stack: [2]\\n\\n2. [2, 4, 3, 3, 5, 4, 9, 6]\\n       ^\\n   4 > last number of stack (2), pushing\\n   stack: [2, 4]\\n\\n3. [2, 4, 3, 3, 5, 4, 9, 6]\\n          ^\\n   3 < last number of stack (4), poping\\n   3 > last number of stack (2), pushing\\n   stack: [2, 3]\\n\\n4. [2, 4, 3, 3, 5, 4, 9, 6]\\n             ^\\n   3 == last number of stack (3), pushing\\n   stack: [2, 3, 3]\\n\\n5. [2, 4, 3, 3, 5, 4, 9, 6]\\n                ^\\n   5 > last number of stack (3), pushing\\n   stack: [2, 3, 3, 5]\\n\\n6. [2, 4, 3, 3, 5, 4, 9, 6]\\n                   ^\\n   4 < last number of stack (5), poping\\n   4 > last number of stack (3), pushing\\n   stack: [2, 3, 3, 4]\\n\\n7. [2, 4, 3, 3, 5, 4, 9, 6]\\n                      ^\\n   9 > last number of stack (4), pushing\\n   stack: [2, 3, 3, 4, 9]\\n\\n8. [2, 4, 3, 3, 5, 4, 9, 6]\\n                         ^\\n   6 < last number of stack (9), poping\\n   6 > last number of stack (4), pushing\\n   stack: [2, 3, 3, 4, 6]\\n```\n```golang\\nfunc mostCompetitive(nums []int, k int) []int {\\n    size := len(nums)\\n    toRemove := size-k\\n    stack := make([]int, 0)\\n\\n    for i := range nums {\\n        for len(stack) > 0 && toRemove > 0 && stack[len(stack)-1] > nums[i] {\\n            toRemove--\\n            stack = stack[:len(stack)-1]\\n        }\\n\\n        stack = append(stack, nums[i])\\n    }\\n\\n    return stack[:k]\\n}\\n```\n```golang\\ntype MinHeap [][]int\\n\\nfunc (h MinHeap) Len() int { return len(h) }\\n\\n// same number, smaller index first\\nfunc (h MinHeap) Less(i, j int) bool {\\n\\tif h[i][0] == h[j][0] {\\n\\t\\treturn h[i][1] < h[j][1]\\n\\t}\\n\\treturn h[i][0] < h[j][0]\\n}\\n\\nfunc (h MinHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\\nfunc (h MinHeap) Peek() []int   { return h[0] }\\n\\nfunc (h *MinHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.([]int))\\n}\\n\\nfunc (h *MinHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc mostCompetitive1(nums []int, k int) []int {\\n\\tsize := len(nums)\\n\\n\\th := &MinHeap{}\\n\\theap.Init(h)\\n\\n\\t// push size-k numbers into heap, make sure selecting\\n\\t// from smallest, and at least remaining numbers are\\n\\t// sufficient to form answers with k remaining numbers\\n\\tvar i int\\n\\tfor i = 0; i <= size-k; i++ {\\n\\t\\theap.Push(h, []int{nums[i], i})\\n\\t}\\n\\n\\tans := make([]int, 0)\\n\\tprev := -1\\n\\n\\tfor len(ans) < k {\\n\\t\\t// remove numbers before selected ones\\n\\t\\t// because smallest is selected, all previous\\n\\t\\t// larger should be removed\\n\\t\\tfor h.Len() > 0 && h.Peek()[1] < prev {\\n\\t\\t\\theap.Pop(h)\\n\\t\\t}\\n\\n\\t\\tp := heap.Pop(h).([]int)\\n\\n\\t\\tif i < size {\\n\\t\\t\\theap.Push(h, []int{nums[i], i})\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t\\tans = append(ans, p[0])\\n\\t\\tprev = p[1]\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952836,
                "title": "python3-easy-to-understand",
                "content": "Very silimar to [**Monotonous Stack**](https://labuladong.gitbook.io/algo-en/ii.-data-structure/monotonicstack)\\n\\nWe should maintance a decreasing monotone stack from top to botom, so we should choose the numbers as small as possible into the stack. \\nFor example:  \\nnums = [3,5,2,6,8], k = 2\\nstep1: stack = [3] `append(3)`\\nstep2: stack = [3,5] since 5 > 3 `append(5)`\\nstep3: stack = [3] since 2<5 and `pop()`\\nstep4: stack = [] since 2<3 and `pop()`\\nstep5: stack = [2] `append(2)`\\nstep6: stack = [2,6] since 6>2 `append(6)`\\nstep7: stack = [2,6,8] since 8>6 `append(8)`\\nThe answer is stack[:2] = [2,6]\\n\\n**However**, the numbers in stack cannot be less than k. \\nWhen **len(stack)+len(nums)-i <= k**, it means we have no choice but choose all the numbers left in the list into stack. \\nFor example:\\nnums = [71,18,66,8,80,2], k = 3\\nstep1: stack = [71] `append(71)`\\nstep2: stack = [18] since 18< 71  `pop()` and `append(18)`\\nstep3: stack = [18, 66] since 66>18 `append(66)`\\nstep4: stack = [18] since 8<66 and `pop()`\\nstep5: stack = [] since 8<18 and `pop()`\\nstep6: stack = [8] `append(8)`\\nstep7: stack = [8, 80] since 80>8 `append(80)`\\nstep8: stack = [8] since 2<80 and `pop()`\\nstep9: stack = [] since 2<8 and `pop()`\\nstep10: stack = [2] `append(2)`\\nOutput: stack = [2]\\nThis is a **Wrong** answer as the` len(output)` must be k\\nIn step8, i = 5 and len(stack)+len(nums)-i == k, so we should not pop anything but just append 2 into stack\\nstep9: stack = [8,80,2] `append(2)`\\nThe answer is stack[:3] = [8,80,2]\\n```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        stack = []\\n        for i in range(len(nums)):\\n            while stack and len(stack)+len(nums)-i>k and stack[-1] > nums[i]:\\n                stack.pop()\\n            stack.append(nums[i])\\n        return stack[:k]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        stack = []\\n        for i in range(len(nums)):\\n            while stack and len(stack)+len(nums)-i>k and stack[-1] > nums[i]:\\n                stack.pop()\\n            stack.append(nums[i])\\n        return stack[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952774,
                "title": "java-easy-to-understand-explanation",
                "content": "I use an increasing stack to store the index. Pop the stack if the new number is less than the stack.peek(). But, if we are almost at the end of the array and we can\\'t afford to lose any more numbers, we shouldn\\'t pop, and we can ignore the increasing order.\\n\\n```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        Stack<Integer> s = new Stack<>();\\n        for (int i = 0; i<nums.length; i++){\\n            while(!s.isEmpty() && nums[s.peek()]>nums[i] && i<= nums.length-1-k+ s.size()) s.pop();\\n            s.push(i);\\n            if (s.size()>k) s.pop();\\n        }\\n        int[] ans = new int[k];\\n        for (int j = k-1; j >=0; j--) ans[j] = nums[s.pop()];\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        Stack<Integer> s = new Stack<>();\\n        for (int i = 0; i<nums.length; i++){\\n            while(!s.isEmpty() && nums[s.peek()]>nums[i] && i<= nums.length-1-k+ s.size()) s.pop();\\n            s.push(i);\\n            if (s.size()>k) s.pop();\\n        }\\n        int[] ans = new int[k];\\n        for (int j = k-1; j >=0; j--) ans[j] = nums[s.pop()];\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903056,
                "title": "c-stack-solution-intuition-monotonic-stack",
                "content": "This question might not seem intuitive at first but its actually really easy. We need to make smallest subsequence possible. I recommend you to solve monotonic stack\\'s problems first, like [[739. Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)].\\n* Monotonic stacks are used to find the next smaller or next greater element in an array. The concept is, we keep on pushing the elements in stack untill we are on an element which is smaller than stack\\'s top and when we reach such a number, we keep on popping the stack till the point where it is either empty or its top is smaller than our current element. This way, we reach a stage where all the elements in the stack are in an increaing order from bottom to top. \\n\\nNow, coming back to this question, here we need to find the next smaller element in such a way that overall subsequence is minimum possible. So, we maintain a track of number of elements remaining in the array and number of positions to be filled. When we have number of elements remining in the array equal to number of positions to be filled, we do not have any choice among the elements and we have to take all the elements in the same order. In other case, where we have enough elements to choose from, we run monotonic stack to find the minimum element possible at current position. While doing the same, we maintain the track of remaining positions as well, ie if we are removing something from stack, we increase the number of remaining positions and when we are pushing into stack, we decrease. At last, we need to pop the extra elements from our stack. Since it could have more elements than required. Thus we pop untill its size is equal to k.\\nFor ex. in case  nums = [2,4,3,3,5,4,9,6], k = 4, stack at last will be [6,4,3,3,2] whereas we only require 4 elements thus we remove the top elements which are greater than other elements in stack(because stack only stores monotonically).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int rem = k, count = 0, n = nums.size();\\n        stack <int> st;\\n        \\n        for(int i = 0; i<n; i++){\\n            if(st.empty()) st.push(nums[i]);\\n            else{\\n                count = n-i;\\n                while(!st.empty() and st.top()>nums[i] and count>=rem and rem<=k) st.pop(), rem++;\\n                st.push(nums[i]);\\n                rem--;\\n            }\\n        }\\n        vector <int> res;\\n        while(st.size()>k) st.pop();\\n        while(!st.empty()){\\n            res.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int rem = k, count = 0, n = nums.size();\\n        stack <int> st;\\n        \\n        for(int i = 0; i<n; i++){\\n            if(st.empty()) st.push(nums[i]);\\n            else{\\n                count = n-i;\\n                while(!st.empty() and st.top()>nums[i] and count>=rem and rem<=k) st.pop(), rem++;\\n                st.push(nums[i]);\\n                rem--;\\n            }\\n        }\\n        vector <int> res;\\n        while(st.size()>k) st.pop();\\n        while(!st.empty()){\\n            res.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027592,
                "title": "js-python-java-c-stack-solution-w-explanation-beats-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe problem\\'s definition for \"competitiveness\" sounds just like a standard sort order, and just like a standard sort order, it can be improved by removing any larger number that comes before a lower number. Also, the further left in the input you make this removal, the larger its impact.\\n\\nThe trick here is to perform this operation as many times as you can while still making sure you have at least **K** elements left.\\n\\nThe standard solution here will resemble a **stack**, as we\\'ll iterate through our input (**N**) and push values to the answer stack. If the next value (**N[i]**) is lower than the top value of the stack, then we\\'ll pop numbers off the stack until it\\'s not. By doing this, our stack will always be sorted in ascending order.\\n\\nIf at any point the number of elements you can safely remove (**moves**) is reduced to **0**, then we combine our stack with the remaining elements of **N** and **return**. If we reach the end of **N** and our stack is longer than **K**, just return the first **K** elements.\\n\\nBut as is often the case when we\\'re doing a one-time pass through an array and selectively removing elements, we can increase our efficiency by doing an **in-place stack** using a **2-pointer system** by using the early positions of **N** as our answer stack.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython, unlike the other three languages, actually prefers the normal stack solution rather than an in-place version.\\n\\nC++ can drastically improve the speed up its solution of this particular problem via use of a custom lambda function designed to speed up I/O.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **200ms / 55.9MB** (beats 98% / 100%).\\n```javascript\\nvar mostCompetitive = function(N, K) {\\n    let len = N.length, moves = len - K\\n    for (let i = 0, j = 1; j < len;) {\\n        while (N[j] < N[i] && moves) i--, moves--\\n        if (!moves) return N.slice(0,i+1).concat(N.slice(j))\\n        N[++i] = N[j++]\\n    }\\n    return N.slice(0,K)\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **1232ms / 27.1MB** (beats 100% / 86%).\\n```python\\nclass Solution:\\n    def mostCompetitive(self, N: List[int], K: int) -> List[int]:\\n        i, moves = 0, len(N) - K\\n        ans = []\\n        for x in N:\\n            while ans and moves and x < ans[-1]:\\n                ans.pop()\\n                moves -= 1\\n            ans.append(x)\\n        return ans[:K]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **5ms / 54.8MB** (beats 100% / 36%).\\n```java\\nclass Solution {\\n    public int[] mostCompetitive(int[] N, int K) {\\n        int len = N.length;\\n        int moves = len - K;\\n        for (int i = 0, j = 1; j < len;) {\\n            while (moves > 0 && i >= 0 && N[j] < N[i]) {\\n                i--;\\n                moves--;\\n            }\\n            N[++i] = N[j++];\\n        }\\n        return Arrays.copyOfRange(N,0,K);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **88ms / 106.3MB** (beats 100% / 93%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& N, int K) {\\n        int len = N.size();\\n        int moves = len - K;\\n        for (int i = 0, j = 1; j < len;) {\\n            while (moves && i >= 0 && N[j] < N[i])\\n                i--, moves--;\\n            N[++i] = N[j++];\\n        }\\n        return vector<int>(N.begin(), N.begin() + K);\\n    }\\n};\\n\\nstatic int fastIO = [] {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(0);\\n    cout.tie(0);\\n    return 0;\\n}();\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar mostCompetitive = function(N, K) {\\n    let len = N.length, moves = len - K\\n    for (let i = 0, j = 1; j < len;) {\\n        while (N[j] < N[i] && moves) i--, moves--\\n        if (!moves) return N.slice(0,i+1).concat(N.slice(j))\\n        N[++i] = N[j++]\\n    }\\n    return N.slice(0,K)\\n};\\n```\n```python\\nclass Solution:\\n    def mostCompetitive(self, N: List[int], K: int) -> List[int]:\\n        i, moves = 0, len(N) - K\\n        ans = []\\n        for x in N:\\n            while ans and moves and x < ans[-1]:\\n                ans.pop()\\n                moves -= 1\\n            ans.append(x)\\n        return ans[:K]\\n```\n```java\\nclass Solution {\\n    public int[] mostCompetitive(int[] N, int K) {\\n        int len = N.length;\\n        int moves = len - K;\\n        for (int i = 0, j = 1; j < len;) {\\n            while (moves > 0 && i >= 0 && N[j] < N[i]) {\\n                i--;\\n                moves--;\\n            }\\n            N[++i] = N[j++];\\n        }\\n        return Arrays.copyOfRange(N,0,K);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& N, int K) {\\n        int len = N.size();\\n        int moves = len - K;\\n        for (int i = 0, j = 1; j < len;) {\\n            while (moves && i >= 0 && N[j] < N[i])\\n                i--, moves--;\\n            N[++i] = N[j++];\\n        }\\n        return vector<int>(N.begin(), N.begin() + K);\\n    }\\n};\\n\\nstatic int fastIO = [] {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(0);\\n    cout.tie(0);\\n    return 0;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1027523,
                "title": "simple-java-based-solution-using-stack",
                "content": "The idea is to find a subsequence in which the left most element gets as much priority as possible. By priority I mean it should be smallest possible. For this, we use a stack and whenever we get an element smaller than the one pushed onto the stack top, we pop the stack and add the new \\'smaller\\' element. We continue this cycle and hence we get an increasing sequence.\\n\\nOne case to consider is when we don\\'t have enough elements in the stack due to a sequence like a decreasing sequence eg - [5,4,3,2,1] and k = 2. Our logic here would pop everyting out and leave us an empty stack which is undesirable. Hence in such cases, we will reach a point while iterating the array such that all elements after it\\'s index have to be pushed onto the stack to give sufficient elements. In this case, when we reach index, `i = 3`. Therefore the `&&` statements in the `while`. \\nOnce rhis is done, the first `k` elements of stack should be returned. \\n\\nI have used another stack to reverse the original stack and return first `k` elements. \\nJava code - \\n```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        if(nums.length == k){\\n            return nums;\\n        }\\n        int n = nums.length;\\n        int remaining = n;\\n        Stack<Integer> s = new Stack<>();\\n        for(int i = 0; i < n; i++){\\n            remaining = n - i - 1;\\n            while(s.empty() == false && s.size() + remaining >= k && s.peek() > nums[i]){\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n        }\\n        Stack<Integer> rev = new Stack<>();\\n        while(s.empty() == false){\\n            rev.push(s.pop());\\n        }\\n        int[] ans = new int[k];\\n        int j = 0;\\n        while(j < k && rev.empty() == false){\\n            ans[j++] = rev.peek();\\n            rev.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        if(nums.length == k){\\n            return nums;\\n        }\\n        int n = nums.length;\\n        int remaining = n;\\n        Stack<Integer> s = new Stack<>();\\n        for(int i = 0; i < n; i++){\\n            remaining = n - i - 1;\\n            while(s.empty() == false && s.size() + remaining >= k && s.peek() > nums[i]){\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n        }\\n        Stack<Integer> rev = new Stack<>();\\n        while(s.empty() == false){\\n            rev.push(s.pop());\\n        }\\n        int[] ans = new int[k];\\n        int j = 0;\\n        while(j < k && rev.empty() == false){\\n            ans[j++] = rev.peek();\\n            rev.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954188,
                "title": "c-using-stack-throw-away-large-elements-if-enough-elements-are-remaining",
                "content": "```csharp\\npublic int[] MostCompetitive(int[] nums, int k)\\n{\\n\\tif (nums.Length == k)\\n\\t{\\n\\t\\treturn nums;\\n\\t}\\n\\n\\tStack<int> stack = new Stack<int>();\\n\\n\\tfor (int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tint remaining = nums.Length - i;\\n\\n\\t\\twhile (stack.Count > 0 && stack.Peek() > nums[i]\\n\\t\\t\\t  && remaining + stack.Count > k)\\n\\t\\t{   \\n\\t\\t\\tstack.Pop();\\n\\t\\t}\\n\\n\\t\\tstack.Push(nums[i]);\\n\\t}\\n\\n\\tint[] result = stack.Reverse().Take(k).ToArray();            \\n\\treturn result;\\n} \\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int[] MostCompetitive(int[] nums, int k)\\n{\\n\\tif (nums.Length == k)\\n\\t{\\n\\t\\treturn nums;\\n\\t}\\n\\n\\tStack<int> stack = new Stack<int>();\\n\\n\\tfor (int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tint remaining = nums.Length - i;\\n\\n\\t\\twhile (stack.Count > 0 && stack.Peek() > nums[i]\\n\\t\\t\\t  && remaining + stack.Count > k)\\n\\t\\t{   \\n\\t\\t\\tstack.Pop();\\n\\t\\t}\\n\\n\\t\\tstack.Push(nums[i]);\\n\\t}\\n\\n\\tint[] result = stack.Reverse().Take(k).ToArray();            \\n\\treturn result;\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952797,
                "title": "kotlin-monotonic-stack",
                "content": "Solution - [github](https://github.com/An7One/leetcode-solutions-kotlin-an7one/tree/main/src/main/kotlin/com/an7one/leetcode/lvl3/lc1673)\\n\\n<b>Problem List</b>\\n#MonoStack - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/stack/stack_monotonic.txt)\\n#MonoDeque - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/queue/queue_monotonic.txt)\\n\\n```\\nclass Solution {\\n    fun mostCompetitive(nums: IntArray, k: Int): IntArray {\\n        val nNums= nums.size\\n\\t\\t// number of esasure at most\\n        val limit = nNums - k\\n\\n        val stack = ArrayDeque<Int>()\\n\\t\\t// the acutal instances of esaure\\n        var count = 0\\n\\n        for(num in nums){\\n            while(stack.isNotEmpty() && count < limit && stack.last() > num){\\n                stack.removeLast()\\n                ++count\\n            }\\n            \\n            stack.addLast(num)\\n        }\\n        \\n\\t\\t// to pop them out, if there are more than k elements in the stack now\\n        while(stack.size > k) {\\n\\t\\t\\tstack.removeLast()\\n\\t\\t}\\n        \\n\\t\\t// to construct the answer array\\n        return stack.toIntArray()\\n\\t}\\n}\\n```\\n\\nThis approach barely passes.\\n```\\nclass Solution {\\n    fun mostCompetitive(nums: IntArray, k: Int): IntArray {\\n        val nNums = nums.size\\n        val limit = nNums - k\\n\\n        val stack = ArrayDeque<Int>()\\n        var count = 0\\n\\n        for (num in nums) {\\n            while (stack.isNotEmpty() && count < limit && stack.last > num) {\\n                stack.removeLast()\\n                ++count\\n            }\\n\\n            stack.addLast(num)\\n        }\\n\\n        while (stack.size > k) {\\n            stack.removeLast()\\n        }\\n\\n\\t\\t// to construct the answer array\\n        return stack.toIntArray()\\n    }\\n}\\n```\\n\\nThis approach gets TLEed.\\n```\\nclass Solution {\\n    fun mostCompetitive(nums: IntArray, k: Int): IntArray {\\n        val nNums = nums.size\\n        val limit = nNums - k\\n\\n        val stack = ArrayDeque<Int>()\\n        var count = 0\\n\\n        for (num in nums) {\\n            while (stack.isNotEmpty() && count < limit && stack.last() > num) {\\n                stack.removeLast()\\n                ++count\\n            }\\n\\n            stack.addLast(num)\\n        }\\n\\n        while (stack.size > k) {\\n            stack.removeLast()\\n        }\\n\\n        return stack.toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    fun mostCompetitive(nums: IntArray, k: Int): IntArray {\\n        val nNums= nums.size\\n\\t\\t// number of esasure at most\\n        val limit = nNums - k\\n\\n        val stack = ArrayDeque<Int>()\\n\\t\\t// the acutal instances of esaure\\n        var count = 0\\n\\n        for(num in nums){\\n            while(stack.isNotEmpty() && count < limit && stack.last() > num){\\n                stack.removeLast()\\n                ++count\\n            }\\n            \\n            stack.addLast(num)\\n        }\\n        \\n\\t\\t// to pop them out, if there are more than k elements in the stack now\\n        while(stack.size > k) {\\n\\t\\t\\tstack.removeLast()\\n\\t\\t}\\n        \\n\\t\\t// to construct the answer array\\n        return stack.toIntArray()\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n    fun mostCompetitive(nums: IntArray, k: Int): IntArray {\\n        val nNums = nums.size\\n        val limit = nNums - k\\n\\n        val stack = ArrayDeque<Int>()\\n        var count = 0\\n\\n        for (num in nums) {\\n            while (stack.isNotEmpty() && count < limit && stack.last > num) {\\n                stack.removeLast()\\n                ++count\\n            }\\n\\n            stack.addLast(num)\\n        }\\n\\n        while (stack.size > k) {\\n            stack.removeLast()\\n        }\\n\\n\\t\\t// to construct the answer array\\n        return stack.toIntArray()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun mostCompetitive(nums: IntArray, k: Int): IntArray {\\n        val nNums = nums.size\\n        val limit = nNums - k\\n\\n        val stack = ArrayDeque<Int>()\\n        var count = 0\\n\\n        for (num in nums) {\\n            while (stack.isNotEmpty() && count < limit && stack.last() > num) {\\n                stack.removeLast()\\n                ++count\\n            }\\n\\n            stack.addLast(num)\\n        }\\n\\n        while (stack.size > k) {\\n            stack.removeLast()\\n        }\\n\\n        return stack.toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669403,
                "title": "monotonic-stack-c-simple-easy",
                "content": "# Intuition\\nBasic Moonotonic increasing Stack\\n\\n# Approach \\nApproach is clear that we need a ans array of size `k` so we need to remove `n - k` element while maintaing the ans array with monotonic increasing stack property.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        int needToRemove = nums.size() - k;\\n        for (auto i : nums) {\\n            while (!ans.empty() && needToRemove > 0 && ans.back() > i) {\\n                ans.pop_back();\\n                needToRemove--;\\n            }\\n            ans.push_back(i);\\n        }\\n        while (needToRemove--) ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\\n\\nIf like solution Upcote it \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        int needToRemove = nums.size() - k;\\n        for (auto i : nums) {\\n            while (!ans.empty() && needToRemove > 0 && ans.back() > i) {\\n                ans.pop_back();\\n                needToRemove--;\\n            }\\n            ans.push_back(i);\\n        }\\n        while (needToRemove--) ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597064,
                "title": "c-o-n-using-stack",
                "content": "\\t//I was trying with recurssion but it gave me TLE. The code is attached Below.\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> res;\\n        stack<int> s;\\n        int n=nums.size();\\n        for(int i=0;i<nums.size();++i){\\n                while(!s.empty() && s.top()>nums[i] && s.size()+(n-i) > k ){\\n                    s.pop();\\n                    res.pop_back();\\n                }\\n            if(s.size()<k){\\n                s.push(nums[i]);\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        return res;\\n    }\\n\\t};\\n\\t\\n//Recurssion but with TLE\\n\\n\\tclass Solution {\\n\\tpublic:\\n    vector<int> res;\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        solve(nums,k,ans,0);\\n        return res;\\n    }\\n    \\n    void solve(vector<int>& nums,int k,vector<int>& ans,int start){\\n        if(ans.size()>k)return;\\n        \\n        if(ans.size()==k)\\n            res=ans;\\n        \\n        int val=INT_MAX;\\n        unordered_map<int,int> m;\\n        for(int i=start;i<nums.size();++i){\\n            if(m.find(nums[i])==m.end()){\\n                m[nums[i]]=1;\\n                  if(nums[i]<val){\\n                    ans.push_back(nums[i]);\\n                    solve(nums,k,ans,i+1);\\n                    val=ans[ans.size()-1];\\n                    ans.pop_back();\\n                  }\\n            }\\n        }\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> res;\\n        stack<int> s;\\n        int n=nums.size();\\n        for(int i=0;i<nums.size();++i){\\n                while(!s.empty() && s.top()>nums[i] && s.size()+(n-i) > k ){\\n                    s.pop();\\n                    res.pop_back();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1238291,
                "title": "one-pass-stack-solution-explanation",
                "content": "**Approach :**\\n Using a monotonic incresing stack we can solve this , whenever our current element is less than top of stack then we have to pop elements but here we have to make sure that if we pop a element from stack and with remaining elemnts in number array we can form a sequence of length k , if not so then we will not pop from stack \\n\\n**Complexity**\\nTime : O(n) \\nSpace : O(k)    at a time  atmost k elements can reside inside stack\\n```\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(NULL);\\n    }\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n    vector<int> st;\\n     int n = nums.size() ; \\n    for(auto i=0 ; i<n ; i++ )\\n    {\\n       while( st.size() != 0  && st.back() > nums[i] && st.size()+(n-i) >k )     \\n           st.pop_back();\\n      \\n        if(st.size()<k)\\n            st.push_back(nums[i]);\\n    \\n    }\\n    return st;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(NULL);\\n    }\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n    vector<int> st;\\n     int n = nums.size() ; \\n    for(auto i=0 ; i<n ; i++ )\\n    {\\n       while( st.size() != 0  && st.back() > nums[i] && st.size()+(n-i) >k )     \\n           st.pop_back();\\n      \\n        if(st.size()<k)\\n            st.push_back(nums[i]);\\n    \\n    }\\n    return st;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220061,
                "title": "easy-to-understand-solution-in-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector <int> st;\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; i++) {\\n            int integersLeft = n - i;\\n            int req = k - st.size();\\n            \\n            int canRemove =  integersLeft - req;\\n            \\n            while(!st.empty() and st.back() > nums[i] and canRemove > 0) {\\n                st.pop_back();\\n                canRemove--;\\n            }\\n            \\n            if(st.size() < k)\\n                st.push_back(nums[i]);\\n\\n        }\\n        \\n        return st;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector <int> st;\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; i++) {\\n            int integersLeft = n - i;\\n            int req = k - st.size();\\n            \\n            int canRemove =  integersLeft - req;\\n            \\n            while(!st.empty() and st.back() > nums[i] and canRemove > 0) {\\n                st.pop_back();\\n                canRemove--;\\n            }\\n            \\n            if(st.size() < k)\\n                st.push_back(nums[i]);\\n\\n        }\\n        \\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028969,
                "title": "most-competitive-subsequence-java",
                "content": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        if (nums == null || nums.length == 0) return new int[]{};\\n        int n = nums.length;\\n        int[] res = new int[k];\\n        int idx = 0;\\n        for (int i = 0; i < n; i++) {\\n            while (idx > 0 && res[idx-1] > nums[i] && (idx+n-i) > k) {\\n                idx--;\\n            }\\n            if (idx < k) res[idx++]= nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        if (nums == null || nums.length == 0) return new int[]{};\\n        int n = nums.length;\\n        int[] res = new int[k];\\n        int idx = 0;\\n        for (int i = 0; i < n; i++) {\\n            while (idx > 0 && res[idx-1] > nums[i] && (idx+n-i) > k) {\\n                idx--;\\n            }\\n            if (idx < k) res[idx++]= nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027537,
                "title": "python-sink-numbers-in-a-stack",
                "content": "The idea is to have a stack of numbers with values consistently increasing. As we process every number it sinks in a stack popping all the number larger than it, making sure to leave enough for sequence of length `k`.\\n```\\ndef mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n\\tN = len(nums)\\n\\tstack = []\\n\\tfor i, n in enumerate(nums):\\n\\t\\tnums_left = N - i\\n\\t\\twhile stack and stack[-1] > n and nums_left > k - len(stack):\\n\\t\\t\\tstack.pop()\\n\\t\\tif len(stack) < k:\\n\\t\\t\\tstack.append(n)\\n\\treturn stack\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ndef mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n\\tN = len(nums)\\n\\tstack = []\\n\\tfor i, n in enumerate(nums):\\n\\t\\tnums_left = N - i\\n\\t\\twhile stack and stack[-1] > n and nums_left > k - len(stack):\\n\\t\\t\\tstack.pop()\\n\\t\\tif len(stack) < k:\\n\\t\\t\\tstack.append(n)\\n\\treturn stack\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 962177,
                "title": "python3-explanation-runtime-and-space-analysis-o-n-time-o-k-space-short",
                "content": "**Explanation**\\nWe use a stack (python list) to store the best subsequence. We loop through `nums` and remove each number from the top of the stack if:\\n\\n1. The current stack is not empty.\\n2. The number on top of the stack is greater than the given number.\\n3. The remaining numbers in the input and the stack together are greater than `k`.\\n\\nReplacing all greater numbers considering the conditions above leads to a new subsequence which might not be of size `k` but could be expanded to this size by using *any* of the remaining input numbers. Such a subsequence will always be *better* as specified in the problem description than the currently best subsequence or a subsequence which could be built with the remaining input numbers if it is not of size `k` already.\\n____________________________\\n**Runtime Complexity**\\n`O(n)` for visiting each input number at maximum twice.\\n___________________________\\n**Space Complexity**\\n`O(k)` for the output list.\\n___________________________\\n**Python Implementation**\\n```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        best_subsequence = []\\n        \\n        \\n        for i in range( len(nums) ):\\n            while ( len(best_subsequence) and best_subsequence[-1] > nums[i] and ( len(nums) - i + len(best_subsequence) ) > k ):\\n                best_subsequence.pop()\\n                \\n                \\n            if ( len(best_subsequence) != k ):\\n                best_subsequence.append( nums[i] )\\n            \\n        return best_subsequence\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        best_subsequence = []\\n        \\n        \\n        for i in range( len(nums) ):\\n            while ( len(best_subsequence) and best_subsequence[-1] > nums[i] and ( len(nums) - i + len(best_subsequence) ) > k ):\\n                best_subsequence.pop()\\n                \\n                \\n            if ( len(best_subsequence) != k ):\\n                best_subsequence.append( nums[i] )\\n            \\n        return best_subsequence\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961863,
                "title": "java-using-stack-with-explanation",
                "content": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        Stack<Integer> st=new Stack<>();\\n        st.push(nums[0]);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(st.isEmpty())\\n            {\\n                st.push(nums[i]);\\n                continue;\\n            }\\n           \\n            //our priroity is to have the smallest element at first place\\n            //but we also have to take care that we need to form a sequence \\n            //of length k\\n            //so we will have a variable remaianing by which we can check \\n            //that if some smaller element comes at what possible place we can take\\n            //as front as possible\\n            //but with taking care that enough elements are availiable after it so that \\n            //we can form the subsequence of given length\\n             int rem=nums.length-i-1;\\n            //checking that if st.size()+remaining>=k then we can remove elemnt from stack\\n            //if something smaller that it occurs\\n            while(st.size()>0 && nums[i]<st.peek() && st.size()+rem>=k)\\n            {\\n                st.pop();\\n            }\\n            //if size is less than k means either space was available or it\\'s created \\n            //by the curr element\\n            //so push element into the stack\\n            if(st.size()<k)\\n            {\\n                st.push(nums[i]);\\n            }\\n        }\\n        int ans[]=new int[k];\\n        int i=k-1;\\n        while(!st.isEmpty())\\n        {\\n            ans[i--]=st.pop();\\n        }\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        Stack<Integer> st=new Stack<>();\\n        st.push(nums[0]);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(st.isEmpty())\\n            {\\n                st.push(nums[i]);\\n                continue;\\n            }\\n           \\n            //our priroity is to have the smallest element at first place\\n            //but we also have to take care that we need to form a sequence \\n            //of length k\\n            //so we will have a variable remaianing by which we can check \\n            //that if some smaller element comes at what possible place we can take\\n            //as front as possible\\n            //but with taking care that enough elements are availiable after it so that \\n            //we can form the subsequence of given length\\n             int rem=nums.length-i-1;\\n            //checking that if st.size()+remaining>=k then we can remove elemnt from stack\\n            //if something smaller that it occurs\\n            while(st.size()>0 && nums[i]<st.peek() && st.size()+rem>=k)\\n            {\\n                st.pop();\\n            }\\n            //if size is less than k means either space was available or it\\'s created \\n            //by the curr element\\n            //so push element into the stack\\n            if(st.size()<k)\\n            {\\n                st.push(nums[i]);\\n            }\\n        }\\n        int ans[]=new int[k];\\n        int i=k-1;\\n        while(!st.isEmpty())\\n        {\\n            ans[i--]=st.pop();\\n        }\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961070,
                "title": "c-stack-solution-explained",
                "content": "We maintain our current most competitive subsequence in a stack, where the top element in the stack is the last element in the subsequence. Iterate through the array from left to right\\n\\n1. If the current `elem` is greater than or equal to the last element in our sequence then we can\\'t really do much to improve the competitiveness, so we have no choice but to add it to our sequence (the stack).\\n\\n2. If the current `elem` is less than `sequence.top()` (i.e. last element in our sequence) then we can improve our sequence by getting rid of some elements. We can continue to remove elements from `sequence` as long as these conditions hold:\\n\\t\\t\\ta. `sequence.top() > elem`: there\\'s not point in removing `sequence.top()` if `sequence.top() < elem` because that would result in a less competitive sequence.\\n\\t\\t\\tb. *There are sufficient elements to build a sequence of size k*: we can\\'t pop more elements off our sequence if the sum of the elements of the sequence and the remaining nums is less than k. This is what the condition `s.size()+(nums.size()-(i+1)) >= k` is for.\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int> sequence;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (sequence.empty() || nums[i] >= sequence.top()) {\\n                sequence.push(nums[i]);\\n            } else {\\n                while (!sequence.empty() && sequence.top()>nums[i] && sequence.size()+(nums.size()-(i+1)) >= k) {\\n                    sequence.pop();\\n                }\\n                sequence.push(nums[i]);\\n            }\\n        }\\n        \\n        while (sequence.size() > k)\\n            sequence.pop();\\n        \\n        vector<int> ans(k);\\n        for (int i = ans.size()-1; i >= 0; --i) {\\n            ans[i] = sequence.top();\\n            sequence.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int> sequence;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (sequence.empty() || nums[i] >= sequence.top()) {\\n                sequence.push(nums[i]);\\n            } else {\\n                while (!sequence.empty() && sequence.top()>nums[i] && sequence.size()+(nums.size()-(i+1)) >= k) {\\n                    sequence.pop();\\n                }\\n                sequence.push(nums[i]);\\n            }\\n        }\\n        \\n        while (sequence.size() > k)\\n            sequence.pop();\\n        \\n        vector<int> ans(k);\\n        for (int i = ans.size()-1; i >= 0; --i) {\\n            ans[i] = sequence.top();\\n            sequence.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953910,
                "title": "python-clear-mono-stack-solution-with-video-explanation",
                "content": "Video with clear visualization and explanation:\\nhttps://youtu.be/F1slBN7wFrI\\n\\nIntuition: Monotonic Increasing Stack\\n\\n**Code**\\nInspired by https://leetcode.com/problems/find-the-most-competitive-subsequence/discuss/952786/JavaC%2B%2BPython-One-Pass-Stack-Solution\\n\\n```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        stack = []\\n        \\n        for i in range(len(nums)):\\n            while stack and nums[i] < stack[-1] and len(stack)-1+len(nums)-i >= k:\\n                stack.pop()\\n            if len(stack) < k:\\n                stack.append(nums[i])\\n                \\n        return stack\\n```\\n\\n\\nTime: O(n)\\nSpace: O(k)\\n\\nFeel free to subscribe to my channel. More LeetCoding videos coming up!\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        stack = []\\n        \\n        for i in range(len(nums)):\\n            while stack and nums[i] < stack[-1] and len(stack)-1+len(nums)-i >= k:\\n                stack.pop()\\n            if len(stack) < k:\\n                stack.append(nums[i])\\n                \\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952928,
                "title": "javascript-stack-224ms",
                "content": "```\\nconst mostCompetitive = (nums, k) => {\\n    let n = nums.length;\\n    let stack = [];\\n    let remove = n - k;\\n    for (const num of nums) {\\n        while (num < stack[stack.length - 1] && remove) {\\n            remove--;\\n            stack.pop();\\n        }\\n        stack.push(num);\\n    }\\n    while (stack.length > k) {\\n        stack.pop();\\n    }\\n    return stack;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst mostCompetitive = (nums, k) => {\\n    let n = nums.length;\\n    let stack = [];\\n    let remove = n - k;\\n    for (const num of nums) {\\n        while (num < stack[stack.length - 1] && remove) {\\n            remove--;\\n            stack.pop();\\n        }\\n        stack.push(num);\\n    }\\n    while (stack.length > k) {\\n        stack.pop();\\n    }\\n    return stack;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952831,
                "title": "easy-o-n-straightforward-c-solution-with-explantion",
                "content": "Idea is simple,\\nSince we need to get minimum element as left as we can, All we need to see is: If current element is smaller than previous, and if so, can we use this current element to make array of length k.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> res;\\n        int n=nums.size();\\n        for(int i=0; i<n; ++i){\\n            if(!res.size()) res.push_back(nums[i]);\\n            else{\\n                int x = res.size();\\n                while(res.size() and res.back()>nums[i])\\n                    if((k-x)<=(n-i-1)){\\n                        res.pop_back();\\n                        x--;\\n                    }\\n                    else break;\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        while(res.size()>k) res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> res;\\n        int n=nums.size();\\n        for(int i=0; i<n; ++i){\\n            if(!res.size()) res.push_back(nums[i]);\\n            else{\\n                int x = res.size();\\n                while(res.size() and res.back()>nums[i])\\n                    if((k-x)<=(n-i-1)){\\n                        res.pop_back();\\n                        x--;\\n                    }\\n                    else break;\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        while(res.size()>k) res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638044,
                "title": "c-o-n",
                "content": "**Approach:-**\\n\\tFor each values of nums[i], (0<=i<n) how many elements u can delete which u have added previously.\\n\\t\\n**Code**\\n```\\nclass Solution\\n{\\n    public:\\n    vector<int> mostCompetitive(vector<int>& nums, int k)\\n    {\\n        int currSize=0;\\n        vector<int> ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int remaining=n-i-1;\\n            while(currSize && ans[currSize-1]>nums[i] && currSize+remaining>=k)\\n            {\\n                ans.pop_back();\\n                currSize--;\\n            }\\n            if(currSize<k)\\n            {\\n                ans.push_back(nums[i]);\\n                currSize++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    vector<int> mostCompetitive(vector<int>& nums, int k)\\n    {\\n        int currSize=0;\\n        vector<int> ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int remaining=n-i-1;\\n            while(currSize && ans[currSize-1]>nums[i] && currSize+remaining>=k)\\n            {\\n                ans.pop_back();\\n                currSize--;\\n            }\\n            if(currSize<k)\\n            {\\n                ans.push_back(nums[i]);\\n                currSize++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545483,
                "title": "c-simple-approach-monotonic-stack",
                "content": "### \\uD83D\\uDD25 Don\\'t Forget to Upvote if you liked the approach. \\uD83D\\uDD25\\n\\n# Intuition\\nThe more you will think about the problem the difficult it will become. That\\'s what I have learnt from this Problem.\\n\\n# Approach\\nApproach is quite simple we just have to find the **Smallest Possible Subsequence** for the given array. \\nI\\'ve created a stack which will store values until it\\'s size becomes ***K*** and also I kept a condition that will pop out the top most value of stack if it is greater than the traversed value.\\nIn the end stored all the values of stack in ***ans*** vector and reversed the vector since stack follows ***LIFO (Last In First Out)***.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n       stack<int> q;\\n\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           while(q.size()!=0&&q.size()+nums.size()-i-1>=k&&nums[i]<q.top())\\n           q.pop();\\n\\n           if(q.size()<k) \\n           q.push(nums[i]);\\n       }\\n\\n       vector<int> ans;\\n\\n       while(q.size()!=0)\\n       {\\n           ans.push_back(q.top());\\n           q.pop();\\n       }\\n\\n       reverse(ans.begin(),ans.end());\\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n       stack<int> q;\\n\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           while(q.size()!=0&&q.size()+nums.size()-i-1>=k&&nums[i]<q.top())\\n           q.pop();\\n\\n           if(q.size()<k) \\n           q.push(nums[i]);\\n       }\\n\\n       vector<int> ans;\\n\\n       while(q.size()!=0)\\n       {\\n           ans.push_back(q.top());\\n           q.pop();\\n       }\\n\\n       reverse(ans.begin(),ans.end());\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249256,
                "title": "python3-monotonic-stack",
                "content": "# Intuition\\nInitially I thought its going to be a LIS problem but optimized LIS requires binary search and this might be an overkill for the problem\\nIn discussion section someone mentioned lexicographically smallest subsequence and I recall this problem [1081](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/). Immideately in my mind popped up `monotonic stack` with a core property to keep increasing/decreasing subsequences in O(N)\\n\\nThe last piece of the puzzle was to come up with the formula `k-len(q) < n-i` to stop popping up elements from a stack when there\\'s left less elements than `k`\\n\\nConsider this test case:\\nAt processing `2` stack will be `[8,80]` it means all elements will be popped-up and only `[2]` is left  if not to prevent it:\\n````\\n[71,18,52,29,55,73,24,42,66,8,80,2]\\n3\\n````\\nExpected answer: `[8,80,2]`\\n\\n# Approach\\nMonotonic queue\\n\\n# Complexity\\nO(N), monotonic queue uses every element only once\\n\\n# Space complexity:\\nO(N) for an answer\\n\\n# Code\\n```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        \\n        n,q = len(nums),[]\\n        for i,num in enumerate(nums):\\n            while q and q[-1] > num and k-len(q) < n-i:\\n                q.pop()\\n            q.append(num)\\n        \\n        while len(q) > k:\\n            q.pop()\\n        \\n        return q\\n```\\n\\nMy current intuition behind monotonic stack is based on solved before problems in the order:\\nhttps://leetcode.com/problems/remove-k-digits/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/sum-of-subarray-ranges/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Monotonic Stack"
                ],
                "code": "````\\n[71,18,52,29,55,73,24,42,66,8,80,2]\\n3\\n```\n```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        \\n        n,q = len(nums),[]\\n        for i,num in enumerate(nums):\\n            while q and q[-1] > num and k-len(q) < n-i:\\n                q.pop()\\n            q.append(num)\\n        \\n        while len(q) > k:\\n            q.pop()\\n        \\n        return q\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720448,
                "title": "c-monotonic-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to pick the smallest K numbers in order that they appear. \\nMonotonic stack is the best DS for such problems.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep pushing into the stack so long as we don\\'t have more than K elements in it and that the stack remains in non-decreasing order.\\nIf we have a value that will keep the stack in non-decreasing order but will add to it the kth + 1 element, then we discard it.\\nIf we see an item that is smaller than the largest value of the stack (at the top of it), we start poping from the stack the values making sure that the size of the stack + the left over items in the array are more than K.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) - each item is inserted at most once to the stack and removed at most onces from the stack.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(K) - the stack size.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> res;\\n\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(res.empty() || (res.size() < k && res.back() <= nums[i])){\\n                res.push_back(nums[i]);\\n            } else {\\n                if(res.size() >= k && res.back() <= nums[i]){\\n                    continue;\\n                }\\n\\n                while(res.empty() == false && res.back() > nums[i] && res.size() + nums.size() - i - 1 >= k){\\n                    res.pop_back();\\n                }\\n\\n                res.push_back(nums[i]);\\n            }\\n        }\\n\\n        return res;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> res;\\n\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(res.empty() || (res.size() < k && res.back() <= nums[i])){\\n                res.push_back(nums[i]);\\n            } else {\\n                if(res.size() >= k && res.back() <= nums[i]){\\n                    continue;\\n                }\\n\\n                while(res.empty() == false && res.back() > nums[i] && res.size() + nums.size() - i - 1 >= k){\\n                    res.pop_back();\\n                }\\n\\n                res.push_back(nums[i]);\\n            }\\n        }\\n\\n        return res;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633555,
                "title": "simplest-fastest-quickest-java-solution-via-stack-all-himself-by-lord-noddy",
                "content": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        Stack<Integer> s=new Stack<>();\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s.isEmpty()  && nums[i] < s.peek() && (n-i)>(k-s.size()))\\n                s.pop();\\n            if(s.size()<k)\\n            s.push(nums[i]);\\n        }\\n        int a[]=new int[k];\\n        for(int i=k-1;i>=0;i--)\\n            a[i]=s.pop();\\n         return a;\\n    }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        Stack<Integer> s=new Stack<>();\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s.isEmpty()  && nums[i] < s.peek() && (n-i)>(k-s.size()))\\n                s.pop();\\n            if(s.size()<k)\\n            s.push(nums[i]);\\n        }\\n        int a[]=new int[k];\\n        for(int i=k-1;i>=0;i--)\\n            a[i]=s.pop();\\n         return a;\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453953,
                "title": "cpp-solution-easy-to-unnderstand-beginner-s-friendly",
                "content": "pLease Upvote the solution-\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int> st;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            while(st.size()>0 && st.top()>nums[i] && n-(i+1)>=k-st.size())\\n                st.pop();\\n            if(st.size()<k)\\n                st.push(nums[i]);\\n        }\\n        vector<int> res(k,0);\\n        int i=k-1;\\n        while(!st.empty()){\\n            res[i]=st.top();\\n        st.pop();\\n            i--;\\n        }\\n        return res;\\n    }\\n};\\n```\\nHappy Coding :-)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int> st;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            while(st.size()>0 && st.top()>nums[i] && n-(i+1)>=k-st.size())\\n                st.pop();\\n            if(st.size()<k)\\n                st.push(nums[i]);\\n        }\\n        vector<int> res(k,0);\\n        int i=k-1;\\n        while(!st.empty()){\\n            res[i]=st.top();\\n        st.pop();\\n            i--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607615,
                "title": "o-n-stack-based-solution",
                "content": "very similar to [removing k digits](https://leetcode.com/problems/remove-k-digits/)\\nThe idea is to just create the minimum number of length k.\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int>st;\\n        int len = nums.size();\\n        int removeLen = abs(len - k);\\n        for(int i=0; i<len; ++i) {\\n            while(!st.empty() && st.top() > nums[i] && removeLen > 0) {\\n                st.pop();\\n                removeLen--;\\n            }\\n            st.push(nums[i]);\\n        }\\n        vector<int>ans;\\n        while(!st.empty()) {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        vector<int>ans2;\\n        for(int i=0; i<k; i++) {\\n            ans2.push_back(ans[i]);\\n        }\\n        return ans2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int>st;\\n        int len = nums.size();\\n        int removeLen = abs(len - k);\\n        for(int i=0; i<len; ++i) {\\n            while(!st.empty() && st.top() > nums[i] && removeLen > 0) {\\n                st.pop();\\n                removeLen--;\\n            }\\n            st.push(nums[i]);\\n        }\\n        vector<int>ans;\\n        while(!st.empty()) {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        vector<int>ans2;\\n        for(int i=0; i<k; i++) {\\n            ans2.push_back(ans[i]);\\n        }\\n        return ans2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391256,
                "title": "easy-python-solution-6-lines-faster-than-90",
                "content": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        stack=[]\\n        for i in range(len(nums)):\\n            while stack and stack[-1]>nums[i] and len(stack)+len(nums)-i-1>=k:\\n                stack.pop()\\n            stack.append(nums[i])\\n        return stack[:k]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        stack=[]\\n        for i in range(len(nums)):\\n            while stack and stack[-1]>nums[i] and len(stack)+len(nums)-i-1>=k:\\n                stack.pop()\\n            stack.append(nums[i])\\n        return stack[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366173,
                "title": "java-stack-greedy-6ms-beats-99-t-c-o-n-s-c-o-k",
                "content": "\\n\\t// Stack\\n\\t// O(n) O(k)\\n\\tpublic int[] mostCompetitive(int[] nums, int k) {\\n\\n\\t\\tint len = nums.length, top = -1;\\n\\t\\tint[] stack = new int[k];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\n\\t\\t\\twhile (top != -1 && nums[i] < stack[top] && top + len - i >= k)\\n\\t\\t\\t\\ttop--;\\n\\n\\t\\t\\tif (top + 1 < k)\\n\\t\\t\\t\\tstack[++top] = nums[i];\\n\\t\\t}\\n\\n\\t\\treturn stack;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\t// Stack\\n\\t// O(n) O(k)\\n\\tpublic int[] mostCompetitive(int[] nums, int k) {\\n\\n\\t\\tint len = nums.length, top = -1;\\n\\t\\tint[] stack = new int[k];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\n\\t\\t\\twhile (top != -1 && nums[i] < stack[top] && top + len - i >= k)\\n\\t\\t\\t\\ttop--;\\n\\n\\t\\t\\tif (top + 1 < k)\\n\\t\\t\\t\\tstack[++top] = nums[i];\\n\\t\\t}\\n\\n\\t\\treturn stack;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1279127,
                "title": "java-easy-stack",
                "content": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] arr, int k) {\\n        Stack<Integer> stack = new Stack<>();\\n      \\n        for(int i = 0;i < arr.length;i++){\\n          \\n          //**remaining elements rem = stacks.size() - k and req = arr.length - i -1;\\n          //** rem >= req\\n          while(stack.size() > 0 && arr[i] < stack.peek() && arr.length - i - 1 >= k - stack.size()){\\n            stack.pop();\\n          }\\n          if(stack.size() < k){\\n            stack.push(arr[i]);\\n          }\\n        }\\n        int res[] = new int[stack.size()];\\n        for(int i = res.length - 1;i >= 0 ;i--){\\n            res[i] = stack.pop();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] arr, int k) {\\n        Stack<Integer> stack = new Stack<>();\\n      \\n        for(int i = 0;i < arr.length;i++){\\n          \\n          //**remaining elements rem = stacks.size() - k and req = arr.length - i -1;\\n          //** rem >= req\\n          while(stack.size() > 0 && arr[i] < stack.peek() && arr.length - i - 1 >= k - stack.size()){\\n            stack.pop();\\n          }\\n          if(stack.size() < k){\\n            stack.push(arr[i]);\\n          }\\n        }\\n        int res[] = new int[stack.size()];\\n        for(int i = res.length - 1;i >= 0 ;i--){\\n            res[i] = stack.pop();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085523,
                "title": "python-very-simple-stack",
                "content": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        st = []\\n        i=0\\n        n = len(nums)\\n        while i < n:\\n            while st and st[-1] > nums[i] and (n+len(st)-i) > k:\\n                st.pop()\\n            if len(st)<k:\\n                st.append(nums[i])\\n            i+=1\\n        return st\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        st = []\\n        i=0\\n        n = len(nums)\\n        while i < n:\\n            while st and st[-1] > nums[i] and (n+len(st)-i) > k:\\n                st.pop()\\n            if len(st)<k:\\n                st.append(nums[i])\\n            i+=1\\n        return st\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028955,
                "title": "python-o-n-with-stack",
                "content": "```\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        allow = len(nums) - k\\n        stack = []\\n        for num in nums:\\n            while stack and allow and stack[-1] > num:\\n                stack.pop()\\n                allow -= 1\\n            \\n            stack.append(num)\\n        return stack[:k]\\n```",
                "solutionTags": [],
                "code": "```\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        allow = len(nums) - k\\n        stack = []\\n        for num in nums:\\n            while stack and allow and stack[-1] > num:\\n                stack.pop()\\n                allow -= 1\\n            \\n            stack.append(num)\\n        return stack[:k]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1028651,
                "title": "o-n-stack-solution",
                "content": "```\\nvar mostCompetitive = function(nums, k) {\\n  let nbToRemove = nums.length - k,stack=[];\\n  for (const num of nums) {\\n    while (num<stack[stack.length -1] && stack.length && nbToRemove) {\\n      stack.pop();\\n      nbToRemove--;\\n    }\\n    stack.push(num)\\n  }\\n  while ( nbToRemove ) {\\n    stack.pop();\\n    nbToRemove--;\\n  }\\n  return stack;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar mostCompetitive = function(nums, k) {\\n  let nbToRemove = nums.length - k,stack=[];\\n  for (const num of nums) {\\n    while (num<stack[stack.length -1] && stack.length && nbToRemove) {\\n      stack.pop();\\n      nbToRemove--;\\n    }\\n    stack.push(num)\\n  }\\n  while ( nbToRemove ) {\\n    stack.pop();\\n    nbToRemove--;\\n  }\\n  return stack;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1028583,
                "title": "c-6-line-deque-solution",
                "content": "Approach 1: Using Double-Ended Queue[1]\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        deque<int> queue;\\n        int additionalCount = nums.size() - k;\\n        for (int i = 0; i < nums.size(); i++) {\\n            while (!queue.empty() && queue.back() > nums[i] && additionalCount-- > 0) queue.pop_back();                \\n            queue.push_back(nums[i]);\\n        }        \\n        return {queue.begin(), queue.begin() + k};        \\n    }\\n};\\n```\\n\\nReference:\\n[1]: tiny modification based on https://leetcode.com/problems/find-the-most-competitive-subsequence/solution/",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        deque<int> queue;\\n        int additionalCount = nums.size() - k;\\n        for (int i = 0; i < nums.size(); i++) {\\n            while (!queue.empty() && queue.back() > nums[i] && additionalCount-- > 0) queue.pop_back();                \\n            queue.push_back(nums[i]);\\n        }        \\n        return {queue.begin(), queue.begin() + k};        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028095,
                "title": "c-7-line-in-place-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, const int& k) {\\n        int i = 0, j = 1, remain = nums.size() - k;\\n        for(; j < nums.size() && remain > 0; ++j) {\\n            for(; i >= 0 && nums[i] > nums[j] && remain > 0; --i, --remain);\\n            nums[++i] = nums[j];\\n        }\\n        if (j < nums.size()) copy(nums.begin() + j, nums.end() - remain, nums.begin() + i + 1);\\n        return vector(nums.begin(), nums.begin() + k);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, const int& k) {\\n        int i = 0, j = 1, remain = nums.size() - k;\\n        for(; j < nums.size() && remain > 0; ++j) {\\n            for(; i >= 0 && nums[i] > nums[j] && remain > 0; --i, --remain);\\n            nums[++i] = nums[j];\\n        }\\n        if (j < nums.size()) copy(nums.begin() + j, nums.end() - remain, nums.begin() + i + 1);\\n        return vector(nums.begin(), nums.begin() + k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027697,
                "title": "java-o-n-solution-using-local-stack",
                "content": "```\\npublic class Solution {\\n\\tpublic int[] mostCompetitive(int[] numbers, int k) {\\n        final int size = numbers.length;\\n        if (size == k) return numbers;\\n        final int[] stack = new int[k];\\n        // si - stack index\\n        for (int i = 0, si = -1, limitToRemove = size - k; i < size; ++i) {\\n            final int number = numbers[i];\\n            while (limitToRemove > 0 && si > -1 && stack[si] > number) {\\n                --si;\\n                --limitToRemove;\\n                final int remainingNumberCount = size - 1 - i;\\n                if (limitToRemove > remainingNumberCount) limitToRemove = remainingNumberCount;\\n            }\\n            if (si + 1 < k) stack[++si] = number;\\n        }\\n        return stack;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\tpublic int[] mostCompetitive(int[] numbers, int k) {\\n        final int size = numbers.length;\\n        if (size == k) return numbers;\\n        final int[] stack = new int[k];\\n        // si - stack index\\n        for (int i = 0, si = -1, limitToRemove = size - k; i < size; ++i) {\\n            final int number = numbers[i];\\n            while (limitToRemove > 0 && si > -1 && stack[si] > number) {\\n                --si;\\n                --limitToRemove;\\n                final int remainingNumberCount = size - 1 - i;\\n                if (limitToRemove > remainingNumberCount) limitToRemove = remainingNumberCount;\\n            }\\n            if (si + 1 < k) stack[++si] = number;\\n        }\\n        return stack;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027688,
                "title": "c-simple-cool-solution-faster-than-99-90-using-stack",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> mostCompetitive(vector<int>& nums, int k) {\\n\\t\\t\\tint end = nums.size() - k;\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tfor (auto num: nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile (end && !ans.empty() && num < ans.back())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans.pop_back();\\n\\t\\t\\t\\t\\t--end;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans.push_back(num);\\n\\t\\t\\t}\\n\\t\\t\\treturn vector<int>(ans.begin(), ans.begin() + k);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> mostCompetitive(vector<int>& nums, int k) {\\n\\t\\t\\tint end = nums.size() - k;\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tfor (auto num: nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile (end && !ans.empty() && num < ans.back())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans.pop_back();\\n\\t\\t\\t\\t\\t--end;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1027584,
                "title": "find-the-most-competitive-subsequence-js-simple-solution-w-explanation-beats-96-99",
                "content": "***Idea:***\\n\\nSince \"competitiveness\" is evaluated from left to right, the most beneficial single move you can make is to remove the first element from left to right whose following value is lower.\\n\\nThe trick here is to do that as many times as you can, while still making sure you have at least K elements left.\\n\\n` `\\n***Implementation:***\\n\\n**Push** values from **N** to the answer stack (**ans**). If the next value (**N[i]**) is better than the top value of **ans**, **pop** numbers off **ans** until it\\'s not. By doing this, **ans** should always be sorted in ascending order.\\n\\nIf at any point the number of elements you can safely remove (**rems**) is reduced to **0**, then combine **ans** with the remaining elements of **N** and **return**.\\n\\nIf you reach the end of **N**, then **return** the first **K** elements of **ans**.\\n\\n` `\\n***Code:***\\n```\\nvar mostCompetitive = function(N, K) {\\n    let len = N.length, ans = [N[0]], curr = 0, rems = len - K\\n    for (let i = 1; i < len;)\\n        if (!rems) return ans.concat(N.slice(i))\\n        else if (N[i] < ans[curr]) ans.pop(), curr--, rems--\\n        else ans.push(N[i]), i++, curr++\\n    return ans.slice(0,K)\\n};\\n\\n```\\n***Bonus:***\\n\\nFor a bonus, here\\'s an even shorter alternate version which modifies **N** in-place. Unfortunately, due to the slow nature of **splice**, it\\'s *hideously* inefficient.\\n\\n```\\nvar mostCompetitive = function(N, K) {\\n    for (let i = 1; i < N.length && N.length > K; i++)\\n        if (N[i] < N[i-1]) N.splice(i-1,1), i -= 2\\n    return N.slice(0,K)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mostCompetitive = function(N, K) {\\n    let len = N.length, ans = [N[0]], curr = 0, rems = len - K\\n    for (let i = 1; i < len;)\\n        if (!rems) return ans.concat(N.slice(i))\\n        else if (N[i] < ans[curr]) ans.pop(), curr--, rems--\\n        else ans.push(N[i]), i++, curr++\\n    return ans.slice(0,K)\\n};\\n\\n```\n```\\nvar mostCompetitive = function(N, K) {\\n    for (let i = 1; i < N.length && N.length > K; i++)\\n        if (N[i] < N[i-1]) N.splice(i-1,1), i -= 2\\n    return N.slice(0,K)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1027570,
                "title": "o-n-time-and-o-n-space-python3-solution-accepted-stack",
                "content": "Actually we want to get smallest increasing subsequence of size k.\\nso for that we have three condition available for every element in the array:\\n1) if stack.top() > nums[i] then its not increasing so we want to remove it out but before removing we have to check the second condition\\n2) if there is enough elements in array so that we could include them in our result in future. If we have then we can remove top element ( it means we are good to proceed the 1st condition).\\n3) after proceeding above two steps we have to check that whether there is any space available in the result(means res.length()< k)  so that we can include the current element.\\n\\nexample:-\\n[2,4,3,3,5,4,9,1] k=4\\ni=0:  stack[2]\\ni=1: stack[2,4]\\ni=2: remove 4 since 4>3(arr[i])  => stack[2,3]\\ni=3: stack[2,3,3]\\ni=4: stack[2,3,3,5]\\ni=5: remove 5 since 5>4(arr[i]) => stack[2,3,3,4]\\ni=6: can\\'t add 9 because stack.length() is k  => stack[2,3,3,4]\\ni=7: remove 4 (since 4 > 1(arr[i]) => stack[2,3,3]          stack.top()=3 and nums[i]=1 here still 3>1 but we can\\'t remove 3 from stack because if we remove 3 then size of stack will become 2 and then we will fail to construct an array of size k(sinse k=4).\\nTherefore we simply add 1 to stack. \\nFINALLY STACK=[2,3,3,1]\\n\\n                          PLEASE UPVOTE IF YOU LIKE!!!\\n\\t\\t\\t              QUERIES ARE ALWAYS WELCOME.\\n\\t\\t\\t\\t            Looking for a good job.\\n```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        i=0\\n        n=len(nums)\\n        res_len=0\\n        stack=[]\\n        while(i<n):\\n            while(stack and (n-i)>k-res_len and stack[-1]>nums[i]):\\n                stack.pop()\\n                res_len-=1\\n            else:\\n                if(res_len<k):\\n                    stack.append(nums[i])\\n                    res_len+=1\\n            i+=1\\n            \\n        return stack  \\n            \\n",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "Actually we want to get smallest increasing subsequence of size k.\\nso for that we have three condition available for every element in the array:\\n1) if stack.top() > nums[i] then its not increasing so we want to remove it out but before removing we have to check the second condition\\n2) if there is enough elements in array so that we could include them in our result in future. If we have then we can remove top element ( it means we are good to proceed the 1st condition).\\n3) after proceeding above two steps we have to check that whether there is any space available in the result(means res.length()< k)  so that we can include the current element.\\n\\nexample:-\\n[2,4,3,3,5,4,9,1] k=4\\ni=0:  stack[2]\\ni=1: stack[2,4]\\ni=2: remove 4 since 4>3(arr[i])  => stack[2,3]\\ni=3: stack[2,3,3]\\ni=4: stack[2,3,3,5]\\ni=5: remove 5 since 5>4(arr[i]) => stack[2,3,3,4]\\ni=6: can\\'t add 9 because stack.length() is k  => stack[2,3,3,4]\\ni=7: remove 4 (since 4 > 1(arr[i]) => stack[2,3,3]          stack.top()=3 and nums[i]=1 here still 3>1 but we can\\'t remove 3 from stack because if we remove 3 then size of stack will become 2 and then we will fail to construct an array of size k(sinse k=4).\\nTherefore we simply add 1 to stack. \\nFINALLY STACK=[2,3,3,1]\\n\\n                          PLEASE UPVOTE IF YOU LIKE!!!\\n\\t\\t\\t              QUERIES ARE ALWAYS WELCOME.\\n\\t\\t\\t\\t            Looking for a good job.\\n```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        i=0\\n        n=len(nums)\\n        res_len=0\\n        stack=[]\\n        while(i<n):\\n            while(stack and (n-i)>k-res_len and stack[-1]>nums[i]):\\n                stack.pop()\\n                res_len-=1\\n            else:\\n                if(res_len<k):\\n                    stack.append(nums[i])\\n                    res_len+=1\\n            i+=1\\n            \\n        return stack  \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 956218,
                "title": "one-pass-easy-simple-solution-beats-100",
                "content": "```\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] res = new int[k];\\n        Deque<Integer> dq = new ArrayDeque<>();\\n\\t\\t\\n        for(int i=0, j=0; i<n; ++i) {\\n            while(!dq.isEmpty() && nums[dq.peekFirst()] > nums[i])\\n                dq.pollFirst();\\n            dq.push(i);\\n            if(i>= n-k) {\\n                res[j++] = nums[dq.pollLast()];\\n            }\\n        }\\n\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] res = new int[k];\\n        Deque<Integer> dq = new ArrayDeque<>();\\n\\t\\t\\n        for(int i=0, j=0; i<n; ++i) {\\n            while(!dq.isEmpty() && nums[dq.peekFirst()] > nums[i])\\n                dq.pollFirst();\\n            dq.push(i);\\n            if(i>= n-k) {\\n                res[j++] = nums[dq.pollLast()];\\n            }\\n        }\\n\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 955536,
                "title": "segment-tree-c-solution",
                "content": "void build(int *tree,vector<int> &arr,int start,int end,int node)\\n    {\\n        if(start==end)\\n            tree[node]=start;\\n        else\\n         {\\n            int mid=(start+end)/2;\\n            build(tree,arr,start,mid,2*node);\\n            build(tree,arr,mid+1,end,2*node+1);\\n            if(arr[ tree[2*node] ]>arr[ tree[2*node+1] ])\\n                tree[node]=tree[2*node+1];\\n            else\\n                tree[node]=tree[2*node];\\n        }\\n    }\\n\\t\\n    int find(int *tree,vector<int> &arr,int start,int end,int first,int last,int node)\\n    {\\n        int mid=(first+last)/2;   \\n        if(start>last or end<first)\\n            return 0;\\n            \\n        if(start<=first and end>=last)\\n            return tree[node];\\n        \\n        int left=find(tree,arr,start,end,first,mid,2*node);\\n        int right=find(tree,arr,start,end,mid+1,last,2*node+1);       \\n        \\n        if(arr[left]>arr[right])\\n            return right;\\n        else\\n            return left;\\n    }\\n\\n    vector<int> mostCompetitive(vector<int>& nums, int k)\\n    {\\n        int n=nums.size();\\n        vector<int> arr;\\n        arr.push_back(INT_MAX);\\n        for(int i=0;i<nums.size();i++)\\n            arr.push_back(nums[i]);\\n        \\n        int tree[2*1000001]={0};\\n        build(tree,arr,1,n,1);\\n        \\n        int start=1;\\n        int end=n;\\n        end-=(k-1);\\n                \\n        vector<int> ans;\\n        while(end<=n)\\n        {                   \\n            int index=find(tree,arr,start,end,1,n,1);\\n            ans.push_back(arr[index]);\\n            \\n            start=index+1;\\n            end++;\\n        }\\n        return ans;\\n    }\\n\\t\\n\\tTime Complexity : O(n) for build tree and K logn for searching kth element.\\nHere , I created the segment tree which store minimum element for different ranges. Let say, if I want the minimum element between L and R then I can able to get the minimum element in logn time using segment tree.\\n\\nFor Ex : [4,7,3,11,5,8,2,6] and k=4\\nthen, I will search minimum k1 element in between index 1 and 5 (inclusive) i.e; 3,\\nHere, end index is 5 because if I check minimum k1 element with end index=8 then I will get minimum element i;e 2 at index 7 then I doesn\\'t have sufficient element to create array of length k for output. Accordingly, I manage the index so that I have sufficient element to make array of k size for output.\\n\\nfor k2 ,Now my start index will be 4 because I found k1 element at index 3.Now,search minimum element between index 4 and 6 i:e 5;\\nfor k3,search min element between index 6 and 7 i;e 2 ,\\nfor k4 ,search min element between index 8 and 8 i;e 6\\n\\nso ,output array will be [3,5,2,6]",
                "solutionTags": [
                    "Tree"
                ],
                "code": "void build(int *tree,vector<int> &arr,int start,int end,int node)\\n    {\\n        if(start==end)\\n            tree[node]=start;\\n        else\\n         {\\n            int mid=(start+end)/2;\\n            build(tree,arr,start,mid,2*node);\\n            build(tree,arr,mid+1,end,2*node+1);\\n            if(arr[ tree[2*node] ]>arr[ tree[2*node+1] ])\\n                tree[node]=tree[2*node+1];\\n            else\\n                tree[node]=tree[2*node];\\n        }\\n    }\\n\\t\\n    int find(int *tree,vector<int> &arr,int start,int end,int first,int last,int node)\\n    {\\n        int mid=(first+last)/2;   \\n        if(start>last or end<first)\\n            return 0;\\n            \\n        if(start<=first and end>=last)\\n            return tree[node];\\n        \\n        int left=find(tree,arr,start,end,first,mid,2*node);\\n        int right=find(tree,arr,start,end,mid+1,last,2*node+1);       \\n        \\n        if(arr[left]>arr[right])\\n            return right;\\n        else\\n            return left;\\n    }\\n\\n    vector<int> mostCompetitive(vector<int>& nums, int k)\\n    {\\n        int n=nums.size();\\n        vector<int> arr;\\n        arr.push_back(INT_MAX);\\n        for(int i=0;i<nums.size();i++)\\n            arr.push_back(nums[i]);\\n        \\n        int tree[2*1000001]={0};\\n        build(tree,arr,1,n,1);\\n        \\n        int start=1;\\n        int end=n;\\n        end-=(k-1);\\n                \\n        vector<int> ans;\\n        while(end<=n)\\n        {                   \\n            int index=find(tree,arr,start,end,1,n,1);\\n            ans.push_back(arr[index]);\\n            \\n            start=index+1;\\n            end++;\\n        }\\n        return ans;\\n    }\\n\\t\\n\\tTime Complexity : O(n) for build tree and K logn for searching kth element.\\nHere , I created the segment tree which store minimum element for different ranges. Let say, if I want the minimum element between L and R then I can able to get the minimum element in logn time using segment tree.\\n\\nFor Ex : [4,7,3,11,5,8,2,6] and k=4\\nthen, I will search minimum k1 element in between index 1 and 5 (inclusive) i.e; 3,\\nHere, end index is 5 because if I check minimum k1 element with end index=8 then I will get minimum element i;e 2 at index 7 then I doesn\\'t have sufficient element to create array of length k for output. Accordingly, I manage the index so that I have sufficient element to make array of k size for output.\\n\\nfor k2 ,Now my start index will be 4 because I found k1 element at index 3.Now,search minimum element between index 4 and 6 i:e 5;\\nfor k3,search min element between index 6 and 7 i;e 2 ,\\nfor k4 ,search min element between index 8 and 8 i;e 6\\n\\nso ,output array will be [3,5,2,6]",
                "codeTag": "Unknown"
            },
            {
                "id": 954095,
                "title": "java-single-pass-array-solution-6ms",
                "content": "```\\npublic int[] mostCompetitive(int[] nums, int k) {\\n        // The brute-force solution is to find the minimum element everytime until we no longer can get k remaining elements.\\n        // The problem with this approach we are iterating the array again and again and we can see that we can somehow do better. The time-complexity of brute-force solution is O(n-k)*O(k) and space is constant.\\n        // So how do we get intution for the optimized solution. By trying to minimize the repetetive work of finding the minimum element k times. \\n\\t\\t// The problem statement helps in this scenario by stating that we need to find a sub-sequence that means order of the elements is necessary. \\n\\t\\t// This gives us an idea of using stack of size k where we keep on pushing the elements in decreasing order, meaning the last element in stack is the smallest. We don\\'t push when the remaining elements in the array are less than the number of elements we need to fill.\\n        // So in the above approach, we iterate once and every element at the max can go once into the stack and gets popped which gives us time-complexity of O(n).\\n        // And just a went step further by using an array instead of stack and keeping track of the index until which we were able to fill the elements. That way we can eliminate use of stack and declare an array of size k which reduces the over-head of stack data-structure.\\n        int[] result = new int[k];\\n        int currIndex = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            while (currIndex >= 0 && nums[i] < result[currIndex] && k-currIndex <= nums.length - i)             {\\n                currIndex--;\\n            }\\n            if (currIndex < k-1) {\\n                result[++currIndex] = nums[i];\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int[] mostCompetitive(int[] nums, int k) {\\n        // The brute-force solution is to find the minimum element everytime until we no longer can get k remaining elements.\\n        // The problem with this approach we are iterating the array again and again and we can see that we can somehow do better. The time-complexity of brute-force solution is O(n-k)*O(k) and space is constant.\\n        // So how do we get intution for the optimized solution. By trying to minimize the repetetive work of finding the minimum element k times. \\n\\t\\t// The problem statement helps in this scenario by stating that we need to find a sub-sequence that means order of the elements is necessary. \\n\\t\\t// This gives us an idea of using stack of size k where we keep on pushing the elements in decreasing order, meaning the last element in stack is the smallest. We don\\'t push when the remaining elements in the array are less than the number of elements we need to fill.\\n        // So in the above approach, we iterate once and every element at the max can go once into the stack and gets popped which gives us time-complexity of O(n).\\n        // And just a went step further by using an array instead of stack and keeping track of the index until which we were able to fill the elements. That way we can eliminate use of stack and declare an array of size k which reduces the over-head of stack data-structure.\\n        int[] result = new int[k];\\n        int currIndex = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            while (currIndex >= 0 && nums[i] < result[currIndex] && k-currIndex <= nums.length - i)             {\\n                currIndex--;\\n            }\\n            if (currIndex < k-1) {\\n                result[++currIndex] = nums[i];\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 953905,
                "title": "c-solution-using-stack-with-clear-explanation",
                "content": "```\\n/*\\n        1. Iterate over the whole array\\n        2. Push the element into the stack is stack size is less than k\\n        3. If the top element in the stack is greater than the current element that we are pushing pop the top element and repeat this until we have ( k - stack.size()  ) elements in the array that are not yet visted.\\n        4. Make a vector array push all stack elements into this vector\\n        5. Reverse and return the vector\\n        \\n*/\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int> s;\\n        for(int i=0; i<nums.size(); i++){\\n            while(!s.empty() && s.top() > nums[i] && (nums.size() - i) > (k - s.size()))\\n                s.pop();\\n            if(s.size() < k)\\n                s.push(nums[i]);\\n        }\\n        vector<int> ans;\\n        for(int i=k-1;i>=0;i--){\\n            ans.push_back(s.top());\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n        1. Iterate over the whole array\\n        2. Push the element into the stack is stack size is less than k\\n        3. If the top element in the stack is greater than the current element that we are pushing pop the top element and repeat this until we have ( k - stack.size()  ) elements in the array that are not yet visted.\\n        4. Make a vector array push all stack elements into this vector\\n        5. Reverse and return the vector\\n        \\n*/\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int> s;\\n        for(int i=0; i<nums.size(); i++){\\n            while(!s.empty() && s.top() > nums[i] && (nums.size() - i) > (k - s.size()))\\n                s.pop();\\n            if(s.size() < k)\\n                s.push(nums[i]);\\n        }\\n        vector<int> ans;\\n        for(int i=k-1;i>=0;i--){\\n            ans.push_back(s.top());\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953862,
                "title": "java-one-pass-monotonic-deque-o-n",
                "content": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        Deque<Integer> queue = new LinkedList();\\n\\t\\t //leaving last k-1 elements  and constructing monotonic deque\\n        for(int i=0; i<nums.length-k + 1; i++){\\n            while(!queue.isEmpty() && queue.peekLast() > nums[i]){\\n                queue.pollLast();\\n            }\\n            queue.offer(nums[i]);\\n        }\\n        int[] ret = new int[k];\\n        ret[0] = queue.poll();\\n        int index = 1;\\n\\t\\t//processing the remaining k-1 elements\\n        for(int i=nums.length-k + 1; i< nums.length; i++){\\n            while(!queue.isEmpty() && queue.peekLast() > nums[i]){\\n                queue.pollLast();\\n            }\\n            queue.offer(nums[i]);\\n            ret[index++] = queue.poll();\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        Deque<Integer> queue = new LinkedList();\\n\\t\\t //leaving last k-1 elements  and constructing monotonic deque\\n        for(int i=0; i<nums.length-k + 1; i++){\\n            while(!queue.isEmpty() && queue.peekLast() > nums[i]){\\n                queue.pollLast();\\n            }\\n            queue.offer(nums[i]);\\n        }\\n        int[] ret = new int[k];\\n        ret[0] = queue.poll();\\n        int index = 1;\\n\\t\\t//processing the remaining k-1 elements\\n        for(int i=nums.length-k + 1; i< nums.length; i++){\\n            while(!queue.isEmpty() && queue.peekLast() > nums[i]){\\n                queue.pollLast();\\n            }\\n            queue.offer(nums[i]);\\n            ret[index++] = queue.poll();\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952915,
                "title": "one-pass-pop-logic",
                "content": "**Steps**\\nWhile going through nums array, at each iteration keep popping from temp until last element of temp is less than current element and push current element to temp array then check if size of temp is equal to \\'k\\', if it is overwrite solution array by temp array. \\nIn the end return solution array. \\n\\n****Edge Case****\\nWhile popping out check if (size of temp+ size of remaining elements )==k. \\nIf it is, just copy remaining elements to temp and return temp. \\n\\n**Time Complexity** \\nO(n)\\n**Space Complexity**\\nO(1)\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> sol;\\n        vector<int> temp;\\n        for(int i=0;i<nums.size();i++){\\n            while(!temp.empty() and temp.back()>nums[i]){\\n                temp.pop_back();\\n                if(temp.size()+nums.size()-i==k){\\n                    while(i<nums.size()){\\n                        temp.push_back(nums[i]);\\n                        i++;\\n                    }\\n                return temp;\\n                }\\n            }\\n            temp.push_back(nums[i]);\\n            if(temp.size()==k)\\n                sol=temp;\\n        }\\n        return sol;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> sol;\\n        vector<int> temp;\\n        for(int i=0;i<nums.size();i++){\\n            while(!temp.empty() and temp.back()>nums[i]){\\n                temp.pop_back();\\n                if(temp.size()+nums.size()-i==k){\\n                    while(i<nums.size()){\\n                        temp.push_back(nums[i]);\\n                        i++;\\n                    }\\n                return temp;\\n                }\\n            }\\n            temp.push_back(nums[i]);\\n            if(temp.size()==k)\\n                sol=temp;\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952825,
                "title": "c-easy-to-understand-with-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> ans(k);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        int K = k;\\n        int x=-1;\\n        \\n        for(int i=0; i<=nums.size()-K; ++i)\\n            pq.push(make_pair(nums[i], i));\\n        \\n        for(int i=0; i<K; ++i) {\\n            while(pq.top().second <= x)\\n                pq.pop();\\n            \\n            ans[i] = nums[pq.top().second];\\n            x = pq.top().second;\\n\\n            --k;\\n            if(k)\\n                pq.push(make_pair(nums[nums.size()-k], nums.size()-k));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> ans(k);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        int K = k;\\n        int x=-1;\\n        \\n        for(int i=0; i<=nums.size()-K; ++i)\\n            pq.push(make_pair(nums[i], i));\\n        \\n        for(int i=0; i<K; ++i) {\\n            while(pq.top().second <= x)\\n                pq.pop();\\n            \\n            ans[i] = nums[pq.top().second];\\n            x = pq.top().second;\\n\\n            --k;\\n            if(k)\\n                pq.push(make_pair(nums[nums.size()-k], nums.size()-k));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952789,
                "title": "java-monotic-stack",
                "content": "Similar question : 1081\\n\\n```\\nclass Solution {\\n    public int[] mostCompetitive(int[] A, int k) {\\n        int n=A.length;\\n        int res[]=new int[k];\\n        Stack<Integer>stack=new Stack<>();\\n        for(int i=0;i<A.length;i++){\\n            while(stack.size()>0&&A[i]<stack.peek()&&stack.size()+(n-(i+1))>=k){\\n                stack.pop();\\n            }\\n            stack.push(A[i]);\\n            \\n        }\\n        \\n        while(stack.size()>k)stack.pop();\\n        for(int i=k-1;i>=0;i--){\\n            res[i]=stack.pop();\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] A, int k) {\\n        int n=A.length;\\n        int res[]=new int[k];\\n        Stack<Integer>stack=new Stack<>();\\n        for(int i=0;i<A.length;i++){\\n            while(stack.size()>0&&A[i]<stack.peek()&&stack.size()+(n-(i+1))>=k){\\n                stack.pop();\\n            }\\n            stack.push(A[i]);\\n            \\n        }\\n        \\n        while(stack.size()>k)stack.pop();\\n        for(int i=k-1;i>=0;i--){\\n            res[i]=stack.pop();\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958766,
                "title": "easy-to-understood-o-o-time-complexity-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe want to sequence of k element so we have n-k number of pop or skip element.using this concept we find sequence \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int>st;\\n        int n=nums.size();\\n        if(n==k)return nums;\\n        int max_pop = n-k;\\n        for(int i=0;i<n;i++){\\n            if(st.empty())st.push(nums[i]);\\n            else{\\n                while(!st.empty() and st.top()>nums[i] and max_pop>0){\\n                    st.pop();\\n                    max_pop--;\\n                }\\n                st.push(nums[i]);\\n            }\\n        }\\n        vector<int>ans;\\n        while(max_pop--)st.pop();\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int>st;\\n        int n=nums.size();\\n        if(n==k)return nums;\\n        int max_pop = n-k;\\n        for(int i=0;i<n;i++){\\n            if(st.empty())st.push(nums[i]);\\n            else{\\n                while(!st.empty() and st.top()>nums[i] and max_pop>0){\\n                    st.pop();\\n                    max_pop--;\\n                }\\n                st.push(nums[i]);\\n            }\\n        }\\n        vector<int>ans;\\n        while(max_pop--)st.pop();\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912839,
                "title": "c-core-logic-simplified-easy-detailed-solution-w-comments",
                "content": "Salut fellow leetcoders!!\\nPlease check the solution code, I\\'ve tried to explain every line of code with necessary explanation using comments!\\nThis is a question of monotonic stack, intuition comes from the fact that the next element coming the answer is directly affected by the previous element and the current size of the proposed answer! and we can access both these info using stack data structure!\\n\\nPlease UPVOTE if this helped you.\\nAny questions or suggestions are welcomed, CHEERS!\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N) , single pass.\\n\\n- Space complexity:\\nO(2K)  as maximum size of stack and answer vector is K.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n\\n        //1 <= k <= nums.length\\n        int n = nums.size();\\n        stack<int>st;\\n\\n        for(int i=0; i<n; i++){ //traversing through the array\\n\\n            while(!st.empty() && nums[i]<st.top() && (k-st.size()) <= (n-1-i)){ //necessary 3 conditions\\n                st.pop();\\n            }\\n            \\n//NOTE : logic behind (k-st.size()) <= (n-1-i) ?\\n        \\n/*A1: In order to put into stack of k elements, we need to make sure those in the stack (stk.size()) +  the elements that not yet to come (n - i) are more than k(required size).\\nONLY Then we can pop out an element from stack but still have assurance to have a k-size sequence in it after complete traversal of nums[] */\\n\\n            if(st.size()<k){\\n                st.push(nums[i]); //only pushing when stack size is less than K\\n            }\\n        }\\n\\n        vector<int>ans; // vector to store final answer\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n\\n        //we have to reverse the ans vector once, as, stack is LIFO data structure!\\n        reverse(ans.begin(), ans.end()); \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n\\n        //1 <= k <= nums.length\\n        int n = nums.size();\\n        stack<int>st;\\n\\n        for(int i=0; i<n; i++){ //traversing through the array\\n\\n            while(!st.empty() && nums[i]<st.top() && (k-st.size()) <= (n-1-i)){ //necessary 3 conditions\\n                st.pop();\\n            }\\n            \\n//NOTE : logic behind (k-st.size()) <= (n-1-i) ?\\n        \\n/*A1: In order to put into stack of k elements, we need to make sure those in the stack (stk.size()) +  the elements that not yet to come (n - i) are more than k(required size).\\nONLY Then we can pop out an element from stack but still have assurance to have a k-size sequence in it after complete traversal of nums[] */\\n\\n            if(st.size()<k){\\n                st.push(nums[i]); //only pushing when stack size is less than K\\n            }\\n        }\\n\\n        vector<int>ans; // vector to store final answer\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n\\n        //we have to reverse the ans vector once, as, stack is LIFO data structure!\\n        reverse(ans.begin(), ans.end()); \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617418,
                "title": "very-simple-c-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int>s;\\n        vector<int>v;\\n        int K=nums.size()-k;\\n        for(int i=0;i<nums.size();i++){\\n            if(s.size()==0){\\n                s.push(nums[i]);\\n            }\\n            else{\\n                while(!s.empty() && nums[i]<s.top() && K){\\n                    s.pop();\\n                    K--;\\n                }\\n                s.push(nums[i]);\\n            }\\n        }\\n        while(K--){\\n            s.pop();\\n        }\\n        while(!s.empty()){\\n           v.push_back(s.top());\\n           s.pop();\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int>s;\\n        vector<int>v;\\n        int K=nums.size()-k;\\n        for(int i=0;i<nums.size();i++){\\n            if(s.size()==0){\\n                s.push(nums[i]);\\n            }\\n            else{\\n                while(!s.empty() && nums[i]<s.top() && K){\\n                    s.pop();\\n                    K--;\\n                }\\n                s.push(nums[i]);\\n            }\\n        }\\n        while(K--){\\n            s.pop();\\n        }\\n        while(!s.empty()){\\n           v.push_back(s.top());\\n           s.pop();\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591323,
                "title": "stack-c-easy-to-understand",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Approach is Simple Just Follow these points:-**\\n\\n1. in each iteration count the number of remaining elements if the remaining elements are less than k, just push the current element into the stack, else remove all the elements those greater than the current element from the stack.\\n2. push the current element into the stack if the stack size is less than k.\\n3. Push back all the elments into a vector and return the reverse of this vector.\\n\\n# Complexity\\n- Time complexity: O(N * K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& arr, int k) {\\n\\n        int n = arr.size();\\n        stack<int> st;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            int left = n-i;\\n\\n            while(st.size()>0 && st.size()+left > k && st.top()>arr[i])\\n            st.pop();\\n\\n            if(st.size()<k)\\n            st.push(arr[i]);\\n        }\\n\\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& arr, int k) {\\n\\n        int n = arr.size();\\n        stack<int> st;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            int left = n-i;\\n\\n            while(st.size()>0 && st.size()+left > k && st.top()>arr[i])\\n            st.pop();\\n\\n            if(st.size()<k)\\n            st.push(arr[i]);\\n        }\\n\\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217889,
                "title": "beginner-friendly-commented-highly-understandable-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        vector<int>ans;\\n        stack<int>st;\\n        int i;\\n        for (i=0;i<n;i++)\\n        {\\n//             we will make sure at the end we wont fall short of elements to form subseq of size k so we pop accordingly \\n            while (!st.empty() && nums[i]<st.top() && st.size()+(n-i)>k)\\n            {\\n                st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        \\n\\n        while (!st.empty())\\n        {\\n            while(st.size()>k)\\n                st.pop();\\n        \\n                ans.push_back(st.top());\\n                st.pop();\\n            \\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n            \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        vector<int>ans;\\n        stack<int>st;\\n        int i;\\n        for (i=0;i<n;i++)\\n        {\\n//             we will make sure at the end we wont fall short of elements to form subseq of size k so we pop accordingly \\n            while (!st.empty() && nums[i]<st.top() && st.size()+(n-i)>k)\\n            {\\n                st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        \\n\\n        while (!st.empty())\\n        {\\n            while(st.size()>k)\\n                st.pop();\\n        \\n                ans.push_back(st.top());\\n                st.pop();\\n            \\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n            \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718607,
                "title": "find-the-most-competitive-subsequence-cpp-solution-easy-to-understand",
                "content": "Basically, we have to keep only k elements from array which should be minimum (most competitive) from any other subsequence of size k. \\n\\n**Approach -**\\n1) We have to remove n-k (let\\'s say **elementsToRemove=n-k**) elements. \\n2) For each element, check if top element of stack is greater or not. If it\\'s greater that curr value, pop that elements from stack and decrease elementsToRemove by 1.\\n3) After that, push curr element to stack.\\n4) Now, get stack values in to a vector called res.\\n5) Now, we have to take first k elements only. \\n6) That would be our appropriate answer. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        int elementsToRemove=n-k;\\n        \\n        stack<int>st; // Stack would contain always non-decreasing values\\n        for(auto i:nums){\\n            // Remove lesser values than current value till elementsToRemove becomes 0\\n            while(st.size()>0 && st.top()>i && elementsToRemove>0){ \\n                st.pop();\\n                elementsToRemove--;\\n            }\\n            st.push(i);\\n        }\\n        \\n        vector<int>res;\\n        while(st.size()>0){\\n            int a=st.top();\\n            st.pop();\\n            res.push_back(a);\\n        }\\n        // Stack would give inverse order, hence we have to reverse res\\n        reverse(res.begin(),res.end()); \\n        \\n        // We would take first k elements only \\n        while(res.size()>k)res.pop_back();\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nI would recommend you to do **[https://leetcode.com/problems/remove-k-digits/](https://leetcode.com/problems/remove-k-digits/)** problem because it is similar to this problem that would brush-up your understanding. \\n\\nThanks for reading !! Comment down for any kind of doubt. \\n",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        int elementsToRemove=n-k;\\n        \\n        stack<int>st; // Stack would contain always non-decreasing values\\n        for(auto i:nums){\\n            // Remove lesser values than current value till elementsToRemove becomes 0\\n            while(st.size()>0 && st.top()>i && elementsToRemove>0){ \\n                st.pop();\\n                elementsToRemove--;\\n            }\\n            st.push(i);\\n        }\\n        \\n        vector<int>res;\\n        while(st.size()>0){\\n            int a=st.top();\\n            st.pop();\\n            res.push_back(a);\\n        }\\n        // Stack would give inverse order, hence we have to reverse res\\n        reverse(res.begin(),res.end()); \\n        \\n        // We would take first k elements only \\n        while(res.size()>k)res.pop_back();\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652542,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        n=len(nums)\\n        a=[nums[0]]\\n        for i in range(1,n):\\n            while a and a[-1]>nums[i] and n-i>k-len(a):\\n                a.pop()\\n            if len(a)<k:\\n                a.append(nums[i])\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        n=len(nums)\\n        a=[nums[0]]\\n        for i in range(1,n):\\n            while a and a[-1]>nums[i] and n-i>k-len(a):\\n                a.pop()\\n            if len(a)<k:\\n                a.append(nums[i])\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418087,
                "title": "easy-java-solution-line-by-line-explained",
                "content": "```\\nThink this problem of like finding the smallest number from the point i.\\nEverey-Step we are at, we are looking for the smallest number wrt to the current number you have.\\nThis way, we can have a sequence of smallest number in the array.\\nAs, we are storing the smallest number untill the point using a stack make our lives easy.\\n\\nLet\\'s head over to the code, i\\'ll explain line by line here.\\n\\n\\n```public int[] mostCompetitive(int[] nums, int k) {\\n    Stack<Integer> stack = new Stack<>();\\n      int No_wecanRemove = nums.length-k;    //this variable is important!!.. length of array - k will give us the number of deletion we can do in our array,  you can run a test case of like \\n\\t                                       // 71, 18,52,29,55,73,24,42,66,8,80,2   with k=3   ---> here, if we don\\'t use the limit of deletion in our array, we would end up with only 2 in the answer, this variable stops us from removing elements from our desired sequence.\\n        \\n        for(int i=0;i<nums.length;i++){                      //we,ll iterate throught the array\\n            while(!stack.isEmpty() && No_wecanRemove > 0 && stack.peek() > nums[i]){    //now, this while is the heart of our solution, it checks for the smallest number from the current position we are in to the end of the array, if we find smaller number, we pop.\\n                stack.pop();   \\n                No_wecanRemove--;     //once we pop, we decrement out ability of remove from the array by 1 each time, as we need to satisfy the length given that is k.\\n            }\\n            stack.push(nums[i]);   //we,ll push either way.\\n        }\\n        \\n        while(stack.size() > k){      //there will be case when we need less deletion as, the smaller numbers are closer to the point we are at, in that case our stack will be over the length k, so can check for the length and resize it.\\n                stack.pop();\\n            }\\n        \\n        int [] ans = new int[stack.size()];          //..now, this is the easy part, just make an ans array and store the stack in it from last to first as we need to return the sequence of the number.\\n        for(int i = ans.length-1; i>=0;i--){\\n            ans[i] = stack.pop();\\n        }\\n        return ans;\\n   }",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nThink this problem of like finding the smallest number from the point i.\\nEverey-Step we are at, we are looking for the smallest number wrt to the current number you have.\\nThis way, we can have a sequence of smallest number in the array.\\nAs, we are storing the smallest number untill the point using a stack make our lives easy.\\n\\nLet\\'s head over to the code, i\\'ll explain line by line here.\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2253250,
                "title": "c-easy-shortest-solution-n-k-approach",
                "content": "Instead of storing k elements in the new array think of it as deleting n-k elements from the given such that it can still be with highest priority possible...Thats is initial values should be increasing.\\n```\\n    vector<int> mostCompetitive(vector<int>& A, int k) {\\n        int n=A.size();\\n        k=n-k;\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(ans.size() and ans.back()>A[i] and k>0)  //We have the power to pop until k>0 \\n                ans.pop_back(),k--;\\n            ans.push_back(A[i]);\\n        }\\n        while(k>0 and ans.size())  //If some elements were not able to pop by the loop\\n            ans.pop_back(),k--;\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n    vector<int> mostCompetitive(vector<int>& A, int k) {\\n        int n=A.size();\\n        k=n-k;\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(ans.size() and ans.back()>A[i] and k>0)  //We have the power to pop until k>0 \\n                ans.pop_back(),k--;\\n            ans.push_back(A[i]);\\n        }\\n        while(k>0 and ans.size())  //If some elements were not able to pop by the loop\\n            ans.pop_back(),k--;\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176615,
                "title": "java-fast-stack-solution",
                "content": "```\\nclass Solution {\\n    \\n    public int[] stackToArr(Stack<Integer> stack) {\\n        int[] res = new int[stack.size()];\\n        for (int i = res.length -1; i >= 0; i--) {\\n            res[i] = stack.pop();\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int[] mostCompetitive(int[] nums, int k) {\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        // The key is this condition: (nums.length - i + stack.size() > k)\\n        // Essentially, we want to make sure that we should only pop the amount of elements in the stack where we have enough to fill out at least k elements afterwards\\n        for (int i = 0; i < nums.length; i++) {\\n            while (stack.size() > 0 && nums[i] < stack.peek() && nums.length - i + stack.size() > k) {\\n                stack.pop();\\n            }\\n            \\n            if (stack.size() < k) {\\n                stack.add(nums[i]);\\n            }\\n        }\\n        \\n        return stackToArr(stack);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int[] stackToArr(Stack<Integer> stack) {\\n        int[] res = new int[stack.size()];\\n        for (int i = res.length -1; i >= 0; i--) {\\n            res[i] = stack.pop();\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int[] mostCompetitive(int[] nums, int k) {\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        // The key is this condition: (nums.length - i + stack.size() > k)\\n        // Essentially, we want to make sure that we should only pop the amount of elements in the stack where we have enough to fill out at least k elements afterwards\\n        for (int i = 0; i < nums.length; i++) {\\n            while (stack.size() > 0 && nums[i] < stack.peek() && nums.length - i + stack.size() > k) {\\n                stack.pop();\\n            }\\n            \\n            if (stack.size() < k) {\\n                stack.add(nums[i]);\\n            }\\n        }\\n        \\n        return stackToArr(stack);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170028,
                "title": "c-monotonic-stack-time-o-n",
                "content": "**We maintain increasing subsequence in a stack of size k.**\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int> st;\\n        int n=nums.size();\\n        int stackSize=1;\\n        st.push(nums[0]);\\n        for(int i=1;i<n;i++){\\n            int left=n-i;\\n            while(!st.empty() and st.top()>nums[i] and k-stackSize<left){\\n                st.pop();\\n                stackSize--;\\n            }\\n            \\n            if(stackSize<k){\\n                st.push(nums[i]);\\n                stackSize++;\\n            }\\n            \\n        }\\n        \\n        vector<int> res;\\n        while(!st.empty()){\\n            res.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int> st;\\n        int n=nums.size();\\n        int stackSize=1;\\n        st.push(nums[0]);\\n        for(int i=1;i<n;i++){\\n            int left=n-i;\\n            while(!st.empty() and st.top()>nums[i] and k-stackSize<left){\\n                st.pop();\\n                stackSize--;\\n            }\\n            \\n            if(stackSize<k){\\n                st.push(nums[i]);\\n                stackSize++;\\n            }\\n            \\n        }\\n        \\n        vector<int> res;\\n        while(!st.empty()){\\n            res.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148884,
                "title": "javascript-solution-monotonic-stack",
                "content": "**// the idea is to solve the problem using monotonic incresing order\\n// if we found item is smallest than prev one we pop prev item from stack\\n// but we need to ensure each time when pop item about the \\n// remaining item in arr (keep store k items in stack)**\\n```\\nvar mostCompetitive = function(nums, k) {\\n    const stack = [];\\n    const n = nums.length;\\n    for(let i = 0; i < n; i++){\\n        while(stack.length > 0 && stack.length + n - (i + 1) >= k &&stack[stack.length - 1] > nums[i]){\\n            stack.pop();\\n        }\\n        stack.push(nums[i]);\\n    }\\n    while(stack.length > k){\\n            stack.pop();\\n    }\\n    return stack;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar mostCompetitive = function(nums, k) {\\n    const stack = [];\\n    const n = nums.length;\\n    for(let i = 0; i < n; i++){\\n        while(stack.length > 0 && stack.length + n - (i + 1) >= k &&stack[stack.length - 1] > nums[i]){\\n            stack.pop();\\n        }\\n        stack.push(nums[i]);\\n    }\\n    while(stack.length > k){\\n            stack.pop();\\n    }\\n    return stack;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2090971,
                "title": "python-simple-stack-solution",
                "content": "\\n    def mostCompetitive(self, nums, k):\\n        remove_num_elements = len(nums) - k\\n        \\n        stack = []\\n        \\n        for index, num in enumerate(nums):\\n            while stack and remove_num_elements and nums[stack[-1]] > nums[index]:\\n                stack.pop()\\n                remove_num_elements -= 1\\n                \\n            stack.append(index)\\n        \\n        return [nums[i] for i in stack][:k]",
                "solutionTags": [],
                "code": "\\n    def mostCompetitive(self, nums, k):\\n        remove_num_elements = len(nums) - k\\n        \\n        stack = []\\n        \\n        for index, num in enumerate(nums):\\n            while stack and remove_num_elements and nums[stack[-1]] > nums[index]:\\n                stack.pop()\\n                remove_num_elements -= 1\\n                \\n            stack.append(index)\\n        \\n        return [nums[i] for i in stack][:k]",
                "codeTag": "Python3"
            },
            {
                "id": 2049977,
                "title": "simple-c-code-o-n",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        //return{2,4,1};\\n        int invalid = n-k;\\n        deque<int> dq;\\n        int right = 0;\\n        while(right < n)\\n        {\\n            if(!dq.empty() && dq.back() > nums[right] && invalid>0)\\n            {\\n                dq.pop_back();\\n                invalid--;\\n            }\\n            else\\n            {\\n                dq.push_back(nums[right]);\\n                right++;\\n            }\\n        }\\n        for(int i = 0; i < invalid; i++)\\n        {\\n            dq.pop_back();\\n        }\\n        vector<int> ans;\\n        while(!dq.empty())\\n        {\\n            ans.push_back(dq.front());\\n            dq.pop_front();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        //return{2,4,1};\\n        int invalid = n-k;\\n        deque<int> dq;\\n        int right = 0;\\n        while(right < n)\\n        {\\n            if(!dq.empty() && dq.back() > nums[right] && invalid>0)\\n            {\\n                dq.pop_back();\\n                invalid--;\\n            }\\n            else\\n            {\\n                dq.push_back(nums[right]);\\n                right++;\\n            }\\n        }\\n        for(int i = 0; i < invalid; i++)\\n        {\\n            dq.pop_back();\\n        }\\n        vector<int> ans;\\n        while(!dq.empty())\\n        {\\n            ans.push_back(dq.front());\\n            dq.pop_front();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021354,
                "title": "easy-and-faster-java-solution-in-7-line",
                "content": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int[] stack = new int[k];\\n        for(int i=0,j=0;i<nums.length;i++) {\\n          while(j>0 && stack[j-1]>nums[i] && j+nums.length-i>k) {\\n              j--;\\n          }\\n          if(j<k) {\\n              stack[j++]=nums[i];\\n          }\\n        }\\n        return stack;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int[] stack = new int[k];\\n        for(int i=0,j=0;i<nums.length;i++) {\\n          while(j>0 && stack[j-1]>nums[i] && j+nums.length-i>k) {\\n              j--;\\n          }\\n          if(j<k) {\\n              stack[j++]=nums[i];\\n          }\\n        }\\n        return stack;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011581,
                "title": "java-straight-forward-monotonic-stack",
                "content": "```java\\nimport java.util.*;\\n\\nclass Solution {\\n  public int[] mostCompetitive(int[] nums, int k) {\\n    // Mono non-dec stack\\n    Stack<Integer> stack = new Stack<>();\\n    int n = nums.length;\\n    int[] ret = new int[k];\\n    for (int i = 0; i < n; i++) {\\n      /**\\n       * Question is, if the peek element of the stack is larger than nums[i], should we pop it?\\n       * stack.size - 1: the size of the stack after poping\\n       * n - i: the number of left elements in the array: [i: n - 1]\\n       * If after poping, the combined size of the stack and the elements left in the array is no less than k, \\n       * then we should pop it because a more competitive subseq of size k can be constructed\\n       */\\n      while (!stack.isEmpty() && stack.size() - 1 + n - i >= k && stack.peek() > nums[i]) {\\n        stack.pop();\\n      }\\n      stack.push(nums[i]);\\n      // This certainly can be optimized but I\\'m too lazy rn\\n      if (stack.size() == k) {\\n        ret = copy(stack);\\n      }\\n    }\\n    return ret;\\n  }\\n\\n  int[] copy(Stack<Integer> stack) {\\n    int[] ret = new int[stack.size()];\\n    for (int i = 0; i < stack.size(); i++) {\\n      ret[i] = stack.get(i);\\n    }\\n    return ret;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```java\\nimport java.util.*;\\n\\nclass Solution {\\n  public int[] mostCompetitive(int[] nums, int k) {\\n    // Mono non-dec stack\\n    Stack<Integer> stack = new Stack<>();\\n    int n = nums.length;\\n    int[] ret = new int[k];\\n    for (int i = 0; i < n; i++) {\\n      /**\\n       * Question is, if the peek element of the stack is larger than nums[i], should we pop it?\\n       * stack.size - 1: the size of the stack after poping\\n       * n - i: the number of left elements in the array: [i: n - 1]\\n       * If after poping, the combined size of the stack and the elements left in the array is no less than k, \\n       * then we should pop it because a more competitive subseq of size k can be constructed\\n       */\\n      while (!stack.isEmpty() && stack.size() - 1 + n - i >= k && stack.peek() > nums[i]) {\\n        stack.pop();\\n      }\\n      stack.push(nums[i]);\\n      // This certainly can be optimized but I\\'m too lazy rn\\n      if (stack.size() == k) {\\n        ret = copy(stack);\\n      }\\n    }\\n    return ret;\\n  }\\n\\n  int[] copy(Stack<Integer> stack) {\\n    int[] ret = new int[stack.size()];\\n    for (int i = 0; i < stack.size(); i++) {\\n      ret[i] = stack.get(i);\\n    }\\n    return ret;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917771,
                "title": "python-6-line-succinct-solution-based-on-monotonic-stack-strategy-for-your-quick-comprehension",
                "content": "\\'len(S) + n-i >k\\': means that the sum of current depth of stack and left elements (ready for comparing)  should be bigger than k. (if the sum was <= k, there would be no enouogh elements left for constructing the solution. The solution needs k elements).\\n```\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        S,n=[],len(nums)\\n        for i,e in enumerate(nums):\\n            while S and S[-1]>e and len(S)+n-i>k:\\n                S.pop()\\n            S.append(e)\\n        return S[:k]\\n```",
                "solutionTags": [],
                "code": "```\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        S,n=[],len(nums)\\n        for i,e in enumerate(nums):\\n            while S and S[-1]>e and len(S)+n-i>k:\\n                S.pop()\\n            S.append(e)\\n        return S[:k]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1860217,
                "title": "c-solution-faster-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int i=0, n=nums.size();\\n        vector<int> res;\\n        while(i<n) {\\n                while(!res.empty() && res.back()>nums[i] && n-i-1>=k-res.size()) \\n                    res.pop_back();\\n            if(res.size()<k)\\n            res.push_back(nums[i]);\\n            i++;\\n        }\\n     return res;\\n    }\\n};\\n/*\\nif(find helpful) {\\n do upvote(); // thanks\\n }\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int i=0, n=nums.size();\\n        vector<int> res;\\n        while(i<n) {\\n                while(!res.empty() && res.back()>nums[i] && n-i-1>=k-res.size()) \\n                    res.pop_back();\\n            if(res.size()<k)\\n            res.push_back(nums[i]);\\n            i++;\\n        }\\n     return res;\\n    }\\n};\\n/*\\nif(find helpful) {\\n do upvote(); // thanks\\n }\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1762031,
                "title": "python-8-line-burn-my-brain",
                "content": "This is crazy, spent 1 hour thinking, and looked up the 8 line solution. Trying to document thought process to go from recurison to stack.\\n\\n```\\n\"\"\"\\nRecursive solution:\\n    if k=1, then return the array containing the minimum of nums\\n    \\n    else:\\n        return [min(arr[0:len(arr)-(k-1)])]+most_competetive (k-1) subsequence at j:len(nums)\\n        where j is the first occurrence of the minimum.\\n    \\n O(kn) time complexity.\\n\\noptimization: pre-compute the minimums in an array mins[i] = minimum of subarray nums[i:len(nums-k)]\\n\\nObservation (towards monotone stack): if nums contains an increasing subsequence of size k such that the starting point is the minimum, then directly using a monotone stack and slicing the stack to the first k elements will work.\\n\\nModification: while forming the stack, keep track of how many elements we can remove (len(nums)-k). Each time remove one, decrement the number of elements we can remove.\\n\\nloop over num in nums:\\n    while stack nonempty and we can still remove and num smaller than end of stack:\\n        pop from stack\\n        decrement to_remove\\n    \\n    # then either stack empty, or we can\\'t remove, or num >= end of stack:\\n        add number to stack\\n    \\n    return stack[:k]\\n    \\nWhy does this work? Think of this as the problem: delete m = n - k characters  to make lexicographically smallest. Look at the array as a graph, and delete the first peak node. Then repeat.\\n\\nk = 3\\n[4,2,3,1,9]\\n[4]\\n[2]\\n[2,3]\\n[2,1]\\n[2,1,9]\\n\"\"\"\\n\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        \\n        to_remove = len(nums) - k\\n        stack = []\\n        \\n        for num in nums:\\n            \\n            while stack and to_remove and num < stack[-1]:\\n                stack.pop()\\n                to_remove -= 1\\n            \\n            stack.append(num)\\n        \\n        return stack[:k]\\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nRecursive solution:\\n    if k=1, then return the array containing the minimum of nums\\n    \\n    else:\\n        return [min(arr[0:len(arr)-(k-1)])]+most_competetive (k-1) subsequence at j:len(nums)\\n        where j is the first occurrence of the minimum.\\n    \\n O(kn) time complexity.\\n\\noptimization: pre-compute the minimums in an array mins[i] = minimum of subarray nums[i:len(nums-k)]\\n\\nObservation (towards monotone stack): if nums contains an increasing subsequence of size k such that the starting point is the minimum, then directly using a monotone stack and slicing the stack to the first k elements will work.\\n\\nModification: while forming the stack, keep track of how many elements we can remove (len(nums)-k). Each time remove one, decrement the number of elements we can remove.\\n\\nloop over num in nums:\\n    while stack nonempty and we can still remove and num smaller than end of stack:\\n        pop from stack\\n        decrement to_remove\\n    \\n    # then either stack empty, or we can\\'t remove, or num >= end of stack:\\n        add number to stack\\n    \\n    return stack[:k]\\n    \\nWhy does this work? Think of this as the problem: delete m = n - k characters  to make lexicographically smallest. Look at the array as a graph, and delete the first peak node. Then repeat.\\n\\nk = 3\\n[4,2,3,1,9]\\n[4]\\n[2]\\n[2,3]\\n[2,1]\\n[2,1,9]\\n\"\"\"\\n\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        \\n        to_remove = len(nums) - k\\n        stack = []\\n        \\n        for num in nums:\\n            \\n            while stack and to_remove and num < stack[-1]:\\n                stack.pop()\\n                to_remove -= 1\\n            \\n            stack.append(num)\\n        \\n        return stack[:k]\\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745158,
                "title": "c-easy-stack-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> mostCompetitive(vector<int>& nums, int k) {\\n\\t\\t\\tif(nums.size()==k) return nums;\\n\\t\\t\\tif(k==1) return {*min_element(nums.begin(),nums.end())};\\n\\t\\t\\t  stack<int> st;\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t  //while taking out element out make sure that you have enough element in vector to make size k\\n\\t\\t\\t\\twhile(!st.empty() && st.top()>nums[i] && (n-i+st.size())>k){   \\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.push(nums[i]);\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<int> v;\\n\\t\\t\\twhile(!st.empty()){\\n\\t\\t\\t\\tv.push_back(st.top());\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t}   \\n\\t\\t\\treverse(v.begin(),v.end());\\n\\t\\t\\tv.resize(k);\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> mostCompetitive(vector<int>& nums, int k) {\\n\\t\\t\\tif(nums.size()==k) return nums;\\n\\t\\t\\tif(k==1) return {*min_element(nums.begin(),nums.end())}",
                "codeTag": "Java"
            },
            {
                "id": 1699376,
                "title": "this-question-proofs-that-practice-makes-man-perfect-c-solution",
                "content": "\\nclass Solution {\\npublic:\\n\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(n == k)return nums;\\n        stack<int>st;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            while(!st.empty() and st.top() > nums[i] and (n - i + st.size()) > k){\\n                st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        vector<int>v;\\n        while(!st.empty()){\\n            v.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(v.begin() , v.end());\\n        vector<int>ans;\\n        for(int i=0 ; i<k ; i++){\\n            ans.push_back(v[i]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(n == k)return nums;\\n        stack<int>st;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            while(!st.empty() and st.top() > nums[i] and (n - i + st.size()) > k){\\n                st.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1689737,
                "title": "c-stack-solution",
                "content": "My approach for this question was based on the question [402. Remove K Digits](hthttps://leetcode.com/problems/remove-k-digits/tp://).\\nIn #402, we need to remove any k characters from a number in decimal representation to make it the lexicographically smallest among all such numbers after k deletions.\\nIn the current question we were required to make a subsequence of size k that is the lexicographically smallest. In other words, we can only make a subsequence of size k from an array of length n, after (n-k) deletions. \\nHence we iterate through the given array in O(n) time and only perform (n-k) operations to make the elements in a stack monotonically increasing as much as possible. Finally we pop out the top elements from the stack till its size reaches k. The remaining elements in the stack is the required answer deemed to be the lexicographically smallest array of k  size subsequences of the array.\\n\\n```\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n = nums.size(), op = n-k;\\n        stack<int> st;\\n        for (int i = 0; i<n; i++){\\n            while(st.size() and st.top() > nums[i]){\\n                if (op == 0)    break;\\n                st.pop();\\n                op--;\\n            }\\n                \\n            st.push(nums[i]);\\n        }\\n        while(st.size() > k)    st.pop();\\n        vector<int> ans;\\n        while(st.size()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n```\\n \\nor we can only use a vector to work as the stack, to prevent multiple iterations.\\n\\n```\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n = nums.size(), op = n-k;\\n        vector<int> ans;\\n        for (int i = 0; i<n; i++){\\n            while(ans.size() and ans.back() > nums[i]){\\n                if (op == 0)    break;\\n                ans.pop_back();\\n                op--;\\n            }\\n                \\n            ans.push_back(nums[i]);\\n        }\\n        while(ans.size() > k)    ans.pop_back();\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n = nums.size(), op = n-k;\\n        stack<int> st;\\n        for (int i = 0; i<n; i++){\\n            while(st.size() and st.top() > nums[i]){\\n                if (op == 0)    break;\\n                st.pop();\\n                op--;\\n            }\\n                \\n            st.push(nums[i]);\\n        }\\n        while(st.size() > k)    st.pop();\\n        vector<int> ans;\\n        while(st.size()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n```\n```\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n = nums.size(), op = n-k;\\n        vector<int> ans;\\n        for (int i = 0; i<n; i++){\\n            while(ans.size() and ans.back() > nums[i]){\\n                if (op == 0)    break;\\n                ans.pop_back();\\n                op--;\\n            }\\n                \\n            ans.push_back(nums[i]);\\n        }\\n        while(ans.size() > k)    ans.pop_back();\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1631978,
                "title": "c-simple-stack",
                "content": "The only trick thing to find out is that when we encounter a smaller element than the top of the stack we can only pop it until there are enough elements left to get the subsequence of size k and the part in the code \\n```\\nwhile(!S.empty() and S.size() + (n - i) > k and S.top() > A[i])\\n            {\\n                S.pop();\\n            } \\n```\\nThe complete code is below: \\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>&A, int k) {\\n        int n = A.size();\\n        stack<int>S;\\n        vector<int>res;\\n        for(int i = 0; i < n; i++)\\n        {\\n            while(!S.empty() and S.size() + (n - i) > k and S.top() > A[i])\\n            {\\n                S.pop();\\n            }\\n            if(S.size() < k)\\n                S.push(A[i]);\\n        }\\n        while(!S.empty())\\n        {\\n            res.push_back(S.top());\\n            S.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nwhile(!S.empty() and S.size() + (n - i) > k and S.top() > A[i])\\n            {\\n                S.pop();\\n            } \\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>&A, int k) {\\n        int n = A.size();\\n        stack<int>S;\\n        vector<int>res;\\n        for(int i = 0; i < n; i++)\\n        {\\n            while(!S.empty() and S.size() + (n - i) > k and S.top() > A[i])\\n            {\\n                S.pop();\\n            }\\n            if(S.size() < k)\\n                S.push(A[i]);\\n        }\\n        while(!S.empty())\\n        {\\n            res.push_back(S.top());\\n            S.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532714,
                "title": "easy-c-o-n-with-detailed-explanation",
                "content": "**Thoughts Flow**\\n\\nAt first I see this as a knapsack problem because we need to find some maximal stuff out of a vector with some size limit, and I try dp. **The problem is the dp method can only tell us the sum of the members in the most competitive sequence but not what the sequence is.** We need a new method.\\n\\n**The key of this problem is to find the subsequence of length k with each number as smallest as possible at each position.** We can use a stack to find a subsequence with the smallest number we can use at each position. \\n\\n**Complexity**\\nTime: O(n)\\nSpace: O(n)\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        deque<int> d;\\n        d.push_back(nums[0]);\\n        for(int i = 1; i < nums.size(); ++i){\\n            while(!d.empty() && nums[i] < d.back() && d.size()+nums.size()-1-i>=k){\\n                d.pop_back();\\n            }\\n            d.push_back(nums[i]);\\n        }\\n        vector<int> ans;\\n        for(int i = 0; i < k; ++i){\\n            ans.push_back(d[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        deque<int> d;\\n        d.push_back(nums[0]);\\n        for(int i = 1; i < nums.size(); ++i){\\n            while(!d.empty() && nums[i] < d.back() && d.size()+nums.size()-1-i>=k){\\n                d.pop_back();\\n            }\\n            d.push_back(nums[i]);\\n        }\\n        vector<int> ans;\\n        for(int i = 0; i < k; ++i){\\n            ans.push_back(d[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501196,
                "title": "easy-java-code-60-faster-using-stack",
                "content": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] a, int k) {\\n        int ans[]=new int[k];\\n        int i=0,n=a.length;\\n        int p=n-k;\\n        Stack<Integer> st=new Stack<>();\\n        while(i<n){\\n            while(p>0 && !st.isEmpty() && st.peek()>a[i]){\\n                st.pop();\\n                p--;\\n            }\\n            st.push(a[i]);\\n            i++;\\n        }\\n        while(st.size()>k) st.pop();\\n        i=0;\\n        while(!st.isEmpty()) ans[i++]=st.pop();\\n        int j=k-1;\\n        i=0;\\n        \\n        while(i<j){\\n            int c=ans[i];\\n            ans[i]=ans[j];\\n            ans[j]=c;\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] a, int k) {\\n        int ans[]=new int[k];\\n        int i=0,n=a.length;\\n        int p=n-k;\\n        Stack<Integer> st=new Stack<>();\\n        while(i<n){\\n            while(p>0 && !st.isEmpty() && st.peek()>a[i]){\\n                st.pop();\\n                p--;\\n            }\\n            st.push(a[i]);\\n            i++;\\n        }\\n        while(st.size()>k) st.pop();\\n        i=0;\\n        while(!st.isEmpty()) ans[i++]=st.pop();\\n        int j=k-1;\\n        i=0;\\n        \\n        while(i<j){\\n            int c=ans[i];\\n            ans[i]=ans[j];\\n            ans[j]=c;\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444472,
                "title": "solution-by-average-coder-not-short-but-easy-to-understand",
                "content": "-->just keep adding elements into stack,the moment the number less than top element appears nums[i]<s.top() ,check if there are enough elements to get a total of k elements including the stack elements,if yes then keep popping and add the element and continue, and if nums[i] where s.top()>nums[i] and size less than k then also we need to add to get k elements right!\\n\\n:)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        stack<int>s;\\n        int val=0;\\n        for(int i=0;i<n;i++){\\n            if(s.empty())\\n                s.push(nums[i]);\\n            else if(s.size()<=k && k-s.size()<n-i && s.top()>nums[i]){\\n                while(!s.empty() && k-s.size()<n-i && s.top()>nums[i]){\\n                    s.pop();\\n                }\\n                s.push(nums[i]);\\n            }\\n            else if(s.size()<k)\\n                s.push(nums[i]);\\n        }\\n        \\n        vector<int>v;\\n        while(!s.empty()){\\n            v.push_back(s.top());\\n            s.pop();\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        stack<int>s;\\n        int val=0;\\n        for(int i=0;i<n;i++){\\n            if(s.empty())\\n                s.push(nums[i]);\\n            else if(s.size()<=k && k-s.size()<n-i && s.top()>nums[i]){\\n                while(!s.empty() && k-s.size()<n-i && s.top()>nums[i]){\\n                    s.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1311651,
                "title": "simple-c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int i;\\n        stack<int> s;\\n        \\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(s.size()==0)\\n                s.push(nums[i]);\\n            \\n            else if(s.size()>0)\\n            {\\n                if(nums[i]>=s.top() && s.size()<k)\\n                    s.push(nums[i]);\\n                \\n                else if(nums[i]<s.top())\\n                {\\n                    while(s.size()>0 && nums[i]<s.top() && ((s.size()-1)+(nums.size()-i))>=k)\\n                        s.pop();\\n                    s.push(nums[i]);\\n                }\\n                \\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        while(s.size()>0)\\n        {\\n            ans.push_back(s.top());\\n            s.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int i;\\n        stack<int> s;\\n        \\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(s.size()==0)\\n                s.push(nums[i]);\\n            \\n            else if(s.size()>0)\\n            {\\n                if(nums[i]>=s.top() && s.size()<k)\\n                    s.push(nums[i]);\\n                \\n                else if(nums[i]<s.top())\\n                {\\n                    while(s.size()>0 && nums[i]<s.top() && ((s.size()-1)+(nums.size()-i))>=k)\\n                        s.pop();\\n                    s.push(nums[i]);\\n                }\\n                \\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        while(s.size()>0)\\n        {\\n            ans.push_back(s.top());\\n            s.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066879,
                "title": "java-clean-concise-code-o-n-time-100-beats-faster-solution",
                "content": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        \\n        int[] ans = new int[k];\\n        int index = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            while (index != 0 && ans[index - 1] > nums[i] && nums.length - i > k - index) {\\n                --index;\\n            }\\n            \\n            if (index < k) {\\n                ans[index++] = nums[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        \\n        int[] ans = new int[k];\\n        int index = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            while (index != 0 && ans[index - 1] > nums[i] && nums.length - i > k - index) {\\n                --index;\\n            }\\n            \\n            if (index < k) {\\n                ans[index++] = nums[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055262,
                "title": "c-one-pass-stack-solution-o-n-time",
                "content": "keep an increasing stack and check if there are still enough elemetst left when we want to pop a value from stack\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> sk;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            while (sk.size() && nums[i] < sk.back() && k-sk.size() <= nums.size()-i-1) {\\n                sk.pop_back();\\n            }\\n            if (sk.size() < k) {\\n                sk.push_back(nums[i]);\\n            }\\n        }\\n        return sk;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> sk;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            while (sk.size() && nums[i] < sk.back() && k-sk.size() <= nums.size()-i-1) {\\n                sk.pop_back();\\n            }\\n            if (sk.size() < k) {\\n                sk.push_back(nums[i]);\\n            }\\n        }\\n        return sk;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036786,
                "title": "rust-solution-using-stack",
                "content": "```\\nimpl Solution {\\n    pub fn most_competitive(nums: Vec<i32>, k: i32) -> Vec<i32> {\\n        let mut increasing_stack = Vec::with_capacity(k as usize);\\n        \\n        for (i, &num) in nums.iter().enumerate() {\\n            while let Some(&last) = increasing_stack.last() {\\n                if last > num &&\\n                    increasing_stack.len() - 1 + nums.len() - i >= k as usize\\n                {\\n                    increasing_stack.pop();\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n            if increasing_stack.len() < k as usize {\\n                increasing_stack.push(num);\\n            }\\n        }\\n        \\n        increasing_stack\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn most_competitive(nums: Vec<i32>, k: i32) -> Vec<i32> {\\n        let mut increasing_stack = Vec::with_capacity(k as usize);\\n        \\n        for (i, &num) in nums.iter().enumerate() {\\n            while let Some(&last) = increasing_stack.last() {\\n                if last > num &&\\n                    increasing_stack.len() - 1 + nums.len() - i >= k as usize\\n                {\\n                    increasing_stack.pop();\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n            if increasing_stack.len() < k as usize {\\n                increasing_stack.push(num);\\n            }\\n        }\\n        \\n        increasing_stack\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1036443,
                "title": "c-solution-using-a-vector",
                "content": "1. Maintaining a vector of length k all time, i.e. a result vector. \\n2. Traverse on elements of input vector,\\n\\t 2.1  if element is greater than last element of vector(recenty traversed element) and result vector size is less than k,  push the element in the back of result vector. because if we already have k size result vector then that element can\\'t be the part of result vector.\\n   \\n   2.2 if element is less than last element of the vector, then we check if we remove the last element of the vector then how many elements are still required to make result vector length k i.e. x = k-result.size(). No of still to be traversed elements in the array should be more than x, only then we will pop the last element of result array. Will keep doing this till this condition is true. \\n   \\n   ```\\n   vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> result;\\n        \\n        for (int i=0; i<nums.size(); i++) {\\n            while (!result.empty() && nums[i]<result.back() && nums.size()-i-1 >= k-result.size()) {\\n                result.pop_back();\\n            }\\n            if (result.size() >= k) {\\n                continue;\\n            }\\n            result.push_back(nums[i]);\\n        }\\n        \\n        return result;\\n    }\\n   ```",
                "solutionTags": [],
                "code": "```\\n   vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> result;\\n        \\n        for (int i=0; i<nums.size(); i++) {\\n            while (!result.empty() && nums[i]<result.back() && nums.size()-i-1 >= k-result.size()) {\\n                result.pop_back();\\n            }\\n            if (result.size() >= k) {\\n                continue;\\n            }\\n            result.push_back(nums[i]);\\n        }\\n        \\n        return result;\\n    }\\n   ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1034257,
                "title": "javascript-one-pass-stack",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar mostCompetitive = function(nums, k) {\\n    const stack = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        while (stack.length !== 0 && nums[i] < stack[stack.length - 1] && i < nums.length - (k - stack.length)) {\\n            stack.pop();\\n        }\\n        if (stack.length < k) stack.push(nums[i]);\\n    }\\n    return stack;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar mostCompetitive = function(nums, k) {\\n    const stack = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        while (stack.length !== 0 && nums[i] < stack[stack.length - 1] && i < nums.length - (k - stack.length)) {\\n            stack.pop();\\n        }\\n        if (stack.length < k) stack.push(nums[i]);\\n    }\\n    return stack;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1029823,
                "title": "my-stack-solution",
                "content": "The idea is to the find the minimum element first because that element is going to be start point and then just remove all the elements which are greater than their right elements.\\n\\n```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int n=nums.length;\\n                int minElement=nums[0];\\n                int minIndex=0;\\n                for(int i=1;i<n;i++){\\n                    if(nums[i]<minElement && n-i>=k){\\n                        minElement=nums[i];\\n                        minIndex=i;\\n                    }\\n                }\\n                Stack<Integer> stack=new Stack<>();\\n                stack.push(minIndex);\\n                for(int i=minIndex+1;i<n;i++){\\n\\n           \\n                   \\n                    while(!stack.isEmpty() && nums[stack.peek()]>nums[i] && \\n                          n-i>k-stack.size())\\n                    {\\n                     \\n                        stack.pop();\\n                    }\\n                    stack.push(i);\\n                }\\n                while (stack.size()>k){\\n                   stack.pop();\\n                }\\n                int[] res=new int[k];\\n                int index=k-1;\\n                while(!stack.isEmpty()){\\n\\n                    res[index--]=nums[stack.pop()];\\n                }\\n               return res;\\n            }\\n    }\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int n=nums.length;\\n                int minElement=nums[0];\\n                int minIndex=0;\\n                for(int i=1;i<n;i++){\\n                    if(nums[i]<minElement && n-i>=k){\\n                        minElement=nums[i];\\n                        minIndex=i;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1029566,
                "title": "find-the-most-competitive-subsequence-c-solution-best-method",
                "content": "class Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) \\n\\t{\\n        vector<int> ans;\\n        for(int i = 0;i < nums.size();i++){\\n            while(!ans.empty() && ans.back() > nums[i] && ans.size() - 1 + nums.size() - i >= k){\\n                ans.pop_back();\\n            }\\n            if(ans.size() < k){\\n            ans.push_back(nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) \\n\\t{\\n        vector<int> ans;\\n        for(int i = 0;i < nums.size();i++){\\n            while(!ans.empty() && ans.back() > nums[i] && ans.size() - 1 + nums.size() - i >= k){\\n                ans.pop_back();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1028976,
                "title": "python-stack-w-comment",
                "content": "```py\\n\\'\\'\\'\\nw: array, greedy\\nh: for a fixed size of k, usually think about a sliding window+hashmap,\\n    however, subsequence allow skipped item, so sliding window may not be applicable\\n    then think about a backtrack, however, the length of nums array indicates that we \\n    could not find all the possible subsequence\\n    Note that although subsequence allows skipped item, there is one important property\\n    which is the relative order of the number must be the same as in the original array\\n    which mean we have to add the item by following the order. so we may use a stack or\\n    a queue.\\n    note the definition of \"competitive\", the naive approach is that we find all the subsequence\\n    and compare them at each index in parallel and filter out those ones have larger number at the same index, \\n    this is equal to that for each position in the subsequence, we only care if it is the smallest number\\n    we can add from the number after current position, which indicate a greedy method to do the comparison\\n    on the fly:\\n    1) we scan the item one by one\\n        if current item is less the previous item, we discard the previous\\n        but we need to make sure we have enough items left to make the subsquence\\n        of length k\\n        \\n        if now the current item is the smallest, we add it to the end of the array\\n        \\n    2) at the end, we only retrieve the [0:k] items as the find result\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        stack = [nums[0]]\\n        n = len(nums)\\n        \\n        for i in range(1,n):\\n            while stack and stack[-1] > nums[i] and k-len(stack) < n-i:\\n                stack.pop()\\n            \\n            stack.append(nums[i])\\n        \\n        return stack[:k]\\n```\\n\\nI would say this problem is really a good one!",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Greedy"
                ],
                "code": "```py\\n\\'\\'\\'\\nw: array, greedy\\nh: for a fixed size of k, usually think about a sliding window+hashmap,\\n    however, subsequence allow skipped item, so sliding window may not be applicable\\n    then think about a backtrack, however, the length of nums array indicates that we \\n    could not find all the possible subsequence\\n    Note that although subsequence allows skipped item, there is one important property\\n    which is the relative order of the number must be the same as in the original array\\n    which mean we have to add the item by following the order. so we may use a stack or\\n    a queue.\\n    note the definition of \"competitive\", the naive approach is that we find all the subsequence\\n    and compare them at each index in parallel and filter out those ones have larger number at the same index, \\n    this is equal to that for each position in the subsequence, we only care if it is the smallest number\\n    we can add from the number after current position, which indicate a greedy method to do the comparison\\n    on the fly:\\n    1) we scan the item one by one\\n        if current item is less the previous item, we discard the previous\\n        but we need to make sure we have enough items left to make the subsquence\\n        of length k\\n        \\n        if now the current item is the smallest, we add it to the end of the array\\n        \\n    2) at the end, we only retrieve the [0:k] items as the find result\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        stack = [nums[0]]\\n        n = len(nums)\\n        \\n        for i in range(1,n):\\n            while stack and stack[-1] > nums[i] and k-len(stack) < n-i:\\n                stack.pop()\\n            \\n            stack.append(nums[i])\\n        \\n        return stack[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028898,
                "title": "c-simple-stack",
                "content": "```\\npublic int[] MostCompetitive(int[] nums, int k) {\\n        if (nums.Length==k) return nums;\\n        \\n        Stack<int> result = new Stack<int>();\\n        for(var i=0;i<nums.Length;i++)\\n        {\\n            int left = nums.Length-i;\\n            while(result.Count>0\\n                 && result.Count+left>k\\n                 && result.Peek()>nums[i])\\n            {\\n                result.Pop();\\n            }\\n            if (result.Count<k)\\n                result.Push(nums[i]);\\n        }\\n        var arr = result.ToArray();\\n        Array.Reverse(arr);\\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int[] MostCompetitive(int[] nums, int k) {\\n        if (nums.Length==k) return nums;\\n        \\n        Stack<int> result = new Stack<int>();\\n        for(var i=0;i<nums.Length;i++)\\n        {\\n            int left = nums.Length-i;\\n            while(result.Count>0\\n                 && result.Count+left>k\\n                 && result.Peek()>nums[i])\\n            {\\n                result.Pop();\\n            }\\n            if (result.Count<k)\\n                result.Push(nums[i]);\\n        }\\n        var arr = result.ToArray();\\n        Array.Reverse(arr);\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1028824,
                "title": "c-explained-briefly",
                "content": "We should try to maintian as sorted sequences as possible. While popping element from the vector we also must make sure that the number of choices remaining/available from nums is enought to fill our ans vector till k.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            int avail=n-i;\\n            while(!ans.empty() && nums[i]<ans.back() && avail>=k-(ans.size()-1)){\\n                ans.pop_back();\\n            }\\n            if(ans.size()<k)ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            int avail=n-i;\\n            while(!ans.empty() && nums[i]<ans.back() && avail>=k-(ans.size()-1)){\\n                ans.pop_back();\\n            }\\n            if(ans.size()<k)ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028788,
                "title": "java-some-comments-stack",
                "content": "```\\n/*\\nIt is same as 402. Remove K Digits;\\n*/\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int needToDelete = nums.length - k;\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int[] result = new int[k];\\n        // Actually, we do not need this if statement, because k must > 0\\n        if(needToDelete == nums.length) {\\n            return result;\\n        }\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            while(!st.isEmpty() && needToDelete > 0 && st.peek() > nums[i]) {\\n                st.pop();\\n                needToDelete--;\\n            }\\n            st.push(nums[i]);\\n        }\\n        // if needToDelete not == 0, all not needed values must stay on top of the stack \\n        while(needToDelete > 0) {\\n            st.pop();\\n            needToDelete--;\\n        }\\n        // put the remaing elements which in the stack to the new array\\n        for(int i = result.length - 1; i >= 0; i--) {\\n            result[i] = st.pop();\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n/*\\nIt is same as 402. Remove K Digits;\\n*/\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int needToDelete = nums.length - k;\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int[] result = new int[k];\\n        // Actually, we do not need this if statement, because k must > 0\\n        if(needToDelete == nums.length) {\\n            return result;\\n        }\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            while(!st.isEmpty() && needToDelete > 0 && st.peek() > nums[i]) {\\n                st.pop();\\n                needToDelete--;\\n            }\\n            st.push(nums[i]);\\n        }\\n        // if needToDelete not == 0, all not needed values must stay on top of the stack \\n        while(needToDelete > 0) {\\n            st.pop();\\n            needToDelete--;\\n        }\\n        // put the remaing elements which in the stack to the new array\\n        for(int i = result.length - 1; i >= 0; i--) {\\n            result[i] = st.pop();\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028533,
                "title": "java-easy-to-understand-stack-solution-explained",
                "content": "**Solution:**\\nWe will use Stack and a Greedy approach in this problem.\\nThe idea is:\\n\\n* Continuously collect items and put them in the stack. Everytime that we visit a new item in the array, we remove all items that are greater than the current considered item since they are less competitive than this item. Then we push the new item onto the stack.\\n\\n* Also, when popping and pushing items out of/into the stack, we also need to make sure that the stack size does not exceed `k` and also there are still enough elements left in the array for us to choose.\\n\\n**Code:**\\n```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            // Greedily popping items that are greater from this element from the stack\\n            // Those items will not make a more competitive subsequence\\n            // The condition \\'stack.size() + nums.length - i > k\\' is to make sure that we don\\'t remove\\n            // elements when there are not enough elements left in the array for us to choose\\n            while (!stack.isEmpty() && nums[i] < stack.peek() && stack.size() + nums.length - i > k) {\\n                stack.pop();\\n            }   \\n            \\n            // Make sure we don\\'t go exceed k elements\\n            if (stack.size() < k) {\\n                stack.push(nums[i]);\\n            }\\n        }\\n        \\n        // Convert back to a normal array\\n        int[] ans = new int[k];\\n        for (int curr = k - 1; curr >= 0; curr--) {\\n            ans[curr] = stack.pop();\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            // Greedily popping items that are greater from this element from the stack\\n            // Those items will not make a more competitive subsequence\\n            // The condition \\'stack.size() + nums.length - i > k\\' is to make sure that we don\\'t remove\\n            // elements when there are not enough elements left in the array for us to choose\\n            while (!stack.isEmpty() && nums[i] < stack.peek() && stack.size() + nums.length - i > k) {\\n                stack.pop();\\n            }   \\n            \\n            // Make sure we don\\'t go exceed k elements\\n            if (stack.size() < k) {\\n                stack.push(nums[i]);\\n            }\\n        }\\n        \\n        // Convert back to a normal array\\n        int[] ans = new int[k];\\n        for (int curr = k - 1; curr >= 0; curr--) {\\n            ans[curr] = stack.pop();\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028315,
                "title": "python-monotonous-increasing-stack-o-n-runtime-o-k-space-with-comments-and-example",
                "content": "O(n) runtime O(k) memory - 1412ms, 27.6MB\\nApproach: Keeping a monotonous increasing stack. Upon finding a smaller value, we keep popping from stack until\\nthe last value is equal or if it\\'s just enough to reach k-length (popping too much may cause us not to have a k-length sequence).\\n\\nEx: nums=[2,4,3,3,5,4,9,6], k=4\\n[2] (at end of i=0)\\n[2,4] (end of i=1)\\n[2,3]\\n[2,3,3]\\n[2,3,3]\\n[2,3,3,4]\\n[2,3,3,4]\\n[2,3,3,4] (end of i=7)\\n\\n```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        \\n        #monotone increasing stack\\n        stack = []\\n        for index,num in enumerate(nums):\\n            \\n            #append to stack if decreasing and still enough for k-length\\n            remaining = len(nums) - index\\n            while (stack and num < stack[-1]) and (len(stack) + remaining > k):\\n                stack.pop()\\n            \\n            #only append if we\\'re below k\\n            if len(stack) < k:\\n                stack.append(num)\\n        \\n        return stack\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        \\n        #monotone increasing stack\\n        stack = []\\n        for index,num in enumerate(nums):\\n            \\n            #append to stack if decreasing and still enough for k-length\\n            remaining = len(nums) - index\\n            while (stack and num < stack[-1]) and (len(stack) + remaining > k):\\n                stack.pop()\\n            \\n            #only append if we\\'re below k\\n            if len(stack) < k:\\n                stack.append(num)\\n        \\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028313,
                "title": "complex-sol-using-segment-tree-to-nlogn-so-4n-95-8",
                "content": "Just in case you want another perspective:\\n```\\n// T O(NlogN)\\n// S O(4N)\\n\\nclass Solution {\\n\\tconst int intMax = ~(1 << 30);\\n\\t\\n\\tint getMinInRange(vector<int>& segTree, int tI, int tL, int tR, int l, int r, vector<int>& nums)\\n\\t{\\n\\t\\tif (l <= tL && r >= tR)\\n\\t\\t\\treturn segTree[tI];\\n\\n\\t\\tif (l > tR || r < tL)\\n\\t\\t\\treturn -1;\\n\\n\\t\\tint tM = tL + (tR - tL) / 2;\\n\\n\\t\\tint minL = getMinInRange(segTree, tI * 2, tL, tM, l, r, nums);\\n\\t\\tint minR = getMinInRange(segTree, tI * 2 + 1, tM + 1, tR, l, r, nums);\\n\\n\\t\\tif (minL != -1 && minR != -1)\\n\\t\\t{\\n\\t\\t\\treturn (nums[minL - 1] <= nums[minR - 1]) ? minL : minR;\\n\\t\\t}\\n\\t\\telse if (minL != -1)\\n\\t\\t{\\n\\t\\t\\treturn minL;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn minR;\\n\\t\\t}\\n\\t}\\n\\n\\tint buildSegTree(vector<int>& segTree, int tI, vector<int>& nums, int l, int r)\\n\\t{\\n\\t\\tif (l == r)\\n\\t\\t{\\n\\t\\t\\tsegTree[tI] = l;\\n\\t\\t\\treturn segTree[tI];\\n\\t\\t}\\n\\t\\t\\t\\n\\t\\tint tL = tI * 2;\\n\\t\\tint tR = tI * 2 + 1;\\n\\n\\t\\tint m = l + (r - l) / 2;\\n\\n\\t\\tint minL = buildSegTree(segTree, tL, nums, l, m);\\n\\t\\tint minR = buildSegTree(segTree, tR, nums, m + 1, r);\\n\\n\\t\\tsegTree[tI] = (nums[minL - 1] <= nums[minR - 1]) ? minL : minR;\\n\\n\\t\\treturn segTree[tI];\\n\\t}\\npublic:\\n\\tvector<int> mostCompetitive(vector<int>& nums, int k) {\\n\\t\\tint size = nums.size();\\n\\t\\tvector<int> segTree(4 * size);\\n\\n\\t\\tbuildSegTree(segTree, 1, nums, 1, size);\\n\\n\\t\\tvector<int> ans;\\n\\t\\tint idx = 1;\\n\\t\\tint l = 1;\\n\\t\\tint r = size - k + 1;\\n\\n\\t\\tfor (int i = 1; i <= k; i++)\\n\\t\\t{\\n\\t\\t\\tint minIdx = getMinInRange(segTree, 1, 1, size, l, r, nums);\\n\\t\\t\\tans.push_back(nums[minIdx - 1]);\\n\\t\\t\\tl = minIdx + 1;\\n\\t\\t\\tr = (size - k + 1) + i;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// T O(NlogN)\\n// S O(4N)\\n\\nclass Solution {\\n\\tconst int intMax = ~(1 << 30);\\n\\t\\n\\tint getMinInRange(vector<int>& segTree, int tI, int tL, int tR, int l, int r, vector<int>& nums)\\n\\t{\\n\\t\\tif (l <= tL && r >= tR)\\n\\t\\t\\treturn segTree[tI];\\n\\n\\t\\tif (l > tR || r < tL)\\n\\t\\t\\treturn -1;\\n\\n\\t\\tint tM = tL + (tR - tL) / 2;\\n\\n\\t\\tint minL = getMinInRange(segTree, tI * 2, tL, tM, l, r, nums);\\n\\t\\tint minR = getMinInRange(segTree, tI * 2 + 1, tM + 1, tR, l, r, nums);\\n\\n\\t\\tif (minL != -1 && minR != -1)\\n\\t\\t{\\n\\t\\t\\treturn (nums[minL - 1] <= nums[minR - 1]) ? minL : minR;\\n\\t\\t}\\n\\t\\telse if (minL != -1)\\n\\t\\t{\\n\\t\\t\\treturn minL;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn minR;\\n\\t\\t}\\n\\t}\\n\\n\\tint buildSegTree(vector<int>& segTree, int tI, vector<int>& nums, int l, int r)\\n\\t{\\n\\t\\tif (l == r)\\n\\t\\t{\\n\\t\\t\\tsegTree[tI] = l;\\n\\t\\t\\treturn segTree[tI];\\n\\t\\t}\\n\\t\\t\\t\\n\\t\\tint tL = tI * 2;\\n\\t\\tint tR = tI * 2 + 1;\\n\\n\\t\\tint m = l + (r - l) / 2;\\n\\n\\t\\tint minL = buildSegTree(segTree, tL, nums, l, m);\\n\\t\\tint minR = buildSegTree(segTree, tR, nums, m + 1, r);\\n\\n\\t\\tsegTree[tI] = (nums[minL - 1] <= nums[minR - 1]) ? minL : minR;\\n\\n\\t\\treturn segTree[tI];\\n\\t}\\npublic:\\n\\tvector<int> mostCompetitive(vector<int>& nums, int k) {\\n\\t\\tint size = nums.size();\\n\\t\\tvector<int> segTree(4 * size);\\n\\n\\t\\tbuildSegTree(segTree, 1, nums, 1, size);\\n\\n\\t\\tvector<int> ans;\\n\\t\\tint idx = 1;\\n\\t\\tint l = 1;\\n\\t\\tint r = size - k + 1;\\n\\n\\t\\tfor (int i = 1; i <= k; i++)\\n\\t\\t{\\n\\t\\t\\tint minIdx = getMinInRange(segTree, 1, 1, size, l, r, nums);\\n\\t\\t\\tans.push_back(nums[minIdx - 1]);\\n\\t\\t\\tl = minIdx + 1;\\n\\t\\t\\tr = (size - k + 1) + i;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028145,
                "title": "c-beats-100-monotonic-stack-video-solution",
                "content": "**Approach** : Maximum count of number that can be removed will be ```nums.size() - k```  so traverse from left to right and whenver we will find that there is a minimum number available we will try to add in our ans List near the begining( near the begining of list because we want most competitive list) and will discard all other numbers.\\n\\nAt the same time we will keep the track of how many numbers we have discarded till now ``` res -- ```.\\n\\nFinally after iterating once through given vector and ``` res != 0 ``` means our list has more than \"k\" numbers. So discard rest elements from last.\\n```cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        int res = nums.size() - k;\\n        \\n        for(auto a: nums)\\n        {\\n            while( (ans.size()>0) && (res ) && (a < ans.back() ))\\n            {\\n                ans.pop_back();\\n                res--;\\n            }\\n            ans.push_back(a);\\n        }\\n        \\n        while(res)\\n        {\\n            ans.pop_back();\\n            res--;\\n        }\\n        return ans;\\n    }\\n};\\n\\nstatic bool     _foo = ios::sync_with_stdio(false);\\nstatic ostream* _bar = cin.tie(NULL);\\n```\\n\\nVideo  [link](https://youtu.be/Ol7yz0XKKLw)\\nAll credit goes to : Lead Coding",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```nums.size() - k```\n``` res -- ```\n``` res != 0 ```\n```cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        int res = nums.size() - k;\\n        \\n        for(auto a: nums)\\n        {\\n            while( (ans.size()>0) && (res ) && (a < ans.back() ))\\n            {\\n                ans.pop_back();\\n                res--;\\n            }\\n            ans.push_back(a);\\n        }\\n        \\n        while(res)\\n        {\\n            ans.pop_back();\\n            res--;\\n        }\\n        return ans;\\n    }\\n};\\n\\nstatic bool     _foo = ios::sync_with_stdio(false);\\nstatic ostream* _bar = cin.tie(NULL);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027858,
                "title": "simple-c-stack-approach-100",
                "content": "We maintain vector of elements that are smaller than current elements in nums. If the current number on `nums` is less than the top of the stack `res` and there are sufficient numbers left. Then push the current number to the stack.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> res(k);\\n        int start = 0, n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            while (start > 0 && (res[start - 1] > nums[i]) && (start + n - i - 1 >= k)) \\n                start--;\\n            if (start < k) res[start++] = nums[i];\\n        }\\n        return res;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> res(k);\\n        int start = 0, n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            while (start > 0 && (res[start - 1] > nums[i]) && (start + n - i - 1 >= k)) \\n                start--;\\n            if (start < k) res[start++] = nums[i];\\n        }\\n        return res;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1027836,
                "title": "simple-java-solution-fast-100",
                "content": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int i = 0;\\n        int length = 0;\\n        int counter = -1;\\n        int n = nums.length;\\n        int[] result = new int[k];\\n        \\n        for (; i < n; i++) {\\n            boolean isBreak = false;\\n            while (counter >= 0 && nums[i] < result[counter]) {\\n                if (n - i > k - length) {\\n                    result[counter] = 0;\\n                    counter--;\\n                    length--;\\n                } else {\\n                    isBreak = true;\\n                    break;\\n                }\\n            }\\n            \\n            if (isBreak) break;\\n            \\n            if (length < k) {\\n                length++;\\n                counter++;\\n                result[counter] = nums[i];\\n            }\\n        }\\n        \\n        while (i < n && length <= k) {\\n            length++;\\n            counter++;\\n            result[counter] = nums[i++];\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int i = 0;\\n        int length = 0;\\n        int counter = -1;\\n        int n = nums.length;\\n        int[] result = new int[k];\\n        \\n        for (; i < n; i++) {\\n            boolean isBreak = false;\\n            while (counter >= 0 && nums[i] < result[counter]) {\\n                if (n - i > k - length) {\\n                    result[counter] = 0;\\n                    counter--;\\n                    length--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1027753,
                "title": "java-binary-search-in-inner-loop",
                "content": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int res[] = new int[k];\\n        int len = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            /* If we have less than k elements and current number is > last item\\n             * insert the item. If current item is less and we do not have sufficient\\n             * numbers in array left then as well put the item\\n             */\\n            if (len < k && (len == 0 || nums[i] > res[len-1] || (k-len == nums.length - i))) {\\n                res[len++] = nums[i];\\n                continue;\\n            }\\n            \\n            /* If we have k elements and current element is >= last skip the loop */\\n            if (len == k && nums[i] >= res[len-1])\\n                continue;\\n            \\n            /* Binary search for the least index where we can put the lesser number */\\n            int lo = (k - nums.length + i) > 0 ? (k - nums.length + i) : 0;\\n            int hi = len;\\n            while (lo < hi) {\\n                int mid = lo + (hi-lo)/2;\\n                if (nums[i] < res[mid])\\n                    hi = mid;\\n                else\\n                    lo = mid+1;\\n            }\\n            res[lo] = nums[i];\\n            len = lo+1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int res[] = new int[k];\\n        int len = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            /* If we have less than k elements and current number is > last item\\n             * insert the item. If current item is less and we do not have sufficient\\n             * numbers in array left then as well put the item\\n             */\\n            if (len < k && (len == 0 || nums[i] > res[len-1] || (k-len == nums.length - i))) {\\n                res[len++] = nums[i];\\n                continue;\\n            }\\n            \\n            /* If we have k elements and current element is >= last skip the loop */\\n            if (len == k && nums[i] >= res[len-1])\\n                continue;\\n            \\n            /* Binary search for the least index where we can put the lesser number */\\n            int lo = (k - nums.length + i) > 0 ? (k - nums.length + i) : 0;\\n            int hi = len;\\n            while (lo < hi) {\\n                int mid = lo + (hi-lo)/2;\\n                if (nums[i] < res[mid])\\n                    hi = mid;\\n                else\\n                    lo = mid+1;\\n            }\\n            res[lo] = nums[i];\\n            len = lo+1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004048,
                "title": "c-o-nlon-n-using-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        \\n        vector<int> ans;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=0;i<n-k;i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n        int ind=n-k;\\n        while(ind<n)\\n        {\\n            pq.push({nums[ind],ind});\\n            ans.push_back(pq.top().first);\\n            int last_ind;\\n            last_ind=pq.top().second;\\n            pq.pop();\\n            \\n            while(pq.size() and pq.top().second<last_ind)\\n            {\\n                pq.pop();\\n            }\\n            ind++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        \\n        vector<int> ans;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=0;i<n-k;i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n        int ind=n-k;\\n        while(ind<n)\\n        {\\n            pq.push({nums[ind],ind});\\n            ans.push_back(pq.top().first);\\n            int last_ind;\\n            last_ind=pq.top().second;\\n            pq.pop();\\n            \\n            while(pq.size() and pq.top().second<last_ind)\\n            {\\n                pq.pop();\\n            }\\n            ind++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983704,
                "title": "simple-python-o-n",
                "content": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        s = []\\n        for i, x in enumerate(nums):\\n            while s and s[-1] > x and len(s) + n - i > k:\\n                s.pop()\\n            if len(s) < k:\\n                s.append(x)\\n        return s\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        s = []\\n        for i, x in enumerate(nums):\\n            while s and s[-1] > x and len(s) + n - i > k:\\n                s.pop()\\n            if len(s) < k:\\n                s.append(x)\\n        return s\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 972526,
                "title": "c-short-greedy-solution",
                "content": "Run-time is `O(N)`, space is `O(1)`. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(const vector<int>& nums, int k) {\\n        std::vector<int> res(k, -1);\\n        for(int i{0}, j{0}, size{(int)nums.size()}; i < size; ++i) {\\n            while(j > 0 && k-j+1 <= size-i && res[j-1] > nums[i]) --j;\\n            if(j < k) res[j++] = nums[i];\\n        }\\n        return res;\\n    }\\n};\\n\\nauto gucciGang = [](){std::ios::sync_with_stdio(0);std::cin.tie(0);std::cout.tie(0);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(const vector<int>& nums, int k) {\\n        std::vector<int> res(k, -1);\\n        for(int i{0}, j{0}, size{(int)nums.size()}; i < size; ++i) {\\n            while(j > 0 && k-j+1 <= size-i && res[j-1] > nums[i]) --j;\\n            if(j < k) res[j++] = nums[i];\\n        }\\n        return res;\\n    }\\n};\\n\\nauto gucciGang = [](){std::ios::sync_with_stdio(0);std::cin.tie(0);std::cout.tie(0);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 959726,
                "title": "python-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n\\t\\t\\tstack = []\\n\\t\\t\\tn = len(nums) - k\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\twhile stack and n and i < stack[-1]:\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\t\\tn -= 1            \\n\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\treturn stack[:k]",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n\\t\\t\\tstack = []\\n\\t\\t\\tn = len(nums) - k\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\twhile stack and n and i < stack[-1]:\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\t\\tn -= 1            \\n\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\treturn stack[:k]",
                "codeTag": "Java"
            },
            {
                "id": 956031,
                "title": "c-o-nlogn-time-o-n-space",
                "content": "> Approach \\n1. To select the minimum number in 1st interation we have range `[0, n-k]`\\n2. Suppose number is found at index p. \\n3. Next search range is [p+1, n-k+1]\\n4. Repeat this k times to get k numbers in the array \\n\\n\\n>Algorithm\\n>\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        \\n        int right = nums.size() - k;\\n        int left = 0;\\n\\t\\t// index of previous min number in range found at\\n        int prev = -1;\\n        \\n        vector<int> ans;\\n\\t\\t// <number, index>\\n        set<pair<int, int>> st;\\n        \\n        for(int i=0; i<k; i++, right++) {\\n            // search in range\\n            while(left <= right) {\\n                st.insert({nums[left], left});\\n                left++;\\n            }\\n\\t\\t\\t// discard the numbers outside of range\\n            while(prev >= st.begin()->second) {\\n                st.erase(*st.begin());\\n            }\\n            // found\\n            auto p = *st.begin();\\n            prev = p.second;\\n            ans.push_back(p.first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        \\n        int right = nums.size() - k;\\n        int left = 0;\\n\\t\\t// index of previous min number in range found at\\n        int prev = -1;\\n        \\n        vector<int> ans;\\n\\t\\t// <number, index>\\n        set<pair<int, int>> st;\\n        \\n        for(int i=0; i<k; i++, right++) {\\n            // search in range\\n            while(left <= right) {\\n                st.insert({nums[left], left});\\n                left++;\\n            }\\n\\t\\t\\t// discard the numbers outside of range\\n            while(prev >= st.begin()->second) {\\n                st.erase(*st.begin());\\n            }\\n            // found\\n            auto p = *st.begin();\\n            prev = p.second;\\n            ans.push_back(p.first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953656,
                "title": "c-min-priority-queue",
                "content": "first value will be min in [0,n-k] ,let at pos=x\\nthen second will be min in [x+1,n-k+1] ,let pos=y;\\nthen third min in [y+1,n-k+2] and so on.\\n\\n``code:\\n\\n        vector<int> mostCompetitive(vector<int>& nums, int k) {\\n\\t\\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int n=nums.size();\\n        int pos=-1;\\n        vector<int> ans;\\n        for(int i=0;i<=n-k;i++) pq.push(make_pair(nums[i],i));\\n        ans.push_back(pq.top().first);\\n        pos=pq.top().second;\\n        pq.pop();\\n        for(int i=n-k+1;i<n;i++)\\n        {\\n            pq.push(make_pair(nums[i],i));\\n            while(pq.top().second<=pos)\\n                pq.pop();\\n            ans.push_back(pq.top().first);\\n            pos=pq.top().second;\\n            pq.pop();\\n        }\\n        return ans;   \\n    }\\n\\t``",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "first value will be min in [0,n-k] ,let at pos=x\\nthen second will be min in [x+1,n-k+1] ,let pos=y;\\nthen third min in [y+1,n-k+2] and so on.\\n\\n``code:\\n\\n        vector<int> mostCompetitive(vector<int>& nums, int k) {\\n\\t\\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int n=nums.size();\\n        int pos=-1;\\n        vector<int> ans;\\n        for(int i=0;i<=n-k;i++) pq.push(make_pair(nums[i],i));\\n        ans.push_back(pq.top().first);\\n        pos=pq.top().second;\\n        pq.pop();\\n        for(int i=n-k+1;i<n;i++)\\n        {\\n            pq.push(make_pair(nums[i],i));\\n            while(pq.top().second<=pos)\\n                pq.pop();\\n            ans.push_back(pq.top().first);\\n            pos=pq.top().second;\\n            pq.pop();\\n        }\\n        return ans;   \\n    }\\n\\t``",
                "codeTag": "Unknown"
            },
            {
                "id": 953286,
                "title": "java-priorityqueue",
                "content": "```\\npublic int[] mostCompetitive(int[] nums, int k) {\\n        int N = nums.length;\\n        int len = N - k;\\n        int[] res = new int[k];\\n        int cnt = 0;\\n        PriorityQueue<Pair<Integer, Integer>> pq=\\n                    new PriorityQueue<Pair<Integer, Integer>>(N,(a,b) -> (a.getKey() == b.getKey()) ? (a.getValue() - b.getValue()) : (a.getKey() - b.getKey()));\\n        for (int i = 0; i <= len; i++) {\\n            pq.add(new Pair<>(nums[i], i));\\n        }\\n        Pair<Integer, Integer> t = pq.poll();\\n        res[cnt++] = t.getKey();\\n        int minIdx = t.getValue();\\n        for (int i = len+1; i < N; i++) {\\n            pq.add(new Pair<>(nums[i], i));\\n            t = pq.poll();\\n            while (t.getValue() < minIdx) {\\n                t = pq.poll();\\n            }\\n            res[cnt++] = t.getKey();\\n            minIdx = t.getValue();\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int[] mostCompetitive(int[] nums, int k) {\\n        int N = nums.length;\\n        int len = N - k;\\n        int[] res = new int[k];\\n        int cnt = 0;\\n        PriorityQueue<Pair<Integer, Integer>> pq=\\n                    new PriorityQueue<Pair<Integer, Integer>>(N,(a,b) -> (a.getKey() == b.getKey()) ? (a.getValue() - b.getValue()) : (a.getKey() - b.getKey()));\\n        for (int i = 0; i <= len; i++) {\\n            pq.add(new Pair<>(nums[i], i));\\n        }\\n        Pair<Integer, Integer> t = pq.poll();\\n        res[cnt++] = t.getKey();\\n        int minIdx = t.getValue();\\n        for (int i = len+1; i < N; i++) {\\n            pq.add(new Pair<>(nums[i], i));\\n            t = pq.poll();\\n            while (t.getValue() < minIdx) {\\n                t = pq.poll();\\n            }\\n            res[cnt++] = t.getKey();\\n            minIdx = t.getValue();\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 953190,
                "title": "javascript-and-typescript-solution",
                "content": "Time Complexity O(n)\\nSpace Complexity O(k)\\n\\n### JavaScript\\n```js\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar mostCompetitive = function(nums, k) {\\n  const res = [];\\n  const n = nums.length;\\n  \\n  for (let i = 0; i < n; i += 1) {\\n    while (res.length &&\\n          nums[i] < res[res.length - 1]) {\\n      if (k - res.length < n - i) {\\n        res.pop();\\n      } else {\\n        break;\\n      }\\n    }\\n    \\n    if (res.length < k) {\\n      res.push(nums[i]);\\n    }\\n  }\\n  return res;\\n};\\n```\\n\\n### TypeScript\\n```ts\\nfunction mostCompetitive(nums: number[], k: number): number[] {\\n  const res = [];\\n  const n = nums.length;\\n  \\n  for (let i = 0; i < n; i += 1) {\\n    while (res.length &&\\n          nums[i] < res[res.length - 1]) {\\n      if (k - res.length < n - i) {\\n        res.pop();\\n      } else {\\n        break;\\n      }\\n    }\\n    \\n    if (res.length < k) {\\n      res.push(nums[i]);\\n    }\\n  }\\n  return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar mostCompetitive = function(nums, k) {\\n  const res = [];\\n  const n = nums.length;\\n  \\n  for (let i = 0; i < n; i += 1) {\\n    while (res.length &&\\n          nums[i] < res[res.length - 1]) {\\n      if (k - res.length < n - i) {\\n        res.pop();\\n      } else {\\n        break;\\n      }\\n    }\\n    \\n    if (res.length < k) {\\n      res.push(nums[i]);\\n    }\\n  }\\n  return res;\\n};\\n```\n```ts\\nfunction mostCompetitive(nums: number[], k: number): number[] {\\n  const res = [];\\n  const n = nums.length;\\n  \\n  for (let i = 0; i < n; i += 1) {\\n    while (res.length &&\\n          nums[i] < res[res.length - 1]) {\\n      if (k - res.length < n - i) {\\n        res.pop();\\n      } else {\\n        break;\\n      }\\n    }\\n    \\n    if (res.length < k) {\\n      res.push(nums[i]);\\n    }\\n  }\\n  return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952916,
                "title": "easy-understanding-c",
                "content": "```\\n//using stack\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        stack<int> stk;\\n        for(int i=0;i<n;i++){\\n            while(!stk.empty() && stk.top()>nums[i] && k<(n-i+stk.size())){\\n               stk.pop();\\n            }\\n            if(stk.size()<k)\\n               stk.push(nums[i]);\\n        }\\n        vector<int> res;\\n        while(!stk.empty()){\\n            res.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n//using vector as stack\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> stk;\\n        for(int i=0;i<n;i++){\\n            while(!stk.empty() && stk.back()>nums[i] && k<(n-i+stk.size())){\\n                stk.pop_back();\\n            }\\n            if(stk.size()<k)\\n               stk.push_back(nums[i]);\\n        }\\n        return stk;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n//using stack\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        stack<int> stk;\\n        for(int i=0;i<n;i++){\\n            while(!stk.empty() && stk.top()>nums[i] && k<(n-i+stk.size())){\\n               stk.pop();\\n            }\\n            if(stk.size()<k)\\n               stk.push(nums[i]);\\n        }\\n        vector<int> res;\\n        while(!stk.empty()){\\n            res.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n//using vector as stack\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> stk;\\n        for(int i=0;i<n;i++){\\n            while(!stk.empty() && stk.back()>nums[i] && k<(n-i+stk.size())){\\n                stk.pop_back();\\n            }\\n            if(stk.size()<k)\\n               stk.push_back(nums[i]);\\n        }\\n        return stk;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952888,
                "title": "python-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        if len(nums) == k:\\n            return nums\\n        stack = []\\n        length = len(nums)\\n        for (i, num) in enumerate(nums):\\n            if length - i + len(stack) <= k:\\n                stack.append(num)\\n            else:\\n                while length - i + len(stack) > k and len(stack) > 0 and stack[-1] > num:\\n                    stack.pop()\\n                if len(stack) < k:\\n                    stack.append(num)\\n            \\n        return stack\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        if len(nums) == k:\\n            return nums\\n        stack = []\\n        length = len(nums)\\n        for (i, num) in enumerate(nums):\\n            if length - i + len(stack) <= k:\\n                stack.append(num)\\n            else:\\n                while length - i + len(stack) > k and len(stack) > 0 and stack[-1] > num:\\n                    stack.pop()\\n                if len(stack) < k:\\n                    stack.append(num)\\n            \\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952883,
                "title": "java-my-stack-solution",
                "content": "**1673. Find the Most Competitive Subsequence**\\n\\n**CODE**\\n```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int start = 0;\\n        int current = 0;\\n        Stack<Integer> s = new Stack<Integer>();\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(s.isEmpty()){\\n                s.push(i);\\n            } else {\\n\\t\\t\\t\\t// not empty && # needed to reach k is < remaining elements && last element is larger than current\\n                while(!s.isEmpty() && k - s.size() < nums.length - i  && nums[s.peek()] > nums[i]){\\n                    s.pop(); // remove it\\n                }\\n                if(s.size() < k) // if valid length add it\\n                    s.push(i); \\n            }\\n        }\\n        \\n        //System.out.println(s);\\n        int[] ans = new int[s.size()];\\n        int index = s.size()-1; // start from the back because the numbers pop from the stack LIFO\\n        while(!s.isEmpty()){\\n            ans[index--] = nums[s.pop()];\\n        }\\n  \\n        return ans;\\n    }\\n}\\n```\\n**PROBLEM OVERVIEW**\\nWe are tasked with finding an array with length `k` Such that the array is a subsequence of `nums`, and is ordered in a way that the smallest numbers are in ascending order (aka  \"competitive\").\\n\\n**SOLUTION ANALYSIS**\\nSince the problem wants us to find the smallest increasing subsequence, we just need to look for the smallest starting points:\\n\\n* \\tCheck if I have enough numbers afterwards to finish the subsequence of length `k`\\n\\t* \\tIf so, I delete everything before, because it is not the \"most competitive\" subsequence \\n\\t* \\tOtherwise, do not clear values and just push the current value onto the stack **if** the stack\\'s size is less than `k`\\n\\nWe can utilize the stack data structure (LIFO) to keep track last smallest value\\'s index. If the current index is:\\n* Smaller than the top-most item in the stack\\n**AND**\\n* The current index has enough remaining numbers in `nums` to reach a length of `k`\\n\\nThen, we can clear the stack and add the current number This is demonstrated by this:\\n\\n ```\\nwhile(!s.isEmpty() && k - s.size() < nums.length - i  && nums[s.peek()] > nums[i]){\\n    s.pop(); // remove it\\n}\\n```\\n`k-s.size()` is how many we need to make the subsequence the correct length, and `nums.length-i` is the number of possible values we have left. `k-s.size()` must be smaller, else we can not clear any more values, causing the subsequence to be too small.\\n\\nIf the stack is empty, or there is enough space in the stack, we can push the current value because it is guaranteed to be the \"most competitive,\" as it is the next smallest value.\\n\\n**TIME COMPLEXITY**\\nO(N)\\nWe can expect at most N-k elements be pushed into the stack, which is still linear time.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int start = 0;\\n        int current = 0;\\n        Stack<Integer> s = new Stack<Integer>();\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(s.isEmpty()){\\n                s.push(i);\\n            } else {\\n\\t\\t\\t\\t// not empty && # needed to reach k is < remaining elements && last element is larger than current\\n                while(!s.isEmpty() && k - s.size() < nums.length - i  && nums[s.peek()] > nums[i]){\\n                    s.pop(); // remove it\\n                }\\n                if(s.size() < k) // if valid length add it\\n                    s.push(i); \\n            }\\n        }\\n        \\n        //System.out.println(s);\\n        int[] ans = new int[s.size()];\\n        int index = s.size()-1; // start from the back because the numbers pop from the stack LIFO\\n        while(!s.isEmpty()){\\n            ans[index--] = nums[s.pop()];\\n        }\\n  \\n        return ans;\\n    }\\n}\\n```\n```\\nwhile(!s.isEmpty() && k - s.size() < nums.length - i  && nums[s.peek()] > nums[i]){\\n    s.pop(); // remove it\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952870,
                "title": "java-monotone-stack-solution",
                "content": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] A, int k) {\\n        Stack<Integer> st = new Stack<>();\\n        int n = A.length;\\n        for (int i = 0; i < n; i++) {\\n            while (!st.isEmpty() && A[i] < st.peek() && st.size() + n - i > k) {\\n                st.pop();\\n            }\\n            st.push(A[i]);\\n        }\\n        while (st.size() > k) {\\n            st.pop();\\n        }\\n        int[] res = new int[k];\\n        for (int i = k - 1; i >= 0; i--) {\\n            res[i] = st.pop();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] A, int k) {\\n        Stack<Integer> st = new Stack<>();\\n        int n = A.length;\\n        for (int i = 0; i < n; i++) {\\n            while (!st.isEmpty() && A[i] < st.peek() && st.size() + n - i > k) {\\n                st.pop();\\n            }\\n            st.push(A[i]);\\n        }\\n        while (st.size() > k) {\\n            st.pop();\\n        }\\n        int[] res = new int[k];\\n        for (int i = k - 1; i >= 0; i--) {\\n            res[i] = st.pop();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952849,
                "title": "python-minheap-solution",
                "content": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        hp=[]\\n        n=len(nums)\\n        out=[]\\n        j=0\\n        for i,num in enumerate(nums):\\n            if i<n-k:\\n                hp.append((num,i))\\n            elif i==n-k:\\n                hp.append((num,i))\\n                heapq.heapify(hp)\\n                minnum,j=heapq.heappop(hp)\\n                out+=[minnum]\\n            else:\\n                heapq.heappush(hp,(num,i))\\n                \\n                while hp and hp[0][1]<=j:\\n                    heapq.heappop(hp)\\n                minnum,j=heapq.heappop(hp)\\n                out+=[minnum]\\n        return out\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        hp=[]\\n        n=len(nums)\\n        out=[]\\n        j=0\\n        for i,num in enumerate(nums):\\n            if i<n-k:\\n                hp.append((num,i))\\n            elif i==n-k:\\n                hp.append((num,i))\\n                heapq.heapify(hp)\\n                minnum,j=heapq.heappop(hp)\\n                out+=[minnum]\\n            else:\\n                heapq.heappush(hp,(num,i))\\n                \\n                while hp and hp[0][1]<=j:\\n                    heapq.heappop(hp)\\n                minnum,j=heapq.heappop(hp)\\n                out+=[minnum]\\n        return out\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 952840,
                "title": "swift-stack",
                "content": "```\\nfunc mostCompetitive(_ nums: [Int], _ k: Int) -> [Int] {\\n    var fin : [Int] = []\\n    for (i,n) in nums.enumerated(){\\n        while (!fin.isEmpty && fin.last! > n && fin.count - 1 + nums.count - i >= k) {\\n            fin.removeLast()\\n        }\\n        if fin.count < k{\\n            fin.append(n)\\n        }\\n    }\\n    return fin\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc mostCompetitive(_ nums: [Int], _ k: Int) -> [Int] {\\n    var fin : [Int] = []\\n    for (i,n) in nums.enumerated(){\\n        while (!fin.isEmpty && fin.last! > n && fin.count - 1 + nums.count - i >= k) {\\n            fin.removeLast()\\n        }\\n        if fin.count < k{\\n            fin.append(n)\\n        }\\n    }\\n    return fin\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952818,
                "title": "c-stack-time-complexity-o-n-space-complexity-o-k",
                "content": "Pop all the previous number that is smaller than the current number\\n\\n```\\npublic class Solution {\\n    public int[] MostCompetitive(int[] nums, int k) {\\n        Stack<int> stack = new Stack<int>();\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (stack.Count > 0)\\n            {\\n                while (stack.Count + (nums.Length - i) > k && stack.Count > 0 && stack.Peek() > nums[i])\\n                {\\n                    stack.Pop();\\n                }\\n                \\n                if (stack.Count < k)\\n                {\\n                    stack.Push(nums[i]);\\n                }\\n            }\\n            else\\n            {\\n                stack.Push(nums[i]);\\n            }\\n        }\\n        \\n        return stack.Reverse().ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MostCompetitive(int[] nums, int k) {\\n        Stack<int> stack = new Stack<int>();\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (stack.Count > 0)\\n            {\\n                while (stack.Count + (nums.Length - i) > k && stack.Count > 0 && stack.Peek() > nums[i])\\n                {\\n                    stack.Pop();\\n                }\\n                \\n                if (stack.Count < k)\\n                {\\n                    stack.Push(nums[i]);\\n                }\\n            }\\n            else\\n            {\\n                stack.Push(nums[i]);\\n            }\\n        }\\n        \\n        return stack.Reverse().ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952811,
                "title": "java-o-n-monotonic-stack-use-array-as-stack",
                "content": "Mantain a monotonic increasing stack, which means if we have a smaller number, we can pop the previous larger number so that the result is smallest possible. \\n\\nOne thing need to mention is that we need at least `k` numbers in the stack, so when we want to pop the elements in the stack, we need to make sure there are enough numbers to fill up the answer.\\n\\nUPDATE: add to the stack only if `stack.size() < k` to avoid unnecessary space cost.\\n\\n```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        Stack<Integer> stk = new Stack<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            while (!stk.isEmpty() && nums[i] < stk.peek() && stk.size() + n - i > k) {\\n                stk.pop();\\n            }\\n            if (stk.size() < k) {\\n                stk.add(nums[i]);                \\n            }\\n        }\\n        int[] ans = new int[k];\\n        for (int i = k - 1; i >= 0; i--) {\\n            ans[i] = num;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nAlso, we can use an `Array` to simulate the stack, `top` means the top of stack, where we should push the new element, it also means the current size of the stack.\\n`stk.push(x)   =>    stk[top++] = x`\\n`stk.pop()       =>    top-- (No need to actually delete the element, just decrement the top pointer and next time it will be overwritten)`\\n`stk.peek() => stk[top - 1]`\\n`stk.size() => top`\\n`stk.isEmpty() => top > 0`\\nUse the above conversion, we can use an array of size `k` to do the job.\\n```\\n    public int[] mostCompetitive(int[] nums, int k) {\\n\\t\\tint[] stk = new int[k];\\n        int top = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            while (top > 0 && nums[i] < stk[top - 1] && top + n - i > k) {\\n                top--;\\n            }\\n            if (top < k) stk[top++] = nums[i];\\n        }\\n        return stk;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        Stack<Integer> stk = new Stack<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            while (!stk.isEmpty() && nums[i] < stk.peek() && stk.size() + n - i > k) {\\n                stk.pop();\\n            }\\n            if (stk.size() < k) {\\n                stk.add(nums[i]);                \\n            }\\n        }\\n        int[] ans = new int[k];\\n        for (int i = k - 1; i >= 0; i--) {\\n            ans[i] = num;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n    public int[] mostCompetitive(int[] nums, int k) {\\n\\t\\tint[] stk = new int[k];\\n        int top = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            while (top > 0 && nums[i] < stk[top - 1] && top + n - i > k) {\\n                top--;\\n            }\\n            if (top < k) stk[top++] = nums[i];\\n        }\\n        return stk;\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952788,
                "title": "python-slide-window-and-deque",
                "content": "```\\n        window = len(nums) - k + 1\\n        res, deq = [], deque()\\n        for i in range(len(nums)):\\n            while deq and nums[deq[-1]] > nums[i]:\\n                deq.pop()\\n            deq.append(i)\\n            if i >= window-1:\\n                res.append(nums[deq[0]])\\n                deq.popleft()\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n        window = len(nums) - k + 1\\n        res, deq = [], deque()\\n        for i in range(len(nums)):\\n            while deq and nums[deq[-1]] > nums[i]:\\n                deq.pop()\\n            deq.append(i)\\n            if i >= window-1:\\n                res.append(nums[deq[0]])\\n                deq.popleft()\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952783,
                "title": "python-monotonic-stack",
                "content": "Use a monotonic stack to store only increasing subsequence. Iterate the array and there will be two possible situations for the current element:\\n1. Current element is greater or equal to the last element in the stack, then push current element into the stack if the number of elements we need is not reached yet, \\n2. Otherwise, keep popping elements from the stack, AND make sure the number of elements following the current element is always greater than the number of elements we still need. Finally add the current element to the stack.\\n\\n```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], need: int) -> List[int]:\\n        stk = []\\n        \\n        for i, num in enumerate(nums):\\n            if not stk or stk[-1] <= num:\\n                if need:\\n                    stk.append(num)\\n                    need -= 1\\n            else:\\n                while stk and stk[-1] > num and len(nums) - i > need:\\n                    stk.pop()\\n                    need += 1\\n                    \\n                stk.append(num)\\n                need -= 1\\n             \\n        return stk\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], need: int) -> List[int]:\\n        stk = []\\n        \\n        for i, num in enumerate(nums):\\n            if not stk or stk[-1] <= num:\\n                if need:\\n                    stk.append(num)\\n                    need -= 1\\n            else:\\n                while stk and stk[-1] > num and len(nums) - i > need:\\n                    stk.pop()\\n                    need += 1\\n                    \\n                stk.append(num)\\n                need -= 1\\n             \\n        return stk\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103691,
                "title": "easy-to-understand-javascript-solution-stack",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar mostCompetitive = function(nums, k) {\\n    const stack = [];\\n    const size = nums.length;\\n\\n    for (let index = 0; index < size; index++) {\\n        const num = nums[index];\\n\\n        while (stack.length && num < stack.at(-1) && size - index + stack.length > k) {\\n            stack.pop();\\n        }\\n        stack.length < k && stack.push(num);\\n    }\\n    return stack;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mostCompetitive = function(nums, k) {\\n    const stack = [];\\n    const size = nums.length;\\n\\n    for (let index = 0; index < size; index++) {\\n        const num = nums[index];\\n\\n        while (stack.length && num < stack.at(-1) && size - index + stack.length > k) {\\n            stack.pop();\\n        }\\n        stack.length < k && stack.push(num);\\n    }\\n    return stack;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097852,
                "title": "best-solution-ever-beats-99-in-time-complexity-beats-85-in-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(2n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k){\\n         vector<int>ans;\\n         ans.push_back(nums[0]);\\n         for(int i=1;i<nums.size();i++){\\n              if(nums[i]>=ans.back()&&ans.size()<k) ans.push_back(nums[i]);\\n              else{\\n                   int availablelements=nums.size()-i;\\n                   while(ans.size()&&nums[i]<ans.back()&&nums.size()-i>k-ans.size())ans.pop_back();\\n                   if(ans.size()<k) ans.push_back(nums[i]);\\n              }  \\n         } \\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k){\\n         vector<int>ans;\\n         ans.push_back(nums[0]);\\n         for(int i=1;i<nums.size();i++){\\n              if(nums[i]>=ans.back()&&ans.size()<k) ans.push_back(nums[i]);\\n              else{\\n                   int availablelements=nums.size()-i;\\n                   while(ans.size()&&nums[i]<ans.back()&&nums.size()-i>k-ans.size())ans.pop_back();\\n                   if(ans.size()<k) ans.push_back(nums[i]);\\n              }  \\n         } \\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091113,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n  func mostCompetitive(_ n: [Int], _ k: Int) -> [Int] {\\n    Array(n.indices.reduce(into:[0]) {s,i in while let t=s.last,n[i]<t,s.count+n.count-i-1>k{s.popLast()};s+=[n[i]]}[1...k])\\n  }\\n}\\n```\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func mostCompetitive(_ n: [Int], _ k: Int) -> [Int] {\\n        Array(\\n            n.indices.reduce(into: [Int]()) { stack, i in\\n                while stack.count + n.count - i > k,\\n\\t\\t\\t\\t\\t  let top = stack.last,  n[i] < top {\\n                    stack.popLast()\\n                }\\n                stack.append(n[i])\\n            }\\n            .prefix(k)\\n        )\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n  func mostCompetitive(_ n: [Int], _ k: Int) -> [Int] {\\n    Array(n.indices.reduce(into:[0]) {s,i in while let t=s.last,n[i]<t,s.count+n.count-i-1>k{s.popLast()};s+=[n[i]]}[1...k])\\n  }\\n}\\n```\n```\\nclass Solution {\\n    func mostCompetitive(_ n: [Int], _ k: Int) -> [Int] {\\n        Array(\\n            n.indices.reduce(into: [Int]()) { stack, i in\\n                while stack.count + n.count - i > k,\\n\\t\\t\\t\\t\\t  let top = stack.last,  n[i] < top {\\n                    stack.popLast()\\n                }\\n                stack.append(n[i])\\n            }\\n            .prefix(k)\\n        )\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088345,
                "title": "stortest-monotonic-stack-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int> st;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            while (!st.empty() && nums[i] < st.top() && st.size() + nums.size() - i > k) {\\n                st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        \\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        ans.resize(std::min(k, static_cast<int>(ans.size())));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int> st;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            while (!st.empty() && nums[i] < st.top() && st.size() + nums.size() - i > k) {\\n                st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        \\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        ans.resize(std::min(k, static_cast<int>(ans.size())));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039523,
                "title": "java-linked-list-greedy",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n\\n// I want the first element to be smallest so i chk for that and remove last element from the LL till :\\n//1) till the element at last find as smallest \\n//2) or  till the LL become empty \\n//3) or till the l.size()+ (n-i) > k  so that i must have array of size atleast k \\n    int n=nums.length;\\n    LinkedList<Integer> l= new LinkedList<>();\\n    int i=0; \\n    for(i=0;i<n;i++){ \\n       \\n       if(l.size()>0 && nums[i]<l.peekLast()){ \\n         int cnt=n-i;\\n         while(!l.isEmpty() &&  l.size()+cnt>k &&  nums[i]<l.peekLast()){ \\n            l.removeLast();\\n         }          \\n       }\\nif(l.size()<k){\\nl.add(nums[i]);\\n}\\n    }\\n\\n\\n// System.out.print(l);\\n\\nint arr[]= new int[k];\\ni=0;\\nwhile(!l.isEmpty()){ \\n  arr[i++]=l.removeFirst();\\n}\\n\\nreturn arr;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Linked List",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n\\n// I want the first element to be smallest so i chk for that and remove last element from the LL till :\\n//1) till the element at last find as smallest \\n//2) or  till the LL become empty \\n//3) or till the l.size()+ (n-i) > k  so that i must have array of size atleast k \\n    int n=nums.length;\\n    LinkedList<Integer> l= new LinkedList<>();\\n    int i=0; \\n    for(i=0;i<n;i++){ \\n       \\n       if(l.size()>0 && nums[i]<l.peekLast()){ \\n         int cnt=n-i;\\n         while(!l.isEmpty() &&  l.size()+cnt>k &&  nums[i]<l.peekLast()){ \\n            l.removeLast();\\n         }          \\n       }\\nif(l.size()<k){\\nl.add(nums[i]);\\n}\\n    }\\n\\n\\n// System.out.print(l);\\n\\nint arr[]= new int[k];\\ni=0;\\nwhile(!l.isEmpty()){ \\n  arr[i++]=l.removeFirst();\\n}\\n\\nreturn arr;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030476,
                "title": "using-binary-search-upper-bound-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse Binary Search (Upper Bound) similar to a monotonic stack\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> temp;\\n        int n = nums.size();\\n        for(int i= 0 ;i <nums.size();i++){\\n            if(temp.size() == 0){\\n                temp.push_back(nums[i]);\\n            }\\n            else{\\n\\n                int plus = max(0, (k - n + i));\\n                auto it = upper_bound(temp.begin() + plus, temp.end(), nums[i]);\\n                if(it == temp.end()){\\n                    if(temp.size() < k)\\n                    temp.push_back(nums[i]);\\n                }\\n                else{\\n                    temp.erase(it, temp.end());\\n                    temp.push_back(nums[i]);\\n                }\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> temp;\\n        int n = nums.size();\\n        for(int i= 0 ;i <nums.size();i++){\\n            if(temp.size() == 0){\\n                temp.push_back(nums[i]);\\n            }\\n            else{\\n\\n                int plus = max(0, (k - n + i));\\n                auto it = upper_bound(temp.begin() + plus, temp.end(), nums[i]);\\n                if(it == temp.end()){\\n                    if(temp.size() < k)\\n                    temp.push_back(nums[i]);\\n                }\\n                else{\\n                    temp.erase(it, temp.end());\\n                    temp.push_back(nums[i]);\\n                }\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023547,
                "title": "easy-stack-approach",
                "content": "\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& arr, int k) {\\n        stack<int>st;\\nvector<int> ans;\\n\\n      for(int i=0;i<arr.size();i++){\\n\\n         while(st.size() and st.top()>arr[i] and k-st.size()<arr.size()-i) st.pop();  \\n          if(st.size()<k) st.push(arr[i]);\\n         \\n      }\\n      while(st.size()) {ans.push_back(st.top());st.pop();}\\n      reverse(ans.begin(),ans.end());\\n      return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& arr, int k) {\\n        stack<int>st;\\nvector<int> ans;\\n\\n      for(int i=0;i<arr.size();i++){\\n\\n         while(st.size() and st.top()>arr[i] and k-st.size()<arr.size()-i) st.pop();  \\n          if(st.size()<k) st.push(arr[i]);\\n         \\n      }",
                "codeTag": "Java"
            },
            {
                "id": 4013756,
                "title": "easy-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int> st;\\n        int n = nums.size();\\n\\n        for(int i=0; i<n; i++) {\\n            while((st.size() != 0)  &&  (st.size() + n-i-1 >= k)  &&     (nums[i] < st.top())) {\\n                st.pop();\\n            }\\n            if(st.size() < k) \\n                st.push(nums[i]);\\n        }\\n\\n        vector<int> ans;\\n        while(!st.empty()) {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/b2881168-41cf-4924-943d-1308fac3ea6f_1694083470.5242531.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        stack<int> st;\\n        int n = nums.size();\\n\\n        for(int i=0; i<n; i++) {\\n            while((st.size() != 0)  &&  (st.size() + n-i-1 >= k)  &&     (nums[i] < st.top())) {\\n                st.pop();\\n            }\\n            if(st.size() < k) \\n                st.push(nums[i]);\\n        }\\n\\n        vector<int> ans;\\n        while(!st.empty()) {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964295,
                "title": "java-ugly-but-fastest-one-pass-stack-solution",
                "content": "I tried to see if it\\'s possible if it\\'s possible to further improve on the simple and fast stack solution (of which several very similar versions have been submitted) and I successfully reduced the runtime from 7 ms down to 6 ms.   The downside is that the code is much more complicated now.\\n\\nThe idea is to minimize the minimize the number of comparisons in the main loop, from 3 to 1.  Usually the stack is *not* empty at this point, and usually there are still some elements to delete; once there are none, we can copy over he rest of the array and return.\\n\\n```\\nclass Solution {\\n    public static int[] mostCompetitive(int[] nums, int k) {\\n        int numToDelete = nums.length - k;\\n        if (numToDelete == 0) {\\n            return nums;\\n        }\\n        int[] stack = new int[k];\\n        int stackSize = 0;\\n        stack[stackSize++] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] < stack[stackSize-1]) {\\n                stackSize--;\\n                numToDelete--;\\n                if (numToDelete == 0) {\\n                    System.arraycopy(nums, i, stack, stackSize, k - stackSize);\\n                    return stack;\\n                }\\n                while (\\n                    stackSize != 0 && nums[i] < stack[stackSize-1]\\n                ) {\\n                    stackSize--;\\n                    numToDelete--;\\n                    if (numToDelete == 0) {\\n                        System.arraycopy(nums, i, stack, stackSize, k - stackSize);\\n                        return stack;\\n                    }\\n                }\\n                stack[stackSize++] = nums[i];\\n            } else {\\n                if (stackSize < k) {\\n                    stack[stackSize++] = nums[i];\\n                } else {\\n                    numToDelete--;\\n                    if (numToDelete == 0) {\\n                        System.arraycopy(nums, i, stack, stackSize, k - stackSize);\\n                        return stack;\\n                    }\\n                }\\n            }\\n        }\\n        return stack;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static int[] mostCompetitive(int[] nums, int k) {\\n        int numToDelete = nums.length - k;\\n        if (numToDelete == 0) {\\n            return nums;\\n        }\\n        int[] stack = new int[k];\\n        int stackSize = 0;\\n        stack[stackSize++] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] < stack[stackSize-1]) {\\n                stackSize--;\\n                numToDelete--;\\n                if (numToDelete == 0) {\\n                    System.arraycopy(nums, i, stack, stackSize, k - stackSize);\\n                    return stack;\\n                }\\n                while (\\n                    stackSize != 0 && nums[i] < stack[stackSize-1]\\n                ) {\\n                    stackSize--;\\n                    numToDelete--;\\n                    if (numToDelete == 0) {\\n                        System.arraycopy(nums, i, stack, stackSize, k - stackSize);\\n                        return stack;\\n                    }\\n                }\\n                stack[stackSize++] = nums[i];\\n            } else {\\n                if (stackSize < k) {\\n                    stack[stackSize++] = nums[i];\\n                } else {\\n                    numToDelete--;\\n                    if (numToDelete == 0) {\\n                        System.arraycopy(nums, i, stack, stackSize, k - stackSize);\\n                        return stack;\\n                    }\\n                }\\n            }\\n        }\\n        return stack;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961937,
                "title": "alternative-approach-using-priorityqueue-java-o-nlogn-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int rejectLessthan = -1;\\n        PriorityQueue<Pair> pq = new PriorityQueue<Pair>();\\n        int n=nums.length;\\n        int nextPushIndex = n-k+1;\\n        int out[]=new int[k];\\n        int outindex =0;\\n        for(int i=0;i<=n-k;i++){\\n            pq.add(new Pair(nums[i],i));\\n        }\\n        while(outindex!=k){\\n            while(pq.peek().index<rejectLessthan){\\n                pq.poll();\\n            }\\n            \\n            Pair curr=pq.poll();\\n            out[outindex++]=curr.val;\\n            rejectLessthan=curr.index;\\n            if(nextPushIndex<n)\\n            {\\n                pq.add(new Pair(nums[nextPushIndex],nextPushIndex));\\n                nextPushIndex++;\\n            }\\n            \\n        }\\n\\n        return out;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair> {\\n    int val;\\n    int index;\\n    Pair(int val,int index){\\n        this.val=val;\\n        this.index=index;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair b){\\n        int c = Integer.compare(this.val, b.val);\\n        if (c!=0)\\n            return c;\\n        return Integer.compare(this.index,b.index);\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int rejectLessthan = -1;\\n        PriorityQueue<Pair> pq = new PriorityQueue<Pair>();\\n        int n=nums.length;\\n        int nextPushIndex = n-k+1;\\n        int out[]=new int[k];\\n        int outindex =0;\\n        for(int i=0;i<=n-k;i++){\\n            pq.add(new Pair(nums[i],i));\\n        }\\n        while(outindex!=k){\\n            while(pq.peek().index<rejectLessthan){\\n                pq.poll();\\n            }\\n            \\n            Pair curr=pq.poll();\\n            out[outindex++]=curr.val;\\n            rejectLessthan=curr.index;\\n            if(nextPushIndex<n)\\n            {\\n                pq.add(new Pair(nums[nextPushIndex],nextPushIndex));\\n                nextPushIndex++;\\n            }\\n            \\n        }\\n\\n        return out;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair> {\\n    int val;\\n    int index;\\n    Pair(int val,int index){\\n        this.val=val;\\n        this.index=index;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair b){\\n        int c = Integer.compare(this.val, b.val);\\n        if (c!=0)\\n            return c;\\n        return Integer.compare(this.index,b.index);\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958884,
                "title": "simple-logic-solution-99-99-beat-like-dettol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    take a counter say k, while pushing elements in the stack decrement k, while popping elements increment k, and use the concept of monotonic stack.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        stack<int>st;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty() && nums[i] < st.top() && i<n-k)\\n            {\\n                st.pop();\\n                k++;\\n            }\\n            if(k>0)\\n            {\\n                k--;\\n                st.push(nums[i]);\\n            }\\n        }\\n        int i=1;\\n        n=st.size();\\n        vector<int>res(n,0);\\n        \\n        while(!st.empty())\\n        {\\n            res[n-i]=st.top();\\n            st.pop();\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        stack<int>st;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty() && nums[i] < st.top() && i<n-k)\\n            {\\n                st.pop();\\n                k++;\\n            }\\n            if(k>0)\\n            {\\n                k--;\\n                st.push(nums[i]);\\n            }\\n        }\\n        int i=1;\\n        n=st.size();\\n        vector<int>res(n,0);\\n        \\n        while(!st.empty())\\n        {\\n            res[n-i]=st.top();\\n            st.pop();\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930180,
                "title": "easy-to-understand-tc-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int n = nums.length;\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i =0 ; i<nums.length ; i++){\\n            int num = nums[i];\\n  while(!stack.isEmpty() && stack.peek()>num && n-(i+1) >= k-stack.size()){\\n       stack.pop();\\n  }\\n      if(stack.size()<k){\\n     stack.push(nums[i]);\\n\\n      }\\n        }\\n       int[] arr = new int[k];\\n        for(int i =k-1 ; i>=0 ; i--){\\n           arr[i]=stack.pop();\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n        int n = nums.length;\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i =0 ; i<nums.length ; i++){\\n            int num = nums[i];\\n  while(!stack.isEmpty() && stack.peek()>num && n-(i+1) >= k-stack.size()){\\n       stack.pop();\\n  }\\n      if(stack.size()<k){\\n     stack.push(nums[i]);\\n\\n      }\\n        }\\n       int[] arr = new int[k];\\n        for(int i =k-1 ; i>=0 ; i--){\\n           arr[i]=stack.pop();\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889678,
                "title": "one-pass-stack-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> st;\\n        for(int i=0;i<nums.size();i++){\\n            while(st.size() && st.back()>nums[i] && (nums.size() - i) + st.size()>k) st.pop_back();\\n            if(st.empty() || (st.size()<k)) st.push_back(nums[i]);\\n        }\\n        return st;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> st;\\n        for(int i=0;i<nums.size();i++){\\n            while(st.size() && st.back()>nums[i] && (nums.size() - i) + st.size()>k) st.pop_back();\\n            if(st.empty() || (st.size()<k)) st.push_back(nums[i]);\\n        }\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884893,
                "title": "an-bui",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> result;\\n        stack<int> st;\\n        int number;\\n        for(auto it = nums.begin(); it != nums.end(); it++){\\n            number = *it;\\n            cout <<\"it = \" << number << endl;\\n            \\n            while(!st.empty()){\\n                if(number < st.top()){\\n                    if(st.size() >= k)\\n                        st.pop();\\n                    else{\\n                        if((k - st.size() < (nums.end() - it)))\\n                            st.pop();\\n                        else\\n                            break;\\n                    }\\n                }else{\\n                    break;\\n                }\\n            }\\n            st.push(number);\\n        }\\n        stack<int> newst;\\n        while(!st.empty()){\\n            newst.push(st.top());\\n            st.pop();\\n        }\\n        for(int i = 0; i < k; i++){\\n            result.push_back(newst.top());\\n            newst.pop();\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> result;\\n        stack<int> st;\\n        int number;\\n        for(auto it = nums.begin(); it != nums.end(); it++){\\n            number = *it;\\n            cout <<\"it = \" << number << endl;\\n            \\n            while(!st.empty()){\\n                if(number < st.top()){\\n                    if(st.size() >= k)\\n                        st.pop();\\n                    else{\\n                        if((k - st.size() < (nums.end() - it)))\\n                            st.pop();\\n                        else\\n                            break;\\n                    }\\n                }else{\\n                    break;\\n                }\\n            }\\n            st.push(number);\\n        }\\n        stack<int> newst;\\n        while(!st.empty()){\\n            newst.push(st.top());\\n            st.pop();\\n        }\\n        for(int i = 0; i < k; i++){\\n            result.push_back(newst.top());\\n            newst.pop();\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3884444,
                "title": "an-bui",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> result;\\n        stack<int> st;\\n        int number;\\n        for(auto it = nums.begin(); it != nums.end(); it++){\\n            number = *it;\\n            cout <<\"it = \" << number << endl;\\n            \\n            while(!st.empty()){\\n                if(number < st.top()){\\n                    if(st.size() >= k)\\n                        st.pop();\\n                    else{\\n                        if((k - st.size() < (nums.end() - it)))\\n                            st.pop();\\n                        else\\n                            break;\\n                    }\\n                }else{\\n                    break;\\n                }\\n            }\\n            st.push(number);\\n        }\\n        stack<int> newst;\\n        while(!st.empty()){\\n            newst.push(st.top());\\n            st.pop();\\n        }\\n        for(int i = 0; i < k; i++){\\n            result.push_back(newst.top());\\n            newst.pop();\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> result;\\n        stack<int> st;\\n        int number;\\n        for(auto it = nums.begin(); it != nums.end(); it++){\\n            number = *it;\\n            cout <<\"it = \" << number << endl;\\n            \\n            while(!st.empty()){\\n                if(number < st.top()){\\n                    if(st.size() >= k)\\n                        st.pop();\\n                    else{\\n                        if((k - st.size() < (nums.end() - it)))\\n                            st.pop();\\n                        else\\n                            break;\\n                    }\\n                }else{\\n                    break;\\n                }\\n            }\\n            st.push(number);\\n        }\\n        stack<int> newst;\\n        while(!st.empty()){\\n            newst.push(st.top());\\n            st.pop();\\n        }\\n        for(int i = 0; i < k; i++){\\n            result.push_back(newst.top());\\n            newst.pop();\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3881075,
                "title": "huynh-phong-java-d",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n    int n = nums.length;\\n\\t\\tStack<Integer> stack = new Stack();\\n\\t\\tint x = n - k;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\n\\t\\t\\t// lap cho den khi lasy duoc cac so nho hon num i ra. Va so lan lay ra toi da se\\n\\t\\t\\t// la size array - k\\n\\t\\t\\twhile (!stack.isEmpty() && nums[i] < stack.peek() && x > 0) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\tx--;\\n\\t\\t\\t}\\n\\t\\t\\tstack.push(nums[i]);\\n\\n//\\t\\t\\tSystem.out.println(stack);\\n\\n\\t\\t}\\n\\t\\tSystem.out.print(stack);\\n\\t\\tint[] result = new int[k];\\n\\t\\tint j = k - 1;\\n\\n\\t\\twhile (!stack.isEmpty() && j >= 0) {\\n\\t\\t\\tif (stack.size() > k) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult[j] = stack.pop();\\n\\t\\t\\t\\tSystem.out.println(result[j]);\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] mostCompetitive(int[] nums, int k) {\\n    int n = nums.length;\\n\\t\\tStack<Integer> stack = new Stack();\\n\\t\\tint x = n - k;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\n\\t\\t\\t// lap cho den khi lasy duoc cac so nho hon num i ra. Va so lan lay ra toi da se\\n\\t\\t\\t// la size array - k\\n\\t\\t\\twhile (!stack.isEmpty() && nums[i] < stack.peek() && x > 0) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\tx--;\\n\\t\\t\\t}\\n\\t\\t\\tstack.push(nums[i]);\\n\\n//\\t\\t\\tSystem.out.println(stack);\\n\\n\\t\\t}\\n\\t\\tSystem.out.print(stack);\\n\\t\\tint[] result = new int[k];\\n\\t\\tint j = k - 1;\\n\\n\\t\\twhile (!stack.isEmpty() && j >= 0) {\\n\\t\\t\\tif (stack.size() > k) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult[j] = stack.pop();\\n\\t\\t\\t\\tSystem.out.println(result[j]);\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869570,
                "title": "typescript-o-n-o-k",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nfunction mostCompetitive(nums: number[], k: number): number[] {\\n  const stack = [];\\n  \\n  for(let i = 0; i < nums.length; i++) {\\n    while(\\n      stack.length > 0\\n      && stack[stack.length - 1] > nums[i]\\n      && haveEnoughNumsToCreateSequence(stack.length, nums.length - i, k)\\n    ) {\\n      stack.pop();\\n    }\\n\\n    if(stack.length < k) {\\n      stack.push(nums[i])\\n    }\\n  }\\n\\n  return stack;\\n\\n};\\n\\nfunction haveEnoughNumsToCreateSequence(stackLength: number, restLength: number, k: number) {\\n  return stackLength - 1 + restLength >= k\\n}\\n\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction mostCompetitive(nums: number[], k: number): number[] {\\n  const stack = [];\\n  \\n  for(let i = 0; i < nums.length; i++) {\\n    while(\\n      stack.length > 0\\n      && stack[stack.length - 1] > nums[i]\\n      && haveEnoughNumsToCreateSequence(stack.length, nums.length - i, k)\\n    ) {\\n      stack.pop();\\n    }\\n\\n    if(stack.length < k) {\\n      stack.push(nums[i])\\n    }\\n  }\\n\\n  return stack;\\n\\n};\\n\\nfunction haveEnoughNumsToCreateSequence(stackLength: number, restLength: number, k: number) {\\n  return stackLength - 1 + restLength >= k\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3862901,
                "title": "by-using-priority-queue-with-beats-93-93-in-memory",
                "content": "# Intuition\\nAs We have to return competitive subsequence of nums of size k where its should conatin minmium but at min sholud be given priorty at at starting index so,from this we get to know we need max-heap\\n\\n# Approach\\nwe will maintain max heap. we will check to remove/poll()\\nis if the remaining arr element and elements conatin by heap is will become k size if yes then we will remove till nums[i]<pq.peek().val or k size maintain this way min element will we at smallest index\\n\\n# Complexity\\n- Time complexity:\\nworst case:O(k*n)\\n\\nbest case:O(n)\\n\\n- Space complexity:\\nwe are using PriorityQueue we will amintain of k size so,\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\n    static private class Node{\\n        int val;\\n        int idx;\\n        Node(int val,int idx){\\n            this.val=val;\\n            this.idx=idx;\\n        }\\n    }\\n    private static class Compare implements Comparator<Node>{\\n\\n        @Override\\n        public int compare(Node o1, Node o2) {\\n            if(o1.val== o2.val){\\n                return o2.idx- o1.idx;\\n            }else{\\n                return o2.val-o1.val;\\n            }\\n        }\\n    }\\n    public int[] mostCompetitive(int[] nums, int k) {\\n         int n=nums.length;\\n        PriorityQueue<Node> pq=new  PriorityQueue<>(new Compare());\\n        for(int i=0;i<n;i++){\\n            if((pq.size()+n-i)>k){\\n                while(!pq.isEmpty()&&(pq.size()+n-i)>k&&pq.peek().val>nums[i]){\\n                    pq.poll();\\n                }\\n                if(pq.size()<k){\\n                    Node nn=new Node(nums[i],i);\\n                    pq.add(nn);\\n                }\\n            }else{\\n                Node nn=new Node(nums[i],i);\\n                pq.add(nn);\\n            }\\n        }\\n        int[] arr=new int[k];\\n        int i=0;\\n        while(!pq.isEmpty()){\\n            arr[i]=pq.poll().idx;\\n            i++;\\n        }\\n        Arrays.sort(arr);\\n        for(i=0;i<k;i++){\\n            arr[i]=nums[arr[i]];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    static private class Node{\\n        int val;\\n        int idx;\\n        Node(int val,int idx){\\n            this.val=val;\\n            this.idx=idx;\\n        }\\n    }\\n    private static class Compare implements Comparator<Node>{\\n\\n        @Override\\n        public int compare(Node o1, Node o2) {\\n            if(o1.val== o2.val){\\n                return o2.idx- o1.idx;\\n            }else{\\n                return o2.val-o1.val;\\n            }\\n        }\\n    }\\n    public int[] mostCompetitive(int[] nums, int k) {\\n         int n=nums.length;\\n        PriorityQueue<Node> pq=new  PriorityQueue<>(new Compare());\\n        for(int i=0;i<n;i++){\\n            if((pq.size()+n-i)>k){\\n                while(!pq.isEmpty()&&(pq.size()+n-i)>k&&pq.peek().val>nums[i]){\\n                    pq.poll();\\n                }\\n                if(pq.size()<k){\\n                    Node nn=new Node(nums[i],i);\\n                    pq.add(nn);\\n                }\\n            }else{\\n                Node nn=new Node(nums[i],i);\\n                pq.add(nn);\\n            }\\n        }\\n        int[] arr=new int[k];\\n        int i=0;\\n        while(!pq.isEmpty()){\\n            arr[i]=pq.poll().idx;\\n            i++;\\n        }\\n        Arrays.sort(arr);\\n        for(i=0;i<k;i++){\\n            arr[i]=nums[arr[i]];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850725,
                "title": "python-heap-sorting",
                "content": "# Intuition\\n- We will add in all the elements with indices in the heap\\n- Post that we first remove the smallest element and mark the index start, beecause it is a subseq, we will need only elements post the start index\\n\\n# Approach\\n- With heap by storing both the value and the index\\n\\n# Complexity\\n**Time complexity:**\\n- O(NlogN)\\n\\n**Space complexity:**\\n- O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        def solve(nums,k):\\n            res = []\\n            heap = []\\n            start = -1\\n            for i in range(len(nums)-k+1):\\n                heapq.heappush(heap,(nums[i],i))\\n            stop = len(nums)-k\\n            while k > 0:\\n                ele = heapq.heappop(heap)\\n                while ele[1] < start:\\n                    ele=heapq.heappop(heap)\\n                res.append(ele[0])\\n                if stop+1 < len(nums):\\n                    heapq.heappush(heap,(nums[stop+1],stop+1))\\n                    stop+=1\\n                start = ele[1]\\n                k-=1\\n            return res\\n        return solve(nums,k)\\n        # return [2,2]\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\\n        def solve(nums,k):\\n            res = []\\n            heap = []\\n            start = -1\\n            for i in range(len(nums)-k+1):\\n                heapq.heappush(heap,(nums[i],i))\\n            stop = len(nums)-k\\n            while k > 0:\\n                ele = heapq.heappop(heap)\\n                while ele[1] < start:\\n                    ele=heapq.heappop(heap)\\n                res.append(ele[0])\\n                if stop+1 < len(nums):\\n                    heapq.heappush(heap,(nums[stop+1],stop+1))\\n                    stop+=1\\n                start = ele[1]\\n                k-=1\\n            return res\\n        return solve(nums,k)\\n        # return [2,2]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574981,
                "content": [
                    {
                        "username": "salyela",
                        "content": "I actually do not understand the question. At first I thought I need to keep the smallest values or the largest values, but clearly that\\'s not the case otherwise the first answer couldn\\'t be [2,6]. But then what really threw me off was the answer to the second example. Can someone please explain the problem differently?"
                    },
                    {
                        "username": "prcsnlvr",
                        "content": "It might help to think of it instead as an array of chars and you\\'re trying to create the lexicographically smallest subsequence. So for the first example [2,6] is smaller than any other subsequence simply because it starts with 2. If you\\'re comparing the words \"axe\" and \"bad\", \"axe\" is before \"bad\" because \\'a\\' < \\'b\\'. It doesn\\'t matter that \\'x\\' > \\'a\\'."
                    },
                    {
                        "username": "ArcticCatfish",
                        "content": "it is similar to leetcode 402 : remove k digits. just like choose k digit and remove (len(nums)-k) digit to make the concatenate of the subarray smallest.  this is my explanation for that problem:https://leetcode.com/problems/remove-k-digits/solutions/3797104/explanation-for-beginners-like-me/"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The use of deque in official solution is misleading. The main algorithm can be done with stack only (pollLast and peekLast). The pollFirst and peekFirst is used only in creating the return, which is separate from main algorithm and can be done with stack too."
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s easier to comprehend with deque"
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "Dont say anything about lexical order because when number is:\\n[71,18,52,29,55,73,24,42,66,8,80,2] k = 3 \\nanswer is [8, 80, 2] "
                    },
                    {
                        "username": "zendemion",
                        "content": "It\\'s lexical order but with an alphabet of 10^9 characters"
                    },
                    {
                        "username": "om_golhani",
                        "content": "[8,80,2] is absolutely correct for given testcase, As we want to build the \"SUBSEQUENCE\" of 3 elements with lowest lexicographical order."
                    }
                ]
            },
            {
                "id": 1980063,
                "content": [
                    {
                        "username": "salyela",
                        "content": "I actually do not understand the question. At first I thought I need to keep the smallest values or the largest values, but clearly that\\'s not the case otherwise the first answer couldn\\'t be [2,6]. But then what really threw me off was the answer to the second example. Can someone please explain the problem differently?"
                    },
                    {
                        "username": "prcsnlvr",
                        "content": "It might help to think of it instead as an array of chars and you\\'re trying to create the lexicographically smallest subsequence. So for the first example [2,6] is smaller than any other subsequence simply because it starts with 2. If you\\'re comparing the words \"axe\" and \"bad\", \"axe\" is before \"bad\" because \\'a\\' < \\'b\\'. It doesn\\'t matter that \\'x\\' > \\'a\\'."
                    },
                    {
                        "username": "ArcticCatfish",
                        "content": "it is similar to leetcode 402 : remove k digits. just like choose k digit and remove (len(nums)-k) digit to make the concatenate of the subarray smallest.  this is my explanation for that problem:https://leetcode.com/problems/remove-k-digits/solutions/3797104/explanation-for-beginners-like-me/"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The use of deque in official solution is misleading. The main algorithm can be done with stack only (pollLast and peekLast). The pollFirst and peekFirst is used only in creating the return, which is separate from main algorithm and can be done with stack too."
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s easier to comprehend with deque"
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "Dont say anything about lexical order because when number is:\\n[71,18,52,29,55,73,24,42,66,8,80,2] k = 3 \\nanswer is [8, 80, 2] "
                    },
                    {
                        "username": "zendemion",
                        "content": "It\\'s lexical order but with an alphabet of 10^9 characters"
                    },
                    {
                        "username": "om_golhani",
                        "content": "[8,80,2] is absolutely correct for given testcase, As we want to build the \"SUBSEQUENCE\" of 3 elements with lowest lexicographical order."
                    }
                ]
            },
            {
                "id": 1763963,
                "content": [
                    {
                        "username": "salyela",
                        "content": "I actually do not understand the question. At first I thought I need to keep the smallest values or the largest values, but clearly that\\'s not the case otherwise the first answer couldn\\'t be [2,6]. But then what really threw me off was the answer to the second example. Can someone please explain the problem differently?"
                    },
                    {
                        "username": "prcsnlvr",
                        "content": "It might help to think of it instead as an array of chars and you\\'re trying to create the lexicographically smallest subsequence. So for the first example [2,6] is smaller than any other subsequence simply because it starts with 2. If you\\'re comparing the words \"axe\" and \"bad\", \"axe\" is before \"bad\" because \\'a\\' < \\'b\\'. It doesn\\'t matter that \\'x\\' > \\'a\\'."
                    },
                    {
                        "username": "ArcticCatfish",
                        "content": "it is similar to leetcode 402 : remove k digits. just like choose k digit and remove (len(nums)-k) digit to make the concatenate of the subarray smallest.  this is my explanation for that problem:https://leetcode.com/problems/remove-k-digits/solutions/3797104/explanation-for-beginners-like-me/"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The use of deque in official solution is misleading. The main algorithm can be done with stack only (pollLast and peekLast). The pollFirst and peekFirst is used only in creating the return, which is separate from main algorithm and can be done with stack too."
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s easier to comprehend with deque"
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "Dont say anything about lexical order because when number is:\\n[71,18,52,29,55,73,24,42,66,8,80,2] k = 3 \\nanswer is [8, 80, 2] "
                    },
                    {
                        "username": "zendemion",
                        "content": "It\\'s lexical order but with an alphabet of 10^9 characters"
                    },
                    {
                        "username": "om_golhani",
                        "content": "[8,80,2] is absolutely correct for given testcase, As we want to build the \"SUBSEQUENCE\" of 3 elements with lowest lexicographical order."
                    }
                ]
            },
            {
                "id": 1820043,
                "content": [
                    {
                        "username": "salyela",
                        "content": "I actually do not understand the question. At first I thought I need to keep the smallest values or the largest values, but clearly that\\'s not the case otherwise the first answer couldn\\'t be [2,6]. But then what really threw me off was the answer to the second example. Can someone please explain the problem differently?"
                    },
                    {
                        "username": "prcsnlvr",
                        "content": "It might help to think of it instead as an array of chars and you\\'re trying to create the lexicographically smallest subsequence. So for the first example [2,6] is smaller than any other subsequence simply because it starts with 2. If you\\'re comparing the words \"axe\" and \"bad\", \"axe\" is before \"bad\" because \\'a\\' < \\'b\\'. It doesn\\'t matter that \\'x\\' > \\'a\\'."
                    },
                    {
                        "username": "ArcticCatfish",
                        "content": "it is similar to leetcode 402 : remove k digits. just like choose k digit and remove (len(nums)-k) digit to make the concatenate of the subarray smallest.  this is my explanation for that problem:https://leetcode.com/problems/remove-k-digits/solutions/3797104/explanation-for-beginners-like-me/"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The use of deque in official solution is misleading. The main algorithm can be done with stack only (pollLast and peekLast). The pollFirst and peekFirst is used only in creating the return, which is separate from main algorithm and can be done with stack too."
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s easier to comprehend with deque"
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "Dont say anything about lexical order because when number is:\\n[71,18,52,29,55,73,24,42,66,8,80,2] k = 3 \\nanswer is [8, 80, 2] "
                    },
                    {
                        "username": "zendemion",
                        "content": "It\\'s lexical order but with an alphabet of 10^9 characters"
                    },
                    {
                        "username": "om_golhani",
                        "content": "[8,80,2] is absolutely correct for given testcase, As we want to build the \"SUBSEQUENCE\" of 3 elements with lowest lexicographical order."
                    }
                ]
            }
        ]
    }
]