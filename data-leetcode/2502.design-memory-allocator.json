[
    {
        "title": "Design Memory Allocator",
        "question_content": "You are given an integer n representing the size of a 0-indexed memory array. All memory units are initially free.\nYou have a memory allocator with the following functionalities:\n\n\tAllocate a block of size consecutive free memory units and assign it the id mID.\n\tFree all memory units with the given id mID.\n\nNote that:\n\n\tMultiple blocks can be allocated to the same mID.\n\tYou should free all the memory units with mID, even if they were allocated in different blocks.\n\nImplement the Allocator class:\n\n\tAllocator(int n) Initializes an Allocator object with a memory array of size n.\n\tint allocate(int size, int mID) Find the leftmost block of size consecutive free memory units and allocate it with the id mID. Return the block's first index. If such a block does not exist, return -1.\n\tint free(int mID) Free all memory units with the id mID. Return the number of memory units you have freed.\n\n&nbsp;\nExample 1:\n\nInput\n[\"Allocator\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"free\"]\n[[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]]\nOutput\n[null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]\nExplanation\nAllocator loc = new Allocator(10); // Initialize a memory array of size 10. All memory units are initially free.\nloc.allocate(1, 1); // The leftmost block's first index is 0. The memory array becomes [1,_,_,_,_,_,_,_,_,_]. We return 0.\nloc.allocate(1, 2); // The leftmost block's first index is 1. The memory array becomes [1,2,_,_,_,_,_,_,_,_]. We return 1.\nloc.allocate(1, 3); // The leftmost block's first index is 2. The memory array becomes [1,2,3,_,_,_,_,_,_,_]. We return 2.\nloc.free(2); // Free all memory units with mID 2. The memory array becomes [1,_, 3,_,_,_,_,_,_,_]. We return 1 since there is only 1 unit with mID 2.\nloc.allocate(3, 4); // The leftmost block's first index is 3. The memory array becomes [1,_,3,4,4,4,_,_,_,_]. We return 3.\nloc.allocate(1, 1); // The leftmost block's first index is 1. The memory array becomes [1,1,3,4,4,4,_,_,_,_]. We return 1.\nloc.allocate(1, 1); // The leftmost block's first index is 6. The memory array becomes [1,1,3,4,4,4,1,_,_,_]. We return 6.\nloc.free(1); // Free all memory units with mID 1. The memory array becomes [_,_,3,4,4,4,_,_,_,_]. We return 3 since there are 3 units with mID 1.\nloc.allocate(10, 2); // We can not find any free block with 10 consecutive free memory units, so we return -1.\nloc.free(7); // Free all memory units with mID 7. The memory array remains the same since there is no memory unit with mID 7. We return 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= n, size, mID <= 1000\n\tAt most 1000 calls will be made to allocate and free.",
        "solutions": [
            {
                "id": 2899668,
                "title": "two-maps",
                "content": "A brute-force solution (store `mID` in array and do full scans) is AC due to `n` constraitned to `1,000`.\\n\\nIt won\\'t work for any practical memory size. \\n\\nHere, we track the available memory intervals in a sorted map `avail`, and allocated chunks in a hash map `alloc`.\\n\\nSince `avail` is sorted, we go left-to-right to find the smallest index of a chunk with the requried size.\\n\\n> We could use something like segment tree to find the smallest index faster.\\n\\nWhen we free the memory, we join all chunks back into `avail`.\\n\\n**C++**\\n```cpp\\nunordered_map<int, vector<pair<int, int>>> alloc;\\nmap<int, int> avail;\\nAllocator(int n) { avail.insert({0, n}); }\\nint allocate(int size, int mID) {\\n    for (auto it = begin(avail); it != end(avail); ++it) {\\n        if (it->second >= size) {\\n            auto [i, i_sz] = *it;\\n            alloc[mID].push_back({i, size});\\n            avail.erase(it);\\n            if (i_sz > size) {\\n                avail.insert({i + size, i_sz - size});\\n            }\\n            return i;\\n        }\\n    }\\n    return -1;\\n}\\nint free(int mID) {\\n    int res = 0;\\n    if (auto it = alloc.find(mID); it != end(alloc)) {\\n        for (auto [i, sz] : it->second) {\\n            auto ita = avail.insert({i, sz}).first;\\n            if (ita != begin(avail)) {\\n                if (auto p = prev(ita); p->first + p->second == i) {\\n                    p->second += sz;\\n                    avail.erase(ita);\\n                    ita = p;\\n                }\\n            }\\n            if (next(ita) != end(avail)) {\\n                if (auto n = next(ita); i + sz == n->first) {\\n                    ita->second += n->second;\\n                    avail.erase(n);\\n                }\\n            }\\n            res += sz;\\n        }\\n        alloc.erase(it);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nunordered_map<int, vector<pair<int, int>>> alloc;\\nmap<int, int> avail;\\nAllocator(int n) { avail.insert({0, n}); }\\nint allocate(int size, int mID) {\\n    for (auto it = begin(avail); it != end(avail); ++it) {\\n        if (it->second >= size) {\\n            auto [i, i_sz] = *it;\\n            alloc[mID].push_back({i, size});\\n            avail.erase(it);\\n            if (i_sz > size) {\\n                avail.insert({i + size, i_sz - size});\\n            }\\n            return i;\\n        }\\n    }\\n    return -1;\\n}\\nint free(int mID) {\\n    int res = 0;\\n    if (auto it = alloc.find(mID); it != end(alloc)) {\\n        for (auto [i, sz] : it->second) {\\n            auto ita = avail.insert({i, sz}).first;\\n            if (ita != begin(avail)) {\\n                if (auto p = prev(ita); p->first + p->second == i) {\\n                    p->second += sz;\\n                    avail.erase(ita);\\n                    ita = p;\\n                }\\n            }\\n            if (next(ita) != end(avail)) {\\n                if (auto n = next(ita); i + sz == n->first) {\\n                    ita->second += n->second;\\n                    avail.erase(n);\\n                }\\n            }\\n            res += sz;\\n        }\\n        alloc.erase(it);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2899438,
                "title": "python-brute-force",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n\\n\\n**Python.**\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.mem = [-1] * n\\n        self.blocks = defaultdict(list)\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        cnt = 0\\n        for i in range(len(self.mem)):\\n            if self.mem[i] == -1: \\n                cnt += 1\\n            else:\\n                cnt = 0\\n            if cnt == size:\\n                self.mem[i+1-cnt:i+1] = [mID] * cnt\\n                self.blocks[mID].extend(list(range(i+1-cnt,i+1)))\\n                return i+1-cnt\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        r = len(self.blocks[mID])\\n        for i in self.blocks[mID]:\\n            self.mem[i] = -1\\n        self.blocks[mID] = []\\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.mem = [-1] * n\\n        self.blocks = defaultdict(list)\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        cnt = 0\\n        for i in range(len(self.mem)):\\n            if self.mem[i] == -1: \\n                cnt += 1\\n            else:\\n                cnt = 0\\n            if cnt == size:\\n                self.mem[i+1-cnt:i+1] = [mID] * cnt\\n                self.blocks[mID].extend(list(range(i+1-cnt,i+1)))\\n                return i+1-cnt\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        r = len(self.blocks[mID])\\n        for i in self.blocks[mID]:\\n            self.mem[i] = -1\\n        self.blocks[mID] = []\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899383,
                "title": "c-simple-iterative-using-vector-very-simple-and-easy-to-understand",
                "content": "\\n```\\nclass Allocator {\\npublic:\\n    \\n    vector<int> v;\\n    Allocator(int n) {\\n        v.resize(n, 0);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int start = -1, count = 0;\\n        for(int i = 0; i < v.size(); ++i){\\n            if(v[i] == 0){\\n                if(count == 0) start = i;\\n                count++;\\n                if(count >= size ) {\\n                    for(int j = 0; j < count; ++j){\\n                        v[start + j] = mID;\\n                    }\\n                    return start;\\n                }\\n            }else{\\n                start = -1;\\n                count = 0;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int sz = 0;\\n        for(int i=0; i < v.size(); ++i){\\n            if(v[i] == mID) {\\n                sz++;\\n                v[i] = 0;\\n            }\\n        }\\n        return sz;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    \\n    vector<int> v;\\n    Allocator(int n) {\\n        v.resize(n, 0);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int start = -1, count = 0;\\n        for(int i = 0; i < v.size(); ++i){\\n            if(v[i] == 0){\\n                if(count == 0) start = i;\\n                count++;\\n                if(count >= size ) {\\n                    for(int j = 0; j < count; ++j){\\n                        v[start + j] = mID;\\n                    }\\n                    return start;\\n                }\\n            }else{\\n                start = -1;\\n                count = 0;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int sz = 0;\\n        for(int i=0; i < v.size(); ++i){\\n            if(v[i] == mID) {\\n                sz++;\\n                v[i] = 0;\\n            }\\n        }\\n        return sz;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899358,
                "title": "c-sliding-window-very-easy-solution",
                "content": "```\\n\\nclass Allocator {\\npublic:\\n    vector<int>arr;\\n    Allocator(int n) {\\n        arr.resize(n,0); //0 means free space\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int j=0;\\n        int count=0;\\n        int flag=0;\\n        for(int i=0;i<arr.size();i++)//appling sliding window\\n        {\\n           if(arr[i]==0) \\n           {\\n               count++;\\n               if(count==size)\\n               {\\n                   flag=1;\\n                   break;\\n               }\\n           }\\n            else {\\n                count=0;\\n                j=i+1;\\n            }\\n        }\\n        if(flag)\\n        {\\n            for(int i=j;i<=j+size-1;i++)\\n                arr[i]=mID;\\n            \\n            return j;\\n        }\\n        else return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int count=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]==mID)\\n            {\\n                count++;\\n                arr[i]=0;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n\\nclass Allocator {\\npublic:\\n    vector<int>arr;\\n    Allocator(int n) {\\n        arr.resize(n,0); //0 means free space\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int j=0;\\n        int count=0;\\n        int flag=0;\\n        for(int i=0;i<arr.size();i++)//appling sliding window\\n        {\\n           if(arr[i]==0) \\n           {\\n               count++;\\n               if(count==size)\\n               {\\n                   flag=1;\\n                   break;\\n               }\\n           }\\n            else {\\n                count=0;\\n                j=i+1;\\n            }\\n        }\\n        if(flag)\\n        {\\n            for(int i=j;i<=j+size-1;i++)\\n                arr[i]=mID;\\n            \\n            return j;\\n        }\\n        else return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int count=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]==mID)\\n            {\\n                count++;\\n                arr[i]=0;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2902331,
                "title": "java-treemap-merge-interval-brute-force-12ms-range-module",
                "content": "PLEASE UPVOTE IF YOU FIND THIS POST HELPFUL, THANKS!\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Use TreeMaps to track ranges of each mID, including mID = 0 which represents free memories\\n- Both free and allocated memories can have mulitple segments\\n    - For one time allocation, memory must be consecutive, but there can be mulitple allocations to one mID to create segments\\n- Allocate: remove a range from free memory and insert it into allocated memory\\n- Free: remove all ranges (intervals) for a mID, and insert them into free memory TreeMap one by one\\n- All insert require merge considerations which is same as problem: [715. Range Module](https://leetcode.com/problems/range-module/description/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRefer to intuition\\n\\n# Complexity\\n- Time complexity: to add\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: to add\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n[12ms](https://leetcode.com/problems/design-memory-allocator/submissions/858284993/)\\n```java\\nclass Allocator {\\n    private TreeMap<Integer, Integer>[] m = new TreeMap[1001]; // Track all allocations for each mID, use array for convienience, should use real map\\n    public Allocator(int n) {\\n        m[0] = new TreeMap<>(); // 0 means free, positive # means allocations to a valid mID\\n        m[0].put(0, n); // [0, n)\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int start = -1;\\n        // loop through all available ranges to find the first available\\n        // use it, if there\\'s range left, save\\n        for (var e : m[0].entrySet()) {\\n            int l = e.getKey(), r = e.getValue(); // l and right bound\\n            if (r-l >= size) { // found the leftmost free space\\n                start = l;\\n                m[0].remove(l);\\n                if (r - l > size) m[0].put(l+size, r); // if there\\'s space left after allocation, save it\\n                // add new range into TreeMap of mID, with merge logic\\n                insert(mID, start, start+size);\\n                // System.out.printf(\"m[%d](New Size: %d): %s\\\\nm[0]: %s\\\\n\", mID, size, m[mID], m[0]);\\n                return start;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n    \\n    public int free(int mID) {\\n        if (m[mID] == null) return 0;\\n\\n        // free all ranges\\n        int size = 0;\\n        for (var e : m[mID].entrySet()) {\\n            size += e.getValue() - e.getKey();\\n            insert(0, e.getKey(), e.getValue()); // recover free space, with merge logic\\n        }\\n        m[mID].clear();\\n\\n        // System.out.printf(\"To free m[%d]: %s, m[0]: %s\\\\n\", mID, m[mID], m[0]);\\n        return size;\\n    }\\n\\n    private void insert(int mID, int s, int e) { // s: start, e: end\\n        if (m[mID] == null) m[mID] = new TreeMap<>();\\n        // found overlap ranges, calc merged range, clear overlapped ranges, insert merged range\\n        var L = m[mID].floorEntry(s); // left possible overlap entry\\n        var R = m[mID].floorEntry(e); // right possible overlap entry\\n\\n        if (L != null && L.getValue() >= s) s = L.getKey(); // update overlap start\\n        if (R != null && R.getValue() > e) e = R.getValue(); // update overlap end\\n\\n        m[mID].subMap(s, e).clear(); // clear all overlapped entries\\n        m[mID].put(s, e); // save final merged entry\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```\\n\\n# Optimize free with map (mid -> List of ranges)\\n[23ms](https://leetcode.com/problems/design-memory-allocator/submissions/858262622/)\\n```java\\nclass Allocator {\\n    record Node (int l, int r) {}\\n\\n    private boolean[] a; // certain area of memory is allocated or not\\n    private List<Node>[] m = new List[1001]; // Track all allocations for each mID\\n    public Allocator(int n) {\\n        a = new boolean[n];\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int l = findFirstAvailable(size);\\n        if (l == -1) return -1;\\n        // find the list of memories allocated for this mID\\n        if (m[mID] == null) m[mID] = new ArrayList<>(); // if new, create the empty memList for this mID\\n        m[mID].add(new Node(l, l+size)); // append to memList allocated to this mID\\n\\n        // allocate memory\\n        for (int i = l, r=l+size; i < r; i++) a[i] = true;\\n        return l;\\n    }\\n    \\n    public int free(int mID) {\\n        if (m[mID] == null) return 0;\\n        int size = 0;\\n        for (var node : m[mID]) { // free all memory allocated to this mID\\n            size += node.r - node.l;\\n            for (int i = node.l; i < node.r; i++) a[i] = false; // free memory\\n        }\\n        m[mID].clear(); // this mID is gone\\n        return size;\\n    }\\n\\n    private int findFirstAvailable(int size) {\\n        for (int i = 0; i <= a.length - size;) {\\n            int j = i, r = i+size;\\n            for (; j < r; j++) if (a[j]) {i = -1; break;} // true is allocated, so can\\'t be used, we go to next section\\n            if (i == -1) i = j + 1;\\n            else return i;\\n        }\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```\\n\\n# Brute Force simulation\\n24 ms\\n- TC:\\n    - Allocate: Worst: O(1000)\\n    - Actual run time is likely better\\n    - Free: O(1000)\\n- SC: O(1000)\\n```java\\nclass Allocator {\\n    private int[] a; // THE MEMORY\\n    public Allocator(int n) {\\n        a = new int[n];\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        for (int i = 0; i <= a.length - size;) { // starting from 0 to search for consecutive free space\\n            int j = i, r = i+size; // range we need to search for every starting point\\n            for (; j < r; j++) if (a[j] != 0) {i = -1; break;} // a[j] != 0 means it\\'s used, i = -1: not found\\n            if (i != -1) { // i != -1 means found free space of size, starting at i\\n                for (j = i; j < r; j++) a[j] = mID; // allocate\\n                return i; // return starting index\\n            } else i = j+1; // when not found that means from i to j are not good, starting next search from j+1\\n        }\\n\\n        return -1; // couldn\\'t find the the consecutive space needed\\n    }\\n    \\n    public int free(int mID) {\\n        int size = 0;\\n        for (int i = 0; i < a.length; i++)\\n            if (a[i] == mID) {a[i] = 0;size++;}\\n        return size;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Allocator {\\n    private TreeMap<Integer, Integer>[] m = new TreeMap[1001]; // Track all allocations for each mID, use array for convienience, should use real map\\n    public Allocator(int n) {\\n        m[0] = new TreeMap<>(); // 0 means free, positive # means allocations to a valid mID\\n        m[0].put(0, n); // [0, n)\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int start = -1;\\n        // loop through all available ranges to find the first available\\n        // use it, if there\\'s range left, save\\n        for (var e : m[0].entrySet()) {\\n            int l = e.getKey(), r = e.getValue(); // l and right bound\\n            if (r-l >= size) { // found the leftmost free space\\n                start = l;\\n                m[0].remove(l);\\n                if (r - l > size) m[0].put(l+size, r); // if there\\'s space left after allocation, save it\\n                // add new range into TreeMap of mID, with merge logic\\n                insert(mID, start, start+size);\\n                // System.out.printf(\"m[%d](New Size: %d): %s\\\\nm[0]: %s\\\\n\", mID, size, m[mID], m[0]);\\n                return start;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n    \\n    public int free(int mID) {\\n        if (m[mID] == null) return 0;\\n\\n        // free all ranges\\n        int size = 0;\\n        for (var e : m[mID].entrySet()) {\\n            size += e.getValue() - e.getKey();\\n            insert(0, e.getKey(), e.getValue()); // recover free space, with merge logic\\n        }\\n        m[mID].clear();\\n\\n        // System.out.printf(\"To free m[%d]: %s, m[0]: %s\\\\n\", mID, m[mID], m[0]);\\n        return size;\\n    }\\n\\n    private void insert(int mID, int s, int e) { // s: start, e: end\\n        if (m[mID] == null) m[mID] = new TreeMap<>();\\n        // found overlap ranges, calc merged range, clear overlapped ranges, insert merged range\\n        var L = m[mID].floorEntry(s); // left possible overlap entry\\n        var R = m[mID].floorEntry(e); // right possible overlap entry\\n\\n        if (L != null && L.getValue() >= s) s = L.getKey(); // update overlap start\\n        if (R != null && R.getValue() > e) e = R.getValue(); // update overlap end\\n\\n        m[mID].subMap(s, e).clear(); // clear all overlapped entries\\n        m[mID].put(s, e); // save final merged entry\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```\n```java\\nclass Allocator {\\n    record Node (int l, int r) {}\\n\\n    private boolean[] a; // certain area of memory is allocated or not\\n    private List<Node>[] m = new List[1001]; // Track all allocations for each mID\\n    public Allocator(int n) {\\n        a = new boolean[n];\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int l = findFirstAvailable(size);\\n        if (l == -1) return -1;\\n        // find the list of memories allocated for this mID\\n        if (m[mID] == null) m[mID] = new ArrayList<>(); // if new, create the empty memList for this mID\\n        m[mID].add(new Node(l, l+size)); // append to memList allocated to this mID\\n\\n        // allocate memory\\n        for (int i = l, r=l+size; i < r; i++) a[i] = true;\\n        return l;\\n    }\\n    \\n    public int free(int mID) {\\n        if (m[mID] == null) return 0;\\n        int size = 0;\\n        for (var node : m[mID]) { // free all memory allocated to this mID\\n            size += node.r - node.l;\\n            for (int i = node.l; i < node.r; i++) a[i] = false; // free memory\\n        }\\n        m[mID].clear(); // this mID is gone\\n        return size;\\n    }\\n\\n    private int findFirstAvailable(int size) {\\n        for (int i = 0; i <= a.length - size;) {\\n            int j = i, r = i+size;\\n            for (; j < r; j++) if (a[j]) {i = -1; break;} // true is allocated, so can\\'t be used, we go to next section\\n            if (i == -1) i = j + 1;\\n            else return i;\\n        }\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```\n```java\\nclass Allocator {\\n    private int[] a; // THE MEMORY\\n    public Allocator(int n) {\\n        a = new int[n];\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        for (int i = 0; i <= a.length - size;) { // starting from 0 to search for consecutive free space\\n            int j = i, r = i+size; // range we need to search for every starting point\\n            for (; j < r; j++) if (a[j] != 0) {i = -1; break;} // a[j] != 0 means it\\'s used, i = -1: not found\\n            if (i != -1) { // i != -1 means found free space of size, starting at i\\n                for (j = i; j < r; j++) a[j] = mID; // allocate\\n                return i; // return starting index\\n            } else i = j+1; // when not found that means from i to j are not good, starting next search from j+1\\n        }\\n\\n        return -1; // couldn\\'t find the the consecutive space needed\\n    }\\n    \\n    public int free(int mID) {\\n        int size = 0;\\n        for (int i = 0; i < a.length; i++)\\n            if (a[i] == mID) {a[i] = 0;size++;}\\n        return size;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899371,
                "title": "c-hashmap-vector-easy-approach",
                "content": "# Approach\\nFor memory allocation, We use a vector i.e. memory and to store indices of allocated memory to mID, We use hashmap which stores mID and all indices allocated to it.\\n\\nTo allocate free memory, We need to check free space in the memory vector and allocate it. We also need to store indices of allocated memory in hashmap and return starting index of allocated memory.\\n\\nTo free allocated memory, we use hashmap to get indices of allocated memory and clear the space by assigning 0 to it and return number of indices allocated to mID.\\n\\n# Time Complexity\\nAllocator : O(1)\\nallocate : O(N + size)\\nfree : O(M)\\nwhere, N-Memory Size, size-size of allocated memory, M-Number of allocated indices\\n\\n# Space Complexity\\nO(N)\\n\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    \\n    vector<int> memory;\\n    int sz;\\n    unordered_map<int, vector<int>> mp;\\n    Allocator(int n) \\n    {\\n        memory.resize(n);\\n        sz=n;\\n    }\\n    \\n    int allocate(int size, int mID) \\n    {\\n        int free=0, idx;\\n        for(int i=0; i<sz; i++)\\n        {\\n            if(free==0) idx=i;\\n            if(memory[i]==0) free++;\\n            else free=0;\\n            \\n            if(free >= size) break;\\n        }\\n        \\n        if(free >= size)\\n        {\\n            for(int i=idx; i<idx+size; i++)\\n            {\\n                memory[i] = mID;\\n                mp[mID].push_back(i);\\n            }\\n        }\\n        \\n        return free>=size ? idx : -1;\\n            \\n    }\\n    \\n    int free(int mID) \\n    {\\n        int count=0;\\n        for(auto it:mp[mID])\\n        {\\n            memory[it]=0;\\n            count++;\\n        }\\n        \\n        mp.erase(mID);\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    \\n    vector<int> memory;\\n    int sz;\\n    unordered_map<int, vector<int>> mp;\\n    Allocator(int n) \\n    {\\n        memory.resize(n);\\n        sz=n;\\n    }\\n    \\n    int allocate(int size, int mID) \\n    {\\n        int free=0, idx;\\n        for(int i=0; i<sz; i++)\\n        {\\n            if(free==0) idx=i;\\n            if(memory[i]==0) free++;\\n            else free=0;\\n            \\n            if(free >= size) break;\\n        }\\n        \\n        if(free >= size)\\n        {\\n            for(int i=idx; i<idx+size; i++)\\n            {\\n                memory[i] = mID;\\n                mp[mID].push_back(i);\\n            }\\n        }\\n        \\n        return free>=size ? idx : -1;\\n            \\n    }\\n    \\n    int free(int mID) \\n    {\\n        int count=0;\\n        for(auto it:mp[mID])\\n        {\\n            memory[it]=0;\\n            count++;\\n        }\\n        \\n        mp.erase(mID);\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899364,
                "title": "java-array-solution",
                "content": "```\\nclass Allocator {\\n    int[] array;\\n    public Allocator(int n) {\\n        array = new int[n];\\n        for (int i = 0; i < array.length; i++) {\\n            array[i] = -1;\\n        }\\n    }\\n    public int allocate(int size, int mID) {\\n        if (size > array.length) {\\n            return -1;\\n        }\\n        int count = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;\\n        for (int i = 0; i < array.length; i++) {\\n            if (array[i] == -1) {\\n                count++;\\n            } else {\\n                count = 0;\\n                startIndex = i + 1;\\n            }\\n            if (count == size) {\\n                endIndex = i;\\n                break;\\n            }\\n        }\\n        if (startIndex > endIndex) {\\n            return -1;\\n        }\\n        Arrays.fill(array, startIndex, Math.min(endIndex + 1, array.length), mID);\\n        return startIndex;\\n    }\\n    public int free(int mID) {\\n        int count = 0;   \\n        for (int i = 0; i < array.length; i++) {\\n            if (array[i] == mID) {\\n                count++;\\n                array[i] = -1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Allocator {\\n    int[] array;\\n    public Allocator(int n) {\\n        array = new int[n];\\n        for (int i = 0; i < array.length; i++) {\\n            array[i] = -1;\\n        }\\n    }\\n    public int allocate(int size, int mID) {\\n        if (size > array.length) {\\n            return -1;\\n        }\\n        int count = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;\\n        for (int i = 0; i < array.length; i++) {\\n            if (array[i] == -1) {\\n                count++;\\n            } else {\\n                count = 0;\\n                startIndex = i + 1;\\n            }\\n            if (count == size) {\\n                endIndex = i;\\n                break;\\n            }\\n        }\\n        if (startIndex > endIndex) {\\n            return -1;\\n        }\\n        Arrays.fill(array, startIndex, Math.min(endIndex + 1, array.length), mID);\\n        return startIndex;\\n    }\\n    public int free(int mID) {\\n        int count = 0;   \\n        for (int i = 0; i < array.length; i++) {\\n            if (array[i] == mID) {\\n                count++;\\n                array[i] = -1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899475,
                "title": "python-simple-solution-with-video-explanation",
                "content": "# Approach\\ncreate an array of length n initialize with -1 \\n- for allocate look for a free block of length size, once found set all values in it to mID and returns the start index \\n- for free find all those set to mID and set to -1 \\n\\nVideo explanation: https://www.youtube.com/watch?v=k9l1PvIRNRw\\n# Code\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.blocks = [-1] * n\\n        self.n = n\\n        \\n    def allocate(self, size: int, mID: int) -> int:\\n        available = 0\\n        for i in range(self.n):\\n            if self.blocks[i] == -1:\\n                available += 1\\n            else:\\n                available = 0\\n            if available == size: \\n                for j in range(i - available + 1, i + 1):\\n                    self.blocks[j] = mID\\n                return i - available + 1\\n        return -1 \\n    \\n    def free(self, mID: int) -> int:\\n        count = 0\\n        for i in range(self.n):\\n            if self.blocks[i] == mID:\\n                count += 1\\n                self.blocks[i] = -1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.blocks = [-1] * n\\n        self.n = n\\n        \\n    def allocate(self, size: int, mID: int) -> int:\\n        available = 0\\n        for i in range(self.n):\\n            if self.blocks[i] == -1:\\n                available += 1\\n            else:\\n                available = 0\\n            if available == size: \\n                for j in range(i - available + 1, i + 1):\\n                    self.blocks[j] = mID\\n                return i - available + 1\\n        return -1 \\n    \\n    def free(self, mID: int) -> int:\\n        count = 0\\n        for i in range(self.n):\\n            if self.blocks[i] == mID:\\n                count += 1\\n                self.blocks[i] = -1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899607,
                "title": "java-solution-treemap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator {\\n    Map<Integer, TreeMap<Integer, Integer>> memory = new HashMap<>();\\n\\n    public Allocator(int n) {\\n        TreeMap<Integer, Integer> ranges = new TreeMap<>(); // <startAdd, endAdd>\\n        ranges.put(0, n-1); // address start from 0\\n        memory.put(0, ranges); // 0 means free block\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int addr = -1;\\n        int[] availableRange = new int[]{-1, -1};\\n        for (Map.Entry<Integer, Integer> range : memory.get(0).entrySet()) {\\n            int startAdd = range.getKey(); int endAdd = range.getValue();\\n            if (endAdd - startAdd + 1 >= size) {\\n                addr = startAdd;\\n                availableRange[0] = startAdd;\\n                availableRange[1] = endAdd;\\n                break;\\n            }\\n        }\\n        if (addr != -1) {\\n            memory.computeIfAbsent(mID, x -> new TreeMap<>()).put(availableRange[0], availableRange[0] + size - 1);\\n            memory.get(0).remove(availableRange[0]);\\n            if (availableRange[1] - availableRange[0] + 1 > size) memory.get(0).put(availableRange[0] + size, availableRange[1]);\\n        }\\n        \\n        mergeRanges(mID);\\n        \\n        return addr;\\n    }\\n    \\n    public int free(int mID) {\\n        int cnt = 0;\\n        TreeMap<Integer, Integer> freeRanges = memory.get(mID);\\n        \\n        if (freeRanges != null) {\\n            for (Map.Entry<Integer, Integer> range : freeRanges.entrySet()) {\\n                int startAdd = range.getKey(); int endAdd = range.getValue();\\n                cnt += endAdd - startAdd + 1;\\n                memory.get(0).put(startAdd, endAdd);\\n            }\\n        }\\n        \\n        memory.remove(mID);\\n        mergeRanges(0);\\n        return cnt;\\n    }\\n    \\n    private void mergeRanges(int mID) {\\n        TreeMap<Integer, Integer> curRanges = memory.get(mID);\\n        TreeMap<Integer, Integer> mergedRanges = new TreeMap<>();\\n        int[] lastRange = new int[]{Integer.MIN_VALUE, Integer.MIN_VALUE};\\n        if (curRanges != null) {\\n            for (Map.Entry<Integer, Integer> range : curRanges.entrySet()) {\\n                int startAdd = range.getKey(); int endAdd = range.getValue();\\n                if (startAdd - 1 == lastRange[1]) {\\n                    lastRange[1] = endAdd;\\n                } else {\\n                    if (lastRange[0] != Integer.MIN_VALUE) mergedRanges.put(lastRange[0], lastRange[1]);\\n                    lastRange[0] = startAdd;\\n                    lastRange[1] = endAdd;\\n                }\\n            }\\n        }\\n        if (lastRange[0] != Integer.MIN_VALUE) mergedRanges.put(lastRange[0], lastRange[1]);\\n        \\n        memory.put(mID, mergedRanges);\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    Map<Integer, TreeMap<Integer, Integer>> memory = new HashMap<>();\\n\\n    public Allocator(int n) {\\n        TreeMap<Integer, Integer> ranges = new TreeMap<>(); // <startAdd, endAdd>\\n        ranges.put(0, n-1); // address start from 0\\n        memory.put(0, ranges); // 0 means free block\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int addr = -1;\\n        int[] availableRange = new int[]{-1, -1};\\n        for (Map.Entry<Integer, Integer> range : memory.get(0).entrySet()) {\\n            int startAdd = range.getKey(); int endAdd = range.getValue();\\n            if (endAdd - startAdd + 1 >= size) {\\n                addr = startAdd;\\n                availableRange[0] = startAdd;\\n                availableRange[1] = endAdd;\\n                break;\\n            }\\n        }\\n        if (addr != -1) {\\n            memory.computeIfAbsent(mID, x -> new TreeMap<>()).put(availableRange[0], availableRange[0] + size - 1);\\n            memory.get(0).remove(availableRange[0]);\\n            if (availableRange[1] - availableRange[0] + 1 > size) memory.get(0).put(availableRange[0] + size, availableRange[1]);\\n        }\\n        \\n        mergeRanges(mID);\\n        \\n        return addr;\\n    }\\n    \\n    public int free(int mID) {\\n        int cnt = 0;\\n        TreeMap<Integer, Integer> freeRanges = memory.get(mID);\\n        \\n        if (freeRanges != null) {\\n            for (Map.Entry<Integer, Integer> range : freeRanges.entrySet()) {\\n                int startAdd = range.getKey(); int endAdd = range.getValue();\\n                cnt += endAdd - startAdd + 1;\\n                memory.get(0).put(startAdd, endAdd);\\n            }\\n        }\\n        \\n        memory.remove(mID);\\n        mergeRanges(0);\\n        return cnt;\\n    }\\n    \\n    private void mergeRanges(int mID) {\\n        TreeMap<Integer, Integer> curRanges = memory.get(mID);\\n        TreeMap<Integer, Integer> mergedRanges = new TreeMap<>();\\n        int[] lastRange = new int[]{Integer.MIN_VALUE, Integer.MIN_VALUE};\\n        if (curRanges != null) {\\n            for (Map.Entry<Integer, Integer> range : curRanges.entrySet()) {\\n                int startAdd = range.getKey(); int endAdd = range.getValue();\\n                if (startAdd - 1 == lastRange[1]) {\\n                    lastRange[1] = endAdd;\\n                } else {\\n                    if (lastRange[0] != Integer.MIN_VALUE) mergedRanges.put(lastRange[0], lastRange[1]);\\n                    lastRange[0] = startAdd;\\n                    lastRange[1] = endAdd;\\n                }\\n            }\\n        }\\n        if (lastRange[0] != Integer.MIN_VALUE) mergedRanges.put(lastRange[0], lastRange[1]);\\n        \\n        memory.put(mID, mergedRanges);\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899362,
                "title": "easy-c",
                "content": "# Plz upvote if you liked it :)\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    vector<int> vt;\\n    int allocated=0;\\n    int nn;\\n    map<int,int> mp;\\n    Allocator(int n) {\\n        vt.resize(n,-1);\\n        nn=n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        if(size>nn) {\\n            return -1;\\n            \\n        }\\n        int cf=0;\\n        int si=0;\\n        for(int i=0;i<nn;++i){\\n           \\n            if(vt[i]==-1){\\n                 cf++;\\n            }\\n            else {\\n                 \\n                cf=0;\\n            }\\n             if(cf==size){\\n                si=i-size+1;\\n                break;\\n            }\\n            \\n        }\\n         \\n        if(cf!=size) return -1;\\n        \\n        for(int i=0;i<size;++i){\\n            vt[i+si]=mID;\\n            // mp[i]=mID;\\n        }\\n        // for(auto it:vt) cout<<it<<\" \";\\n        // cout<<endl;\\n        // cout<<si<<endl;\\n        \\n        \\n        return si;\\n        \\n        \\n        \\n        \\n    }\\n    \\n    int free(int mID) {\\n        int cnt=0;\\n        for(auto& it:vt){\\n            if(it==mID) {\\n                it=-1;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n\\n\\n// [null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    vector<int> vt;\\n    int allocated=0;\\n    int nn;\\n    map<int,int> mp;\\n    Allocator(int n) {\\n        vt.resize(n,-1);\\n        nn=n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        if(size>nn) {\\n            return -1;\\n            \\n        }\\n        int cf=0;\\n        int si=0;\\n        for(int i=0;i<nn;++i){\\n           \\n            if(vt[i]==-1){\\n                 cf++;\\n            }\\n            else {\\n                 \\n                cf=0;\\n            }\\n             if(cf==size){\\n                si=i-size+1;\\n                break;\\n            }\\n            \\n        }\\n         \\n        if(cf!=size) return -1;\\n        \\n        for(int i=0;i<size;++i){\\n            vt[i+si]=mID;\\n            // mp[i]=mID;\\n        }\\n        // for(auto it:vt) cout<<it<<\" \";\\n        // cout<<endl;\\n        // cout<<si<<endl;\\n        \\n        \\n        return si;\\n        \\n        \\n        \\n        \\n    }\\n    \\n    int free(int mID) {\\n        int cnt=0;\\n        for(auto& it:vt){\\n            if(it==mID) {\\n                it=-1;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n\\n\\n// [null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2949363,
                "title": "python-abuse-strings-to-beat-97-in-o-n",
                "content": "# Approach\\nEncode the whole thing as a unicode string, where the free blocks and non-free blocks have identities as characters. Then use the string api to implement behavior.\\n\\n# Complexity\\n- Time complexity:\\n$O(n)$, but very nice constant factor\\n\\n- Space complexity:\\n$O(n)$\\n\\n\\n# Code\\n```\\nFREE = chr(0)\\n\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.data = FREE*n   \\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        i = self.data.find(FREE*size)\\n        if i != -1:\\n            self.data = self.data[:i] + chr(mID)*size + self.data[i+size:]\\n        return i\\n\\n    def free(self, mID: int) -> int:\\n        freed = self.data.count(chr(mID))\\n        self.data = self.data.replace(chr(mID), FREE)\\n        return freed\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nFREE = chr(0)\\n\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.data = FREE*n   \\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        i = self.data.find(FREE*size)\\n        if i != -1:\\n            self.data = self.data[:i] + chr(mID)*size + self.data[i+size:]\\n        return i\\n\\n    def free(self, mID: int) -> int:\\n        freed = self.data.count(chr(mID))\\n        self.data = self.data.replace(chr(mID), FREE)\\n        return freed\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570867,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator {\\n    private int[] memory; \\n    \\n    public Allocator(int n) {\\n        memory = new int[n]; \\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int cnt = 0; \\n        for (int i = 0; i < memory.length; ++i) {\\n            if (memory[i] == 0) {\\n                if (++cnt == size) {\\n                    for (int ii = i; ii >= i-size+1; --ii) \\n                        memory[ii] = mID; \\n                    return i-size+1; \\n                }\\n            } else cnt = 0; \\n        }\\n        return -1; \\n    }\\n    \\n    public int free(int mID) {\\n        int ans = 0; \\n        for (int i = 0; i < memory.length; ++i) \\n            if (memory[i] == mID) {\\n                ++ans; \\n                memory[i] = 0; \\n            }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    private int[] memory; \\n    \\n    public Allocator(int n) {\\n        memory = new int[n]; \\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int cnt = 0; \\n        for (int i = 0; i < memory.length; ++i) {\\n            if (memory[i] == 0) {\\n                if (++cnt == size) {\\n                    for (int ii = i; ii >= i-size+1; --ii) \\n                        memory[ii] = mID; \\n                    return i-size+1; \\n                }\\n            } else cnt = 0; \\n        }\\n        return -1; \\n    }\\n    \\n    public int free(int mID) {\\n        int ans = 0; \\n        for (int i = 0; i < memory.length; ++i) \\n            if (memory[i] == mID) {\\n                ++ans; \\n                memory[i] = 0; \\n            }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904598,
                "title": "java-simple-way-solution",
                "content": "class Allocator {\\n\\n    int[] arr;\\n    public Allocator(int n) {\\n        //by default array will be initialized with 0 hence zero will denote empty space.\\n        arr = new int[n];\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int cnt = 0;\\n        int j = -2;\\n        \\n        for(int i = 0 ; i < arr.length ; i++)\\n        {\\n            //if free space(zero) is available in array then increase the cnt.\\n            if(arr[i] == 0)\\n            {\\n                cnt++;\\n            }\\n            else\\n            {\\n                //if encountered with occupied space then we need to count free spaces again\\n                cnt = 0;\\n            }\\n            \\n            \\n            //As free space count will be enough\\n            if(cnt == size)\\n            {\\n                 j = i;\\n                //Now occupie the available free space.\\n                while(cnt != 0)\\n                {\\n                    cnt--;\\n                    \\n                    arr[j] = mID;\\n                    j--;\\n                }\\n                break;\\n            }\\n        }\\n        \\n        //return the index.\\n        return j+1;\\n    }\\n    \\n    public int free(int mID) {\\n        int cnt = 0;\\n        for(int i = 0 ;i < arr.length ;i++)\\n        {\\n            if(arr[i] == mID){\\n                cnt++;\\n                arr[i] = 0;\\n            } \\n        }\\n        \\n        return cnt;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Allocator {\\n\\n    int[] arr;\\n    public Allocator(int n) {\\n        //by default array will be initialized with 0 hence zero will denote empty space.\\n        arr = new int[n];\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int cnt = 0;\\n        int j = -2;\\n        \\n        for(int i = 0 ; i < arr.length ; i++)\\n        {\\n            //if free space(zero) is available in array then increase the cnt.\\n            if(arr[i] == 0)\\n            {\\n                cnt++;\\n            }\\n            else\\n            {\\n                //if encountered with occupied space then we need to count free spaces again\\n                cnt = 0;\\n            }\\n            \\n            \\n            //As free space count will be enough\\n            if(cnt == size)\\n            {\\n                 j = i;\\n                //Now occupie the available free space.\\n                while(cnt != 0)\\n                {\\n                    cnt--;\\n                    \\n                    arr[j] = mID;\\n                    j--;\\n                }\\n                break;\\n            }\\n        }\\n        \\n        //return the index.\\n        return j+1;\\n    }\\n    \\n    public int free(int mID) {\\n        int cnt = 0;\\n        for(int i = 0 ;i < arr.length ;i++)\\n        {\\n            if(arr[i] == mID){\\n                cnt++;\\n                arr[i] = 0;\\n            } \\n        }\\n        \\n        return cnt;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2900517,
                "title": "python-solution-hashmap-and-list-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) <b>Constructor</b>\\n    For memory allocation, We use a list i.e. ```self.memory``` and to store indices of allocated memory to ```mID```, We use hashmap i.e. ```self.hashMap``` which stores ```mID``` and all indices allocated to it.\\n\\n2) <b>Allocate</b>\\n    To allocate free memory, We need to check free space in the memory vector and allocate it. We also need to store indices of allocated memory in hashmap and return starting index of allocated memory.\\n\\n3) <b>Free</b>\\nTo free allocated memory, we use hashmap to get indices of allocated memory and clear the space by assigning ```0``` to it and return number of indices allocated to ```mID```.\\n\\n# Complexity\\nHere, ```N``` is Memory Size, ```size``` is size of allocated memory, ```M``` is Number of allocated indices\\n\\n- Time complexity:\\n    - Constructor: $$O(1)$$\\n    - Allocate : $$O(N + size)$$\\n    - Free : $$O(M)$$\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.memory, self.sz, self.hashMap = [0] * n, n, defaultdict(list)\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        free, idx = 0, 0\\n        for i in range(self.sz):\\n            if free == 0: \\n                idx = i\\n            if self.memory[i] == 0: \\n                free += 1\\n            else: \\n                free = 0\\n            if free >= size: \\n                break\\n        if free >= size:\\n            for i in range(idx, idx + size):\\n                self.memory[i] = mID\\n                self.hashMap[mID].append(i)\\n        return idx if free >= size else -1\\n\\n    def free(self, mID: int) -> int:\\n        count = 0\\n        for idx in self.hashMap[mID]:\\n            self.memory[idx] = 0\\n            count += 1\\n        del self.hashMap[mID]\\n        return count\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```self.memory```\n```mID```\n```self.hashMap```\n```mID```\n```0```\n```mID```\n```N```\n```size```\n```M```\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.memory, self.sz, self.hashMap = [0] * n, n, defaultdict(list)\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        free, idx = 0, 0\\n        for i in range(self.sz):\\n            if free == 0: \\n                idx = i\\n            if self.memory[i] == 0: \\n                free += 1\\n            else: \\n                free = 0\\n            if free >= size: \\n                break\\n        if free >= size:\\n            for i in range(idx, idx + size):\\n                self.memory[i] = mID\\n                self.hashMap[mID].append(i)\\n        return idx if free >= size else -1\\n\\n    def free(self, mID: int) -> int:\\n        count = 0\\n        for idx in self.hashMap[mID]:\\n            self.memory[idx] = 0\\n            count += 1\\n        del self.hashMap[mID]\\n        return count\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899480,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    int s = 0;\\n    vector<int> arr;\\n    Allocator(int n) {\\n        s=n;\\n        for(int i=0 ; i<n ; i++){\\n            arr.push_back(-1);\\n        }\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int count = 0;\\n        int idx = -1;\\n        for(int i=0 ; i<s ; i++){\\n            if(arr[i] == -1){\\n                count++;\\n                if(count==size){\\n                    idx = i-size+1;\\n                    break;\\n                }\\n            }\\n            else if(arr[i] != -1){\\n                count=0;\\n            }\\n        }\\n        if(count!=size){\\n            return -1;\\n        }\\n        for(int i=idx ; i<idx+size ; i++){\\n            arr[i] = mID;\\n        }\\n        return idx;\\n        \\n    }\\n    \\n    int free(int mID) {\\n        int cnt = 0;\\n        for(int i=0 ; i<s ; i++){\\n            if(arr[i]==mID){\\n                arr[i] = -1;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    int s = 0;\\n    vector<int> arr;\\n    Allocator(int n) {\\n        s=n;\\n        for(int i=0 ; i<n ; i++){\\n            arr.push_back(-1);\\n        }\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int count = 0;\\n        int idx = -1;\\n        for(int i=0 ; i<s ; i++){\\n            if(arr[i] == -1){\\n                count++;\\n                if(count==size){\\n                    idx = i-size+1;\\n                    break;\\n                }\\n            }\\n            else if(arr[i] != -1){\\n                count=0;\\n            }\\n        }\\n        if(count!=size){\\n            return -1;\\n        }\\n        for(int i=idx ; i<idx+size ; i++){\\n            arr[i] = mID;\\n        }\\n        return idx;\\n        \\n    }\\n    \\n    int free(int mID) {\\n        int cnt = 0;\\n        for(int i=0 ; i<s ; i++){\\n            if(arr[i]==mID){\\n                arr[i] = -1;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899448,
                "title": "sliding-window",
                "content": "# Code\\n```\\nclass Allocator {\\npublic:\\n    // we can solve this problem using sliding window\\n    vector<int> arr;\\n    int n;\\n    \\n    Allocator(int n) {\\n        this->n = n;\\n        arr = vector<int>(n, 0);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int i=0, l=0;\\n        \\n        for(i=0; i<n; i++) {\\n            if(arr[i] != 0) l=i+1;\\n            if(i-l+1 >= size) break;\\n        }\\n        \\n        if(i == n) i--;\\n        \\n        if(i-l+1 >= size) {\\n            for(int j=l; j<=i; j++) arr[j] = mID;\\n            return l;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int count = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(arr[i] == mID) {\\n                count++;\\n                arr[i] = 0;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    // we can solve this problem using sliding window\\n    vector<int> arr;\\n    int n;\\n    \\n    Allocator(int n) {\\n        this->n = n;\\n        arr = vector<int>(n, 0);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int i=0, l=0;\\n        \\n        for(i=0; i<n; i++) {\\n            if(arr[i] != 0) l=i+1;\\n            if(i-l+1 >= size) break;\\n        }\\n        \\n        if(i == n) i--;\\n        \\n        if(i-l+1 >= size) {\\n            for(int j=l; j<=i; j++) arr[j] = mID;\\n            return l;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int count = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(arr[i] == mID) {\\n                count++;\\n                arr[i] = 0;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899393,
                "title": "python-3-brute-force",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n    O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n    O(n)\\n# Code\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.arr=[0 for i in range(n)]\\n        self.n=n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        index=-1\\n        t=0\\n        for i in range(self.n-1,-1,-1):\\n            if(self.arr[i]==0):\\n                t+=1\\n                if(t>=size):\\n                    index=i\\n            else:\\n                t=0\\n        if(index==-1):\\n            return index\\n        for i in range(index,index+size):\\n            self.arr[i]=mID\\n        return index\\n    def free(self, mID: int) -> int:\\n        t=0\\n        for i in range(self.n):\\n            if(self.arr[i]==mID):\\n                self.arr[i]=0\\n                t+=1\\n        return t\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.arr=[0 for i in range(n)]\\n        self.n=n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        index=-1\\n        t=0\\n        for i in range(self.n-1,-1,-1):\\n            if(self.arr[i]==0):\\n                t+=1\\n                if(t>=size):\\n                    index=i\\n            else:\\n                t=0\\n        if(index==-1):\\n            return index\\n        for i in range(index,index+size):\\n            self.arr[i]=mID\\n        return index\\n    def free(self, mID: int) -> int:\\n        t=0\\n        for i in range(self.n):\\n            if(self.arr[i]==mID):\\n                self.arr[i]=0\\n                t+=1\\n        return t\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899372,
                "title": "linked-list-block-allocation-merge-consecutive-free-blocks",
                "content": "```\\nclass Block:\\n    def __init__(self, size, mID, nxt = None):\\n        self.size = size\\n        self.mID = mID\\n        self.next = nxt\\n\\nclass Allocator:\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.head = Block(n, -1)\\n        \\n    def allocate(self, size: int, mID: int) -> int:\\n        curr = self.head\\n        l = 0\\n        while curr:\\n            if curr.size >= size and curr.mID == -1:\\n                prevID = curr.mID\\n                rem = curr.size - size\\n                curr.size = size\\n                curr.mID = mID\\n                if rem > 0:\\n                    curr.next = Block(rem, prevID, curr.next)\\n                return l\\n            l += curr.size\\n            curr = curr.next\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        curr = self.head\\n        res = 0\\n        while curr:\\n            if curr.mID == mID:\\n                res += curr.size\\n                curr.mID = -1\\n            curr = curr.next\\n        curr = self.head\\n        while curr:\\n            if curr.next and curr.mID == curr.next.mID == -1:\\n                curr.size += curr.next.size\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Block:\\n    def __init__(self, size, mID, nxt = None):\\n        self.size = size\\n        self.mID = mID\\n        self.next = nxt\\n\\nclass Allocator:\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.head = Block(n, -1)\\n        \\n    def allocate(self, size: int, mID: int) -> int:\\n        curr = self.head\\n        l = 0\\n        while curr:\\n            if curr.size >= size and curr.mID == -1:\\n                prevID = curr.mID\\n                rem = curr.size - size\\n                curr.size = size\\n                curr.mID = mID\\n                if rem > 0:\\n                    curr.next = Block(rem, prevID, curr.next)\\n                return l\\n            l += curr.size\\n            curr = curr.next\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        curr = self.head\\n        res = 0\\n        while curr:\\n            if curr.mID == mID:\\n                res += curr.size\\n                curr.mID = -1\\n            curr = curr.next\\n        curr = self.head\\n        while curr:\\n            if curr.next and curr.mID == curr.next.mID == -1:\\n                curr.size += curr.next.size\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254086,
                "title": "real-allocator-that-beats-100",
                "content": "# Intuition\\n1. Use a linked list to track all memory blocks. It starts with a single block for all the available memory\\n2. Use a dict to track all allocations\\n\\nIf you like my implementation please upvote!\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Allocator:\\n    class Block:\\n        def __init__(self, size: int, free: bool = False):\\n            self.size = size\\n            self.free = free\\n            self.next = None\\n\\n    def __init__(self, n: int):\\n        #self.memo = [0] * n\\n        self.available = n\\n        self.allocated = dict()\\n        self.head = self.Block(0, 0)\\n        self.head.next = self.Block(self.available, True)\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        offset = 0\\n        if size <= self.available:\\n            prev = self.head\\n            p = prev.next\\n            while p and (not p.free or p.size < size):\\n                offset += p.size\\n                prev = p\\n                p = p.next\\n            if not p:\\n                return -1\\n            if size < p.size:\\n                sub = self.Block(p.size - size, True)\\n                sub.next = p.next\\n                p.next = sub\\n            p.free = False\\n            p.size = size\\n            blocks = self.allocated.setdefault(mID, set())\\n            blocks.add(p)\\n            self.available -= size\\n            return offset\\n        else:\\n            return -1\\n\\n    def free(self, mID: int) -> int:\\n        r = 0\\n        blocks = self.allocated.get(mID)\\n        if blocks:\\n            for block in blocks:\\n                self.available += block.size\\n                r += block.size\\n                self.free_block(block)\\n            blocks.clear()\\n            del self.allocated[mID]\\n        return r\\n\\n    def free_block(self, block: Block):\\n        block.free = True\\n        # merge with next block\\n        if block.next and block.next.free:\\n            block.size += block.next.size\\n            block.next = block.next.next\\n\\n        # check if we need to merge with prev block\\n        prev = self.head\\n        p = prev.next\\n        while p and p != block:\\n            prev = p\\n            p = p.next\\n        if prev.free:\\n            prev.size += block.size\\n            prev.next = block.next\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n    class Block:\\n        def __init__(self, size: int, free: bool = False):\\n            self.size = size\\n            self.free = free\\n            self.next = None\\n\\n    def __init__(self, n: int):\\n        #self.memo = [0] * n\\n        self.available = n\\n        self.allocated = dict()\\n        self.head = self.Block(0, 0)\\n        self.head.next = self.Block(self.available, True)\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        offset = 0\\n        if size <= self.available:\\n            prev = self.head\\n            p = prev.next\\n            while p and (not p.free or p.size < size):\\n                offset += p.size\\n                prev = p\\n                p = p.next\\n            if not p:\\n                return -1\\n            if size < p.size:\\n                sub = self.Block(p.size - size, True)\\n                sub.next = p.next\\n                p.next = sub\\n            p.free = False\\n            p.size = size\\n            blocks = self.allocated.setdefault(mID, set())\\n            blocks.add(p)\\n            self.available -= size\\n            return offset\\n        else:\\n            return -1\\n\\n    def free(self, mID: int) -> int:\\n        r = 0\\n        blocks = self.allocated.get(mID)\\n        if blocks:\\n            for block in blocks:\\n                self.available += block.size\\n                r += block.size\\n                self.free_block(block)\\n            blocks.clear()\\n            del self.allocated[mID]\\n        return r\\n\\n    def free_block(self, block: Block):\\n        block.free = True\\n        # merge with next block\\n        if block.next and block.next.free:\\n            block.size += block.next.size\\n            block.next = block.next.next\\n\\n        # check if we need to merge with prev block\\n        prev = self.head\\n        p = prev.next\\n        while p and p != block:\\n            prev = p\\n            p = p.next\\n        if prev.free:\\n            prev.size += block.size\\n            prev.next = block.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921256,
                "title": "c-short-and-clean-solution-using-intervals-and-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse two maps.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne map to map mID to a list of start indexes.\\nOne map to track memory usage, where `key` = start of memory and `value` = end of memory, where both start and end are inclusive, e.g. `[start, end]`. Find free space by subtracting the difference between two nodes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN) for both `allocate` and `free`.\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    map<int, int> mem;\\n    map<int, vector<int>> mID_map;\\n    \\n    Allocator(int n) {\\n        mem = {{INT_MIN, -1}, {n, INT_MAX}};\\n    }\\n    \\n    \\n    int allocate(int size, int mID) {\\n        // check every pair of intervals\\n        for (auto it1 = mem.begin(), it2 = next(it1); it1 != mem.end() && it2 != mem.end(); ++it1, ++it2) {\\n            int start = it1->second + 1;\\n            int end = it2->first;\\n            if (end - start >= size) {\\n                mem[start] = start + size - 1;\\n                mID_map[mID].push_back(start);\\n                return start;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    // It removes all entries in the mem map that correspond to \\n    // the memory allocated to the process, and also removes the entry\\n    // for the process in the mID_map.\\n    int free(int mID) {\\n        int sum = 0;\\n        for (int idx : mID_map[mID]) {\\n            sum += mem[idx] - idx + 1;\\n            mem.erase(idx);\\n        }\\n        mID_map.erase(mID);\\n        return sum;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse two maps.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne map to map mID to a list of start indexes.\\nOne map to track memory usage, where `key` = start of memory and `value` = end of memory, where both start and end are inclusive, e.g. `[start, end]`. Find free space by subtracting the difference between two nodes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN) for both `allocate` and `free`.\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    map<int, int> mem;\\n    map<int, vector<int>> mID_map;\\n    \\n    Allocator(int n) {\\n        mem = {{INT_MIN, -1}, {n, INT_MAX}};\\n    }\\n    \\n    \\n    int allocate(int size, int mID) {\\n        // check every pair of intervals\\n        for (auto it1 = mem.begin(), it2 = next(it1); it1 != mem.end() && it2 != mem.end(); ++it1, ++it2) {\\n            int start = it1->second + 1;\\n            int end = it2->first;\\n            if (end - start >= size) {\\n                mem[start] = start + size - 1;\\n                mID_map[mID].push_back(start);\\n                return start;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    // It removes all entries in the mem map that correspond to \\n    // the memory allocated to the process, and also removes the entry\\n    // for the process in the mID_map.\\n    int free(int mID) {\\n        int sum = 0;\\n        for (int idx : mID_map[mID]) {\\n            sum += mem[idx] - idx + 1;\\n            mem.erase(idx);\\n        }\\n        mID_map.erase(mID);\\n        return sum;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2916352,
                "title": "python-detailed-explanation-simple-code",
                "content": "# Intuition\\nKeep a memAr where memAr[i] represents index till where the memAr is ocupied by a process. Ex if memAr[3] = 6, the memAr is filled at indices 3,4,5. By default memAr[i] = -1, which indicates there is no process occupying memory starting at index i.\\n\\nmemMap stores for each process mID a list of all starting indices where the memory is allocated in memAr\\n\\n**Allocation Approach**:\\nfor size m len blocks for an mID, Look through contiguous blocks of \\nsize m in memAr and find the max value inside that block. If max value is -1 it means there is no process allocated in that contuguous block and hence we can allocate current mID here and return.\\nElse we proceed to the index at max value and continue looking. Reason we proceed to index at max value is because this is the farthest position in memAr till where any process is taking up space which starts anywhere in our current contiguous block.\\n\\n$$Time Complexity:$$ O(n), since we end up searching through the entire memAr in case where incoming mID needs 1 block and memAr is completely filled in blocks of 1 unit by different processes.\\n\\n**Free Approach**:\\nGoto each position in memMap for the given mID and reset memAr at that position to -1. Finally clear out the memMap[mID].\\n$$Time Complexity$$: O(number of unique processes we ran for a given mID)\\n\\nSpace complexity = O(n)\\n# Code\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.memAr = [-1]*n\\n        self.n = n\\n        self.memMap = defaultdict(lambda:[])\\n        \\n    def allocate(self, size: int, mID: int) -> int:\\n        i = 0\\n        while i <= self.n-size:\\n            # check for size length consequetive blocks from ith index in the memAr\\n            max_elem = max(self.memAr[i:i+size])\\n            if max_elem == -1:\\n                self.memAr[i] = i+size\\n                self.memMap[mID].append(i)\\n                return i\\n            # if cannot find goto i+size and check again\\n            i = max_elem\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        totalFreed = 0\\n        for i in self.memMap[mID]:\\n            # free up memory allocation\\n            totalFreed += self.memAr[i]-i\\n            self.memAr[i] = -1\\n        self.memMap[mID] = []\\n        return totalFreed\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.memAr = [-1]*n\\n        self.n = n\\n        self.memMap = defaultdict(lambda:[])\\n        \\n    def allocate(self, size: int, mID: int) -> int:\\n        i = 0\\n        while i <= self.n-size:\\n            # check for size length consequetive blocks from ith index in the memAr\\n            max_elem = max(self.memAr[i:i+size])\\n            if max_elem == -1:\\n                self.memAr[i] = i+size\\n                self.memMap[mID].append(i)\\n                return i\\n            # if cannot find goto i+size and check again\\n            i = max_elem\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        totalFreed = 0\\n        for i in self.memMap[mID]:\\n            # free up memory allocation\\n            totalFreed += self.memAr[i]-i\\n            self.memAr[i] = -1\\n        self.memMap[mID] = []\\n        return totalFreed\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900705,
                "title": "python3-array-merge-solution",
                "content": "Consider memory allocation pool as start and end ranges. lots of edge cases, :-()\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn]\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.pool = [[0,n-1]]\\n        self.allocated = defaultdict(list)\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        ret = -1\\n        for i in range(len(self.pool)): \\n            start, end = self.pool[i]\\n            if end-start+1 > size: \\n                ret = start\\n                self.pool[i][0] += size\\n                self.allocated[mID].append((start,start+size-1))\\n                break              \\n            elif end-start+1 == size:\\n                ret = start  \\n                del self.pool[i]\\n                self.allocated[mID].append((start,start+size-1))\\n                break\\n\\n        # print (\"alloc = \", [size, mID], self.pool, self.allocated.items())\\n        return ret\\n        \\n    def free(self, mID: int) -> int:\\n        freed_size = 0 \\n\\n        for start,end in self.allocated[mID]:\\n            freed_size += end-start+1\\n            if not self.pool and self.allocated[mID]: \\n                self.pool.append([start,end])\\n                continue \\n            for i in range(len(self.pool)):\\n                ps,pe = self.pool[i]\\n                if pe + 1 == start or ps-1 == end:\\n                    self.pool[i] = [min(start, ps), max(end, pe)]\\n                    if i+1 < len(self.pool) and self.pool[i][1]+1 == self.pool[i+1][0]:\\n                        self.pool[i][1] = self.pool[i+1][1]\\n                        del self.pool[i+1]\\n                    if i-1>= 0 and self.pool[i-1][1]+1 == self.pool[i][0]:\\n                        self.pool[i][0] = self.pool[i-1][0]\\n                        del self.pool[i-1]\\n                    break\\n                elif ps > end: \\n                    self.pool.insert(i, [start,end])\\n                    break\\n\\n        # print (\"free = \", self.allocated[mID], self.pool)\\n        del self.allocated[mID]\\n\\n        return freed_size\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.pool = [[0,n-1]]\\n        self.allocated = defaultdict(list)\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        ret = -1\\n        for i in range(len(self.pool)): \\n            start, end = self.pool[i]\\n            if end-start+1 > size: \\n                ret = start\\n                self.pool[i][0] += size\\n                self.allocated[mID].append((start,start+size-1))\\n                break              \\n            elif end-start+1 == size:\\n                ret = start  \\n                del self.pool[i]\\n                self.allocated[mID].append((start,start+size-1))\\n                break\\n\\n        # print (\"alloc = \", [size, mID], self.pool, self.allocated.items())\\n        return ret\\n        \\n    def free(self, mID: int) -> int:\\n        freed_size = 0 \\n\\n        for start,end in self.allocated[mID]:\\n            freed_size += end-start+1\\n            if not self.pool and self.allocated[mID]: \\n                self.pool.append([start,end])\\n                continue \\n            for i in range(len(self.pool)):\\n                ps,pe = self.pool[i]\\n                if pe + 1 == start or ps-1 == end:\\n                    self.pool[i] = [min(start, ps), max(end, pe)]\\n                    if i+1 < len(self.pool) and self.pool[i][1]+1 == self.pool[i+1][0]:\\n                        self.pool[i][1] = self.pool[i+1][1]\\n                        del self.pool[i+1]\\n                    if i-1>= 0 and self.pool[i-1][1]+1 == self.pool[i][0]:\\n                        self.pool[i][0] = self.pool[i-1][0]\\n                        del self.pool[i-1]\\n                    break\\n                elif ps > end: \\n                    self.pool.insert(i, [start,end])\\n                    break\\n\\n        # print (\"free = \", self.allocated[mID], self.pool)\\n        del self.allocated[mID]\\n\\n        return freed_size\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900296,
                "title": "easy-c-implementation",
                "content": "# Intuition\\nSimple intution is to use a array to represent memory of size n. Initially we mark every block as -1 (empty).\\n# Approach\\n1. When we have to allocate memory we check such possible contigous block from the beginning. If we found such block then we allocate the memory with given mID. else we return -1.\\n2. When we have to free memory then we simply check all block with given mID and mark that as -1 (empty) again.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Allocator {\\n    vector<int>vec;\\n    int n;\\npublic:\\n    Allocator(int n) {\\n        vec.resize(n,-1);\\n        this->n = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int cnt = 0;\\n        int idx = -1;\\n        for(int i = 0;i < n;i++){\\n            if(vec[i] == -1){\\n                if(cnt == 0){\\n                    idx = i;\\n                }\\n                cnt++;\\n            }else{\\n                cnt = 0;\\n                idx = -1;\\n            }\\n            if(cnt == size){\\n                break;\\n            }\\n        }\\n        if(idx == -1) return -1;\\n        if(cnt < size) return -1;\\n        for(int i = idx;i < idx+size;i++){\\n            vec[i] = mID;\\n        }\\n        return idx;\\n    }\\n    \\n    int free(int mID) {\\n        int cnt = 0;\\n        for(int i = 0;i < n;i++){\\n            if(vec[i] == mID){\\n                vec[i] = -1;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Allocator {\\n    vector<int>vec;\\n    int n;\\npublic:\\n    Allocator(int n) {\\n        vec.resize(n,-1);\\n        this->n = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int cnt = 0;\\n        int idx = -1;\\n        for(int i = 0;i < n;i++){\\n            if(vec[i] == -1){\\n                if(cnt == 0){\\n                    idx = i;\\n                }\\n                cnt++;\\n            }else{\\n                cnt = 0;\\n                idx = -1;\\n            }\\n            if(cnt == size){\\n                break;\\n            }\\n        }\\n        if(idx == -1) return -1;\\n        if(cnt < size) return -1;\\n        for(int i = idx;i < idx+size;i++){\\n            vec[i] = mID;\\n        }\\n        return idx;\\n    }\\n    \\n    int free(int mID) {\\n        int cnt = 0;\\n        for(int i = 0;i < n;i++){\\n            if(vec[i] == mID){\\n                vec[i] = -1;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900277,
                "title": "beats-100-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.ht={}\\n        self.freeMemeory=[[0, n]]\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        if self.freeMemeory:\\n            self.refreshMemeory()\\n        val = self.giveFreeMemeory(size)\\n        if not val:\\n            return -1\\n        # one mID can have multiple occurrences, so need to keep track of all occurrences.\\n        if mID in self.ht:\\n            self.ht[mID].append(val)\\n        else:\\n            self.ht[mID]=[val]\\n        return val[0]\\n        \\n\\n    def free(self, mID: int) -> int:\\n        if self.freeMemeory:\\n            self.refreshMemeory()\\n        if mID not in self.ht or not self.ht[mID]:\\n            return 0\\n        size=0\\n        # suppose we have multiple occurrences of 1 then in that case we need to remove all the occurrences and return the total size.\\n        for ids in self.ht[mID]:\\n            size+=ids[1]-ids[0]\\n            heapq.heappush(self.freeMemeory,ids)\\n        # need to reset the HashTable, once every occurrences are removed\\n        self.ht[mID]=[]\\n        return size\\n\\n    # giveFreeMemeory is to return FIRST FREE MEMORY which comes in the range of size.\\n    def giveFreeMemeory(self, size):\\n        temp=[]\\n        send=[]\\n        while self.freeMemeory:\\n            start, end = heapq.heappop(self.freeMemeory)\\n            if (end-start)>=size:\\n                if (end-start)>size:\\n                    heapq.heappush(self.freeMemeory,[start+size, end])\\n                send=[start, start+size]\\n                break\\n            else:\\n                temp.append([start, end])\\n        if temp:\\n            for i in range(len(temp)):\\n                heapq.heappush(self.freeMemeory,temp[i])\\n        if not send:\\n            return 0\\n        return send\\n\\n    # refreshMemeory function helps us to refactor the memory, suppose we have [[40,50], [12,40]] so this is nothing but [[12,50]], our refreshMemory function will help us do the same.\\n    def refreshMemeory(self):\\n        start, end = heapq.heappop(self.freeMemeory)\\n        temp=[[start, end]]\\n        while self.freeMemeory:\\n            newStart, newEnd = heapq.heappop(self.freeMemeory)\\n            if end==newStart:\\n                temp.pop()\\n                end=newEnd\\n            else:\\n                start=newStart\\n                end=newEnd\\n            temp.append([start, end])\\n        if temp:\\n            for i in range(len(temp)):\\n                heapq.heappush(self.freeMemeory,temp[i])\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.ht={}\\n        self.freeMemeory=[[0, n]]\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        if self.freeMemeory:\\n            self.refreshMemeory()\\n        val = self.giveFreeMemeory(size)\\n        if not val:\\n            return -1\\n        # one mID can have multiple occurrences, so need to keep track of all occurrences.\\n        if mID in self.ht:\\n            self.ht[mID].append(val)\\n        else:\\n            self.ht[mID]=[val]\\n        return val[0]\\n        \\n\\n    def free(self, mID: int) -> int:\\n        if self.freeMemeory:\\n            self.refreshMemeory()\\n        if mID not in self.ht or not self.ht[mID]:\\n            return 0\\n        size=0\\n        # suppose we have multiple occurrences of 1 then in that case we need to remove all the occurrences and return the total size.\\n        for ids in self.ht[mID]:\\n            size+=ids[1]-ids[0]\\n            heapq.heappush(self.freeMemeory,ids)\\n        # need to reset the HashTable, once every occurrences are removed\\n        self.ht[mID]=[]\\n        return size\\n\\n    # giveFreeMemeory is to return FIRST FREE MEMORY which comes in the range of size.\\n    def giveFreeMemeory(self, size):\\n        temp=[]\\n        send=[]\\n        while self.freeMemeory:\\n            start, end = heapq.heappop(self.freeMemeory)\\n            if (end-start)>=size:\\n                if (end-start)>size:\\n                    heapq.heappush(self.freeMemeory,[start+size, end])\\n                send=[start, start+size]\\n                break\\n            else:\\n                temp.append([start, end])\\n        if temp:\\n            for i in range(len(temp)):\\n                heapq.heappush(self.freeMemeory,temp[i])\\n        if not send:\\n            return 0\\n        return send\\n\\n    # refreshMemeory function helps us to refactor the memory, suppose we have [[40,50], [12,40]] so this is nothing but [[12,50]], our refreshMemory function will help us do the same.\\n    def refreshMemeory(self):\\n        start, end = heapq.heappop(self.freeMemeory)\\n        temp=[[start, end]]\\n        while self.freeMemeory:\\n            newStart, newEnd = heapq.heappop(self.freeMemeory)\\n            if end==newStart:\\n                temp.pop()\\n                end=newEnd\\n            else:\\n                start=newStart\\n                end=newEnd\\n            temp.append([start, end])\\n        if temp:\\n            for i in range(len(temp)):\\n                heapq.heappush(self.freeMemeory,temp[i])\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900066,
                "title": "sliding-window-c",
                "content": "```\\nclass Allocator {\\npublic:\\n    vector<int> arr;\\n    Allocator(int n) {\\n        for(int i=0; i<n; i++) arr.push_back(0);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        if(size > arr.size()) return -1;\\n        vector<int> prev = arr;\\n        int i = 0;\\n        for(int j=0; j<arr.size(); j++) {\\n            if(!arr[j]) arr[j] = mID;\\n            else {\\n                while(i <= j) arr[i] = prev[i], i++;\\n            }\\n            if(j - i + 1 == size) break;\\n        }\\n        if(arr.size() - i < size) {\\n            while(i < arr.size()) arr[i] = prev[i], i++;\\n            return -1;\\n        }\\n        return i == arr.size() ? -1 : i;\\n    }\\n    \\n    int free(int mID) {\\n        int cnt = 0;\\n        for(int i=0; i<arr.size(); i++) {\\n            if(arr[i] == mID) arr[i] = 0, cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    vector<int> arr;\\n    Allocator(int n) {\\n        for(int i=0; i<n; i++) arr.push_back(0);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        if(size > arr.size()) return -1;\\n        vector<int> prev = arr;\\n        int i = 0;\\n        for(int j=0; j<arr.size(); j++) {\\n            if(!arr[j]) arr[j] = mID;\\n            else {\\n                while(i <= j) arr[i] = prev[i], i++;\\n            }\\n            if(j - i + 1 == size) break;\\n        }\\n        if(arr.size() - i < size) {\\n            while(i < arr.size()) arr[i] = prev[i], i++;\\n            return -1;\\n        }\\n        return i == arr.size() ? -1 : i;\\n    }\\n    \\n    int free(int mID) {\\n        int cnt = 0;\\n        for(int i=0; i<arr.size(); i++) {\\n            if(arr[i] == mID) arr[i] = 0, cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899930,
                "title": "java-easy-approach-using-array",
                "content": "```\\nclass Allocator {\\n    int map[];\\n    int index;\\n\\n    public Allocator(int n) {\\n        map = new int[n];\\n        index = 0;\\n    }\\n\\n    public int allocate(int size, int mID) {\\n        int freeSpaces = 0;\\n        for (int i = 0; i < map.length; i++) {\\n            //Check for consecutive freeSpaces\\n            if (map[i] == 0) {\\n                freeSpaces++;\\n            } else {\\n                freeSpaces = 0;\\n            }\\n            //if we found the consecutive freeSpaces then fill the mID\\'s\\n            if (freeSpaces == size) {\\n                for (int j = i - size + 1; j <= i; j++) {\\n                    map[j] = mID;\\n                }\\n                return i - size + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    public int free(int mID) {\\n        int c = 0;\\n        for (int i = 0; i < map.length; i++) {\\n            if (map[i] == mID) {\\n                map[i] = 0;\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Allocator {\\n    int map[];\\n    int index;\\n\\n    public Allocator(int n) {\\n        map = new int[n];\\n        index = 0;\\n    }\\n\\n    public int allocate(int size, int mID) {\\n        int freeSpaces = 0;\\n        for (int i = 0; i < map.length; i++) {\\n            //Check for consecutive freeSpaces\\n            if (map[i] == 0) {\\n                freeSpaces++;\\n            } else {\\n                freeSpaces = 0;\\n            }\\n            //if we found the consecutive freeSpaces then fill the mID\\'s\\n            if (freeSpaces == size) {\\n                for (int j = i - size + 1; j <= i; j++) {\\n                    map[j] = mID;\\n                }\\n                return i - size + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    public int free(int mID) {\\n        int c = 0;\\n        for (int i = 0; i < map.length; i++) {\\n            if (map[i] == mID) {\\n                map[i] = 0;\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899828,
                "title": "python-easy-approach-using-array-only-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator(object):\\n\\n    def __init__(self, n):\\n        self.n = n\\n        self.v = [0 for i in range(n)]\\n        \\n\\n    def allocate(self, size, mID):\\n        free = 0\\n        ind = 0\\n        for i in range(0, self.n):\\n            if free == 0: ind = i\\n            elif (free >= size): break\\n            \\n            if(self.v[i] == 0): free+=1\\n            else: free = 0\\n\\n        if(free >= size):\\n            for j in range(ind, ind + size):\\n                self.v[j] = mID\\n\\n        return -1 if free < size else ind\\n\\n    def free(self, mID):\\n        cnt = 0\\n        for i in range(0, self.n):\\n            if (self.v[i] == mID):\\n                self.v[i] = 0\\n                cnt += 1\\n        return cnt\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Allocator(object):\\n\\n    def __init__(self, n):\\n        self.n = n\\n        self.v = [0 for i in range(n)]\\n        \\n\\n    def allocate(self, size, mID):\\n        free = 0\\n        ind = 0\\n        for i in range(0, self.n):\\n            if free == 0: ind = i\\n            elif (free >= size): break\\n            \\n            if(self.v[i] == 0): free+=1\\n            else: free = 0\\n\\n        if(free >= size):\\n            for j in range(ind, ind + size):\\n                self.v[j] = mID\\n\\n        return -1 if free < size else ind\\n\\n    def free(self, mID):\\n        cnt = 0\\n        for i in range(0, self.n):\\n            if (self.v[i] == mID):\\n                self.v[i] = 0\\n                cnt += 1\\n        return cnt\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899718,
                "title": "simple-vector-and-map-used",
                "content": "Create a vector and map\\nthen initialize the vector with size n with every elements -1.\\n\\n// Read comments on code\\n\\n```\\nclass Allocator {\\npublic:\\n    vector<int> vec;\\n    map<int,int> mp;\\n    Allocator(int n) {\\n        vector<int> arr(n,-1);\\n        vec=arr;\\n    }\\n    \\n    int allocate(int size, int mId) {\\n\\t    // cnt variable will tell possible of size or not\\n        int cnt = 0;\\n\\t\\t//l will keep the left index and r will keep the right \\n        int l =-1;\\n        int r =-1;\\n        for(int i=0;i<vec.size();i++){\\n\\t\\t    // if vec[i] empty the means -1 then cnt++ and update left index\\n            if(vec[i]==-1){\\n                if(cnt==0 && l==-1) l=i;\\n                cnt++;\\n            }\\n\\t\\t\\t// or set cnt=0 and left index also\\n            else{\\n                l=-1;\\n                cnt=0;\\n            }\\n\\t\\t\\t// if cnt==size then break \\n            if(cnt==size){\\n                r=i;\\n                break;\\n            }\\n        }\\n        //if it is possible then only store the right index\\n        if(cnt==size){\\n\\t\\t   // iterate l to r index and store value the mID\\n\\t\\t   // also add map\\n            for(int i=l;i<=r;i++){\\n                vec[i]=mId;\\n                mp[mId]++;\\n            }\\n            return l;\\n        }else{\\n            return -1;\\n        }\\n        \\n    }\\n    \\n    int free(int mId) {\\n\\t    // if map exist then return the map size and empty the vector of the mID\\n        if(mp.count(mId)>0){\\n            for(int i=0;i<vec.size();i++){\\n                if(vec[i]==mId) vec[i]=-1;\\n            }\\n            int ans = mp[mId];\\n\\t\\t\\t// delete that key from the map\\n            mp.erase(mId);\\n            return ans;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    vector<int> vec;\\n    map<int,int> mp;\\n    Allocator(int n) {\\n        vector<int> arr(n,-1);\\n        vec=arr;\\n    }\\n    \\n    int allocate(int size, int mId) {\\n\\t    // cnt variable will tell possible of size or not\\n        int cnt = 0;\\n\\t\\t//l will keep the left index and r will keep the right \\n        int l =-1;\\n        int r =-1;\\n        for(int i=0;i<vec.size();i++){\\n\\t\\t    // if vec[i] empty the means -1 then cnt++ and update left index\\n            if(vec[i]==-1){\\n                if(cnt==0 && l==-1) l=i;\\n                cnt++;\\n            }\\n\\t\\t\\t// or set cnt=0 and left index also\\n            else{\\n                l=-1;\\n                cnt=0;\\n            }\\n\\t\\t\\t// if cnt==size then break \\n            if(cnt==size){\\n                r=i;\\n                break;\\n            }\\n        }\\n        //if it is possible then only store the right index\\n        if(cnt==size){\\n\\t\\t   // iterate l to r index and store value the mID\\n\\t\\t   // also add map\\n            for(int i=l;i<=r;i++){\\n                vec[i]=mId;\\n                mp[mId]++;\\n            }\\n            return l;\\n        }else{\\n            return -1;\\n        }\\n        \\n    }\\n    \\n    int free(int mId) {\\n\\t    // if map exist then return the map size and empty the vector of the mID\\n        if(mp.count(mId)>0){\\n            for(int i=0;i<vec.size();i++){\\n                if(vec[i]==mId) vec[i]=-1;\\n            }\\n            int ans = mp[mId];\\n\\t\\t\\t// delete that key from the map\\n            mp.erase(mId);\\n            return ans;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899670,
                "title": "c-implementation-using-vector-easy-72-time-18-space",
                "content": "```\\nclass Allocator {\\npublic:\\n    vector<int> v;\\n    int sz;\\n  \\n    Allocator(int n) {\\n      v.resize(n, 0);\\n      sz = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n      if(size > count(v.begin(), v.end(), 0)) return -1;\\n      int cnt = 0;\\n      bool flag = false;\\n      for(int i = 0; i < sz; i++){\\n        if(v[i] == 0){\\n          cnt++;\\n          if(cnt == size){\\n            flag = true; cnt = i;\\n          }\\n        } else {\\n          cnt = 0;\\n        }\\n        if(flag) break;\\n      } \\n      if(flag)\\n        for(int i = cnt - size + 1; i <= cnt; i++){\\n          v[i] = mID;\\n        }\\n      return flag ? cnt - size + 1 : -1;\\n    }\\n    \\n    int free(int mID) {\\n      int res = 0;\\n      for(int i = 0; i < sz; i++){\\n        if(v[i] == mID) {\\n          v[i] = 0; res++;\\n        }\\n      }\\n      return res;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    vector<int> v;\\n    int sz;\\n  \\n    Allocator(int n) {\\n      v.resize(n, 0);\\n      sz = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n      if(size > count(v.begin(), v.end(), 0)) return -1;\\n      int cnt = 0;\\n      bool flag = false;\\n      for(int i = 0; i < sz; i++){\\n        if(v[i] == 0){\\n          cnt++;\\n          if(cnt == size){\\n            flag = true; cnt = i;\\n          }\\n        } else {\\n          cnt = 0;\\n        }\\n        if(flag) break;\\n      } \\n      if(flag)\\n        for(int i = cnt - size + 1; i <= cnt; i++){\\n          v[i] = mID;\\n        }\\n      return flag ? cnt - size + 1 : -1;\\n    }\\n    \\n    int free(int mID) {\\n      int res = 0;\\n      for(int i = 0; i < sz; i++){\\n        if(v[i] == mID) {\\n          v[i] = 0; res++;\\n        }\\n      }\\n      return res;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899640,
                "title": "sliding-window-linear-search-clean-solution",
                "content": "\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    Allocator(int n) {\\n        arr.resize(n);\\n    }\\n    int allocate(int size, int mID) {\\n        int idx = -1,cnt = 0;\\n        bool flag = false;\\n        for(int i= 0;i<arr.size();i++){\\n             if(arr[i])continue;\\n             idx = i,cnt = 0;\\n             while(i < arr.size() and !arr[i]){\\n                 ++i;\\n                 if(++cnt == size)break;\\n             };\\n             if(cnt != size)continue;\\n             flag = true;\\n             break;\\n        }\\n        if(!flag or idx == -1)return -1;\\n        for(int len = idx;len< size+idx;len++)arr[len] = mID;\\n        return idx;\\n    }\\n    \\n    int free(int mID,int cnt = 0) {\\n        for(int i=0; i<arr.size(); i++)\\n            if(arr[i]==mID)cnt++, arr[i]=0;\\n        st.erase(mID);\\n        return cnt;\\n    }\\nprivate:\\n    vector<int> arr;\\n    unordered_set<int> st;\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    Allocator(int n) {\\n        arr.resize(n);\\n    }\\n    int allocate(int size, int mID) {\\n        int idx = -1,cnt = 0;\\n        bool flag = false;\\n        for(int i= 0;i<arr.size();i++){\\n             if(arr[i])continue;\\n             idx = i,cnt = 0;\\n             while(i < arr.size() and !arr[i]){\\n                 ++i;\\n                 if(++cnt == size)break;\\n             };\\n             if(cnt != size)continue;\\n             flag = true;\\n             break;\\n        }\\n        if(!flag or idx == -1)return -1;\\n        for(int len = idx;len< size+idx;len++)arr[len] = mID;\\n        return idx;\\n    }\\n    \\n    int free(int mID,int cnt = 0) {\\n        for(int i=0; i<arr.size(); i++)\\n            if(arr[i]==mID)cnt++, arr[i]=0;\\n        st.erase(mID);\\n        return cnt;\\n    }\\nprivate:\\n    vector<int> arr;\\n    unordered_set<int> st;\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899588,
                "title": "simplest-python-solution-without-hashmap",
                "content": "# Code\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.mem = [0]*n\\n        \\n    def allocate(self, size: int, mID: int) -> int:\\n        def checksize(size):\\n            flag = False \\n            pos = -1\\n            count = 0\\n            for i in range(0, len(self.mem)):\\n                if self.mem[i] == 0:\\n                    flag = True\\n                    count += 1\\n                    if count == size:\\n                        return pos + 1\\n                else:\\n                    if count >= size:\\n                        return pos + 1\\n                    pos = i\\n                    count = 0\\n            return -1\\n                \\n                \\n        idx = checksize(size)\\n        if idx == -1:\\n            return -1\\n        else:\\n            for i in range(idx, idx+size):\\n                self.mem[i] = mID\\n            return idx\\n        \\n    def free(self, mID: int) -> int:\\n        count = 0\\n        for i in range(0, len(self.mem)):\\n            if self.mem[i] == mID:\\n                self.mem[i] = 0\\n                count += 1\\n        return count\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.mem = [0]*n\\n        \\n    def allocate(self, size: int, mID: int) -> int:\\n        def checksize(size):\\n            flag = False \\n            pos = -1\\n            count = 0\\n            for i in range(0, len(self.mem)):\\n                if self.mem[i] == 0:\\n                    flag = True\\n                    count += 1\\n                    if count == size:\\n                        return pos + 1\\n                else:\\n                    if count >= size:\\n                        return pos + 1\\n                    pos = i\\n                    count = 0\\n            return -1\\n                \\n                \\n        idx = checksize(size)\\n        if idx == -1:\\n            return -1\\n        else:\\n            for i in range(idx, idx+size):\\n                self.mem[i] = mID\\n            return idx\\n        \\n    def free(self, mID: int) -> int:\\n        count = 0\\n        for i in range(0, len(self.mem)):\\n            if self.mem[i] == mID:\\n                self.mem[i] = 0\\n                count += 1\\n        return count\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899583,
                "title": "how-can-i-solve-this-compile-error-c",
                "content": "There are TWO given functions in the same name \"allocatorFree\" which made this error.\\n___________________________________________________\\nGiven code\\nint allocatorFree(Allocator* obj, int mID) {\\n}\\nvoid allocatorFree(Allocator* obj) {\\n}\\n____________________________________________________\\nError\\nLine 74: Char 6: error: conflicting types for \\u2018allocatorFree\\u2019 [solution.c]\\n void allocatorFree(Allocator* obj) {\\n      ^~~~~~~~~~~~~\\n________________________________________________\\nI tried to remove the \"void\" one like this. But also got another error.\\n______________________________________________________\\nCode\\nint allocatorFree(Allocator* obj, int mID) {\\n      // my code\\n}\\n// no void function anymore\\n______________________________________________________\\nError\\nsolution.c: In function \\u2018__helper__\\u2019\\nLine 227: Char 5: error: too few arguments to function \\u2018allocatorFree\\u2019 [solution.c]\\n     allocatorFree(obj);\\n     ^~~~~~~~~~~~~\\n_______________________________________________\\nNote in the last several lines of the given code.\\n_____________________________________________\\n/**\\n * Your Allocator struct will be instantiated and called as such:\\n * Allocator* obj = allocatorCreate(n);\\n * int param_1 = allocatorAllocate(obj, size, mID);\\n \\n * int param_2 = allocatorFree(obj, mID);\\n \\n * allocatorFree(obj);\\n*/",
                "solutionTags": [
                    "C"
                ],
                "code": "There are TWO given functions in the same name \"allocatorFree\" which made this error.\\n___________________________________________________\\nGiven code\\nint allocatorFree(Allocator* obj, int mID) {\\n}\\nvoid allocatorFree(Allocator* obj) {\\n}\\n____________________________________________________\\nError\\nLine 74: Char 6: error: conflicting types for \\u2018allocatorFree\\u2019 [solution.c]\\n void allocatorFree(Allocator* obj) {\\n      ^~~~~~~~~~~~~\\n________________________________________________\\nI tried to remove the \"void\" one like this. But also got another error.\\n______________________________________________________\\nCode\\nint allocatorFree(Allocator* obj, int mID) {\\n      // my code\\n}\\n// no void function anymore\\n______________________________________________________\\nError\\nsolution.c: In function \\u2018__helper__\\u2019\\nLine 227: Char 5: error: too few arguments to function \\u2018allocatorFree\\u2019 [solution.c]\\n     allocatorFree(obj);\\n     ^~~~~~~~~~~~~\\n_______________________________________________\\nNote in the last several lines of the given code.\\n_____________________________________________\\n/**\\n * Your Allocator struct will be instantiated and called as such:\\n * Allocator* obj = allocatorCreate(n);\\n * int param_1 = allocatorAllocate(obj, size, mID);\\n \\n * int param_2 = allocatorFree(obj, mID);\\n \\n * allocatorFree(obj);\\n*/",
                "codeTag": "Unknown"
            },
            {
                "id": 2899534,
                "title": "easy-to-understand-c-accepted",
                "content": "# Code\\n```\\nclass Allocator {\\npublic:\\n    int n;\\n    vector<int> arr;\\n    Allocator(int m) {\\n        n = m;\\n        for(int i=0;i<m;i++) arr.push_back(-1);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        // if the size > n\\n        int i=0;\\n        while(i<n) \\n        {\\n            if(arr[i] == -1) {\\n                int count = 0;\\n                int j=i;\\n                while(j<n && arr[j] == -1) {\\n                    count++;\\n                    j++;\\n                    if(count == size) break;\\n                }\\n                if(count == size) {\\n                    for(int x=i;x<i+count;x++) arr[x] = mID;\\n                    return i;\\n                }\\n                i=j;\\n            }\\n            i++;\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int count = 0;\\n        for(int i=0;i<n;i++) {\\n            if(arr[i] == mID){\\n                arr[i] = -1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    int n;\\n    vector<int> arr;\\n    Allocator(int m) {\\n        n = m;\\n        for(int i=0;i<m;i++) arr.push_back(-1);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        // if the size > n\\n        int i=0;\\n        while(i<n) \\n        {\\n            if(arr[i] == -1) {\\n                int count = 0;\\n                int j=i;\\n                while(j<n && arr[j] == -1) {\\n                    count++;\\n                    j++;\\n                    if(count == size) break;\\n                }\\n                if(count == size) {\\n                    for(int x=i;x<i+count;x++) arr[x] = mID;\\n                    return i;\\n                }\\n                i=j;\\n            }\\n            i++;\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int count = 0;\\n        for(int i=0;i<n;i++) {\\n            if(arr[i] == mID){\\n                arr[i] = -1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899493,
                "title": "c-java-python3-brute-force",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/8f409c5e220a4a1a1d7fdfbfcc1dcd24eeead232) for solutions of weekly 323. \\n\\n**Intuition**\\nThis is a brute-force solution where in `allocate` I traverse the whole `memory` array to find the consecutive free block of given size and in `free` I also traverse the whole `memory` to free memory with given id. \\n\\n**Implementation**\\n**C++**\\n```\\nclass Allocator {\\n    vector<int> memory; \\npublic:\\n    Allocator(int n) {\\n        memory.resize(n); \\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int cnt = 0; \\n        for (int i = 0; i < memory.size(); ++i) \\n            if (memory[i] == 0) {\\n                if (++cnt == size) {\\n                    for (int ii = i; ii >= i-size+1; --ii)\\n                        memory[ii] = mID; \\n                    return i-size+1; \\n                }\\n            } else cnt = 0; \\n        return -1; \\n    }\\n    \\n    int free(int mID) {\\n        int ans = 0; \\n        for (int i = 0; i < memory.size(); ++i) \\n            if (memory[i] == mID) {\\n                ++ans; \\n                memory[i] = 0; \\n            }\\n        return ans; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Allocator {\\n    private int[] memory; \\n    \\n    public Allocator(int n) {\\n        memory = new int[n]; \\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int cnt = 0; \\n        for (int i = 0; i < memory.length; ++i) {\\n            if (memory[i] == 0) {\\n                if (++cnt == size) {\\n                    for (int ii = i; ii >= i-size+1; --ii) \\n                        memory[ii] = mID; \\n                    return i-size+1; \\n                }\\n            } else cnt = 0; \\n        }\\n        return -1; \\n    }\\n    \\n    public int free(int mID) {\\n        int ans = 0; \\n        for (int i = 0; i < memory.length; ++i) \\n            if (memory[i] == mID) {\\n                ++ans; \\n                memory[i] = 0; \\n            }\\n        return ans; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.memory = [0] * n \\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        cnt = 0 \\n        for i, x in enumerate(self.memory): \\n            if x == 0: \\n                cnt += 1\\n                if cnt == size: break \\n            else: cnt = 0 \\n        else: return -1 \\n        self.memory[i-size+1 : i+1] = [mID]*size\\n        return i-size+1\\n\\n    def free(self, mID: int) -> int:\\n        ans = 0 \\n        for i, x in enumerate(self.memory): \\n            if x == mID: \\n                ans += 1\\n                self.memory[i] = 0 \\n        return ans \\n```\\n**Complexity**\\nTime `O(N)` for `allocate` and `free`\\nSpace `O(N)`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Allocator {\\n    vector<int> memory; \\npublic:\\n    Allocator(int n) {\\n        memory.resize(n); \\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int cnt = 0; \\n        for (int i = 0; i < memory.size(); ++i) \\n            if (memory[i] == 0) {\\n                if (++cnt == size) {\\n                    for (int ii = i; ii >= i-size+1; --ii)\\n                        memory[ii] = mID; \\n                    return i-size+1; \\n                }\\n            } else cnt = 0; \\n        return -1; \\n    }\\n    \\n    int free(int mID) {\\n        int ans = 0; \\n        for (int i = 0; i < memory.size(); ++i) \\n            if (memory[i] == mID) {\\n                ++ans; \\n                memory[i] = 0; \\n            }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Allocator {\\n    private int[] memory; \\n    \\n    public Allocator(int n) {\\n        memory = new int[n]; \\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int cnt = 0; \\n        for (int i = 0; i < memory.length; ++i) {\\n            if (memory[i] == 0) {\\n                if (++cnt == size) {\\n                    for (int ii = i; ii >= i-size+1; --ii) \\n                        memory[ii] = mID; \\n                    return i-size+1; \\n                }\\n            } else cnt = 0; \\n        }\\n        return -1; \\n    }\\n    \\n    public int free(int mID) {\\n        int ans = 0; \\n        for (int i = 0; i < memory.length; ++i) \\n            if (memory[i] == mID) {\\n                ++ans; \\n                memory[i] = 0; \\n            }\\n        return ans; \\n    }\\n}\\n```\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.memory = [0] * n \\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        cnt = 0 \\n        for i, x in enumerate(self.memory): \\n            if x == 0: \\n                cnt += 1\\n                if cnt == size: break \\n            else: cnt = 0 \\n        else: return -1 \\n        self.memory[i-size+1 : i+1] = [mID]*size\\n        return i-size+1\\n\\n    def free(self, mID: int) -> int:\\n        ans = 0 \\n        for i, x in enumerate(self.memory): \\n            if x == mID: \\n                ans += 1\\n                self.memory[i] = 0 \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899460,
                "title": "c-easy-solution-using-unordered-map",
                "content": "\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    vector<int> arr;\\n    unordered_map<int,int>mp;\\n    int n;\\n    Allocator(int n) {\\n        this->n=n;\\n        arr.resize(n);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==0){\\n                int k=i,b=0;\\n                 while(i<n && arr[i]==0){\\n                     i++;\\n                     b++;\\n}\\n                if(b>=size){\\n                    for(int j=k;j<k+size;j++){\\n                        arr[j]=mID;\\n                    }\\n                        mp[mID]=k;\\n                        return k;\\n                        \\n\\n}\\n}\\n}\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n     int i=mp[mID],b=0;\\n        for(int i=0;i<n;i++){\\n     if(arr[i]==mID)\\n     { b++;\\n            arr[i]=0;}\\n        }\\n    mp.erase(mID);\\n    return b;\\n    }\\n        \\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    vector<int> arr;\\n    unordered_map<int,int>mp;\\n    int n;\\n    Allocator(int n) {\\n        this->n=n;\\n        arr.resize(n);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==0){\\n                int k=i,b=0;\\n                 while(i<n && arr[i]==0){\\n                     i++;\\n                     b++;\\n}\\n                if(b>=size){\\n                    for(int j=k;j<k+size;j++){\\n                        arr[j]=mID;\\n                    }\\n                        mp[mID]=k;\\n                        return k;\\n                        \\n\\n}\\n}\\n}\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n     int i=mp[mID],b=0;\\n        for(int i=0;i<n;i++){\\n     if(arr[i]==mID)\\n     { b++;\\n            arr[i]=0;}\\n        }\\n    mp.erase(mID);\\n    return b;\\n    }\\n        \\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899456,
                "title": "python-3-first-fit",
                "content": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.nums = [0] * n\\n        \\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        if size > len(self.nums): return -1\\n        \\n\\t\\t# availableBlocks is to calculate size of available memory blocks  and their starting index.\\n        availableBlocks = []\\n        cnt = start = 0\\n        for idx, i in enumerate(self.nums):\\n            if i == 0:\\n                if cnt == 0: start = idx\\n                cnt += 1\\n            else:\\n                if cnt != 0: availableBlocks.append([cnt, start])\\n                cnt = 0\\n        if cnt != 0:\\n            availableBlocks.append([cnt, start])\\n        \\n\\t\\t# now check the available memory blocks to fit the new incoming block\\n        for i, j in availableBlocks:\\n            if size <= i:\\n                for x in range(j, j + size):\\n                    self.nums[x] = mID\\n                return j\\n        return -1\\n        \\n\\n    def free(self, mID: int) -> int:\\n        res = 0\\n        for i in range(len(self.nums)):\\n            if self.nums[i] == mID:\\n                res += 1\\n                self.nums[i] = 0\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Design"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.nums = [0] * n\\n        \\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        if size > len(self.nums): return -1\\n        \\n\\t\\t# availableBlocks is to calculate size of available memory blocks  and their starting index.\\n        availableBlocks = []\\n        cnt = start = 0\\n        for idx, i in enumerate(self.nums):\\n            if i == 0:\\n                if cnt == 0: start = idx\\n                cnt += 1\\n            else:\\n                if cnt != 0: availableBlocks.append([cnt, start])\\n                cnt = 0\\n        if cnt != 0:\\n            availableBlocks.append([cnt, start])\\n        \\n\\t\\t# now check the available memory blocks to fit the new incoming block\\n        for i, j in availableBlocks:\\n            if size <= i:\\n                for x in range(j, j + size):\\n                    self.nums[x] = mID\\n                return j\\n        return -1\\n        \\n\\n    def free(self, mID: int) -> int:\\n        res = 0\\n        for i in range(len(self.nums)):\\n            if self.nums[i] == mID:\\n                res += 1\\n                self.nums[i] = 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899414,
                "title": "python-brute-force-solution-list-and-dictionary",
                "content": "```\\nclass Allocator:\\n    def __init__(self, n: int):\\n        self.q = [0]*n\\n        self.allo_me = defaultdict(list)\\n\\n    def allocate(self, size: int, m: int) -> int:\\n        idx, s = -1, 0\\n        for i in range(len(self.q)):\\n            if self.q[i]==0:\\n                if idx==-1:\\n                    idx, s = i, 1\\n                else:\\n                    s += 1\\n                if s==size:\\n                    break\\n            else:\\n                idx, s = -1, 0\\n        if s==size:\\n            for i in range(idx, idx+size):\\n                self.q[i] = m\\n                self.allo_me[m].append(i)\\n        else:\\n            idx = -1\\n        return idx\\n            \\n            \\n    def free(self, m: int) -> int:\\n        if m not in self.allo_me:\\n            return 0\\n        ans = len(self.allo_me[m])\\n        for i in self.allo_me[m]:\\n            self.q[i] = 0\\n        self.allo_me[m] = []\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Allocator:\\n    def __init__(self, n: int):\\n        self.q = [0]*n\\n        self.allo_me = defaultdict(list)\\n\\n    def allocate(self, size: int, m: int) -> int:\\n        idx, s = -1, 0\\n        for i in range(len(self.q)):\\n            if self.q[i]==0:\\n                if idx==-1:\\n                    idx, s = i, 1\\n                else:\\n                    s += 1\\n                if s==size:\\n                    break\\n            else:\\n                idx, s = -1, 0\\n        if s==size:\\n            for i in range(idx, idx+size):\\n                self.q[i] = m\\n                self.allo_me[m].append(i)\\n        else:\\n            idx = -1\\n        return idx\\n            \\n            \\n    def free(self, m: int) -> int:\\n        if m not in self.allo_me:\\n            return 0\\n        ans = len(self.allo_me[m])\\n        for i in self.allo_me[m]:\\n            self.q[i] = 0\\n        self.allo_me[m] = []\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899401,
                "title": "straight-forward-java-solution-hashmap-treemap",
                "content": "Very straight forward, only thing worth mentioning is TreeMap.firstKey() and TreeMap.higherKey().\\n\\nUse 2 Map to store allocated blocks\\n**id2start**: each mID will have a List of block\\'s start indices\\n**start2end**: each allocated block\\'s range of <start, end>\\n\\n**allocate**(): will go from low to high of allocated blocklist to search\\n**free**(): will remove allocated blocks from id2start and start2end.\\n\\n\\n# Code\\n```\\nclass Allocator {\\n    int capacity = 0;\\n    Map<Integer, List<Integer>> id2start;\\n    TreeMap<Integer, Integer> start2end;\\n\\n    public Allocator(int n) {\\n        capacity = n;\\n        id2start = new HashMap<>();\\n        start2end = new TreeMap<>();\\n    }\\n\\n    public int allocate(int size, int mID) {\\n        Integer ite = start2end.isEmpty()?null:start2end.firstKey();\\n        Integer ret = 0;\\n        if (ite==null || ite >= size) {\\n            if (size > capacity) {\\n                return -1;\\n            }\\n            ret = 0;\\n            start2end.put(ret, size);\\n            id2start.computeIfAbsent(mID, a->new ArrayList<>()).add(ret);\\n            return ret;\\n        }\\n        Integer nextStart = start2end.higherKey(ite);\\n        while (nextStart!= null && nextStart - start2end.get(ite) < size) {\\n            ite = nextStart;\\n            nextStart = start2end.higherKey(ite);\\n        }\\n        if (nextStart!= null || capacity - start2end.get(ite) >= size) {\\n            ret = start2end.get(ite);\\n            start2end.put(ret, ret+size);\\n            id2start.computeIfAbsent(mID, a->new ArrayList<>()).add(ret);\\n            return ret;\\n        } else {\\n            return -1;\\n        }\\n    }\\n\\n    public int free(int mID) {\\n        List<Integer> starts = id2start.get(mID);\\n        if (starts == null || starts.size() == 0)\\n            return 0;\\n        int ret = 0;\\n        for (int start: starts) {\\n            Integer end = start2end.get(start);\\n            ret += (end-start);\\n            start2end.remove(start);\\n        }\\n        id2start.remove(mID);\\n        return ret;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    int capacity = 0;\\n    Map<Integer, List<Integer>> id2start;\\n    TreeMap<Integer, Integer> start2end;\\n\\n    public Allocator(int n) {\\n        capacity = n;\\n        id2start = new HashMap<>();\\n        start2end = new TreeMap<>();\\n    }\\n\\n    public int allocate(int size, int mID) {\\n        Integer ite = start2end.isEmpty()?null:start2end.firstKey();\\n        Integer ret = 0;\\n        if (ite==null || ite >= size) {\\n            if (size > capacity) {\\n                return -1;\\n            }\\n            ret = 0;\\n            start2end.put(ret, size);\\n            id2start.computeIfAbsent(mID, a->new ArrayList<>()).add(ret);\\n            return ret;\\n        }\\n        Integer nextStart = start2end.higherKey(ite);\\n        while (nextStart!= null && nextStart - start2end.get(ite) < size) {\\n            ite = nextStart;\\n            nextStart = start2end.higherKey(ite);\\n        }\\n        if (nextStart!= null || capacity - start2end.get(ite) >= size) {\\n            ret = start2end.get(ite);\\n            start2end.put(ret, ret+size);\\n            id2start.computeIfAbsent(mID, a->new ArrayList<>()).add(ret);\\n            return ret;\\n        } else {\\n            return -1;\\n        }\\n    }\\n\\n    public int free(int mID) {\\n        List<Integer> starts = id2start.get(mID);\\n        if (starts == null || starts.size() == 0)\\n            return 0;\\n        int ret = 0;\\n        for (int start: starts) {\\n            Integer end = start2end.get(start);\\n            ret += (end-start);\\n            start2end.remove(start);\\n        }\\n        id2start.remove(mID);\\n        return ret;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076506,
                "title": "c-python-binary-search-tree-solution-with-explanation",
                "content": "We can use binary search tree to record intervals we have used,\\nkey is start, value is end, and interval is [start, end).\\nAnd use a hash map to record which interval belong to mID.\\n\\nAllocation strategy is first fit, 2 spaces whose size >= size, we use the leftmost space.\\n\\ntc of free is O(number of interval belong to mID).\\ntc of allocate is O(number of interval in Allocator + log(number of interval in Allocator)).\\n\\n\\n### python\\n\\n```python\\nfrom sortedcontainers import SortedDict\\nclass Allocator:\\n    def __init__(self, n: int):\\n        self.interval = SortedDict({n: n}) # sentinel, positions after n can not use.\\n        self.id_interval = defaultdict(list)\\n    \\n    def allocate(self, size: int, mID: int) -> int:\\n        end = 0 # [end, s) space we can assign\\n        for s, e in self.interval.items():\\n            # [s, e) is the space we have used\\n            if s - end >= size:\\n                self.interval[end] = end + size\\n                self.id_interval[mID].append(end)\\n                return end\\n            end = e\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        cnt = 0\\n        for start in self.id_interval[mID]:\\n            cnt += self.interval[start] - start\\n            self.interval.pop(start)\\n        self.id_interval.pop(mID)\\n        return cnt\\n```\\n\\n### c++\\n```cpp\\nclass Allocator {\\npublic:\\n    map<int, int> interval;\\n    unordered_map<int, vector<int>> id_interval;\\n    Allocator(int n): interval {{n, n}} {}\\n    \\n    int allocate(int size, int mID) {\\n        int end = 0;\\n        for (auto& [s, e]: this -> interval) {\\n            if (s - end >= size) {\\n                this -> interval[end] = end + size;\\n                this -> id_interval[mID].emplace_back(end);\\n                return end;\\n            }\\n            end = e;\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        if (this -> id_interval.count(mID) == 0) return 0;\\n        int cnt = 0;\\n        for (auto& s: this -> id_interval[mID]) {\\n            cnt += this -> interval[s] - s;\\n            this -> interval.erase(s);\\n        }\\n        this -> id_interval.erase(mID);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```python\\nfrom sortedcontainers import SortedDict\\nclass Allocator:\\n    def __init__(self, n: int):\\n        self.interval = SortedDict({n: n}) # sentinel, positions after n can not use.\\n        self.id_interval = defaultdict(list)\\n    \\n    def allocate(self, size: int, mID: int) -> int:\\n        end = 0 # [end, s) space we can assign\\n        for s, e in self.interval.items():\\n            # [s, e) is the space we have used\\n            if s - end >= size:\\n                self.interval[end] = end + size\\n                self.id_interval[mID].append(end)\\n                return end\\n            end = e\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        cnt = 0\\n        for start in self.id_interval[mID]:\\n            cnt += self.interval[start] - start\\n            self.interval.pop(start)\\n        self.id_interval.pop(mID)\\n        return cnt\\n```\n```cpp\\nclass Allocator {\\npublic:\\n    map<int, int> interval;\\n    unordered_map<int, vector<int>> id_interval;\\n    Allocator(int n): interval {{n, n}} {}\\n    \\n    int allocate(int size, int mID) {\\n        int end = 0;\\n        for (auto& [s, e]: this -> interval) {\\n            if (s - end >= size) {\\n                this -> interval[end] = end + size;\\n                this -> id_interval[mID].emplace_back(end);\\n                return end;\\n            }\\n            end = e;\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        if (this -> id_interval.count(mID) == 0) return 0;\\n        int cnt = 0;\\n        for (auto& s: this -> id_interval[mID]) {\\n            cnt += this -> interval[s] - s;\\n            this -> interval.erase(s);\\n        }\\n        this -> id_interval.erase(mID);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061663,
                "title": "elegant-linked-list-design-c-oop-interview",
                "content": "# Code\\n```\\nstruct Node {\\n    Node(int startVal, int sizeVal, int mIDVal) \\n        : start(startVal), size(sizeVal), mID(mIDVal) {}\\n\\n    /**\\n    Insert this node between left and right\\n    */\\n    void insert(Node* left, Node* right) {\\n        left->next = this;\\n        this->next = right;\\n        this->prev = left;\\n        right->prev = this;\\n    }\\n\\n    /**\\n    Merge this node with the node to the right\\n    */\\n    void merge(Node* right) {\\n        size += right->size;\\n        next = right->next;\\n        right->next->prev = this;\\n        delete right; \\n    }\\n\\n    int start;\\n    int size;\\n    int mID;\\n    Node* next;\\n    Node* prev;\\n};\\n\\nclass Allocator {\\npublic:\\n    Allocator(int n) {\\n        leftDummy = new Node(0, 0, 0);\\n        rightDummy = new Node(0, 0, 0);\\n        Node* freeNode = new Node(0, n, -1); \\n        leftDummy->next = freeNode;\\n        freeNode->prev = leftDummy;\\n        freeNode->next = rightDummy;\\n        rightDummy->prev = freeNode;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        Node* curr = leftDummy->next;\\n        while (curr != rightDummy) {\\n            if (curr->mID == -1 && curr->size > size) {\\n                curr->size -= size;\\n                Node* mem = new Node(curr->start, size, mID);\\n                curr->start += size;\\n                mem->insert(curr->prev, curr);\\n                idToNodes[mID].push_back(mem);\\n                return mem->start;\\n            } else if (curr->mID == -1 && curr->size == size) {\\n                curr->mID = mID;\\n                idToNodes[mID].push_back(curr);\\n                return curr->start;\\n            } \\n            curr = curr->next;\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int freed = 0;\\n        for (auto& node : idToNodes[mID]) {\\n            freed += node->size;\\n            node->mID = -1;\\n            if (node->next->mID == -1) {\\n                node->merge(node->next);\\n            }\\n            if (node->prev->mID == -1) {\\n                node->prev->merge(node);\\n            }\\n        }\\n        idToNodes.erase(mID);\\n        return freed;\\n    }\\n\\nprivate:\\n    Node* leftDummy;\\n    Node* rightDummy;\\n    std::unordered_map<int, std::vector<Node*>> idToNodes; \\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node {\\n    Node(int startVal, int sizeVal, int mIDVal) \\n        : start(startVal), size(sizeVal), mID(mIDVal) {}\\n\\n    /**\\n    Insert this node between left and right\\n    */\\n    void insert(Node* left, Node* right) {\\n        left->next = this;\\n        this->next = right;\\n        this->prev = left;\\n        right->prev = this;\\n    }\\n\\n    /**\\n    Merge this node with the node to the right\\n    */\\n    void merge(Node* right) {\\n        size += right->size;\\n        next = right->next;\\n        right->next->prev = this;\\n        delete right; \\n    }\\n\\n    int start;\\n    int size;\\n    int mID;\\n    Node* next;\\n    Node* prev;\\n};\\n\\nclass Allocator {\\npublic:\\n    Allocator(int n) {\\n        leftDummy = new Node(0, 0, 0);\\n        rightDummy = new Node(0, 0, 0);\\n        Node* freeNode = new Node(0, n, -1); \\n        leftDummy->next = freeNode;\\n        freeNode->prev = leftDummy;\\n        freeNode->next = rightDummy;\\n        rightDummy->prev = freeNode;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        Node* curr = leftDummy->next;\\n        while (curr != rightDummy) {\\n            if (curr->mID == -1 && curr->size > size) {\\n                curr->size -= size;\\n                Node* mem = new Node(curr->start, size, mID);\\n                curr->start += size;\\n                mem->insert(curr->prev, curr);\\n                idToNodes[mID].push_back(mem);\\n                return mem->start;\\n            } else if (curr->mID == -1 && curr->size == size) {\\n                curr->mID = mID;\\n                idToNodes[mID].push_back(curr);\\n                return curr->start;\\n            } \\n            curr = curr->next;\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int freed = 0;\\n        for (auto& node : idToNodes[mID]) {\\n            freed += node->size;\\n            node->mID = -1;\\n            if (node->next->mID == -1) {\\n                node->merge(node->next);\\n            }\\n            if (node->prev->mID == -1) {\\n                node->prev->merge(node);\\n            }\\n        }\\n        idToNodes.erase(mID);\\n        return freed;\\n    }\\n\\nprivate:\\n    Node* leftDummy;\\n    Node* rightDummy;\\n    std::unordered_map<int, std::vector<Node*>> idToNodes; \\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887083,
                "title": "javascript-es6-o-n",
                "content": "```\\n/**\\n * @param {number} n\\n */\\nvar Allocator = function(n) {\\n    this.memory = Array(n).fill(null)\\n};\\n\\n/** \\n * @param {number} size \\n * @param {number} mID\\n * @return {number}\\n */\\nAllocator.prototype.allocate = function(size, mID) {\\n    let startIndex = -1\\n\\n    // Find first available block, if one exists\\n    for (let i = 0; i < this.memory.length; i++) {\\n        const end = i + size\\n        let found = true\\n\\n        if (end > this.memory.length) return -1\\n\\n        for (let j = i; j < this.memory.length && j < end ; j++) {\\n            if (this.memory[j] !== null) {\\n                i = j\\n                found = false\\n                break\\n            }\\n        }\\n\\n        if (found) {\\n            startIndex = i\\n            break\\n        }\\n    }\\n\\n    // Return -1 if one cannot be found\\n    if (startIndex === -1) return -1\\n\\n    // Calculate end range\\n    const endIndex = startIndex + size\\n\\n    // Update memory range with value\\n    for (let i = startIndex; i < endIndex; i++) {\\n        this.memory[i] = mID\\n    }\\n\\n    return startIndex\\n};\\n\\n/** \\n * @param {number} mID\\n * @return {number}\\n */\\nAllocator.prototype.free = function(mID) {\\n    let count = 0\\n\\n    // Full scan memory for matching value\\n    for (let i = 0; i < this.memory.length; i++) {\\n        if (this.memory[i] === mID) {\\n            this.memory[i] = null\\n            count++\\n        }\\n    }\\n\\n    return count\\n};\\n\\n/** \\n * Your Allocator object will be instantiated and called as such:\\n * var obj = new Allocator(n)\\n * var param_1 = obj.allocate(size,mID)\\n * var param_2 = obj.free(mID)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n */\\nvar Allocator = function(n) {\\n    this.memory = Array(n).fill(null)\\n};\\n\\n/** \\n * @param {number} size \\n * @param {number} mID\\n * @return {number}\\n */\\nAllocator.prototype.allocate = function(size, mID) {\\n    let startIndex = -1\\n\\n    // Find first available block, if one exists\\n    for (let i = 0; i < this.memory.length; i++) {\\n        const end = i + size\\n        let found = true\\n\\n        if (end > this.memory.length) return -1\\n\\n        for (let j = i; j < this.memory.length && j < end ; j++) {\\n            if (this.memory[j] !== null) {\\n                i = j\\n                found = false\\n                break\\n            }\\n        }\\n\\n        if (found) {\\n            startIndex = i\\n            break\\n        }\\n    }\\n\\n    // Return -1 if one cannot be found\\n    if (startIndex === -1) return -1\\n\\n    // Calculate end range\\n    const endIndex = startIndex + size\\n\\n    // Update memory range with value\\n    for (let i = startIndex; i < endIndex; i++) {\\n        this.memory[i] = mID\\n    }\\n\\n    return startIndex\\n};\\n\\n/** \\n * @param {number} mID\\n * @return {number}\\n */\\nAllocator.prototype.free = function(mID) {\\n    let count = 0\\n\\n    // Full scan memory for matching value\\n    for (let i = 0; i < this.memory.length; i++) {\\n        if (this.memory[i] === mID) {\\n            this.memory[i] = null\\n            count++\\n        }\\n    }\\n\\n    return count\\n};\\n\\n/** \\n * Your Allocator object will be instantiated and called as such:\\n * var obj = new Allocator(n)\\n * var param_1 = obj.allocate(size,mID)\\n * var param_2 = obj.free(mID)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3785154,
                "title": "simple-c-solution",
                "content": "# Approach\\nstraight forward. the map will store a list of pair of start point  and end point of memory chunks used by mID. <mID,vector<pair<start,end>>>\\n\\n\\n# Code\\n```\\nclass Allocator {\\nprivate:\\n    vector<int> memo;\\n    int n;\\n    unordered_map<int,vector<pair<int,int>>> mp;\\npublic:\\n    Allocator(int n) {\\n       memo.resize(n);\\n       this->n = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int free = 0;\\n        int start;\\n        for(int i = 0; i<n; ++i){\\n            if(free == 0) start = i;\\n            if(memo[i] == 0) free++;\\n            else free = 0;\\n            if (free >= size) break;\\n        }\\n        if(free >= size){\\n            for(int i = start; i < start + size; ++i){\\n                memo[i] = mID;\\n            }\\n            mp[mID].push_back(make_pair(start,start + size));\\n            return start;\\n        }\\n        else return -1;    \\n    }\\n    \\n    int free(int mID) {\\n        int count = 0;\\n        for(auto pair : mp[mID]){\\n            int start = pair.first;\\n            int end = pair.second;\\n            for(int i = start;i < end; ++i){\\n                memo[i] = 0;\\n                count++;\\n            }\\n        }\\n        mp.erase(mID);\\n        return count;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Allocator {\\nprivate:\\n    vector<int> memo;\\n    int n;\\n    unordered_map<int,vector<pair<int,int>>> mp;\\npublic:\\n    Allocator(int n) {\\n       memo.resize(n);\\n       this->n = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int free = 0;\\n        int start;\\n        for(int i = 0; i<n; ++i){\\n            if(free == 0) start = i;\\n            if(memo[i] == 0) free++;\\n            else free = 0;\\n            if (free >= size) break;\\n        }\\n        if(free >= size){\\n            for(int i = start; i < start + size; ++i){\\n                memo[i] = mID;\\n            }\\n            mp[mID].push_back(make_pair(start,start + size));\\n            return start;\\n        }\\n        else return -1;    \\n    }\\n    \\n    int free(int mID) {\\n        int count = 0;\\n        for(auto pair : mp[mID]){\\n            int start = pair.first;\\n            int end = pair.second;\\n            for(int i = start;i < end; ++i){\\n                memo[i] = 0;\\n                count++;\\n            }\\n        }\\n        mp.erase(mID);\\n        return count;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738613,
                "title": "java-o-min-n-k-doubly-linked-list",
                "content": "# Complexity\\n- Time complexity:\\nO(min(N, K)) for both allocate() and free(), K beling number of allocate() calls\\n\\n- Space complexity:\\nO(min(N, K))\\n\\n# Code\\n```\\nclass Allocator {\\n    private class Block {\\n        Block pre, next;\\n        int start, end;\\n        boolean free;\\n        public Block(int s, int e, boolean f) {\\n            start = s;\\n            end = e;\\n            free = f;\\n        };\\n    }\\n    Block head, tail;\\n    Map<Integer, List<Block>> map = new HashMap<>();\\n\\n    // O(1)\\n    public Allocator(int n) {\\n        head = new Block(-1, -1, false);\\n        tail = new Block(n, n, false);\\n        insert(head, tail, new Block(0, n - 1, true));\\n    }\\n    \\n    // O(min(N, K)), K being number of allocate() calls\\n    public int allocate(int size, int mID) {\\n        Block cur = head.next;\\n        while (cur != tail && (!cur.free || cur.end - cur.start + 1 < size)) cur = cur.next;\\n        if (cur == tail) return -1;\\n        int newStart = cur.start + size, newEnd = cur.end;\\n        cur.free = false;\\n        cur.end = newStart - 1;\\n        if (newStart <= newEnd) insert(cur, cur.next, new Block(newStart, newEnd, true));\\n        map.putIfAbsent(mID, new ArrayList<>());\\n        map.get(mID).add(cur);\\n        return cur.start;\\n    }\\n    \\n    // O(min(N, K)), K being number of allocate() calls\\n    public int free(int mID) {\\n        if (!map.containsKey(mID)) return 0;\\n        int size = 0;\\n        for (Block b : map.get(mID)) {\\n            size += b.end - b.start + 1;\\n            b.free = true;\\n            if (b.next.free) merge(b, b.next);\\n            if (b.pre.free) merge(b.pre, b);\\n        }\\n        map.remove(mID);\\n        return size;\\n    }\\n\\n    // O(1)\\n    private void insert(Block pre, Block next, Block cur) {\\n        pre.next = cur;\\n        cur.next = next;\\n        next.pre = cur;\\n        cur.pre = pre;\\n    }\\n\\n    // O(1)\\n    private void merge(Block cur, Block next) {\\n        cur.next = next.next;\\n        next.next.pre = cur; // next.free is true thus guaranteed not to be tail\\n        cur.end = next.end;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    private class Block {\\n        Block pre, next;\\n        int start, end;\\n        boolean free;\\n        public Block(int s, int e, boolean f) {\\n            start = s;\\n            end = e;\\n            free = f;\\n        };\\n    }\\n    Block head, tail;\\n    Map<Integer, List<Block>> map = new HashMap<>();\\n\\n    // O(1)\\n    public Allocator(int n) {\\n        head = new Block(-1, -1, false);\\n        tail = new Block(n, n, false);\\n        insert(head, tail, new Block(0, n - 1, true));\\n    }\\n    \\n    // O(min(N, K)), K being number of allocate() calls\\n    public int allocate(int size, int mID) {\\n        Block cur = head.next;\\n        while (cur != tail && (!cur.free || cur.end - cur.start + 1 < size)) cur = cur.next;\\n        if (cur == tail) return -1;\\n        int newStart = cur.start + size, newEnd = cur.end;\\n        cur.free = false;\\n        cur.end = newStart - 1;\\n        if (newStart <= newEnd) insert(cur, cur.next, new Block(newStart, newEnd, true));\\n        map.putIfAbsent(mID, new ArrayList<>());\\n        map.get(mID).add(cur);\\n        return cur.start;\\n    }\\n    \\n    // O(min(N, K)), K being number of allocate() calls\\n    public int free(int mID) {\\n        if (!map.containsKey(mID)) return 0;\\n        int size = 0;\\n        for (Block b : map.get(mID)) {\\n            size += b.end - b.start + 1;\\n            b.free = true;\\n            if (b.next.free) merge(b, b.next);\\n            if (b.pre.free) merge(b.pre, b);\\n        }\\n        map.remove(mID);\\n        return size;\\n    }\\n\\n    // O(1)\\n    private void insert(Block pre, Block next, Block cur) {\\n        pre.next = cur;\\n        cur.next = next;\\n        next.pre = cur;\\n        cur.pre = pre;\\n    }\\n\\n    // O(1)\\n    private void merge(Block cur, Block next) {\\n        cur.next = next.next;\\n        next.next.pre = cur; // next.free is true thus guaranteed not to be tail\\n        cur.end = next.end;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699023,
                "title": "easy-to-understand-python-solution",
                "content": "# Intuition\\nMaintaing a list of memory and memoryMap to point all the idx which are occupied in memory\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int): # memory array of size n\\n        self.memory = [0]*n\\n        self.memoryMap = collections.defaultdict(set)\\n\\n    def allocate(self, size: int, mID: int) -> int: # find leftmost block of size size and allocate it with mID\\n        freeSpace = 0\\n        startIdx = -1\\n        \\n        for i in range(len(self.memory)):\\n            if self.memory[i] == 0:\\n                if startIdx == -1:\\n                    startIdx = i\\n                freeSpace+=1\\n                if freeSpace == size:\\n                    break\\n            else:\\n                startIdx = -1\\n                freeSpace = 0\\n        if freeSpace == size:\\n            for i in range(startIdx, startIdx+size):\\n                self.memory[i] = mID\\n            # if (mID in self.memoryMap and self.memoryMap[mID] > startIdx) or mID not in self.memoryMap:\\n                self.memoryMap[mID].add(i)\\n            # print(self.memory)\\n            return startIdx\\n        \\n        return -1\\n\\n    def free(self, mID: int) -> int: # free memory units with id mID. \\n        if not mID in self.memoryMap:\\n            return 0\\n\\n        count = len(self.memoryMap[mID])\\n        # print(\\'free--: \\', self.memory, count) \\n        for x in self.memoryMap[mID]:\\n            self.memory[x] = 0\\n        # print(\\'freed--: \\', self.memory, count) \\n        del self.memoryMap[mID]\\n        return count\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int): # memory array of size n\\n        self.memory = [0]*n\\n        self.memoryMap = collections.defaultdict(set)\\n\\n    def allocate(self, size: int, mID: int) -> int: # find leftmost block of size size and allocate it with mID\\n        freeSpace = 0\\n        startIdx = -1\\n        \\n        for i in range(len(self.memory)):\\n            if self.memory[i] == 0:\\n                if startIdx == -1:\\n                    startIdx = i\\n                freeSpace+=1\\n                if freeSpace == size:\\n                    break\\n            else:\\n                startIdx = -1\\n                freeSpace = 0\\n        if freeSpace == size:\\n            for i in range(startIdx, startIdx+size):\\n                self.memory[i] = mID\\n            # if (mID in self.memoryMap and self.memoryMap[mID] > startIdx) or mID not in self.memoryMap:\\n                self.memoryMap[mID].add(i)\\n            # print(self.memory)\\n            return startIdx\\n        \\n        return -1\\n\\n    def free(self, mID: int) -> int: # free memory units with id mID. \\n        if not mID in self.memoryMap:\\n            return 0\\n\\n        count = len(self.memoryMap[mID])\\n        # print(\\'free--: \\', self.memory, count) \\n        for x in self.memoryMap[mID]:\\n            self.memory[x] = 0\\n        # print(\\'freed--: \\', self.memory, count) \\n        del self.memoryMap[mID]\\n        return count\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691848,
                "title": "1-map-1-set-beats-92-34",
                "content": "# Intuition\\nset<array<int,2>> // set of {index,size}\\nmap<int,vector<array<int,2>>> //map[mID] = vector of {index,size}\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    set<array<int,2>> idxs;\\n    map<int,vector<array<int,2>>> mp;\\n    Allocator(int n) {\\n        idxs.insert({-1,1}); // -1 is allocated\\n        idxs.insert({n,1});  // n is allocated\\n        \\n    }\\n    \\n    int allocate(int size, int mID) {\\n            // cout<<size<<\" size mID \"<<mID<<endl;\\n        auto curr=idxs.begin();\\n        while(curr!=idxs.end()){\\n            auto next=curr;\\n            next++;\\n            if(next==idxs.end()) return -1;\\n            int end=(*next)[0];\\n            int first=(*curr)[0]+(*curr)[1];\\n            // cout<<first<<\" first end \"<<end<<endl;\\n            auto diff = end-first;\\n            if(diff>=size){\\n                int idx = first;\\n                int res=idx;\\n                idxs.insert({idx,size});\\n                mp[mID].push_back({idx,size});\\n                return res;\\n            }\\n            curr=next;\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int sz=0;\\n        for(auto v:mp[mID]){\\n            auto [a,b]=v;\\n            sz+=b;\\n            idxs.erase(v);\\n        }\\n        mp.erase(mID);\\n        return sz;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    set<array<int,2>> idxs;\\n    map<int,vector<array<int,2>>> mp;\\n    Allocator(int n) {\\n        idxs.insert({-1,1}); // -1 is allocated\\n        idxs.insert({n,1});  // n is allocated\\n        \\n    }\\n    \\n    int allocate(int size, int mID) {\\n            // cout<<size<<\" size mID \"<<mID<<endl;\\n        auto curr=idxs.begin();\\n        while(curr!=idxs.end()){\\n            auto next=curr;\\n            next++;\\n            if(next==idxs.end()) return -1;\\n            int end=(*next)[0];\\n            int first=(*curr)[0]+(*curr)[1];\\n            // cout<<first<<\" first end \"<<end<<endl;\\n            auto diff = end-first;\\n            if(diff>=size){\\n                int idx = first;\\n                int res=idx;\\n                idxs.insert({idx,size});\\n                mp[mID].push_back({idx,size});\\n                return res;\\n            }\\n            curr=next;\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int sz=0;\\n        for(auto v:mp[mID]){\\n            auto [a,b]=v;\\n            sz+=b;\\n            idxs.erase(v);\\n        }\\n        mp.erase(mID);\\n        return sz;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3602725,
                "title": "c-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\nvector<int> a;\\nint k;\\n    Allocator(int n) {\\n    a.resize(n,-1) ;\\n    k=n;  \\n    }\\n    \\n    int allocate(int size, int mID) {\\n    int val=-1;\\n    int freq = count(a.begin(), a.end(), val);\\n    if(size>freq){\\n        return -1;\\n    }\\n    int cnt=0;\\n    bool flag =false;\\n    for(int i=0;i<k;i++){\\n        if(a[i]==-1){\\n            cnt++;\\n            if(cnt==size){\\n                flag=true;\\n                cnt=i;\\n                break;\\n            }\\n        } else {\\n            cnt=0;\\n        }\\n    }\\n    if(flag){\\n    for(int i=cnt-size+1;i<=cnt;i++){\\n        if(a[i]==-1){\\n            a[i]=mID;\\n        }\\n    }\\n    return cnt-size+1;\\n    }\\n    \\n    return -1;\\n    }\\n    int free(int mID) {\\n        int kp=0;\\n    for(int i=0;i<a.size();i++){\\n        if(a[i]==mID){\\n         a[i]=-1;\\n         kp++;\\n        }\\n    }\\n    \\n    return kp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\nvector<int> a;\\nint k;\\n    Allocator(int n) {\\n    a.resize(n,-1) ;\\n    k=n;  \\n    }\\n    \\n    int allocate(int size, int mID) {\\n    int val=-1;\\n    int freq = count(a.begin(), a.end(), val);\\n    if(size>freq){\\n        return -1;\\n    }\\n    int cnt=0;\\n    bool flag =false;\\n    for(int i=0;i<k;i++){\\n        if(a[i]==-1){\\n            cnt++;\\n            if(cnt==size){\\n                flag=true;\\n                cnt=i;\\n                break;\\n            }\\n        } else {\\n            cnt=0;\\n        }\\n    }\\n    if(flag){\\n    for(int i=cnt-size+1;i<=cnt;i++){\\n        if(a[i]==-1){\\n            a[i]=mID;\\n        }\\n    }\\n    return cnt-size+1;\\n    }\\n    \\n    return -1;\\n    }\\n    int free(int mID) {\\n        int kp=0;\\n    for(int i=0;i<a.size();i++){\\n        if(a[i]==mID){\\n         a[i]=-1;\\n         kp++;\\n        }\\n    }\\n    \\n    return kp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597742,
                "title": "java-memory-allocator-using-treemap-and-mergeintervals-concepts",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\nThe idea is to use maps to track empty, non-empty blocks and another map for memoryID and its block starting index.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nAs mentioned in question, lets try to make a memory allocator. So main functionalities need to be supported are \\n1. constructor init\\n2. allocate\\n3. free\\n\\nThe idea is to use maps to track empty, non-empty blocks and another map for memoryID and its block starting index.\\n\\nuse treeMaps for the empty and non-emptyBlocks maps as further there will be a need of merging blocks in case of emptyBlocks after free-ing up the certain mId.\\n\\nSo this should initialize the memory allocator constructor.\\n\\n**Allocate(int size, int mID)**\\nThis allocate method need to \\n* verify if requested size block available starting from leftMost, if not return \"-1\"\\n* Add this mID and leftMostIndex to map<Integer, List<Integer>> as one mID has multiple blocks possibility\\n* With above figured out leftMostIndex, update this (leftMostIndex, size) as nonEmptyBlock\\n* store next possible index and block size to emptyBlock mapper and in case of next possible index has already occupied or it is out of range then no need to find the possible block size \\n    * if there is a possible empty block, identify next large index that is occupied if its available, till that point empty block available\\n    * else till end of the memory array\\n\\n**free(int mID)**\\nThis needs to free all blocks that are occupied with mID\\n* If there is no such mID exists return -1\\n* for given mID, all blocks needs to be emptied so now with map storing mID and their blocks starting index, remove all of them and add it to the emptyBlock map\\n* remove the mID from memoryID map\\n* now merge all emptyBlocks in the emptyBlockMap\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n* allocate - $$O(m)$$ where m: size of the emptyBlocks (worst case m = n) each block of size 1\\n* free - $$O(m + n)$$ where m: total mID occupied blocks and n: size of the emptyBlock -> merge the empty blocks\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n* O(n) where n: size of the memory units\\n\\n# Code\\n```\\nclass Allocator {\\n    Map<Integer, List<Integer>> memoryIDMap;\\n    Map<Integer, Integer> emptyBlockMap;\\n    Map<Integer, Integer> nonEmptyBlockMap;\\n    int n;\\n\\n    public Allocator(int n) {\\n        // store mID to list of blocks with their starting indexes\\n        this.memoryIDMap = new HashMap<>(); \\n        // stores index to size of occupied block\\n        this.nonEmptyBlockMap = new TreeMap<>();\\n        // stores index to size of empty block\\n        this.emptyBlockMap = new TreeMap<>();\\n        // initially its free block\\n        this.emptyBlockMap.put(0, n);\\n        // overall size of the memory\\n        this.n = n;\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        // first check if requested block fit into memory, if not return -1\\n        int curLeftMostIndex = -1;\\n        for (Integer leftMostIndex : emptyBlockMap.keySet()) {\\n            if (emptyBlockMap.get(leftMostIndex) >= size) {\\n                curLeftMostIndex = leftMostIndex;\\n                emptyBlockMap.remove(leftMostIndex);\\n                break;\\n            }\\n        }\\n        if (curLeftMostIndex == -1) {\\n            return -1;\\n        }\\n        \\n        // allocate free block with mID from identified left most index\\n        int tempIndex = curLeftMostIndex + size;\\n        // update mID with leftMostIndex in the map\\n        memoryIDMap.computeIfAbsent(mID, (k) -> new ArrayList<>());\\n        memoryIDMap.get(mID).add(curLeftMostIndex);\\n        // update index to size for given mID\\n        nonEmptyBlockMap.put(curLeftMostIndex, size);\\n        // store next possible index and block size to emptyBlock mapper \\n        // in case of next possible index has already occupied or it is out of range then no need to find the possible block size \\n        // if there is a possible empty block, identify next large index that is occupied if its available, till that point empty block available\\n        // else till end of the memory array\\n        if (!nonEmptyBlockMap.containsKey(tempIndex) && tempIndex < n) {\\n            boolean flag = true;\\n            for (Integer index : nonEmptyBlockMap.keySet()) {\\n                if (tempIndex < index) {\\n                    emptyBlockMap.put(tempIndex, index - tempIndex);\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                emptyBlockMap.put(tempIndex, n - tempIndex);\\n            }\\n        }\\n        return curLeftMostIndex;\\n    }\\n    \\n    public int free(int mID) {\\n        if (!memoryIDMap.containsKey(mID)) {\\n            return 0;\\n        }\\n        int totalUnits = 0;\\n        int minIndex = Integer.MAX_VALUE;\\n        List<Integer> locator = memoryIDMap.get(mID);\\n        for (Integer index : locator) {\\n            minIndex = Math.min(index, minIndex);\\n            int size = nonEmptyBlockMap.remove(index);\\n            emptyBlockMap.put(index, size);\\n            totalUnits += size;\\n        }\\n        memoryIDMap.remove(mID);\\n        mergeEmptyBlock();\\n        return totalUnits;\\n    }\\n\\n    private void mergeEmptyBlock() {    \\n        List<Pair<Integer, Integer>> pairs = new ArrayList<>();\\n        List<Pair<Integer, Integer>> merge = new ArrayList<>();\\n        for (Map.Entry<Integer, Integer> kv : emptyBlockMap.entrySet()) {\\n            pairs.add(new Pair(kv.getKey(), kv.getValue()));\\n        }\\n        merge.add(pairs.get(0));\\n        for (int i = 1; i < pairs.size(); i++) {\\n            int x = merge.get(merge.size() - 1).getKey();\\n            int y = merge.get(merge.size() - 1).getValue();\\n            int x1 = pairs.get(i).getKey();\\n            int y1 = pairs.get(i).getValue();\\n            if (x <= x1 && x1 <= y) {\\n                merge.add(new Pair(x, y + y1));\\n            } else if ((x + y) >= x1) {\\n                merge.add(new Pair(x, y + y1));\\n            } else {\\n                merge.add(pairs.get(i));\\n            }\\n        }\\n        emptyBlockMap.clear();\\n        for (Pair pair : merge) {\\n            emptyBlockMap.put((int)pair.getKey(), (int)pair.getValue());\\n        }\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    Map<Integer, List<Integer>> memoryIDMap;\\n    Map<Integer, Integer> emptyBlockMap;\\n    Map<Integer, Integer> nonEmptyBlockMap;\\n    int n;\\n\\n    public Allocator(int n) {\\n        // store mID to list of blocks with their starting indexes\\n        this.memoryIDMap = new HashMap<>(); \\n        // stores index to size of occupied block\\n        this.nonEmptyBlockMap = new TreeMap<>();\\n        // stores index to size of empty block\\n        this.emptyBlockMap = new TreeMap<>();\\n        // initially its free block\\n        this.emptyBlockMap.put(0, n);\\n        // overall size of the memory\\n        this.n = n;\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        // first check if requested block fit into memory, if not return -1\\n        int curLeftMostIndex = -1;\\n        for (Integer leftMostIndex : emptyBlockMap.keySet()) {\\n            if (emptyBlockMap.get(leftMostIndex) >= size) {\\n                curLeftMostIndex = leftMostIndex;\\n                emptyBlockMap.remove(leftMostIndex);\\n                break;\\n            }\\n        }\\n        if (curLeftMostIndex == -1) {\\n            return -1;\\n        }\\n        \\n        // allocate free block with mID from identified left most index\\n        int tempIndex = curLeftMostIndex + size;\\n        // update mID with leftMostIndex in the map\\n        memoryIDMap.computeIfAbsent(mID, (k) -> new ArrayList<>());\\n        memoryIDMap.get(mID).add(curLeftMostIndex);\\n        // update index to size for given mID\\n        nonEmptyBlockMap.put(curLeftMostIndex, size);\\n        // store next possible index and block size to emptyBlock mapper \\n        // in case of next possible index has already occupied or it is out of range then no need to find the possible block size \\n        // if there is a possible empty block, identify next large index that is occupied if its available, till that point empty block available\\n        // else till end of the memory array\\n        if (!nonEmptyBlockMap.containsKey(tempIndex) && tempIndex < n) {\\n            boolean flag = true;\\n            for (Integer index : nonEmptyBlockMap.keySet()) {\\n                if (tempIndex < index) {\\n                    emptyBlockMap.put(tempIndex, index - tempIndex);\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                emptyBlockMap.put(tempIndex, n - tempIndex);\\n            }\\n        }\\n        return curLeftMostIndex;\\n    }\\n    \\n    public int free(int mID) {\\n        if (!memoryIDMap.containsKey(mID)) {\\n            return 0;\\n        }\\n        int totalUnits = 0;\\n        int minIndex = Integer.MAX_VALUE;\\n        List<Integer> locator = memoryIDMap.get(mID);\\n        for (Integer index : locator) {\\n            minIndex = Math.min(index, minIndex);\\n            int size = nonEmptyBlockMap.remove(index);\\n            emptyBlockMap.put(index, size);\\n            totalUnits += size;\\n        }\\n        memoryIDMap.remove(mID);\\n        mergeEmptyBlock();\\n        return totalUnits;\\n    }\\n\\n    private void mergeEmptyBlock() {    \\n        List<Pair<Integer, Integer>> pairs = new ArrayList<>();\\n        List<Pair<Integer, Integer>> merge = new ArrayList<>();\\n        for (Map.Entry<Integer, Integer> kv : emptyBlockMap.entrySet()) {\\n            pairs.add(new Pair(kv.getKey(), kv.getValue()));\\n        }\\n        merge.add(pairs.get(0));\\n        for (int i = 1; i < pairs.size(); i++) {\\n            int x = merge.get(merge.size() - 1).getKey();\\n            int y = merge.get(merge.size() - 1).getValue();\\n            int x1 = pairs.get(i).getKey();\\n            int y1 = pairs.get(i).getValue();\\n            if (x <= x1 && x1 <= y) {\\n                merge.add(new Pair(x, y + y1));\\n            } else if ((x + y) >= x1) {\\n                merge.add(new Pair(x, y + y1));\\n            } else {\\n                merge.add(pairs.get(i));\\n            }\\n        }\\n        emptyBlockMap.clear();\\n        for (Pair pair : merge) {\\n            emptyBlockMap.put((int)pair.getKey(), (int)pair.getValue());\\n        }\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511253,
                "title": "simple-ordered-map-cpp",
                "content": "# Intuition\\nsimple ordered map solution\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    map<int,int>mp1;\\n    map<int,vector<pair<int,int>>>mp2;\\n    int n;\\n    Allocator(int n1) {\\n        mp1.clear();\\n        mp2.clear();\\n        n=n1;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int pos=0;\\n        if(mp1.size()==0&&size<=n)\\n        {\\n                mp1[pos]=size;\\n                mp2[mID].push_back({pos,size});\\n                return pos;\\n        }\\n        pos=-1;\\n        for(auto&p:mp1)\\n        {\\n            if(pos+size<p.first)\\n            {\\n                mp1[pos+1]=size;\\n                mp2[mID].push_back({pos+1,size});\\n                return pos+1;\\n            }\\n            else pos=p.first+p.second-1;\\n        }\\n        if(pos+size<n)\\n        {\\n            mp1[pos+1]=size;\\n            mp2[mID].push_back({pos+1,size});\\n            return pos+1;\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int ans=0;\\n        for(auto&p:mp2[mID])\\n        {\\n            mp1.erase(p.first);\\n            ans+=p.second;\\n        }\\n        mp2.erase(mID);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    map<int,int>mp1;\\n    map<int,vector<pair<int,int>>>mp2;\\n    int n;\\n    Allocator(int n1) {\\n        mp1.clear();\\n        mp2.clear();\\n        n=n1;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int pos=0;\\n        if(mp1.size()==0&&size<=n)\\n        {\\n                mp1[pos]=size;\\n                mp2[mID].push_back({pos,size});\\n                return pos;\\n        }\\n        pos=-1;\\n        for(auto&p:mp1)\\n        {\\n            if(pos+size<p.first)\\n            {\\n                mp1[pos+1]=size;\\n                mp2[mID].push_back({pos+1,size});\\n                return pos+1;\\n            }\\n            else pos=p.first+p.second-1;\\n        }\\n        if(pos+size<n)\\n        {\\n            mp1[pos+1]=size;\\n            mp2[mID].push_back({pos+1,size});\\n            return pos+1;\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int ans=0;\\n        for(auto&p:mp2[mID])\\n        {\\n            mp1.erase(p.first);\\n            ans+=p.second;\\n        }\\n        mp2.erase(mID);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490816,
                "title": "c-lazy-merging-freed-blocks",
                "content": "```\\nclass Allocator {\\n    map<int,int> avail;// [i] = j: block [i, j) } \\n    unordered_map<int, vector<pair<int,int>>> used;  // mid => map of i to j for [i, j) blocks, with same mid\\npublic:\\n    Allocator(int n) {\\n        avail[0] = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        for(auto cur = avail.begin(); cur != avail.end(); ) {\\n            if(auto [i, j] = *cur; j -i >= size) {\\n                avail.erase(cur);\\n                used[mID].emplace_back(i, i + size);\\n                if(j > i + size) \\n                    avail[i+size] = j;\\n                return i;\\n            }\\n            else if(auto next = cur; ++next != avail.end() && next->first == j) {\\n                cur->second = next->second;\\n                avail.erase(next);\\n            }\\n            else\\n                ++cur;\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int freed = 0;\\n        for(auto const& [i, j] : used[mID]) {\\n            avail[i] = j;\\n            freed += j - i;\\n        }\\n        used.erase(mID);\\n        return freed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\n    map<int,int> avail;// [i] = j: block [i, j) } \\n    unordered_map<int, vector<pair<int,int>>> used;  // mid => map of i to j for [i, j) blocks, with same mid\\npublic:\\n    Allocator(int n) {\\n        avail[0] = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        for(auto cur = avail.begin(); cur != avail.end(); ) {\\n            if(auto [i, j] = *cur; j -i >= size) {\\n                avail.erase(cur);\\n                used[mID].emplace_back(i, i + size);\\n                if(j > i + size) \\n                    avail[i+size] = j;\\n                return i;\\n            }\\n            else if(auto next = cur; ++next != avail.end() && next->first == j) {\\n                cur->second = next->second;\\n                avail.erase(next);\\n            }\\n            else\\n                ++cur;\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int freed = 0;\\n        for(auto const& [i, j] : used[mID]) {\\n            avail[i] = j;\\n            freed += j - i;\\n        }\\n        used.erase(mID);\\n        return freed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474836,
                "title": "python-solution-using-two-hashmaps",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo store the blocks of memory that are allocated, we can use a hashmap. This hashmap will store the start of the block as the key for easy finding and the end of the block as the value. With this hashmap we know exactly the blocks that are allocated. To store the mapping between the user and the blocks, we also use another hash map. This hashmap maps the users to an array of start indices. Whenever we want to free memory we use this hashmap to find all the allocated memory that are assigned to the specific user and free them.\\n\\n\\n# Code\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.size = n\\n        # Store all the starts of the blocks for a user\\n        self.userIds = defaultdict(list)\\n\\n        # Store all the starts of the blocks and the sizes \\n        self.starts = {}\\n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        # Traverse from 0 to n - 1 (size of the memory) if the location is \\n        # in the self.starts, move the ptr to the end of block location,\\n        # otherwise move to the next location\\n        idx = 0\\n\\n        # current size of free block\\n        cur_size = 0\\n        while idx < self.size:\\n            if idx in self.starts:\\n                idx += self.starts[idx]\\n                # if the index is already allocated, reset the current block size\\n                cur_size = 0\\n            else:\\n                cur_size += 1\\n                idx += 1\\n                if cur_size == size:\\n                    break\\n                \\n        if cur_size == size:\\n            self.userIds[mID].append(idx - size)\\n            self.starts[idx - size] = size\\n            return idx - size\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        freed = 0\\n        if mID in self.userIds:\\n            for start in self.userIds[mID]:\\n                freed += self.starts[start]\\n                del self.starts[start]\\n            del self.userIds[mID]\\n        return freed\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.size = n\\n        # Store all the starts of the blocks for a user\\n        self.userIds = defaultdict(list)\\n\\n        # Store all the starts of the blocks and the sizes \\n        self.starts = {}\\n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        # Traverse from 0 to n - 1 (size of the memory) if the location is \\n        # in the self.starts, move the ptr to the end of block location,\\n        # otherwise move to the next location\\n        idx = 0\\n\\n        # current size of free block\\n        cur_size = 0\\n        while idx < self.size:\\n            if idx in self.starts:\\n                idx += self.starts[idx]\\n                # if the index is already allocated, reset the current block size\\n                cur_size = 0\\n            else:\\n                cur_size += 1\\n                idx += 1\\n                if cur_size == size:\\n                    break\\n                \\n        if cur_size == size:\\n            self.userIds[mID].append(idx - size)\\n            self.starts[idx - size] = size\\n            return idx - size\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        freed = 0\\n        if mID in self.userIds:\\n            for start in self.userIds[mID]:\\n                freed += self.starts[start]\\n                del self.starts[start]\\n            del self.userIds[mID]\\n        return freed\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457357,
                "title": "clean-c-using-remove-erase-idiom",
                "content": "# Approach\\nI created a helper Struct containing all the information regarding a single allocated block, this includes the half open interval of memory blocks it contains and its id. \\n\\nFor the allocation function we simply have to scan through all the adjacent blocks and see if there is enough space in between. If there is then we insert the block in between those blocks. To help with this I have included the non-assignable blocks (from INT_MIN to 0 and from n to INT_MAX) to our array. \\n\\nFor the free function we can use the remove-erase idiom, in this case we are using the std::remove_if function with a lambda function that also counts the units freed by the operation.\\n\\n\\n# Code\\n```Cpp\\nstruct Block{\\n    Block(int s, int e, int id): m_start(s), m_end(e), m_id(id){}; \\n    int m_start{}; \\n    int m_end{}; \\n    int m_id{}; \\n}; \\n\\nclass Allocator {\\n    std::vector<Block> m_blocks{}; \\n    int m_n{};\\npublic:\\n    Allocator(int n): m_n(n) {\\n        m_blocks.emplace_back(INT_MIN,0,0);\\n        m_blocks.emplace_back(n,INT_MAX,0); \\n    }\\n    \\n    int allocate(int size, int mID) {\\n        for(int i = 0; i < m_blocks.size()-1; ++i){\\n            if(m_blocks[i+1].m_start -m_blocks[i].m_end >= size){\\n                auto start = m_blocks[i].m_end; \\n                m_blocks.insert(m_blocks.begin()+i+1,Block(start,start+size,mID)); \\n                return start; \\n            }\\n        }\\n        return -1; \\n        \\n    }\\n    \\n    int free(int mID) {\\n        int freed_units = 0; \\n        m_blocks.erase(std::remove_if(m_blocks.begin(),m_blocks.end(),[mID,&freed_units](const Block& b){\\n            if(mID == b.m_id){\\n                freed_units+=b.m_end-b.m_start; \\n                return true; \\n            }else{\\n                return false; \\n            }\\n        }),m_blocks.end()); \\n        return freed_units; \\n\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```Cpp\\nstruct Block{\\n    Block(int s, int e, int id): m_start(s), m_end(e), m_id(id){}; \\n    int m_start{}; \\n    int m_end{}; \\n    int m_id{}; \\n}; \\n\\nclass Allocator {\\n    std::vector<Block> m_blocks{}; \\n    int m_n{};\\npublic:\\n    Allocator(int n): m_n(n) {\\n        m_blocks.emplace_back(INT_MIN,0,0);\\n        m_blocks.emplace_back(n,INT_MAX,0); \\n    }\\n    \\n    int allocate(int size, int mID) {\\n        for(int i = 0; i < m_blocks.size()-1; ++i){\\n            if(m_blocks[i+1].m_start -m_blocks[i].m_end >= size){\\n                auto start = m_blocks[i].m_end; \\n                m_blocks.insert(m_blocks.begin()+i+1,Block(start,start+size,mID)); \\n                return start; \\n            }\\n        }\\n        return -1; \\n        \\n    }\\n    \\n    int free(int mID) {\\n        int freed_units = 0; \\n        m_blocks.erase(std::remove_if(m_blocks.begin(),m_blocks.end(),[mID,&freed_units](const Block& b){\\n            if(mID == b.m_id){\\n                freed_units+=b.m_end-b.m_start; \\n                return true; \\n            }else{\\n                return false; \\n            }\\n        }),m_blocks.end()); \\n        return freed_units; \\n\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450178,
                "title": "sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\nvector<int>v;\\n    Allocator(int n) {\\n     v.resize(n,-1);   \\n    }\\n    \\n    int allocate(int size, int mID) {\\n      int i=0;\\n      int j=0;\\n      int c=0;\\n      while(j<v.size())\\n      {\\n          if(v[j]==-1)\\n          c++;\\n          if(j-i+1<size)\\n          {\\n              j++;\\n          }\\n          else if(j-i+1==size)\\n          {\\n            if(c==size)\\n            {\\n                for(int it=i;it<=j;it++)\\n                v[it]=mID;\\n                return i;\\n            } \\n            if(v[i]==-1)\\n            c--;\\n            i++;\\n            j++;  \\n          }\\n      }\\n      return -1;  \\n    }\\n    \\n    int free(int mID) {\\n        int c=0;\\n       for(int i=0;i<v.size();i++)\\n       {\\n           if(v[i]==mID)\\n           {\\n               c++;\\n           v[i]=-1;\\n           }\\n       }\\n       return c; \\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\nvector<int>v;\\n    Allocator(int n) {\\n     v.resize(n,-1);   \\n    }\\n    \\n    int allocate(int size, int mID) {\\n      int i=0;\\n      int j=0;\\n      int c=0;\\n      while(j<v.size())\\n      {\\n          if(v[j]==-1)\\n          c++;\\n          if(j-i+1<size)\\n          {\\n              j++;\\n          }\\n          else if(j-i+1==size)\\n          {\\n            if(c==size)\\n            {\\n                for(int it=i;it<=j;it++)\\n                v[it]=mID;\\n                return i;\\n            } \\n            if(v[i]==-1)\\n            c--;\\n            i++;\\n            j++;  \\n          }\\n      }\\n      return -1;  \\n    }\\n    \\n    int free(int mID) {\\n        int c=0;\\n       for(int i=0;i<v.size();i++)\\n       {\\n           if(v[i]==mID)\\n           {\\n               c++;\\n           v[i]=-1;\\n           }\\n       }\\n       return c; \\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435806,
                "title": "simple-array-manipulation-java-o-n",
                "content": "# Intuition\\nConstraints allow for $$O(n^2)$$ solution, but can we do better? Of course we will be needing an array of size n, but can we use it to tell how many consecutive elements are \"free\" to be allocated, and the use this data to allocate the blocks. Similarly, while freeing, we have to recompute this data again. Fortunately, both can be done in $$O(n)$$ time.\\n\\n# Approach\\nIdea is to store the number of items that can be allocated (including the current position) in our `mem` array. For example, if we initialize our array with `size` as 5, the array would be computed as `[5, 4, 3, 2, 1]`. Each index tells you number of consecutive blocks you can allocate right away, for example, `mem[0]` whose value is `5` tells that starting from index `0` you can allocate 5 consecutive blocks starting from index `0`.\\n\\n**But how do we maintain the IDs?**\\nEasy, since IDs will always be positive, we can store the negative of the id in the `mem`. So if we allocate the first 3 blocks with id as `1`, our `mem` array will look like `[-1, -1, -1, 2, 1]`.\\n\\n**Freeing**\\nIn order to free, we first check the total number of elements in the `mem` array whose value is `-1 * mID` (since we are storing the ids as negative), count them and also make them `0` in the same process.\\nSo after the above allocation, if we free the blocks with id as `1`, we check the `mem` array for `id = -1 * 1 = -1`, count them and make them 0. After this our `mem` array would look like `[0, 0, 0, 2, 1]` and `count = 3` (which we are going to return).\\nNow, we have to recompute the array so that it will be able to tell how many blocks we can allocate for each index. We can simply do that by checking each index from the end, if the value at an index is greater than or equal to zero, and if the value at its next index is a non-negative number (since we are storing ids as negative, we cannot modify the portion with negative values), we assign `mem[i] = mem[i + 1] + 1` (if `i` is the last index then `mem[i] = 1`).\\n\\nBoth `allocate` and `free` requires multiple loops, but none of them requires nested loops, making them O(n).\\n\\n# Complexity\\nIf the maximum size of memory is `n`, then:\\n- Time complexity:\\n- `Constructor` - $$O(n)$$ for initial array creation and computation.\\n- `allocate` - First loop to find the index (which at worst will take `n` iterations), and second loop to allocate the blocks, so $$O(n + size)$$. Since `size` can at most be n, it becomes $$O(n + n)$$ = $$O(2n)$$ = $$O(n)$$.\\n- `free` - First loop to free, and second to re-compute, so $$O(n + n)$$ = $$O(2n)$$ = $$O(n)$$.\\n\\n- Space complexity:\\n$$O(n)$$ since we are working with the `mem` array whose size will be `n`.\\n\\n# Code\\n```\\n// https://leetcode.com/problems/design-memory-allocator\\nclass Allocator {\\n    int[] mem;\\n\\n    public Allocator(int n) {\\n        mem = new int[n];\\n\\n        // Store a value in each element\\n        // The value would signify that \"Including this element, the next <value> elements are free\"\\n        for (int i = n - 1, j = 1; i >= 0; i--, j++) {\\n            mem[i] = j;\\n        }\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        // Find the first index where mem[i] >= size\\n        int allocIndex = -1;\\n        for (int i = 0; i < mem.length; i++) {\\n            if (mem[i] >= size) {\\n                allocIndex = i;\\n                break;\\n            }\\n        }\\n\\n        if (allocIndex >= 0) {\\n            for (int i = allocIndex, j = 0; j < size; j++) {\\n                // Store the id as negative\\n                mem[i + j] = -mID;\\n            }\\n        }\\n\\n        return allocIndex;\\n    }\\n    \\n    public int free(int mID) {\\n        int count = 0;\\n        for (int i = 0; i < mem.length; i++) {\\n            if (mem[i] == -mID) {\\n                mem[i] = 0;\\n                count += 1;\\n            }\\n        }\\n\\n        // Re-process the array so that it can tell how many blocks are free\\n        for (int i = mem.length - 1; i >= 0; i--) {\\n            if (i == mem.length - 1) {\\n                if (mem[i] == 0)\\n                    mem[i] = 1;\\n            } else {\\n                if (mem[i] >= 0) {\\n                    if (mem[i + 1] > 0) {\\n                        mem[i] = mem[i + 1] + 1;\\n                    } else {\\n                        mem[i] = 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// https://leetcode.com/problems/design-memory-allocator\\nclass Allocator {\\n    int[] mem;\\n\\n    public Allocator(int n) {\\n        mem = new int[n];\\n\\n        // Store a value in each element\\n        // The value would signify that \"Including this element, the next <value> elements are free\"\\n        for (int i = n - 1, j = 1; i >= 0; i--, j++) {\\n            mem[i] = j;\\n        }\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        // Find the first index where mem[i] >= size\\n        int allocIndex = -1;\\n        for (int i = 0; i < mem.length; i++) {\\n            if (mem[i] >= size) {\\n                allocIndex = i;\\n                break;\\n            }\\n        }\\n\\n        if (allocIndex >= 0) {\\n            for (int i = allocIndex, j = 0; j < size; j++) {\\n                // Store the id as negative\\n                mem[i + j] = -mID;\\n            }\\n        }\\n\\n        return allocIndex;\\n    }\\n    \\n    public int free(int mID) {\\n        int count = 0;\\n        for (int i = 0; i < mem.length; i++) {\\n            if (mem[i] == -mID) {\\n                mem[i] = 0;\\n                count += 1;\\n            }\\n        }\\n\\n        // Re-process the array so that it can tell how many blocks are free\\n        for (int i = mem.length - 1; i >= 0; i--) {\\n            if (i == mem.length - 1) {\\n                if (mem[i] == 0)\\n                    mem[i] = 1;\\n            } else {\\n                if (mem[i] >= 0) {\\n                    if (mem[i + 1] > 0) {\\n                        mem[i] = mem[i + 1] + 1;\\n                    } else {\\n                        mem[i] = 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434826,
                "title": "accepted-swift",
                "content": "```\\nclass Allocator {\\n\\n    private let n: Int\\n    private var allocs: [(Int, Int)]\\n    private var ids = [Int: [Int]]()\\n\\n    init(_ n: Int) {\\n        self.n = n\\n        allocs = [(0, 0), (n, n)]\\n    }\\n    \\n    func allocate(_ size: Int, _ mID: Int) -> Int {\\n        let i = allocs.indices.first { $0 > 0 && allocs[$0].0 - allocs[$0 - 1].1 >= size }\\n        guard let i = i else { return -1 }\\n\\n        for (k, v) in ids {\\n            ids[k] = v.map { ($0 < i) ? $0 : ($0 + 1) }\\n        }\\n\\n        allocs.insert((allocs[i - 1].1, allocs[i - 1].1 + size), at: i)\\n        ids[mID, default: []].append(i)\\n\\n        return allocs[i - 1].1\\n    }\\n    \\n    func free(_ mID: Int) -> Int {\\n        guard let inds = ids[mID], !inds.isEmpty else { return 0 }\\n        ids[mID] = nil\\n        var res = 0\\n\\n        for i in inds.sorted(by: >) {\\n            res += allocs[i].1 - allocs[i].0\\n            allocs.remove(at: i)\\n\\n            for (k, v) in ids {\\n                ids[k] = v.map { ($0 > i) ? ($0 - 1) : $0 }\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Allocator {\\n\\n    private let n: Int\\n    private var allocs: [(Int, Int)]\\n    private var ids = [Int: [Int]]()\\n\\n    init(_ n: Int) {\\n        self.n = n\\n        allocs = [(0, 0), (n, n)]\\n    }\\n    \\n    func allocate(_ size: Int, _ mID: Int) -> Int {\\n        let i = allocs.indices.first { $0 > 0 && allocs[$0].0 - allocs[$0 - 1].1 >= size }\\n        guard let i = i else { return -1 }\\n\\n        for (k, v) in ids {\\n            ids[k] = v.map { ($0 < i) ? $0 : ($0 + 1) }\\n        }\\n\\n        allocs.insert((allocs[i - 1].1, allocs[i - 1].1 + size), at: i)\\n        ids[mID, default: []].append(i)\\n\\n        return allocs[i - 1].1\\n    }\\n    \\n    func free(_ mID: Int) -> Int {\\n        guard let inds = ids[mID], !inds.isEmpty else { return 0 }\\n        ids[mID] = nil\\n        var res = 0\\n\\n        for i in inds.sorted(by: >) {\\n            res += allocs[i].1 - allocs[i].0\\n            allocs.remove(at: i)\\n\\n            for (k, v) in ids {\\n                ids[k] = v.map { ($0 > i) ? ($0 - 1) : $0 }\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407580,
                "title": "c-set",
                "content": "\\n# Code\\n```\\nclass Allocator {\\n\\nprivate:\\n        map<int, vector<vector<int>>> mp;\\n        set<vector<int>> st;\\n        int sz;\\npublic:\\n    Allocator(int n) {\\n        sz = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        if(st.size() == 0){\\n            if(size > sz) return -1;\\n            st.insert({0, size-1});\\n            mp[mID].push_back({0, size-1});\\n            return 0;\\n        }\\n        for(auto it = st.begin(); it != st.end(); ++it){\\n            if(it == st.begin() && (*it)[0] > size - 1){\\n                st.insert({0, size-1});\\n                mp[mID].push_back({0, size-1});\\n                return 0;\\n            }\\n            else{\\n                auto it2 = next(it, 1);\\n                if(it2 != st.end()){\\n                    if((*it2)[0] - (*it)[1] > size){\\n                        st.insert({(*it)[1]+1, (*it)[1]+size});\\n                        mp[mID].push_back({(*it)[1]+1, (*it)[1]+size});\\n                        return (*it)[1]+1;\\n                    }\\n                }\\n                else{\\n                    if(sz - (*it)[1] > size){\\n                        st.insert({(*it)[1]+1, (*it)[1]+size});\\n                        mp[mID].push_back({(*it)[1]+1, (*it)[1]+size});\\n                        return (*it)[1]+1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int r = 0;\\n        for(int i = 0; i < mp[mID].size(); i++){\\n            r += mp[mID][i][1] - mp[mID][i][0] + 1;\\n            st.erase(mp[mID][i]);\\n        }\\n        mp.erase(mID);\\n        return r;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\n\\nprivate:\\n        map<int, vector<vector<int>>> mp;\\n        set<vector<int>> st;\\n        int sz;\\npublic:\\n    Allocator(int n) {\\n        sz = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        if(st.size() == 0){\\n            if(size > sz) return -1;\\n            st.insert({0, size-1});\\n            mp[mID].push_back({0, size-1});\\n            return 0;\\n        }\\n        for(auto it = st.begin(); it != st.end(); ++it){\\n            if(it == st.begin() && (*it)[0] > size - 1){\\n                st.insert({0, size-1});\\n                mp[mID].push_back({0, size-1});\\n                return 0;\\n            }\\n            else{\\n                auto it2 = next(it, 1);\\n                if(it2 != st.end()){\\n                    if((*it2)[0] - (*it)[1] > size){\\n                        st.insert({(*it)[1]+1, (*it)[1]+size});\\n                        mp[mID].push_back({(*it)[1]+1, (*it)[1]+size});\\n                        return (*it)[1]+1;\\n                    }\\n                }\\n                else{\\n                    if(sz - (*it)[1] > size){\\n                        st.insert({(*it)[1]+1, (*it)[1]+size});\\n                        mp[mID].push_back({(*it)[1]+1, (*it)[1]+size});\\n                        return (*it)[1]+1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int r = 0;\\n        for(int i = 0; i < mp[mID].size(); i++){\\n            r += mp[mID][i][1] - mp[mID][i][0] + 1;\\n            st.erase(mp[mID][i]);\\n        }\\n        mp.erase(mID);\\n        return r;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402599,
                "title": "simple-java-100-faster-with-a-linked-list-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsed a linked list of memory block \\n# Complexity\\n- Time complexity: allocate O(N), free O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Block{\\n    Block next;\\n    int start;\\n    int size;\\n    int mID;\\n    public Block(int st, int sz, int id, Block nxt){\\n        next = nxt;\\n        start = st;\\n        size = sz;\\n        mID = id;\\n    }\\n}\\nclass Allocator {\\n    Block memory;\\n    int n;\\n    public Allocator(int n) {\\n        //setting up the boundary\\n        memory = new Block( 0,0,0,new Block(n,0,0,null));\\n        this.n = n;\\n    }    \\n    public int allocate(int size, int mID) {\\n        Block iter = memory;\\n        while(iter.start<n){\\n            int nextAvailableStart = iter.start+iter.size;\\n            int space = iter.next.start-nextAvailableStart;\\n            if(space >=size){\\n                iter.next = new Block(nextAvailableStart,size,mID,iter.next);\\n                return nextAvailableStart;\\n            }\\n            iter = iter.next;\\n        }\\n        return -1;\\n    }    \\n    public int free(int mID) {\\n        Block iter = memory;\\n        int unitsFreed = 0;\\n        while(iter.start<n){\\n            if(iter.next.mID==mID){\\n                unitsFreed+=iter.next.size;\\n                iter.next = iter.next.next;                \\n            }\\n            else iter = iter.next;\\n        }\\n        return unitsFreed;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Block{\\n    Block next;\\n    int start;\\n    int size;\\n    int mID;\\n    public Block(int st, int sz, int id, Block nxt){\\n        next = nxt;\\n        start = st;\\n        size = sz;\\n        mID = id;\\n    }\\n}\\nclass Allocator {\\n    Block memory;\\n    int n;\\n    public Allocator(int n) {\\n        //setting up the boundary\\n        memory = new Block( 0,0,0,new Block(n,0,0,null));\\n        this.n = n;\\n    }    \\n    public int allocate(int size, int mID) {\\n        Block iter = memory;\\n        while(iter.start<n){\\n            int nextAvailableStart = iter.start+iter.size;\\n            int space = iter.next.start-nextAvailableStart;\\n            if(space >=size){\\n                iter.next = new Block(nextAvailableStart,size,mID,iter.next);\\n                return nextAvailableStart;\\n            }\\n            iter = iter.next;\\n        }\\n        return -1;\\n    }    \\n    public int free(int mID) {\\n        Block iter = memory;\\n        int unitsFreed = 0;\\n        while(iter.start<n){\\n            if(iter.next.mID==mID){\\n                unitsFreed+=iter.next.size;\\n                iter.next = iter.next.next;                \\n            }\\n            else iter = iter.next;\\n        }\\n        return unitsFreed;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388396,
                "title": "btreemap-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nallocate: $$O(n)$$\\nfree: $$O(n\\\\log n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nuse std::collections::{HashMap, BTreeMap};\\nstruct Allocator {\\n    empties: BTreeMap<i32, i32>,\\n    ids: HashMap<i32, BTreeMap<i32, i32>>\\n}\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Allocator {\\n\\n    fn new(n: i32) -> Self {\\n        let mut empties =  BTreeMap::new();\\n        empties.insert(0, n - 1);\\n        return Allocator {\\n            empties,\\n            ids: HashMap::new()\\n        }\\n    }\\n\\n    fn allocate(&mut self, size: i32, m_id: i32) -> i32 {\\n        let mut result_x = -1;\\n        let mut result_y = -1;\\n        for (k, v) in self.empties.iter() {\\n            if size <= *v - *k + 1 {\\n                result_x = *k;\\n                result_y = *v;\\n                break;\\n            }\\n        }\\n        if result_x != -1 {\\n            self.empties.remove(&result_x);\\n            if result_y - result_x + 1 > size  {\\n                self.empties.insert(result_x + size, result_y);\\n            }\\n            self.ids.entry(m_id).or_insert(BTreeMap::new());\\n            Self::merge(self.ids.get_mut(&m_id).unwrap(), result_x, size + result_x - 1);\\n        }\\n        result_x\\n    }\\n    \\n    fn free(&mut self, m_id: i32) -> i32 {\\n        let mut result = 0;\\n        let empties = &mut self.empties;\\n        self.ids.entry(m_id).and_modify(|o| {\\n            o.retain(|result_x, result_y| {\\n                result += *result_y + 1 - *result_x;\\n                Self::merge(empties, *result_x, *result_y);\\n                false\\n            });\\n        });\\n        result\\n    }\\n\\n    fn merge(sorted_list: &mut BTreeMap<i32, i32>, result_x: i32, result_y: i32) {\\n        let mut back_x = -1;\\n        let mut final_x = sorted_list.range(..result_x).next_back().map_or(result_x, |(k, v)| { \\n            if result_x == 1 + *v {\\n                back_x = *k;\\n                return *k;\\n            }\\n            result_x\\n        });\\n        let mut forward_x = -1;\\n        let mut final_y = sorted_list.range((result_y + 1)..).next().map_or(result_y, |(k, v)| { \\n            if result_y == *k - 1 {\\n                forward_x = *k;\\n                return *v;\\n            }\\n            result_y\\n        });\\n        if back_x != -1 {\\n            sorted_list.remove(&back_x);\\n        }\\n        if forward_x != -1 {\\n            sorted_list.remove(&forward_x);\\n        }\\n        sorted_list.insert(final_x, final_y);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nuse std::collections::{HashMap, BTreeMap};\\nstruct Allocator {\\n    empties: BTreeMap<i32, i32>,\\n    ids: HashMap<i32, BTreeMap<i32, i32>>\\n}\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Allocator {\\n\\n    fn new(n: i32) -> Self {\\n        let mut empties =  BTreeMap::new();\\n        empties.insert(0, n - 1);\\n        return Allocator {\\n            empties,\\n            ids: HashMap::new()\\n        }\\n    }\\n\\n    fn allocate(&mut self, size: i32, m_id: i32) -> i32 {\\n        let mut result_x = -1;\\n        let mut result_y = -1;\\n        for (k, v) in self.empties.iter() {\\n            if size <= *v - *k + 1 {\\n                result_x = *k;\\n                result_y = *v;\\n                break;\\n            }\\n        }\\n        if result_x != -1 {\\n            self.empties.remove(&result_x);\\n            if result_y - result_x + 1 > size  {\\n                self.empties.insert(result_x + size, result_y);\\n            }\\n            self.ids.entry(m_id).or_insert(BTreeMap::new());\\n            Self::merge(self.ids.get_mut(&m_id).unwrap(), result_x, size + result_x - 1);\\n        }\\n        result_x\\n    }\\n    \\n    fn free(&mut self, m_id: i32) -> i32 {\\n        let mut result = 0;\\n        let empties = &mut self.empties;\\n        self.ids.entry(m_id).and_modify(|o| {\\n            o.retain(|result_x, result_y| {\\n                result += *result_y + 1 - *result_x;\\n                Self::merge(empties, *result_x, *result_y);\\n                false\\n            });\\n        });\\n        result\\n    }\\n\\n    fn merge(sorted_list: &mut BTreeMap<i32, i32>, result_x: i32, result_y: i32) {\\n        let mut back_x = -1;\\n        let mut final_x = sorted_list.range(..result_x).next_back().map_or(result_x, |(k, v)| { \\n            if result_x == 1 + *v {\\n                back_x = *k;\\n                return *k;\\n            }\\n            result_x\\n        });\\n        let mut forward_x = -1;\\n        let mut final_y = sorted_list.range((result_y + 1)..).next().map_or(result_y, |(k, v)| { \\n            if result_y == *k - 1 {\\n                forward_x = *k;\\n                return *v;\\n            }\\n            result_y\\n        });\\n        if back_x != -1 {\\n            sorted_list.remove(&back_x);\\n        }\\n        if forward_x != -1 {\\n            sorted_list.remove(&forward_x);\\n        }\\n        sorted_list.insert(final_x, final_y);\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3388075,
                "title": "bst",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nallocate: $$O(n + \\\\log n) = O(n)$$\\nfree: $$O(n \\\\log n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Allocator:\\n    def __init__(self, n: int):\\n        self.empties = SortedList(iterable=[(0, n - 1)], key=lambda x: x[0])\\n        self.ids = {}\\n\\n    def merge(self, sorted_list, result_x, result_y):\\n        sorted_list.add((result_x, result_y))    \\n        index_of_interval = sorted_list.index((result_x, result_y))\\n        after_linked = index_of_interval < len(sorted_list) - 1 and result_y == sorted_list[index_of_interval + 1][0] - 1\\n        before_linked = index_of_interval > 0 and result_x == sorted_list[index_of_interval - 1][1] + 1   \\n        final_x, final_y = float(\"inf\"), float(\"-inf\")\\n        if after_linked: # Order is important\\n            final_y = sorted_list.pop(index_of_interval + 1)[1]\\n        if before_linked:\\n            final_x = sorted_list.pop(index_of_interval - 1)[0]\\n        if after_linked or before_linked:\\n            sorted_list.remove((result_x, result_y))\\n            sorted_list.add((min(final_x, result_x), max(final_y, result_y)))\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        result_x, result_y = -1, -1\\n        for x, y in self.empties:\\n            if y - x + 1 >= size:\\n                result_x, result_y = x, y\\n                break\\n        if result_x > -1:\\n            if y - x + 1 > size:\\n                self.empties.add((result_x + size, result_y))\\n            self.empties.remove((result_x, result_y))\\n            if mID not in self.ids:\\n                self.ids[mID] = SortedList(key=lambda x: x[0])\\n            self.merge(self.ids[mID], result_x, result_x - 1 + size)\\n        return result_x\\n    \\n    def free(self, mID: int) -> int:\\n        result = 0\\n        if mID not in self.ids:\\n            return 0\\n        for result_x, result_y in self.ids[mID]:\\n            result += result_y + 1 - result_x\\n            self.merge(self.empties, result_x, result_y)\\n        del self.ids[mID]\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Binary Search Tree"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Allocator:\\n    def __init__(self, n: int):\\n        self.empties = SortedList(iterable=[(0, n - 1)], key=lambda x: x[0])\\n        self.ids = {}\\n\\n    def merge(self, sorted_list, result_x, result_y):\\n        sorted_list.add((result_x, result_y))    \\n        index_of_interval = sorted_list.index((result_x, result_y))\\n        after_linked = index_of_interval < len(sorted_list) - 1 and result_y == sorted_list[index_of_interval + 1][0] - 1\\n        before_linked = index_of_interval > 0 and result_x == sorted_list[index_of_interval - 1][1] + 1   \\n        final_x, final_y = float(\"inf\"), float(\"-inf\")\\n        if after_linked: # Order is important\\n            final_y = sorted_list.pop(index_of_interval + 1)[1]\\n        if before_linked:\\n            final_x = sorted_list.pop(index_of_interval - 1)[0]\\n        if after_linked or before_linked:\\n            sorted_list.remove((result_x, result_y))\\n            sorted_list.add((min(final_x, result_x), max(final_y, result_y)))\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        result_x, result_y = -1, -1\\n        for x, y in self.empties:\\n            if y - x + 1 >= size:\\n                result_x, result_y = x, y\\n                break\\n        if result_x > -1:\\n            if y - x + 1 > size:\\n                self.empties.add((result_x + size, result_y))\\n            self.empties.remove((result_x, result_y))\\n            if mID not in self.ids:\\n                self.ids[mID] = SortedList(key=lambda x: x[0])\\n            self.merge(self.ids[mID], result_x, result_x - 1 + size)\\n        return result_x\\n    \\n    def free(self, mID: int) -> int:\\n        result = 0\\n        if mID not in self.ids:\\n            return 0\\n        for result_x, result_y in self.ids[mID]:\\n            result += result_y + 1 - result_x\\n            self.merge(self.empties, result_x, result_y)\\n        del self.ids[mID]\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364273,
                "title": "java-simulation-hashmap-mid-assigned-ranges",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator {\\n    private int[] memory; // count empty blocks starting from each index\\n    private Map<Integer, Set<int[]>> memoryToRange;\\n    private int N;\\n\\n    public Allocator(int n) {\\n        N = n;\\n        memory = new int[n];\\n        memoryToRange = new HashMap<>();\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        for (int i = 0; i <= N - size; i++) {\\n            boolean unassigned = true;\\n            for (int j = i; j < i + size; j++) {\\n                if (memory[j] != 0) {\\n                    i = j;\\n                    unassigned = false;\\n                    break;\\n                }\\n            }\\n            if (unassigned) {\\n                for (int j = i; j < i + size; j++) {\\n                    memory[j] = mID;\\n                }\\n                memoryToRange.computeIfAbsent(mID, k -> new HashSet<>()).add(new int[]{i, i + size});\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n    \\n    public int free(int mID) {\\n        if (!memoryToRange.containsKey(mID)) {\\n            return 0;\\n        }\\n\\n        int count = 0;\\n        for (int[] range : memoryToRange.get(mID)) {\\n            Arrays.fill(memory, range[0], range[1], 0);\\n            count += range[1] - range[0];\\n        }\\n        memoryToRange.remove(mID);\\n\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    private int[] memory; // count empty blocks starting from each index\\n    private Map<Integer, Set<int[]>> memoryToRange;\\n    private int N;\\n\\n    public Allocator(int n) {\\n        N = n;\\n        memory = new int[n];\\n        memoryToRange = new HashMap<>();\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        for (int i = 0; i <= N - size; i++) {\\n            boolean unassigned = true;\\n            for (int j = i; j < i + size; j++) {\\n                if (memory[j] != 0) {\\n                    i = j;\\n                    unassigned = false;\\n                    break;\\n                }\\n            }\\n            if (unassigned) {\\n                for (int j = i; j < i + size; j++) {\\n                    memory[j] = mID;\\n                }\\n                memoryToRange.computeIfAbsent(mID, k -> new HashSet<>()).add(new int[]{i, i + size});\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n    \\n    public int free(int mID) {\\n        if (!memoryToRange.containsKey(mID)) {\\n            return 0;\\n        }\\n\\n        int count = 0;\\n        for (int[] range : memoryToRange.get(mID)) {\\n            Arrays.fill(memory, range[0], range[1], 0);\\n            count += range[1] - range[0];\\n        }\\n        memoryToRange.remove(mID);\\n\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364126,
                "title": "c-simple-and-concise-answer-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    Allocator(int n): size_(n) {\\n        // Boundary guards.\\n        set_[-1] = 0;\\n        set_[n] = size_;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        // Iterate all the segments. (except the very end one)\\n        for (auto iter = set_.begin(); iter->first != size_; ++iter) {\\n            auto next = iter;\\n            ++next;\\n            // Find the gap between 2 segments, if it is larger than size\\n            // then that means we can fit in.\\n            int diff = next->first - iter->second;\\n            if (diff >= size) {\\n                int start = iter->second;\\n                int end = iter->second + size;\\n                // Update both the segment-id dictionary and insert to\\n                // segments.\\n                segments_[mID].push_back(start);\\n                set_[start] = end;\\n                return start;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int res = 0;\\n        if (segments_.find(mID) != segments_.end()) {\\n            auto &starts = segments_[mID];\\n            for (int start : starts) {\\n                res += set_[start] - start;\\n                set_.erase(start);\\n            }\\n            starts.clear();\\n        }\\n        return res;\\n    }\\nprivate:\\n    // stores all the segments, order by start of segment.\\n    std::map<int, int> set_;  \\n    // a segmentid - segment start dictionary.\\n    unordered_map<int, vector<int>> segments_;\\n    // memory total size.\\n    int size_;\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    Allocator(int n): size_(n) {\\n        // Boundary guards.\\n        set_[-1] = 0;\\n        set_[n] = size_;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        // Iterate all the segments. (except the very end one)\\n        for (auto iter = set_.begin(); iter->first != size_; ++iter) {\\n            auto next = iter;\\n            ++next;\\n            // Find the gap between 2 segments, if it is larger than size\\n            // then that means we can fit in.\\n            int diff = next->first - iter->second;\\n            if (diff >= size) {\\n                int start = iter->second;\\n                int end = iter->second + size;\\n                // Update both the segment-id dictionary and insert to\\n                // segments.\\n                segments_[mID].push_back(start);\\n                set_[start] = end;\\n                return start;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int res = 0;\\n        if (segments_.find(mID) != segments_.end()) {\\n            auto &starts = segments_[mID];\\n            for (int start : starts) {\\n                res += set_[start] - start;\\n                set_.erase(start);\\n            }\\n            starts.clear();\\n        }\\n        return res;\\n    }\\nprivate:\\n    // stores all the segments, order by start of segment.\\n    std::map<int, int> set_;  \\n    // a segmentid - segment start dictionary.\\n    unordered_map<int, vector<int>> segments_;\\n    // memory total size.\\n    int size_;\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346279,
                "title": "c-two-maps-and-one-unordered-map-faster-than-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have two maps for free and taken. The have an unordered_map from mID to the taken_ iterator for freeing.\\n\\n# Approach\\nWe merge blocks whenever necessary. Note that lower_bound is used to get the previous free location. Note thaat if lower_bound(start) exceeds the maximum then free_::end will return and we still want to take the prior to that. The only time we don\\'t want to take the prior is if it returns free_.begin(). We only want to do the merge if the prior\\'s end is our start.\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    Allocator(int n) {\\n        // use n instead of n-1 for:\\n        // : end = size\\n        // : end = start of next\\n        free_[0] = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        for (auto& p : free_)\\n        {\\n            const int start = p.first;\\n            const int end = p.second;\\n            if (end - start == size)\\n            {\\n                taken_[start] = end;\\n                free_.erase(start);\\n                id_to_taken[mID].emplace_back(taken_.find(start));\\n                return start;\\n            }\\n            else if (end - start > size)\\n            {\\n                taken_[start] = start+size;\\n                free_.erase(start);\\n                free_[start+size] = end;\\n                id_to_taken[mID].emplace_back(taken_.find(start));\\n                return start;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int blocks_freed = 0;\\n        const auto& to_free_list = id_to_taken[mID];\\n        for (const auto it : to_free_list)\\n        {\\n            int start = it->first;\\n            int end = it->second;\\n            // count freed block before merge \\n            blocks_freed += end - start;\\n            if (free_.count(end) > 0)\\n            {\\n                // keep track of old end which is the block we want to erase from free\\n                const int erase_start = end;\\n                end = free_[end];\\n                free_.erase(erase_start);\\n            }\\n            // Lower bound gets us the iterator to the block after the one we want to potentially merge.\\n            // We don\\'t use upper_bound here because we include start as the inclusive boundary of the one we want to take prev to.\\n            // We don\\'t don\\'t check against not found. If not found end() will be returned which if we take prev we will get\\n            // valid iterator unless begin() == end() in which case we will still be covered by the != begin check.\\n            auto prior_it = free_.lower_bound(start);\\n            // if start is the first block, we have no priors\\n            if (prior_it != free_.begin())\\n            {\\n                // get prior to merge\\n                prior_it = prev(prior_it);\\n                // if the free block is adjacent to the block to be freed then we merge\\n                if (prior_it->second == start)\\n                {\\n                    start = prior_it->first;\\n                    free_.erase(start);\\n                }\\n            }\\n            free_[start] = end;\\n            taken_.erase(it);\\n        }\\n        id_to_taken.erase(mID);\\n\\n        return blocks_freed;\\n    }\\nprivate:\\n    using Blocks = map<int, int>;\\n    Blocks free_{};\\n    Blocks taken_{};\\n    unordered_map<int, list<Blocks::iterator>> id_to_taken;\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    Allocator(int n) {\\n        // use n instead of n-1 for:\\n        // : end = size\\n        // : end = start of next\\n        free_[0] = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        for (auto& p : free_)\\n        {\\n            const int start = p.first;\\n            const int end = p.second;\\n            if (end - start == size)\\n            {\\n                taken_[start] = end;\\n                free_.erase(start);\\n                id_to_taken[mID].emplace_back(taken_.find(start));\\n                return start;\\n            }\\n            else if (end - start > size)\\n            {\\n                taken_[start] = start+size;\\n                free_.erase(start);\\n                free_[start+size] = end;\\n                id_to_taken[mID].emplace_back(taken_.find(start));\\n                return start;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int blocks_freed = 0;\\n        const auto& to_free_list = id_to_taken[mID];\\n        for (const auto it : to_free_list)\\n        {\\n            int start = it->first;\\n            int end = it->second;\\n            // count freed block before merge \\n            blocks_freed += end - start;\\n            if (free_.count(end) > 0)\\n            {\\n                // keep track of old end which is the block we want to erase from free\\n                const int erase_start = end;\\n                end = free_[end];\\n                free_.erase(erase_start);\\n            }\\n            // Lower bound gets us the iterator to the block after the one we want to potentially merge.\\n            // We don\\'t use upper_bound here because we include start as the inclusive boundary of the one we want to take prev to.\\n            // We don\\'t don\\'t check against not found. If not found end() will be returned which if we take prev we will get\\n            // valid iterator unless begin() == end() in which case we will still be covered by the != begin check.\\n            auto prior_it = free_.lower_bound(start);\\n            // if start is the first block, we have no priors\\n            if (prior_it != free_.begin())\\n            {\\n                // get prior to merge\\n                prior_it = prev(prior_it);\\n                // if the free block is adjacent to the block to be freed then we merge\\n                if (prior_it->second == start)\\n                {\\n                    start = prior_it->first;\\n                    free_.erase(start);\\n                }\\n            }\\n            free_[start] = end;\\n            taken_.erase(it);\\n        }\\n        id_to_taken.erase(mID);\\n\\n        return blocks_freed;\\n    }\\nprivate:\\n    using Blocks = map<int, int>;\\n    Blocks free_{};\\n    Blocks taken_{};\\n    unordered_map<int, list<Blocks::iterator>> id_to_taken;\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326427,
                "title": "java-using-iteration-over-humble-int",
                "content": "# Intuition\\nThis is a relatively easy coding challenge and you need to translate real world approach into a program\\n\\n# Approach\\n- To allocate space, find first available slot, see if consequetive slots are available to accomodate mID and fill array. If consequetive slots are unavailable, reset search from where you left off as you already know that there is insufficient space from the index based on your lookforward window\\n- To free space simply iterate through array and reset mID to 0 \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Allocator {\\n    int[] mem;\\n    public Allocator(int n) {\\n        mem = new int[n];\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        System.out.println(\"Allocate size: \"+size+\", mID: \"+mID);\\n        int j=-1; //tracks free index\\n        for(int i=0;i<mem.length && j==-1;i++) {\\n            //find first empty location \\n            if(mem[i]==0) {\\n                j=i;\\n                for(int k=1;k<size;k++) {\\n                    if(j+k >= mem.length) {\\n                        return -1;\\n                    } \\n                    if(mem[j+k]!=0) {\\n                        i=j+k; //restart search from next index\\n                        j=-1;// we did not find index with sufficient memory yet\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"Index for allocation: \"+j);\\n        if(j!=-1) {\\n            Arrays.fill(mem,j,j+size,mID);\\n        }\\n        return j;\\n    }\\n    \\n    public int free(int mID) {\\n        int cnt=0;\\n        for(int i=0;i<mem.length;i++) {\\n            if(mem[i] == mID) {\\n                mem[i] =0;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    int[] mem;\\n    public Allocator(int n) {\\n        mem = new int[n];\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        System.out.println(\"Allocate size: \"+size+\", mID: \"+mID);\\n        int j=-1; //tracks free index\\n        for(int i=0;i<mem.length && j==-1;i++) {\\n            //find first empty location \\n            if(mem[i]==0) {\\n                j=i;\\n                for(int k=1;k<size;k++) {\\n                    if(j+k >= mem.length) {\\n                        return -1;\\n                    } \\n                    if(mem[j+k]!=0) {\\n                        i=j+k; //restart search from next index\\n                        j=-1;// we did not find index with sufficient memory yet\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"Index for allocation: \"+j);\\n        if(j!=-1) {\\n            Arrays.fill(mem,j,j+size,mID);\\n        }\\n        return j;\\n    }\\n    \\n    public int free(int mID) {\\n        int cnt=0;\\n        for(int i=0;i<mem.length;i++) {\\n            if(mem[i] == mID) {\\n                mem[i] =0;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322370,
                "title": "java-with-an-array",
                "content": "# Code\\n```\\nclass Allocator {\\n    private int n;\\n    private int[] arr;\\n\\n    public Allocator(int n) {\\n        this.n = n;\\n        this.arr = new int[n];\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int leftMost = getOpenBlock(size);\\n        int openBlock = leftMost;\\n\\n        if (openBlock != -1) {\\n            while (size > 0) {\\n                arr[openBlock++] = mID;\\n                size--;\\n            }\\n        }\\n\\n        return leftMost;\\n    }\\n    \\n    public int free(int mID) {\\n        int count = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == mID) {\\n                arr[i] = 0;\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private int getOpenBlock(int size) {\\n        int i = 0;\\n\\n        while (i < n) {\\n            int j = i;\\n            int temp = size;\\n\\n            while (j < n && arr[j] == 0 && temp > 0) {\\n                j++;\\n                temp--;\\n            }\\n\\n            if (temp == 0)\\n                return i;\\n            \\n            i = i == j ? i + 1 : j;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    private int n;\\n    private int[] arr;\\n\\n    public Allocator(int n) {\\n        this.n = n;\\n        this.arr = new int[n];\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int leftMost = getOpenBlock(size);\\n        int openBlock = leftMost;\\n\\n        if (openBlock != -1) {\\n            while (size > 0) {\\n                arr[openBlock++] = mID;\\n                size--;\\n            }\\n        }\\n\\n        return leftMost;\\n    }\\n    \\n    public int free(int mID) {\\n        int count = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == mID) {\\n                arr[i] = 0;\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private int getOpenBlock(int size) {\\n        int i = 0;\\n\\n        while (i < n) {\\n            int j = i;\\n            int temp = size;\\n\\n            while (j < n && arr[j] == 0 && temp > 0) {\\n                j++;\\n                temp--;\\n            }\\n\\n            if (temp == 0)\\n                return i;\\n            \\n            i = i == j ? i + 1 : j;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302674,
                "title": "java-brute-force-allocation-optimized-free-solution",
                "content": "# Approach\\n<!-- Use array to find the first available range for allocation. An additional map will keep track of assignment of mID to assigned index range in the array which will help optimize the freeing operation. -->\\n\\n\\n# Code\\n```\\nclass Allocator {\\n    int[] memory;\\n    Map<Integer, List<Range>> mIDs;\\n\\n    public Allocator(int n) {\\n        memory = new int[n];\\n        Arrays.fill(memory, -1);\\n        mIDs = new HashMap<>();\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int count = 0;\\n        int startIndex = 0;\\n        for(int i=0; i<memory.length; i++) {\\n            if (memory[i] == -1) {\\n                count++;\\n            } else {\\n                count = 0;\\n                startIndex = i+1;\\n            }\\n\\n            if (count == size) {\\n                break;\\n            }\\n        }\\n\\n        if (count < size) return -1;\\n\\n        Arrays.fill(memory, startIndex, startIndex+count, mID);\\n        if (!mIDs.containsKey(mID)) {\\n            mIDs.put(mID, new ArrayList<>());\\n        }\\n\\n        List<Range> ranges = mIDs.get(mID);\\n        ranges.add(new Range(startIndex, startIndex+count));\\n\\n        return startIndex;\\n    }\\n    \\n    public int free(int mID) {\\n        int count = 0;\\n        List<Range> ranges = mIDs.get(mID);\\n        if (ranges == null) return 0;\\n\\n        Iterator<Range> rangesIt = ranges.listIterator();\\n        while (rangesIt.hasNext()) {\\n            Range range = rangesIt.next();\\n            int start = range.start;\\n            int end = range.end;\\n\\n            for (int i=start; i<end; i++) {\\n                memory[i] = -1;\\n                count++;\\n            }\\n\\n            rangesIt.remove();\\n        }\\n\\n        return count;\\n    }\\n\\n    class Range {\\n        int start, end;\\n        Range(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    int[] memory;\\n    Map<Integer, List<Range>> mIDs;\\n\\n    public Allocator(int n) {\\n        memory = new int[n];\\n        Arrays.fill(memory, -1);\\n        mIDs = new HashMap<>();\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int count = 0;\\n        int startIndex = 0;\\n        for(int i=0; i<memory.length; i++) {\\n            if (memory[i] == -1) {\\n                count++;\\n            } else {\\n                count = 0;\\n                startIndex = i+1;\\n            }\\n\\n            if (count == size) {\\n                break;\\n            }\\n        }\\n\\n        if (count < size) return -1;\\n\\n        Arrays.fill(memory, startIndex, startIndex+count, mID);\\n        if (!mIDs.containsKey(mID)) {\\n            mIDs.put(mID, new ArrayList<>());\\n        }\\n\\n        List<Range> ranges = mIDs.get(mID);\\n        ranges.add(new Range(startIndex, startIndex+count));\\n\\n        return startIndex;\\n    }\\n    \\n    public int free(int mID) {\\n        int count = 0;\\n        List<Range> ranges = mIDs.get(mID);\\n        if (ranges == null) return 0;\\n\\n        Iterator<Range> rangesIt = ranges.listIterator();\\n        while (rangesIt.hasNext()) {\\n            Range range = rangesIt.next();\\n            int start = range.start;\\n            int end = range.end;\\n\\n            for (int i=start; i<end; i++) {\\n                memory[i] = -1;\\n                count++;\\n            }\\n\\n            rangesIt.remove();\\n        }\\n\\n        return count;\\n    }\\n\\n    class Range {\\n        int start, end;\\n        Range(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298342,
                "title": "java-brute-force-avoid-tle-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator {\\n    int[] memArr;\\n    Map<Integer, List<Integer>> midIndexMap;\\n    public Allocator(int n) {\\n        this.memArr = new int[n];\\n        this.midIndexMap = new HashMap<>();\\n        Arrays.fill(memArr, -1);\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        for (int i = 0; i < memArr.length; i++) {\\n            int fills = canFillNumber(i, size);\\n            if (fills == size) {\\n                if (!midIndexMap.containsKey(mID)) {\\n                    midIndexMap.put(mID, new LinkedList<>());\\n                }\\n                for (int off = 0 ; off < size; off++) {\\n                    memArr[i + off] = mID;\\n                    midIndexMap.get(mID).add(i + off);\\n                }\\n                return i;\\n            } \\n            i += fills;\\n        }\\n        return -1;\\n    }\\n    public int canFillNumber(int index, int size) {\\n        int offset = 0;\\n        while(offset < size ) {\\n            if (index + offset >= memArr.length || memArr[index + offset] != -1) return offset;\\n            offset++;\\n        }\\n        return offset;\\n    }\\n    \\n    public int free(int mID) {\\n        if (!midIndexMap.containsKey(mID)) return 0;\\n        int freeCount = midIndexMap.get(mID).size();\\n        for (int index: midIndexMap.get(mID)) {\\n            memArr[index] = -1;\\n        }\\n        midIndexMap.put(mID, new LinkedList<>());\\n        return freeCount;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    int[] memArr;\\n    Map<Integer, List<Integer>> midIndexMap;\\n    public Allocator(int n) {\\n        this.memArr = new int[n];\\n        this.midIndexMap = new HashMap<>();\\n        Arrays.fill(memArr, -1);\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        for (int i = 0; i < memArr.length; i++) {\\n            int fills = canFillNumber(i, size);\\n            if (fills == size) {\\n                if (!midIndexMap.containsKey(mID)) {\\n                    midIndexMap.put(mID, new LinkedList<>());\\n                }\\n                for (int off = 0 ; off < size; off++) {\\n                    memArr[i + off] = mID;\\n                    midIndexMap.get(mID).add(i + off);\\n                }\\n                return i;\\n            } \\n            i += fills;\\n        }\\n        return -1;\\n    }\\n    public int canFillNumber(int index, int size) {\\n        int offset = 0;\\n        while(offset < size ) {\\n            if (index + offset >= memArr.length || memArr[index + offset] != -1) return offset;\\n            offset++;\\n        }\\n        return offset;\\n    }\\n    \\n    public int free(int mID) {\\n        if (!midIndexMap.containsKey(mID)) return 0;\\n        int freeCount = midIndexMap.get(mID).size();\\n        for (int index: midIndexMap.get(mID)) {\\n            memArr[index] = -1;\\n        }\\n        midIndexMap.put(mID, new LinkedList<>());\\n        return freeCount;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252483,
                "title": "python-4-ways",
                "content": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.array = [0] * n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        from itertools import groupby\\n        i = 0\\n        for g, it in groupby(self.array):\\n            n = len(list(it))\\n            if g == 0 and n >= size:\\n                self.array[i: i + size] = [mID] * size\\n                return i\\n            i += n\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        ctr = 0\\n        for i, n in enumerate(self.array):\\n            if n == mID:\\n                self.array[i] = 0\\n                ctr += 1\\n        return ctr\\n\\n\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.data = chr(0) * n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        i = self.data.find(chr(0) * size)\\n        if i != -1:\\n            self.data = self.data[:i] + chr(mID) * size + self.data[i + size:]\\n        return i\\n\\n    def free(self, mID: int) -> int:\\n        freed = self.data.count(chr(mID))\\n        self.data = self.data.replace(chr(mID), chr(0))\\n        return freed\\n\\n\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        from collections import defaultdict\\n        from sortedcontainers import SortedList\\n        self._mem_map = defaultdict(SortedList)\\n        self._mem_map[0].update(((-1, -1), (0, n), (n + 1, n + 1)))\\n\\n    @property\\n    def free_blocks(self):\\n        return self._mem_map[0]\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        for (start, stop) in self.free_blocks:\\n            if stop - start < size:\\n                continue\\n            self.free_blocks.remove((start, stop))\\n            self._mem_map[mID].add((start, start + size))\\n            if start + size != stop:\\n                self.free_blocks.add((start + size, stop))\\n            return start\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n\\n        def merge(*blocks: tuple[int, int]) -> list[tuple[int, int]]:\\n            merged = []\\n            for i, b in enumerate(blocks):\\n                if merged and merged[-1][1] == b[0]:\\n                    merged[-1] = (merged[-1][0], b[1])\\n                else:\\n                    merged.append(b)\\n            return merged\\n\\n        size = 0\\n        for block in self._mem_map.pop(mID, set()):\\n            idx = self.free_blocks.bisect(block)\\n            after = self.free_blocks.pop(idx)\\n            before = self.free_blocks.pop(idx - 1)\\n            self.free_blocks.update(merge(before, block, after))\\n            size += block[1] - block[0]\\n        return size\\n\\n    def __repr__(self):\\n        return \"\\\\n\".join(f\"{k:4d}: {list(v)}\" for k, v in self._mem_map.items())\\n\\n\\nclass Allocator:\\n\\n    from dataclasses import dataclass\\n\\n    @dataclass\\n    class Node:\\n        start: int\\n        end: int\\n        _next: Optional[\\'Node\\'] = None\\n        _prev: Optional[\\'Node\\'] = None\\n\\n        @property\\n        def next(self) -> Optional[\\'Node\\']:\\n            return self._next\\n\\n        @next.setter\\n        def next(self, node: \\'Node\\') -> None:\\n            self._next, node._prev = node, self\\n\\n        @property\\n        def prev(self) -> Optional[\\'Node\\']:\\n            return self._prev\\n\\n        def delete(self):\\n            if self.prev:\\n                self.prev._next = self.next\\n            if self.next:\\n                self.next._prev = self.prev\\n\\n    def __init__(self, n: int):\\n        from collections import defaultdict\\n        self.head = self.Node(-1, -1, self.Node(n, n))\\n        self.sections = defaultdict(list)\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        node = self.head\\n        while node.next:\\n            if node.next.start - node.end - 1 >= size:\\n                new_node = self.Node(node.end + 1, node.end + size)\\n                new_node.next, node.next = node.next, new_node\\n                self.sections[mID].append(new_node)\\n                return new_node.start\\n            node = node.next\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        freed = 0\\n        while self.sections[mID]:\\n            node = self.sections[mID].pop()\\n            freed += node.end - node.start + 1\\n            node.delete()\\n        return freed\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.array = [0] * n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        from itertools import groupby\\n        i = 0\\n        for g, it in groupby(self.array):\\n            n = len(list(it))\\n            if g == 0 and n >= size:\\n                self.array[i: i + size] = [mID] * size\\n                return i\\n            i += n\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        ctr = 0\\n        for i, n in enumerate(self.array):\\n            if n == mID:\\n                self.array[i] = 0\\n                ctr += 1\\n        return ctr\\n\\n\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.data = chr(0) * n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        i = self.data.find(chr(0) * size)\\n        if i != -1:\\n            self.data = self.data[:i] + chr(mID) * size + self.data[i + size:]\\n        return i\\n\\n    def free(self, mID: int) -> int:\\n        freed = self.data.count(chr(mID))\\n        self.data = self.data.replace(chr(mID), chr(0))\\n        return freed\\n\\n\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        from collections import defaultdict\\n        from sortedcontainers import SortedList\\n        self._mem_map = defaultdict(SortedList)\\n        self._mem_map[0].update(((-1, -1), (0, n), (n + 1, n + 1)))\\n\\n    @property\\n    def free_blocks(self):\\n        return self._mem_map[0]\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        for (start, stop) in self.free_blocks:\\n            if stop - start < size:\\n                continue\\n            self.free_blocks.remove((start, stop))\\n            self._mem_map[mID].add((start, start + size))\\n            if start + size != stop:\\n                self.free_blocks.add((start + size, stop))\\n            return start\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n\\n        def merge(*blocks: tuple[int, int]) -> list[tuple[int, int]]:\\n            merged = []\\n            for i, b in enumerate(blocks):\\n                if merged and merged[-1][1] == b[0]:\\n                    merged[-1] = (merged[-1][0], b[1])\\n                else:\\n                    merged.append(b)\\n            return merged\\n\\n        size = 0\\n        for block in self._mem_map.pop(mID, set()):\\n            idx = self.free_blocks.bisect(block)\\n            after = self.free_blocks.pop(idx)\\n            before = self.free_blocks.pop(idx - 1)\\n            self.free_blocks.update(merge(before, block, after))\\n            size += block[1] - block[0]\\n        return size\\n\\n    def __repr__(self):\\n        return \"\\\\n\".join(f\"{k:4d}: {list(v)}\" for k, v in self._mem_map.items())\\n\\n\\nclass Allocator:\\n\\n    from dataclasses import dataclass\\n\\n    @dataclass\\n    class Node:\\n        start: int\\n        end: int\\n        _next: Optional[\\'Node\\'] = None\\n        _prev: Optional[\\'Node\\'] = None\\n\\n        @property\\n        def next(self) -> Optional[\\'Node\\']:\\n            return self._next\\n\\n        @next.setter\\n        def next(self, node: \\'Node\\') -> None:\\n            self._next, node._prev = node, self\\n\\n        @property\\n        def prev(self) -> Optional[\\'Node\\']:\\n            return self._prev\\n\\n        def delete(self):\\n            if self.prev:\\n                self.prev._next = self.next\\n            if self.next:\\n                self.next._prev = self.prev\\n\\n    def __init__(self, n: int):\\n        from collections import defaultdict\\n        self.head = self.Node(-1, -1, self.Node(n, n))\\n        self.sections = defaultdict(list)\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        node = self.head\\n        while node.next:\\n            if node.next.start - node.end - 1 >= size:\\n                new_node = self.Node(node.end + 1, node.end + size)\\n                new_node.next, node.next = node.next, new_node\\n                self.sections[mID].append(new_node)\\n                return new_node.start\\n            node = node.next\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        freed = 0\\n        while self.sections[mID]:\\n            node = self.sections[mID].pop()\\n            freed += node.end - node.start + 1\\n            node.delete()\\n        return freed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230436,
                "title": "c-o-n-log-n-ordered-map-hash-map-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use a map or linked list to store all the available memory chuncks. Here I choose to use ordered map to make the code cleaner. For each mID, we can store the claimed memory by the user with a hash map from mID to vector of pairs.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOrdered map + hash map\\n\\nFor allocate, we can iterate through the data structure to find the first chunck with a size bigger than request and claim the first `size` bytes of it.\\n\\nFor free operation, we can find all the previous/next free memory of each freed chunck and try merge them. For each interval returned, there is at most two merge operations happen.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n\\\\log n)$ since each allocated interval can be merged by at most twice when they are freed.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    Allocator(int n) {\\n        mp.insert({0, n});\\n        chunck = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        // request memory greater than the original chunk\\n        if (size > chunck) return -1;\\n        // find the first memory block that\\'s larger\\n        // than the requested memory\\n        for (auto [start, length]: mp) {\\n            if (length < size)\\n                continue;\\n            // Allocate the first `size` byte of the\\n            // memory and put residual memory back to \\n            // the map if any\\n            ownership[mID].push_back({start, size});\\n            mp.erase(start);\\n            if (length > size)\\n                mp.insert({start + size, length-size});\\n            return start;\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int ans = 0;\\n        for (auto [start, size]: ownership[mID]) {\\n            // it\\'s always fine to return the memory\\n            ans += size;\\n\\n            // case 1: empty map\\n            if (mp.empty()) {\\n                mp.insert({start, size});\\n                continue;\\n            }\\n\\n            // case 2: nonempty map\\n            // beg, len is the new start and length after\\n            // we merge the freed interval with the adjacent\\n            // free chuncks.\\n            int beg = start, len = size;\\n            auto it = mp.upper_bound(start);\\n\\n            // --it is the previous free memory of [start, size]\\n            // If it is begin, then there\\'s no previous chunck.\\n            if (it != mp.begin()) {\\n                auto prev_it = it;\\n                --prev_it;\\n                // check if they overlap\\n                if (prev_it->first + prev_it->second == start) {\\n                    beg = prev_it->first;\\n                    len += prev_it->second;\\n                    mp.erase(prev_it);\\n                }\\n            }\\n\\n            // it is the next free memory chunk of [start, size]\\n            // If it\\'s end, then there\\'s no next chunck\\n            if (it != mp.end()) {\\n                // check if they overlap\\n                if (it->first == start + size) {\\n                    len += it->second;\\n                    mp.erase(it);\\n                }\\n            }\\n            // put back the merged free interval\\n            mp.insert({beg, len});\\n        }\\n        // remove all the allocated interval by mID from the unordered_map\\n        ownership[mID].clear();\\n        return ans;\\n    }\\n\\n    int chunck;\\n    map<int, int> mp; // (left boundary, size)\\n    unordered_map<int, vector<pair<int,int>>> ownership; // mID -> vector of (left boundary, size)\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Ordered Map"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    Allocator(int n) {\\n        mp.insert({0, n});\\n        chunck = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        // request memory greater than the original chunk\\n        if (size > chunck) return -1;\\n        // find the first memory block that\\'s larger\\n        // than the requested memory\\n        for (auto [start, length]: mp) {\\n            if (length < size)\\n                continue;\\n            // Allocate the first `size` byte of the\\n            // memory and put residual memory back to \\n            // the map if any\\n            ownership[mID].push_back({start, size});\\n            mp.erase(start);\\n            if (length > size)\\n                mp.insert({start + size, length-size});\\n            return start;\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int ans = 0;\\n        for (auto [start, size]: ownership[mID]) {\\n            // it\\'s always fine to return the memory\\n            ans += size;\\n\\n            // case 1: empty map\\n            if (mp.empty()) {\\n                mp.insert({start, size});\\n                continue;\\n            }\\n\\n            // case 2: nonempty map\\n            // beg, len is the new start and length after\\n            // we merge the freed interval with the adjacent\\n            // free chuncks.\\n            int beg = start, len = size;\\n            auto it = mp.upper_bound(start);\\n\\n            // --it is the previous free memory of [start, size]\\n            // If it is begin, then there\\'s no previous chunck.\\n            if (it != mp.begin()) {\\n                auto prev_it = it;\\n                --prev_it;\\n                // check if they overlap\\n                if (prev_it->first + prev_it->second == start) {\\n                    beg = prev_it->first;\\n                    len += prev_it->second;\\n                    mp.erase(prev_it);\\n                }\\n            }\\n\\n            // it is the next free memory chunk of [start, size]\\n            // If it\\'s end, then there\\'s no next chunck\\n            if (it != mp.end()) {\\n                // check if they overlap\\n                if (it->first == start + size) {\\n                    len += it->second;\\n                    mp.erase(it);\\n                }\\n            }\\n            // put back the merged free interval\\n            mp.insert({beg, len});\\n        }\\n        // remove all the allocated interval by mID from the unordered_map\\n        ownership[mID].clear();\\n        return ans;\\n    }\\n\\n    int chunck;\\n    map<int, int> mp; // (left boundary, size)\\n    unordered_map<int, vector<pair<int,int>>> ownership; // mID -> vector of (left boundary, size)\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219683,
                "title": "c-two-map",
                "content": "```\\nclass Allocator {\\n    map<int, int> freeInd2Size; // for free memory\\n    unordered_map<int, vector<pair<int, int>>> mID2ListOfPairsOfIndSize; // for allocated memory\\n\\npublic:\\n    Allocator(int n) {\\n        freeInd2Size.insert({0, n});\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        for (auto& e : freeInd2Size) {\\n            int i = e.first; // index of `free block`\\n            int s = e.second; // size of `free block`\\n            if (size <= s) {\\n                // found\\n                mID2ListOfPairsOfIndSize[mID].push_back({i, size});\\n                if (s > size) {\\n                    freeInd2Size.insert({i + size, s - size});\\n                }\\n                freeInd2Size.erase(i);\\n                return i;\\n            }\\n        }\\n        // not found\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int freeMemoryCount = 0;\\n\\n        // ------ the key here is to update the freeInd2Size ------\\n        for (const auto& pair : mID2ListOfPairsOfIndSize[mID]) {\\n            int i = pair.first; // index of `block to be released`\\n            int s = pair.second; // size of `block to be released`\\n            auto it = freeInd2Size.insert({i, s}).first; // get the iterator pointing to the inserted element\\n\\n            // update the memory location due to continuous block\\n            if (it != freeInd2Size.begin()) {\\n                auto prevIt = prev(it);\\n                // check if left continueos\\n                if (prevIt->first + prevIt->second == i) {\\n                    prevIt->second += s;\\n                    freeInd2Size.erase(it);\\n                    it = prevIt;\\n                }\\n            }\\n            if (next(it) != freeInd2Size.end()) {\\n                auto nextIt = next(it);\\n                // check right continueos\\n                if (i + s == nextIt->first) {\\n                    it->second += nextIt->second;\\n                    freeInd2Size.erase(nextIt);\\n                }\\n            }\\n\\n            freeMemoryCount += s;\\n        }\\n        mID2ListOfPairsOfIndSize.erase(mID);\\n        return freeMemoryCount;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\n    map<int, int> freeInd2Size; // for free memory\\n    unordered_map<int, vector<pair<int, int>>> mID2ListOfPairsOfIndSize; // for allocated memory\\n\\npublic:\\n    Allocator(int n) {\\n        freeInd2Size.insert({0, n});\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        for (auto& e : freeInd2Size) {\\n            int i = e.first; // index of `free block`\\n            int s = e.second; // size of `free block`\\n            if (size <= s) {\\n                // found\\n                mID2ListOfPairsOfIndSize[mID].push_back({i, size});\\n                if (s > size) {\\n                    freeInd2Size.insert({i + size, s - size});\\n                }\\n                freeInd2Size.erase(i);\\n                return i;\\n            }\\n        }\\n        // not found\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int freeMemoryCount = 0;\\n\\n        // ------ the key here is to update the freeInd2Size ------\\n        for (const auto& pair : mID2ListOfPairsOfIndSize[mID]) {\\n            int i = pair.first; // index of `block to be released`\\n            int s = pair.second; // size of `block to be released`\\n            auto it = freeInd2Size.insert({i, s}).first; // get the iterator pointing to the inserted element\\n\\n            // update the memory location due to continuous block\\n            if (it != freeInd2Size.begin()) {\\n                auto prevIt = prev(it);\\n                // check if left continueos\\n                if (prevIt->first + prevIt->second == i) {\\n                    prevIt->second += s;\\n                    freeInd2Size.erase(it);\\n                    it = prevIt;\\n                }\\n            }\\n            if (next(it) != freeInd2Size.end()) {\\n                auto nextIt = next(it);\\n                // check right continueos\\n                if (i + s == nextIt->first) {\\n                    it->second += nextIt->second;\\n                    freeInd2Size.erase(nextIt);\\n                }\\n            }\\n\\n            freeMemoryCount += s;\\n        }\\n        mID2ListOfPairsOfIndSize.erase(mID);\\n        return freeMemoryCount;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186829,
                "title": "java-9ms-95-doubly-linkedlist-map",
                "content": "# Approach\\n1. Create a double linked list of MemoryBlock (int start, end)\\n2. Start by adding MemoryBlocks traverse from head and  stopping when there is a gap between current and next.\\n    - Pay attention to the case when you can add before the head or at the tail.    \\n3. Maintain a Map<mId, List<MemoryBlock>> to access the elements in the LinkedList for deletion.\\n4. For a shallow quick-fail, also keep track of remaining capacity to reject allocations when not enough space remains globally\\n\\n# Complexity\\n- Time complexity:$$O(n)- allocate, O(1) - free$$,\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator {\\n    private final Map<Integer, List<MemoryBlock>> mids;\\n    private final int maxSize;\\n    private MemoryBlock head;\\n    private int remaining;\\n    public Allocator(int n) {\\n        this.maxSize = n;\\n        this.remaining = n;\\n        mids = new HashMap<>();\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        if (remaining < size) {\\n            return -1;\\n        }\\n        if (head == null) {\\n            head = new MemoryBlock(0, size, mID);\\n            remaining -= size;\\n            mids.computeIfAbsent(mID, k -> new ArrayList<>()).add(head);\\n            return head.start;\\n        } else {\\n            return traverseAndInsert(size, mID);\\n        }\\n    }\\n\\n    private int traverseAndInsert(int size, int mID) {\\n        MemoryBlock iterator = head;\\n        while(iterator != null) {\\n            int leftAvailable = iterator.previous == null ? iterator.start : (iterator.start - iterator.previous.end) - 1;\\n            if (leftAvailable >= size) {\\n                MemoryBlock newBlock;\\n                if (iterator.previous == null) {\\n                    // new head!\\n                    newBlock = new MemoryBlock(0, size, mID);\\n                    newBlock.next = iterator;\\n                    iterator.previous = newBlock;\\n                    head = newBlock;\\n                } else {\\n                    newBlock = new MemoryBlock(iterator.previous.end +1, size, mID);\\n                    iterator.previous.next = newBlock;\\n                    newBlock.previous = iterator.previous;\\n                    newBlock.next = iterator;\\n                    iterator.previous = newBlock;\\n                }\\n                mids.computeIfAbsent(mID, k -> new ArrayList<>()).add(newBlock);\\n                remaining -= size;\\n                return newBlock.start;\\n            }\\n            if (iterator.next == null) {\\n                break;\\n            }\\n            iterator = iterator.next;\\n        }\\n        // reached the end/tail.\\n        if (maxSize - iterator.end > size) {\\n            // add at the end\\n            MemoryBlock newBlock = new MemoryBlock(iterator.end +1, size, mID);\\n            newBlock.previous = iterator;\\n            iterator.next = newBlock;\\n            mids.computeIfAbsent(mID, k -> new ArrayList<>()).add(newBlock);\\n            remaining -= size;\\n            return newBlock.start;\\n        } else {\\n            return -1;\\n        }\\n    }\\n    \\n    public int free(int mID) {\\n        List<MemoryBlock> deallocated = mids.remove(mID);\\n        if (deallocated != null && !deallocated.isEmpty()) {\\n            int space = 0;\\n            for (MemoryBlock mb : deallocated) {\\n                space += mb.end - mb.start + 1;\\n                deallocateBlock(mb);\\n            }\\n            return space;\\n        }\\n        return 0;\\n    }\\n\\n    private void deallocateBlock(MemoryBlock mb) {\\n        if (head == mb) {\\n            if (head.next != null) { \\n                head.next.previous = null;\\n            }\\n            head = mb.next;\\n            mb.next = null;\\n        // tail    \\n        } else if (mb.next == null) {\\n            mb.previous.next = null;\\n            mb.previous = null;\\n        } else { // somewhere in the middle\\n            mb.previous.next = mb.next;\\n            mb.next.previous = mb.previous;\\n        }\\n        remaining += (mb.end - mb.start + 1);\\n    }\\n\\n    private static class MemoryBlock {\\n        int start;\\n        int end;\\n        int mID;\\n        MemoryBlock previous;\\n        MemoryBlock next;\\n\\n        public MemoryBlock(int start, int size, int mID) {\\n            this.start = start;\\n            this.end = start + size - 1;\\n            this.mID = mID;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass Allocator {\\n    private final Map<Integer, List<MemoryBlock>> mids;\\n    private final int maxSize;\\n    private MemoryBlock head;\\n    private int remaining;\\n    public Allocator(int n) {\\n        this.maxSize = n;\\n        this.remaining = n;\\n        mids = new HashMap<>();\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        if (remaining < size) {\\n            return -1;\\n        }\\n        if (head == null) {\\n            head = new MemoryBlock(0, size, mID);\\n            remaining -= size;\\n            mids.computeIfAbsent(mID, k -> new ArrayList<>()).add(head);\\n            return head.start;\\n        } else {\\n            return traverseAndInsert(size, mID);\\n        }\\n    }\\n\\n    private int traverseAndInsert(int size, int mID) {\\n        MemoryBlock iterator = head;\\n        while(iterator != null) {\\n            int leftAvailable = iterator.previous == null ? iterator.start : (iterator.start - iterator.previous.end) - 1;\\n            if (leftAvailable >= size) {\\n                MemoryBlock newBlock;\\n                if (iterator.previous == null) {\\n                    // new head!\\n                    newBlock = new MemoryBlock(0, size, mID);\\n                    newBlock.next = iterator;\\n                    iterator.previous = newBlock;\\n                    head = newBlock;\\n                } else {\\n                    newBlock = new MemoryBlock(iterator.previous.end +1, size, mID);\\n                    iterator.previous.next = newBlock;\\n                    newBlock.previous = iterator.previous;\\n                    newBlock.next = iterator;\\n                    iterator.previous = newBlock;\\n                }\\n                mids.computeIfAbsent(mID, k -> new ArrayList<>()).add(newBlock);\\n                remaining -= size;\\n                return newBlock.start;\\n            }\\n            if (iterator.next == null) {\\n                break;\\n            }\\n            iterator = iterator.next;\\n        }\\n        // reached the end/tail.\\n        if (maxSize - iterator.end > size) {\\n            // add at the end\\n            MemoryBlock newBlock = new MemoryBlock(iterator.end +1, size, mID);\\n            newBlock.previous = iterator;\\n            iterator.next = newBlock;\\n            mids.computeIfAbsent(mID, k -> new ArrayList<>()).add(newBlock);\\n            remaining -= size;\\n            return newBlock.start;\\n        } else {\\n            return -1;\\n        }\\n    }\\n    \\n    public int free(int mID) {\\n        List<MemoryBlock> deallocated = mids.remove(mID);\\n        if (deallocated != null && !deallocated.isEmpty()) {\\n            int space = 0;\\n            for (MemoryBlock mb : deallocated) {\\n                space += mb.end - mb.start + 1;\\n                deallocateBlock(mb);\\n            }\\n            return space;\\n        }\\n        return 0;\\n    }\\n\\n    private void deallocateBlock(MemoryBlock mb) {\\n        if (head == mb) {\\n            if (head.next != null) { \\n                head.next.previous = null;\\n            }\\n            head = mb.next;\\n            mb.next = null;\\n        // tail    \\n        } else if (mb.next == null) {\\n            mb.previous.next = null;\\n            mb.previous = null;\\n        } else { // somewhere in the middle\\n            mb.previous.next = mb.next;\\n            mb.next.previous = mb.previous;\\n        }\\n        remaining += (mb.end - mb.start + 1);\\n    }\\n\\n    private static class MemoryBlock {\\n        int start;\\n        int end;\\n        int mID;\\n        MemoryBlock previous;\\n        MemoryBlock next;\\n\\n        public MemoryBlock(int start, int size, int mID) {\\n            this.start = start;\\n            this.end = start + size - 1;\\n            this.mID = mID;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160164,
                "title": "region-map-with-comments",
                "content": "# Approach\\nWe\\'ll store free and allocated regions of memory in descriptor tuples of type `[start, end, mID]`. Free regions have mID of `NaN`.\\n\\nEvery time we allocate new memory, we either fully cover a free region or fill and split it, depending on its size. We update the allocated and free regions\\' indices and values.\\n\\nWhen we free a region, we simply set its mID to `NaN`. The size of the region is the number of freed blocks. We then run an iterative merge of all consecutive free regions to \"defragment\" the memory.\\n\\n# Code\\n```\\nclass Allocator {\\n    // Allocation region map. Free space has mID = NaN.\\n    alloc_map: [start: number, end: number, mID: number][];\\n\\n    constructor(n: number) {\\n        // Initialize allocation map with a single region\\n        this.alloc_map = [[0, n, NaN]];\\n    }\\n\\n    allocate(size: number, mID: number): number {\\n        // Find the next empty block with given size or greater\\n        const next_free = this.find_free(size);\\n\\n        if (next_free === -1) {\\n            return -1;\\n        }\\n\\n        // Get a reference to the suitable region and remember its original size\\n        const alloc = this.alloc_map[next_free];\\n        const alloc_size = alloc[1] - alloc[0];\\n\\n        // Set the whole region\\'s mID to the one requested for allocation\\n        alloc[2] = mID;\\n\\n        // If the free region was bigger than requested...\\n        if (alloc_size > size) {\\n            // ... add a new free region that starts after the current one\\n            this.alloc_map.splice(next_free + 1, 0, [\\n                alloc[0] + size,\\n                alloc[1],\\n                NaN,\\n            ]);\\n\\n            // ... and update the current region\\'s size\\n            alloc[1] = alloc[0] + size;\\n        }\\n\\n        return alloc[0];\\n    }\\n\\n    free(mID: number): number {\\n        const mID_allocs = [] as typeof this.alloc_map;\\n\\n        // Find all allocations for the given mID\\n        this.alloc_map.forEach((alloc) => {\\n            if (alloc[2] === mID) {\\n                mID_allocs.push(alloc);\\n            }\\n        });\\n\\n        if (mID_allocs.length === 0) {\\n            return 0;\\n        }\\n\\n        // Add their lengths together to count the number of freed blocks\\n        const freed = mID_allocs.reduce(\\n            (sum, alloc) => sum += alloc[1] - alloc[0],\\n            0,\\n        );\\n\\n        // Mark all allocations as free space\\n        mID_allocs.forEach((alloc) => alloc[2] = NaN);\\n\\n        // Merge consecutive free regions into one\\n        this.merge_free();\\n\\n        return freed;\\n    }\\n\\n    find_free(size: number) {\\n        return this.alloc_map.findIndex(([fs, fe, mID]) =>\\n            isNaN(mID) && ((fe - fs) >= size ? true : false)\\n        );\\n    }\\n\\n    merge_free() {\\n        let i = 0;\\n\\n        // Iterate over all allocations\\n        while (i < this.alloc_map.length) {\\n            const current = this.alloc_map[i];\\n            const next = this.alloc_map[i + 1];\\n\\n            // If we have two consecutive free regions ...\\n            if (isNaN(current[2]) && next && isNaN(next[2])) {\\n                // ... absorb the second one into the first\\n                current[1] = next[1];\\n\\n                // ... and remove the second one\\n                this.alloc_map.splice(i + 1, 1);\\n\\n                // Note: If we remove a region, the pointer does not advance.\\n                // That way we can check the current region with the one following\\n                // the recently merged\\n            } else {\\n                // If not, advance the pointer\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nclass Allocator {\\n    // Allocation region map. Free space has mID = NaN.\\n    alloc_map: [start: number, end: number, mID: number][];\\n\\n    constructor(n: number) {\\n        // Initialize allocation map with a single region\\n        this.alloc_map = [[0, n, NaN]];\\n    }\\n\\n    allocate(size: number, mID: number): number {\\n        // Find the next empty block with given size or greater\\n        const next_free = this.find_free(size);\\n\\n        if (next_free === -1) {\\n            return -1;\\n        }\\n\\n        // Get a reference to the suitable region and remember its original size\\n        const alloc = this.alloc_map[next_free];\\n        const alloc_size = alloc[1] - alloc[0];\\n\\n        // Set the whole region\\'s mID to the one requested for allocation\\n        alloc[2] = mID;\\n\\n        // If the free region was bigger than requested...\\n        if (alloc_size > size) {\\n            // ... add a new free region that starts after the current one\\n            this.alloc_map.splice(next_free + 1, 0, [\\n                alloc[0] + size,\\n                alloc[1],\\n                NaN,\\n            ]);\\n\\n            // ... and update the current region\\'s size\\n            alloc[1] = alloc[0] + size;\\n        }\\n\\n        return alloc[0];\\n    }\\n\\n    free(mID: number): number {\\n        const mID_allocs = [] as typeof this.alloc_map;\\n\\n        // Find all allocations for the given mID\\n        this.alloc_map.forEach((alloc) => {\\n            if (alloc[2] === mID) {\\n                mID_allocs.push(alloc);\\n            }\\n        });\\n\\n        if (mID_allocs.length === 0) {\\n            return 0;\\n        }\\n\\n        // Add their lengths together to count the number of freed blocks\\n        const freed = mID_allocs.reduce(\\n            (sum, alloc) => sum += alloc[1] - alloc[0],\\n            0,\\n        );\\n\\n        // Mark all allocations as free space\\n        mID_allocs.forEach((alloc) => alloc[2] = NaN);\\n\\n        // Merge consecutive free regions into one\\n        this.merge_free();\\n\\n        return freed;\\n    }\\n\\n    find_free(size: number) {\\n        return this.alloc_map.findIndex(([fs, fe, mID]) =>\\n            isNaN(mID) && ((fe - fs) >= size ? true : false)\\n        );\\n    }\\n\\n    merge_free() {\\n        let i = 0;\\n\\n        // Iterate over all allocations\\n        while (i < this.alloc_map.length) {\\n            const current = this.alloc_map[i];\\n            const next = this.alloc_map[i + 1];\\n\\n            // If we have two consecutive free regions ...\\n            if (isNaN(current[2]) && next && isNaN(next[2])) {\\n                // ... absorb the second one into the first\\n                current[1] = next[1];\\n\\n                // ... and remove the second one\\n                this.alloc_map.splice(i + 1, 1);\\n\\n                // Note: If we remove a region, the pointer does not advance.\\n                // That way we can check the current region with the one following\\n                // the recently merged\\n            } else {\\n                // If not, advance the pointer\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149739,
                "title": "python-hashmap-linked-list-lazy-update-beats-98",
                "content": "when you free node, only set the specific nodes to deleted through a dictionary with all the node objects. Then sum blocks up by sum( end-start )\\n\\n\\n\\nWhen you search for free space, you need to fist check if the next node is deleted. If it is, the connect the following node.\\n\\nIf the next node is not deleted, then you can check if there is space between them. If there is, good, add node object to dictionary. \\n\\nContinue going to next node if cannot find\\n\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.head=NODE(-1,-1)\\n        tail=NODE(n,n)\\n        self.head.next=tail\\n        tail.prev=self.head\\n        \\n        self.sections=defaultdict(list)\\n        \\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        pointer=self.head\\n        \\n        \\n        while pointer and pointer.next:\\n            if pointer.next.deleted:\\n                nextNode=pointer.next.next\\n                pointer.next=nextNode\\n                \\n            elif pointer.next.start-pointer.end -1>=size:\\n                newNode=NODE(pointer.end+1,pointer.end+size)\\n                following=pointer.next\\n                pointer.next=newNode\\n                newNode.next=following\\n                \\n                self.sections[mID].append(newNode)\\n                return newNode.start\\n            \\n            else:\\n                pointer=pointer.next\\n        \\n        \\n        return -1\\n\\n        \\n        \\n        \\n\\n    def free(self, mID: int) -> int:\\n        for node in self.sections[mID]:\\n            node.deleted=True\\n        \\n        ans=sum(node.end-node.start+1 for node in self.sections[mID])\\n        self.sections[mID]=[]\\n        return ans\\n        \\n        \\n        \\nclass NODE:\\n    def __init__(self,start,end):\\n        self.next=None\\n        self.start=start\\n        self.end=end\\n        self.deleted=False",
                "solutionTags": [],
                "code": "when you free node, only set the specific nodes to deleted through a dictionary with all the node objects. Then sum blocks up by sum( end-start )\\n\\n\\n\\nWhen you search for free space, you need to fist check if the next node is deleted. If it is, the connect the following node.\\n\\nIf the next node is not deleted, then you can check if there is space between them. If there is, good, add node object to dictionary. \\n\\nContinue going to next node if cannot find\\n\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.head=NODE(-1,-1)\\n        tail=NODE(n,n)\\n        self.head.next=tail\\n        tail.prev=self.head\\n        \\n        self.sections=defaultdict(list)\\n        \\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        pointer=self.head\\n        \\n        \\n        while pointer and pointer.next:\\n            if pointer.next.deleted:\\n                nextNode=pointer.next.next\\n                pointer.next=nextNode\\n                \\n            elif pointer.next.start-pointer.end -1>=size:\\n                newNode=NODE(pointer.end+1,pointer.end+size)\\n                following=pointer.next\\n                pointer.next=newNode\\n                newNode.next=following\\n                \\n                self.sections[mID].append(newNode)\\n                return newNode.start\\n            \\n            else:\\n                pointer=pointer.next\\n        \\n        \\n        return -1\\n\\n        \\n        \\n        \\n\\n    def free(self, mID: int) -> int:\\n        for node in self.sections[mID]:\\n            node.deleted=True\\n        \\n        ans=sum(node.end-node.start+1 for node in self.sections[mID])\\n        self.sections[mID]=[]\\n        return ans\\n        \\n        \\n        \\nclass NODE:\\n    def __init__(self,start,end):\\n        self.next=None\\n        self.start=start\\n        self.end=end\\n        self.deleted=False",
                "codeTag": "Java"
            },
            {
                "id": 3138455,
                "title": "design-memory-allocator",
                "content": "\\n\\n# Code\\n```\\n#from sortedcontainers import SortedList\\n\\nclass ListNodeMem( object):\\n    def __init__(   self,   mID = None, prev    =   None, next =   None):\\n        self.mID    =   mID\\n        self.prev   =   prev\\n        self.next   =   next\\n        self.start  =   self.end    =   0\\n        return\\n    \\n    def pop(    self):\\n        if self.prev:       self.prev.next  =   self.next\\n        if self.next:       self.next.prev  =   self.prev\\n        del self\\n        return\\n    \\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        # CONSTANTS\\n        self.EMPTY_VAL  =   None  \\n        self.INVALID_INDEX  =   -1\\n\\n        self.head   =   ListNodeMem(   mID =   \\'HEAD\\')\\n        self.tail   =   ListNodeMem(   mID =   \\'TAIL\\')\\n        firstEmpty  =   ListNodeMem(   mID =   self.EMPTY_VAL, prev = self.head, next = self.tail)\\n        self.head.next  =   self.tail.prev  =   firstEmpty\\n        firstEmpty.start    =   0\\n        firstEmpty.end      =   n-1        \\n\\n        self.mIDNodes   =   collections.defaultdict(    list)\\n        self.memorySize =   n\\n        return\\n        \\n    def allocate(self, size: int, mID: int) -> int:\\n        ptr =   self.head.next\\n        startBlockIndex =   -1\\n\\n        while ptr != self.tail:\\n            ptrSize =   ptr.end - ptr.start + 1\\n\\n            if  ptr.mID == self.EMPTY_VAL and ptrSize >= size:\\n                newAlloc    =   ListNodeMem(   mID =   mID)   #[mID, ptrStart, ptrStart+size-1])\\n                newAlloc.start  =   ptr.start\\n                newAlloc.end    =   ptr.start + size -1\\n                newAlloc.prev   =   ptr.prev\\n                self.mIDNodes[mID].append(   newAlloc)\\n                ptr.prev.next   =   newAlloc\\n\\n                if ptrSize == size:\\n                    newAlloc.next   =   ptr.next\\n                    ptr.next.prev   =   newAlloc\\n                    del ptr\\n\\n                else:\\n                    newAlloc.next   =   ptr\\n                    ptr.prev    =   newAlloc\\n                    ptr.start   =   ptr.start + size\\n                return newAlloc.start\\n\\n            ptr =   ptr.next\\n        return self.INVALID_INDEX   #returns -1 if can\\'t allocate.\\n\\n    def free(self, mID: int) -> int:\\n        totalFreedSize  =   0\\n        \\n        while self.mIDNodes[mID]:\\n            currNode    =   self.mIDNodes[mID].pop()\\n            totalFreedSize  +=  currNode.end - currNode.start + 1\\n            emptyStart, emptyEnd    =   currNode.start, currNode.end\\n\\n            #if prev node is Free/Empty, merge it with currNode.\\n            if currNode.prev != self.head and currNode.prev.mID == self.EMPTY_VAL:\\n                emptyStart  =   currNode.prev.start                \\n                currNode.prev.pop()\\n            \\n            #if next node is Free/Empty, merge it with currNode.\\n            if currNode.next != self.tail and currNode.next.mID == self.EMPTY_VAL:\\n                emptyEnd    =   currNode.next.end\\n                currNode.next.pop()\\n            \\n            #mark Free/Empty val in interval [EmptyStart, EmptyEnd]\\n            currNode.mID, currNode.start, currNode.end  =   self.EMPTY_VAL, emptyStart, emptyEnd\\n        return totalFreedSize\\n\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#from sortedcontainers import SortedList\\n\\nclass ListNodeMem( object):\\n    def __init__(   self,   mID = None, prev    =   None, next =   None):\\n        self.mID    =   mID\\n        self.prev   =   prev\\n        self.next   =   next\\n        self.start  =   self.end    =   0\\n        return\\n    \\n    def pop(    self):\\n        if self.prev:       self.prev.next  =   self.next\\n        if self.next:       self.next.prev  =   self.prev\\n        del self\\n        return\\n    \\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        # CONSTANTS\\n        self.EMPTY_VAL  =   None  \\n        self.INVALID_INDEX  =   -1\\n\\n        self.head   =   ListNodeMem(   mID =   \\'HEAD\\')\\n        self.tail   =   ListNodeMem(   mID =   \\'TAIL\\')\\n        firstEmpty  =   ListNodeMem(   mID =   self.EMPTY_VAL, prev = self.head, next = self.tail)\\n        self.head.next  =   self.tail.prev  =   firstEmpty\\n        firstEmpty.start    =   0\\n        firstEmpty.end      =   n-1        \\n\\n        self.mIDNodes   =   collections.defaultdict(    list)\\n        self.memorySize =   n\\n        return\\n        \\n    def allocate(self, size: int, mID: int) -> int:\\n        ptr =   self.head.next\\n        startBlockIndex =   -1\\n\\n        while ptr != self.tail:\\n            ptrSize =   ptr.end - ptr.start + 1\\n\\n            if  ptr.mID == self.EMPTY_VAL and ptrSize >= size:\\n                newAlloc    =   ListNodeMem(   mID =   mID)   #[mID, ptrStart, ptrStart+size-1])\\n                newAlloc.start  =   ptr.start\\n                newAlloc.end    =   ptr.start + size -1\\n                newAlloc.prev   =   ptr.prev\\n                self.mIDNodes[mID].append(   newAlloc)\\n                ptr.prev.next   =   newAlloc\\n\\n                if ptrSize == size:\\n                    newAlloc.next   =   ptr.next\\n                    ptr.next.prev   =   newAlloc\\n                    del ptr\\n\\n                else:\\n                    newAlloc.next   =   ptr\\n                    ptr.prev    =   newAlloc\\n                    ptr.start   =   ptr.start + size\\n                return newAlloc.start\\n\\n            ptr =   ptr.next\\n        return self.INVALID_INDEX   #returns -1 if can\\'t allocate.\\n\\n    def free(self, mID: int) -> int:\\n        totalFreedSize  =   0\\n        \\n        while self.mIDNodes[mID]:\\n            currNode    =   self.mIDNodes[mID].pop()\\n            totalFreedSize  +=  currNode.end - currNode.start + 1\\n            emptyStart, emptyEnd    =   currNode.start, currNode.end\\n\\n            #if prev node is Free/Empty, merge it with currNode.\\n            if currNode.prev != self.head and currNode.prev.mID == self.EMPTY_VAL:\\n                emptyStart  =   currNode.prev.start                \\n                currNode.prev.pop()\\n            \\n            #if next node is Free/Empty, merge it with currNode.\\n            if currNode.next != self.tail and currNode.next.mID == self.EMPTY_VAL:\\n                emptyEnd    =   currNode.next.end\\n                currNode.next.pop()\\n            \\n            #mark Free/Empty val in interval [EmptyStart, EmptyEnd]\\n            currNode.mID, currNode.start, currNode.end  =   self.EMPTY_VAL, emptyStart, emptyEnd\\n        return totalFreedSize\\n\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130765,
                "title": "java-beats-100-using-array-short-and-fast-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n100%\\n\\n- Space complexity:\\n100%\\n\\n# Code\\n```\\nclass Allocator {\\n    int[] array;\\n    int n;\\n    public Allocator(int n) {\\n        array = new int[n];\\n        this.n = n;\\n        for(int i = 0; i < n; i++){\\n            array[i] = -1;\\n        }\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        if(size > n) return -1;\\n        int count = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;\\n        for(int i = 0; i < n; i++){\\n            if(array[i] == -1){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n                startIndex = i + 1;\\n            }\\n            if(count == size){\\n                endIndex = i;\\n                break;\\n            }\\n        }\\n        if(startIndex > endIndex) return -1;\\n        Arrays.fill(array, startIndex, Math.min(endIndex + 1, n), mID);\\n        return startIndex;\\n    }\\n    \\n    public int free(int mID) {\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            if(array[i] == mID){\\n                array[i] = -1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    int[] array;\\n    int n;\\n    public Allocator(int n) {\\n        array = new int[n];\\n        this.n = n;\\n        for(int i = 0; i < n; i++){\\n            array[i] = -1;\\n        }\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        if(size > n) return -1;\\n        int count = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;\\n        for(int i = 0; i < n; i++){\\n            if(array[i] == -1){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n                startIndex = i + 1;\\n            }\\n            if(count == size){\\n                endIndex = i;\\n                break;\\n            }\\n        }\\n        if(startIndex > endIndex) return -1;\\n        Arrays.fill(array, startIndex, Math.min(endIndex + 1, n), mID);\\n        return startIndex;\\n    }\\n    \\n    public int free(int mID) {\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            if(array[i] == mID){\\n                array[i] = -1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123533,
                "title": "java-simulation-solution",
                "content": "\\n\\n# Code\\n```\\nclass Allocator {\\n        int[] arr;\\n        int length;\\n        public Allocator(int n) {\\n            arr = new int[n];\\n            length = n;\\n        }\\n        public int allocate(int size, int mID) {\\n            for (int i = 0; i < length; i++) {\\n                int c = size;\\n                int j = i;\\n                while(i < length && arr[i] == 0 && c > 0){\\n                    arr[i] = mID;\\n                    c--;\\n                    i++;\\n                }\\n                if(c == 0){\\n                    return j;\\n                }\\n                int t = i;\\n                while (i != j){\\n                    i--;\\n                    arr[i] = 0;\\n                }\\n                i = t;\\n            }\\n            return -1;\\n        }\\n        public int free(int mID) {\\n            int cnt = 0;\\n            for (int i = 0; i < length; i++) {\\n                if(arr[i] == mID){\\n                    cnt++;\\n                    arr[i] = 0;\\n                }\\n            }\\n            return cnt;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n        int[] arr;\\n        int length;\\n        public Allocator(int n) {\\n            arr = new int[n];\\n            length = n;\\n        }\\n        public int allocate(int size, int mID) {\\n            for (int i = 0; i < length; i++) {\\n                int c = size;\\n                int j = i;\\n                while(i < length && arr[i] == 0 && c > 0){\\n                    arr[i] = mID;\\n                    c--;\\n                    i++;\\n                }\\n                if(c == 0){\\n                    return j;\\n                }\\n                int t = i;\\n                while (i != j){\\n                    i--;\\n                    arr[i] = 0;\\n                }\\n                i = t;\\n            }\\n            return -1;\\n        }\\n        public int free(int mID) {\\n            int cnt = 0;\\n            for (int i = 0; i < length; i++) {\\n                if(arr[i] == mID){\\n                    cnt++;\\n                    arr[i] = 0;\\n                }\\n            }\\n            return cnt;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111236,
                "title": "cpu-and-mem-efficient-vector-based",
                "content": "# Intuition\\nMaintain an ordered list of the available blocks.\\n\\n# Approach\\nWe maintain a vector of blocks, and make sure to always merge adjacent blocks with equal mID. Then we can just look for the first available block of a big enough size on allocate, and flip all the available blocks to free on free.\\n\\nAllocate needs to insert the new free block right after the resized block. This is guaranteed to not have another free block after it, so we can just insert it and return the addr.\\n\\nFree needs to run a merge after all blocks have been freed. This can be an expensive process. Possibly, a linked list could be slightly more effective for this purpose, but it would be less effective for the general iteration.\\n\\n# Code\\n```\\nclass Block {\\npublic:\\n    int addr;\\n    mutable int sz;\\n    mutable int mid;\\n\\n    Block(int sz): addr(0), sz(sz), mid(-1) {};\\n    Block(int addr, int sz): addr(addr), sz(sz), mid(-1) {};\\n    Block(int addr, int sz, int mid): addr(addr), sz(sz), mid(mid) {};\\n\\n    // NO sanity checking!\\n    void merge_adjacent(Block& other) {\\n        sz += other.sz;\\n    }\\n};\\n\\nclass Allocator {\\n    vector<Block> blocks;\\npublic:\\n    Allocator(int n) {\\n        Block b { 0, n };\\n        blocks = vector { b };\\n    }\\n    \\n    int allocate(int size, int mID) {\\n\\n        int idx = 0;\\n        for (Block& block : blocks) {\\n            if (block.mid == -1 && block.sz >= size) {\\n                block.mid = mID;\\n                int retaddr = block.addr;\\n\\n                if (block.sz != size) {\\n                    int freesize = block.sz - size;\\n                    block.sz = size;\\n                    \\n                    Block nb { block.addr + size, freesize };\\n                    blocks.insert(next(blocks.begin(), idx + 1), nb);                    \\n                }\\n                return retaddr;\\n            }\\n            idx++;\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int sum = 0;\\n        for (Block& block : blocks) {\\n            if (block.mid == mID) {\\n                sum += block.sz;\\n                block.mid = -1;\\n            }\\n        }\\n        merge_adjacent_blocks();\\n        return sum;\\n    }\\n\\n    void merge_adjacent_blocks() {\\n        for (int i = 0; i < blocks.size() - 1; i++) {\\n            if (blocks[i].mid == blocks[i+1].mid) {\\n                blocks[i].merge_adjacent(blocks[i+1]);\\n                blocks.erase(blocks.begin() + i + 1);\\n                i--;\\n            }\\n        }\\n        return;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Intuition\\nMaintain an ordered list of the available blocks.\\n\\n# Approach\\nWe maintain a vector of blocks, and make sure to always merge adjacent blocks with equal mID. Then we can just look for the first available block of a big enough size on allocate, and flip all the available blocks to free on free.\\n\\nAllocate needs to insert the new free block right after the resized block. This is guaranteed to not have another free block after it, so we can just insert it and return the addr.\\n\\nFree needs to run a merge after all blocks have been freed. This can be an expensive process. Possibly, a linked list could be slightly more effective for this purpose, but it would be less effective for the general iteration.\\n\\n# Code\\n```\\nclass Block {\\npublic:\\n    int addr;\\n    mutable int sz;\\n    mutable int mid;\\n\\n    Block(int sz): addr(0), sz(sz), mid(-1) {};\\n    Block(int addr, int sz): addr(addr), sz(sz), mid(-1) {};\\n    Block(int addr, int sz, int mid): addr(addr), sz(sz), mid(mid) {};\\n\\n    // NO sanity checking!\\n    void merge_adjacent(Block& other) {\\n        sz += other.sz;\\n    }\\n};\\n\\nclass Allocator {\\n    vector<Block> blocks;\\npublic:\\n    Allocator(int n) {\\n        Block b { 0, n };\\n        blocks = vector { b };\\n    }\\n    \\n    int allocate(int size, int mID) {\\n\\n        int idx = 0;\\n        for (Block& block : blocks) {\\n            if (block.mid == -1 && block.sz >= size) {\\n                block.mid = mID;\\n                int retaddr = block.addr;\\n\\n                if (block.sz != size) {\\n                    int freesize = block.sz - size;\\n                    block.sz = size;\\n                    \\n                    Block nb { block.addr + size, freesize };\\n                    blocks.insert(next(blocks.begin(), idx + 1), nb);                    \\n                }\\n                return retaddr;\\n            }\\n            idx++;\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int sum = 0;\\n        for (Block& block : blocks) {\\n            if (block.mid == mID) {\\n                sum += block.sz;\\n                block.mid = -1;\\n            }\\n        }\\n        merge_adjacent_blocks();\\n        return sum;\\n    }\\n\\n    void merge_adjacent_blocks() {\\n        for (int i = 0; i < blocks.size() - 1; i++) {\\n            if (blocks[i].mid == blocks[i+1].mid) {\\n                blocks[i].merge_adjacent(blocks[i+1]);\\n                blocks.erase(blocks.begin() + i + 1);\\n                i--;\\n            }\\n        }\\n        return;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3111071,
                "title": "c-brute-force",
                "content": "\\n\\n# Code\\n```\\nclass Allocator {\\npublic:vector<int> v;\\n    Allocator(int m) {\\n        v.resize(m);\\n        for(int i=0;i<m;i++)\\n        v[i]=0;\\n    }\\n    int allocate(int size, int mID) {\\n        int c=0;int id=0;bool b=0,start=1;\\n        for(int i=0;i<v.size();i++)\\n        {\\n          if(v[i]==0)\\n          {\\n              if(start)\\n              id=i;\\n              start=0;\\n              c++;\\n            if(c==size)\\n             {b=1; break;}\\n          }\\n          else\\n          { c=0;\\n            start=1;\\n          }\\n        }\\n      \\n   if(b){for(int i=id;i<id+size;i++)\\n          v[i]=mID;}\\n\\n        if(b)\\n        return id;\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n       int t=0;\\n       for(int i=0;i<v.size();i++)\\n       {\\n           if(v[i]==mID)\\n           {v[i]=0;t++;}\\n       }\\n        return t;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:vector<int> v;\\n    Allocator(int m) {\\n        v.resize(m);\\n        for(int i=0;i<m;i++)\\n        v[i]=0;\\n    }\\n    int allocate(int size, int mID) {\\n        int c=0;int id=0;bool b=0,start=1;\\n        for(int i=0;i<v.size();i++)\\n        {\\n          if(v[i]==0)\\n          {\\n              if(start)\\n              id=i;\\n              start=0;\\n              c++;\\n            if(c==size)\\n             {b=1; break;}\\n          }\\n          else\\n          { c=0;\\n            start=1;\\n          }\\n        }\\n      \\n   if(b){for(int i=id;i<id+size;i++)\\n          v[i]=mID;}\\n\\n        if(b)\\n        return id;\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n       int t=0;\\n       for(int i=0;i<v.size();i++)\\n       {\\n           if(v[i]==mID)\\n           {v[i]=0;t++;}\\n       }\\n        return t;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097860,
                "title": "simple-swift-solution-with-pseudo-code",
                "content": "# Pseudo Code\\n1. Create an array of size n and initialize it with 0\\n2. Iterate through the array and check if the current element is 0\\n3. If it is 0, increment the counter k by 1\\n4. If the counter k is equal to the size, then we have found a contiguous block of memory5. If we have found a contiguous block of memory, then we need to allocate the memory\\n6. We need to iterate from the end of the block to the start of the block and assign the memory id to the array\\n7. If we have not found a contiguous block of memory, then we return -1\\n8. To free the memory, we iterate through the array and check if the current element is equal to the memory id\\n9. If it is equal to the memory id, then we increment the counter count by 1 and assign 0 to the current element\\n10. Return the counter count\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Allocator {\\n    var arr: [Int] = []\\n    init(_ n: Int) {\\n        arr = Array(repeating: 0, count: n)\\n    }\\n    \\n    func allocate(_ size: Int, _ mID: Int) -> Int {\\n        var k: Int = 0\\n        var ei: Int = 0\\n        var flag: Bool = false\\n        for i in 0..<arr.count {\\n            if arr[i] == 0 {\\n                k += 1\\n                if k == size {\\n                    flag = true\\n                    ei = i\\n                    break\\n                }\\n            }\\n            else {\\n                k = 0\\n            }\\n        }\\n        if flag {\\n            var size = size\\n            while size > 0 {\\n                arr[ei] = mID\\n                ei -= 1\\n                size -= 1\\n            }\\n            return ei + 1\\n        }\\n        else {\\n            return -1\\n        }\\n    }\\n    \\n    func free(_ mID: Int) -> Int {\\n        var count: Int = 0\\n        for i in 0..<arr.count {\\n            if arr[i] == mID {\\n                count += 1\\n                arr[i] = 0\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Allocator {\\n    var arr: [Int] = []\\n    init(_ n: Int) {\\n        arr = Array(repeating: 0, count: n)\\n    }\\n    \\n    func allocate(_ size: Int, _ mID: Int) -> Int {\\n        var k: Int = 0\\n        var ei: Int = 0\\n        var flag: Bool = false\\n        for i in 0..<arr.count {\\n            if arr[i] == 0 {\\n                k += 1\\n                if k == size {\\n                    flag = true\\n                    ei = i\\n                    break\\n                }\\n            }\\n            else {\\n                k = 0\\n            }\\n        }\\n        if flag {\\n            var size = size\\n            while size > 0 {\\n                arr[ei] = mID\\n                ei -= 1\\n                size -= 1\\n            }\\n            return ei + 1\\n        }\\n        else {\\n            return -1\\n        }\\n    }\\n    \\n    func free(_ mID: Int) -> Int {\\n        var count: Int = 0\\n        for i in 0..<arr.count {\\n            if arr[i] == mID {\\n                count += 1\\n                arr[i] = 0\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078809,
                "title": "c-linked-list-solution",
                "content": "```\\nclass Allocator {\\nprivate:\\n    struct node {\\n        int mID;\\n        int size;\\n        node* next;\\n        node(int a, int b): mID(a), size(b), next(NULL) {}\\n        node(int a, int b, node* c): mID(a), size(b), next(c) {}\\n    };\\n\\n    node* head;\\n\\npublic:\\n    Allocator(int n) {\\n        head = new node(-1, -1);\\n        head->next = new node(0, n);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int pos = 0;\\n        node* start = head->next;\\n\\n        while(start != NULL) {\\n            if(!start->mID) {\\n                if (start->size > size) {\\n                    node *temp = new node(0, start->size - size, start->next);\\n                    start->next = temp;\\n                    start->mID = mID;\\n                    start->size = size;\\n                    return pos;\\n                }\\n\\n                else if(start->size == size) {\\n                    start->mID = mID;\\n                    return pos;\\n                }\\n            }\\n\\n            pos += start->size;\\n            start = start->next;\\n        }\\n\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int count = 0;\\n        int merge = 0;\\n        node* start = head->next;\\n        node* prev = head;\\n\\n        while(start != NULL) {\\n            if(start->mID == mID) {\\n                start->mID = 0;\\n                count += start->size;\\n            }\\n\\n            if(start->mID == prev->mID) {\\n                prev->size += start->size;\\n                prev->next = start->next;\\n                merge = 1;\\n            }\\n\\n            if(!merge) prev = start;\\n            start = start->next;\\n            merge = 0;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\nprivate:\\n    struct node {\\n        int mID;\\n        int size;\\n        node* next;\\n        node(int a, int b): mID(a), size(b), next(NULL) {}\\n        node(int a, int b, node* c): mID(a), size(b), next(c) {}\\n    };\\n\\n    node* head;\\n\\npublic:\\n    Allocator(int n) {\\n        head = new node(-1, -1);\\n        head->next = new node(0, n);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int pos = 0;\\n        node* start = head->next;\\n\\n        while(start != NULL) {\\n            if(!start->mID) {\\n                if (start->size > size) {\\n                    node *temp = new node(0, start->size - size, start->next);\\n                    start->next = temp;\\n                    start->mID = mID;\\n                    start->size = size;\\n                    return pos;\\n                }\\n\\n                else if(start->size == size) {\\n                    start->mID = mID;\\n                    return pos;\\n                }\\n            }\\n\\n            pos += start->size;\\n            start = start->next;\\n        }\\n\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int count = 0;\\n        int merge = 0;\\n        node* start = head->next;\\n        node* prev = head;\\n\\n        while(start != NULL) {\\n            if(start->mID == mID) {\\n                start->mID = 0;\\n                count += start->size;\\n            }\\n\\n            if(start->mID == prev->mID) {\\n                prev->size += start->size;\\n                prev->next = start->next;\\n                merge = 1;\\n            }\\n\\n            if(!merge) prev = start;\\n            start = start->next;\\n            merge = 0;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058352,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    \\n    vector<int> memory;\\n    int sz;\\n    unordered_map<int, vector<int>> mp;\\n    Allocator(int n) \\n    {\\n        memory.resize(n);\\n        sz=n;\\n    }\\n    \\n    int allocate(int size, int mID) \\n    {\\n        int free=0, idx;\\n        for(int i=0; i<sz; i++)\\n        {\\n            if(free==0) idx=i;\\n            if(memory[i]==0) free++;\\n            else free=0;\\n            \\n            if(free >= size) break;\\n        }\\n        \\n        if(free >= size)\\n        {\\n            for(int i=idx; i<idx+size; i++)\\n            {\\n                memory[i] = mID;\\n                mp[mID].push_back(i);\\n            }\\n        }\\n        \\n        return free>=size ? idx : -1;\\n            \\n    }\\n    \\n    int free(int mID) \\n    {\\n        int count=0;\\n        for(auto it:mp[mID])\\n        {\\n            memory[it]=0;\\n            count++;\\n        }\\n        \\n        mp.erase(mID);\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    \\n    vector<int> memory;\\n    int sz;\\n    unordered_map<int, vector<int>> mp;\\n    Allocator(int n) \\n    {\\n        memory.resize(n);\\n        sz=n;\\n    }\\n    \\n    int allocate(int size, int mID) \\n    {\\n        int free=0, idx;\\n        for(int i=0; i<sz; i++)\\n        {\\n            if(free==0) idx=i;\\n            if(memory[i]==0) free++;\\n            else free=0;\\n            \\n            if(free >= size) break;\\n        }\\n        \\n        if(free >= size)\\n        {\\n            for(int i=idx; i<idx+size; i++)\\n            {\\n                memory[i] = mID;\\n                mp[mID].push_back(i);\\n            }\\n        }\\n        \\n        return free>=size ? idx : -1;\\n            \\n    }\\n    \\n    int free(int mID) \\n    {\\n        int count=0;\\n        for(auto it:mp[mID])\\n        {\\n            memory[it]=0;\\n            count++;\\n        }\\n        \\n        mp.erase(mID);\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031078,
                "title": "java-using-2-maps",
                "content": "# Code\\n```\\nclass Allocator {\\n\\n    private TreeMap<Integer, Integer> start_size = new TreeMap<>();\\n    private Map<Integer, List<Integer>> mID_starts = new HashMap<>();\\n    private int n = 0;\\n    private int end = 0;\\n    \\n    public Allocator(int n) {\\n        this.n = n;\\n        end = n;\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        if (n < size) return -1;\\n        int ans = -1;\\n        int prev = 0;\\n        for (int start : start_size.keySet()) {\\n            if (start - prev >= size) {\\n                ans = prev;\\n                break;\\n            }\\n            prev = start + start_size.get(start);\\n        }\\n        if (ans == -1) {//check space from the end\\n            if (end - prev >= size) {\\n                ans = prev;\\n            }\\n        }\\n        if (ans != -1) {\\n            n -= size;\\n            start_size.put(ans, size);\\n            if (mID_starts.get(mID) == null) {\\n                mID_starts.put(mID, new LinkedList<>());\\n            }\\n            mID_starts.get(mID).add(ans);\\n        }\\n        return ans;\\n    }\\n    \\n    public int free(int mID) {\\n        List<Integer> starts = mID_starts.get(mID);\\n        int reclaimSize = 0;\\n        if (starts == null) return reclaimSize;\\n        for (int start : starts) {\\n            reclaimSize += start_size.get(start);\\n            start_size.remove(start);\\n        }\\n        mID_starts.remove(mID);\\n        n += reclaimSize;\\n        return reclaimSize;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n\\n    private TreeMap<Integer, Integer> start_size = new TreeMap<>();\\n    private Map<Integer, List<Integer>> mID_starts = new HashMap<>();\\n    private int n = 0;\\n    private int end = 0;\\n    \\n    public Allocator(int n) {\\n        this.n = n;\\n        end = n;\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        if (n < size) return -1;\\n        int ans = -1;\\n        int prev = 0;\\n        for (int start : start_size.keySet()) {\\n            if (start - prev >= size) {\\n                ans = prev;\\n                break;\\n            }\\n            prev = start + start_size.get(start);\\n        }\\n        if (ans == -1) {//check space from the end\\n            if (end - prev >= size) {\\n                ans = prev;\\n            }\\n        }\\n        if (ans != -1) {\\n            n -= size;\\n            start_size.put(ans, size);\\n            if (mID_starts.get(mID) == null) {\\n                mID_starts.put(mID, new LinkedList<>());\\n            }\\n            mID_starts.get(mID).add(ans);\\n        }\\n        return ans;\\n    }\\n    \\n    public int free(int mID) {\\n        List<Integer> starts = mID_starts.get(mID);\\n        int reclaimSize = 0;\\n        if (starts == null) return reclaimSize;\\n        for (int start : starts) {\\n            reclaimSize += start_size.get(start);\\n            start_size.remove(start);\\n        }\\n        mID_starts.remove(mID);\\n        n += reclaimSize;\\n        return reclaimSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015200,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\npublic class Allocator {\\n\\n    private static final int NO_AVAILABLE_MEMORY_BLOCK = -1;\\n    private static final int DUMMY_MEMORY_ID = -2;\\n    private static final int FREE_MEMORY_ID = 0;\\n\\n    //Dummy \\'head\\' and \\'tail\\' in order to avoid constant checking for \\'null\\' of \\'current.previous\\' and \\'current.next\\'\\n    Memory head;\\n    Memory tail;\\n\\n    public Allocator(int initialFreeMemorySize) {\\n        head = new Memory(DUMMY_MEMORY_ID);\\n        tail = new Memory(DUMMY_MEMORY_ID);\\n        Memory current = new Memory(FREE_MEMORY_ID);\\n\\n        head.next = current;\\n        tail.previous = current;\\n\\n        current.memorySize = initialFreeMemorySize;\\n        current.previous = head;\\n        current.next = tail;\\n    }\\n\\n    public int allocate(int memorySize, int memoryID) {\\n        Memory current = head.next;\\n        int indexAllocation = 0;\\n\\n        while (current != tail) {\\n\\n            if (current.memoryID == FREE_MEMORY_ID) {\\n\\n                if (current.memorySize > memorySize) {\\n\\n                    Memory memoryBlock = new Memory(memoryID);\\n                    memoryBlock.memorySize = memorySize;\\n                    memoryBlock.next = current;\\n                    memoryBlock.previous = current.previous;\\n\\n                    current.memorySize -= memorySize;\\n                    current.previous.next = memoryBlock;\\n                    current.previous = memoryBlock;\\n                    return indexAllocation;\\n                }\\n                if (current.memorySize == memorySize) {\\n                    current.memoryID = memoryID;\\n                    return indexAllocation;\\n                }\\n            }\\n            indexAllocation += current.memorySize;\\n            current = current.next;\\n        }\\n        return NO_AVAILABLE_MEMORY_BLOCK;\\n    }\\n\\n    public int free(int memoryID) {\\n        Memory current = head.next;\\n        int totalFreedMemorySize = 0;\\n\\n        while (current != tail) {\\n\\n            if (current.memoryID == memoryID) {\\n                totalFreedMemorySize += current.memorySize;\\n                current.memoryID = FREE_MEMORY_ID;\\n\\n                if (current.previous.memoryID == FREE_MEMORY_ID && current.next.memoryID == FREE_MEMORY_ID) {\\n                    mergePreviousAndNextIntoCurrentMemoryBlock(current);\\n                } else if (current.previous.memoryID == FREE_MEMORY_ID) {\\n                    mergePreviousIntoCurrentMemoryBlock(current);\\n                } else if (current.next.memoryID == FREE_MEMORY_ID) {\\n                    mergeNextIntoCurrentMemoryBlock(current);\\n                }\\n            }\\n            current = current.next;\\n\\n        }\\n        return totalFreedMemorySize;\\n    }\\n\\n    private void mergePreviousAndNextIntoCurrentMemoryBlock(Memory current) {\\n        current.memorySize += current.previous.memorySize + current.next.memorySize;\\n        current.previous = current.previous.previous;\\n        current.next = current.next.next;\\n\\n        current.previous.next = current;\\n        current.next.previous = current;\\n    }\\n\\n    private void mergePreviousIntoCurrentMemoryBlock(Memory current) {\\n        current.memorySize += current.previous.memorySize;\\n        current.previous = current.previous.previous;\\n        current.previous.next = current;\\n    }\\n\\n    private void mergeNextIntoCurrentMemoryBlock(Memory current) {\\n        current.memorySize += current.next.memorySize;\\n        current.next = current.next.next;\\n        current.next.previous = current;\\n    }\\n}\\n\\nclass Memory {\\n\\n    int memoryID;\\n    int memorySize;\\n    Memory previous;\\n    Memory next;\\n\\n    Memory(int memoryID) {\\n        this.memoryID = memoryID;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nclass Allocator {\\n\\n    static NO_AVAILABLE_MEMORY_BLOCK = -1;\\n    static DUMMY_MEMORY_ID = -2;\\n    static FREE_MEMORY_ID = 0;\\n\\n    /**\\n     * @param {number} initialFreeMemorySize\\n     */\\n    constructor(initialFreeMemorySize) {\\n        //Dummy \\'head\\' and \\'tail\\' in order to avoid constant checking for \\'null\\' of \\'current.previous\\' and \\'current.next\\'\\n        this.head = new Memory(Allocator.DUMMY_MEMORY_ID);\\n        this.tail = new Memory(Allocator.DUMMY_MEMORY_ID);\\n        let current = new Memory(Allocator.FREE_MEMORY_ID);\\n\\n        this.head.next = current;\\n        this.tail.previous = current;\\n\\n        current.memorySize = initialFreeMemorySize;\\n        current.previous = this.head;\\n        current.next = this.tail;\\n    }\\n\\n    /** \\n     * @param {number} memorySize \\n     * @param {number} memoryID\\n     * @return {number}\\n     */\\n    allocate(memorySize, memoryID) {\\n        let current = this.head.next;\\n        let indexAllocation = 0;\\n\\n        while (current !== this.tail) {\\n\\n            if (current.memoryID === Allocator.FREE_MEMORY_ID) {\\n\\n                if (current.memorySize > memorySize) {\\n\\n                    let memoryBlock = new Memory(memoryID);\\n                    memoryBlock.memorySize = memorySize;\\n                    memoryBlock.next = current;\\n                    memoryBlock.previous = current.previous;\\n\\n                    current.memorySize -= memorySize;\\n                    current.previous.next = memoryBlock;\\n                    current.previous = memoryBlock;\\n                    return indexAllocation;\\n                }\\n                if (current.memorySize === memorySize) {\\n                    current.memoryID = memoryID;\\n                    return indexAllocation;\\n                }\\n            }\\n            indexAllocation += current.memorySize;\\n            current = current.next;\\n        }\\n        return Allocator.NO_AVAILABLE_MEMORY_BLOCK;\\n    }\\n\\n    /** \\n     * @param {number} memoryID\\n     * @return {number}\\n     */\\n    free(memoryID) {\\n        let current = this.head.next;\\n        let totalFreedMemorySize = 0;\\n\\n        while (current !== this.tail) {\\n\\n            if (current.memoryID === memoryID) {\\n                totalFreedMemorySize += current.memorySize;\\n                current.memoryID = Allocator.FREE_MEMORY_ID;\\n\\n                if (current.previous.memoryID === Allocator.FREE_MEMORY_ID && current.next.memoryID === Allocator.FREE_MEMORY_ID) {\\n                    this.mergePreviousAndNextIntoCurrentMemoryBlock(current);\\n                } else if (current.previous.memoryID === Allocator.FREE_MEMORY_ID) {\\n                    this.mergePreviousIntoCurrentMemoryBlock(current);\\n                } else if (current.next.memoryID === Allocator.FREE_MEMORY_ID) {\\n                    this.mergeNextIntoCurrentMemoryBlock(current);\\n                }\\n            }\\n            current = current.next;\\n        }\\n        return totalFreedMemorySize;\\n    }\\n\\n    /** \\n     * @param {Memory} current \\n     * @return {void}\\n     */\\n    mergePreviousAndNextIntoCurrentMemoryBlock(current) {\\n        current.memorySize += current.previous.memorySize + current.next.memorySize;\\n        current.previous = current.previous.previous;\\n        current.next = current.next.next;\\n\\n        current.previous.next = current;\\n        current.next.previous = current;\\n    }\\n\\n    /** \\n     * @param {Memory} current \\n     * @return {void}\\n     */\\n    mergePreviousIntoCurrentMemoryBlock(current) {\\n        current.memorySize += current.previous.memorySize;\\n        current.previous = current.previous.previous;\\n        current.previous.next = current;\\n    }\\n\\n    /** \\n     * @param {Memory} current \\n     * @return {void}\\n     */\\n    mergeNextIntoCurrentMemoryBlock(current) {\\n        current.memorySize += current.next.memorySize;\\n        current.next = current.next.next;\\n        current.next.previous = current;\\n    }\\n}\\n\\n\\nclass Memory {\\n\\n    /**\\n     * @param {number} memoryID\\n     */\\n    constructor(memoryID) {\\n        this.memoryID = memoryID;\\n        this.memorySize = 0;\\n        this.previous = null;\\n        this.next = null;\\n    }\\n}\\n```\\n**C++**\\n```\\n#include <memory>\\nusing namespace std;\\n\\nstruct Memory {\\n    int memoryID;\\n    int memorySize{};\\n    shared_ptr<Memory> previous;\\n    shared_ptr<Memory> next;\\n\\n    explicit Memory(int memoryID) : memoryID {memoryID}{}\\n};\\n\\nclass Allocator {\\n    \\n    inline static const int NO_AVAILABLE_MEMORY_BLOCK = -1;\\n    inline static const int DUMMY_MEMORY_ID = -2;\\n    inline static const int FREE_MEMORY_ID = 0;\\n\\n    //Dummy \\'head\\' and \\'tail\\' in order to avoid constant checking for \\'null\\' of \\'current.previous\\' and \\'current.next\\'\\n    shared_ptr<Memory> head;\\n    shared_ptr<Memory> tail;\\n\\npublic:\\n    explicit Allocator(int initialFreeMemorySize) {\\n        head = make_shared<Memory>(DUMMY_MEMORY_ID);\\n        tail = make_shared<Memory>(DUMMY_MEMORY_ID);\\n        shared_ptr<Memory> current{ make_shared<Memory>(FREE_MEMORY_ID)};\\n\\n        head->next = current;\\n        tail->previous = current;\\n\\n        current->memorySize = initialFreeMemorySize;\\n        current->previous = head;\\n        current->next = tail;\\n    }\\n\\n    int allocate(int memorySize, int memoryID) const {\\n        shared_ptr<Memory> current = head->next;\\n        int indexAllocation = 0;\\n\\n        while (current != tail) {\\n\\n            if (current->memoryID == FREE_MEMORY_ID) {\\n\\n                if (current->memorySize > memorySize) {\\n\\n                    shared_ptr<Memory> memoryBlock{ make_shared<Memory>(memoryID)};\\n                    memoryBlock->memorySize = memorySize;\\n                    memoryBlock->next = current;\\n                    memoryBlock->previous = current->previous;\\n\\n                    current->memorySize -= memorySize;\\n                    current->previous->next = memoryBlock;\\n                    current->previous = memoryBlock;\\n                    return indexAllocation;\\n                }\\n                if (current->memorySize == memorySize) {\\n                    current->memoryID = memoryID;\\n                    return indexAllocation;\\n                }\\n            }\\n            indexAllocation += current->memorySize;\\n            current = current->next;\\n        }\\n        return NO_AVAILABLE_MEMORY_BLOCK;\\n    }\\n\\n    int free(int memoryID) const {\\n        shared_ptr<Memory> current = head->next;\\n        int totalFreedMemorySize = 0;\\n\\n        while (current != tail) {\\n\\n            if (current->memoryID == memoryID) {\\n                totalFreedMemorySize += current->memorySize;\\n                current->memoryID = FREE_MEMORY_ID;\\n\\n                if (current->previous->memoryID == FREE_MEMORY_ID && current->next->memoryID == FREE_MEMORY_ID) {\\n                    mergePreviousAndNextIntoCurrentMemoryBlock(current);\\n                } else if (current->previous->memoryID == FREE_MEMORY_ID) {\\n                    mergePreviousIntoCurrentMemoryBlock(current);\\n                } else if (current->next->memoryID == FREE_MEMORY_ID) {\\n                    mergeNextIntoCurrentMemoryBlock(current);\\n                }\\n            }\\n            current = current->next;\\n        }\\n        return totalFreedMemorySize;\\n    }\\n\\nprivate:\\n    void mergePreviousAndNextIntoCurrentMemoryBlock(shared_ptr<Memory> current) const {\\n        current->memorySize += current->previous->memorySize + current->next->memorySize;\\n        current->previous = current->previous->previous;\\n        current->next = current->next->next;\\n\\n        current->previous->next = current;\\n        current->next->previous = current;\\n    }\\n\\n    void mergePreviousIntoCurrentMemoryBlock(shared_ptr<Memory> current) const {\\n        current->memorySize += current->previous->memorySize;\\n        current->previous = current->previous->previous;\\n        current->previous->next = current;\\n    }\\n\\n    void mergeNextIntoCurrentMemoryBlock(shared_ptr<Memory> current) const {\\n        current->memorySize += current->next->memorySize;\\n        current->next = current->next->next;\\n        current->next->previous = current;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\npublic class Allocator {\\n\\n    private static final int NO_AVAILABLE_MEMORY_BLOCK = -1;\\n    private static final int DUMMY_MEMORY_ID = -2;\\n    private static final int FREE_MEMORY_ID = 0;\\n\\n    //Dummy \\'head\\' and \\'tail\\' in order to avoid constant checking for \\'null\\' of \\'current.previous\\' and \\'current.next\\'\\n    Memory head;\\n    Memory tail;\\n\\n    public Allocator(int initialFreeMemorySize) {\\n        head = new Memory(DUMMY_MEMORY_ID);\\n        tail = new Memory(DUMMY_MEMORY_ID);\\n        Memory current = new Memory(FREE_MEMORY_ID);\\n\\n        head.next = current;\\n        tail.previous = current;\\n\\n        current.memorySize = initialFreeMemorySize;\\n        current.previous = head;\\n        current.next = tail;\\n    }\\n\\n    public int allocate(int memorySize, int memoryID) {\\n        Memory current = head.next;\\n        int indexAllocation = 0;\\n\\n        while (current != tail) {\\n\\n            if (current.memoryID == FREE_MEMORY_ID) {\\n\\n                if (current.memorySize > memorySize) {\\n\\n                    Memory memoryBlock = new Memory(memoryID);\\n                    memoryBlock.memorySize = memorySize;\\n                    memoryBlock.next = current;\\n                    memoryBlock.previous = current.previous;\\n\\n                    current.memorySize -= memorySize;\\n                    current.previous.next = memoryBlock;\\n                    current.previous = memoryBlock;\\n                    return indexAllocation;\\n                }\\n                if (current.memorySize == memorySize) {\\n                    current.memoryID = memoryID;\\n                    return indexAllocation;\\n                }\\n            }\\n            indexAllocation += current.memorySize;\\n            current = current.next;\\n        }\\n        return NO_AVAILABLE_MEMORY_BLOCK;\\n    }\\n\\n    public int free(int memoryID) {\\n        Memory current = head.next;\\n        int totalFreedMemorySize = 0;\\n\\n        while (current != tail) {\\n\\n            if (current.memoryID == memoryID) {\\n                totalFreedMemorySize += current.memorySize;\\n                current.memoryID = FREE_MEMORY_ID;\\n\\n                if (current.previous.memoryID == FREE_MEMORY_ID && current.next.memoryID == FREE_MEMORY_ID) {\\n                    mergePreviousAndNextIntoCurrentMemoryBlock(current);\\n                } else if (current.previous.memoryID == FREE_MEMORY_ID) {\\n                    mergePreviousIntoCurrentMemoryBlock(current);\\n                } else if (current.next.memoryID == FREE_MEMORY_ID) {\\n                    mergeNextIntoCurrentMemoryBlock(current);\\n                }\\n            }\\n            current = current.next;\\n\\n        }\\n        return totalFreedMemorySize;\\n    }\\n\\n    private void mergePreviousAndNextIntoCurrentMemoryBlock(Memory current) {\\n        current.memorySize += current.previous.memorySize + current.next.memorySize;\\n        current.previous = current.previous.previous;\\n        current.next = current.next.next;\\n\\n        current.previous.next = current;\\n        current.next.previous = current;\\n    }\\n\\n    private void mergePreviousIntoCurrentMemoryBlock(Memory current) {\\n        current.memorySize += current.previous.memorySize;\\n        current.previous = current.previous.previous;\\n        current.previous.next = current;\\n    }\\n\\n    private void mergeNextIntoCurrentMemoryBlock(Memory current) {\\n        current.memorySize += current.next.memorySize;\\n        current.next = current.next.next;\\n        current.next.previous = current;\\n    }\\n}\\n\\nclass Memory {\\n\\n    int memoryID;\\n    int memorySize;\\n    Memory previous;\\n    Memory next;\\n\\n    Memory(int memoryID) {\\n        this.memoryID = memoryID;\\n    }\\n}\\n```\n```\\nclass Allocator {\\n\\n    static NO_AVAILABLE_MEMORY_BLOCK = -1;\\n    static DUMMY_MEMORY_ID = -2;\\n    static FREE_MEMORY_ID = 0;\\n\\n    /**\\n     * @param {number} initialFreeMemorySize\\n     */\\n    constructor(initialFreeMemorySize) {\\n        //Dummy \\'head\\' and \\'tail\\' in order to avoid constant checking for \\'null\\' of \\'current.previous\\' and \\'current.next\\'\\n        this.head = new Memory(Allocator.DUMMY_MEMORY_ID);\\n        this.tail = new Memory(Allocator.DUMMY_MEMORY_ID);\\n        let current = new Memory(Allocator.FREE_MEMORY_ID);\\n\\n        this.head.next = current;\\n        this.tail.previous = current;\\n\\n        current.memorySize = initialFreeMemorySize;\\n        current.previous = this.head;\\n        current.next = this.tail;\\n    }\\n\\n    /** \\n     * @param {number} memorySize \\n     * @param {number} memoryID\\n     * @return {number}\\n     */\\n    allocate(memorySize, memoryID) {\\n        let current = this.head.next;\\n        let indexAllocation = 0;\\n\\n        while (current !== this.tail) {\\n\\n            if (current.memoryID === Allocator.FREE_MEMORY_ID) {\\n\\n                if (current.memorySize > memorySize) {\\n\\n                    let memoryBlock = new Memory(memoryID);\\n                    memoryBlock.memorySize = memorySize;\\n                    memoryBlock.next = current;\\n                    memoryBlock.previous = current.previous;\\n\\n                    current.memorySize -= memorySize;\\n                    current.previous.next = memoryBlock;\\n                    current.previous = memoryBlock;\\n                    return indexAllocation;\\n                }\\n                if (current.memorySize === memorySize) {\\n                    current.memoryID = memoryID;\\n                    return indexAllocation;\\n                }\\n            }\\n            indexAllocation += current.memorySize;\\n            current = current.next;\\n        }\\n        return Allocator.NO_AVAILABLE_MEMORY_BLOCK;\\n    }\\n\\n    /** \\n     * @param {number} memoryID\\n     * @return {number}\\n     */\\n    free(memoryID) {\\n        let current = this.head.next;\\n        let totalFreedMemorySize = 0;\\n\\n        while (current !== this.tail) {\\n\\n            if (current.memoryID === memoryID) {\\n                totalFreedMemorySize += current.memorySize;\\n                current.memoryID = Allocator.FREE_MEMORY_ID;\\n\\n                if (current.previous.memoryID === Allocator.FREE_MEMORY_ID && current.next.memoryID === Allocator.FREE_MEMORY_ID) {\\n                    this.mergePreviousAndNextIntoCurrentMemoryBlock(current);\\n                } else if (current.previous.memoryID === Allocator.FREE_MEMORY_ID) {\\n                    this.mergePreviousIntoCurrentMemoryBlock(current);\\n                } else if (current.next.memoryID === Allocator.FREE_MEMORY_ID) {\\n                    this.mergeNextIntoCurrentMemoryBlock(current);\\n                }\\n            }\\n            current = current.next;\\n        }\\n        return totalFreedMemorySize;\\n    }\\n\\n    /** \\n     * @param {Memory} current \\n     * @return {void}\\n     */\\n    mergePreviousAndNextIntoCurrentMemoryBlock(current) {\\n        current.memorySize += current.previous.memorySize + current.next.memorySize;\\n        current.previous = current.previous.previous;\\n        current.next = current.next.next;\\n\\n        current.previous.next = current;\\n        current.next.previous = current;\\n    }\\n\\n    /** \\n     * @param {Memory} current \\n     * @return {void}\\n     */\\n    mergePreviousIntoCurrentMemoryBlock(current) {\\n        current.memorySize += current.previous.memorySize;\\n        current.previous = current.previous.previous;\\n        current.previous.next = current;\\n    }\\n\\n    /** \\n     * @param {Memory} current \\n     * @return {void}\\n     */\\n    mergeNextIntoCurrentMemoryBlock(current) {\\n        current.memorySize += current.next.memorySize;\\n        current.next = current.next.next;\\n        current.next.previous = current;\\n    }\\n}\\n\\n\\nclass Memory {\\n\\n    /**\\n     * @param {number} memoryID\\n     */\\n    constructor(memoryID) {\\n        this.memoryID = memoryID;\\n        this.memorySize = 0;\\n        this.previous = null;\\n        this.next = null;\\n    }\\n}\\n```\n```\\n#include <memory>\\nusing namespace std;\\n\\nstruct Memory {\\n    int memoryID;\\n    int memorySize{};\\n    shared_ptr<Memory> previous;\\n    shared_ptr<Memory> next;\\n\\n    explicit Memory(int memoryID) : memoryID {memoryID}{}\\n};\\n\\nclass Allocator {\\n    \\n    inline static const int NO_AVAILABLE_MEMORY_BLOCK = -1;\\n    inline static const int DUMMY_MEMORY_ID = -2;\\n    inline static const int FREE_MEMORY_ID = 0;\\n\\n    //Dummy \\'head\\' and \\'tail\\' in order to avoid constant checking for \\'null\\' of \\'current.previous\\' and \\'current.next\\'\\n    shared_ptr<Memory> head;\\n    shared_ptr<Memory> tail;\\n\\npublic:\\n    explicit Allocator(int initialFreeMemorySize) {\\n        head = make_shared<Memory>(DUMMY_MEMORY_ID);\\n        tail = make_shared<Memory>(DUMMY_MEMORY_ID);\\n        shared_ptr<Memory> current{ make_shared<Memory>(FREE_MEMORY_ID)};\\n\\n        head->next = current;\\n        tail->previous = current;\\n\\n        current->memorySize = initialFreeMemorySize;\\n        current->previous = head;\\n        current->next = tail;\\n    }\\n\\n    int allocate(int memorySize, int memoryID) const {\\n        shared_ptr<Memory> current = head->next;\\n        int indexAllocation = 0;\\n\\n        while (current != tail) {\\n\\n            if (current->memoryID == FREE_MEMORY_ID) {\\n\\n                if (current->memorySize > memorySize) {\\n\\n                    shared_ptr<Memory> memoryBlock{ make_shared<Memory>(memoryID)};\\n                    memoryBlock->memorySize = memorySize;\\n                    memoryBlock->next = current;\\n                    memoryBlock->previous = current->previous;\\n\\n                    current->memorySize -= memorySize;\\n                    current->previous->next = memoryBlock;\\n                    current->previous = memoryBlock;\\n                    return indexAllocation;\\n                }\\n                if (current->memorySize == memorySize) {\\n                    current->memoryID = memoryID;\\n                    return indexAllocation;\\n                }\\n            }\\n            indexAllocation += current->memorySize;\\n            current = current->next;\\n        }\\n        return NO_AVAILABLE_MEMORY_BLOCK;\\n    }\\n\\n    int free(int memoryID) const {\\n        shared_ptr<Memory> current = head->next;\\n        int totalFreedMemorySize = 0;\\n\\n        while (current != tail) {\\n\\n            if (current->memoryID == memoryID) {\\n                totalFreedMemorySize += current->memorySize;\\n                current->memoryID = FREE_MEMORY_ID;\\n\\n                if (current->previous->memoryID == FREE_MEMORY_ID && current->next->memoryID == FREE_MEMORY_ID) {\\n                    mergePreviousAndNextIntoCurrentMemoryBlock(current);\\n                } else if (current->previous->memoryID == FREE_MEMORY_ID) {\\n                    mergePreviousIntoCurrentMemoryBlock(current);\\n                } else if (current->next->memoryID == FREE_MEMORY_ID) {\\n                    mergeNextIntoCurrentMemoryBlock(current);\\n                }\\n            }\\n            current = current->next;\\n        }\\n        return totalFreedMemorySize;\\n    }\\n\\nprivate:\\n    void mergePreviousAndNextIntoCurrentMemoryBlock(shared_ptr<Memory> current) const {\\n        current->memorySize += current->previous->memorySize + current->next->memorySize;\\n        current->previous = current->previous->previous;\\n        current->next = current->next->next;\\n\\n        current->previous->next = current;\\n        current->next->previous = current;\\n    }\\n\\n    void mergePreviousIntoCurrentMemoryBlock(shared_ptr<Memory> current) const {\\n        current->memorySize += current->previous->memorySize;\\n        current->previous = current->previous->previous;\\n        current->previous->next = current;\\n    }\\n\\n    void mergeNextIntoCurrentMemoryBlock(shared_ptr<Memory> current) const {\\n        current->memorySize += current->next->memorySize;\\n        current->next = current->next->next;\\n        current->next->previous = current;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3011032,
                "title": "python3-linkedlist-index-intervals",
                "content": "Use LinkedList and index intervals for fastest runtime.\\n\\n# Code\\n```\\n#from sortedcontainers import SortedList\\n\\nclass ListNodeMem( object):\\n    def __init__(   self,   mID = None, prev    =   None, next =   None):\\n        self.mID    =   mID\\n        self.prev   =   prev\\n        self.next   =   next\\n        self.start  =   self.end    =   0\\n        return\\n    \\n    def pop(    self):\\n        if self.prev:       self.prev.next  =   self.next\\n        if self.next:       self.next.prev  =   self.prev\\n        del self\\n        return\\n    \\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        # CONSTANTS\\n        self.EMPTY_VAL  =   None  \\n        self.INVALID_INDEX  =   -1\\n\\n        self.head   =   ListNodeMem(   mID =   \\'HEAD\\')\\n        self.tail   =   ListNodeMem(   mID =   \\'TAIL\\')\\n        firstEmpty  =   ListNodeMem(   mID =   self.EMPTY_VAL, prev = self.head, next = self.tail)\\n        self.head.next  =   self.tail.prev  =   firstEmpty\\n        firstEmpty.start    =   0\\n        firstEmpty.end      =   n-1        \\n\\n        self.mIDNodes   =   collections.defaultdict(    list)\\n        self.memorySize =   n\\n        return\\n        \\n    def allocate(self, size: int, mID: int) -> int:\\n        ptr =   self.head.next\\n        startBlockIndex =   -1\\n\\n        while ptr != self.tail:\\n            ptrSize =   ptr.end - ptr.start + 1\\n\\n            if  ptr.mID == self.EMPTY_VAL and ptrSize >= size:\\n                newAlloc    =   ListNodeMem(   mID =   mID)   #[mID, ptrStart, ptrStart+size-1])\\n                newAlloc.start  =   ptr.start\\n                newAlloc.end    =   ptr.start + size -1\\n                newAlloc.prev   =   ptr.prev\\n                self.mIDNodes[mID].append(   newAlloc)\\n                ptr.prev.next   =   newAlloc\\n\\n                if ptrSize == size:\\n                    newAlloc.next   =   ptr.next\\n                    ptr.next.prev   =   newAlloc\\n                    del ptr\\n\\n                else:\\n                    newAlloc.next   =   ptr\\n                    ptr.prev    =   newAlloc\\n                    ptr.start   =   ptr.start + size\\n                return newAlloc.start\\n\\n            ptr =   ptr.next\\n        return self.INVALID_INDEX   #returns -1 if can\\'t allocate.\\n\\n    def free(self, mID: int) -> int:\\n        totalFreedSize  =   0\\n        \\n        while self.mIDNodes[mID]:\\n            currNode    =   self.mIDNodes[mID].pop()\\n            totalFreedSize  +=  currNode.end - currNode.start + 1\\n            emptyStart, emptyEnd    =   currNode.start, currNode.end\\n\\n            #if prev node is Free/Empty, merge it with currNode.\\n            if currNode.prev != self.head and currNode.prev.mID == self.EMPTY_VAL:\\n                emptyStart  =   currNode.prev.start                \\n                currNode.prev.pop()\\n            \\n            #if next node is Free/Empty, merge it with currNode.\\n            if currNode.next != self.tail and currNode.next.mID == self.EMPTY_VAL:\\n                emptyEnd    =   currNode.next.end\\n                currNode.next.pop()\\n            \\n            #mark Free/Empty val in interval [EmptyStart, EmptyEnd]\\n            currNode.mID, currNode.start, currNode.end  =   self.EMPTY_VAL, emptyStart, emptyEnd\\n        return totalFreedSize\\n\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3",
                    "Doubly-Linked List"
                ],
                "code": "```\\n#from sortedcontainers import SortedList\\n\\nclass ListNodeMem( object):\\n    def __init__(   self,   mID = None, prev    =   None, next =   None):\\n        self.mID    =   mID\\n        self.prev   =   prev\\n        self.next   =   next\\n        self.start  =   self.end    =   0\\n        return\\n    \\n    def pop(    self):\\n        if self.prev:       self.prev.next  =   self.next\\n        if self.next:       self.next.prev  =   self.prev\\n        del self\\n        return\\n    \\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        # CONSTANTS\\n        self.EMPTY_VAL  =   None  \\n        self.INVALID_INDEX  =   -1\\n\\n        self.head   =   ListNodeMem(   mID =   \\'HEAD\\')\\n        self.tail   =   ListNodeMem(   mID =   \\'TAIL\\')\\n        firstEmpty  =   ListNodeMem(   mID =   self.EMPTY_VAL, prev = self.head, next = self.tail)\\n        self.head.next  =   self.tail.prev  =   firstEmpty\\n        firstEmpty.start    =   0\\n        firstEmpty.end      =   n-1        \\n\\n        self.mIDNodes   =   collections.defaultdict(    list)\\n        self.memorySize =   n\\n        return\\n        \\n    def allocate(self, size: int, mID: int) -> int:\\n        ptr =   self.head.next\\n        startBlockIndex =   -1\\n\\n        while ptr != self.tail:\\n            ptrSize =   ptr.end - ptr.start + 1\\n\\n            if  ptr.mID == self.EMPTY_VAL and ptrSize >= size:\\n                newAlloc    =   ListNodeMem(   mID =   mID)   #[mID, ptrStart, ptrStart+size-1])\\n                newAlloc.start  =   ptr.start\\n                newAlloc.end    =   ptr.start + size -1\\n                newAlloc.prev   =   ptr.prev\\n                self.mIDNodes[mID].append(   newAlloc)\\n                ptr.prev.next   =   newAlloc\\n\\n                if ptrSize == size:\\n                    newAlloc.next   =   ptr.next\\n                    ptr.next.prev   =   newAlloc\\n                    del ptr\\n\\n                else:\\n                    newAlloc.next   =   ptr\\n                    ptr.prev    =   newAlloc\\n                    ptr.start   =   ptr.start + size\\n                return newAlloc.start\\n\\n            ptr =   ptr.next\\n        return self.INVALID_INDEX   #returns -1 if can\\'t allocate.\\n\\n    def free(self, mID: int) -> int:\\n        totalFreedSize  =   0\\n        \\n        while self.mIDNodes[mID]:\\n            currNode    =   self.mIDNodes[mID].pop()\\n            totalFreedSize  +=  currNode.end - currNode.start + 1\\n            emptyStart, emptyEnd    =   currNode.start, currNode.end\\n\\n            #if prev node is Free/Empty, merge it with currNode.\\n            if currNode.prev != self.head and currNode.prev.mID == self.EMPTY_VAL:\\n                emptyStart  =   currNode.prev.start                \\n                currNode.prev.pop()\\n            \\n            #if next node is Free/Empty, merge it with currNode.\\n            if currNode.next != self.tail and currNode.next.mID == self.EMPTY_VAL:\\n                emptyEnd    =   currNode.next.end\\n                currNode.next.pop()\\n            \\n            #mark Free/Empty val in interval [EmptyStart, EmptyEnd]\\n            currNode.mID, currNode.start, currNode.end  =   self.EMPTY_VAL, emptyStart, emptyEnd\\n        return totalFreedSize\\n\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979944,
                "title": "python-disjoint-interval",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Allocator:\\n    \"\"\"\\n        . we need easy way to find first free block of size sz\\n    \"\"\"\\n    \\n    \\n    def __init__(self, n: int):\\n        self.n = n\\n        self.s = SortedList()\\n        self.book = defaultdict(list) # mID : [indexs]\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        \\n        if size > self.n:\\n            return -1\\n        \\n        if not self.s:\\n            # insert at start\\n            _range = (0, size)\\n            self.s.add(_range)\\n            self.book[mID].append(_range)\\n            return 0\\n        \\n        prev = 0\\n        for i in range(len(self.s)):\\n            if self.s[i][0] - prev >= size:\\n                # got space\\n                self.s.add((prev, prev + size))\\n                self.book[mID].append((prev, prev + size))\\n                return prev\\n            else:\\n                prev = self.s[i][1]\\n        \\n        # reached end\\n        if self.n - prev >= size:\\n            self.book[mID].append((prev, prev + size))\\n            self.s.add((prev, prev + size))\\n            return prev\\n        \\n        return -1\\n        \\n\\n    def free(self, mID: int) -> int:\\n       \\n        c = 0\\n        for ran in self.book[mID]:\\n            c += ran[1] - ran[0]\\n            self.s.remove(ran)\\n        \\n        self.book[mID] = []\\n        return c\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Allocator:\\n    \"\"\"\\n        . we need easy way to find first free block of size sz\\n    \"\"\"\\n    \\n    \\n    def __init__(self, n: int):\\n        self.n = n\\n        self.s = SortedList()\\n        self.book = defaultdict(list) # mID : [indexs]\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        \\n        if size > self.n:\\n            return -1\\n        \\n        if not self.s:\\n            # insert at start\\n            _range = (0, size)\\n            self.s.add(_range)\\n            self.book[mID].append(_range)\\n            return 0\\n        \\n        prev = 0\\n        for i in range(len(self.s)):\\n            if self.s[i][0] - prev >= size:\\n                # got space\\n                self.s.add((prev, prev + size))\\n                self.book[mID].append((prev, prev + size))\\n                return prev\\n            else:\\n                prev = self.s[i][1]\\n        \\n        # reached end\\n        if self.n - prev >= size:\\n            self.book[mID].append((prev, prev + size))\\n            self.s.add((prev, prev + size))\\n            return prev\\n        \\n        return -1\\n        \\n\\n    def free(self, mID: int) -> int:\\n       \\n        c = 0\\n        for ran in self.book[mID]:\\n            c += ran[1] - ran[0]\\n            self.s.remove(ran)\\n        \\n        self.book[mID] = []\\n        return c\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976689,
                "title": "easy-c-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator {\\n    map<int, int> omem;\\n    unordered_map<int, vector<int>> valmap;\\n    int n;\\npublic:\\n    Allocator(int n) {\\n        this->n = n;\\n        omem[n] = 1;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int ind = 0;\\n        \\n        while(ind < n) {\\n            auto it = omem.lower_bound(ind);\\n            int nind = it->first, nsize = it->second;\\n\\n            if(nind - ind >= size and !omem.count(ind)) {\\n                omem[ind] = size;\\n                valmap[mID].push_back(ind);\\n                break;\\n            }\\n            \\n            else\\n                ind = nind + nsize;\\n        }\\n        \\n        return ind >= n ? -1 : ind;\\n    }\\n    \\n    int free(int mID) {\\n        int ans = 0;\\n        \\n        for(int ind : valmap[mID]) {\\n            ans += omem[ind];\\n            omem.erase(ind);\\n        }\\n        \\n        valmap.erase(mID);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Allocator {\\n    map<int, int> omem;\\n    unordered_map<int, vector<int>> valmap;\\n    int n;\\npublic:\\n    Allocator(int n) {\\n        this->n = n;\\n        omem[n] = 1;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int ind = 0;\\n        \\n        while(ind < n) {\\n            auto it = omem.lower_bound(ind);\\n            int nind = it->first, nsize = it->second;\\n\\n            if(nind - ind >= size and !omem.count(ind)) {\\n                omem[ind] = size;\\n                valmap[mID].push_back(ind);\\n                break;\\n            }\\n            \\n            else\\n                ind = nind + nsize;\\n        }\\n        \\n        return ind >= n ? -1 : ind;\\n    }\\n    \\n    int free(int mID) {\\n        int ans = 0;\\n        \\n        for(int ind : valmap[mID]) {\\n            ans += omem[ind];\\n            omem.erase(ind);\\n        }\\n        \\n        valmap.erase(mID);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975611,
                "title": "c-modelling",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can model `memory` with a help of array and then apply greedy approach (allocate as early as possible)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ngreedy approach with sliding window\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ (worst case) for each `Allocate` or `Free` call\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Allocator {\\n    int[] memory;\\n\\n    public Allocator(int n) {\\n        memory = new int[n];    \\n    }\\n    \\n    public int Allocate(int size, int mID) {\\n        for (int i = 0, current = 0; i < memory.Length; ++i) \\n            if (memory[i] == 0) {\\n                if (++current == size) {\\n                    for (int j = 0; j < size; ++j)\\n                        memory[i - size + j + 1] = mID;\\n\\n                    return i - size + 1;\\n                }\\n            }\\n            else\\n                current = 0;\\n\\n        return -1;\\n    }\\n    \\n    public int Free(int mID) {\\n        int result = 0;\\n\\n        for (int i = memory.Length - 1; i >= 0; --i) \\n            if (memory[i] == mID) {\\n                memory[i] = 0;\\n\\n                ++result;\\n            }    \\n\\n        return result;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.Allocate(size,mID);\\n * int param_2 = obj.Free(mID);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Allocator {\\n    int[] memory;\\n\\n    public Allocator(int n) {\\n        memory = new int[n];    \\n    }\\n    \\n    public int Allocate(int size, int mID) {\\n        for (int i = 0, current = 0; i < memory.Length; ++i) \\n            if (memory[i] == 0) {\\n                if (++current == size) {\\n                    for (int j = 0; j < size; ++j)\\n                        memory[i - size + j + 1] = mID;\\n\\n                    return i - size + 1;\\n                }\\n            }\\n            else\\n                current = 0;\\n\\n        return -1;\\n    }\\n    \\n    public int Free(int mID) {\\n        int result = 0;\\n\\n        for (int i = memory.Length - 1; i >= 0; --i) \\n            if (memory[i] == mID) {\\n                memory[i] = 0;\\n\\n                ++result;\\n            }    \\n\\n        return result;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.Allocate(size,mID);\\n * int param_2 = obj.Free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975610,
                "title": "c-modelling",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can model `memory` with a help of array and then apply greedy approach (allocate as early as possible)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ngreedy approach with sliding window\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ (worst case) for each `Allocate` or `Free` call\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Allocator {\\n    int[] memory;\\n\\n    public Allocator(int n) {\\n        memory = new int[n];    \\n    }\\n    \\n    public int Allocate(int size, int mID) {\\n        for (int i = 0, current = 0; i < memory.Length; ++i) \\n            if (memory[i] == 0) {\\n                if (++current == size) {\\n                    for (int j = 0; j < size; ++j)\\n                        memory[i - size + j + 1] = mID;\\n\\n                    return i - size + 1;\\n                }\\n            }\\n            else\\n                current = 0;\\n\\n        return -1;\\n    }\\n    \\n    public int Free(int mID) {\\n        int result = 0;\\n\\n        for (int i = memory.Length - 1; i >= 0; --i) \\n            if (memory[i] == mID) {\\n                memory[i] = 0;\\n\\n                ++result;\\n            }    \\n\\n        return result;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.Allocate(size,mID);\\n * int param_2 = obj.Free(mID);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Allocator {\\n    int[] memory;\\n\\n    public Allocator(int n) {\\n        memory = new int[n];    \\n    }\\n    \\n    public int Allocate(int size, int mID) {\\n        for (int i = 0, current = 0; i < memory.Length; ++i) \\n            if (memory[i] == 0) {\\n                if (++current == size) {\\n                    for (int j = 0; j < size; ++j)\\n                        memory[i - size + j + 1] = mID;\\n\\n                    return i - size + 1;\\n                }\\n            }\\n            else\\n                current = 0;\\n\\n        return -1;\\n    }\\n    \\n    public int Free(int mID) {\\n        int result = 0;\\n\\n        for (int i = memory.Length - 1; i >= 0; --i) \\n            if (memory[i] == mID) {\\n                memory[i] = 0;\\n\\n                ++result;\\n            }    \\n\\n        return result;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.Allocate(size,mID);\\n * int param_2 = obj.Free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971762,
                "title": "use-array-and-hash-map-of-mid-and-set-of-idxs-beats-65",
                "content": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        \"\"\"\\n        we will maintain an array to find the next available slot\\n        and we will maintain a hash map with key as mID and value as\\n        a set of indexes of the array assigned to that mID. Using this, \\n        we can resolve the free call in O(1) time\\n        allocate will be resolved in O(n) time\\n        \"\"\"\\n        self.array = [0 for _ in range(n)]\\n        self.hash_map = {}\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        rem = size\\n        start = 0\\n        for i in range(len(self.array)):\\n            if not rem:\\n                break\\n            if self.array[i] == 0:\\n                rem-=1\\n            else:\\n                rem = size\\n                start = i+1\\n                \\n        if not rem:\\n            for j in range(start, start+size):\\n                self.array[j] = mID\\n                if mID not in self.hash_map:\\n                    self.hash_map[mID] = {j}\\n                else:\\n                    self.hash_map[mID].add(j)\\n            return start\\n        return -1\\n        \\n    def free(self, mID: int) -> int:\\n        if mID not in self.hash_map:\\n            return 0\\n        for idx in self.hash_map[mID]:\\n            self.array[idx] = 0\\n        size = len(self.hash_map[mID])\\n        del self.hash_map[mID]\\n        return size\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        \"\"\"\\n        we will maintain an array to find the next available slot\\n        and we will maintain a hash map with key as mID and value as\\n        a set of indexes of the array assigned to that mID. Using this, \\n        we can resolve the free call in O(1) time\\n        allocate will be resolved in O(n) time\\n        \"\"\"\\n        self.array = [0 for _ in range(n)]\\n        self.hash_map = {}\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        rem = size\\n        start = 0\\n        for i in range(len(self.array)):\\n            if not rem:\\n                break\\n            if self.array[i] == 0:\\n                rem-=1\\n            else:\\n                rem = size\\n                start = i+1\\n                \\n        if not rem:\\n            for j in range(start, start+size):\\n                self.array[j] = mID\\n                if mID not in self.hash_map:\\n                    self.hash_map[mID] = {j}\\n                else:\\n                    self.hash_map[mID].add(j)\\n            return start\\n        return -1\\n        \\n    def free(self, mID: int) -> int:\\n        if mID not in self.hash_map:\\n            return 0\\n        for idx in self.hash_map[mID]:\\n            self.array[idx] = 0\\n        size = len(self.hash_map[mID])\\n        del self.hash_map[mID]\\n        return size\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971066,
                "title": "design-memory-allocator-faster-than-99-space-complexity-better-than-99",
                "content": "\\n\\n# Code\\n```\\nclass Allocator {\\n\\n    int[] memory;\\n    HashMap<Integer,Integer> mids = new HashMap<>();\\n    \\n    int totalAvailableSize;\\n    \\n    public Allocator(int n) {\\n        memory = new int[n];\\n        totalAvailableSize = n;\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        \\n        if(totalAvailableSize<size)\\n            return -1;\\n\\n           \\n        \\n        int idx = -1;\\n        \\n        boolean isAllocationPossible = true;\\n        \\n        for(int i=0;i<memory.length;i++){\\n            \\n            if(i+size-1>=memory.length)\\n                return -1;\\n              \\n            \\n            isAllocationPossible = true;\\n            \\n            if(memory[i]==0){\\n                for(int j=i;j<i+size && i+size-1<memory.length;j++){\\n                    if(memory[j]!=0){\\n                        isAllocationPossible = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(isAllocationPossible){\\n                    idx = i;\\n                    break;\\n                }\\n                        \\n            }\\n \\n        }\\n        \\n        if(!isAllocationPossible)\\n            return -1;\\n            \\n        \\n        for(int i=idx;i<idx+size;i++)\\n            memory[i] = mID;\\n        \\n        \\n        totalAvailableSize -=size;\\n\\n        mids.put(mID,mids.getOrDefault(mID,0)+size);\\n        \\n        return idx;\\n   \\n    }\\n    \\n    public int free(int mID) {\\n        if(!mids.containsKey(mID))\\n            return 0;\\n     \\n        for(int i=0;i<memory.length;i++){\\n            if(memory[i]==mID)\\n                memory[i] = 0;\\n        }\\n        \\n        totalAvailableSize+=mids.get(mID);\\n        return mids.remove(mID);\\n        \\n        \\n    }\\n    \\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Allocator {\\n\\n    int[] memory;\\n    HashMap<Integer,Integer> mids = new HashMap<>();\\n    \\n    int totalAvailableSize;\\n    \\n    public Allocator(int n) {\\n        memory = new int[n];\\n        totalAvailableSize = n;\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        \\n        if(totalAvailableSize<size)\\n            return -1;\\n\\n           \\n        \\n        int idx = -1;\\n        \\n        boolean isAllocationPossible = true;\\n        \\n        for(int i=0;i<memory.length;i++){\\n            \\n            if(i+size-1>=memory.length)\\n                return -1;\\n              \\n            \\n            isAllocationPossible = true;\\n            \\n            if(memory[i]==0){\\n                for(int j=i;j<i+size && i+size-1<memory.length;j++){\\n                    if(memory[j]!=0){\\n                        isAllocationPossible = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(isAllocationPossible){\\n                    idx = i;\\n                    break;\\n                }\\n                        \\n            }\\n \\n        }\\n        \\n        if(!isAllocationPossible)\\n            return -1;\\n            \\n        \\n        for(int i=idx;i<idx+size;i++)\\n            memory[i] = mID;\\n        \\n        \\n        totalAvailableSize -=size;\\n\\n        mids.put(mID,mids.getOrDefault(mID,0)+size);\\n        \\n        return idx;\\n   \\n    }\\n    \\n    public int free(int mID) {\\n        if(!mids.containsKey(mID))\\n            return 0;\\n     \\n        for(int i=0;i<memory.length;i++){\\n            if(memory[i]==mID)\\n                memory[i] = 0;\\n        }\\n        \\n        totalAvailableSize+=mids.get(mID);\\n        return mids.remove(mID);\\n        \\n        \\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970269,
                "title": "clean-code-must-see-easy-to-understand",
                "content": "# Code\\n```\\nclass Allocator {\\npublic:\\n    //making the vector to reserve the block using the mID\\n    vector<int>v;\\n    //unordered_map to find the location of the leftmost block when free is called\\n    unordered_map<int,vector<int>>mp;\\n    Allocator(int n) {\\n        //we will first make the array or vetor of the given size\\n        v.resize(n,-1);  //-1 indicating that all the slots are initially free\\n    }\\n    \\n    int allocate(int size, int mID) \\n    {\\n         int startidx = -1;\\n         int counter = 0;\\n\\n         int idx = 0;\\n         while(idx < v.size())\\n         {\\n              if(v[idx] == -1)\\n              {\\n                  if(startidx == -1)\\n                  startidx = idx;\\n\\n                  counter++;\\n              }\\n              else if((v[idx] != -1) and (counter < size))\\n              {\\n                  startidx = -1;\\n                  counter = 0;    \\n              }\\n              if(counter >= size)\\n              {\\n                  break;\\n              }\\n              idx++;\\n         }    \\n         if(counter >= size)\\n         {\\n             int idx = startidx;\\n             int tempsize = size;\\n             while((tempsize > 0) and (idx < v.size()))\\n             {\\n                 v[idx] = mID;\\n                 tempsize--;\\n                 idx++;\\n             }\\n             //storing the leftmost block position for this reservation\\n             mp[mID].push_back(startidx);\\n             return startidx;\\n         }\\n         return -1;\\n    }\\n    \\n    int free(int mID) \\n    {\\n        if(mp.find(mID) == mp.end())\\n        return 0;\\n\\n        int count = 0;\\n        for(auto firstpos : mp[mID])\\n        {\\n            int idx = firstpos;\\n            while(idx < v.size() and v[idx] == mID)\\n            {\\n                 count++;\\n                 v[idx]=-1; //making it as free\\n                 idx++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Simulation"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    //making the vector to reserve the block using the mID\\n    vector<int>v;\\n    //unordered_map to find the location of the leftmost block when free is called\\n    unordered_map<int,vector<int>>mp;\\n    Allocator(int n) {\\n        //we will first make the array or vetor of the given size\\n        v.resize(n,-1);  //-1 indicating that all the slots are initially free\\n    }\\n    \\n    int allocate(int size, int mID) \\n    {\\n         int startidx = -1;\\n         int counter = 0;\\n\\n         int idx = 0;\\n         while(idx < v.size())\\n         {\\n              if(v[idx] == -1)\\n              {\\n                  if(startidx == -1)\\n                  startidx = idx;\\n\\n                  counter++;\\n              }\\n              else if((v[idx] != -1) and (counter < size))\\n              {\\n                  startidx = -1;\\n                  counter = 0;    \\n              }\\n              if(counter >= size)\\n              {\\n                  break;\\n              }\\n              idx++;\\n         }    \\n         if(counter >= size)\\n         {\\n             int idx = startidx;\\n             int tempsize = size;\\n             while((tempsize > 0) and (idx < v.size()))\\n             {\\n                 v[idx] = mID;\\n                 tempsize--;\\n                 idx++;\\n             }\\n             //storing the leftmost block position for this reservation\\n             mp[mID].push_back(startidx);\\n             return startidx;\\n         }\\n         return -1;\\n    }\\n    \\n    int free(int mID) \\n    {\\n        if(mp.find(mID) == mp.end())\\n        return 0;\\n\\n        int count = 0;\\n        for(auto firstpos : mp[mID])\\n        {\\n            int idx = firstpos;\\n            while(idx < v.size() and v[idx] == mID)\\n            {\\n                 count++;\\n                 v[idx]=-1; //making it as free\\n                 idx++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968800,
                "title": "c-vector-and-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    std::vector<int>v;\\n    Allocator(int n) {\\n        int newSize=v.size()+n;\\n        v.resize(newSize, -1);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n\\n        int allocateSize=size;\\n        int startingPointer = 0, endingPointer = 0, n=v.size();\\n        while(startingPointer<n && endingPointer<n)\\n        {\\n            while(endingPointer<n && v[endingPointer]==-1 && size>0) endingPointer++, size--;\\n            if(size==0) break;\\n            else \\n            {\\n                size=allocateSize;\\n                startingPointer = endingPointer + 1;\\n                endingPointer = startingPointer;\\n            }\\n        }\\n        if(size!=0) return -1;\\n        for(int i = startingPointer; i<startingPointer+allocateSize; i++) v[i]=mID;\\n        return startingPointer;\\n    }\\n    \\n    int free(int mID) {\\n        int freedMIDs=0;\\n        for(int i=0;i<v.size();i++) if(v[i]==mID) \\n        {\\n            v[i]=-1;\\n            freedMIDs++;\\n        }\\n        return freedMIDs;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    std::vector<int>v;\\n    Allocator(int n) {\\n        int newSize=v.size()+n;\\n        v.resize(newSize, -1);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n\\n        int allocateSize=size;\\n        int startingPointer = 0, endingPointer = 0, n=v.size();\\n        while(startingPointer<n && endingPointer<n)\\n        {\\n            while(endingPointer<n && v[endingPointer]==-1 && size>0) endingPointer++, size--;\\n            if(size==0) break;\\n            else \\n            {\\n                size=allocateSize;\\n                startingPointer = endingPointer + 1;\\n                endingPointer = startingPointer;\\n            }\\n        }\\n        if(size!=0) return -1;\\n        for(int i = startingPointer; i<startingPointer+allocateSize; i++) v[i]=mID;\\n        return startingPointer;\\n    }\\n    \\n    int free(int mID) {\\n        int freedMIDs=0;\\n        for(int i=0;i<v.size();i++) if(v[i]==mID) \\n        {\\n            v[i]=-1;\\n            freedMIDs++;\\n        }\\n        return freedMIDs;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964368,
                "title": "python-using-intervals-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-Brute force solution would be to maintain an array of size n, where each element is either 0 (i.e. free space) or mID (i.e. space is occupied by mID). Then to allocate a given space, we iterate thru the entire array until we find a contiguous blocks of 0\\'s of length \"size\". \\n\\n-However, note that it would genereally be more efficient, compared to using an array, to simply maintain the start & end of intervals instead. \\n\\n-Because of the requirement to find the left-most contiguous block of length size, we also need some way of identifying the left most free space. A min-heap consisting of the start-idx of each interval comes in handy here. \\n\\n-To simplify things, we also write a function to \"stitch\" together contiguous intervals into one.\\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n--\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(number of queries * log-n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(#of intervals)\\n# Code\\n```\\nfrom heapq import heappush, heappop\\n\\n\"\"\"\\napproach: \\n    -maintain: free_s_to_e & free_e_to_s hashmap\\n    -maintain: a heap consisting of free_s.\\n    -maintain: a hashmap (mID -> list(list)) consisting of intervals allocated to mID.\\n\\n    -create a stitch function that will stitch appropriate two free intervals into one (i.e. (1, 3), (4, 5) -> we stitch into (1,5))\\n\"\"\"\\n\\nclass Allocator:\\n    def __init__(self, n: int):\\n        self.free_s_to_e = {0: n-1}\\n        self.free_e_to_s = {n-1: 0}\\n\\n        self.free_s_heap = [0]\\n\\n        self.mID_to_loc = defaultdict(list)\\n    \\n    def _can_stitch(self, s, e):\\n        if s - 1 in self.free_e_to_s:\\n            return True\\n        \\n        if e + 1 in self.free_s_to_e:\\n            return True\\n        \\n        return False\\n\\n    def _stitch(self, s, e):\\n        if s - 1 in self.free_e_to_s:\\n            new_s = self.free_e_to_s[s-1]\\n            new_e = e\\n\\n            del self.free_e_to_s[s-1]\\n            self.free_e_to_s[new_e] = new_s\\n            self.free_s_to_e[new_s] = new_e\\n\\n            #update to check for next conditional statement\\n            s = new_s\\n            e = new_e\\n        \\n        if e + 1 in self.free_s_to_e:\\n            new_s = s\\n            new_e = self.free_s_to_e[e+1]\\n\\n            if new_s not in self.free_s_to_e:\\n                heappush(self.free_s_heap, new_s)\\n\\n            del self.free_s_to_e[e + 1]\\n            self.free_s_to_e[new_s] = new_e\\n            self.free_e_to_s[new_e] = new_s\\n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        checked = []\\n        first_idx = -1\\n\\n        while self.free_s_heap: \\n            s = heappop(self.free_s_heap)\\n            if s not in self.free_s_to_e:\\n                continue\\n            \\n            e = self.free_s_to_e[s]\\n            if e - s + 1 >= size:\\n                taken_s = s\\n                taken_e = s + size - 1\\n                self.mID_to_loc[mID].append([taken_s, taken_e])\\n\\n                if e - s + 1 == size:\\n                    del self.free_s_to_e[s]\\n                    del self.free_e_to_s[e]\\n                \\n                else:\\n                    del self.free_s_to_e[s]\\n\\n                    self.free_s_to_e[taken_e + 1] = e\\n                    self.free_e_to_s[e] = taken_e + 1\\n\\n                    heappush(self.free_s_heap, taken_e + 1)\\n                \\n                first_idx = taken_s\\n                break\\n            \\n            checked.append(s)\\n        \\n        for _s in checked:\\n            heappush(self.free_s_heap, _s)\\n        \\n        return first_idx\\n        \\n\\n    def free(self, mID): \\n        size_freed = 0\\n        for s, e in self.mID_to_loc[mID]:\\n            size_freed += e - s + 1\\n            \\n            if self._can_stitch(s, e): \\n                self._stitch(s, e)\\n                continue\\n            \\n            self.free_s_to_e[s] = e\\n            self.free_e_to_s[e] = s\\n            heappush(self.free_s_heap, s)\\n        \\n        del self.mID_to_loc[mID]\\n\\n        return size_freed\\n\\n\\n\\n       \\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\n\\n\"\"\"\\napproach: \\n    -maintain: free_s_to_e & free_e_to_s hashmap\\n    -maintain: a heap consisting of free_s.\\n    -maintain: a hashmap (mID -> list(list)) consisting of intervals allocated to mID.\\n\\n    -create a stitch function that will stitch appropriate two free intervals into one (i.e. (1, 3), (4, 5) -> we stitch into (1,5))\\n\"\"\"\\n\\nclass Allocator:\\n    def __init__(self, n: int):\\n        self.free_s_to_e = {0: n-1}\\n        self.free_e_to_s = {n-1: 0}\\n\\n        self.free_s_heap = [0]\\n\\n        self.mID_to_loc = defaultdict(list)\\n    \\n    def _can_stitch(self, s, e):\\n        if s - 1 in self.free_e_to_s:\\n            return True\\n        \\n        if e + 1 in self.free_s_to_e:\\n            return True\\n        \\n        return False\\n\\n    def _stitch(self, s, e):\\n        if s - 1 in self.free_e_to_s:\\n            new_s = self.free_e_to_s[s-1]\\n            new_e = e\\n\\n            del self.free_e_to_s[s-1]\\n            self.free_e_to_s[new_e] = new_s\\n            self.free_s_to_e[new_s] = new_e\\n\\n            #update to check for next conditional statement\\n            s = new_s\\n            e = new_e\\n        \\n        if e + 1 in self.free_s_to_e:\\n            new_s = s\\n            new_e = self.free_s_to_e[e+1]\\n\\n            if new_s not in self.free_s_to_e:\\n                heappush(self.free_s_heap, new_s)\\n\\n            del self.free_s_to_e[e + 1]\\n            self.free_s_to_e[new_s] = new_e\\n            self.free_e_to_s[new_e] = new_s\\n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        checked = []\\n        first_idx = -1\\n\\n        while self.free_s_heap: \\n            s = heappop(self.free_s_heap)\\n            if s not in self.free_s_to_e:\\n                continue\\n            \\n            e = self.free_s_to_e[s]\\n            if e - s + 1 >= size:\\n                taken_s = s\\n                taken_e = s + size - 1\\n                self.mID_to_loc[mID].append([taken_s, taken_e])\\n\\n                if e - s + 1 == size:\\n                    del self.free_s_to_e[s]\\n                    del self.free_e_to_s[e]\\n                \\n                else:\\n                    del self.free_s_to_e[s]\\n\\n                    self.free_s_to_e[taken_e + 1] = e\\n                    self.free_e_to_s[e] = taken_e + 1\\n\\n                    heappush(self.free_s_heap, taken_e + 1)\\n                \\n                first_idx = taken_s\\n                break\\n            \\n            checked.append(s)\\n        \\n        for _s in checked:\\n            heappush(self.free_s_heap, _s)\\n        \\n        return first_idx\\n        \\n\\n    def free(self, mID): \\n        size_freed = 0\\n        for s, e in self.mID_to_loc[mID]:\\n            size_freed += e - s + 1\\n            \\n            if self._can_stitch(s, e): \\n                self._stitch(s, e)\\n                continue\\n            \\n            self.free_s_to_e[s] = e\\n            self.free_e_to_s[e] = s\\n            heappush(self.free_s_heap, s)\\n        \\n        del self.mID_to_loc[mID]\\n\\n        return size_freed\\n\\n\\n\\n       \\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963578,
                "title": "golang-array",
                "content": "# Code\\n```\\ntype Allocator struct {\\n    memory []int\\n}\\n\\n\\nfunc Constructor(n int) Allocator {\\n    return Allocator {\\n        memory: make([]int, n),\\n    }\\n}\\n\\n\\nfunc (this *Allocator) Allocate(size int, mID int) int {\\n    var count int = 0\\n    var start int = 0\\n    for i := 0; i < len(this.memory); i++ {\\n        if this.memory[i] == 0 {\\n            count++\\n            if count == size {\\n                for j := 0; j < size; j++ {\\n                    this.memory[j + start] = mID\\n                }\\n                return start\\n            }\\n        } else {\\n            start = i + 1\\n            count = 0\\n        }\\n    }\\n    return -1\\n}\\n\\n\\nfunc (this *Allocator) Free(mID int) int {\\n    var count int = 0\\n    for i := 0; i < len(this.memory); i++ {\\n        if this.memory[i] == mID {\\n            this.memory[i] = 0\\n            count++\\n        }\\n    }\\n    return count\\n}\\n\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * obj := Constructor(n);\\n * param_1 := obj.Allocate(size,mID);\\n * param_2 := obj.Free(mID);\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Design",
                    "Simulation"
                ],
                "code": "```\\ntype Allocator struct {\\n    memory []int\\n}\\n\\n\\nfunc Constructor(n int) Allocator {\\n    return Allocator {\\n        memory: make([]int, n),\\n    }\\n}\\n\\n\\nfunc (this *Allocator) Allocate(size int, mID int) int {\\n    var count int = 0\\n    var start int = 0\\n    for i := 0; i < len(this.memory); i++ {\\n        if this.memory[i] == 0 {\\n            count++\\n            if count == size {\\n                for j := 0; j < size; j++ {\\n                    this.memory[j + start] = mID\\n                }\\n                return start\\n            }\\n        } else {\\n            start = i + 1\\n            count = 0\\n        }\\n    }\\n    return -1\\n}\\n\\n\\nfunc (this *Allocator) Free(mID int) int {\\n    var count int = 0\\n    for i := 0; i < len(this.memory); i++ {\\n        if this.memory[i] == mID {\\n            this.memory[i] = 0\\n            count++\\n        }\\n    }\\n    return count\\n}\\n\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * obj := Constructor(n);\\n * param_1 := obj.Allocate(size,mID);\\n * param_2 := obj.Free(mID);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2963543,
                "title": "c-array",
                "content": "# Code\\n```\\nclass Allocator {\\n    vector<int> memory;\\npublic:\\n    Allocator(int n) {\\n        memory.resize(n);\\n        fill(memory.begin(), memory.end(), -1);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int count = 0, start = 0;\\n        for(int i = 0; i < memory.size(); i++) {\\n            if(memory[i] == -1) {\\n                count++;\\n                if(count == size) {\\n                    for(int j = 0; j < size; j++) {\\n                        memory[j + start] = mID;\\n                    }\\n                    return start;\\n                }\\n            } else {\\n                start = i + 1;\\n                count = 0;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int count = 0;\\n        for(int i = 0; i < memory.size(); i++) {\\n            if(memory[i] == mID) {\\n                memory[i] = -1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Design",
                    "Simulation"
                ],
                "code": "```\\nclass Allocator {\\n    vector<int> memory;\\npublic:\\n    Allocator(int n) {\\n        memory.resize(n);\\n        fill(memory.begin(), memory.end(), -1);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int count = 0, start = 0;\\n        for(int i = 0; i < memory.size(); i++) {\\n            if(memory[i] == -1) {\\n                count++;\\n                if(count == size) {\\n                    for(int j = 0; j < size; j++) {\\n                        memory[j + start] = mID;\\n                    }\\n                    return start;\\n                }\\n            } else {\\n                start = i + 1;\\n                count = 0;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int count = 0;\\n        for(int i = 0; i < memory.size(); i++) {\\n            if(memory[i] == mID) {\\n                memory[i] = -1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960721,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Allocator {\\n    int arr[];\\n    public Allocator(int n) {\\n        arr=new int[n];\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int count=0;\\n        int startIndex=-1;\\n        int flag=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                if(count==0)\\n                {\\n                    startIndex=i;\\n                    count++;\\n                    if(count==size)\\n                    {\\n                        flag=1;\\n                        break;\\n\\n                    }\\n                }\\n                else\\n                {\\n                    count++;\\n                    if(count==size)\\n                    {\\n                        flag=1;\\n                        break;\\n\\n                    }\\n                }\\n            }\\n            else\\n            {\\n               count=0; \\n            }\\n        }\\n\\n        if(flag==1)\\n        {\\n            for(int i=startIndex;i<startIndex+size;i++)\\n            {\\n                arr[i]=mID;\\n            }\\n\\n            return startIndex;\\n        }\\n\\n        return -1;\\n    }\\n    \\n    public int free(int mID) {\\n        int count=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==mID)\\n            {\\n                arr[i]=0;\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    int arr[];\\n    public Allocator(int n) {\\n        arr=new int[n];\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int count=0;\\n        int startIndex=-1;\\n        int flag=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                if(count==0)\\n                {\\n                    startIndex=i;\\n                    count++;\\n                    if(count==size)\\n                    {\\n                        flag=1;\\n                        break;\\n\\n                    }\\n                }\\n                else\\n                {\\n                    count++;\\n                    if(count==size)\\n                    {\\n                        flag=1;\\n                        break;\\n\\n                    }\\n                }\\n            }\\n            else\\n            {\\n               count=0; \\n            }\\n        }\\n\\n        if(flag==1)\\n        {\\n            for(int i=startIndex;i<startIndex+size;i++)\\n            {\\n                arr[i]=mID;\\n            }\\n\\n            return startIndex;\\n        }\\n\\n        return -1;\\n    }\\n    \\n    public int free(int mID) {\\n        int count=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==mID)\\n            {\\n                arr[i]=0;\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951197,
                "title": "c-std-map-based-solution",
                "content": "# Intuition\\nFor allocation we use Red Black Tree: {free_block_start_index -> free_block_size}, it\\'s sorted by free_block_start_index. Iterating from smallest index to biggest we\\'re trying to find the appropriate block which has enough size.\\n\\nFor deallocation we use Hash Table {mID -> {block1,block2,block3}}, where block has {size, start_index}. While the memory is returned we populate the Red Black Tree.\\n\\n\\n# Complexity\\n- Time complexity, allocation=O(N), deallocation(K*log(N)), N=number of memory units, K=number of allocations for mID. \\n\\n- Space complexity: worst is O(N)\\n\\n# Code\\n```\\nclass Allocator {\\n    using u32=uint32_t;\\n    struct TMemBlock{\\n        u32 size;\\n        u32 start;\\n    };\\n    // {mID->{block1,block2,block3}}\\n    std::unordered_map<u32, std::vector<TMemBlock>> ID;\\n    std::map<u32,u32> Free; // {idx->size}\\n    \\npublic:\\n    Allocator(u32 n)\\n    {\\n        Free.emplace(0,n);\\n    }\\n    void print_me() const noexcept {\\n        std::cout << \"\\\\nFREE:\\\\n\";\\n        for(const auto &p: Free){\\n            std::cout << \"[\" << p.first << \\',\\' << p.first+p.second << \")\\\\n\";\\n        }\\n        std::cout << \"\\\\nID:\\\\n\";\\n        for(const auto &p: ID){\\n            std::cout << \"[id=\" << p.first << \"->{\";\\n            for(const auto &mb: p.second){\\n                std::cout << \"[\" << mb.start << \\',\\' << mb.start+mb.size << \");\";\\n            }\\n            std::cout << \"}]\\\\n\";\\n        }\\n        std::cout << std::endl;\\n    }\\n    \\n    int allocate(const u32 size, const u32 mID) {\\n        auto it=Free.begin();\\n        while(true){\\n            if (it == Free.end()) return -1;\\n            if (it->second>=size) break;\\n            ++it;\\n        }\\n        u32 free_size=it->second-size;\\n        u32 start=it->first;\\n        Free.erase(it);\\n        if (free_size){\\n            Free.emplace(start+size, free_size);\\n        }\\n        ID[mID].push_back({size, start});\\n        return start;\\n    }\\n    \\n    int free(u32 mID) {\\n        auto id_it=ID.find(mID);\\n        if (id_it == ID.end()) return 0;\\n        \\n        u32 freed=0;\\n        for(const TMemBlock &mb: id_it->second){\\n            freed+=mb.size;\\n\\n            auto mid=Free.upper_bound(mb.start);\\n            auto right=mid;\\n            if(right!=Free.end()){\\n                if(right->first != mb.start+mb.size){\\n                    right=Free.end();\\n                }\\n            }\\n            auto left=mid;\\n            if(left!=Free.begin()){\\n                --left;\\n                if(left->first+left->second != mb.start){\\n                    not_found: left=Free.end();\\n                }\\n            } else goto not_found;\\n\\n            /* no merge */\\n            if (left==Free.end() && right==Free.end()){\\n                Free.emplace(mb.start, mb.size);\\n                continue;\\n            }\\n            /* merge left */\\n            if (left!=Free.end()){\\n                left->second+=mb.size;\\n                /* + merge right */\\n                if(right!=Free.end()){\\n                    left->second+=right->second;\\n                    Free.erase(right);\\n                }\\n                continue;\\n            }\\n            /* merge right only */\\n            if (right!=Free.end()){\\n                u32 sz=mb.size+right->second;\\n                Free.erase(right);\\n                Free.emplace(mb.start, sz);\\n                continue;\\n            }\\n        }\\n        ID.erase(id_it);\\n        return freed;\\n    }\\n};\\nint speedup=[](){\\n    std::ios_base::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    std::cout.tie(nullptr);\\n    return 13;\\n}();\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\n    using u32=uint32_t;\\n    struct TMemBlock{\\n        u32 size;\\n        u32 start;\\n    };\\n    // {mID->{block1,block2,block3}}\\n    std::unordered_map<u32, std::vector<TMemBlock>> ID;\\n    std::map<u32,u32> Free; // {idx->size}\\n    \\npublic:\\n    Allocator(u32 n)\\n    {\\n        Free.emplace(0,n);\\n    }\\n    void print_me() const noexcept {\\n        std::cout << \"\\\\nFREE:\\\\n\";\\n        for(const auto &p: Free){\\n            std::cout << \"[\" << p.first << \\',\\' << p.first+p.second << \")\\\\n\";\\n        }\\n        std::cout << \"\\\\nID:\\\\n\";\\n        for(const auto &p: ID){\\n            std::cout << \"[id=\" << p.first << \"->{\";\\n            for(const auto &mb: p.second){\\n                std::cout << \"[\" << mb.start << \\',\\' << mb.start+mb.size << \");\";\\n            }\\n            std::cout << \"}]\\\\n\";\\n        }\\n        std::cout << std::endl;\\n    }\\n    \\n    int allocate(const u32 size, const u32 mID) {\\n        auto it=Free.begin();\\n        while(true){\\n            if (it == Free.end()) return -1;\\n            if (it->second>=size) break;\\n            ++it;\\n        }\\n        u32 free_size=it->second-size;\\n        u32 start=it->first;\\n        Free.erase(it);\\n        if (free_size){\\n            Free.emplace(start+size, free_size);\\n        }\\n        ID[mID].push_back({size, start});\\n        return start;\\n    }\\n    \\n    int free(u32 mID) {\\n        auto id_it=ID.find(mID);\\n        if (id_it == ID.end()) return 0;\\n        \\n        u32 freed=0;\\n        for(const TMemBlock &mb: id_it->second){\\n            freed+=mb.size;\\n\\n            auto mid=Free.upper_bound(mb.start);\\n            auto right=mid;\\n            if(right!=Free.end()){\\n                if(right->first != mb.start+mb.size){\\n                    right=Free.end();\\n                }\\n            }\\n            auto left=mid;\\n            if(left!=Free.begin()){\\n                --left;\\n                if(left->first+left->second != mb.start){\\n                    not_found: left=Free.end();\\n                }\\n            } else goto not_found;\\n\\n            /* no merge */\\n            if (left==Free.end() && right==Free.end()){\\n                Free.emplace(mb.start, mb.size);\\n                continue;\\n            }\\n            /* merge left */\\n            if (left!=Free.end()){\\n                left->second+=mb.size;\\n                /* + merge right */\\n                if(right!=Free.end()){\\n                    left->second+=right->second;\\n                    Free.erase(right);\\n                }\\n                continue;\\n            }\\n            /* merge right only */\\n            if (right!=Free.end()){\\n                u32 sz=mb.size+right->second;\\n                Free.erase(right);\\n                Free.emplace(mb.start, sz);\\n                continue;\\n            }\\n        }\\n        ID.erase(id_it);\\n        return freed;\\n    }\\n};\\nint speedup=[](){\\n    std::ios_base::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    std::cout.tie(nullptr);\\n    return 13;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2941972,
                "title": "c",
                "content": "```\\n#include <stdarg.h>\\n\\n\\ntypedef struct {\\n    int* count;\\n    int* mem;\\n    int size;\\n    int curCn;\\n} Allocator;\\n\\n\\nAllocator* allocatorCreate(int n) {\\n    Allocator* ret = malloc(sizeof(Allocator));\\n    ret->count = calloc(1001, sizeof(int));\\n    ret->mem = calloc(n, sizeof(int));\\n    ret->size = n;\\n    ret->curCn = 0;\\n    return ret;\\n}\\n\\nint allocatorAllocate(Allocator* obj, int size, int mID) {\\n    if(size > (obj->size - obj->curCn))  \\n        return -1;\\n    int k = 0;\\n    while(1){\\n        if(obj->mem[k] > 0){\\n            k++;\\n            continue;\\n        }\\n        if(( k + size) > obj->size)\\n            return -1;\\n        for(int i = 0; i < size; i++){\\n            if(obj->mem[k]){\\n                k++;\\n                break;\\n            }\\n            if(i == size - 1){\\n                obj->count[mID] += size;\\n                for(int j = 0; j < size; j++){\\n                    obj->mem[k] = mID;                                       \\n                    k--;\\n                }\\n                obj->curCn += size;\\n                return k+1;\\n            }\\n            k++;\\n        }\\n    }  \\n}\\n\\n//int allocatorFree(Allocator* obj, int mID) {\\nint allocatorFree(Allocator* obj, ...) {\\n  va_list argp;\\n  va_start(argp, obj);\\n  int mID = va_arg(argp, int);\\n    int ans = obj->count[mID];\\n    obj->count[mID] = 0;\\n    obj->curCn -= ans;\\n    if(ans == 0)\\n        return ans;\\n    int k = 0;  \\n    for(int i = 0; i < obj->size; i++){\\n        if(obj->mem[i] == mID){\\n            obj->mem[i] = 0;\\n            k++;\\n            if(k == ans)\\n                break;\\n        }\\n    }\\n    return ans;\\n}\\n\\n//void allocatorFree(Allocator* obj) {\\n   // free(obj->count);\\n   // free(obj->mem);\\n   // free(obj);        \\n//}\\n\\n/**\\n * Your Allocator struct will be instantiated and called as such:\\n * Allocator* obj = allocatorCreate(n);\\n * int param_1 = allocatorAllocate(obj, size, mID);\\n \\n * int param_2 = allocatorFree(obj, mID);\\n \\n * allocatorFree(obj);\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\n#include <stdarg.h>\\n\\n\\ntypedef struct {\\n    int* count;\\n    int* mem;\\n    int size;\\n    int curCn;\\n} Allocator;\\n\\n\\nAllocator* allocatorCreate(int n) {\\n    Allocator* ret = malloc(sizeof(Allocator));\\n    ret->count = calloc(1001, sizeof(int));\\n    ret->mem = calloc(n, sizeof(int));\\n    ret->size = n;\\n    ret->curCn = 0;\\n    return ret;\\n}\\n\\nint allocatorAllocate(Allocator* obj, int size, int mID) {\\n    if(size > (obj->size - obj->curCn))  \\n        return -1;\\n    int k = 0;\\n    while(1){\\n        if(obj->mem[k] > 0){\\n            k++;\\n            continue;\\n        }\\n        if(( k + size) > obj->size)\\n            return -1;\\n        for(int i = 0; i < size; i++){\\n            if(obj->mem[k]){\\n                k++;\\n                break;\\n            }\\n            if(i == size - 1){\\n                obj->count[mID] += size;\\n                for(int j = 0; j < size; j++){\\n                    obj->mem[k] = mID;                                       \\n                    k--;\\n                }\\n                obj->curCn += size;\\n                return k+1;\\n            }\\n            k++;\\n        }\\n    }  \\n}\\n\\n//int allocatorFree(Allocator* obj, int mID) {\\nint allocatorFree(Allocator* obj, ...) {\\n  va_list argp;\\n  va_start(argp, obj);\\n  int mID = va_arg(argp, int);\\n    int ans = obj->count[mID];\\n    obj->count[mID] = 0;\\n    obj->curCn -= ans;\\n    if(ans == 0)\\n        return ans;\\n    int k = 0;  \\n    for(int i = 0; i < obj->size; i++){\\n        if(obj->mem[i] == mID){\\n            obj->mem[i] = 0;\\n            k++;\\n            if(k == ans)\\n                break;\\n        }\\n    }\\n    return ans;\\n}\\n\\n//void allocatorFree(Allocator* obj) {\\n   // free(obj->count);\\n   // free(obj->mem);\\n   // free(obj);        \\n//}\\n\\n/**\\n * Your Allocator struct will be instantiated and called as such:\\n * Allocator* obj = allocatorCreate(n);\\n * int param_1 = allocatorAllocate(obj, size, mID);\\n \\n * int param_2 = allocatorFree(obj, mID);\\n \\n * allocatorFree(obj);\\n*/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2939822,
                "title": "py3-array-hashmap-and-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n Allocate: $$O(n)$$ \\n Free: $$O(n)$$ where n = number of slots that currently have value mID\\n\\n- Space complexity:\\n~$$O(n) * 2$$\\n\\n# Code\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.mem = [None] * n\\n        self.values = {}\\n        \\n    def recordValue(self, value, idx):\\n        if value not in self.values:\\n            self.values[value] = set()\\n        self.values[value].add(idx)\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        curWindow = 0\\n        for idx, i in enumerate(self.mem):\\n            if i is not None:\\n                curWindow = 0\\n            else:\\n                curWindow += 1\\n            if curWindow == size:\\n                for j in range(idx - curWindow + 1, idx+1):\\n                    self.mem[j] = mID\\n                    self.recordValue(mID, j)\\n                return idx - curWindow + 1\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        freed = 0\\n        if mID in self.values:\\n            freed += len(self.values[mID])\\n            for i in self.values[mID]:\\n                self.mem[i] = None\\n            del self.values[mID]\\n        return freed\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.mem = [None] * n\\n        self.values = {}\\n        \\n    def recordValue(self, value, idx):\\n        if value not in self.values:\\n            self.values[value] = set()\\n        self.values[value].add(idx)\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        curWindow = 0\\n        for idx, i in enumerate(self.mem):\\n            if i is not None:\\n                curWindow = 0\\n            else:\\n                curWindow += 1\\n            if curWindow == size:\\n                for j in range(idx - curWindow + 1, idx+1):\\n                    self.mem[j] = mID\\n                    self.recordValue(mID, j)\\n                return idx - curWindow + 1\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        freed = 0\\n        if mID in self.values:\\n            freed += len(self.values[mID])\\n            for i in self.values[mID]:\\n                self.mem[i] = None\\n            del self.values[mID]\\n        return freed\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936940,
                "title": "c-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    Allocator(int n) {\\n        _buf.resize(n, 0);\\n        _freeMap[0] = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        for(auto p : _freeMap){\\n            if(p.second >= size){\\n                _freeMap.erase(p.first);\\n                _idMap[mID].push_back(vector<int>{p.first, size});\\n                if(p.second > size)_freeMap[p.first+size] = p.second - size;\\n                return p.first;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int count = 0;\\n        if(_idMap.count(mID)){\\n            for(auto p : _idMap[mID]){\\n                 _freeMap[p[0]] = p[1];\\n                 count += p[1];\\n            }\\n            _idMap.erase(mID);\\n        }\\n        // merge all the free memories with continus address\\n        map<int, int>::iterator it = _freeMap.begin();\\n        while(it != _freeMap.end()){\\n            map<int, int>::iterator next = std::next(it);\\n            while(next != _freeMap.end() && it->first + it->second == next->first){\\n                it->second += next->second;\\n                _freeMap.erase(next->first);\\n                next = std::next(it);\\n            }\\n            it++;\\n        }\\n        return count;\\n    }\\nprivate:\\n    vector<int> _buf;\\n    map<int, int> _freeMap;\\n    map<int, vector<vector<int>>> _idMap;\\n\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    Allocator(int n) {\\n        _buf.resize(n, 0);\\n        _freeMap[0] = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        for(auto p : _freeMap){\\n            if(p.second >= size){\\n                _freeMap.erase(p.first);\\n                _idMap[mID].push_back(vector<int>{p.first, size});\\n                if(p.second > size)_freeMap[p.first+size] = p.second - size;\\n                return p.first;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int count = 0;\\n        if(_idMap.count(mID)){\\n            for(auto p : _idMap[mID]){\\n                 _freeMap[p[0]] = p[1];\\n                 count += p[1];\\n            }\\n            _idMap.erase(mID);\\n        }\\n        // merge all the free memories with continus address\\n        map<int, int>::iterator it = _freeMap.begin();\\n        while(it != _freeMap.end()){\\n            map<int, int>::iterator next = std::next(it);\\n            while(next != _freeMap.end() && it->first + it->second == next->first){\\n                it->second += next->second;\\n                _freeMap.erase(next->first);\\n                next = std::next(it);\\n            }\\n            it++;\\n        }\\n        return count;\\n    }\\nprivate:\\n    vector<int> _buf;\\n    map<int, int> _freeMap;\\n    map<int, vector<vector<int>>> _idMap;\\n\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936636,
                "title": "easiest-java-solution-beats-66",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Allocator {\\n\\n    int []arr;\\n    HashMap<Integer,ArrayList<Integer>>mp=new HashMap<>();\\n\\n    public Allocator(int n) {\\n        \\n    arr=new int[n];\\n\\n    for(int i=0;i<n;i++){\\n        arr[i]=-1;\\n    }\\n\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        \\n    int count=0;\\n    int first=-1;\\n    boolean havefirst=false;\\n    int back=-1;\\n\\n    if(size>arr.length)return -1;\\n\\n    for(int i=0;i<arr.length;i++){       //this section is for checking whether we have required side available or not\\n\\n    if(arr[i]==-1)\\n    {\\n    count+=1;\\n    if(havefirst==false)\\n    {\\n        havefirst=true;\\n        first=i;\\n    }\\n    }\\n    else if(arr[i]!=-1){\\n        count=0;\\n        first=-1;\\n        havefirst=false;\\n    }\\n\\n    if(count==size)break;\\n\\n    }\\n    \\n    if(count<size)return -1;\\n\\n    if(!mp.containsKey(mID))\\n    mp.put(mID,new ArrayList<Integer>());\\n\\n    for(int i=first;i<(first+count);i++){\\n\\n    mp.get(mID).add(i);\\n\\n    arr[i]=mID;\\n\\n    }\\n\\n    return first;\\n\\n    }\\n    \\n    public int free(int mID) {\\n        \\n    if(!mp.containsKey(mID))return 0;\\n\\n    int size=mp.get(mID).size();\\n\\n    ArrayList<Integer>temp=mp.get(mID);\\n\\n    for(int m:temp){\\n        arr[m]=-1;\\n    }\\n\\n    mp.remove(mID);\\n\\n    return size;\\n\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Design",
                    "Simulation"
                ],
                "code": "```\\nclass Allocator {\\n\\n    int []arr;\\n    HashMap<Integer,ArrayList<Integer>>mp=new HashMap<>();\\n\\n    public Allocator(int n) {\\n        \\n    arr=new int[n];\\n\\n    for(int i=0;i<n;i++){\\n        arr[i]=-1;\\n    }\\n\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        \\n    int count=0;\\n    int first=-1;\\n    boolean havefirst=false;\\n    int back=-1;\\n\\n    if(size>arr.length)return -1;\\n\\n    for(int i=0;i<arr.length;i++){       //this section is for checking whether we have required side available or not\\n\\n    if(arr[i]==-1)\\n    {\\n    count+=1;\\n    if(havefirst==false)\\n    {\\n        havefirst=true;\\n        first=i;\\n    }\\n    }\\n    else if(arr[i]!=-1){\\n        count=0;\\n        first=-1;\\n        havefirst=false;\\n    }\\n\\n    if(count==size)break;\\n\\n    }\\n    \\n    if(count<size)return -1;\\n\\n    if(!mp.containsKey(mID))\\n    mp.put(mID,new ArrayList<Integer>());\\n\\n    for(int i=first;i<(first+count);i++){\\n\\n    mp.get(mID).add(i);\\n\\n    arr[i]=mID;\\n\\n    }\\n\\n    return first;\\n\\n    }\\n    \\n    public int free(int mID) {\\n        \\n    if(!mp.containsKey(mID))return 0;\\n\\n    int size=mp.get(mID).size();\\n\\n    ArrayList<Integer>temp=mp.get(mID);\\n\\n    for(int m:temp){\\n        arr[m]=-1;\\n    }\\n\\n    mp.remove(mID);\\n\\n    return size;\\n\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934624,
                "title": "python-cumulative-sum",
                "content": "```\\nclass Allocator:\\n    def __init__(self, n: int):\\n        # [mID, occupied, cumulative sum]\\n        self.arr = [[0, 0, 0] for _ in range(n + 1)]\\n        self.n = n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        index = -1\\n        for i in range(1, self.n + 1):\\n            right = i + size - 1\\n            if right <= self.n:\\n                if self.arr[i][1] == 0 and self.arr[i][2] == self.arr[right][2]:\\n                    index = i\\n                    break\\n\\n        if index == -1:\\n            return index\\n        \\n        for i in range(index, index + size):\\n            self.arr[i][0] = mID\\n            self.arr[i][1] = 1\\n            self.arr[i][2] = self.arr[i - 1][2] + 1\\n        \\n        for j in range(index + size, self.n + 1):\\n            self.arr[i][2] = self.arr[i - 1][2] + self.arr[i][1]\\n            \\n        return index - 1\\n\\n    def free(self, mID: int) -> int:\\n        count = 0\\n        for i in range(1, self.n + 1):\\n            if self.arr[i][1] == 1 and self.arr[i][0] == mID:\\n                self.arr[i][0] = 0\\n                self.arr[i][1] = 0\\n                self.arr[i][2] = self.arr[i - 1][2]\\n                count += 1\\n            \\n            else:\\n                self.arr[i][2] = self.arr[i - 1][2] + self.arr[i][1]\\n        \\n        return count\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Allocator:\\n    def __init__(self, n: int):\\n        # [mID, occupied, cumulative sum]\\n        self.arr = [[0, 0, 0] for _ in range(n + 1)]\\n        self.n = n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        index = -1\\n        for i in range(1, self.n + 1):\\n            right = i + size - 1\\n            if right <= self.n:\\n                if self.arr[i][1] == 0 and self.arr[i][2] == self.arr[right][2]:\\n                    index = i\\n                    break\\n\\n        if index == -1:\\n            return index\\n        \\n        for i in range(index, index + size):\\n            self.arr[i][0] = mID\\n            self.arr[i][1] = 1\\n            self.arr[i][2] = self.arr[i - 1][2] + 1\\n        \\n        for j in range(index + size, self.n + 1):\\n            self.arr[i][2] = self.arr[i - 1][2] + self.arr[i][1]\\n            \\n        return index - 1\\n\\n    def free(self, mID: int) -> int:\\n        count = 0\\n        for i in range(1, self.n + 1):\\n            if self.arr[i][1] == 1 and self.arr[i][0] == mID:\\n                self.arr[i][0] = 0\\n                self.arr[i][1] = 0\\n                self.arr[i][2] = self.arr[i - 1][2]\\n                count += 1\\n            \\n            else:\\n                self.arr[i][2] = self.arr[i - 1][2] + self.arr[i][1]\\n        \\n        return count\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934148,
                "title": "speed-beat-92-5-and-memory-usage-beat-88",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nallocate need 2 loops:\\nfirst check left most free block starting point and if its tail is free\\nthen check if all space is free between tail and head\\nExit point:\\nif the Allocator\\'s space left < size allocated\\nif loop index > total self.size\\nfree:\\ncache the index\\'s starting and ending point\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. finish the 2 loops \\n2. setup exit point\\n3. cache the head and tail of mID each time in self.at\\n4. fix the duplicated key error in self.at, as same mID maybe insert multi times by starting tuple(head, tail) inf self.at like {mID:[(head, tail),]}\\n5. fix time exceed by adding Exit point, that is: if the Allocator\\'s space left < size allocated\\n\\n# Complexity\\n- Time complexity:\\nAllocate: best: O(1), worst O(n)\\nFree: O(1)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAllocate: O(n)\\nFree: O(n)\\n\\n\\n# Code\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.cache = [0]*n\\n        self.size = n\\n        self.at = dict()\\n        self.space = n\\n        \\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        # loop cache and find the leftmost empty index an\\n        i = 0\\n        if size > self.space:\\n            return -1 \\n        while i < self.size:\\n            if i-1+size >= self.size:\\n                return -1\\n            # check if both block head and tail are empty\\n            if self.cache[i] == 0 and self.cache[i-1+size] != 0:\\n                i = i+size\\n                start = i\\n            elif self.cache[i] == 0 and self.cache[i-1+size] == 0:\\n                is_block_free = True\\n                # scan if all sub block free \\n                for k in range(i, i+size):\\n                    if self.cache[k] != 0:\\n                        is_block_free = False\\n                        i = k\\n                        break\\n                # if free fill it up, and break the while loop\\n                if is_block_free:\\n                    # store mID starting and ending(exclusive) index\\n\\n                    self.at.setdefault(mID, []).append((i, i+size))\\n                    for k in range(i, i+size):\\n                        self.cache[k] = mID\\n                    self.space -= size\\n                    return i\\n            # go to next positon\\n            i += 1\\n            # finish the loop and not find \\n            if i >=self.size:\\n                i = -1\\n            \\n        return i\\n            \\n                 \\n        # check the size of left most index\\n        # if not enough\\n        # check next not empty block\\n        \\n\\n    def free(self, mID: int) -> int:\\n        pos = self.at.get(mID)\\n        count = 0\\n        if pos is None:\\n            return count\\n        while len(pos)>0:\\n            start, end = pos.pop()\\n            self.cache = self.cache[:start] + [0]*(end-start) + self.cache[end:]\\n            count = count + end-start\\n        self.space += count\\n\\n        return count\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.cache = [0]*n\\n        self.size = n\\n        self.at = dict()\\n        self.space = n\\n        \\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        # loop cache and find the leftmost empty index an\\n        i = 0\\n        if size > self.space:\\n            return -1 \\n        while i < self.size:\\n            if i-1+size >= self.size:\\n                return -1\\n            # check if both block head and tail are empty\\n            if self.cache[i] == 0 and self.cache[i-1+size] != 0:\\n                i = i+size\\n                start = i\\n            elif self.cache[i] == 0 and self.cache[i-1+size] == 0:\\n                is_block_free = True\\n                # scan if all sub block free \\n                for k in range(i, i+size):\\n                    if self.cache[k] != 0:\\n                        is_block_free = False\\n                        i = k\\n                        break\\n                # if free fill it up, and break the while loop\\n                if is_block_free:\\n                    # store mID starting and ending(exclusive) index\\n\\n                    self.at.setdefault(mID, []).append((i, i+size))\\n                    for k in range(i, i+size):\\n                        self.cache[k] = mID\\n                    self.space -= size\\n                    return i\\n            # go to next positon\\n            i += 1\\n            # finish the loop and not find \\n            if i >=self.size:\\n                i = -1\\n            \\n        return i\\n            \\n                 \\n        # check the size of left most index\\n        # if not enough\\n        # check next not empty block\\n        \\n\\n    def free(self, mID: int) -> int:\\n        pos = self.at.get(mID)\\n        count = 0\\n        if pos is None:\\n            return count\\n        while len(pos)>0:\\n            start, end = pos.pop()\\n            self.cache = self.cache[:start] + [0]*(end-start) + self.cache[end:]\\n            count = count + end-start\\n        self.space += count\\n\\n        return count\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933199,
                "title": "python-concise-o-blocks-allocate-and-o-id-blocks-log-b-free",
                "content": "# Intuition\\nInstead of saving the occupied memory in a bit array O(n) we want to just store the ranges of each block in O(Blocks).\\n\\n# Approach\\nImagine we have a sorted list where we store the ranges of the occupied memory and in a dictionary we save the mapping of the blocks:\\n```\\n# Example after some operations\\n# Occupied memory:\\n[(0, 10), (20, 40), (100, 130)]\\n# ID-mapping:\\n{5: [(0, 10)], 10: [(20, 40), (100, 130)]}\\n```\\nTo insert a new block we iterate over the blocks of memory and try to find a large enough free block by inspecting two consecutive blocks.\\n```\\nInsert block of size 20:\\n(0,  10) - ( 20,  40) # block doesn\\'t fit because the space between is only 10 elements big \\n(20, 40) - (100, 130) # block fits between here\\n# therefore the new block\\'s starting index is 40 \\n```\\nThen we can just insert the new block `(40, 60)` into the block ranges.\\nTo handle the boundaries we just initialize the block ranges with 2 empty blocks:\\n`[(0, 0), (n, 0)]`\\n\\n\\n# Complexity\\n- Time complexity:\\n  - Allocate: O(B + log(B)) = O(B), where B is the total number of blocks inserted.\\n  - Free: O(IDB * log(B)), where ID-B is the number of blocks for the given ID and B is the total number of blocks inserted. The log(B) factor comes from the deletion of a block from the sorted list.\\n\\n- Space complexity:\\n  O(B), where B is the number of blocks inserted\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.id_blocks = defaultdict(list)\\n        self.blocks = SortedList([(0,0), (n,0)])\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        for i in range(len(self.blocks)-1):\\n            _, b = self.blocks[i]\\n            c, _ = self.blocks[i+1]\\n            if c - b < size:\\n                continue\\n            self.blocks.add((b,b+size))\\n            self.id_blocks[mID].append((b,b+size))\\n            return b\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        sizes = 0\\n        for b in self.id_blocks[mID]:\\n            sizes += b[1] - b[0]\\n            self.blocks.remove(b)\\n        del self.id_blocks[mID]\\n        return sizes\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Example after some operations\\n# Occupied memory:\\n[(0, 10), (20, 40), (100, 130)]\\n# ID-mapping:\\n{5: [(0, 10)], 10: [(20, 40), (100, 130)]}\\n```\n```\\nInsert block of size 20:\\n(0,  10) - ( 20,  40) # block doesn\\'t fit because the space between is only 10 elements big \\n(20, 40) - (100, 130) # block fits between here\\n# therefore the new block\\'s starting index is 40 \\n```\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.id_blocks = defaultdict(list)\\n        self.blocks = SortedList([(0,0), (n,0)])\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        for i in range(len(self.blocks)-1):\\n            _, b = self.blocks[i]\\n            c, _ = self.blocks[i+1]\\n            if c - b < size:\\n                continue\\n            self.blocks.add((b,b+size))\\n            self.id_blocks[mID].append((b,b+size))\\n            return b\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        sizes = 0\\n        for b in self.id_blocks[mID]:\\n            sizes += b[1] - b[0]\\n            self.blocks.remove(b)\\n        del self.id_blocks[mID]\\n        return sizes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933093,
                "title": "python-bruteforce-o-n",
                "content": "# Code\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.mem = [0]*n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        i = 0\\n        cnt = 0\\n        left = -1\\n        while i < len(self.mem):\\n            if not self.mem[i]:\\n                cnt += 1\\n                if cnt == size:\\n                    left += 1\\n                    for j in range(cnt):\\n                        self.mem[left+j] = mID\\n                    return left\\n            else:\\n                cnt = 0\\n                left = i\\n            i += 1\\n        return -1\\n            \\n\\n    def free(self, mID: int) -> int:\\n        res = 0\\n        for i in range(len(self.mem)):\\n            if self.mem[i] == mID:\\n                res += 1\\n                self.mem[i] = 0\\n        return res\\n\\n\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.mem = [0]*n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        i = 0\\n        cnt = 0\\n        left = -1\\n        while i < len(self.mem):\\n            if not self.mem[i]:\\n                cnt += 1\\n                if cnt == size:\\n                    left += 1\\n                    for j in range(cnt):\\n                        self.mem[left+j] = mID\\n                    return left\\n            else:\\n                cnt = 0\\n                left = i\\n            i += 1\\n        return -1\\n            \\n\\n    def free(self, mID: int) -> int:\\n        res = 0\\n        for i in range(len(self.mem)):\\n            if self.mem[i] == mID:\\n                res += 1\\n                self.mem[i] = 0\\n        return res\\n\\n\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932189,
                "title": "python-bruteforce",
                "content": "\\n# Code\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.memory = [0] * n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        count = 0\\n        applicable = False\\n        index = -1\\n        for idx, m in enumerate(self.memory):\\n            if m == 0:\\n                count+=1\\n            else:\\n                count = 0\\n\\n            if count == size:\\n                index = idx - size+1\\n                applicable = True\\n                break\\n        \\n        if not applicable:\\n            return -1\\n\\n        for i in range(index, index+size):\\n            self.memory[i] = mID\\n        \\n        return index\\n\\n\\n\\n    def free(self, mID: int) -> int:\\n        freed = 0\\n        for idx, m in enumerate(self.memory):\\n            if m == mID:\\n                self.memory[idx] = 0\\n                freed+=1\\n        return freed\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.memory = [0] * n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        count = 0\\n        applicable = False\\n        index = -1\\n        for idx, m in enumerate(self.memory):\\n            if m == 0:\\n                count+=1\\n            else:\\n                count = 0\\n\\n            if count == size:\\n                index = idx - size+1\\n                applicable = True\\n                break\\n        \\n        if not applicable:\\n            return -1\\n\\n        for i in range(index, index+size):\\n            self.memory[i] = mID\\n        \\n        return index\\n\\n\\n\\n    def free(self, mID: int) -> int:\\n        freed = 0\\n        for idx, m in enumerate(self.memory):\\n            if m == mID:\\n                self.memory[idx] = 0\\n                freed+=1\\n        return freed\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929740,
                "title": "simple",
                "content": "\\n```\\nclass Allocator:\\n    def __init__(self, n: int):\\n        self.memory = [0]*n\\n        self.hashmap={}\\n    def allocate(self, size: int, mID: int) -> int:\\n        def f(array,size,i):\\n            while i<len(array) and array[i]!=0:i+=1\\n            if i>len(array)-1:return -1\\n            c=0\\n            res=i\\n            while i<len(array) and array[i]==0:\\n              i +=1\\n              c+=1\\n              if c==size:return res\\n            return f(array,size,i)\\n        index=f(self.memory,size,0)\\n        if index !=-1:\\n            res =index\\n            for i in range(size):\\n                self.memory[index]=1\\n                if mID not in self.hashmap:self.hashmap[mID]=[]\\n                self.hashmap[mID].append(index)\\n                index+=1\\n            return res\\n        else:return -1    \\n    def free(self, mID: int) -> int:\\n        if mID not in self.hashmap:return 0\\n        for i in self.hashmap[mID]:self.memory[i]=0\\n        g = len(self.hashmap[mID])\\n        self.hashmap[mID]=[]\\n        return g\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n    def __init__(self, n: int):\\n        self.memory = [0]*n\\n        self.hashmap={}\\n    def allocate(self, size: int, mID: int) -> int:\\n        def f(array,size,i):\\n            while i<len(array) and array[i]!=0:i+=1\\n            if i>len(array)-1:return -1\\n            c=0\\n            res=i\\n            while i<len(array) and array[i]==0:\\n              i +=1\\n              c+=1\\n              if c==size:return res\\n            return f(array,size,i)\\n        index=f(self.memory,size,0)\\n        if index !=-1:\\n            res =index\\n            for i in range(size):\\n                self.memory[index]=1\\n                if mID not in self.hashmap:self.hashmap[mID]=[]\\n                self.hashmap[mID].append(index)\\n                index+=1\\n            return res\\n        else:return -1    \\n    def free(self, mID: int) -> int:\\n        if mID not in self.hashmap:return 0\\n        for i in self.hashmap[mID]:self.memory[i]=0\\n        g = len(self.hashmap[mID])\\n        self.hashmap[mID]=[]\\n        return g\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929738,
                "title": "memory-array-and-allocations-dict-python3-detailed-explanation",
                "content": "\\nKeypoint:\\n1. Each allocation should take less than O(n) time \\n\\nData structure:\\n1. allocations map: {mID, List[(start_index, length)]}\\n2. memory array: record each unit\\'s allocation\\n\\nAlg:\\n1. allocate: scan memory from left to right. If unit not allocated, add count by 1, otherwise reset count to 0. if count is equal to size, we have found a block.\\n2. free: for all blocks of mID, remove it from memory array\\n\\nComments:\\n1. In real world, memory is stored in linked list to get better performance. Not necessary for this problem though.\\n\\n```\\nclass Allocator:\\n    def __init__(self, n: int):\\n        self.memory = [None] * n  # Initialize the memory array with all units free\\n        self.allocations = {}  # Initialize the allocations dictionary\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        # Find the leftmost block of size consecutive free memory units\\n        start = -1\\n        end = -1\\n        count = 0\\n        for i, unit in enumerate(self.memory):\\n            if unit is None:\\n                # If this is the first free unit, mark it as the start of the block\\n                if start == -1:\\n                    start = i\\n                count += 1\\n            else:\\n                # If this is not a free unit, reset the start and count\\n                start = -1\\n                count = 0\\n            # If we have found a block of size consecutive free units, mark it as the end of the block\\n            if count == size:\\n                end = i\\n                break\\n        if start == -1 or end == -1:\\n            return -1  # Return -1 if such a block does not exist\\n        # Allocate the block by filling it with mID\\n        for i in range(start, end + 1):\\n            self.memory[i] = mID\\n        # Update the allocations dictionary\\n        if mID not in self.allocations:\\n            self.allocations[mID] = []\\n        self.allocations[mID].append((start, end))\\n        return start  # Return the block\\'s first index\\n\\n    def free(self, mID: int) -> int:\\n        if mID not in self.allocations:\\n            return 0  # Return 0 if there are no allocations with this ID\\n        # Free all memory units with the given ID\\n        count = 0\\n        for start, end in self.allocations[mID]:\\n            for i in range(start, end + 1):\\n                self.memory[i] = None\\n                count += 1\\n        del self.allocations[mID]  # Remove the ID from the allocations dictionary\\n        return count  # Return the number of memory units freed\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n    def __init__(self, n: int):\\n        self.memory = [None] * n  # Initialize the memory array with all units free\\n        self.allocations = {}  # Initialize the allocations dictionary\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        # Find the leftmost block of size consecutive free memory units\\n        start = -1\\n        end = -1\\n        count = 0\\n        for i, unit in enumerate(self.memory):\\n            if unit is None:\\n                # If this is the first free unit, mark it as the start of the block\\n                if start == -1:\\n                    start = i\\n                count += 1\\n            else:\\n                # If this is not a free unit, reset the start and count\\n                start = -1\\n                count = 0\\n            # If we have found a block of size consecutive free units, mark it as the end of the block\\n            if count == size:\\n                end = i\\n                break\\n        if start == -1 or end == -1:\\n            return -1  # Return -1 if such a block does not exist\\n        # Allocate the block by filling it with mID\\n        for i in range(start, end + 1):\\n            self.memory[i] = mID\\n        # Update the allocations dictionary\\n        if mID not in self.allocations:\\n            self.allocations[mID] = []\\n        self.allocations[mID].append((start, end))\\n        return start  # Return the block\\'s first index\\n\\n    def free(self, mID: int) -> int:\\n        if mID not in self.allocations:\\n            return 0  # Return 0 if there are no allocations with this ID\\n        # Free all memory units with the given ID\\n        count = 0\\n        for start, end in self.allocations[mID]:\\n            for i in range(start, end + 1):\\n                self.memory[i] = None\\n                count += 1\\n        del self.allocations[mID]  # Remove the ID from the allocations dictionary\\n        return count  # Return the number of memory units freed\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928707,
                "title": "simple-easy-java-logic",
                "content": "```\\nclass Allocator {\\n    int[] arr;\\n    int n;\\n\\n    public Allocator(int sz) {\\n        arr = new int[sz];\\n        n = sz;\\n    }\\n\\n    public int allocate(int size, int mID) {\\n        int len = 0;\\n        int st = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 0) {\\n                if (st == -1) {\\n                    st = i;\\n                }\\n                len++;\\n                if (size == len) {\\n                    int r = st;\\n                    for (int j = st; j < r + size; j++) {\\n                        arr[j] = mID;\\n                    }\\n                    return st;\\n                }\\n            } else {\\n                len = 0;\\n                st = -1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    public int free(int mID) {\\n        int c = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == mID) {\\n                c++;\\n                arr[i] = 0;\\n            }\\n        }\\n\\n        return c;\\n    }\\n}\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    int[] arr;\\n    int n;\\n\\n    public Allocator(int sz) {\\n        arr = new int[sz];\\n        n = sz;\\n    }\\n\\n    public int allocate(int size, int mID) {\\n        int len = 0;\\n        int st = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 0) {\\n                if (st == -1) {\\n                    st = i;\\n                }\\n                len++;\\n                if (size == len) {\\n                    int r = st;\\n                    for (int j = st; j < r + size; j++) {\\n                        arr[j] = mID;\\n                    }\\n                    return st;\\n                }\\n            } else {\\n                len = 0;\\n                st = -1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    public int free(int mID) {\\n        int c = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == mID) {\\n                c++;\\n                arr[i] = 0;\\n            }\\n        }\\n\\n        return c;\\n    }\\n}\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925542,
                "title": "ez-c-solution-brute-force-explained",
                "content": "Since the constraints are really small and this was a contest question, we can get away with brute force.\\n**Time taken : 202 ms Faster than 59%**\\n**APPROACH :**\\n* Declare a vector of size n and initialize with 0.\\n* Start searching from the left of the vector whether a block of contagious space is availaible or not while also storing their index.\\n* If available allocate mID to the index we calculated earlier.\\n* Return the starting index.\\n* FOr freeing we simply count number of elements that are equal to mID and make them as 0.\\n```\\nclass Allocator {\\npublic:\\n    vector<int>ar;\\n    int c=0,cap;\\n    Allocator(int n) {\\n        ar.resize(n,0);\\n        cap=n;\\n    }\\n    void print(){\\n        for(auto i:ar)\\n            cout<<i<<\" \";\\n        cout<<endl;\\n    }\\n    int allocate(int size, int mID) {\\n       int a=0,b=0;\\n        for(int i=0;i<cap;i++){\\n            if(b-a==size)\\n                break;\\n            if(ar[i]==0)\\n                b++;\\n            else{\\n                a=i+1,b=a;\\n            }\\n        }\\n         if(b-a<size)\\n             return -1;\\n        for(int i=a;i<b;i++)\\n            ar[i]=mID;\\n       // print();\\n        return a;\\n    }\\n    \\n    int free(int mID) {\\n        int c=0;\\n        for(int i=0;i<cap;i++)\\n            if(ar[i]==mID){\\n                c++;\\n                ar[i]=0;\\n            }\\n        // print();\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    vector<int>ar;\\n    int c=0,cap;\\n    Allocator(int n) {\\n        ar.resize(n,0);\\n        cap=n;\\n    }\\n    void print(){\\n        for(auto i:ar)\\n            cout<<i<<\" \";\\n        cout<<endl;\\n    }\\n    int allocate(int size, int mID) {\\n       int a=0,b=0;\\n        for(int i=0;i<cap;i++){\\n            if(b-a==size)\\n                break;\\n            if(ar[i]==0)\\n                b++;\\n            else{\\n                a=i+1,b=a;\\n            }\\n        }\\n         if(b-a<size)\\n             return -1;\\n        for(int i=a;i<b;i++)\\n            ar[i]=mID;\\n       // print();\\n        return a;\\n    }\\n    \\n    int free(int mID) {\\n        int c=0;\\n        for(int i=0;i<cap;i++)\\n            if(ar[i]==mID){\\n                c++;\\n                ar[i]=0;\\n            }\\n        // print();\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2924167,
                "title": "javascript-direct-way-377ms",
                "content": "```\\nfunction Allocator(n) {\\n    let a = Array(n).fill(-1), used = new Set();\\n    return { allocate, free }\\n    function allocate(size, id) {\\n        let cnt = 0;\\n        for (let i = 0; i < n; i++) {\\n            a[i] == -1 ? cnt++ : cnt = 0; // range count\\n            if (cnt == size) { // previous range valid\\n                for (let j = 0; j < cnt; j++) a[i-j] = id;\\n                return i - size + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n    function free(id) {\\n        let res = 0;\\n        for (let i = 0; i < n; i++) {\\n            if (a[i] == id) {\\n                a[i] = -1;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction Allocator(n) {\\n    let a = Array(n).fill(-1), used = new Set();\\n    return { allocate, free }\\n    function allocate(size, id) {\\n        let cnt = 0;\\n        for (let i = 0; i < n; i++) {\\n            a[i] == -1 ? cnt++ : cnt = 0; // range count\\n            if (cnt == size) { // previous range valid\\n                for (let j = 0; j < cnt; j++) a[i-j] = id;\\n                return i - size + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n    function free(id) {\\n        let res = 0;\\n        for (let i = 0; i < n; i++) {\\n            if (a[i] == id) {\\n                a[i] = -1;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2923712,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\npub struct Allocator {\\n    pub memory: Vec<i32>,\\n    pub free: Vec<(usize, usize)>,\\n}\\n\\nimpl Allocator {\\n    pub fn new(n: i32) -> Self {\\n        Allocator {\\n            memory: vec![-1; n as usize],\\n            free: vec![(0, n as usize)],\\n        }\\n    }\\n\\n    pub fn allocate(&mut self, size: i32, m_id: i32) -> i32 {\\n        let size = size as usize;\\n        let m_id = m_id as usize;\\n\\n        let mut i = 0;\\n        while i < self.free.len() {\\n            let (start, end) = self.free[i];\\n            if end - start >= size {\\n                self.free.remove(i);\\n                if start + size < end {\\n                    self.free.insert(i, (start + size, end));\\n                }\\n                for j in start..start + size {\\n                    self.memory[j] = m_id as i32;\\n                }\\n                return start as i32;\\n            }\\n            i += 1;\\n        }\\n        -1\\n    }\\n\\n    pub fn free(&mut self, m_id: i32) -> i32 {\\n        let m_id = m_id as usize;\\n        let mut i = 0;\\n        let mut count = 0;\\n        while i < self.memory.len() {\\n            if self.memory[i] == m_id as i32 {\\n                self.memory[i] = -1;\\n                count += 1;\\n                let mut j = i + 1;\\n                while j < self.memory.len() && self.memory[j] == m_id as i32 {\\n                    self.memory[j] = -1;\\n                    count += 1;\\n                    j += 1;\\n                }\\n                self.free.push((i, j));\\n                i = j;\\n            } else {\\n                i += 1;\\n            }\\n        }\\n        self.free.sort_by(|a, b| a.0.cmp(&b.0));\\n        let mut i = 0;\\n        while !self.free.is_empty() && i < self.free.len() - 1 {\\n            let (start, end) = self.free[i];\\n            let (next_start, next_end) = self.free[i + 1];\\n            if end == next_start {\\n                self.free.remove(i);\\n                self.free[i] = (start, next_end);\\n            } else {\\n                i += 1;\\n            }\\n        }\\n        count as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub struct Allocator {\\n    pub memory: Vec<i32>,\\n    pub free: Vec<(usize, usize)>,\\n}\\n\\nimpl Allocator {\\n    pub fn new(n: i32) -> Self {\\n        Allocator {\\n            memory: vec![-1; n as usize],\\n            free: vec![(0, n as usize)],\\n        }\\n    }\\n\\n    pub fn allocate(&mut self, size: i32, m_id: i32) -> i32 {\\n        let size = size as usize;\\n        let m_id = m_id as usize;\\n\\n        let mut i = 0;\\n        while i < self.free.len() {\\n            let (start, end) = self.free[i];\\n            if end - start >= size {\\n                self.free.remove(i);\\n                if start + size < end {\\n                    self.free.insert(i, (start + size, end));\\n                }\\n                for j in start..start + size {\\n                    self.memory[j] = m_id as i32;\\n                }\\n                return start as i32;\\n            }\\n            i += 1;\\n        }\\n        -1\\n    }\\n\\n    pub fn free(&mut self, m_id: i32) -> i32 {\\n        let m_id = m_id as usize;\\n        let mut i = 0;\\n        let mut count = 0;\\n        while i < self.memory.len() {\\n            if self.memory[i] == m_id as i32 {\\n                self.memory[i] = -1;\\n                count += 1;\\n                let mut j = i + 1;\\n                while j < self.memory.len() && self.memory[j] == m_id as i32 {\\n                    self.memory[j] = -1;\\n                    count += 1;\\n                    j += 1;\\n                }\\n                self.free.push((i, j));\\n                i = j;\\n            } else {\\n                i += 1;\\n            }\\n        }\\n        self.free.sort_by(|a, b| a.0.cmp(&b.0));\\n        let mut i = 0;\\n        while !self.free.is_empty() && i < self.free.len() - 1 {\\n            let (start, end) = self.free[i];\\n            let (next_start, next_end) = self.free[i + 1];\\n            if end == next_start {\\n                self.free.remove(i);\\n                self.free[i] = (start, next_end);\\n            } else {\\n                i += 1;\\n            }\\n        }\\n        count as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2923410,
                "title": "6-lines-of-c-stl-vector",
                "content": "# Intuition\\nSince memory size is fairly small, it\\'s possible to model it using a vector with elements tracking `mID`s of its owners.\\n\\n# Approach\\nTo allocate, we need to find a contiguous chunk of memory cells that are not assigned yet, e.g. have `mID == 0`, and fill it with `mID` to make sure it\\'s not available for other allocation requests.\\n`free` has to count the number of cells assigned to `mID` and \"free\" them by assigning their `mID`s to `0`.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Allocator {\\nprivate:\\n    vector<int> memory;\\npublic:\\n    Allocator(int n): memory(n) {}\\n    \\n    int allocate(int size, int mID) {\\n        auto last = find_if(begin(memory), end(memory), [free=0, size](int val) mutable { free = val == 0 ? free + 1 : 0; return free == size; });\\n        if (last == end(memory)) return -1;\\n        auto first = last - size + 1;\\n        fill_n(first, size, mID);\\n        return distance(begin(memory), first);\\n    }\\n    \\n    int free(int mID) {\\n        return count_if(begin(memory), end(memory), [=](int& val) { return val == mID ? (val = 0, true) : false; });\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\nprivate:\\n    vector<int> memory;\\npublic:\\n    Allocator(int n): memory(n) {}\\n    \\n    int allocate(int size, int mID) {\\n        auto last = find_if(begin(memory), end(memory), [free=0, size](int val) mutable { free = val == 0 ? free + 1 : 0; return free == size; });\\n        if (last == end(memory)) return -1;\\n        auto first = last - size + 1;\\n        fill_n(first, size, mID);\\n        return distance(begin(memory), first);\\n    }\\n    \\n    int free(int mID) {\\n        return count_if(begin(memory), end(memory), [=](int& val) { return val == mID ? (val = 0, true) : false; });\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921649,
                "title": "java-simple-solution-o-n",
                "content": "# Approach\\n- **defaultValue**: the block\\'s first index.\\n    - need to store until you can find empty array space.\\n- **count**: the number of consecutive empty array index.\\n    - **TO AVOID Time Limit Exceeded** \\u2192 if the count is not above size, i (for loop index) can move to **i + count**.\\n\\n\\n# Code\\n```\\nclass Allocator {\\n\\n    int[] memory;\\n\\n    public Allocator(int n) {\\n        memory = new int[n];\\n        Arrays.fill(memory, -1);\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        for (int i = 0; i < memory.length; i++) {\\n            if (memory[i] == -1) {\\n                int defaultIndex = i;\\n                int count = 0;\\n                while (i+count < memory.length && memory[i+count] == -1) {\\n                    count++;\\n                    if (count == size) {\\n                        for (int j = defaultIndex; j < (defaultIndex+size); j++) {\\n                            memory[j] = mID;\\n                        }\\n                        return defaultIndex;\\n                    }\\n                    if (count >= memory.length) {\\n                        return -1;\\n                    }\\n                }\\n                i += count;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int free(int mID) {\\n        int count = 0;\\n        for (int i = 0; i < memory.length; i++) {\\n            if (memory[i] == mID) {\\n                memory[i] = -1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n\\n    int[] memory;\\n\\n    public Allocator(int n) {\\n        memory = new int[n];\\n        Arrays.fill(memory, -1);\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        for (int i = 0; i < memory.length; i++) {\\n            if (memory[i] == -1) {\\n                int defaultIndex = i;\\n                int count = 0;\\n                while (i+count < memory.length && memory[i+count] == -1) {\\n                    count++;\\n                    if (count == size) {\\n                        for (int j = defaultIndex; j < (defaultIndex+size); j++) {\\n                            memory[j] = mID;\\n                        }\\n                        return defaultIndex;\\n                    }\\n                    if (count >= memory.length) {\\n                        return -1;\\n                    }\\n                }\\n                i += count;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int free(int mID) {\\n        int count = 0;\\n        for (int i = 0; i < memory.length; i++) {\\n            if (memory[i] == mID) {\\n                memory[i] = -1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920416,
                "title": "c-memory-allocator-beginner-friendly-solution",
                "content": "# Code\\n```\\nclass Allocator {\\npublic:\\n    vector<int>v;\\n    \\n    int cap=0;\\n    Allocator(int n) {\\n        v.resize(1001,-1);\\n        cap=n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        for(int i=0;i<cap;i++){\\n            if(v[i]==-1){\\n               \\n               int len=0,j=i;\\n                while(v[i]==-1 && i<cap && len<size){\\n                   i++;\\n                   len++;\\n                }\\n                if(size==len){\\n                   for(int k=j;k<i;k++){\\n                       v[k]=mID;\\n                   }\\n                   return j;\\n                }\\n\\n            }\\n        }\\n         \\n       return -1; \\n    }\\n    \\n    int free(int mID) {\\n        int res=0;\\n     \\n      for(int i=0;i<cap;i++){\\n          if(v[i]==mID){\\n              v[i]=-1;\\n              res++;\\n          }\\n      }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    vector<int>v;\\n    \\n    int cap=0;\\n    Allocator(int n) {\\n        v.resize(1001,-1);\\n        cap=n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        for(int i=0;i<cap;i++){\\n            if(v[i]==-1){\\n               \\n               int len=0,j=i;\\n                while(v[i]==-1 && i<cap && len<size){\\n                   i++;\\n                   len++;\\n                }\\n                if(size==len){\\n                   for(int k=j;k<i;k++){\\n                       v[k]=mID;\\n                   }\\n                   return j;\\n                }\\n\\n            }\\n        }\\n         \\n       return -1; \\n    }\\n    \\n    int free(int mID) {\\n        int res=0;\\n     \\n      for(int i=0;i<cap;i++){\\n          if(v[i]==mID){\\n              v[i]=-1;\\n              res++;\\n          }\\n      }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919345,
                "title": "brute-force-java",
                "content": "```\\nclass Allocator {\\n  public boolean checkFreeSpace(int index,int[]array,int size){\\n    int i=index;\\n    while(size>0&&i<array.length){\\n      if(array[i++]!=0)break;\\n      size--;\\n    }\\n    return size==0?true:false;\\n  }\\n  \\n   private int[]array;\\n    public Allocator(int n) {\\n        array=new int[n];\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n     int index=-1;\\n      boolean ic=false;\\n      for(int i=0;i<array.length&&ic==false;i++){\\n        if(checkFreeSpace(i,array,size)){\\n        for(int j=i;i<array.length&&size>0;i++){\\n          ic=true;\\n          if(array[i]==0){ \\n          array[i]=mID;\\n          if(index==-1){\\n            index=i;\\n          }\\n        size--;\\n         }    \\n       }\\n     }\\n  }\\n      return index;\\n}\\n    \\n    public int free(int mID) {\\n      int count=0;\\n        for(int i=0;i<array.length;i++){\\n          if(array[i]==mID){\\n            array[i]=0;\\n            count++;\\n          }\\n        }\\n      return count;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Design"
                ],
                "code": "```\\nclass Allocator {\\n  public boolean checkFreeSpace(int index,int[]array,int size){\\n    int i=index;\\n    while(size>0&&i<array.length){\\n      if(array[i++]!=0)break;\\n      size--;\\n    }\\n    return size==0?true:false;\\n  }\\n  \\n   private int[]array;\\n    public Allocator(int n) {\\n        array=new int[n];\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n     int index=-1;\\n      boolean ic=false;\\n      for(int i=0;i<array.length&&ic==false;i++){\\n        if(checkFreeSpace(i,array,size)){\\n        for(int j=i;i<array.length&&size>0;i++){\\n          ic=true;\\n          if(array[i]==0){ \\n          array[i]=mID;\\n          if(index==-1){\\n            index=i;\\n          }\\n        size--;\\n         }    \\n       }\\n     }\\n  }\\n      return index;\\n}\\n    \\n    public int free(int mID) {\\n      int count=0;\\n        for(int i=0;i<array.length;i++){\\n          if(array[i]==mID){\\n            array[i]=0;\\n            count++;\\n          }\\n        }\\n      return count;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918956,
                "title": "dart",
                "content": "# Complexity\\n$n$ = number of calls to `allocate()` over the program\\'s lifespan.\\n\\n- Time complexity:\\n  - `allocate()`: $$O(n)$$, where $n$ = number of calls to `allocate()`\\n  - `free()`: $$O(nlogn)$$, because it sorts the freelist after inserting entries. With additional code, this could be reduced to $O(n + mlogn)$, where $m$ = the number of regions being freed.\\n\\n- Space complexity: $O(n)$, where $n$ = # of calls to `allocate()`\\n\\n# Code\\n```dart\\nclass Region {\\n  int offset;\\n  int size;\\n  Region(this.offset, this.size);\\n  // For debugging.\\n  String toString() => \\'$offset:$size\\';\\n}\\n\\nclass Allocator {\\n  final List<Region> _freeList;\\n  final Map<int, List<Region>> _allocated;\\n\\n  Allocator(int n) : \\n    _freeList = [Region(0, n)], \\n    _allocated = <int, List<Region>>{};\\n  \\n  int allocate(int size, int mID) {\\n    for (var i = 0; i < _freeList.length; i++) {\\n      if (_freeList[i].size >= size) {\\n        final offset = _freeList[i].offset;\\n        _allocated.update(mID,\\n          (regionList) {\\n            regionList.add(Region(offset, size));\\n            return regionList;\\n          },\\n          ifAbsent: () => [Region(offset, size)]);\\n        // This will sometimes leave a region with size 0 in the freelist.\\n        // That\\'s ok - we\\'ll clean it up when free() is called, rather than\\n        // paying O(n) to shift elements around here.\\n        _freeList[i].offset += size;\\n        _freeList[i].size -= size;\\n        return offset;\\n      }\\n    }\\n    return -1;\\n  }\\n  \\n  int free(int mID) {\\n    var regionsToFree = _allocated.remove(mID);\\n    if (regionsToFree == null) {\\n      return 0;\\n    }\\n    var freedUnits = 0;\\n    for (final r in regionsToFree) {\\n      freedUnits += r.size;\\n    }\\n    _freeList.addAll(regionsToFree);\\n    _freeList.sort((a, b) => a.offset - b.offset);\\n    cleanFreeList();\\n    return freedUnits;\\n  }\\n\\n  // Do a linear pass through the free list to:\\n  // - Remove 0-sized regions\\n  // - Merge adjacent regions\\n  void cleanFreeList() {\\n    var src = 0, dst = 0;\\n    for (var src = 0; src < _freeList.length; src++) {\\n      // Skip overlapping regions\\n      if (_freeList[src].size == 0) {\\n        continue;\\n      }\\n      // Consolidate adjacent regions.\\n      var prev = dst - 1;\\n      if (prev >= 0 &&  \\n          (_freeList[prev].offset + _freeList[prev].size) == _freeList[src].offset) {\\n        _freeList[prev].size += _freeList[src].size;\\n        continue;\\n      }\\n      if (src != dst) {\\n        _freeList[dst] = _freeList[src];\\n      }\\n      dst++;\\n    }\\n    _freeList.length = dst;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```dart\\nclass Region {\\n  int offset;\\n  int size;\\n  Region(this.offset, this.size);\\n  // For debugging.\\n  String toString() => \\'$offset:$size\\';\\n}\\n\\nclass Allocator {\\n  final List<Region> _freeList;\\n  final Map<int, List<Region>> _allocated;\\n\\n  Allocator(int n) : \\n    _freeList = [Region(0, n)], \\n    _allocated = <int, List<Region>>{};\\n  \\n  int allocate(int size, int mID) {\\n    for (var i = 0; i < _freeList.length; i++) {\\n      if (_freeList[i].size >= size) {\\n        final offset = _freeList[i].offset;\\n        _allocated.update(mID,\\n          (regionList) {\\n            regionList.add(Region(offset, size));\\n            return regionList;\\n          },\\n          ifAbsent: () => [Region(offset, size)]);\\n        // This will sometimes leave a region with size 0 in the freelist.\\n        // That\\'s ok - we\\'ll clean it up when free() is called, rather than\\n        // paying O(n) to shift elements around here.\\n        _freeList[i].offset += size;\\n        _freeList[i].size -= size;\\n        return offset;\\n      }\\n    }\\n    return -1;\\n  }\\n  \\n  int free(int mID) {\\n    var regionsToFree = _allocated.remove(mID);\\n    if (regionsToFree == null) {\\n      return 0;\\n    }\\n    var freedUnits = 0;\\n    for (final r in regionsToFree) {\\n      freedUnits += r.size;\\n    }\\n    _freeList.addAll(regionsToFree);\\n    _freeList.sort((a, b) => a.offset - b.offset);\\n    cleanFreeList();\\n    return freedUnits;\\n  }\\n\\n  // Do a linear pass through the free list to:\\n  // - Remove 0-sized regions\\n  // - Merge adjacent regions\\n  void cleanFreeList() {\\n    var src = 0, dst = 0;\\n    for (var src = 0; src < _freeList.length; src++) {\\n      // Skip overlapping regions\\n      if (_freeList[src].size == 0) {\\n        continue;\\n      }\\n      // Consolidate adjacent regions.\\n      var prev = dst - 1;\\n      if (prev >= 0 &&  \\n          (_freeList[prev].offset + _freeList[prev].size) == _freeList[src].offset) {\\n        _freeList[prev].size += _freeList[src].size;\\n        continue;\\n      }\\n      if (src != dst) {\\n        _freeList[dst] = _freeList[src];\\n      }\\n      dst++;\\n    }\\n    _freeList.length = dst;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918934,
                "title": "c-linkedlist",
                "content": "Use the `LinkedList` type to store our allocations. Each element in the list has 3 properties:\\n\\n1. **Index** - Start of the block\\n2. **Id** - Id of allocator or -1 it the block is available\\n3. **Size** - Number of units in the block\\n\\nThe constructor adds a single available range of specified size.\\n\\n* Runtime: O(1)\\n\\nThe `Allocate` function traverses the linked list, searching for an available block large enough to allocate. The available block is removed from the list and an allocated block is added. If more memory is available, a smaller available block is added.\\n\\n* Runtime: O(n)\\n\\nThe `Free` function traverses the linked list, searching for blocks allocated to the specified id and replacing them with available blocks. A second pass is made to merge adjacent available blocks.\\n\\n* Runtime: O(n)\\n\\n```\\npublic class Allocator\\n{\\n    private const int AVAILABLE = -1;\\n    \\n    private readonly LinkedList<Block> blocks = new LinkedList<Block>();\\n\\n    public Allocator(int n)\\n    {\\n        blocks.AddFirst(new Block(0, AVAILABLE, n));\\n    }\\n    \\n    public int Allocate(int size, int mID)\\n    {\\n        for (var block = blocks.First; block != null; )\\n        {\\n            var next = block.Next;\\n            if (block.Value.Id == AVAILABLE && block.Value.Size >= size)\\n            {\\n                blocks.AddBefore(block, new Block(block.Value.Index, mID, size));\\n                if (block.Value.Size > size)\\n                {\\n                    blocks.AddBefore(block, new Block(block.Value.Index + size, AVAILABLE, block.Value.Size - size));\\n                }\\n                blocks.Remove(block);\\n                return block.Value.Index;\\n            }\\n            block = next;\\n        }\\n        return -1;\\n    }\\n    \\n    public int Free(int mID)\\n    {\\n        int freed = 0;\\n        \\n        // 1) replace blocks w/ available blocks\\n        for (var block = blocks.First; block != null; )\\n        {\\n            var next = block.Next;\\n            if (block.Value.Id == mID)\\n            {\\n                freed += block.Value.Size;\\n                blocks.AddBefore(block, new Block(block.Value.Index, AVAILABLE, block.Value.Size));\\n                blocks.Remove(block);\\n            }\\n            block = next;\\n        }\\n        \\n        // 2) merge available blocks\\n        for (var block = blocks.First; block != null; )\\n        {\\n            var next = block.Next;\\n            if (block.Value.Id == AVAILABLE && next?.Value.Id == AVAILABLE)\\n            {\\n                var merged = blocks.AddBefore(block, new Block(block.Value.Index, AVAILABLE, block.Value.Size + next.Value.Size));\\n                blocks.Remove(block);\\n                blocks.Remove(next);\\n                next = merged;\\n            }\\n            block = next;\\n        }\\n        \\n        return freed;\\n    }\\n    \\n    private struct Block\\n    {\\n        public readonly int Index;\\n        public readonly int Id;\\n        public readonly int Size;\\n\\n        public Block(int index, int id, int size)\\n        {\\n            Index = index;\\n            Id = id;\\n            Size = size;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\npublic class Allocator\\n{\\n    private const int AVAILABLE = -1;\\n    \\n    private readonly LinkedList<Block> blocks = new LinkedList<Block>();\\n\\n    public Allocator(int n)\\n    {\\n        blocks.AddFirst(new Block(0, AVAILABLE, n));\\n    }\\n    \\n    public int Allocate(int size, int mID)\\n    {\\n        for (var block = blocks.First; block != null; )\\n        {\\n            var next = block.Next;\\n            if (block.Value.Id == AVAILABLE && block.Value.Size >= size)\\n            {\\n                blocks.AddBefore(block, new Block(block.Value.Index, mID, size));\\n                if (block.Value.Size > size)\\n                {\\n                    blocks.AddBefore(block, new Block(block.Value.Index + size, AVAILABLE, block.Value.Size - size));\\n                }\\n                blocks.Remove(block);\\n                return block.Value.Index;\\n            }\\n            block = next;\\n        }\\n        return -1;\\n    }\\n    \\n    public int Free(int mID)\\n    {\\n        int freed = 0;\\n        \\n        // 1) replace blocks w/ available blocks\\n        for (var block = blocks.First; block != null; )\\n        {\\n            var next = block.Next;\\n            if (block.Value.Id == mID)\\n            {\\n                freed += block.Value.Size;\\n                blocks.AddBefore(block, new Block(block.Value.Index, AVAILABLE, block.Value.Size));\\n                blocks.Remove(block);\\n            }\\n            block = next;\\n        }\\n        \\n        // 2) merge available blocks\\n        for (var block = blocks.First; block != null; )\\n        {\\n            var next = block.Next;\\n            if (block.Value.Id == AVAILABLE && next?.Value.Id == AVAILABLE)\\n            {\\n                var merged = blocks.AddBefore(block, new Block(block.Value.Index, AVAILABLE, block.Value.Size + next.Value.Size));\\n                blocks.Remove(block);\\n                blocks.Remove(next);\\n                next = merged;\\n            }\\n            block = next;\\n        }\\n        \\n        return freed;\\n    }\\n    \\n    private struct Block\\n    {\\n        public readonly int Index;\\n        public readonly int Id;\\n        public readonly int Size;\\n\\n        public Block(int index, int id, int size)\\n        {\\n            Index = index;\\n            Id = id;\\n            Size = size;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917774,
                "title": "two-hashmaps-o-m-logm-o-1-beats-99-concise-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing map to store memory blocks by startIndex (for **allocate**) and mID (for **free**)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Ordered map: All memory blocks: <startIndex, endIndex>\\n- Unordered map: <mID, vector: startIndex>\\n\\n# Complexity\\n- Time complexity: \\n    - allocate: $$O(M*logM)$$, M is the number of all the memory blocks\\n    - free: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    - $$O(M)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nhttps://leetcode.com/problems/design-memory-allocator/submissions/860620092/\\n\\n# Code\\n```\\nclass Allocator {\\nprivate:\\n    map<int, int> map; // All memory blocks: <startIndex, endIndex>, e.g. [s, e) e-s=size\\n    unordered_map<int, vector<int>> idMap; // <mID, vector: startIndex>\\npublic:\\n    Allocator(int n) {\\n        map[n] = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int start = 0;\\n        for (auto [k, v] : map) {\\n            if (k - start >= size) {\\n                map[start] = start + size;\\n                idMap[mID].push_back(start);\\n                return start;\\n            } else {\\n                start = v;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        if (idMap.find(mID) == idMap.end()) return 0;\\n        int ans = 0;\\n        for (int s : idMap[mID]) {\\n            ans += (map[s] - s);\\n            map.erase(s);\\n        }\\n        idMap.erase(mID);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\nprivate:\\n    map<int, int> map; // All memory blocks: <startIndex, endIndex>, e.g. [s, e) e-s=size\\n    unordered_map<int, vector<int>> idMap; // <mID, vector: startIndex>\\npublic:\\n    Allocator(int n) {\\n        map[n] = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int start = 0;\\n        for (auto [k, v] : map) {\\n            if (k - start >= size) {\\n                map[start] = start + size;\\n                idMap[mID].push_back(start);\\n                return start;\\n            } else {\\n                start = v;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        if (idMap.find(mID) == idMap.end()) return 0;\\n        int ans = 0;\\n        for (int s : idMap[mID]) {\\n            ans += (map[s] - s);\\n            map.erase(s);\\n        }\\n        idMap.erase(mID);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915460,
                "title": "python-array-solution",
                "content": "# Approach\\nUse two arry, one is for memory and another one is to store consecusive avaiable spot count. \\n\\n\\n# Code\\n```\\nclass Allocator(object):\\n\\n    def __init__(self, n):\\n        \"\"\"\\n        :type n: int\\n        \"\"\"\\n        self.memory = [0] * n\\n        self.n = n\\n        self.locationSumArr = [i for i in range(n, 0, -1)]\\n        \\n\\n    def allocate(self, size, mID):\\n        \"\"\"\\n        :type size: int\\n        :type mID: int\\n        :rtype: int\\n        \"\"\"\\n        for i in range(self.n):\\n            if self.locationSumArr[i] >= size:\\n                for j in range(size):\\n                    self.memory[i+j] = mID\\n                    self.locationSumArr[i+j] = 0\\n                return i\\n        return -1\\n\\n    def free(self, mID):\\n        \"\"\"\\n        :type mID: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(self.n-1, -1, -1):\\n            if self.memory[i] == mID:\\n                self.memory[i] = 0\\n                count += 1\\n                if i == self.n-1:\\n                    self.locationSumArr[i] = 1    \\n                else:\\n                    self.locationSumArr[i] = self.locationSumArr[i+1] + 1\\n                check = i-1\\n                while self.memory[check] == 0 and check >=0:\\n                    self.locationSumArr[check] = self.locationSumArr[check+1] + 1\\n                    check -= 1\\n        return count\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Allocator(object):\\n\\n    def __init__(self, n):\\n        \"\"\"\\n        :type n: int\\n        \"\"\"\\n        self.memory = [0] * n\\n        self.n = n\\n        self.locationSumArr = [i for i in range(n, 0, -1)]\\n        \\n\\n    def allocate(self, size, mID):\\n        \"\"\"\\n        :type size: int\\n        :type mID: int\\n        :rtype: int\\n        \"\"\"\\n        for i in range(self.n):\\n            if self.locationSumArr[i] >= size:\\n                for j in range(size):\\n                    self.memory[i+j] = mID\\n                    self.locationSumArr[i+j] = 0\\n                return i\\n        return -1\\n\\n    def free(self, mID):\\n        \"\"\"\\n        :type mID: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(self.n-1, -1, -1):\\n            if self.memory[i] == mID:\\n                self.memory[i] = 0\\n                count += 1\\n                if i == self.n-1:\\n                    self.locationSumArr[i] = 1    \\n                else:\\n                    self.locationSumArr[i] = self.locationSumArr[i+1] + 1\\n                check = i-1\\n                while self.memory[check] == 0 and check >=0:\\n                    self.locationSumArr[check] = self.locationSumArr[check+1] + 1\\n                    check -= 1\\n        return count\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913018,
                "title": "two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n   class Allocator {\\n\\n        int a[];\\n\\n        public Allocator(int n) {\\n            a = new int[n];\\n        }\\n        public int allocate(int size, int mID) {\\n            int p1 = 0;\\n            int p2 = 0;\\n            int s = 0;\\n            while (p2 < a.length) {\\n                if (a[p2] == 0) {\\n                    s++;\\n                    p2++;\\n                } else {\\n                    p2++;\\n                    p1 = p2;\\n                    s = 0;\\n                }\\n                if (s == size) {\\n                    for (int i = p1; i < p2; i++) {\\n                        a[i] = mID;\\n                    }\\n                    return p1;\\n                }\\n            }\\n            return -1;\\n        }\\n\\n        public int free(int mID) {\\n            int cnt = 0;\\n            for (int i = 0; i < a.length; i++) {\\n                if (a[i] == mID) {\\n                    cnt++;\\n                    a[i] = 0;\\n                }\\n            }\\n            return cnt;\\n        }\\n    }\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n   class Allocator {\\n\\n        int a[];\\n\\n        public Allocator(int n) {\\n            a = new int[n];\\n        }\\n        public int allocate(int size, int mID) {\\n            int p1 = 0;\\n            int p2 = 0;\\n            int s = 0;\\n            while (p2 < a.length) {\\n                if (a[p2] == 0) {\\n                    s++;\\n                    p2++;\\n                } else {\\n                    p2++;\\n                    p1 = p2;\\n                    s = 0;\\n                }\\n                if (s == size) {\\n                    for (int i = p1; i < p2; i++) {\\n                        a[i] = mID;\\n                    }\\n                    return p1;\\n                }\\n            }\\n            return -1;\\n        }\\n\\n        public int free(int mID) {\\n            int cnt = 0;\\n            for (int i = 0; i < a.length; i++) {\\n                if (a[i] == mID) {\\n                    cnt++;\\n                    a[i] = 0;\\n                }\\n            }\\n            return cnt;\\n        }\\n    }\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912801,
                "title": "c-linked-list-beats-99-time",
                "content": "# Approach\\nStore the intervals which have been added in a linked list. Check if the gap between each pair of consecutive intervals is large enough to add a new one.\\n\\n# Complexity\\n- Time complexity: `O((number of intervals)^2)`\\n\\n- Space complexity: `O(number of intervals)`\\n \\n# Code\\n```\\nstruct Entry {\\n    int id;\\n    int l;\\n    int r;\\n};\\n\\nclass Allocator {\\npublic:\\n    int n; \\n    list <Entry> data;\\n    unordered_map <int, vector<list<Entry>::iterator>> with_id; \\n\\n    Allocator(int _n) {\\n        n = _n; \\n    }\\n    \\n    int allocate(int size, int mID) {\\n        if (data.empty()) {\\n            if (n>=size) {\\n                with_id[mID].push_back(data.insert(data.end(), {mID,0,size-1})); \\n                return 0; \\n            }\\n            return -1; \\n        }\\n        if (data.begin()->l >= size) {\\n            with_id[mID].push_back(data.insert(data.begin(), {mID,0,size-1})); \\n            return 0;\\n        }\\n        for (auto i = data.begin(); i != data.end(); ++i) {\\n            auto j = next(i);\\n            if (j==data.end()) {\\n                if (n - i->r - 1 >= size) {\\n                    with_id[mID].push_back(data.insert(data.end(), {mID, i->r + 1, i->r + size}));\\n                    return i->r+1;\\n                } \\n            }\\n            else {\\n                if (j->l - i->r - 1 >= size) {\\n                    with_id[mID].push_back(data.insert(j, {mID, i->r + 1, i->r + size}));\\n                    return i->r+1;\\n                } \\n            }\\n        }\\n        return -1; \\n    }\\n    \\n    int free(int mID) {\\n        if (with_id.find(mID) == with_id.end()) return 0;\\n        int ans = 0;\\n        for (auto i : with_id[mID]) {\\n            ans += i->r - i->l + 1;\\n            data.erase(i);\\n        }\\n        with_id.erase(mID); \\n        return ans; \\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nstruct Entry {\\n    int id;\\n    int l;\\n    int r;\\n};\\n\\nclass Allocator {\\npublic:\\n    int n; \\n    list <Entry> data;\\n    unordered_map <int, vector<list<Entry>::iterator>> with_id; \\n\\n    Allocator(int _n) {\\n        n = _n; \\n    }\\n    \\n    int allocate(int size, int mID) {\\n        if (data.empty()) {\\n            if (n>=size) {\\n                with_id[mID].push_back(data.insert(data.end(), {mID,0,size-1})); \\n                return 0; \\n            }\\n            return -1; \\n        }\\n        if (data.begin()->l >= size) {\\n            with_id[mID].push_back(data.insert(data.begin(), {mID,0,size-1})); \\n            return 0;\\n        }\\n        for (auto i = data.begin(); i != data.end(); ++i) {\\n            auto j = next(i);\\n            if (j==data.end()) {\\n                if (n - i->r - 1 >= size) {\\n                    with_id[mID].push_back(data.insert(data.end(), {mID, i->r + 1, i->r + size}));\\n                    return i->r+1;\\n                } \\n            }\\n            else {\\n                if (j->l - i->r - 1 >= size) {\\n                    with_id[mID].push_back(data.insert(j, {mID, i->r + 1, i->r + size}));\\n                    return i->r+1;\\n                } \\n            }\\n        }\\n        return -1; \\n    }\\n    \\n    int free(int mID) {\\n        if (with_id.find(mID) == with_id.end()) return 0;\\n        int ans = 0;\\n        for (auto i : with_id[mID]) {\\n            ans += i->r - i->l + 1;\\n            data.erase(i);\\n        }\\n        with_id.erase(mID); \\n        return ans; \\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911960,
                "title": "java-solution-using-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport javax.sound.midi.MidiChannel;\\n\\nclass Allocator {\\n    int arr[];\\n\\n    public Allocator(int n) {\\n        arr = new int[n];\\n        Arrays.fill(arr, -1);\\n    }\\n\\n    public int allocate(int size, int mID) {\\n        int count=0;\\n        int i,start=0,end=0;\\n        if(size>arr.length)\\n        return -1;\\n        for(i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==-1)\\n            count++;\\n            else\\n            {\\n                count=0;\\n                start=i+1;\\n            }\\n            if(count==size)\\n            {\\n                end=i;\\n                break;\\n            }\\n        }\\n        if(start>end)\\n        return -1;\\n        Arrays.fill(arr,start,Math.min(end+1,arr.length),mID);\\n        return start;\\n    }\\n\\n    public int free(int mID) {\\n        int count=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==mID)\\n            {\\n                arr[i]=-1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport javax.sound.midi.MidiChannel;\\n\\nclass Allocator {\\n    int arr[];\\n\\n    public Allocator(int n) {\\n        arr = new int[n];\\n        Arrays.fill(arr, -1);\\n    }\\n\\n    public int allocate(int size, int mID) {\\n        int count=0;\\n        int i,start=0,end=0;\\n        if(size>arr.length)\\n        return -1;\\n        for(i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==-1)\\n            count++;\\n            else\\n            {\\n                count=0;\\n                start=i+1;\\n            }\\n            if(count==size)\\n            {\\n                end=i;\\n                break;\\n            }\\n        }\\n        if(start>end)\\n        return -1;\\n        Arrays.fill(arr,start,Math.min(end+1,arr.length),mID);\\n        return start;\\n    }\\n\\n    public int free(int mID) {\\n        int count=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==mID)\\n            {\\n                arr[i]=-1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910505,
                "title": "swift-solution-for-memory-allocator",
                "content": "\\n\\nclass Allocator {\\n    \\n\\n    var memoryArray = [Int]()\\n\\n    init(_ n: Int) {\\n        \\n        memoryArray = Array(repeating: 0, count: n)\\n        \\n    }\\n    \\n    func allocate(_ size: Int, _ mID: Int) -> Int {\\n        \\n        \\n        let startIndex = checkFreeBlock(memoryArray: memoryArray, size: size)\\n        \\n        if startIndex != -1{\\n            \\n            fillMemory(size: size, mID: mID, startIndex: startIndex)\\n        }\\n        \\n        return startIndex\\n    }\\n    \\n    func fillMemory(size: Int,mID: Int,startIndex:Int){\\n        \\n        for i in startIndex..<(startIndex + size){\\n            \\n            memoryArray[i] = mID\\n        }\\n     \\n    }\\n    \\n    \\n    \\n    func checkFreeBlock(memoryArray:[Int],size:Int)->Int{\\n        \\n        var start = -1\\n        var index = 0\\n        var counter = 0\\n        \\n        \\n        for i in 0..<memoryArray.count{\\n            \\n           \\n            \\n            if start == -1 && memoryArray[i] == 0{\\n                \\n                start = i\\n                index = i + 1\\n                counter += 1\\n                \\n                \\n            } else if memoryArray[i] == 0 && i == index{\\n                \\n                index += 1\\n                counter += 1\\n            } else{\\n                \\n                index = -1\\n                start = -1\\n                counter = 0\\n            }\\n            \\n            if counter == size{\\n                \\n                return start\\n            }\\n            \\n            \\n        }\\n        \\n        return -1\\n    }\\n    \\n    func free(_ mID: Int) -> Int {\\n        \\n        var counter = 0\\n        for i in 0..<memoryArray.count{\\n            \\n            if memoryArray[i] == mID{\\n                \\n                counter += 1\\n                memoryArray[i] = 0\\n            }\\n        }\\n\\n        return counter\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * let obj = Allocator(n)\\n * let ret_1: Int = obj.allocate(size, mID)\\n * let ret_2: Int = obj.free(mID)\\n */\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "\\n\\nclass Allocator {\\n    \\n\\n    var memoryArray = [Int]()\\n\\n    init(_ n: Int) {\\n        \\n        memoryArray = Array(repeating: 0, count: n)\\n        \\n    }\\n    \\n    func allocate(_ size: Int, _ mID: Int) -> Int {\\n        \\n        \\n        let startIndex = checkFreeBlock(memoryArray: memoryArray, size: size)\\n        \\n        if startIndex != -1{\\n            \\n            fillMemory(size: size, mID: mID, startIndex: startIndex)\\n        }\\n        \\n        return startIndex\\n    }\\n    \\n    func fillMemory(size: Int,mID: Int,startIndex:Int){\\n        \\n        for i in startIndex..<(startIndex + size){\\n            \\n            memoryArray[i] = mID\\n        }\\n     \\n    }\\n    \\n    \\n    \\n    func checkFreeBlock(memoryArray:[Int],size:Int)->Int{\\n        \\n        var start = -1\\n        var index = 0\\n        var counter = 0\\n        \\n        \\n        for i in 0..<memoryArray.count{\\n            \\n           \\n            \\n            if start == -1 && memoryArray[i] == 0{\\n                \\n                start = i\\n                index = i + 1\\n                counter += 1\\n                \\n                \\n            } else if memoryArray[i] == 0 && i == index{\\n                \\n                index += 1\\n                counter += 1\\n            } else{\\n                \\n                index = -1\\n                start = -1\\n                counter = 0\\n            }\\n            \\n            if counter == size{\\n                \\n                return start\\n            }\\n            \\n            \\n        }\\n        \\n        return -1\\n    }\\n    \\n    func free(_ mID: Int) -> Int {\\n        \\n        var counter = 0\\n        for i in 0..<memoryArray.count{\\n            \\n            if memoryArray[i] == mID{\\n                \\n                counter += 1\\n                memoryArray[i] = 0\\n            }\\n        }\\n\\n        return counter\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * let obj = Allocator(n)\\n * let ret_1: Int = obj.allocate(size, mID)\\n * let ret_2: Int = obj.free(mID)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909280,
                "title": "python-linked-list-map-cpu-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLinked list + index map\\n\\n# Complexity\\n- Time complexity:\\nalloc - O(num of allocated items)\\nfree - O(num of freed items)\\n\\n- Space complexity:\\n0(num of allocated items)\\n\\n# Code\\n```\\nclass Allocator:\\n    class AllocNode:\\n        def __init__(self, start: int, size: int):\\n            self.start = start\\n            self.size = size\\n            self.next = None\\n            self.prev = None\\n\\n\\n    def __init__(self, n: int):\\n        self.size = n\\n        self.alloc = Allocator.AllocNode(0,0)\\n        self.allocMap = {}\\n        self.freeMem = n\\n\\n\\n    def addAllocNode(self, prev: AllocNode, size: int, mID: int):\\n        node = Allocator.AllocNode(prev.start + prev.size, size)\\n        node.next = prev.next\\n        node.prev = prev\\n\\n        if prev.next:\\n            prev.next.prev = node\\n        prev.next = node\\n        if mID not in self.allocMap:\\n            self.allocMap[mID] = []\\n\\n        self.allocMap[mID].append(node)\\n        return node.start\\n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        if size > self.freeMem:\\n            return -1\\n\\n        node = self.alloc\\n        while node:\\n            if (not node.next) and ((self.size - node.start - node.size) >= size):\\n                return self.addAllocNode(node, size, mID)\\n\\n            if node.next and ((node.next.start - node.start - node.size) >= size):\\n                return self.addAllocNode(node, size, mID)\\n\\n            node = node.next\\n\\n        return -1\\n\\n\\n    def free(self, mID: int) -> int:\\n        nodes = self.allocMap.get(mID)\\n        if not nodes:\\n            return 0\\n\\n        res = 0\\n        for node in nodes:\\n            node.prev.next = node.next\\n            if node.next:\\n                node.next.prev = node.prev\\n            res += node.size\\n\\n        del self.allocMap[mID]\\n        self.freeMem += res\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n    class AllocNode:\\n        def __init__(self, start: int, size: int):\\n            self.start = start\\n            self.size = size\\n            self.next = None\\n            self.prev = None\\n\\n\\n    def __init__(self, n: int):\\n        self.size = n\\n        self.alloc = Allocator.AllocNode(0,0)\\n        self.allocMap = {}\\n        self.freeMem = n\\n\\n\\n    def addAllocNode(self, prev: AllocNode, size: int, mID: int):\\n        node = Allocator.AllocNode(prev.start + prev.size, size)\\n        node.next = prev.next\\n        node.prev = prev\\n\\n        if prev.next:\\n            prev.next.prev = node\\n        prev.next = node\\n        if mID not in self.allocMap:\\n            self.allocMap[mID] = []\\n\\n        self.allocMap[mID].append(node)\\n        return node.start\\n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        if size > self.freeMem:\\n            return -1\\n\\n        node = self.alloc\\n        while node:\\n            if (not node.next) and ((self.size - node.start - node.size) >= size):\\n                return self.addAllocNode(node, size, mID)\\n\\n            if node.next and ((node.next.start - node.start - node.size) >= size):\\n                return self.addAllocNode(node, size, mID)\\n\\n            node = node.next\\n\\n        return -1\\n\\n\\n    def free(self, mID: int) -> int:\\n        nodes = self.allocMap.get(mID)\\n        if not nodes:\\n            return 0\\n\\n        res = 0\\n        for node in nodes:\\n            node.prev.next = node.next\\n            if node.next:\\n                node.next.prev = node.prev\\n            res += node.size\\n\\n        del self.allocMap[mID]\\n        self.freeMem += res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909196,
                "title": "go-list-map-100-cpu-90-mem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLinked list + index map\\n\\n# Complexity\\n- Time complexity:\\nAlloc - O(num of allocated items)\\nFree - O(num of freed items)\\n\\n- Space complexity:\\nO(num of allocated items)\\n\\n# Code\\n```\\ntype AllocNode struct {\\n\\tprev  *AllocNode\\n\\tnext  *AllocNode\\n\\tstart int\\n\\tsize  int\\n}\\n\\ntype Allocator struct {\\n\\tallocMap map[int][]*AllocNode\\n\\talloc    *AllocNode\\n\\tsize     int\\n\\tfree     int\\n}\\n\\nfunc Constructor(n int) Allocator {\\n\\treturn Allocator{\\n\\t\\tallocMap: make(map[int][]*AllocNode),\\n\\t\\tsize:     n,\\n\\t\\tfree:     n,\\n\\t\\talloc:    &AllocNode{},\\n\\t}\\n}\\n\\nfunc (al *Allocator) AddAllocNode(prev *AllocNode, size int, mID int) int {\\n\\tnode := &AllocNode{\\n\\t\\tsize:  size,\\n\\t\\tprev:  prev,\\n\\t\\tnext:  prev.next,\\n\\t\\tstart: prev.start + prev.size,\\n\\t}\\n\\tif prev.next != nil {\\n\\t\\tprev.next.prev = node\\n\\t}\\n\\tprev.next = node\\n\\tif v, ok := al.allocMap[mID]; ok {\\n\\t\\tal.allocMap[mID] = append(v, node)\\n\\t} else {\\n\\t\\tal.allocMap[mID] = []*AllocNode{node}\\n\\t}\\n\\tal.free = al.free - size\\n\\treturn node.start\\n}\\n\\nfunc (al *Allocator) Allocate(size int, mID int) int {\\n\\tif size > al.free {\\n\\t\\treturn -1\\n\\t}\\n\\tnode := al.alloc\\n\\tfor node != nil {\\n\\t\\tif (node.next == nil) && ((al.size - node.start - node.size) >= size) {\\n\\t\\t\\treturn al.AddAllocNode(node, size, mID)\\n\\t\\t}\\n\\t\\tif (node.next != nil) && ((node.next.start - node.start - node.size) >= size) {\\n\\t\\t\\treturn al.AddAllocNode(node, size, mID)\\n\\t\\t}\\n\\t\\tnode = node.next\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc (al *Allocator) Free(mID int) int {\\n\\tres := 0\\n\\tfor _, node := range al.allocMap[mID] {\\n\\t\\tnode.prev.next = node.next\\n\\t\\tif node.next != nil {\\n\\t\\t\\tnode.next.prev = node.prev\\n\\t\\t}\\n\\t\\tres = res + node.size\\n\\t}\\n\\tdelete(al.allocMap, mID)\\n    al.free = al.free + res\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype AllocNode struct {\\n\\tprev  *AllocNode\\n\\tnext  *AllocNode\\n\\tstart int\\n\\tsize  int\\n}\\n\\ntype Allocator struct {\\n\\tallocMap map[int][]*AllocNode\\n\\talloc    *AllocNode\\n\\tsize     int\\n\\tfree     int\\n}\\n\\nfunc Constructor(n int) Allocator {\\n\\treturn Allocator{\\n\\t\\tallocMap: make(map[int][]*AllocNode),\\n\\t\\tsize:     n,\\n\\t\\tfree:     n,\\n\\t\\talloc:    &AllocNode{},\\n\\t}\\n}\\n\\nfunc (al *Allocator) AddAllocNode(prev *AllocNode, size int, mID int) int {\\n\\tnode := &AllocNode{\\n\\t\\tsize:  size,\\n\\t\\tprev:  prev,\\n\\t\\tnext:  prev.next,\\n\\t\\tstart: prev.start + prev.size,\\n\\t}\\n\\tif prev.next != nil {\\n\\t\\tprev.next.prev = node\\n\\t}\\n\\tprev.next = node\\n\\tif v, ok := al.allocMap[mID]; ok {\\n\\t\\tal.allocMap[mID] = append(v, node)\\n\\t} else {\\n\\t\\tal.allocMap[mID] = []*AllocNode{node}\\n\\t}\\n\\tal.free = al.free - size\\n\\treturn node.start\\n}\\n\\nfunc (al *Allocator) Allocate(size int, mID int) int {\\n\\tif size > al.free {\\n\\t\\treturn -1\\n\\t}\\n\\tnode := al.alloc\\n\\tfor node != nil {\\n\\t\\tif (node.next == nil) && ((al.size - node.start - node.size) >= size) {\\n\\t\\t\\treturn al.AddAllocNode(node, size, mID)\\n\\t\\t}\\n\\t\\tif (node.next != nil) && ((node.next.start - node.start - node.size) >= size) {\\n\\t\\t\\treturn al.AddAllocNode(node, size, mID)\\n\\t\\t}\\n\\t\\tnode = node.next\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc (al *Allocator) Free(mID int) int {\\n\\tres := 0\\n\\tfor _, node := range al.allocMap[mID] {\\n\\t\\tnode.prev.next = node.next\\n\\t\\tif node.next != nil {\\n\\t\\t\\tnode.next.prev = node.prev\\n\\t\\t}\\n\\t\\tres = res + node.size\\n\\t}\\n\\tdelete(al.allocMap, mID)\\n    al.free = al.free + res\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2909131,
                "title": "clean-fast-python3-w-ranges-faster-than-99",
                "content": "Please upvote if it helps!\\n```\\nclass Allocator:\\n    def __init__(self, n: int):\\n        # initialize with placeholders to make edge cases easier\\n        self.mem = [(-1, -1, -1), (n, n, -1)]\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        for i in range(1, len(self.mem)):\\n            l0, r0, m0 = self.mem[i-1]\\n            l1, r1, m1 = self.mem[i]\\n            if l1 - r0 > size:\\n                self.mem.insert(i, (r0+1, r0+size, mID))\\n                return r0 + 1\\n        return -1\\n            \\n    def free(self, mID: int) -> int:\\n        removed, mem2 = 0, []\\n        for rng in self.mem:\\n            if rng[2] != mID:\\n                mem2.append(rng)\\n            else:\\n                removed += rng[1] - rng[0] + 1\\n        self.mem = mem2\\n        return removed",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Please upvote if it helps!\\n```\\nclass Allocator:\\n    def __init__(self, n: int):\\n        # initialize with placeholders to make edge cases easier\\n        self.mem = [(-1, -1, -1), (n, n, -1)]\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        for i in range(1, len(self.mem)):\\n            l0, r0, m0 = self.mem[i-1]\\n            l1, r1, m1 = self.mem[i]\\n            if l1 - r0 > size:\\n                self.mem.insert(i, (r0+1, r0+size, mID))\\n                return r0 + 1\\n        return -1\\n            \\n    def free(self, mID: int) -> int:\\n        removed, mem2 = 0, []\\n        for rng in self.mem:\\n            if rng[2] != mID:\\n                mem2.append(rng)\\n            else:\\n                removed += rng[1] - rng[0] + 1\\n        self.mem = mem2\\n        return removed",
                "codeTag": "Java"
            },
            {
                "id": 2909023,
                "title": "java-easy-array-map-solution",
                "content": "# Code\\n```\\nclass Allocator {\\n    \\n    private int[] memory;\\n    private Map<Integer, List<int[]>> map; // mID, List of {start, end}\\n\\n    public Allocator(int n) {\\n        this.memory = new int[n];\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public int allocate(int size, int mID) {   \\n        int start = 0, bound = 0;\\n        do {\\n            if ((start = findNextFree(bound)) == -1) return -1;  \\n            bound = findNextOccupied(start);\\n        } while (bound >= 0 && start + size - 1 >= bound);\\n\\n        if (start + size - 1 >= memory.length) {\\n            return -1;\\n        }\\n        fillMemory(start, start + size - 1, mID);\\n        map.computeIfAbsent(mID, k -> new ArrayList<>()).add(new int[]{start, start + size - 1});\\n        return start;\\n    }\\n    \\n    public int free(int mID) {\\n        int ans = 0;\\n        List<int[]> indices = map.remove(mID);\\n        if (indices == null) return ans;\\n        for (int[] index : indices) {\\n            int start = index[0], end = index[1];\\n            clearMemory(start, end);\\n            ans += end - start + 1;\\n        }\\n        return ans;\\n    }\\n\\n    private int findNextFree(int index) {\\n        for (; index < memory.length; ++index) {\\n            if (memory[index] == 0) return index;\\n        }\\n        return -1;\\n    }\\n\\n    private int findNextOccupied(int index) {\\n        for (; index < memory.length; ++index) {\\n            if (memory[index] > 0) return index;\\n        }\\n        return -1;\\n    }\\n\\n    private void fillMemory(int start, int end, int mID) {\\n        for (; start <= end; ++start) {\\n            memory[start] = mID;\\n        }\\n    }\\n\\n    private void clearMemory(int start, int end) {\\n        for (; start <= end; ++start) {\\n            memory[start] = 0;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Allocator {\\n    \\n    private int[] memory;\\n    private Map<Integer, List<int[]>> map; // mID, List of {start, end}\\n\\n    public Allocator(int n) {\\n        this.memory = new int[n];\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public int allocate(int size, int mID) {   \\n        int start = 0, bound = 0;\\n        do {\\n            if ((start = findNextFree(bound)) == -1) return -1;  \\n            bound = findNextOccupied(start);\\n        } while (bound >= 0 && start + size - 1 >= bound);\\n\\n        if (start + size - 1 >= memory.length) {\\n            return -1;\\n        }\\n        fillMemory(start, start + size - 1, mID);\\n        map.computeIfAbsent(mID, k -> new ArrayList<>()).add(new int[]{start, start + size - 1});\\n        return start;\\n    }\\n    \\n    public int free(int mID) {\\n        int ans = 0;\\n        List<int[]> indices = map.remove(mID);\\n        if (indices == null) return ans;\\n        for (int[] index : indices) {\\n            int start = index[0], end = index[1];\\n            clearMemory(start, end);\\n            ans += end - start + 1;\\n        }\\n        return ans;\\n    }\\n\\n    private int findNextFree(int index) {\\n        for (; index < memory.length; ++index) {\\n            if (memory[index] == 0) return index;\\n        }\\n        return -1;\\n    }\\n\\n    private int findNextOccupied(int index) {\\n        for (; index < memory.length; ++index) {\\n            if (memory[index] > 0) return index;\\n        }\\n        return -1;\\n    }\\n\\n    private void fillMemory(int start, int end, int mID) {\\n        for (; start <= end; ++start) {\\n            memory[start] = mID;\\n        }\\n    }\\n\\n    private void clearMemory(int start, int end) {\\n        for (; start <= end; ++start) {\\n            memory[start] = 0;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908798,
                "title": "java-treemap-and-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator {\\n    TreeMap<Integer,Integer> idxVal = new TreeMap<>();\\n    HashMap<Integer,List<Integer>> valIdx = new HashMap<>();\\n    int maxSize = 0;\\n    public Allocator(int n) {\\n        maxSize = n;\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int pre = -1;\\n        \\n        for(Integer idx : idxVal.keySet()){\\n            if(idx - pre -1>= size){\\n                break;\\n            }\\n            pre = idx;\\n        }\\n        //the first time idxVal is Empty. pre must be -1\\n        if(pre == -1 && maxSize - pre - 1 <size){\\n             return -1;\\n        }\\n        if(pre!=-1 && pre == idxVal.lastKey() && maxSize - pre - 1 <size){\\n            return -1;\\n        }\\n        // populate from pre+ 1\\n        for(int i = pre + 1;i<size+ pre+1;i++){\\n            idxVal.put(i,mID);\\n            valIdx.putIfAbsent(mID,new ArrayList<>());\\n            valIdx.get(mID).add(i);\\n        }\\n        return pre+1;\\n    }\\n    \\n    public int free(int mID) {\\n        List<Integer> idxes = valIdx.get(mID);\\n        if(idxes == null){\\n            return 0;\\n        }\\n        valIdx.remove(mID);\\n        for(Integer idx : idxes){\\n            idxVal.remove(idx);\\n        }\\n        return idxes.size();\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    TreeMap<Integer,Integer> idxVal = new TreeMap<>();\\n    HashMap<Integer,List<Integer>> valIdx = new HashMap<>();\\n    int maxSize = 0;\\n    public Allocator(int n) {\\n        maxSize = n;\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int pre = -1;\\n        \\n        for(Integer idx : idxVal.keySet()){\\n            if(idx - pre -1>= size){\\n                break;\\n            }\\n            pre = idx;\\n        }\\n        //the first time idxVal is Empty. pre must be -1\\n        if(pre == -1 && maxSize - pre - 1 <size){\\n             return -1;\\n        }\\n        if(pre!=-1 && pre == idxVal.lastKey() && maxSize - pre - 1 <size){\\n            return -1;\\n        }\\n        // populate from pre+ 1\\n        for(int i = pre + 1;i<size+ pre+1;i++){\\n            idxVal.put(i,mID);\\n            valIdx.putIfAbsent(mID,new ArrayList<>());\\n            valIdx.get(mID).add(i);\\n        }\\n        return pre+1;\\n    }\\n    \\n    public int free(int mID) {\\n        List<Integer> idxes = valIdx.get(mID);\\n        if(idxes == null){\\n            return 0;\\n        }\\n        valIdx.remove(mID);\\n        for(Integer idx : idxes){\\n            idxVal.remove(idx);\\n        }\\n        return idxes.size();\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907876,
                "title": "python-3-storing-data-in-right-manner",
                "content": "# Code\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.space={}\\n        self.arr=[]\\n        for i in range(n):\\n            self.arr.append(None)\\n        \\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        ctr=0\\n        flag=False\\n        start=-1\\n        for i in range(len(self.arr)):\\n            if self.arr[i]==None:\\n                if not flag:\\n                    start=i\\n                    flag=True\\n                    ctr=1\\n                else:\\n                    ctr+=1\\n            else:\\n                if ctr>=size and start!=-1:\\n                    break\\n                else:\\n                    flag=False\\n        if ctr>=size and start!=-1:\\n            for i in range(start,start+size):\\n                self.arr[i]=mID\\n                if mID in self.space:\\n                    self.space[mID].append(i)\\n                else:\\n                    self.space[mID]=[i]\\n        #print(self.arr,self.space)\\n        return start if ctr>=size else -1\\n        \\n        \\n        \\n\\n    def free(self, mID: int) -> int:\\n        if mID in self.space:\\n            re=len(self.space[mID])\\n            for i in self.space[mID]:\\n                self.arr[i]=None\\n            del self.space[mID]\\n            return re\\n        #print(self.arr,self.space)\\n        return 0\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.space={}\\n        self.arr=[]\\n        for i in range(n):\\n            self.arr.append(None)\\n        \\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        ctr=0\\n        flag=False\\n        start=-1\\n        for i in range(len(self.arr)):\\n            if self.arr[i]==None:\\n                if not flag:\\n                    start=i\\n                    flag=True\\n                    ctr=1\\n                else:\\n                    ctr+=1\\n            else:\\n                if ctr>=size and start!=-1:\\n                    break\\n                else:\\n                    flag=False\\n        if ctr>=size and start!=-1:\\n            for i in range(start,start+size):\\n                self.arr[i]=mID\\n                if mID in self.space:\\n                    self.space[mID].append(i)\\n                else:\\n                    self.space[mID]=[i]\\n        #print(self.arr,self.space)\\n        return start if ctr>=size else -1\\n        \\n        \\n        \\n\\n    def free(self, mID: int) -> int:\\n        if mID in self.space:\\n            re=len(self.space[mID])\\n            for i in self.space[mID]:\\n                self.arr[i]=None\\n            del self.space[mID]\\n            return re\\n        #print(self.arr,self.space)\\n        return 0\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907803,
                "title": "go-faster-than-100",
                "content": "[Go] Faster than 100% Maintain a allocList (Doubly Linked List) + map[id] -> list pointer for faster access\\n```\\ntype allocationEntry struct {\\n    id      int\\n    size    int\\n    index   int\\n    prev    *allocationEntry\\n    next    *allocationEntry\\n}\\n\\nfunc newAllocationEntry(id, size, index int) *allocationEntry {\\n    return &allocationEntry {\\n        id      : id,\\n        size    : size,\\n        index   : index,\\n        prev    : nil,\\n        next    : nil,\\n    }\\n}\\n\\ntype Allocator struct {\\n    occupied    int\\n    allowed     int\\n    head        *allocationEntry\\n    idToEntry   map[int][]*allocationEntry\\n    enableLog   bool\\n}\\n\\n\\nfunc Constructor(n int) Allocator {\\n    return Allocator {\\n        occupied    : 0,\\n        allowed     : n,\\n        head        : nil,\\n        idToEntry   : make(map[int][]*allocationEntry),\\n        enableLog   : false,\\n    }\\n}\\n\\n\\nfunc (this *Allocator) Allocate(size int, mID int) int {\\n    this.log(\"Allocate\", fmt.Sprint(\"mID = \", mID, \" size = \", size))\\n    defer this.logMemoryState()\\n    if this.occupied + size > this.allowed {\\n        this.log(\"Allocate\", \"Occupancy Exceed\")\\n        return -1\\n    }\\n    if this.head == nil {\\n        this.occupied = size\\n        this.head = newAllocationEntry(mID, size, 0)\\n        this.addToIdMap(mID, this.head)\\n        this.log(\"Allocate\", fmt.Sprint(\"id \", mID, \" allocated at head\"))\\n        return 0\\n    }\\n    startIndex := 0\\n    temp := this.head\\n    inserted := false\\n    var insertNext *allocationEntry = nil\\n    var prev *allocationEntry = nil\\n    for ;temp!=nil; temp=temp.next {\\n        if temp.index - startIndex >= size {\\n            insertNext = temp\\n            break\\n        }\\n        startIndex = temp.index + temp.size\\n        prev = temp\\n    }\\n    this.log(\"Allocate\", fmt.Sprint(\"insertNext = \", insertNext, \" prev = \", prev, \" Start Indx = \", startIndex))\\n    if startIndex + size > this.allowed {\\n        this.log(\"Allocate\", \"Can\\'t really allocate\")\\n        return -1\\n    }\\n    if insertNext == nil {\\n        // Insert at last\\n        newNode := newAllocationEntry(mID, size, startIndex)\\n        newNode.prev = prev\\n        prev.next = newNode\\n        newNode.next = nil\\n        inserted = true\\n        this.addToIdMap(mID, newNode)\\n        this.occupied += size\\n    } else {\\n        newNode := newAllocationEntry(mID, size, startIndex)\\n        if insertNext.prev == nil {\\n            insertNext.prev = newNode\\n            newNode.next = insertNext\\n            newNode.prev = nil\\n            this.head = newNode\\n        } else {\\n            newNode.prev = insertNext.prev\\n            newNode.next = insertNext\\n            newNode.prev.next = newNode\\n            insertNext.prev = newNode\\n        }\\n        inserted = true\\n        this.addToIdMap(mID, newNode)\\n        this.occupied += size\\n    }\\n    if inserted {\\n        return startIndex\\n    }\\n    return -1\\n}\\n\\n\\nfunc (this *Allocator) Free(mID int) int {\\n    this.log(\"Free\", fmt.Sprint(mID))\\n    defer this.logMemoryState()\\n    nodeList, ok := this.idToEntry[mID]\\n    if !ok {\\n        this.log(\"Free\", fmt.Sprint(\"ID not found\"))\\n        return 0\\n    }\\n    this.log(\"Free\", fmt.Sprint(\"NodeList = \", nodeList))\\n    clear := 0\\n    delete(this.idToEntry, mID)\\n    for _, node := range nodeList {\\n        if node == this.head {\\n            this.head = node.next\\n            node.next = nil\\n            if this.head != nil {\\n                this.head.prev = nil\\n            }\\n        } else {\\n            node.prev.next = node.next\\n            if node.next != nil {\\n                node.next.prev = node.prev\\n            }\\n            node.next = nil\\n            node.prev = nil\\n        }\\n        clear += node.size\\n    }\\n    this.occupied -= clear\\n    return clear\\n}\\n\\nfunc (this *Allocator) log(tag, log string) {\\n    if !this.enableLog {\\n        return\\n    }\\n    fmt.Println(\"[\", tag, \"]\", log)\\n}\\n\\nfunc (this *Allocator) logMemoryState() {\\n    if !this.enableLog {\\n        return\\n    }\\n    fmt.Println(\"---------------------\")\\n    fmt.Println(\"[STATE] occupied \", this.occupied, \"map: \", this.idToEntry)\\n    temp := this.head\\n    s := \"\"\\n    for ; temp!=nil; temp = temp.next {\\n        s += \"->\" + fmt.Sprint(temp)\\n    }\\n    fmt.Println(\"[STATE]\", s)\\n    fmt.Println(\"---------------------\")\\n}\\n\\nfunc (this *Allocator) addToIdMap(id int, entry *allocationEntry) {\\n    v, ok := this.idToEntry[id]\\n    if !ok {\\n        v = make([]*allocationEntry, 0)\\n    }\\n    v = append(v, entry)\\n    this.idToEntry[id] = v\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype allocationEntry struct {\\n    id      int\\n    size    int\\n    index   int\\n    prev    *allocationEntry\\n    next    *allocationEntry\\n}\\n\\nfunc newAllocationEntry(id, size, index int) *allocationEntry {\\n    return &allocationEntry {\\n        id      : id,\\n        size    : size,\\n        index   : index,\\n        prev    : nil,\\n        next    : nil,\\n    }\\n}\\n\\ntype Allocator struct {\\n    occupied    int\\n    allowed     int\\n    head        *allocationEntry\\n    idToEntry   map[int][]*allocationEntry\\n    enableLog   bool\\n}\\n\\n\\nfunc Constructor(n int) Allocator {\\n    return Allocator {\\n        occupied    : 0,\\n        allowed     : n,\\n        head        : nil,\\n        idToEntry   : make(map[int][]*allocationEntry),\\n        enableLog   : false,\\n    }\\n}\\n\\n\\nfunc (this *Allocator) Allocate(size int, mID int) int {\\n    this.log(\"Allocate\", fmt.Sprint(\"mID = \", mID, \" size = \", size))\\n    defer this.logMemoryState()\\n    if this.occupied + size > this.allowed {\\n        this.log(\"Allocate\", \"Occupancy Exceed\")\\n        return -1\\n    }\\n    if this.head == nil {\\n        this.occupied = size\\n        this.head = newAllocationEntry(mID, size, 0)\\n        this.addToIdMap(mID, this.head)\\n        this.log(\"Allocate\", fmt.Sprint(\"id \", mID, \" allocated at head\"))\\n        return 0\\n    }\\n    startIndex := 0\\n    temp := this.head\\n    inserted := false\\n    var insertNext *allocationEntry = nil\\n    var prev *allocationEntry = nil\\n    for ;temp!=nil; temp=temp.next {\\n        if temp.index - startIndex >= size {\\n            insertNext = temp\\n            break\\n        }\\n        startIndex = temp.index + temp.size\\n        prev = temp\\n    }\\n    this.log(\"Allocate\", fmt.Sprint(\"insertNext = \", insertNext, \" prev = \", prev, \" Start Indx = \", startIndex))\\n    if startIndex + size > this.allowed {\\n        this.log(\"Allocate\", \"Can\\'t really allocate\")\\n        return -1\\n    }\\n    if insertNext == nil {\\n        // Insert at last\\n        newNode := newAllocationEntry(mID, size, startIndex)\\n        newNode.prev = prev\\n        prev.next = newNode\\n        newNode.next = nil\\n        inserted = true\\n        this.addToIdMap(mID, newNode)\\n        this.occupied += size\\n    } else {\\n        newNode := newAllocationEntry(mID, size, startIndex)\\n        if insertNext.prev == nil {\\n            insertNext.prev = newNode\\n            newNode.next = insertNext\\n            newNode.prev = nil\\n            this.head = newNode\\n        } else {\\n            newNode.prev = insertNext.prev\\n            newNode.next = insertNext\\n            newNode.prev.next = newNode\\n            insertNext.prev = newNode\\n        }\\n        inserted = true\\n        this.addToIdMap(mID, newNode)\\n        this.occupied += size\\n    }\\n    if inserted {\\n        return startIndex\\n    }\\n    return -1\\n}\\n\\n\\nfunc (this *Allocator) Free(mID int) int {\\n    this.log(\"Free\", fmt.Sprint(mID))\\n    defer this.logMemoryState()\\n    nodeList, ok := this.idToEntry[mID]\\n    if !ok {\\n        this.log(\"Free\", fmt.Sprint(\"ID not found\"))\\n        return 0\\n    }\\n    this.log(\"Free\", fmt.Sprint(\"NodeList = \", nodeList))\\n    clear := 0\\n    delete(this.idToEntry, mID)\\n    for _, node := range nodeList {\\n        if node == this.head {\\n            this.head = node.next\\n            node.next = nil\\n            if this.head != nil {\\n                this.head.prev = nil\\n            }\\n        } else {\\n            node.prev.next = node.next\\n            if node.next != nil {\\n                node.next.prev = node.prev\\n            }\\n            node.next = nil\\n            node.prev = nil\\n        }\\n        clear += node.size\\n    }\\n    this.occupied -= clear\\n    return clear\\n}\\n\\nfunc (this *Allocator) log(tag, log string) {\\n    if !this.enableLog {\\n        return\\n    }\\n    fmt.Println(\"[\", tag, \"]\", log)\\n}\\n\\nfunc (this *Allocator) logMemoryState() {\\n    if !this.enableLog {\\n        return\\n    }\\n    fmt.Println(\"---------------------\")\\n    fmt.Println(\"[STATE] occupied \", this.occupied, \"map: \", this.idToEntry)\\n    temp := this.head\\n    s := \"\"\\n    for ; temp!=nil; temp = temp.next {\\n        s += \"->\" + fmt.Sprint(temp)\\n    }\\n    fmt.Println(\"[STATE]\", s)\\n    fmt.Println(\"---------------------\")\\n}\\n\\nfunc (this *Allocator) addToIdMap(id int, entry *allocationEntry) {\\n    v, ok := this.idToEntry[id]\\n    if !ok {\\n        v = make([]*allocationEntry, 0)\\n    }\\n    v = append(v, entry)\\n    this.idToEntry[id] = v\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2907163,
                "title": "java-array-solution-with-comments",
                "content": "# Code\\n```\\nclass Allocator {\\n\\n    int[] arr;\\n\\n    public Allocator(int n) {\\n        arr = new int[n];\\n    }\\n\\n    public int allocate(int size, int mID) {\\n        int startInd = -1;\\n        int freeSize = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                freeSize++;\\n            } else {\\n                freeSize = 0;\\n            }\\n            if (freeSize == size) {\\n                startInd = (i - size) + 1;\\n                break;\\n            }\\n        }\\n        if (startInd != -1) {\\n            for (int i = startInd; i <= startInd + size - 1; i++) {\\n                arr[i] = mID;\\n            }\\n        }\\n        return startInd;\\n    }\\n\\n    public int free(int mID) {\\n        int freed = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == mID) {\\n                arr[i] = 0;\\n                freed++;\\n            }\\n        }\\n        return freed;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n\\n    int[] arr;\\n\\n    public Allocator(int n) {\\n        arr = new int[n];\\n    }\\n\\n    public int allocate(int size, int mID) {\\n        int startInd = -1;\\n        int freeSize = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                freeSize++;\\n            } else {\\n                freeSize = 0;\\n            }\\n            if (freeSize == size) {\\n                startInd = (i - size) + 1;\\n                break;\\n            }\\n        }\\n        if (startInd != -1) {\\n            for (int i = startInd; i <= startInd + size - 1; i++) {\\n                arr[i] = mID;\\n            }\\n        }\\n        return startInd;\\n    }\\n\\n    public int free(int mID) {\\n        int freed = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == mID) {\\n                arr[i] = 0;\\n                freed++;\\n            }\\n        }\\n        return freed;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906406,
                "title": "priority-queue-java",
                "content": "# Intuition\\nMaintain two heaps in the form - [start, end]. Initially, your space is `[0, n)`, where `n` is non-inclusive. Imagine, you allocate 4 memory units, then your heaps become:\\n`av: [{4-10}]`\\n`n_av: [{0-4}]`\\nWhen you free it, it becomes\\n`av: [{0-4},{4-10}]`\\n`n_av: []`\\nSo, we will implement additional function to merge those intervals when we are freeing up the space. Also, when we allocate, we will find the first available interval that meets our size. \\n\\n# Complexity\\n- Time complexity:\\n- $$O(n*logn)$$\\n\\n- Space complexity:\\n- $$O(n*logn)$$\\n\\n# Code\\n```\\nclass Allocator {\\n    // available space \\n    PriorityQueue<int[]> av = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n    // not available space \\n    PriorityQueue<Pair> n_av = new PriorityQueue<>((a, b) -> a.second - b.second); \\n    \\n    public Allocator(int n) {\\n        av.offer(new int[]{ 0, n });\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        List<int[]> tmp = new ArrayList<>();\\n        int ans = -1;\\n        \\n        while (!av.isEmpty()) {\\n            int[] cur = av.poll();\\n            \\n            if (cur[1] - cur[0] > size) {\\n                n_av.offer(new Pair(new int[]{ cur[0], cur[0] + size }, mID));\\n                tmp.add(new int[]{ cur[0]+size, cur[1] });\\n                ans = cur[0];\\n                break;\\n            } else if (cur[1] - cur[0] == size) {\\n                n_av.offer(new Pair(cur, mID));\\n                ans = cur[0];\\n                break;\\n            } else {\\n                tmp.add(cur);\\n            }\\n        }\\n        \\n        for (int[] t : tmp) av.offer(t);\\n        \\n        return ans;\\n    }\\n    \\n    public int free(int mID) {\\n        List<Pair> tmp = new ArrayList<>();\\n        List<int[]> freeSpace = new ArrayList<>();\\n        int cnt = 0;\\n        \\n        while (!n_av.isEmpty()) {\\n            Pair cur = n_av.poll();\\n            \\n            if (cur.second == mID) {\\n                int[] range = cur.first;\\n                cnt += range[1] - range[0];\\n                freeSpace.add(range);\\n            } else {\\n                tmp.add(cur);\\n            }\\n        }\\n        \\n        for (Pair t : tmp) n_av.offer(t);\\n        merge(freeSpace);\\n        \\n        return cnt;\\n    }\\n    \\n    public void merge(List<int[]> freeSpace) {\\n        List<int[]> tmp = new ArrayList<>();\\n        for (int[] t : freeSpace) av.offer(t);\\n\\n        while (av.size() > 1) {\\n            int[] first = av.poll();\\n            int[] second = av.poll();\\n            if (first[1] >= second[0]) {\\n                av.offer(new int[]{ first[0], second[1] });\\n            } else {\\n                tmp.add(first);\\n                av.offer(second);\\n            }\\n        }\\n        while (!av.isEmpty()) {\\n            tmp.add(av.poll());\\n        }\\n\\n        for (int[] t : tmp) {\\n            av.offer(t);\\n        }\\n    }\\n    \\n    class Pair {\\n        int[] first;\\n        int second;\\n        \\n        public Pair(int[] a, int b) {\\n            first = a;\\n            second = b;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    // available space \\n    PriorityQueue<int[]> av = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n    // not available space \\n    PriorityQueue<Pair> n_av = new PriorityQueue<>((a, b) -> a.second - b.second); \\n    \\n    public Allocator(int n) {\\n        av.offer(new int[]{ 0, n });\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        List<int[]> tmp = new ArrayList<>();\\n        int ans = -1;\\n        \\n        while (!av.isEmpty()) {\\n            int[] cur = av.poll();\\n            \\n            if (cur[1] - cur[0] > size) {\\n                n_av.offer(new Pair(new int[]{ cur[0], cur[0] + size }, mID));\\n                tmp.add(new int[]{ cur[0]+size, cur[1] });\\n                ans = cur[0];\\n                break;\\n            } else if (cur[1] - cur[0] == size) {\\n                n_av.offer(new Pair(cur, mID));\\n                ans = cur[0];\\n                break;\\n            } else {\\n                tmp.add(cur);\\n            }\\n        }\\n        \\n        for (int[] t : tmp) av.offer(t);\\n        \\n        return ans;\\n    }\\n    \\n    public int free(int mID) {\\n        List<Pair> tmp = new ArrayList<>();\\n        List<int[]> freeSpace = new ArrayList<>();\\n        int cnt = 0;\\n        \\n        while (!n_av.isEmpty()) {\\n            Pair cur = n_av.poll();\\n            \\n            if (cur.second == mID) {\\n                int[] range = cur.first;\\n                cnt += range[1] - range[0];\\n                freeSpace.add(range);\\n            } else {\\n                tmp.add(cur);\\n            }\\n        }\\n        \\n        for (Pair t : tmp) n_av.offer(t);\\n        merge(freeSpace);\\n        \\n        return cnt;\\n    }\\n    \\n    public void merge(List<int[]> freeSpace) {\\n        List<int[]> tmp = new ArrayList<>();\\n        for (int[] t : freeSpace) av.offer(t);\\n\\n        while (av.size() > 1) {\\n            int[] first = av.poll();\\n            int[] second = av.poll();\\n            if (first[1] >= second[0]) {\\n                av.offer(new int[]{ first[0], second[1] });\\n            } else {\\n                tmp.add(first);\\n                av.offer(second);\\n            }\\n        }\\n        while (!av.isEmpty()) {\\n            tmp.add(av.poll());\\n        }\\n\\n        for (int[] t : tmp) {\\n            av.offer(t);\\n        }\\n    }\\n    \\n    class Pair {\\n        int[] first;\\n        int second;\\n        \\n        public Pair(int[] a, int b) {\\n            first = a;\\n            second = b;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906154,
                "title": "simple-java-array-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator {\\n      int[] arr;\\n\\n    public Allocator(int n) {\\n        arr = new int[n];\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int res = -1 ;\\n        int count =0 ;\\n        for(int i =0 ; i < arr.length ; i++){\\n\\n            if(arr[i] == 0){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n            }\\n\\n            if(count == size){\\n                Arrays.fill(arr, i-size+1, i+1, mID);\\n                res = i-size+1;\\n                break;\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n    \\n    public int free(int mID) {\\n        int freed = 0 ;\\n        for(int i=0 ; i < arr.length ; i++){\\n            if(arr[i] == mID){\\n                freed++;\\n                arr[i] = 0;\\n            }\\n        }\\n        return freed;\\n        \\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n      int[] arr;\\n\\n    public Allocator(int n) {\\n        arr = new int[n];\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int res = -1 ;\\n        int count =0 ;\\n        for(int i =0 ; i < arr.length ; i++){\\n\\n            if(arr[i] == 0){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n            }\\n\\n            if(count == size){\\n                Arrays.fill(arr, i-size+1, i+1, mID);\\n                res = i-size+1;\\n                break;\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n    \\n    public int free(int mID) {\\n        int freed = 0 ;\\n        for(int i=0 ; i < arr.length ; i++){\\n            if(arr[i] == mID){\\n                freed++;\\n                arr[i] = 0;\\n            }\\n        }\\n        return freed;\\n        \\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906116,
                "title": "best-cpp-explanation-2d-vector",
                "content": "UPVOTE IF HELPFUL!!\\n\\n```\\nclass Allocator {\\npublic:\\n\\n    vector<vector<pair<int,int>>> mpp;\\n    vector<bool> vec;\\n    int total=0;\\n\\n    Allocator(int n) \\n    {\\n        vec.resize(n);\\n        mpp.resize(1001);\\n        total = n;\\n\\n        for(int i=0; i<n; i++)vec[i]=false;\\n    }\\n    \\n    int allocate(int size, int mID) \\n    {\\n        for(int i=0; i<vec.size(); i++)\\n        {\\n            int flag=0;\\n\\n            for(int k=i; k<i+size; k++)\\n            {\\n                if(k>=total ||  vec[k] == true)\\n                {\\n                    if(k>=total)return -1;\\n                    if(vec[k] == true)i=k;\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n\\n                if(!flag)\\n                {\\n                    mpp[mID].push_back({i,(i+size)});\\n\\n                    for(int j=i; j<i+size; j++)vec[j]=true;\\n\\n                    return i;\\n                }\\n        }\\n\\n        return -1;\\n    }\\n    \\n    int free(int mID) \\n    {\\n        int ans = 0;\\n        for(auto[s,e] : mpp[mID])\\n        {\\n            for(int i=s; i<e; i++)\\n            {\\n                vec[i]=false;\\n                ans++;\\n            }\\n\\n        }\\n        mpp[mID].clear();\\n        return ans;\\n        // return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n\\n    vector<vector<pair<int,int>>> mpp;\\n    vector<bool> vec;\\n    int total=0;\\n\\n    Allocator(int n) \\n    {\\n        vec.resize(n);\\n        mpp.resize(1001);\\n        total = n;\\n\\n        for(int i=0; i<n; i++)vec[i]=false;\\n    }\\n    \\n    int allocate(int size, int mID) \\n    {\\n        for(int i=0; i<vec.size(); i++)\\n        {\\n            int flag=0;\\n\\n            for(int k=i; k<i+size; k++)\\n            {\\n                if(k>=total ||  vec[k] == true)\\n                {\\n                    if(k>=total)return -1;\\n                    if(vec[k] == true)i=k;\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n\\n                if(!flag)\\n                {\\n                    mpp[mID].push_back({i,(i+size)});\\n\\n                    for(int j=i; j<i+size; j++)vec[j]=true;\\n\\n                    return i;\\n                }\\n        }\\n\\n        return -1;\\n    }\\n    \\n    int free(int mID) \\n    {\\n        int ans = 0;\\n        for(auto[s,e] : mpp[mID])\\n        {\\n            for(int i=s; i<e; i++)\\n            {\\n                vec[i]=false;\\n                ans++;\\n            }\\n\\n        }\\n        mpp[mID].clear();\\n        return ans;\\n        // return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905588,
                "title": "java-using-a-sorted-set-and-a-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to keep track of free slots and used up slots. The free slots must be sorted by their start and used up slots must be grouped by id.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep two data structures - \\n1. A sorted set to keep track of free slots. This set keeps the slots sorted by their start position.\\n2. A map to keep track of id to list of slots currently in use by this id.\\n\\n**Initialize**\\nAll n slots are free initially.\\n\\n**Allocate**  \\nStraightforward and pseudocode is also written with the solution.\\n\\n**Free**\\nIdea is to merge the current slot with any neighbouring slots if present. So we find the left and right slots and try to expand the current slot we are trying to free up. Then we remove the left and right slots and add the expanded slot to our set of free slots.\\n\\n\\n# Code\\n```\\nclass Allocator {\\n    class Slot {\\n        int start;\\n        int size;\\n        public Slot(int st, int si){\\n            start = st;\\n            size = si;\\n        }\\n    }\\n    TreeSet<Slot> free;\\n    Map<Integer, List<Slot>> used;\\n    public Allocator(int n) {\\n        free = new TreeSet<>((a,b) -> a.start - b.start);\\n        free.add(new Slot(0, n));\\n        used = new HashMap();\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        if(free.isEmpty()) return -1;\\n        Slot foundSlot = null;\\n        for(Slot slot : free){\\n            if(slot.size >= size){\\n                foundSlot = slot;\\n                \\n                break;\\n            }\\n        }\\n        if(foundSlot == null) return -1;\\n        free.remove(foundSlot);\\n        if(foundSlot.size > size){\\n            free.add(new Slot(foundSlot.start + size, foundSlot.size - size));\\n        }\\n        used.computeIfAbsent(mID, t -> new ArrayList()).add(new Slot(foundSlot.start, size));\\n        return foundSlot.start;\\n    }\\n    \\n    public int free(int mID) {\\n        if(!used.containsKey(mID)) return 0;\\n        int freed = 0;\\n        List<Slot> freeUp = used.get(mID);\\n        for(Slot slot : freeUp){\\n            freed += slot.size;\\n            int left = slot.start;\\n            int right = slot.start + slot.size;\\n            Slot floor = free.floor(slot);\\n            if(floor != null && floor.start + floor.size == left){\\n                left = floor.start;\\n            }\\n            Slot ceil = free.floor(new Slot(right, 0));\\n            if(ceil != null && right == ceil.start){\\n                right = ceil.start + ceil.size;\\n            }\\n            free.subSet(new Slot(left, 0), true, new Slot(right,0), true).clear();\\n            free.add(new Slot(left, right - left));\\n        }\\n        used.remove(mID);\\n        return freed;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n\\n\\n//start, size\\nfreeSet<int[]> -> sorted by start\\nused<int, List<int[]>> -> mid to slots used up\\n\\nallocate(size, mId)\\n    1. is freeSet is empty, return -1;\\n    2. find the first slot with space >= size (foundSlot)\\n    3. if not found, return -1\\n    4. if foundSlot found, delete it from freeSet\\n    5. if slotSize > size\\n        add a smaller slot to freeSet\\n    6. add required slot to used using mId\\n    7. return foundSlot[0]\\n\\nfree(mId)\\n    1. if mId not found return -1\\n    2. get all slots to be freed up -> freeUp\\n    3. merge into all freeslots\\n    4. remove mId from used\\n    5. return total freed up\\n\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    class Slot {\\n        int start;\\n        int size;\\n        public Slot(int st, int si){\\n            start = st;\\n            size = si;\\n        }\\n    }\\n    TreeSet<Slot> free;\\n    Map<Integer, List<Slot>> used;\\n    public Allocator(int n) {\\n        free = new TreeSet<>((a,b) -> a.start - b.start);\\n        free.add(new Slot(0, n));\\n        used = new HashMap();\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        if(free.isEmpty()) return -1;\\n        Slot foundSlot = null;\\n        for(Slot slot : free){\\n            if(slot.size >= size){\\n                foundSlot = slot;\\n                \\n                break;\\n            }\\n        }\\n        if(foundSlot == null) return -1;\\n        free.remove(foundSlot);\\n        if(foundSlot.size > size){\\n            free.add(new Slot(foundSlot.start + size, foundSlot.size - size));\\n        }\\n        used.computeIfAbsent(mID, t -> new ArrayList()).add(new Slot(foundSlot.start, size));\\n        return foundSlot.start;\\n    }\\n    \\n    public int free(int mID) {\\n        if(!used.containsKey(mID)) return 0;\\n        int freed = 0;\\n        List<Slot> freeUp = used.get(mID);\\n        for(Slot slot : freeUp){\\n            freed += slot.size;\\n            int left = slot.start;\\n            int right = slot.start + slot.size;\\n            Slot floor = free.floor(slot);\\n            if(floor != null && floor.start + floor.size == left){\\n                left = floor.start;\\n            }\\n            Slot ceil = free.floor(new Slot(right, 0));\\n            if(ceil != null && right == ceil.start){\\n                right = ceil.start + ceil.size;\\n            }\\n            free.subSet(new Slot(left, 0), true, new Slot(right,0), true).clear();\\n            free.add(new Slot(left, right - left));\\n        }\\n        used.remove(mID);\\n        return freed;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n\\n\\n//start, size\\nfreeSet<int[]> -> sorted by start\\nused<int, List<int[]>> -> mid to slots used up\\n\\nallocate(size, mId)\\n    1. is freeSet is empty, return -1;\\n    2. find the first slot with space >= size (foundSlot)\\n    3. if not found, return -1\\n    4. if foundSlot found, delete it from freeSet\\n    5. if slotSize > size\\n        add a smaller slot to freeSet\\n    6. add required slot to used using mId\\n    7. return foundSlot[0]\\n\\nfree(mId)\\n    1. if mId not found return -1\\n    2. get all slots to be freed up -> freeUp\\n    3. merge into all freeslots\\n    4. remove mId from used\\n    5. return total freed up\\n\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905494,
                "title": "python-implementation-of-two-maps",
                "content": "# Summary\\nPython implementation based on [Two Maps](https://leetcode.com/problems/design-memory-allocator/solutions/2899668/two-maps/). Credit to `votrubac`\\'s brilliant solution.\\n\\n# Code\\n\\n```\\nfrom sortedcontainers import SortedDict\\n\\nclass Allocator:\\n    def __init__(self, n: int):\\n        self.avail = SortedDict({0: n})\\n        self.alloc = defaultdict(list)\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        for start, free_size in self.avail.items():\\n            if free_size >= size:\\n                self.alloc[mID].append((start, size))\\n                del self.avail[start]\\n                # if there is still remaining memory, alloc that memory \\n                if free_size > size:\\n                    self.avail[start+size] = free_size - size\\n                return start\\n        return -1\\n\\n    def _combine_mem(self, s1, s2):\\n        # if the first node reach the second node, combine them\\n        if s1 + self.avail[s1] == s2:\\n            self.avail[s1] += self.avail[s2]\\n            del self.avail[s2]\\n\\n    def free(self, mID: int) -> int:\\n        if mID not in self.alloc:\\n            return 0\\n        \\n        out = 0\\n        for start, size in self.alloc[mID]:\\n            self.avail[start] = size\\n            out += size\\n\\n            # combine memory with the prev and next node\\n            # note that, first handle the next node, so that we don\\'t need to move i\\n            i = self.avail.bisect_left(start)\\n            keys = self.avail.keys()\\n            if i < len(self.avail) - 1:\\n                self._combine_mem(start, keys[i+1])\\n            if i >= 0:\\n                self._combine_mem(keys[i-1], start)\\n        del self.alloc[mID]\\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedDict\\n\\nclass Allocator:\\n    def __init__(self, n: int):\\n        self.avail = SortedDict({0: n})\\n        self.alloc = defaultdict(list)\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        for start, free_size in self.avail.items():\\n            if free_size >= size:\\n                self.alloc[mID].append((start, size))\\n                del self.avail[start]\\n                # if there is still remaining memory, alloc that memory \\n                if free_size > size:\\n                    self.avail[start+size] = free_size - size\\n                return start\\n        return -1\\n\\n    def _combine_mem(self, s1, s2):\\n        # if the first node reach the second node, combine them\\n        if s1 + self.avail[s1] == s2:\\n            self.avail[s1] += self.avail[s2]\\n            del self.avail[s2]\\n\\n    def free(self, mID: int) -> int:\\n        if mID not in self.alloc:\\n            return 0\\n        \\n        out = 0\\n        for start, size in self.alloc[mID]:\\n            self.avail[start] = size\\n            out += size\\n\\n            # combine memory with the prev and next node\\n            # note that, first handle the next node, so that we don\\'t need to move i\\n            i = self.avail.bisect_left(start)\\n            keys = self.avail.keys()\\n            if i < len(self.avail) - 1:\\n                self._combine_mem(start, keys[i+1])\\n            if i >= 0:\\n                self._combine_mem(keys[i-1], start)\\n        del self.alloc[mID]\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904922,
                "title": "java-very-efficient",
                "content": "# Code\\n```\\nclass Allocator {\\n\\tprivate static class Block {\\n\\t\\tfinal int begin;\\n\\t\\tfinal int end;\\n\\t\\tBlock left;\\n\\t\\tBlock right;\\n\\t\\tBlock sibling;\\n\\n\\t\\tBlock(int position) {\\n\\t\\t\\tbegin = end = position;\\n\\t\\t}\\n\\n\\t\\tBlock(Block left, int size, Block sibling) {\\n\\t\\t\\tbegin = left.end;\\n\\t\\t\\tend = begin + size;\\n\\t\\t\\tthis.left = left;\\n\\t\\t\\tright = left.right;\\n\\t\\t\\tleft.right = this;\\n\\t\\t\\tright.left = this;\\n\\t\\t\\tthis.sibling = sibling;\\n\\t\\t}\\n\\n\\t\\tint remove() {\\n\\t\\t\\tleft.right = right;\\n\\t\\t\\tright.left = left;\\n\\t\\t\\treturn end - begin;\\n\\t\\t}\\n\\t}\\n\\n\\tprivate final Block leftBorder;\\n\\tprivate final Block rightBorder;\\n\\tprivate final Map<Integer, Block> mIDChain = new HashMap<>();\\n\\n\\tpublic Allocator(int n) {\\n\\t\\tleftBorder = new Block(0);\\n\\t\\trightBorder = new Block(n);\\n\\t\\tleftBorder.right = rightBorder;\\n\\t\\trightBorder.left = leftBorder;\\n\\t}\\n\\n\\tpublic int allocate(int size, int mID) {\\n\\t\\tBlock block;\\n\\t\\tBlock next = leftBorder;\\n\\t\\tdo {\\n\\t\\t\\tblock = next;\\n\\t\\t\\tnext = block.right;\\n\\t\\t\\tif (next.begin - block.end >= size) {\\n\\t\\t\\t\\tBlock left = block;\\n\\t\\t\\t\\treturn mIDChain.compute(mID, (id, sib) -> new Block(left, size, sib)).begin;\\n\\t\\t\\t}\\n\\t\\t} while (next != rightBorder);\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic int free(int mID) {\\n\\t\\tint size = 0;\\n\\t\\tfor (Block block = mIDChain.remove(mID); block != null; block = block.sibling)\\n\\t\\t\\tsize += block.remove();\\n\\t\\treturn size;\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass Allocator {\\n\\tprivate static class Block {\\n\\t\\tfinal int begin;\\n\\t\\tfinal int end;\\n\\t\\tBlock left;\\n\\t\\tBlock right;\\n\\t\\tBlock sibling;\\n\\n\\t\\tBlock(int position) {\\n\\t\\t\\tbegin = end = position;\\n\\t\\t}\\n\\n\\t\\tBlock(Block left, int size, Block sibling) {\\n\\t\\t\\tbegin = left.end;\\n\\t\\t\\tend = begin + size;\\n\\t\\t\\tthis.left = left;\\n\\t\\t\\tright = left.right;\\n\\t\\t\\tleft.right = this;\\n\\t\\t\\tright.left = this;\\n\\t\\t\\tthis.sibling = sibling;\\n\\t\\t}\\n\\n\\t\\tint remove() {\\n\\t\\t\\tleft.right = right;\\n\\t\\t\\tright.left = left;\\n\\t\\t\\treturn end - begin;\\n\\t\\t}\\n\\t}\\n\\n\\tprivate final Block leftBorder;\\n\\tprivate final Block rightBorder;\\n\\tprivate final Map<Integer, Block> mIDChain = new HashMap<>();\\n\\n\\tpublic Allocator(int n) {\\n\\t\\tleftBorder = new Block(0);\\n\\t\\trightBorder = new Block(n);\\n\\t\\tleftBorder.right = rightBorder;\\n\\t\\trightBorder.left = leftBorder;\\n\\t}\\n\\n\\tpublic int allocate(int size, int mID) {\\n\\t\\tBlock block;\\n\\t\\tBlock next = leftBorder;\\n\\t\\tdo {\\n\\t\\t\\tblock = next;\\n\\t\\t\\tnext = block.right;\\n\\t\\t\\tif (next.begin - block.end >= size) {\\n\\t\\t\\t\\tBlock left = block;\\n\\t\\t\\t\\treturn mIDChain.compute(mID, (id, sib) -> new Block(left, size, sib)).begin;\\n\\t\\t\\t}\\n\\t\\t} while (next != rightBorder);\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic int free(int mID) {\\n\\t\\tint size = 0;\\n\\t\\tfor (Block block = mIDChain.remove(mID); block != null; block = block.sibling)\\n\\t\\t\\tsize += block.remove();\\n\\t\\treturn size;\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904542,
                "title": "java-array-cache-free-memory-and-mid-length-100",
                "content": "# Please upvote if you like it, thanks!\\n\\n# Code\\n```\\nclass Allocator {\\n    int[][] a;\\n    int n;\\n\\n    /**\\n     * a[i][0]: mID\\n     * a[i][1]: How many consecutive free memory or same mID are there after i (for i = 0 || a[i][0] != a[i - 1][0]))\\n     * a[i][2]: How much continuous free memory is there in the i front(for i > 0 && a[i-1][0] == 0 && a[i][0] != 0))\\n     * @param n\\n     */\\n    public Allocator(int n) {\\n        this.n = n;\\n        a = new int[n][3];\\n        for (int i = 0; i < n; i++) a[i][1] = n - i;\\n    }\\n\\n    /**\\n     * 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3\\n     *             |-------------freeBehind--------|\\n     * allocate(6,2)\\n     * 1 1 1 1 1 1 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 3 3\\n     *             |---size--|\\n     *             |           |\\n     *          a[left][0] a[right][0]\\n     *                         |-->-a[right][1]-->-|\\n     * R = left + freeBehind\\n     *                         |---<--a[R][2]--<---|\\n     * update: a[right][1] and a[R][2]\\n     *\\n     * @param size\\n     * @param mID\\n     * @return\\n     */\\n    public int allocate(int size, int mID) {\\n        int left,right = 0,freeBehind;\\n        while (right < n && (a[right][0] != 0 || a[right][1] < size)) right += a[right][1];\\n        if (right >= n) return -1;\\n\\n        left = right;\\n        for (int i = 0; i < size; i++) a[right++][0] = mID;\\n        freeBehind = a[left][1];\\n        a[left][1] = size;\\n\\n        if (freeBehind > size)  a[right][1] = freeBehind - size;\\n        if (left + freeBehind < n) a[left + freeBehind][2] = freeBehind - size;\\n        return left;\\n    }\\n\\n    /**\\n     * free mID 2\\n     *\\n     * 1 1 0 0 0 0 0 0 0 0 0 2 2 2 2 2 2 0 0 0 0 0 0 0 0 3 3\\n     *     |                 |           |               |\\n     *                     a[left][0] a[right][0]\\n     *     |---freeFront-----|a[left][1] |--freeBehind---|\\n     *     |-<-a[left][2]-<--|           |->a[right][1]->|\\n     * a[left - freeFront][0]                     a[right + freeBehind][0]\\n     *     |--->---->--a[left - freeFront][1]--->---->---|\\n     *     |---<----<--a[right + freeBehind][2]---<--<---|\\n     * update: a[left - freeFront][1] and a[right + freeBehind][2]\\n     * \\n     * @param mID\\n     * @return\\n     */\\n    public int free(int mID) {\\n        int size = 0, left, right = 0,  freeBehind, freeFront;\\n        while (right < n) {\\n            while (right < n && a[right][0] != mID) right += a[right][1];\\n            if (right >= n) return size;\\n\\n            left = right;\\n            size += a[left][1];\\n\\n            while (right < left + a[left][1]) a[right++][0] = 0;\\n            freeBehind = (right > n - 1 || a[right][0] != 0) ? 0 : a[right][1];\\n            freeFront = a[left][2];\\n\\n            a[left - freeFront][1] = freeFront + a[left][1] + freeBehind;\\n            if (right + freeBehind < n) a[right + freeBehind][2] = a[left - freeFront][1];\\n        }\\n        return size;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Allocator {\\n    int[][] a;\\n    int n;\\n\\n    /**\\n     * a[i][0]: mID\\n     * a[i][1]: How many consecutive free memory or same mID are there after i (for i = 0 || a[i][0] != a[i - 1][0]))\\n     * a[i][2]: How much continuous free memory is there in the i front(for i > 0 && a[i-1][0] == 0 && a[i][0] != 0))\\n     * @param n\\n     */\\n    public Allocator(int n) {\\n        this.n = n;\\n        a = new int[n][3];\\n        for (int i = 0; i < n; i++) a[i][1] = n - i;\\n    }\\n\\n    /**\\n     * 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3\\n     *             |-------------freeBehind--------|\\n     * allocate(6,2)\\n     * 1 1 1 1 1 1 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 3 3\\n     *             |---size--|\\n     *             |           |\\n     *          a[left][0] a[right][0]\\n     *                         |-->-a[right][1]-->-|\\n     * R = left + freeBehind\\n     *                         |---<--a[R][2]--<---|\\n     * update: a[right][1] and a[R][2]\\n     *\\n     * @param size\\n     * @param mID\\n     * @return\\n     */\\n    public int allocate(int size, int mID) {\\n        int left,right = 0,freeBehind;\\n        while (right < n && (a[right][0] != 0 || a[right][1] < size)) right += a[right][1];\\n        if (right >= n) return -1;\\n\\n        left = right;\\n        for (int i = 0; i < size; i++) a[right++][0] = mID;\\n        freeBehind = a[left][1];\\n        a[left][1] = size;\\n\\n        if (freeBehind > size)  a[right][1] = freeBehind - size;\\n        if (left + freeBehind < n) a[left + freeBehind][2] = freeBehind - size;\\n        return left;\\n    }\\n\\n    /**\\n     * free mID 2\\n     *\\n     * 1 1 0 0 0 0 0 0 0 0 0 2 2 2 2 2 2 0 0 0 0 0 0 0 0 3 3\\n     *     |                 |           |               |\\n     *                     a[left][0] a[right][0]\\n     *     |---freeFront-----|a[left][1] |--freeBehind---|\\n     *     |-<-a[left][2]-<--|           |->a[right][1]->|\\n     * a[left - freeFront][0]                     a[right + freeBehind][0]\\n     *     |--->---->--a[left - freeFront][1]--->---->---|\\n     *     |---<----<--a[right + freeBehind][2]---<--<---|\\n     * update: a[left - freeFront][1] and a[right + freeBehind][2]\\n     * \\n     * @param mID\\n     * @return\\n     */\\n    public int free(int mID) {\\n        int size = 0, left, right = 0,  freeBehind, freeFront;\\n        while (right < n) {\\n            while (right < n && a[right][0] != mID) right += a[right][1];\\n            if (right >= n) return size;\\n\\n            left = right;\\n            size += a[left][1];\\n\\n            while (right < left + a[left][1]) a[right++][0] = 0;\\n            freeBehind = (right > n - 1 || a[right][0] != 0) ? 0 : a[right][1];\\n            freeFront = a[left][2];\\n\\n            a[left - freeFront][1] = freeFront + a[left][1] + freeBehind;\\n            if (right + freeBehind < n) a[right + freeBehind][2] = a[left - freeFront][1];\\n        }\\n        return size;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903471,
                "title": "python3-bitmask",
                "content": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.memo = [0] * n\\n        self.bitmask = 0\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        if size > len(self.memo): return -1\\n        for i in range(len(self.memo) - size + 1):\\n            mask = ((1 << size) - 1) << i\\n            if not self.bitmask & mask:\\n                self.bitmask |= mask\\n                for k in range(size): self.memo[i + k] = mID\\n                return i\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        ret = 0\\n        for i in range(len(self.memo)):\\n            if self.memo[i] == mID:\\n                ret += 1\\n                self.memo[i] = 0\\n                self.bitmask &= ~(1 << i)\\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.memo = [0] * n\\n        self.bitmask = 0\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        if size > len(self.memo): return -1\\n        for i in range(len(self.memo) - size + 1):\\n            mask = ((1 << size) - 1) << i\\n            if not self.bitmask & mask:\\n                self.bitmask |= mask\\n                for k in range(size): self.memo[i + k] = mID\\n                return i\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        ret = 0\\n        for i in range(len(self.memo)):\\n            if self.memo[i] == mID:\\n                ret += 1\\n                self.memo[i] = 0\\n                self.bitmask &= ~(1 << i)\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903451,
                "title": "c-sc-o-1000-max-easy-solution",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitialize an array memory of size n, \\nwhere,\\n    `memory[i]` = `mID` **OR** (the number of blocks available to be allocated including itself + 1000 ```[to differentiate it\\'s value from mID]```) \\n\\nWhen `Allocator` object is instantiated each of its index will be initialized with the value which represent `(the number of blocks available to be allocated including itself + 1000)`\\n\\nEx: \\n    *for* **n = 10**\\n`memory = [1010, 1009, 1008, 1007, 1006, 1005, 1004, 1003, 1002, 1001]`\\n\\nWhen `allocate()` is called:\\nIt will check if for each index ***i < memory.size()*** there exist `i` such that `memory[i]-1000 >= size` \\nthen it will assign each value of memory from ***i to i+size*** to `mID`\\n\\nif `i` exista such that `memory[i]-1000 >= size` it will return `-1`\\n\\n\\nWhen `free()` is called:\\nIt will start traversing from end of list `memory` and if `(memory[i] == mID)` it will count it and set current and other index values according to the format defined at the beginning(i.e, each of its index value will be initialized with the value which represent `(the number of blocks available to be allocated including itself + 1000)`)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(n)$$ || $$O(1000)$$ `Max`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```javascript []\\nconsole.log(\\'Do Upvote If you like the solution\\')\\n```\\n```python []\\nprint(\\'Do Upvote If you like the solution\\')\\n```\\n```C++ []\\ncout << \\'Do Upvote If you like the solution\\'\\n```\\n\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    vector<int> memory;\\n\\n    Allocator(int n) { // O(n) = 1000\\n        memory.resize(n, 0);\\n        int num=1;\\n        for(int i=n-1; i>=0; i--){\\n            memory[i] = (num++) + 1000;\\n        }\\n    }\\n    \\n    int allocate(int size, int mID) { // O(n) ~ 1000 [Max]\\n        int i=0;\\n        while(i<memory.size()){ // O(n) ~ 1000\\n            if(memory[i]-1000 >= size){\\n                int j = i;\\n                while(j < i+size){ \\n                    memory[j++] = mID;\\n                }\\n                return i;\\n            }i++;\\n        }\\n        return -1;\\n    }\\n\\n    int free(int mID) { // O(n) ~ 1000 [Max]\\n        int i=memory.size()-1, cnt=0;\\n        while(i >= 0){\\n            cnt += (memory[i] == mID);\\n            if(i < memory.size()-1 && (memory[i] == mID || memory[i] > 1000)){\\n                if(memory[i+1] > 1000)\\n                    memory[i] = memory[i+1]+1;\\n                else\\n                    memory[i] = 1001;\\n            } else if(memory[i] == mID)\\n                memory[i] = 1001;\\n            i--;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Suffix Array"
                ],
                "code": "```[to differentiate it\\'s value from mID]```\n```javascript []\\nconsole.log(\\'Do Upvote If you like the solution\\')\\n```\n```python []\\nprint(\\'Do Upvote If you like the solution\\')\\n```\n```C++ []\\ncout << \\'Do Upvote If you like the solution\\'\\n```\n```\\nclass Allocator {\\npublic:\\n    vector<int> memory;\\n\\n    Allocator(int n) { // O(n) = 1000\\n        memory.resize(n, 0);\\n        int num=1;\\n        for(int i=n-1; i>=0; i--){\\n            memory[i] = (num++) + 1000;\\n        }\\n    }\\n    \\n    int allocate(int size, int mID) { // O(n) ~ 1000 [Max]\\n        int i=0;\\n        while(i<memory.size()){ // O(n) ~ 1000\\n            if(memory[i]-1000 >= size){\\n                int j = i;\\n                while(j < i+size){ \\n                    memory[j++] = mID;\\n                }\\n                return i;\\n            }i++;\\n        }\\n        return -1;\\n    }\\n\\n    int free(int mID) { // O(n) ~ 1000 [Max]\\n        int i=memory.size()-1, cnt=0;\\n        while(i >= 0){\\n            cnt += (memory[i] == mID);\\n            if(i < memory.size()-1 && (memory[i] == mID || memory[i] > 1000)){\\n                if(memory[i+1] > 1000)\\n                    memory[i] = memory[i+1]+1;\\n                else\\n                    memory[i] = 1001;\\n            } else if(memory[i] == mID)\\n                memory[i] = 1001;\\n            i--;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2903252,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Allocator {\\n    private int[] arr;\\n    Map<Integer, List<int[]>> map;\\n    public Allocator(int n) {\\n        arr = new int[n];\\n        map = new HashMap<>();\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int i = 0;\\n        while(i < arr.length){\\n            if(arr[i] == 0){\\n                int mem = i + 1;\\n                while(mem < arr.length && arr[mem] == 0) mem++;\\n                mem = mem - i;\\n                if(mem >= size){\\n                    List<int[]> vals = map.getOrDefault(mID, new ArrayList<>());\\n                    vals.add(new int[]{i, i + size - 1});\\n                    map.put(mID, vals);\\n                    mem = 0;\\n                    while(mem < size){\\n                        arr[i + mem] = mID;\\n                        mem ++;\\n                    }\\n                    return i;\\n                }\\n                i = i + mem + 1;\\n            }else\\n                i ++;\\n        }\\n        return -1;\\n    }\\n    \\n    public int free(int mID) {\\n        int count = 0;\\n        List<int[]> vals = map.getOrDefault(mID, new ArrayList<>());\\n        for(int[] val: vals){\\n            int start = val[0], end = val[1];\\n            for(; start <= end; start++){\\n                arr[start] = 0;\\n                count ++;\\n            }\\n        }\\n        map.remove(mID);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    private int[] arr;\\n    Map<Integer, List<int[]>> map;\\n    public Allocator(int n) {\\n        arr = new int[n];\\n        map = new HashMap<>();\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        int i = 0;\\n        while(i < arr.length){\\n            if(arr[i] == 0){\\n                int mem = i + 1;\\n                while(mem < arr.length && arr[mem] == 0) mem++;\\n                mem = mem - i;\\n                if(mem >= size){\\n                    List<int[]> vals = map.getOrDefault(mID, new ArrayList<>());\\n                    vals.add(new int[]{i, i + size - 1});\\n                    map.put(mID, vals);\\n                    mem = 0;\\n                    while(mem < size){\\n                        arr[i + mem] = mID;\\n                        mem ++;\\n                    }\\n                    return i;\\n                }\\n                i = i + mem + 1;\\n            }else\\n                i ++;\\n        }\\n        return -1;\\n    }\\n    \\n    public int free(int mID) {\\n        int count = 0;\\n        List<int[]> vals = map.getOrDefault(mID, new ArrayList<>());\\n        for(int[] val: vals){\\n            int start = val[0], end = val[1];\\n            for(; start <= end; start++){\\n                arr[start] = 0;\\n                count ++;\\n            }\\n        }\\n        map.remove(mID);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902941,
                "title": "use-a-treemap-to-manage-free-space-and-merge-consecutive-free-space",
                "content": "# Intuition\\nThe key challenge is how to merge consecutive free space. We can use a TreeMap to store previous and next segment, so we don\\'t need to walk through the entire space to find the next and previous segment.\\n\\n# Approach\\nUse a TreeMap to store free segments, and walk through this tree map to find first available space.\\n\\n# Complexity\\n- Time complexity:\\nLinear to find available space,\\nand log (number of segments) to free.\\n\\n- Space complexity:\\nLinear to total space.\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    Allocator(int n) {\\n        avail[0] = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int b = -1, len = -1;\\n        for (auto [k, v] : avail) {\\n            if (v >= size) {\\n                b = k;\\n                len = v;\\n                break;\\n            }\\n        }\\n        if (b != -1) {\\n            avail.erase(b);\\n            if (len > size) {\\n                avail[b + size] = len - size;\\n            }\\n            alloced[mID].emplace_back(b, size);\\n        }\\n        return b;\\n    }\\n    \\n    int free(int mID) {\\n        int ans = 0;\\n        for (auto [b, len] : alloced[mID]) {\\n            auto iter_r = avail.lower_bound(b);\\n            auto iter_l = (iter_r != avail.begin() ?\\n                          prev(iter_r) : avail.end());\\n            int b0 = (iter_l != avail.end() ? iter_l->first : -1);\\n            int len0 = (iter_l != avail.end() ? iter_l->second : -1);\\n            int b1 = (iter_r != avail.end() ? iter_r->first : -1);\\n            int len1 = (iter_r != avail.end() ? iter_r->second : -1);\\n            if (b0 != -1 && b1 != -1) {\\n                if (b0 + len0 != b && b + len != b1) {\\n                    avail[b] = len;\\n                } else if (b0 + len0 == b && b + len != b1) {\\n                    avail[b0] = len0 + len;\\n                } else if (b0 + len0 != b && b + len == b1) {\\n                    avail.erase(b1);\\n                    avail[b] = len + len1;\\n                } else {\\n                    avail.erase(b1);\\n                    avail[b0] = len0 + len + len1;\\n                }\\n            } else if (b0 != -1 && b1 == -1) {\\n                if (b0 + len0 != b) {\\n                    avail[b] = len;\\n                } else {\\n                    avail[b0] = len0 + len;\\n                }\\n            } else if (b0 == -1 && b1 != -1) {\\n                if (b + len != b1) {\\n                    avail[b] = len;\\n                } else {\\n                    avail.erase(b1);\\n                    avail[b] = len + len1;\\n                }\\n            } else {\\n                avail[b] = len;\\n            }\\n            ans += len;\\n        }\\n        alloced[mID].clear();\\n        return ans;\\n    }\\n\\nprivate:\\n    map<int, int> avail;\\n    unordered_map<int, vector<pair<int, int>>> alloced;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    Allocator(int n) {\\n        avail[0] = n;\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int b = -1, len = -1;\\n        for (auto [k, v] : avail) {\\n            if (v >= size) {\\n                b = k;\\n                len = v;\\n                break;\\n            }\\n        }\\n        if (b != -1) {\\n            avail.erase(b);\\n            if (len > size) {\\n                avail[b + size] = len - size;\\n            }\\n            alloced[mID].emplace_back(b, size);\\n        }\\n        return b;\\n    }\\n    \\n    int free(int mID) {\\n        int ans = 0;\\n        for (auto [b, len] : alloced[mID]) {\\n            auto iter_r = avail.lower_bound(b);\\n            auto iter_l = (iter_r != avail.begin() ?\\n                          prev(iter_r) : avail.end());\\n            int b0 = (iter_l != avail.end() ? iter_l->first : -1);\\n            int len0 = (iter_l != avail.end() ? iter_l->second : -1);\\n            int b1 = (iter_r != avail.end() ? iter_r->first : -1);\\n            int len1 = (iter_r != avail.end() ? iter_r->second : -1);\\n            if (b0 != -1 && b1 != -1) {\\n                if (b0 + len0 != b && b + len != b1) {\\n                    avail[b] = len;\\n                } else if (b0 + len0 == b && b + len != b1) {\\n                    avail[b0] = len0 + len;\\n                } else if (b0 + len0 != b && b + len == b1) {\\n                    avail.erase(b1);\\n                    avail[b] = len + len1;\\n                } else {\\n                    avail.erase(b1);\\n                    avail[b0] = len0 + len + len1;\\n                }\\n            } else if (b0 != -1 && b1 == -1) {\\n                if (b0 + len0 != b) {\\n                    avail[b] = len;\\n                } else {\\n                    avail[b0] = len0 + len;\\n                }\\n            } else if (b0 == -1 && b1 != -1) {\\n                if (b + len != b1) {\\n                    avail[b] = len;\\n                } else {\\n                    avail.erase(b1);\\n                    avail[b] = len + len1;\\n                }\\n            } else {\\n                avail[b] = len;\\n            }\\n            ans += len;\\n        }\\n        alloced[mID].clear();\\n        return ans;\\n    }\\n\\nprivate:\\n    map<int, int> avail;\\n    unordered_map<int, vector<pair<int, int>>> alloced;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902828,
                "title": "javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n */\\nvar Allocator = function(n) {\\n    this.memory = Array(n).fill(null);\\n};\\n\\n/** \\n * @param {number} size \\n * @param {number} mID\\n * @return {number}\\n */\\nAllocator.prototype.allocate = function(size, mID) {\\n    const n = this.memory.length;\\n    const memory = this.memory;\\n    const checkFree = function(leftmost, size) {\\n        for (let i = leftmost; i < leftmost + size; i++) {\\n           if (memory[i] !== null) return false;\\n        }\\n        for (let i = leftmost; i < leftmost + size; i++) {\\n           memory[i] = mID;\\n        }\\n        return true;\\n    }\\n    for (let i = 0; i < n; i++) {\\n        if (memory[i] === null && i + size <= n && checkFree(i, size)) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n};\\n\\n\\n/** \\n * @param {number} mID\\n * @return {number}\\n */\\nAllocator.prototype.free = function(mID) {\\n    let count = 0;\\n    for (let i = 0; i < this.memory.length; i++) {\\n        if (this.memory[i] === mID) {\\n            this.memory[i] = null;\\n            count++;\\n        }\\n    } \\n    return count\\n};\\n\\n/** \\n * Your Allocator object will be instantiated and called as such:\\n * var obj = new Allocator(n)\\n * var param_1 = obj.allocate(size,mID)\\n * var param_2 = obj.free(mID)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n */\\nvar Allocator = function(n) {\\n    this.memory = Array(n).fill(null);\\n};\\n\\n/** \\n * @param {number} size \\n * @param {number} mID\\n * @return {number}\\n */\\nAllocator.prototype.allocate = function(size, mID) {\\n    const n = this.memory.length;\\n    const memory = this.memory;\\n    const checkFree = function(leftmost, size) {\\n        for (let i = leftmost; i < leftmost + size; i++) {\\n           if (memory[i] !== null) return false;\\n        }\\n        for (let i = leftmost; i < leftmost + size; i++) {\\n           memory[i] = mID;\\n        }\\n        return true;\\n    }\\n    for (let i = 0; i < n; i++) {\\n        if (memory[i] === null && i + size <= n && checkFree(i, size)) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n};\\n\\n\\n/** \\n * @param {number} mID\\n * @return {number}\\n */\\nAllocator.prototype.free = function(mID) {\\n    let count = 0;\\n    for (let i = 0; i < this.memory.length; i++) {\\n        if (this.memory[i] === mID) {\\n            this.memory[i] = null;\\n            count++;\\n        }\\n    } \\n    return count\\n};\\n\\n/** \\n * Your Allocator object will be instantiated and called as such:\\n * var obj = new Allocator(n)\\n * var param_1 = obj.allocate(size,mID)\\n * var param_2 = obj.free(mID)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2902794,
                "title": "java-map-treemap",
                "content": "```\\n    class Allocator {\\n        TreeMap<Integer, Integer> a;\\n        Map<Integer, List<Integer>> b;\\n        int n;\\n        public Allocator(int n) {\\n            a = new TreeMap<>();\\n            b = new HashMap<>();\\n            this.n = n;\\n        }\\n\\n        public int allocate(int size, int mID) {\\n            Integer pivot = 0;\\n            while (pivot != null) {\\n                if (pivot + size > n) return -1;\\n                Integer next = a.ceilingKey(pivot);\\n                if (next == null || next - pivot >= size) {\\n                    a.put(pivot, pivot + size - 1);\\n                    b.putIfAbsent(mID, new ArrayList<>());\\n                    b.get(mID).add(pivot);\\n                    return pivot;\\n                }\\n                pivot = a.get(next) + 1;\\n            }\\n            return -1;\\n        }\\n\\n        public int free(int mID) {\\n            int res = 0;\\n            for (int key : b.getOrDefault(mID, new ArrayList<>())) {\\n                res += a.get(key) - key + 1;\\n                a.remove(key);\\n            }\\n            b.put(mID, new ArrayList<>());\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    class Allocator {\\n        TreeMap<Integer, Integer> a;\\n        Map<Integer, List<Integer>> b;\\n        int n;\\n        public Allocator(int n) {\\n            a = new TreeMap<>();\\n            b = new HashMap<>();\\n            this.n = n;\\n        }\\n\\n        public int allocate(int size, int mID) {\\n            Integer pivot = 0;\\n            while (pivot != null) {\\n                if (pivot + size > n) return -1;\\n                Integer next = a.ceilingKey(pivot);\\n                if (next == null || next - pivot >= size) {\\n                    a.put(pivot, pivot + size - 1);\\n                    b.putIfAbsent(mID, new ArrayList<>());\\n                    b.get(mID).add(pivot);\\n                    return pivot;\\n                }\\n                pivot = a.get(next) + 1;\\n            }\\n            return -1;\\n        }\\n\\n        public int free(int mID) {\\n            int res = 0;\\n            for (int key : b.getOrDefault(mID, new ArrayList<>())) {\\n                res += a.get(key) - key + 1;\\n                a.remove(key);\\n            }\\n            b.put(mID, new ArrayList<>());\\n            return res;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2902759,
                "title": "java-priorityqueue-hashmap-12ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**PriorityQueue** for keeping available blocks with index ascending to ensure we can get left most available block.\\n\\n**HashMap** for keeping the blocks which assigned to same ID.\\n\\nUse a two elements array **a**, a[0] for start index and a[1] for size as fundamental structure.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA main problem here is memory fragmentation, so we perform defragment before allocate. \\n\\n* Scan on the list of blocks which sorted by index, and try to combine continued blocks. \\n* Perform search to find first block which size equal required. \\n* If greater, need to create a new available block for remains size.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![Screenshot from 2022-12-12 10-02-24.png](https://assets.leetcode.com/users/images/01ee3402-572a-424e-b16f-760ebd16bf56_1670812279.324939.png)\\n\\n\\n# Code\\n```\\nclass Allocator {\\n    PriorityQueue<int[]> avail;\\n    Map<Integer, List<int[]>> allocated;\\n    public Allocator(int n) {\\n        avail = new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        allocated = new HashMap();\\n        avail.offer(new int[]{0, n});        \\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        if(avail.isEmpty())\\n            return -1;\\n        List<int[]> merge = defragment();\\n        int idx = -1;\\n        boolean found = false;\\n        for(int i=0;i<merge.size();i++) {\\n            int a[] = merge.get(i);\\n            if(!found && a[1] >= size) {\\n                idx = a[0];\\n                // create new available block if current one greater than demanded\\n                if(a[1] > size) {\\n                    int b[] = new int[2];\\n                    b[0] = a[0]+size;\\n                    b[1] = a[1]-size;\\n                    avail.offer(b);\\n                }\\n                List<int[]> list = allocated.getOrDefault(mID, new ArrayList());\\n                list.add(new int[]{a[0], size});                \\n                allocated.put(mID, list);\\n                // do not break look, need to push back avaible blocks into priority queue\\n                found = true;\\n            } else \\n                avail.offer(a);            \\n        }      \\n        return idx;                    \\n    }   \\n\\n    List<int[]> defragment() {                \\n        int current[] = avail.poll();\\n        List<int[]> merge = new ArrayList();        \\n        while(!avail.isEmpty()) {\\n            int a[] = avail.poll();\\n            // if start index + size == next block start, then \\n            // we can merge them\\n            if(current[0]+current[1] == a[0]) \\n                current[1] += a[1];\\n            // otherwise, put it into merged list\\n            else {                \\n                merge.add(current);\\n                current = a;\\n            }\\n        }\\n        merge.add(current);\\n        return merge;\\n    }\\n    \\n    public int free(int mID) {\\n        List<int[]> list = allocated.getOrDefault(mID, new ArrayList());\\n        int sum = 0;\\n        for(int i=0;i<list.size();i++) {\\n            int[] a = list.get(i);\\n            sum+= a[1];\\n            avail.add(a);\\n        }\\n        allocated.remove(mID);\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    PriorityQueue<int[]> avail;\\n    Map<Integer, List<int[]>> allocated;\\n    public Allocator(int n) {\\n        avail = new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        allocated = new HashMap();\\n        avail.offer(new int[]{0, n});        \\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        if(avail.isEmpty())\\n            return -1;\\n        List<int[]> merge = defragment();\\n        int idx = -1;\\n        boolean found = false;\\n        for(int i=0;i<merge.size();i++) {\\n            int a[] = merge.get(i);\\n            if(!found && a[1] >= size) {\\n                idx = a[0];\\n                // create new available block if current one greater than demanded\\n                if(a[1] > size) {\\n                    int b[] = new int[2];\\n                    b[0] = a[0]+size;\\n                    b[1] = a[1]-size;\\n                    avail.offer(b);\\n                }\\n                List<int[]> list = allocated.getOrDefault(mID, new ArrayList());\\n                list.add(new int[]{a[0], size});                \\n                allocated.put(mID, list);\\n                // do not break look, need to push back avaible blocks into priority queue\\n                found = true;\\n            } else \\n                avail.offer(a);            \\n        }      \\n        return idx;                    \\n    }   \\n\\n    List<int[]> defragment() {                \\n        int current[] = avail.poll();\\n        List<int[]> merge = new ArrayList();        \\n        while(!avail.isEmpty()) {\\n            int a[] = avail.poll();\\n            // if start index + size == next block start, then \\n            // we can merge them\\n            if(current[0]+current[1] == a[0]) \\n                current[1] += a[1];\\n            // otherwise, put it into merged list\\n            else {                \\n                merge.add(current);\\n                current = a;\\n            }\\n        }\\n        merge.add(current);\\n        return merge;\\n    }\\n    \\n    public int free(int mID) {\\n        List<int[]> list = allocated.getOrDefault(mID, new ArrayList());\\n        int sum = 0;\\n        for(int i=0;i<list.size();i++) {\\n            int[] a = list.get(i);\\n            sum+= a[1];\\n            avail.add(a);\\n        }\\n        allocated.remove(mID);\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator obj = new Allocator(n);\\n * int param_1 = obj.allocate(size,mID);\\n * int param_2 = obj.free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902741,
                "title": "c-two-map",
                "content": "# Intuition\\nA lot of edge cases need to be consider\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator {\\npublic:\\n    \\n    unordered_map<int, vector<pair<int, int>>> u2m;\\n    set<pair<int, int>> memo;\\n    int max_id;\\n    \\n    Allocator(int n) {\\n        max_id = n;    \\n    }\\n    \\n    int allocate(int size, int mID) {\\n\\n        //if memory is empty\\n        if(memo.empty()){\\n            if(size <= max_id){\\n                memo.emplace(0, size);\\n                u2m[mID].emplace_back(0, size);\\n                return 0;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n\\n        //if we can insert into the begining of memory\\n        auto it = memo.begin();\\n        if(it->first >= size){\\n            u2m[mID].emplace_back(0, size);\\n            if(size == it->first){\\n                int tmp = it->second;\\n                memo.erase(it);\\n                memo.emplace(0, tmp);\\n            }\\n            else{\\n                memo.emplace(0, size);\\n            }\\n            return 0;\\n        }\\n\\n        //traverse the memory\\n        it++;\\n        while(it != memo.end()){\\n            if(it->first - prev(it)->second >= size)\\n                break;\\n            it++;\\n        }\\n        \\n        //if we push back the end of memory\\n        if(it == memo.end()){\\n            if(prev(it)->second + size <= max_id){\\n                int res = prev(it)->second;\\n                pair<int, int> np = {prev(it)->first, prev(it)->second + size};\\n                u2m[mID].emplace_back(res, res + size);\\n                memo.erase(prev(it));\\n                memo.emplace(np);\\n                return res;\\n            }\\n        } //insert into the middle of memory\\n        else{\\n            int res = prev(it)->second;\\n            if(it->first - prev(it)->second == size){\\n                pair<int, int> np = {prev(it)->first, it->second};\\n                auto it1 = prev(it);\\n                memo.erase(it);\\n                memo.erase(it1);\\n                memo.emplace(np);\\n            }\\n            else{\\n                pair<int, int> np = {prev(it)->first, prev(it)->second + size};\\n                memo.erase(prev(it));\\n                memo.emplace(np);\\n            }\\n            u2m[mID].emplace_back(res, res + size);\\n            return res;\\n        }\\n        return -1;\\n    }\\n    \\n    void del(int l, int r){\\n        auto it = memo.upper_bound({l, r});\\n        if(it == memo.end() || it->first > l) it--;\\n        pair<int, int> np1 = {it->first, l};\\n        pair<int, int> np2 = {r, it->second};\\n        memo.erase(it);\\n        if(np1.first != np1.second)\\n            memo.emplace(np1);\\n        if(np2.first != np2.second)\\n            memo.emplace(np2); \\n    }\\n    \\n    int free(int mID) {\\n        if(!u2m.count(mID)) return 0;\\n        int res = 0;\\n        for(auto& [l, r] : u2m[mID]){\\n            del(l, r);\\n            res += r - l;\\n        }\\n        u2m.erase(mID);\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\npublic:\\n    \\n    unordered_map<int, vector<pair<int, int>>> u2m;\\n    set<pair<int, int>> memo;\\n    int max_id;\\n    \\n    Allocator(int n) {\\n        max_id = n;    \\n    }\\n    \\n    int allocate(int size, int mID) {\\n\\n        //if memory is empty\\n        if(memo.empty()){\\n            if(size <= max_id){\\n                memo.emplace(0, size);\\n                u2m[mID].emplace_back(0, size);\\n                return 0;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n\\n        //if we can insert into the begining of memory\\n        auto it = memo.begin();\\n        if(it->first >= size){\\n            u2m[mID].emplace_back(0, size);\\n            if(size == it->first){\\n                int tmp = it->second;\\n                memo.erase(it);\\n                memo.emplace(0, tmp);\\n            }\\n            else{\\n                memo.emplace(0, size);\\n            }\\n            return 0;\\n        }\\n\\n        //traverse the memory\\n        it++;\\n        while(it != memo.end()){\\n            if(it->first - prev(it)->second >= size)\\n                break;\\n            it++;\\n        }\\n        \\n        //if we push back the end of memory\\n        if(it == memo.end()){\\n            if(prev(it)->second + size <= max_id){\\n                int res = prev(it)->second;\\n                pair<int, int> np = {prev(it)->first, prev(it)->second + size};\\n                u2m[mID].emplace_back(res, res + size);\\n                memo.erase(prev(it));\\n                memo.emplace(np);\\n                return res;\\n            }\\n        } //insert into the middle of memory\\n        else{\\n            int res = prev(it)->second;\\n            if(it->first - prev(it)->second == size){\\n                pair<int, int> np = {prev(it)->first, it->second};\\n                auto it1 = prev(it);\\n                memo.erase(it);\\n                memo.erase(it1);\\n                memo.emplace(np);\\n            }\\n            else{\\n                pair<int, int> np = {prev(it)->first, prev(it)->second + size};\\n                memo.erase(prev(it));\\n                memo.emplace(np);\\n            }\\n            u2m[mID].emplace_back(res, res + size);\\n            return res;\\n        }\\n        return -1;\\n    }\\n    \\n    void del(int l, int r){\\n        auto it = memo.upper_bound({l, r});\\n        if(it == memo.end() || it->first > l) it--;\\n        pair<int, int> np1 = {it->first, l};\\n        pair<int, int> np2 = {r, it->second};\\n        memo.erase(it);\\n        if(np1.first != np1.second)\\n            memo.emplace(np1);\\n        if(np2.first != np2.second)\\n            memo.emplace(np2); \\n    }\\n    \\n    int free(int mID) {\\n        if(!u2m.count(mID)) return 0;\\n        int res = 0;\\n        for(auto& [l, r] : u2m[mID]){\\n            del(l, r);\\n            res += r - l;\\n        }\\n        u2m.erase(mID);\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902662,
                "title": "java-o-n",
                "content": "**Intuition**\\nUse one array to simulate the storage and the other to record the max blocks starting at each index.\\n\\n**Approach**\\nWhen allocate, traverse the block sizes array to find the first block that is larger than *size*, then fill the storage and update the block size array;\\nWhen free, just simply update two arrays.\\n\\n**Complexity**\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n\\n```\\nclass Allocator {\\n    \\n    int[] arr;  \\n    int[] maxBlocks; // record the max block starting at index i\\n    int n;\\n\\n    public Allocator(int n) {\\n        this.n = n;\\n        arr = new int[n];\\n        maxBlocks = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            maxBlocks[i] = n - i;\\n        }\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        for (int i = 0; i < n; i++) {\\n            if (maxBlocks[i] >= size) {\\n                for (int j = 0; j < size; j++) {\\n                    arr[i + j] = mID;\\n                    maxBlocks[i + j] = 0;\\n                }\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int free(int mID) {\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == mID) {\\n                int j = i;\\n                while (j < n && arr[j] == mID) {\\n                    arr[j] = 0;\\n                    j++;\\n                }\\n                res += j - i;\\n                i = j - 1;\\n            }\\n        }\\n        int cur = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (arr[i] == 0) {\\n                maxBlocks[i] = ++cur;\\n            } else {\\n                cur = 0;\\n                maxBlocks[i] = 0;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Allocator {\\n    \\n    int[] arr;  \\n    int[] maxBlocks; // record the max block starting at index i\\n    int n;\\n\\n    public Allocator(int n) {\\n        this.n = n;\\n        arr = new int[n];\\n        maxBlocks = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            maxBlocks[i] = n - i;\\n        }\\n    }\\n    \\n    public int allocate(int size, int mID) {\\n        for (int i = 0; i < n; i++) {\\n            if (maxBlocks[i] >= size) {\\n                for (int j = 0; j < size; j++) {\\n                    arr[i + j] = mID;\\n                    maxBlocks[i + j] = 0;\\n                }\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int free(int mID) {\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == mID) {\\n                int j = i;\\n                while (j < n && arr[j] == mID) {\\n                    arr[j] = 0;\\n                    j++;\\n                }\\n                res += j - i;\\n                i = j - 1;\\n            }\\n        }\\n        int cur = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (arr[i] == 0) {\\n                maxBlocks[i] = ++cur;\\n            } else {\\n                cur = 0;\\n                maxBlocks[i] = 0;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902506,
                "title": "javascript",
                "content": "\\n```\\n/**\\n * @param {number} n\\n */\\nvar Allocator = function (n) {\\n    this.emptySlots = [[0, n]]; // sorted array of empty slots [start, end], end exclusive\\n    this.mID = new Map(); // Map<number, [number, number][]> - map of allocated slots\\n};\\n\\n/**\\n * @param {number} size\\n * @param {number} mID\\n * @return {number}\\n */\\nAllocator.prototype.allocate = function (size, mID) {\\n    for (let i = 0; i < this.emptySlots.length; i++) {\\n        if (size <= this.emptySlots[i][1] - this.emptySlots[i][0]) {\\n            const v = this.mID.get(mID) ?? [];\\n            const firstIndex = this.emptySlots[i][0];\\n            v.push([firstIndex, firstIndex + size]);\\n            this.mID.set(mID, v);\\n            \\n            if (firstIndex + size === this.emptySlots[i][1]) {\\n                this.emptySlots.splice(i, 1);\\n            } else {\\n                this.emptySlots[i][0] += size;\\n            }\\n            \\n            return firstIndex;\\n        }\\n    }\\n\\n    return -1;\\n};\\n\\n/**\\n * @param {number} mID\\n * @return {number}\\n */\\nAllocator.prototype.free = function (mID) {\\n    if (!this.mID.has(mID)) return 0;\\n\\n    const allocated = this.mID.get(mID);\\n    const freed = allocated.reduce((acc, cur) => acc + cur[1] - cur[0], 0);\\n\\n    this.emptySlots.push(...allocated);\\n    this.emptySlots.sort((a, b) => a[0] - b[0]);\\n\\n    const mergedSlots = [this.emptySlots[0]];\\n    for (let i = 1; i < this.emptySlots.length; i++) {\\n        if (this.emptySlots[i][0] === mergedSlots.at(-1)[1]) {\\n            mergedSlots.at(-1)[1] = this.emptySlots[i][1];\\n        } else {\\n            mergedSlots.push(this.emptySlots[i]);\\n        }\\n    }\\n\\n    this.emptySlots = mergedSlots;\\n    this.mID.delete(mID);\\n\\n    return freed;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n */\\nvar Allocator = function (n) {\\n    this.emptySlots = [[0, n]]; // sorted array of empty slots [start, end], end exclusive\\n    this.mID = new Map(); // Map<number, [number, number][]> - map of allocated slots\\n};\\n\\n/**\\n * @param {number} size\\n * @param {number} mID\\n * @return {number}\\n */\\nAllocator.prototype.allocate = function (size, mID) {\\n    for (let i = 0; i < this.emptySlots.length; i++) {\\n        if (size <= this.emptySlots[i][1] - this.emptySlots[i][0]) {\\n            const v = this.mID.get(mID) ?? [];\\n            const firstIndex = this.emptySlots[i][0];\\n            v.push([firstIndex, firstIndex + size]);\\n            this.mID.set(mID, v);\\n            \\n            if (firstIndex + size === this.emptySlots[i][1]) {\\n                this.emptySlots.splice(i, 1);\\n            } else {\\n                this.emptySlots[i][0] += size;\\n            }\\n            \\n            return firstIndex;\\n        }\\n    }\\n\\n    return -1;\\n};\\n\\n/**\\n * @param {number} mID\\n * @return {number}\\n */\\nAllocator.prototype.free = function (mID) {\\n    if (!this.mID.has(mID)) return 0;\\n\\n    const allocated = this.mID.get(mID);\\n    const freed = allocated.reduce((acc, cur) => acc + cur[1] - cur[0], 0);\\n\\n    this.emptySlots.push(...allocated);\\n    this.emptySlots.sort((a, b) => a[0] - b[0]);\\n\\n    const mergedSlots = [this.emptySlots[0]];\\n    for (let i = 1; i < this.emptySlots.length; i++) {\\n        if (this.emptySlots[i][0] === mergedSlots.at(-1)[1]) {\\n            mergedSlots.at(-1)[1] = this.emptySlots[i][1];\\n        } else {\\n            mergedSlots.push(this.emptySlots[i]);\\n        }\\n    }\\n\\n    this.emptySlots = mergedSlots;\\n    this.mID.delete(mID);\\n\\n    return freed;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2902474,
                "title": "python-solution-with-hash-table-mid-size-of-block-leftmost-ind",
                "content": "In the dictionary for each block with id mID, we store the index of the beginning of the block and its size. \\nSince there can be several blocks with the same id, each mID corresponds to a list where its beginning and size are indicated for each block.\\n\\n# Code\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.arr = [None] * n\\n        self.mId_listOfSizesAndLeftInd = collections.defaultdict(list)\\n        self.capacity = n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        count = 0\\n        for ind in range(self.capacity):\\n            count = count + 1 if self.arr[ind] is None else 0\\n            if count == size:\\n                leftmost = ind - size + 1\\n                for ind_for_mID in range(leftmost, leftmost + size):\\n                    self.arr[ind_for_mID] = mID\\n                self.mId_listOfSizesAndLeftInd[mID].append((size, leftmost))\\n                return leftmost\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        if mID not in self.mId_listOfSizesAndLeftInd:\\n            return 0\\n        freed = 0\\n        for cur_size, cur_ind in self.mId_listOfSizesAndLeftInd[mID]:\\n            freed += cur_size\\n            for offset in range(cur_size):\\n                self.arr[cur_ind + offset] = None\\n        del self.mId_listOfSizesAndLeftInd[mID]\\n        return freed\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.arr = [None] * n\\n        self.mId_listOfSizesAndLeftInd = collections.defaultdict(list)\\n        self.capacity = n\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        count = 0\\n        for ind in range(self.capacity):\\n            count = count + 1 if self.arr[ind] is None else 0\\n            if count == size:\\n                leftmost = ind - size + 1\\n                for ind_for_mID in range(leftmost, leftmost + size):\\n                    self.arr[ind_for_mID] = mID\\n                self.mId_listOfSizesAndLeftInd[mID].append((size, leftmost))\\n                return leftmost\\n        return -1\\n\\n    def free(self, mID: int) -> int:\\n        if mID not in self.mId_listOfSizesAndLeftInd:\\n            return 0\\n        freed = 0\\n        for cur_size, cur_ind in self.mId_listOfSizesAndLeftInd[mID]:\\n            freed += cur_size\\n            for offset in range(cur_size):\\n                self.arr[cur_ind + offset] = None\\n        del self.mId_listOfSizesAndLeftInd[mID]\\n        return freed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902458,
                "title": "python-100-faster-binary-search",
                "content": "# Intuition\\nIt\\'s a usual **system design** problem which can be solved using **binary search**. \\n\\n# Approach\\nWe Store ```(space, leftmost_index)``` using $$Insort$$. It helps in faster insertion. \\n\\n# Complexity\\n- Time complexity:\\n- **To allocate**: $$O(size)+O(logK)$$, where $$K$$ is size of space checking array\\n- **To free**: $$O(n + logK)$$, where $$K$$ is size of space checking array\\n\\n\\n- Space complexity: $$O(n)$$\\n\\n\\n# Code\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.counter = defaultdict(int)     #Counts occurance/not neccessary but for fast searching\\n        self.n = n\\n        self.space = [(n, 0)]               #For check space (space, leftmost_index)\\n        self.array = [0]*n                  #Working array\\n        \\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        i = bisect.bisect_left(self.space, (size, 0))\\n        if i==len(self.space): return -1\\n        \\n        #We can go further ahead to check if there\\'s an index more left to current one\\n        req = i\\n        left, j = self.space[i]\\n        for k in range(i, len(self.space)):\\n            if self.space[k][1]<j:\\n                left, j = self.space[k]\\n                req = k\\n\\n        #pop out required one\\n        left, j = self.space.pop(req)\\n        self.counter[mID]+=size\\n        ans = j\\n\\n        #Fill in\\n        while size:\\n            self.array[j] = mID\\n            j+=1\\n            left-=1\\n            size-=1\\n        \\n        #Re-filling the space\\n        if j<self.n:\\n            bisect.insort(self.space, (left, j))\\n        \\n        return ans\\n        \\n\\n    def free(self, mID: int) -> int:\\n        if mID not in self.counter: return 0\\n        ans = self.counter[mID]\\n        #DELETING ID\\n        del self.counter[mID]\\n\\n        #Removing previous spaces\\n        self.space.clear()\\n        curr, last = 0, 1e9\\n        \\n        #Filling in new ones, use Insort for fast greedy insert\\n        for i in range(self.n):\\n            if self.array[i] in [0, mID]:\\n                self.array[i] = 0\\n                curr+=1\\n                last = min(last, i)\\n            else:\\n                if curr>0:\\n                    bisect.insort(self.space, (curr, last))\\n        \\n                curr = 0\\n                last = 1e9\\n                \\n        if curr>0:\\n            bisect.insort(self.space, (curr, last))\\n            \\n        \\n        return ans\\n            \\n```\\n\\n# Note - \\nRuntime : $$369 ms$$ (100% faster)\\nMemory : $$14.5 MB$$ (50% faster)\\n**Upvote if you like it. :))**\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Design"
                ],
                "code": "```(space, leftmost_index)```\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.counter = defaultdict(int)     #Counts occurance/not neccessary but for fast searching\\n        self.n = n\\n        self.space = [(n, 0)]               #For check space (space, leftmost_index)\\n        self.array = [0]*n                  #Working array\\n        \\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        i = bisect.bisect_left(self.space, (size, 0))\\n        if i==len(self.space): return -1\\n        \\n        #We can go further ahead to check if there\\'s an index more left to current one\\n        req = i\\n        left, j = self.space[i]\\n        for k in range(i, len(self.space)):\\n            if self.space[k][1]<j:\\n                left, j = self.space[k]\\n                req = k\\n\\n        #pop out required one\\n        left, j = self.space.pop(req)\\n        self.counter[mID]+=size\\n        ans = j\\n\\n        #Fill in\\n        while size:\\n            self.array[j] = mID\\n            j+=1\\n            left-=1\\n            size-=1\\n        \\n        #Re-filling the space\\n        if j<self.n:\\n            bisect.insort(self.space, (left, j))\\n        \\n        return ans\\n        \\n\\n    def free(self, mID: int) -> int:\\n        if mID not in self.counter: return 0\\n        ans = self.counter[mID]\\n        #DELETING ID\\n        del self.counter[mID]\\n\\n        #Removing previous spaces\\n        self.space.clear()\\n        curr, last = 0, 1e9\\n        \\n        #Filling in new ones, use Insort for fast greedy insert\\n        for i in range(self.n):\\n            if self.array[i] in [0, mID]:\\n                self.array[i] = 0\\n                curr+=1\\n                last = min(last, i)\\n            else:\\n                if curr>0:\\n                    bisect.insort(self.space, (curr, last))\\n        \\n                curr = 0\\n                last = 1e9\\n                \\n        if curr>0:\\n            bisect.insort(self.space, (curr, last))\\n            \\n        \\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902404,
                "title": "c-difference-array",
                "content": "# Intuition\\nAlways mark the start and the end of a memory block that was allocated in an efficient way ($$O(1)$$), and store the <mID, <start, size>> pair in a hashtable in order to be retrieved in constant time, to have efficient free operations.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe main idea is that the beginning of a memory block will be marked  in an array by a +mID operation, and the end by a -mID operation. \\n\\nSo, incrementing the start element of a memory block with the mID and decrementing its end with the same value it\\'s enough to know that all the cells between start and end are from the same block labeled with mID.\\n\\n    // ex: allocate from 0 -> 5, using the mID = 1:\\n    //     a[0] += 1, a[5 + 1] -= 1\\n\\nIn order to retrieve the mID of some block of memory, I will keep a tracker variable for all the changes.\\n\\nFor instance, the +1 operation marked by a[0] will be propagated until the a[5], and when the index 6 is reached, the +1 will be anulated by the -1\\n\\n# Complexity\\n- Time complexity:\\n    - allocate(): $$O(n * log(n))$$\\n    - free(): $$O(n)$$, because we can have at most n independent blocks with the same mID that have to be cleared\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, because the tags unordered_map will hold at most n elements at a moment\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Allocator {\\nprivate:\\n    vector<int> memoryArray;\\n    unordered_map<int, vector<pair<int, int>>> tags;\\n    \\npublic:\\n    Allocator(int n) {\\n        memoryArray = vector<int>(n + 1, 0);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int current = 0;\\n        int len = 0;\\n        \\n        for (int i = 0; i < memoryArray.size() - 1; ++i) {\\n            current += memoryArray[i];\\n            \\n            if (current == 0) len++;\\n            else len = 0;\\n            \\n            if (len == size) {\\n                memoryArray[i - size + 1] += mID;\\n                memoryArray[i + 1] -= mID;\\n                tags[mID].push_back({i - size + 1, size});\\n                \\n                return i - size + 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int memoryUnits = 0;\\n        int sz = tags[mID].size();\\n        \\n        for (int i = 0; i < sz; ++i) {\\n            memoryUnits += tags[mID][i].second;\\n            memoryArray[tags[mID][i].first] -= mID;\\n            memoryArray[tags[mID][i].first + tags[mID][i].second] += mID;\\n        }\\n\\n        tags.erase(mID);\\n        return memoryUnits;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Allocator {\\nprivate:\\n    vector<int> memoryArray;\\n    unordered_map<int, vector<pair<int, int>>> tags;\\n    \\npublic:\\n    Allocator(int n) {\\n        memoryArray = vector<int>(n + 1, 0);\\n    }\\n    \\n    int allocate(int size, int mID) {\\n        int current = 0;\\n        int len = 0;\\n        \\n        for (int i = 0; i < memoryArray.size() - 1; ++i) {\\n            current += memoryArray[i];\\n            \\n            if (current == 0) len++;\\n            else len = 0;\\n            \\n            if (len == size) {\\n                memoryArray[i - size + 1] += mID;\\n                memoryArray[i + 1] -= mID;\\n                tags[mID].push_back({i - size + 1, size});\\n                \\n                return i - size + 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    int free(int mID) {\\n        int memoryUnits = 0;\\n        int sz = tags[mID].size();\\n        \\n        for (int i = 0; i < sz; ++i) {\\n            memoryUnits += tags[mID][i].second;\\n            memoryArray[tags[mID][i].first] -= mID;\\n            memoryArray[tags[mID][i].first + tags[mID][i].second] += mID;\\n        }\\n\\n        tags.erase(mID);\\n        return memoryUnits;\\n    }\\n};\\n\\n/**\\n * Your Allocator object will be instantiated and called as such:\\n * Allocator* obj = new Allocator(n);\\n * int param_1 = obj->allocate(size,mID);\\n * int param_2 = obj->free(mID);\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1713010,
                "content": [
                    {
                        "username": "krishnatiwarishikharrama",
                        "content": "while loop sucks "
                    },
                    {
                        "username": "sbthycode",
                        "content": "This guy is def God."
                    },
                    {
                        "username": "slammy",
                        "content": "Hare Krishna"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@brinuke](/brinuke) Hare Krishna\\n"
                    },
                    {
                        "username": "dcoder_op",
                        "content": "[@brinuke](/brinuke) Hare Krishna bro :)"
                    },
                    {
                        "username": "brinuke",
                        "content": "Hare Krishna"
                    }
                ]
            }
        ]
    }
]