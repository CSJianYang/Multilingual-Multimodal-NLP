[
    {
        "title": "K-diff Pairs in an Array",
        "question_content": "Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the array.\nA k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:\n\n\t0 <= i, j < nums.length\n\ti != j\n\t|nums[i] - nums[j]| == k\n\nNotice that |val| denotes the absolute value of val.\n&nbsp;\nExample 1:\n\nInput: nums = [3,1,4,1,5], k = 2\nOutput: 2\nExplanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).\nAlthough we have two 1s in the input, we should only return the number of unique pairs.\n\nExample 2:\n\nInput: nums = [1,2,3,4,5], k = 1\nOutput: 4\nExplanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\n\nExample 3:\n\nInput: nums = [1,3,1,5,4], k = 0\nOutput: 1\nExplanation: There is one 0-diff pair in the array, (1, 1).\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t-107 <= nums[i] <= 107\n\t0 <= k <= 107",
        "solutions": [
            {
                "id": 1756874,
                "title": "c-multiple-approaches-maps-two-pointer",
                "content": "Hi , This problem is pretty straightforward . Let me explain the problem first. \\n##### EXPLANATION : \\nThe problem says that we are provided with an array of integers and we have to find out the ***Count of unique pairs*** in the array such that the ***absolute difference of elements of the pair is ==k.***\\nMathematically , find the **count of unique pairs ( nums[i], nums[j] )** such that ,\\n* *0 <= i < j < nums.length*\\n* *|nums[i] - nums[j]| == k*\\n\\n##### SOLUTION : \\nIt is pretty clear that in order to obtain the answer , we have to find all pairs the array which have an absolute difference of \\'k\\' and then eliminate those which are not unique.\\n\\nThere are multiple ways to achieve that. \\n\\n#### 1. USING MAPS : \\nWe are aware of the fact that for a pair to be counted as an answer , **both the elements ( x and x+k ) , need to be in the array**. \\nSo we simply **create a map and store the frequency** of each element in the map. \\nNow we traverse the map and for **each element \\'x\\'** , we **check if \\'x+k\\' exists in the map** . If it does , then it means **a unique pair can be formed** and hence, we **increment the answer**. \\n##### EDGE CASE : \\nThe only edge case is the situation where**k=0**. If k=0 , instead of finding \\'x+k\\' , we **check if the frequency of \\'x\\'>1**. If it is , then we**increment the answer** . \\nElse , we don\\'t **increment the answer , as the frequency of x=1 and hence it can\\'t form a pair with itself**.\\n\\n##### CODE : \\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> a;\\n        for(int i:nums)\\n            a[i]++;\\n        int ans=0;\\n        for(auto x:a)\\n        {\\n            if(k==0)\\n            {    \\n                if(x.second>1)\\n                ans++;\\n            }\\n             else if(a.find(x.first+k)!=a.end())\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**TIME COMPLEXITY : O(N)**\\n**SPACE COMPLEXITY : O(N)**\\n\\n\\n#### 2. USING TWO POINTERS : \\nWe are aware of the fact that for a pair to be counted as an answer , **both the elements ( x and x+k ) , need to be in the array.** \\nIn this approach , **first we sort the array** and maintain 2 pointers. \\n* *1st Pointer --> 1st Element of the Pair*\\n* *2nd Pointer --> 2nd Element of the Pair*\\n\\nWe set the 1st pointer at the 0th index and 2nd pointer at the 1st index. Then , \\n1. Move the 2nd pointer until **2nd pointer - 1st pointer >=k** . \\n2. If the **2nd pointer - 1st pointer ==k** , then **increment the answer and move the 2nd pointer to the next greater element.**   \\n3. Move the **1st pointer to the next greater element**. \\n\\nFollow the above procedure until **the 2nd pointer reaches the end of the array**.\\n\\n##### CODE : \\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0,i=0,j=1;\\n        for(i,j;i<nums.size() and j<nums.size();)\\n        {\\n            if(i==j or nums[j]-nums[i]<k)\\n                j++;\\n            else \\n            {\\n                if(nums[j]-nums[i]==k)\\n                {\\n                    ans++;\\n                    j++;\\n                    for(;j<nums.size();j++)\\n                        if(nums[j]!=nums[j-1])\\n                            break;\\n                    if(j==nums.size())\\n                    return ans;\\n                    j--;                  \\n                }\\n                i++;\\n                while(i<j and nums[i]==nums[i-1])\\n                    i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**TIME COMPLEXITY : O(NlogN)**\\n**SPACE COMPLEXITY : O(1)**\\n\\n**NOTE : The 2nd approach doesn\\'t need to deal with the EDGE CASE mentioned in the 1st approach as , in the 2nd approach after finding a pair , we immediately move to the next greater element.**\\n\\nIf you found this post helpful , do upvote. \\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> a;\\n        for(int i:nums)\\n            a[i]++;\\n        int ans=0;\\n        for(auto x:a)\\n        {\\n            if(k==0)\\n            {    \\n                if(x.second>1)\\n                ans++;\\n            }\\n             else if(a.find(x.first+k)!=a.end())\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0,i=0,j=1;\\n        for(i,j;i<nums.size() and j<nums.size();)\\n        {\\n            if(i==j or nums[j]-nums[i]<k)\\n                j++;\\n            else \\n            {\\n                if(nums[j]-nums[i]==k)\\n                {\\n                    ans++;\\n                    j++;\\n                    for(;j<nums.size();j++)\\n                        if(nums[j]!=nums[j-1])\\n                            break;\\n                    if(j==nums.size())\\n                    return ans;\\n                    j--;                  \\n                }\\n                i++;\\n                while(i<j and nums[i]==nums[i-1])\\n                    i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756967,
                "title": "well-explained-two-easy-solutions",
                "content": "**First Approach : Using HashMap**\\n\\n1. First we will create map for counting frequencies of each element in the array.\\n2. Now we have 2 cases over here as \\n    -->a) if k == 0 it means we need to count frequency of the same element by using map.get(i) method.\\n\\t-->b) we need to take counter approach for every element by adding k everytime and check whether that element is present in map or not.\\n3. Instead of iterating through array, we will iterate through map.keySet() for getting unique elements.\\n\\t\\n\\t\\t// O(n) Time Solution\\n\\t\\n\\t\\tclass Solution {\\n\\t\\t\\t\\tpublic int findPairs(int[] nums, int k) {\\n\\t\\t\\t\\t\\tMap<Integer, Integer> map = new HashMap();\\n\\t\\t\\t\\t\\tfor (int num : nums)\\n\\t\\t\\t\\t\\t\\tmap.put(num, map.getOrDefault(num, 0) + 1);\\n\\n\\t\\t\\t\\t\\tint result = 0;\\n\\t\\t\\t\\t\\tfor (int i : map.keySet())\\n\\t\\t\\t\\t\\t\\tif (k > 0 && map.containsKey(i + k) || k == 0 && map.get(i) > 1)\\n\\t\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\treturn result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n**Second Approach : Using HashSet**\\n\\n1. First sort the array.\\n2. After that, iterating through loop from first element to the last element.\\n3. Using BinarySearch, checked whether (nums[i] + k) is present in the array from index i+1 to n....i.e. if it is present we can take it as for counting approach.\\n\\t\\t\\n\\t\\tArrays.binarySearch(array_name, start_index, end_index, value_for_checking) ==> this method returns index of value which we are searching.\\n\\t\\t\\n4. After that just added minimum element to set for getting unique pairs as we know set contains only unique values.\\n \\n\\t\\t// O(nlogn) Time Solution\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic int findPairs(int[] nums, int k) {\\n\\t\\t\\t\\tSet<Integer> uniquePair = new HashSet();\\n\\t\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\t\\tint n = nums.length;\\n\\n\\t\\t\\t\\tfor (int i = 0; i < n - 1; i++)\\n\\t\\t\\t\\t\\tif (Arrays.binarySearch(nums, i + 1, n, nums[i] + k) > 0)\\n\\t\\t\\t\\t\\t\\tuniquePair.add(nums[i]);\\n\\n\\t\\t\\t\\treturn uniquePair.size();\\n\\t\\t\\t}\\n\\t\\t}\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0\\uD83C\\uDF38), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\tpublic int findPairs(int[] nums, int k) {\\n\\t\\t\\t\\t\\tMap<Integer, Integer> map = new HashMap();\\n\\t\\t\\t\\t\\tfor (int num : nums)\\n\\t\\t\\t\\t\\t\\tmap.put(num, map.getOrDefault(num, 0) + 1);\\n\\n\\t\\t\\t\\t\\tint result = 0;\\n\\t\\t\\t\\t\\tfor (int i : map.keySet())\\n\\t\\t\\t\\t\\t\\tif (k > 0 && map.containsKey(i + k) || k == 0 && map.get(i) > 1)\\n\\t\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\treturn result;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1756933,
                "title": "an-explanation-going-from-o-nlogn-o-n",
                "content": "So, this problem is very similar to a very famous problem `Two Sum` problem. But a slightly different, there we have to only check wether a pair exists or not which has 2 sum equals to the target. But here we have to count those such pairs & only consider the unique one.\\n\\n**Okay, so how we will solve this problem?**\\n\\n>One of the first idea came in mind that first-of all we sort this array. Let\\'s take an example :-\\n\\n**Input:** nums = [3,1,4,1,5], k = 2\\n**Output:** 2\\n\\nFirst we sort this array & it becomes :- [1,1,3,4,5]. After sorting what we will do is, start from the starting place & check the \\'x + k\\' exists on to right place or not!\\n\\n![image](https://assets.leetcode.com/users/images/525d936e-2f0e-435d-a65d-aa1fa0d50ee3_1644372336.409042.png)\\n\\nSo, first we sort the array & then we will look for the binary search. There is a `method in Java library` called **Arrays.binarySearch** & it may be available in `C++ & Python`. In this method we will pass the array [nums], start index [i + 1], end [n] \"size of the array\" & the value which we have to search [x + k]. If we find that we, then we will store minimum value of \\'x\\' into a set. Because we need only the **Unique Pair**.\\n\\nSo, we will get :- **{1,3} & {3,5}** so these are the 2 pairs we will get. \\n\\n***Let\\'s look at the code you will understand more clearly then,***\\n\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums); // sorted the array\\n        Set<Integer> set = new HashSet<>(); // Declare the HashSet to only consider unique one\\'s\\n        int n = nums.length; // length of the array\\n        for(int i = 0; i < nums.length - 1; i++){\\n            // searching for binary index for the no from the i + 1 index to n \\n            // and check if we are getting nums[i] + k, where nums[i] is our \\'x\\'\\n            if(Arrays.binarySearch(nums, i + 1, n, nums[i] + k) > 0){\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```\\n**Time Complexity :-** O(NlogN) + O(N * logN) = O(NlogN) + O(NlogN) = O(2NlogN) = *BigO(NlogN)*\\n\\n<hr>\\n<hr>\\n\\n> **Now, you we will ask**. Can we further improve it\\'s time complexity? **I\\'ll say yes. Using HashMap.**\\n\\nOkay, so considering the same example : nums[3,1,4,1,5]\\n\\nFirst we will build our HashMap. In Map we will keep the no. as a key & value as a count of occurence\\n\\n![image](https://assets.leetcode.com/users/images/16d72c73-6d89-4fcb-8bf0-db63867f5e1c_1644373538.138938.png)\\n\\nNow, there are 2 cases :-\\n1. If k > 0, then in this case we just need to check wether the counter part exists or not. So, if we are iterating \\'x + k\\' in our map, then we can increment our count\\n\\n\\n2. If k == 0, then we just need to check if x is more then 1 or not [x > 1] in our map.\\n\\nBut another thing we need to note that here as we iterate from the array after doing counting. Then we will get \"1\" two times. So, to avoid this instead of iterating over the array, we will iterate over the keyset of this map, which will give us the unique no. i.e. (3,1,4,5).\\n\\nAlright, so now *I hope approach is clear.*\\n\\n**Let\\'s code it:**\\n\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int num : nums){\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        int count = 0;\\n        for(int x : map.keySet()){\\n            if(k > 0 && map.containsKey(x + k) || k == 0 && map.get(x) > 1) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums); // sorted the array\\n        Set<Integer> set = new HashSet<>(); // Declare the HashSet to only consider unique one\\'s\\n        int n = nums.length; // length of the array\\n        for(int i = 0; i < nums.length - 1; i++){\\n            // searching for binary index for the no from the i + 1 index to n \\n            // and check if we are getting nums[i] + k, where nums[i] is our \\'x\\'\\n            if(Arrays.binarySearch(nums, i + 1, n, nums[i] + k) > 0){\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int num : nums){\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        int count = 0;\\n        for(int x : map.keySet()){\\n            if(k > 0 && map.containsKey(x + k) || k == 0 && map.get(x) > 1) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100098,
                "title": "java-o-n-solution-one-hashmap-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if (nums == null || nums.length == 0 || k < 0)   return 0;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for (int i : nums) {\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            if (k == 0) {\\n                //count how many elements in the array that appear more than twice.\\n                if (entry.getValue() >= 2) {\\n                    count++;\\n                } \\n            } else {\\n                if (map.containsKey(entry.getKey() + k)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if (nums == null || nums.length == 0 || k < 0)   return 0;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for (int i : nums) {\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            if (k == 0) {\\n                //count how many elements in the array that appear more than twice.\\n                if (entry.getValue() >= 2) {\\n                    count++;\\n                } \\n            } else {\\n                if (map.containsKey(entry.getKey() + k)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100135,
                "title": "java-python-easy-understood-solution",
                "content": "# **Explanation**\\nCount the elements with `Counter`\\nIf `k > 0`, for each element `i`, check if `i + k` exist.\\nIf `k == 0`, for each element `i`, check if `count[i] > 1`\\n<br>\\n\\n# **Explanation**\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**Python**\\n```py\\ndef findPairs(self, nums, k):\\n        res = 0\\n        c = collections.Counter(nums)\\n        for i in c:\\n            if k > 0 and i + k in c or k == 0 and c[i] > 1:\\n                res += 1\\n        return res\\n```\\nwhich equals to:\\n```py\\ndef findPairs(self, nums, k):\\n        c = collections.Counter(nums)\\n        return  sum(k > 0 and i + k in c or k == 0 and c[i] > 1 for i in c)\\n```\\n\\n**Java**\\nBy @blackspinner\\n```java\\n    public int findPairs(int[] nums, int k) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int x : nums) {\\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\\n        }\\n        int res = 0;\\n        for (int x : cnt.keySet()) {\\n            if ((k > 0 && cnt.containsKey(x + k)) || (k == 0 && cnt.get(x) > 1)) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```py\\ndef findPairs(self, nums, k):\\n        res = 0\\n        c = collections.Counter(nums)\\n        for i in c:\\n            if k > 0 and i + k in c or k == 0 and c[i] > 1:\\n                res += 1\\n        return res\\n```\n```py\\ndef findPairs(self, nums, k):\\n        c = collections.Counter(nums)\\n        return  sum(k > 0 and i + k in c or k == 0 and c[i] > 1 for i in c)\\n```\n```java\\n    public int findPairs(int[] nums, int k) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int x : nums) {\\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\\n        }\\n        int res = 0;\\n        for (int x : cnt.keySet()) {\\n            if ((k > 0 && cnt.containsKey(x + k)) || (k == 0 && cnt.get(x) > 1)) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 142648,
                "title": "easy-java-solution-two-hashsets-o-n",
                "content": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if (k < 0) return 0;\\n        Set<Integer> numbers = new HashSet<>();\\n        Set<Integer> found = new HashSet<>();\\n        for (int n : nums) {\\n            if (numbers.contains(n + k)) found.add(n);\\n            if (numbers.contains(n - k)) found.add(n - k);\\n            numbers.add(n);\\n        }\\n        return found.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if (k < 0) return 0;\\n        Set<Integer> numbers = new HashSet<>();\\n        Set<Integer> found = new HashSet<>();\\n        for (int n : nums) {\\n            if (numbers.contains(n + k)) found.add(n);\\n            if (numbers.contains(n - k)) found.add(n - k);\\n            numbers.add(n);\\n        }\\n        return found.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100104,
                "title": "two-pointer-approach",
                "content": "The problem is just a variant of 2-sum.\\n**Update:** Fixed a bug that can cause integer subtraction overflow.\\n**Update:** The code runs in `O(n log n)` time, using `O(1)` space.\\n\\n```java\\npublic int findPairs(int[] nums, int k) {\\n    int ans = 0;\\n    Arrays.sort(nums);\\n    for (int i = 0, j = 0; i < nums.length; i++) {\\n        for (j = Math.max(j, i + 1); j < nums.length && (long) nums[j] - nums[i] < k; j++) ;\\n        if (j < nums.length && (long) nums[j] - nums[i] == k) ans++;\\n        while (i + 1 < nums.length && nums[i] == nums[i + 1]) i++;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int findPairs(int[] nums, int k) {\\n    int ans = 0;\\n    Arrays.sort(nums);\\n    for (int i = 0, j = 0; i < nums.length; i++) {\\n        for (j = Math.max(j, i + 1); j < nums.length && (long) nums[j] - nums[i] < k; j++) ;\\n        if (j < nums.length && (long) nums[j] - nums[i] == k) ans++;\\n        while (i + 1 < nums.length && nums[i] == nums[i + 1]) i++;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 100101,
                "title": "c-o-n-time-with-unordered-map",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n```\\n// OJ: https://leetcode.com/problems/k-diff-pairs-in-an-array\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n  int findPairs(vector<int>& nums, int k) {\\n    if (k < 0) return 0;\\n    unordered_map<int, int> m;\\n    for (int n : nums) m[n]++;\\n    int cnt = 0;\\n    for (auto p : m) {\\n      if ((!k && p.second > 1)\\n        || (k && m.count(p.first + k))) ++cnt;\\n    }\\n    return cnt;\\n  }\\n};\\n```\\n\\n---\\n\\nUpdate 2022/02/08:\\n\\nBack on 2017/06/06, the constraint of this problem was as follows (You can see the full problem description [here](https://github.com/lzl124631x/LeetCode/commit/8536736d9fb97483cd0875ccb7a7830b30420b24))\\n\\n>Given an array of integers and an integer **k**, ...\\n>**Note:**  \\n>\\n>1.  The pairs (i, j) and (j, i) count as the same pair.\\n>2.  The length of the array won\\'t exceed 10,000.\\n>3.  All the integers in the given input belong to the range: [-1e7, 1e7].\\n\\nIt didn\\'t say that `k >= 0`. That\\'s why I added the `k < 0` guard -- just like what we need to do in real world.\\n\\nNowadays, the constraints on LeetCode are much more detailed and explicit.\\n\\nIf I write the code today:\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/k-diff-pairs-in-an-array\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& A, int k) {\\n        unordered_map<int, int> m;\\n        for (int n : A) m[n]++;\\n        int ans = 0;\\n        for (auto &[n, cnt] : m) {\\n            ans += k ? m.count(n - k) : cnt > 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// OJ: https://leetcode.com/problems/k-diff-pairs-in-an-array\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n  int findPairs(vector<int>& nums, int k) {\\n    if (k < 0) return 0;\\n    unordered_map<int, int> m;\\n    for (int n : nums) m[n]++;\\n    int cnt = 0;\\n    for (auto p : m) {\\n      if ((!k && p.second > 1)\\n        || (k && m.count(p.first + k))) ++cnt;\\n    }\\n    return cnt;\\n  }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/k-diff-pairs-in-an-array\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& A, int k) {\\n        unordered_map<int, int> m;\\n        for (int n : A) m[n]++;\\n        int ans = 0;\\n        for (auto &[n, cnt] : m) {\\n            ans += k ? m.count(n - k) : cnt > 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100151,
                "title": "c-java-clean-code-with-explanation-set-map",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    /**\\n     * for every number in the array:\\n     *  - if there was a number previously k-diff with it, save the smaller to a set;\\n     *  - and save the value-index to a map;\\n     */\\n    int findPairs(vector<int>& nums, int k) {\\n        if (k < 0) {\\n            return 0;\\n        }\\n        unordered_set<int> starters;\\n        unordered_map<int, int> indices;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (indices.count(nums[i] - k)) {\\n                starters.insert(nums[i] - k);\\n            }\\n            if (indices.count(nums[i] + k)) {\\n                starters.insert(nums[i]);\\n            }\\n\\n            indices[nums[i]] += 1;\\n        }\\n        \\n        return starters.size();\\n    }\\n};\\n```\\n**Java**\\n```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if (k < 0) { return 0; }\\n\\n        Set<Integer> starters = new HashSet<Integer>();\\n        Set<Integer> uniqs = new HashSet<Integer>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (uniqs.contains(nums[i] - k)) starters.add(nums[i] - k);\\n            if (uniqs.contains(nums[i] + k)) starters.add(nums[i]);\\n            uniqs.add(nums[i]);\\n        }\\n\\n        return starters.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /**\\n     * for every number in the array:\\n     *  - if there was a number previously k-diff with it, save the smaller to a set;\\n     *  - and save the value-index to a map;\\n     */\\n    int findPairs(vector<int>& nums, int k) {\\n        if (k < 0) {\\n            return 0;\\n        }\\n        unordered_set<int> starters;\\n        unordered_map<int, int> indices;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (indices.count(nums[i] - k)) {\\n                starters.insert(nums[i] - k);\\n            }\\n            if (indices.count(nums[i] + k)) {\\n                starters.insert(nums[i]);\\n            }\\n\\n            indices[nums[i]] += 1;\\n        }\\n        \\n        return starters.size();\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if (k < 0) { return 0; }\\n\\n        Set<Integer> starters = new HashSet<Integer>();\\n        Set<Integer> uniqs = new HashSet<Integer>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (uniqs.contains(nums[i] - k)) starters.add(nums[i] - k);\\n            if (uniqs.contains(nums[i] + k)) starters.add(nums[i]);\\n            uniqs.add(nums[i]);\\n        }\\n\\n        return starters.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876197,
                "title": "python-o-n-solution-explained",
                "content": "Let us just use counter and count frequency of each number in our array. We can have two options:\\n\\n1. `k > 0`, it means, that for each unique number `i` we are asking if number `i+k` also in table.\\n2. `k = 0`, it means, that we are looking for pairs of equal numbers, so just check each frequency.\\n\\n**Complexity**: time and space complexity is `O(n)`, because we traverse our array twice: first time to create counter and second to find `res`.\\n\\n```\\nclass Solution:\\n    def findPairs(self, nums, k):\\n        count = Counter(nums)\\n        if k > 0:\\n            res = sum([i + k in count for i in count])\\n        else:\\n            res = sum([count[i] > 1 for i in count])\\n        return res\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums, k):\\n        count = Counter(nums)\\n        if k > 0:\\n            res = sum([i + k in count for i in count])\\n        else:\\n            res = sum([count[i] > 1 for i in count])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100116,
                "title": "1-liner-in-python-o-n-time",
                "content": "```\\n    def findPairs(self, nums, k):\\n       return len(set(nums)&{n+k for n in nums}) if k>0 else sum(v>1 for v in collections.Counter(nums).values()) if k==0 else 0\\n```\\nwhich is equivalent to:\\n```\\n    def findPairs(self, nums, k):\\n        if k>0:\\n            return len(set(nums)&set(n+k for n in nums))\\n        elif k==0:\\n            sum(v>1 for v in collections.Counter(nums).values())\\n        else:\\n            return 0\\n```",
                "solutionTags": [],
                "code": "```\\n    def findPairs(self, nums, k):\\n       return len(set(nums)&{n+k for n in nums}) if k>0 else sum(v>1 for v in collections.Counter(nums).values()) if k==0 else 0\\n```\n```\\n    def findPairs(self, nums, k):\\n        if k>0:\\n            return len(set(nums)&set(n+k for n in nums))\\n        elif k==0:\\n            sum(v>1 for v in collections.Counter(nums).values())\\n        else:\\n            return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1757434,
                "title": "python-o-n-solution-98-faster-easy-solution-k-diff-pairs-in-an-array",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\nVisit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation: https://www.python-techs.com/\\n\\n**Solution:**\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        cnt=0\\n        c=Counter(nums)\\n        \\n        if k==0:\\n            for key,v in c.items():\\n                if v>1:\\n                    cnt+=1\\n        else:\\n            for key,v in c.items():\\n                if key+k in c:\\n                    cnt+=1\\n        return cnt\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        cnt=0\\n        c=Counter(nums)\\n        \\n        if k==0:\\n            for key,v in c.items():\\n                if v>1:\\n                    cnt+=1\\n        else:\\n            for key,v in c.items():\\n                if key+k in c:\\n                    cnt+=1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877159,
                "title": "c-super-simple-solution-o-n-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> map;\\n        for(auto num:nums)\\n            map[num]++;\\n        \\n        int res = 0;\\n        if (k > 0) {\\n            for(auto a:map)\\n                if (map.find(a.first+k) != map.end()) \\n                    res++;\\n        }\\n        \\n        else {\\n            for(auto a:map)\\n                if (a.second > 1)\\n                    res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> map;\\n        for(auto num:nums)\\n            map[num]++;\\n        \\n        int res = 0;\\n        if (k > 0) {\\n            for(auto a:map)\\n                if (map.find(a.first+k) != map.end()) \\n                    res++;\\n        }\\n        \\n        else {\\n            for(auto a:map)\\n                if (a.second > 1)\\n                    res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757692,
                "title": "java-easy-to-understand-two-approaches-sorting-hashmap",
                "content": "#### **Method 1:  using sorting and two pointers**\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int i=0, j=1, diff=0, n=nums.length, sum=Integer.MIN_VALUE;\\n        int count=0;\\n        while(j<n && i<n-1){\\n\\t\\t    // ((nums[i]+nums[j])!=sum) -> this will take care of no repetetion\\n\\t\\t\\t//if we found any match, increase i , j by 1\\n            if(nums[j]-nums[i]==k && (nums[i]+nums[j])!=sum){\\n                sum=nums[i]+nums[j];\\n                i++; j++; count++;\\n            }\\n\\t\\t\\t//if diff is smaller than k increase j by 1\\n\\t\\t\\telse if((nums[j]-nums[i])<k){\\n                j++;\\n            }\\n\\t\\t\\t//else case, when diff is greater than k, increase i by 1\\n\\t\\t\\telse{\\n                i++;\\n            }\\n\\t\\t\\t//check if i and j are not same to aoid duplicates\\n            if(i==j) j++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Time Complexity** : O(nlogn) + O(n)\\n**Space Complexity** : O(n)\\n\\n#### **Method 2 : using HashMap**\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n\\t    // corner cases\\n        if(nums==null || nums.length==0 || k<0) return 0;\\n        int count=0;\\n        Map<Integer, Integer> hash=new HashMap<>();\\n\\t\\t//frequency map\\n        for(int i:nums)\\n            hash.put(i, hash.getOrDefault(i, 0)+1);\\n        for(Map.Entry<Integer, Integer> entry:hash.entrySet())\\n\\t\\t    // check if any such pair exist or not\\n\\t\\t\\t//in case of k==0 check whether any number having frequency >=2 or not.\\n            if((hash.containsKey(entry.getKey()+k) && k!=0) || (k==0 && entry.getValue()>1))\\n                count++;\\n        return count;\\n    }\\n}\\n```\\n**Time Complexity** :  O(n)\\n**Space Complexity** : O(n)\\n\\n**Don\\'t forget to upvote, it inspires me a lot, Thank you!**",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int i=0, j=1, diff=0, n=nums.length, sum=Integer.MIN_VALUE;\\n        int count=0;\\n        while(j<n && i<n-1){\\n\\t\\t    // ((nums[i]+nums[j])!=sum) -> this will take care of no repetetion\\n\\t\\t\\t//if we found any match, increase i , j by 1\\n            if(nums[j]-nums[i]==k && (nums[i]+nums[j])!=sum){\\n                sum=nums[i]+nums[j];\\n                i++; j++; count++;\\n            }\\n\\t\\t\\t//if diff is smaller than k increase j by 1\\n\\t\\t\\telse if((nums[j]-nums[i])<k){\\n                j++;\\n            }\\n\\t\\t\\t//else case, when diff is greater than k, increase i by 1\\n\\t\\t\\telse{\\n                i++;\\n            }\\n\\t\\t\\t//check if i and j are not same to aoid duplicates\\n            if(i==j) j++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n\\t    // corner cases\\n        if(nums==null || nums.length==0 || k<0) return 0;\\n        int count=0;\\n        Map<Integer, Integer> hash=new HashMap<>();\\n\\t\\t//frequency map\\n        for(int i:nums)\\n            hash.put(i, hash.getOrDefault(i, 0)+1);\\n        for(Map.Entry<Integer, Integer> entry:hash.entrySet())\\n\\t\\t    // check if any such pair exist or not\\n\\t\\t\\t//in case of k==0 check whether any number having frequency >=2 or not.\\n            if((hash.containsKey(entry.getKey()+k) && k!=0) || (k==0 && entry.getValue()>1))\\n                count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100109,
                "title": "interesting-java-solution-hashset-only",
                "content": "Put all numbers n in Hashset S1.\\nPut all numbers n+k in HashSet S2.\\nThe number of pairs are the intersection of the two Hashsets. Different conditions apply to k=0 or k<0.\\n\\n```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n        int ans = 0;\\n        \\n        if(k<0) return ans;\\n        \\n        Set<Integer> set1 = new HashSet<Integer> ();\\n        Set<Integer> set2 = new HashSet<Integer> ();\\n        \\n        if(k==0){\\n                for(int n:nums){\\n                    if(!set1.contains(n))\\n                        {set1.add(n);}\\n                    else{\\n                        set1.remove(n);\\n                        if(!set2.contains(n)) ans++;\\n                        set2.add(n);\\n                        }\\n                }\\n        }\\n        else{\\n            for(int n:nums){\\n                set1.add(n);\\n                set2.add(n+k);\\n            }\\n            set1.retainAll(set2);\\n            ans = set1.size();\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n        int ans = 0;\\n        \\n        if(k<0) return ans;\\n        \\n        Set<Integer> set1 = new HashSet<Integer> ();\\n        Set<Integer> set2 = new HashSet<Integer> ();\\n        \\n        if(k==0){\\n                for(int n:nums){\\n                    if(!set1.contains(n))\\n                        {set1.add(n);}\\n                    else{\\n                        set1.remove(n);\\n                        if(!set2.contains(n)) ans++;\\n                        set2.add(n);\\n                        }\\n                }\\n        }\\n        else{\\n            for(int n:nums){\\n                set1.add(n);\\n                set2.add(n+k);\\n            }\\n            set1.retainAll(set2);\\n            ans = set1.size();\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757438,
                "title": "c-solution-w-explanation-brute-force-to-optimize-two-approaches",
                "content": "***Brief note about Question-***\\n\\nWe have to  ***return the number of unique k-diff pairs in the array.***\\n\\nK- diff pair (arr[i], arr[j]) is nothing but basically \\n* 0 < i < j < arr.size()\\n* abs(arr[i] - arr[j]) == k\\n______________\\n***Solution - I (Accepted)-***\\n* We try to implement what the question wants to do, like this is the most basic thing we can do.\\n* We traverse from all of the array and find unique pairs where their absoloute difference is k and increment our count.\\n* See commented program for explanation.\\n```\\nTime Complexity --> O(n ^ 2) // where n is the length of the array\\nSpace Complexity --> O(n) // as we are using map to store pairs\\nIt paases [ 60 / 60] in built test cases\\n```\\n\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& arr, int k) {\\n        int n = arr.size(); // take the size of the array\\n        int count = 0; // variable to store count\\n        \\n        sort(arr.begin(), arr.end()); // sort the array to find unique pairs\\n        map<pair<int,int>, int> mp; // make a map where key is pair & value if it occurs\\n        \\n        for(int i = 0; i < n - 1; i++) // traverse from the whole array\\n        {\\n            for(int j = i + 1; j < n; j++)\\n            {\\n                if(abs(arr[j] - arr[i]) == k) // if it follows criteria\\n                {\\n                    // make a pair to find whether it is unique or not\\n                    pair<int,int> p = {arr[i], arr[j]}; \\n                    \\n                     // if this pair not present in the map, then we do the computation\\n                    if(mp.find(p) == mp.end())\\n                    {\\n                        count++; // increment count\\n                        mp[p] = 1; // make its value as 1, saying that now it is present in our map\\n                    }\\n                }\\n            }\\n        }\\n        return count; // and at last return the count\\n    }\\n};\\n```\\n__________________\\n***Solution - II (Accepted)-***\\n* So a question arises can we optimise it.\\n* And answer is yes, but how?\\n* See, *we have to find number of unique pairs such that their absoloute difference is k.*\\n* suppose, **`a - b == k --> a = b + k`**\\n* Can\\'t we store all the values of array into a map and then `for every value we find value + k`.\\n* That\\'s all we have to do.\\n* see commented code for more explanation.\\n```\\nTime Complexity --> O(n) // where n is the length of the array\\nSpace Complexity --> O(n) // as we are using unordered map to store pairs\\nIt paases [ 60 / 60] in built test cases\\n```\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& arr, int k) {\\n        int n = arr.size(); // take the size of the array\\n        unordered_map<int, int> mp; // map to store all values of array\\n        \\n        for(int i = 0; i < n; i++) //store all values of array into map\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n        int count = 0; // variable to store the unique pairs\\n        \\n        if(k != 0) // if k is not zero\\n        {\\n            for(auto it = mp.begin(); it != mp.end(); it++) // traverse in all over the map\\n            {\\n                // if value + k is present in map\\n                if(mp.find(it -> first + k) != mp.end())\\n                {\\n                    count++; // increment count\\n                }\\n            }\\n        }\\n        else // see for k = 0, we have to just find all the values greater than 1\\n        {\\n            for(auto it = mp.begin(); it != mp.end(); it++)\\n            {\\n                if(it -> second > 1)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count; // at last return count\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTime Complexity --> O(n ^ 2) // where n is the length of the array\\nSpace Complexity --> O(n) // as we are using map to store pairs\\nIt paases [ 60 / 60] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& arr, int k) {\\n        int n = arr.size(); // take the size of the array\\n        int count = 0; // variable to store count\\n        \\n        sort(arr.begin(), arr.end()); // sort the array to find unique pairs\\n        map<pair<int,int>, int> mp; // make a map where key is pair & value if it occurs\\n        \\n        for(int i = 0; i < n - 1; i++) // traverse from the whole array\\n        {\\n            for(int j = i + 1; j < n; j++)\\n            {\\n                if(abs(arr[j] - arr[i]) == k) // if it follows criteria\\n                {\\n                    // make a pair to find whether it is unique or not\\n                    pair<int,int> p = {arr[i], arr[j]}; \\n                    \\n                     // if this pair not present in the map, then we do the computation\\n                    if(mp.find(p) == mp.end())\\n                    {\\n                        count++; // increment count\\n                        mp[p] = 1; // make its value as 1, saying that now it is present in our map\\n                    }\\n                }\\n            }\\n        }\\n        return count; // and at last return the count\\n    }\\n};\\n```\n```\\nTime Complexity --> O(n) // where n is the length of the array\\nSpace Complexity --> O(n) // as we are using unordered map to store pairs\\nIt paases [ 60 / 60] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& arr, int k) {\\n        int n = arr.size(); // take the size of the array\\n        unordered_map<int, int> mp; // map to store all values of array\\n        \\n        for(int i = 0; i < n; i++) //store all values of array into map\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n        int count = 0; // variable to store the unique pairs\\n        \\n        if(k != 0) // if k is not zero\\n        {\\n            for(auto it = mp.begin(); it != mp.end(); it++) // traverse in all over the map\\n            {\\n                // if value + k is present in map\\n                if(mp.find(it -> first + k) != mp.end())\\n                {\\n                    count++; // increment count\\n                }\\n            }\\n        }\\n        else // see for k = 0, we have to just find all the values greater than 1\\n        {\\n            for(auto it = mp.begin(); it != mp.end(); it++)\\n            {\\n                if(it -> second > 1)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count; // at last return count\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324925,
                "title": "readable-simple-python",
                "content": "O(n) Time.\\nO(n) Space.\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n\\t\\t#If k is less than 0, then the result is 0 since we are looking fpr pairs with an ABSOLUTE difference of k.\\n        if k < 0:\\n            return 0\\n        \\n        count = Counter(nums)\\n        pairs = set([])\\n        \\n        for num in count.keys():\\n\\t\\t\\t#Special case: If k == 0, then there needs to be at least two occurences of a particular num in nums \\n\\t\\t\\t#in order for there to be a pair (num, num).\\n            if k == 0:\\n                if count[num] > 1:\\n                    pairs.add((num, num))\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#Regular case: k != 0. Simply check if num + k is a member of the array nums.\\n\\t\\t\\t#Insert the pair into the set of pairs (smallerNum, largerNum) so that there are no duplicate pairs.\\n            else:\\n                otherNum = num + k\\n                if otherNum in count:\\n                    pairs.add((num, otherNum) if num <= otherNum else (otherNum, num))\\n                    \\n        return len(pairs)\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n\\t\\t#If k is less than 0, then the result is 0 since we are looking fpr pairs with an ABSOLUTE difference of k.\\n        if k < 0:\\n            return 0\\n        \\n        count = Counter(nums)\\n        pairs = set([])\\n        \\n        for num in count.keys():\\n\\t\\t\\t#Special case: If k == 0, then there needs to be at least two occurences of a particular num in nums \\n\\t\\t\\t#in order for there to be a pair (num, num).\\n            if k == 0:\\n                if count[num] > 1:\\n                    pairs.add((num, num))\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#Regular case: k != 0. Simply check if num + k is a member of the array nums.\\n\\t\\t\\t#Insert the pair into the set of pairs (smallerNum, largerNum) so that there are no duplicate pairs.\\n            else:\\n                otherNum = num + k\\n                if otherNum in count:\\n                    pairs.add((num, otherNum) if num <= otherNum else (otherNum, num))\\n                    \\n        return len(pairs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100111,
                "title": "o-n-concise-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        if(k < 0) return 0;\\n        unordered_map<int,int> m;\\n        for(int i = 0; i < nums.size(); ++i)\\n           ++m[nums[i]];\\n        int res = 0;\\n        if(k != 0) {\\n            for(auto it = m.begin(); it != m.end(); ++it)\\n               if(m.find(it->first+k) != m.end())\\n                   ++res;\\n        } else {\\n            for(auto it = m.begin(); it != m.end(); ++it)\\n               if(it->second > 1)\\n                   ++res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        if(k < 0) return 0;\\n        unordered_map<int,int> m;\\n        for(int i = 0; i < nums.size(); ++i)\\n           ++m[nums[i]];\\n        int res = 0;\\n        if(k != 0) {\\n            for(auto it = m.begin(); it != m.end(); ++it)\\n               if(m.find(it->first+k) != m.end())\\n                   ++res;\\n        } else {\\n            for(auto it = m.begin(); it != m.end(); ++it)\\n               if(it->second > 1)\\n                   ++res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399753,
                "title": "python-concise-o-n-solution-using-sets-only-one-pass-through-the-list",
                "content": "Check whether num + k and num - k are already in the set and also make sure the pair is not already counted. Only goes throught the list one time.\\n\\nEdit: after reading other solutions, some memory can be saved by only saving the smallest value between num1 and num2 in pairsSet instead of the sorted tuple.\\n```\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        if k < 0: return 0\\n        numsSet, pairsSet = set(), set()\\n        for num1 in nums:\\n            for num2 in [num1 + k, num1 - k]:\\n                if num2 in numsSet:\\n                    pairsSet.add(tuple(sorted([num1, num2])))\\n            numsSet.add(num1)\\n        return len(pairsSet)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        if k < 0: return 0\\n        numsSet, pairsSet = set(), set()\\n        for num1 in nums:\\n            for num2 in [num1 + k, num1 - k]:\\n                if num2 in numsSet:\\n                    pairsSet.add(tuple(sorted([num1, num2])))\\n            numsSet.add(num1)\\n        return len(pairsSet)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298502,
                "title": "java-6ms-beats-98-simple-2-pointer-approach",
                "content": "This is a pretty standard 2 pointer approach with a unique take away when looking at duplicates. One thing that took me a little bit to wrap my head around was how we can accurately determine what is a valid answer. I also didn\\'t see any posts where they showed this approach so I thought I would share.\\n\\n\\nTo start I think its easier to look at, what IS NOT a valid answer.\\n1. If the left pointer has caught up to our right pointer. This is between two different values so if left == right, this will never be a valid answer.\\n2. If we have previously used this value to accurately determine that two values compute a valid answer.\\n\\t* \\tFor this problem I used a previous variable and set it whenever we find a value where nums[r] - nums[l] == k. This stops any sort of duplicates from happening.\\n3. As mentioned earlier we must also check that nums[r]-nums[l] == k. We use the while loop to get as close as possible for each iteration but we need the final if statement to check accuracy.\\n\\nHope this helps someone!\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if(nums == null || nums.length < 1) return 0;\\n        \\n        Arrays.sort(nums);\\n        int l = 0, ans = 0, prev = Integer.MAX_VALUE;\\n        for(int r = 1; r < nums.length; r++) {\\n            while(l < r && nums[r] - nums[l] > k) l++;\\n            \\n            if(l != r && prev != nums[l] && nums[r] - nums[l] == k) {\\n                ans++;\\n                prev = nums[l];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if(nums == null || nums.length < 1) return 0;\\n        \\n        Arrays.sort(nums);\\n        int l = 0, ans = 0, prev = Integer.MAX_VALUE;\\n        for(int r = 1; r < nums.length; r++) {\\n            while(l < r && nums[r] - nums[l] > k) l++;\\n            \\n            if(l != r && prev != nums[l] && nums[r] - nums[l] == k) {\\n                ans++;\\n                prev = nums[l];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287783,
                "title": "java-o-n-hashmap-one-pass-easy-solution",
                "content": "```\\npublic int findPairs(int[] nums, int k) {\\n        int count =0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(!map.containsKey(nums[i])) {\\n                if(map.containsKey(nums[i] + k)) count++;\\n                if(map.containsKey(nums[i] - k)) count++;\\n                map.put(nums[i], 1);\\n            } else if (k == 0) {\\n                   if(map.get(nums[i]) == 1)\\n                      count++;\\n                   map.put(nums[i], map.get(nums[i]) + 1);\\n            }         \\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findPairs(int[] nums, int k) {\\n        int count =0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(!map.containsKey(nums[i])) {\\n                if(map.containsKey(nums[i] + k)) count++;\\n                if(map.containsKey(nums[i] - k)) count++;\\n                map.put(nums[i], 1);\\n            } else if (k == 0) {\\n                   if(map.get(nums[i]) == 1)\\n                      count++;\\n                   map.put(nums[i], map.get(nums[i]) + 1);\\n            }         \\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 100114,
                "title": "self-explained-ac-java-sliding-window",
                "content": "```\\n public  int findPairs(int[] nums, int k) {\\n\\tif(k<0 || nums.length<=1){\\n\\t    return 0;\\n\\t}\\n\\t\\t \\n         Arrays.sort(nums);\\n         int count = 0;\\n         int left = 0;\\n         int right = 1;\\n         \\n         while(right<nums.length){\\n             int firNum = nums[left];\\n             int secNum = nums[right];\\n             // If less than k, increase the right index\\n             if(secNum-firNum<k){\\n                 right++;\\n             }\\n             // If larger than k, increase the left index\\n             else if(secNum - firNum>k){\\n                 left++;   \\n             }\\n             // If equal, move left and right to next different number\\n             else{\\n                 count++;\\n                 while(left<nums.length && nums[left]==firNum){\\n                     left++;\\n                 }\\n                 while(right<nums.length && nums[right]==secNum){\\n                     right++;\\n                 }\\n                             \\n             }\\n             //left and right should not be the same number\\n             if(right==left){\\n             \\tright++;\\n             }\\n         }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public  int findPairs(int[] nums, int k) {\\n\\tif(k<0 || nums.length<=1){\\n\\t    return 0;\\n\\t}\\n\\t\\t \\n         Arrays.sort(nums);\\n         int count = 0;\\n         int left = 0;\\n         int right = 1;\\n         \\n         while(right<nums.length){\\n             int firNum = nums[left];\\n             int secNum = nums[right];\\n             // If less than k, increase the right index\\n             if(secNum-firNum<k){\\n                 right++;\\n             }\\n             // If larger than k, increase the left index\\n             else if(secNum - firNum>k){\\n                 left++;   \\n             }\\n             // If equal, move left and right to next different number\\n             else{\\n                 count++;\\n                 while(left<nums.length && nums[left]==firNum){\\n                     left++;\\n                 }\\n                 while(right<nums.length && nums[right]==secNum){\\n                     right++;\\n                 }\\n                             \\n             }\\n             //left and right should not be the same number\\n             if(right==left){\\n             \\tright++;\\n             }\\n         }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757594,
                "title": "best-approach-easy-solution-easy-understanding",
                "content": "```\\n//Please upvote,if u like it :)\\nint findPairs(vector<int>& nums, int k){\\n        unordered_map<int,int> mp;\\n        for(auto it:nums){\\n            mp[it]++;\\n        }\\n        int ans = 0;\\n        for(auto it:mp){\\n            int findd = it.first + k;\\n            if(mp.find(findd) != mp.end()){\\n                if(findd == it.first && mp[findd] > 1){\\n                    ans++;\\n                }else if(findd != it.first){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n//Please upvote,if u like it :)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n//Please upvote,if u like it :)\\nint findPairs(vector<int>& nums, int k){\\n        unordered_map<int,int> mp;\\n        for(auto it:nums){\\n            mp[it]++;\\n        }\\n        int ans = 0;\\n        for(auto it:mp){\\n            int findd = it.first + k;\\n            if(mp.find(findd) != mp.end()){\\n                if(findd == it.first && mp[findd] > 1){\\n                    ans++;\\n                }else if(findd != it.first){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n//Please upvote,if u like it :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1756950,
                "title": "problem-with-description",
                "content": "The question that is being checked for is not the question that is being asked.\\n\\nThe question being checked for seems to be:\\n\\n*Given an array of integers nums and an integer k, return the number of unique pairs that are of the form (nums[i], nums[j]) where*\\n**nums[i] <= nums[j]\\ni != j\\nabs(nums[i] - nums[j]) == k**\\n\\nThe question that is being asked is similar but different:\\n\\n*Given an array of integers nums and an integer k, return the number of unique pairs that are of the form (nums[i], nums[j]) where*\\n**i < j\\nabs(nums[i] - nums[j]) == k**\\n\\nFor all of the examples in the problem description, the two questions give the same answer. Buf for the test case\\n```\\n[0,3,0]\\n3\\n```\\nthe expected solution is 1, while the answer should be 2, given the actual problem description.\\n\\nThe pairs for the actual question are (0, 3) and (3, 0)\\nThe pair for the checked for question is (0, 3)\\n\\nFWIW, here\\'s a quadratic time brute force literal interpretation of the problem description that gets 2.\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        k_diff_pairs = []\\n        for i in range(n):\\n            for j in range(n):\\n                if i < j:\\n                    if abs(nums[i] - nums[j]) == k:\\n                        k_diff_pairs.append((nums[i], nums[j]))\\n        return len(frozenset(k_diff_pairs))\\n```\\nAnd here\\'s an O(n) time solution\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        so_far = dict()\\n        for num in nums:\\n            for x in (num - k, num + k):\\n                if x in so_far:\\n                    if num not in so_far[x]:\\n                        count += 1\\n                        so_far[x].append(num)\\n            if num not in so_far:\\n                so_far[num] = []\\n        return count\\n```\\nPlease consider updating the problem statement and adding the above test case to the examples.\\n\\nNote that the above test example is a simplified version of one of the tests used to check a solution, namely\\n```\\n[1,2,4,4,3,3,0,9,2,3]\\n3\\n```",
                "solutionTags": [],
                "code": "```\\n[0,3,0]\\n3\\n```\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        k_diff_pairs = []\\n        for i in range(n):\\n            for j in range(n):\\n                if i < j:\\n                    if abs(nums[i] - nums[j]) == k:\\n                        k_diff_pairs.append((nums[i], nums[j]))\\n        return len(frozenset(k_diff_pairs))\\n```\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        so_far = dict()\\n        for num in nums:\\n            for x in (num - k, num + k):\\n                if x in so_far:\\n                    if num not in so_far[x]:\\n                        count += 1\\n                        so_far[x].append(num)\\n            if num not in so_far:\\n                so_far[num] = []\\n        return count\\n```\n```\\n[1,2,4,4,3,3,0,9,2,3]\\n3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876351,
                "title": "c-java-python-counter-o-n-clean-concise",
                "content": "**Idea**\\n- Build `cnt` is a map to map `unique numbers` and `their counts` .\\n- For each `b` in `cnt`: \\n\\t- If `k > 0` and `a = b - k` exists then we count `(a, b)` as a `k-diff pair`.\\n\\t- If `k = 0` and `b` appears at least 2 times then we count`(b, b)` as a `k-diff pair`.\\n\\n**Complexity** \\n- Time & Space: O(N)\\n\\n**Python**\\n```python\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        cnt = Counter(nums)\\n        ans = 0\\n        for b in cnt:\\n            if (k > 0 and b - k in cnt) or (k == 0 and cnt[b] >= 2):\\n                ans += 1\\n        return ans\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> cnt;\\n        for (int x : nums)\\n            cnt[x] += 1;\\n        int ans = 0;\\n        for (auto [b, _] : cnt)\\n            if ((k > 0 && cnt.count(b - k)) || (k == 0 && cnt[b] >= 2))\\n                ans += 1;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        HashMap<Integer, Integer> cnt = new HashMap();\\n        for (int x : nums)\\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\\n        \\n        int ans = 0;\\n        for (int b : cnt.keySet())\\n            if ((k > 0 && cnt.containsKey(b - k)) || (k == 0 && cnt.get(b) >= 2))\\n                ans += 1;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        cnt = Counter(nums)\\n        ans = 0\\n        for b in cnt:\\n            if (k > 0 and b - k in cnt) or (k == 0 and cnt[b] >= 2):\\n                ans += 1\\n        return ans\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> cnt;\\n        for (int x : nums)\\n            cnt[x] += 1;\\n        int ans = 0;\\n        for (auto [b, _] : cnt)\\n            if ((k > 0 && cnt.count(b - k)) || (k == 0 && cnt[b] >= 2))\\n                ans += 1;\\n        return ans;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        HashMap<Integer, Integer> cnt = new HashMap();\\n        for (int x : nums)\\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\\n        \\n        int ans = 0;\\n        for (int b : cnt.keySet())\\n            if ((k > 0 && cnt.containsKey(b - k)) || (k == 0 && cnt.get(b) >= 2))\\n                ans += 1;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676154,
                "title": "java-hashmap",
                "content": "```\\n    public int findPairs(int[] nums, int k) {\\n        if (k < 0) return 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for(int i : nums) {\\n            if (map.containsKey(i)) {\\n                if (k == 0 && map.get(i) == 1) {\\n                    map.put(i, map.get(i) + 1);\\n                    res++;\\n                }\\n                continue;\\n            }\\n            res += map.getOrDefault(i + k, 0);\\n            res += map.getOrDefault(i - k, 0);\\n            map.put(i, 1);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findPairs(int[] nums, int k) {\\n        if (k < 0) return 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for(int i : nums) {\\n            if (map.containsKey(i)) {\\n                if (k == 0 && map.get(i) == 1) {\\n                    map.put(i, map.get(i) + 1);\\n                    res++;\\n                }\\n                continue;\\n            }\\n            res += map.getOrDefault(i + k, 0);\\n            res += map.getOrDefault(i - k, 0);\\n            map.put(i, 1);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516401,
                "title": "c-o-nlogn-solution-without-hashmap-detail-explanation",
                "content": "Sort and then perform two scans in parallel, maintaining a difference as close to k as possible between the two scan positions. In other words, advance the leading scan when the difference is smaller than k, and advance the lagging scan when the difference is greater. This way we either find a pair or scan through the list and report that no pair exists. Time complexity: O(n log n).\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findPairs(vector<int>& nums, int k) {\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tint fast=1;\\n\\t\\t\\tint slow=0;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\twhile(slow<nums.size() && fast<nums.size()){\\n\\t\\t\\t\\tif(nums[fast]-nums[slow]==k){\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\tfast++;\\n\\t\\t\\t\\t\\tslow++;\\n\\t\\t\\t\\t\\twhile(fast<nums.size() && nums[fast]==nums[fast-1]){\\n\\t\\t\\t\\t\\t\\tfast++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(nums[fast]-nums[slow]>k){\\n\\t\\t\\t\\t\\tslow++;  \\n\\t\\t\\t\\t\\tif(fast-slow==0){\\n\\t\\t\\t\\t\\t\\tfast++;}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{      \\n\\t\\t\\t\\t\\tfast++;\\n\\t\\t\\t\\t}         \\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findPairs(vector<int>& nums, int k) {\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tint fast=1;\\n\\t\\t\\tint slow=0;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\twhile(slow<nums.size() && fast<nums.size()){\\n\\t\\t\\t\\tif(nums[fast]-nums[slow]==k){\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\tfast++;\\n\\t\\t\\t\\t\\tslow++;\\n\\t\\t\\t\\t\\twhile(fast<nums.size() && nums[fast]==nums[fast-1]){\\n\\t\\t\\t\\t\\t\\tfast++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1682639,
                "title": "multiple-solutions-in-c-with-explanations",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we sort the vector to avoid duplicate elements in the set.\\n- Take to loops & if the difference is equal to k, push it to set.\\n- Calculate the set size in the count variable and return it.\\n- **Time complexity:** O(n^2 logn).\\n\\n### Solution 02\\n\\n- Here we sort the values and store the element occurrence in the map.\\n- If k=0, then the difference of 2 same elements will be equal to 0.\\n- If not then we\\u2019ll iterate the map & will find if the ***(k-current element)*** is present in the map.\\nIf present then we\\u2019ll increase count.\\n- Also every time we\\u2019ll remove the current element from map to avoid repeating elements.\\n- **Time complexity:** O(nlogn).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int count=0;\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>>res;\\n        \\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(abs(nums[i]-nums[j])==k)\\n                    res.insert({nums[i], nums[j]});\\n            }\\n        }\\n        count = res.size();\\n        return count;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int count=0, l=0, r=n-1;\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int, int>mp;\\n        \\n        if(k<0) return 0;\\n        \\n        for(auto x: nums)\\n            mp[x]++;\\n\\n        if(k==0){\\n            for(auto x:mp){\\n                if(x.second>1)\\n                    count++;\\n            }\\n        }\\n        else{\\n            for(auto x:mp){\\n                x.second--;\\n                if(mp.count(x.first-k))\\n                    count++;\\n                x.second++;\\n            }    \\n        }\\n        \\n        return count;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int count=0;\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>>res;\\n        \\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(abs(nums[i]-nums[j])==k)\\n                    res.insert({nums[i], nums[j]});\\n            }\\n        }\\n        count = res.size();\\n        return count;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int count=0, l=0, r=n-1;\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int, int>mp;\\n        \\n        if(k<0) return 0;\\n        \\n        for(auto x: nums)\\n            mp[x]++;\\n\\n        if(k==0){\\n            for(auto x:mp){\\n                if(x.second>1)\\n                    count++;\\n            }\\n        }\\n        else{\\n            for(auto x:mp){\\n                x.second--;\\n                if(mp.count(x.first-k))\\n                    count++;\\n                x.second++;\\n            }    \\n        }\\n        \\n        return count;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877137,
                "title": "python-3-faster-than-99-77-dictionary",
                "content": "```\\n# Faster than 99.77% of Python3 online submissions\\n# Memory Usage: 15.6 MB, less than 34.48% of Python3 online submissions\\n\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        # return the number of unique pairs\\n        answ=0\\n        # create a dictionary: d[x]==nums.count(x)\\n        d={}\\n        for x in nums:\\n            if x in d: d[x]+=1\\n            else:      d[x]=1\\n        \\n        if k: # k>0\\n            answ=sum(x+k in d for x in d.keys())\\n        else: # k==0\\n            answ=sum(k>1 for k in d.values())\\n                \\n        return answ\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Faster than 99.77% of Python3 online submissions\\n# Memory Usage: 15.6 MB, less than 34.48% of Python3 online submissions\\n\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        # return the number of unique pairs\\n        answ=0\\n        # create a dictionary: d[x]==nums.count(x)\\n        d={}\\n        for x in nums:\\n            if x in d: d[x]+=1\\n            else:      d[x]=1\\n        \\n        if k: # k>0\\n            answ=sum(x+k in d for x in d.keys())\\n        else: # k==0\\n            answ=sum(k>1 for k in d.values())\\n                \\n        return answ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877129,
                "title": "c-simple-soln-hashing-beats-99-99",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> m;\\n        for(int x: nums) m[x]++;\\n        int ans=0;\\n        if(k==0)\\n        {\\n            for(auto x: m) if(x.second>1) ans++;\\n        }\\n        else\\n        {\\n            for(auto x: m)\\n            {\\n                if(m.count(x.first + k) > 0) ans++; \\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> m;\\n        for(int x: nums) m[x]++;\\n        int ans=0;\\n        if(k==0)\\n        {\\n            for(auto x: m) if(x.second>1) ans++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 876550,
                "title": "beats-99-of-python3-hashmap-no-libraries",
                "content": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        d = {}\\n        cnt = 0\\n        for i in nums:\\n            if i not in d:\\n                d[i] = 1\\n            else:\\n                d[i] += 1\\n        \\n        if k == 0:\\n            for i in d.values():\\n                if i > 1:\\n                    cnt += 1\\n        else:\\n            for i in d:\\n                if k + i in d:\\n                    cnt += 1\\n            \\n        return cnt\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        d = {}\\n        cnt = 0\\n        for i in nums:\\n            if i not in d:\\n                d[i] = 1\\n            else:\\n                d[i] += 1\\n        \\n        if k == 0:\\n            for i in d.values():\\n                if i > 1:\\n                    cnt += 1\\n        else:\\n            for i in d:\\n                if k + i in d:\\n                    cnt += 1\\n            \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431250,
                "title": "java-hashmap-solution-easy-to-understand",
                "content": "```\\npublic int findPairs(int[] nums, int k) {\\n\\tif(nums == null || nums.length == 0 || k<0) return 0;\\n\\tint count = 0;\\n\\tHashMap<Integer, Integer> hm = new HashMap<>();\\n\\tfor(int num : nums) \\n\\t\\thm.put(num, hm.getOrDefault(num, 0)+1);\\n\\tfor(Map.Entry<Integer, Integer> e : hm.entrySet())\\n\\t\\tif(k==0 && e.getValue()>=2) count++;\\n\\t\\telse if(k!=0 && hm.containsKey(e.getKey()+k)) count++;\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findPairs(int[] nums, int k) {\\n\\tif(nums == null || nums.length == 0 || k<0) return 0;\\n\\tint count = 0;\\n\\tHashMap<Integer, Integer> hm = new HashMap<>();\\n\\tfor(int num : nums) \\n\\t\\thm.put(num, hm.getOrDefault(num, 0)+1);\\n\\tfor(Map.Entry<Integer, Integer> e : hm.entrySet())\\n\\t\\tif(k==0 && e.getValue()>=2) count++;\\n\\t\\telse if(k!=0 && hm.containsKey(e.getKey()+k)) count++;\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 415255,
                "title": "javascript-solution-o-n-beats-92-r-and-100-m-using-map-easy-to-understand",
                "content": "\\t/**\\n\\t * @param {number[]} nums\\n\\t * @param {number} k\\n\\t * @return {number}\\n\\t */\\n\\tvar findPairs = function(nums, k) {\\n\\t\\tif(nums.length === 0 || k < 0) return 0\\n\\t\\tlet myMap = new Map(),\\n\\t\\t\\tcount = 0\\n\\t\\t//Get wordcount\\n\\t\\tfor(num of nums){\\n\\t\\t\\tmyMap.set(num,(myMap.get(num)+1) || 1)\\n\\t\\t}\\n\\t\\t\\n\\t\\t//search solutions\\n\\t\\tmyMap.forEach((value,key) =>{\\n\\t\\t\\tif(k === 0){\\n\\t\\t\\t\\tif(value > 1) count++\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif(myMap.has(key+k)) count++\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\treturn count\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\t/**\\n\\t * @param {number[]} nums\\n\\t * @param {number} k\\n\\t * @return {number}\\n\\t */\\n\\tvar findPairs = function(nums, k) {\\n\\t\\tif(nums.length === 0 || k < 0) return 0\\n\\t\\tlet myMap = new Map(),\\n\\t\\t\\tcount = 0\\n\\t\\t//Get wordcount\\n\\t\\tfor(num of nums){\\n\\t\\t\\tmyMap.set(num,(myMap.get(num)+1) || 1)\\n\\t\\t}\\n\\t\\t\\n\\t\\t//search solutions\\n\\t\\tmyMap.forEach((value,key) =>{\\n\\t\\t\\tif(k === 0){\\n\\t\\t\\t\\tif(value > 1) count++\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif(myMap.has(key+k)) count++\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\treturn count\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 383278,
                "title": "java-o-n-sets-clean-7-ms",
                "content": "This problem has two main cases - when k == 0 and all others. The idea is - for number n if there is n + k in the array - pair is possible. We add all numbers from array to the set, then check for n + k. For k == 0 we need to count how many unqiue numbers repeated 2+ times. For that I use second set - add number that we met for the second time to that second set, then size of that second set will be the result.\\n\\nO(n) for time - 2 linear scans of the array. O(n) for space - need to store numbers to the set.\\n\\n```\\n    public int findPairs(int[] nums, int k) {\\n        if (k < 0)\\n            return 0;\\n        int res = 0;\\n        Set<Integer> set = new HashSet();\\n        //if k == 0 we need to count only repeated nums\\n        //for that we need second set that indicats which num we have\\n        //count already\\n        if (k == 0 ) {\\n            Set<Integer> seen = new HashSet();\\n            for (int n : nums) {\\n                //if we met this num before - add it to the second set\\n                if (set.contains(n)) {\\n                    seen.add(n);\\n                } else\\n                    set.add(n);\\n            }\\n            //size of second set will be the resulting num\\n            res = seen.size();\\n        } else {\\n            //for k > 0 we check if n + k is in the set, this means we have a pair\\n            for (int n : nums) {\\n                set.add(n);\\n            }\\n\\n            for (int n : set) {\\n                if (set.contains(n + k))\\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int findPairs(int[] nums, int k) {\\n        if (k < 0)\\n            return 0;\\n        int res = 0;\\n        Set<Integer> set = new HashSet();\\n        //if k == 0 we need to count only repeated nums\\n        //for that we need second set that indicats which num we have\\n        //count already\\n        if (k == 0 ) {\\n            Set<Integer> seen = new HashSet();\\n            for (int n : nums) {\\n                //if we met this num before - add it to the second set\\n                if (set.contains(n)) {\\n                    seen.add(n);\\n                } else\\n                    set.add(n);\\n            }\\n            //size of second set will be the resulting num\\n            res = seen.size();\\n        } else {\\n            //for k > 0 we check if n + k is in the set, this means we have a pair\\n            for (int n : nums) {\\n                set.add(n);\\n            }\\n\\n            for (int n : set) {\\n                if (set.contains(n + k))\\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757306,
                "title": "using-hashmap-java-code-with-explaination",
                "content": "If you find it useful do upvote\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                // the array element and  increament the frequence by 1\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            } else {\\n                // keep the frequene of current element as 1\\n                map.put(nums[i], 1);\\n            }\\n        }\\n        int count = 0;\\n        //create key set\\n        Set<Integer> set = map.keySet();\\n        for(int num: set){\\n            //first check\\n            if(k > 0 &&map.containsKey(num + k)){\\n                count++;\\n            }\\n            // second check\\n            if(k==0 && map.get(num) > 1){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n```\\nTime Complexity : O(N)\\nSpace Complexity : O(N)\\n```\\n\\n**NOTES**\\n[(https://github.com/rizonkumar/LeetCode-Notes/blob/bb59b2137e810d07dd1f91470e31e4842bf70fa4/532.pdf)]",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                // the array element and  increament the frequence by 1\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            } else {\\n                // keep the frequene of current element as 1\\n                map.put(nums[i], 1);\\n            }\\n        }\\n        int count = 0;\\n        //create key set\\n        Set<Integer> set = map.keySet();\\n        for(int num: set){\\n            //first check\\n            if(k > 0 &&map.containsKey(num + k)){\\n                count++;\\n            }\\n            // second check\\n            if(k==0 && map.get(num) > 1){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nTime Complexity : O(N)\\nSpace Complexity : O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757225,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        map<pair<int, int>, int> m;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(abs(nums[i]-nums[j])==k and m.find({nums[j], nums[i]})==m.end())\\n                    m[{nums[i], nums[j]}]++;\\n            }\\n        }\\n        return m.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        map<pair<int, int>, int> m;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(abs(nums[i]-nums[j])==k and m.find({nums[j], nums[i]})==m.end())\\n                    m[{nums[i], nums[j]}]++;\\n            }\\n        }\\n        return m.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519220,
                "title": "c-o-n-one-pass-with-unordered-map",
                "content": "```\\nint findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int ans = 0;\\n        if(k < 0) return 0;\\n        for(int num:nums){\\n            if(k == 0 && mp[num] == 1){\\n                ans++;\\n            }else if(k > 0 && mp[num] == 0){\\n                ans += mp.count(num - k) + mp.count(num + k);\\n            }\\n            mp[num]++;\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int ans = 0;\\n        if(k < 0) return 0;\\n        for(int num:nums){\\n            if(k == 0 && mp[num] == 1){\\n                ans++;\\n            }else if(k > 0 && mp[num] == 0){\\n                ans += mp.count(num - k) + mp.count(num + k);\\n            }\\n            mp[num]++;\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 100157,
                "title": "java-two-pointer-solution-beats-97",
                "content": "The idea is simple. Sort the array first. Then for each number in the array, find if there exists a number satisfy the requirement. Note that ```right = Math.max(right, i + 1)``` can make sure each number in the array is accessed at most twice. So the time complexity is O(nlogn) + O(n) = O(nlogn)\\n```\\npublic int findPairs(int[] nums, int k) {\\n    if (nums.length < 2 || k < 0) {\\n        return 0;\\n    }\\n    int count = 0;\\n    Arrays.sort(nums);\\n    int right = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (i > 0 && nums[i] == nums[i - 1]) {\\n            continue;\\n        }\\n            \\n        right = Math.max(right, i + 1);\\n        while (right < nums.length) {\\n            if (nums[right] - k == nums[i]) {\\n                count++;\\n                break;\\n            } else if (nums[right] - k < nums[i]) {\\n                right++;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```right = Math.max(right, i + 1)```\n```\\npublic int findPairs(int[] nums, int k) {\\n    if (nums.length < 2 || k < 0) {\\n        return 0;\\n    }\\n    int count = 0;\\n    Arrays.sort(nums);\\n    int right = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (i > 0 && nums[i] == nums[i - 1]) {\\n            continue;\\n        }\\n            \\n        right = Math.max(right, i + 1);\\n        while (right < nums.length) {\\n            if (nums[right] - k == nums[i]) {\\n                count++;\\n                break;\\n            } else if (nums[right] - k < nums[i]) {\\n                right++;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 884432,
                "title": "simple-java-o-n-solution-with-explaination",
                "content": "``` \\npublic int findPairs(int[] nums, int k) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int res=0;\\n        //storing count of all the elements\\n        for(int i:nums){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        for(int a:map.keySet()){\\n            if(k!=0){\\n                //we avoid duplicate by looking for the values (i,j) where i is smaller element eg k=4 (1,3) & (3,1) gives same result but when we are processing 1 we are lloking fr val greater than 1 to form the pair and likewise when we are at 3we are looking for val 3 and above to form the pair\\n                int b=a+k;\\n                if(map.containsKey(b)){\\n                    res++;\\n                }\\n            }else{\\n                //processing the key so processing unique values which is occuring twice  and diff of it gives 0\\n                if(map.get(a)>=2)\\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\npublic int findPairs(int[] nums, int k) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int res=0;\\n        //storing count of all the elements\\n        for(int i:nums){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        for(int a:map.keySet()){\\n            if(k!=0){\\n                //we avoid duplicate by looking for the values (i,j) where i is smaller element eg k=4 (1,3) & (3,1) gives same result but when we are processing 1 we are lloking fr val greater than 1 to form the pair and likewise when we are at 3we are looking for val 3 and above to form the pair\\n                int b=a+k;\\n                if(map.containsKey(b)){\\n                    res++;\\n                }\\n            }else{\\n                //processing the key so processing unique values which is occuring twice  and diff of it gives 0\\n                if(map.get(a)>=2)\\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 150243,
                "title": "easy-to-understand-2-pointer-sliding-window-approach-in-python-o-1-space-o-nlogn-time",
                "content": "```\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        nums.sort()\\n        \\n        slow = 0\\n        fast = 1\\n        size = len(nums)\\n        \\n        while fast < size:\\n            if nums[fast] - nums[slow] < k: # case 1, diff is less than k\\n                fast += 1\\n            elif nums[fast] - nums[slow] > k: # case 2, diff is greater than k\\n                slow += 1\\n            else: # case 3, diff is equal to k so increment the count!\\n                count += 1\\n                fast += 1\\n                slow += 1\\n                \\n                #Now ignore any duplicates, both slow and fast could be pointing to duplicates\\n                while slow < size-1 and nums[slow] == nums[slow-1]:\\n                    slow += 1\\n                    \\n                while fast < size-1 and nums[fast] == nums[fast-1]:\\n                    fast += 1\\n                    \\n            if fast <= slow: # fast should be atleast one more than slow\\n                fast = slow + (slow - fast) + 1\\n                \\n        return count\\n\\t\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        nums.sort()\\n        \\n        slow = 0\\n        fast = 1\\n        size = len(nums)\\n        \\n        while fast < size:\\n            if nums[fast] - nums[slow] < k: # case 1, diff is less than k\\n                fast += 1\\n            elif nums[fast] - nums[slow] > k: # case 2, diff is greater than k\\n                slow += 1\\n            else: # case 3, diff is equal to k so increment the count!\\n                count += 1\\n                fast += 1\\n                slow += 1\\n                \\n                #Now ignore any duplicates, both slow and fast could be pointing to duplicates\\n                while slow < size-1 and nums[slow] == nums[slow-1]:\\n                    slow += 1\\n                    \\n                while fast < size-1 and nums[fast] == nums[fast-1]:\\n                    fast += 1\\n                    \\n            if fast <= slow: # fast should be atleast one more than slow\\n                fast = slow + (slow - fast) + 1\\n                \\n        return count\\n\\t\\t\\t\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1757242,
                "title": "c-using-map-easy-soln",
                "content": "\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n       \\n        int n = nums.size();\\n        map<int,int>m;        \\n        for(int i = 0;i<n;i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        int sum = 0; \\n        if(k == 0){\\n            for(auto i:m){\\n                if(i.second>1){\\n                    sum++;\\n                }\\n            }\\n        }\\n        else{\\n            for(auto i:m){\\n                if( m.count(i.first + k))\\n               //if(m.find(i.first + k)!=m.end()) \\n                {\\n                    sum++;\\n                }\\n            }\\n        }\\n        return sum;\\n       \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n       \\n        int n = nums.size();\\n        map<int,int>m;        \\n        for(int i = 0;i<n;i++)\\n        {\\n            m[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1757048,
                "title": "easy-commented-javascript-hashmap-o-n-solution",
                "content": "```\\nvar findPairs = function (nums, k) {\\n\\tlet map = {}, //Object to store count/frequency of numbers in array\\n\\t\\tcount = 0; //count the desired output/result\\n\\n\\t//loop through the array and store the count/frequency in the object\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\t/*if num appears for the 1st time them map[nums[i]] will be undefined\\n\\tand undefined||0 will result in 0 and 0+1 will store 1 as count of that number */\\n\\t\\tmap[nums[i]] = (map[nums[i]] || 0) + 1;\\n\\t}\\n\\n\\t//loop through keys.In this case keys will be unique as they have the frequency of their occurrences\\n\\tObject.keys(map).forEach((key) => {\\n\\t\\t/* Now we need to check if target k is 0 or not \\n\\t\\tbecause in case k is 0 then only possible combination to get \\n\\t\\tdifference 0 will be when same num appear twice i.e \\n\\t\\t1-1=0 ,here 1 count has to be 2 in map to get diff 0\\n\\t\\t*/\\n\\t\\tif (k !== 0) {\\n\\t\\t\\t/* \\n\\t\\t\\tit is given that |a-b|=k\\n\\t\\t\\tso a=k+b i.e secondNum=k+key\\n\\t\\t\\tSince object stores key as string so we have to typecast it to integer\\n\\t\\t\\tand +k is shorthand of parseInt(k)\\n\\t\\t\\tso we can write  parseInt(k)+parseInt(key) as\\n\\t\\t\\t+k + +key (make sure there is space between +/add operator)\\n\\t\\t\\t*/\\n\\t\\t\\tlet secondNum = +k + +key;\\n\\t\\t\\tif (map[secondNum] !== undefined) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t/*So when k is 0 we check is num count is greater or equal\\n\\t\\t\\t to 2 because then only we will get difference of these two as 0\\n\\t\\t\\t */\\n\\t\\t\\tif (map[key] >= 2) count++;\\n\\t\\t}\\n\\t});\\n\\treturn count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findPairs = function (nums, k) {\\n\\tlet map = {}, //Object to store count/frequency of numbers in array\\n\\t\\tcount = 0; //count the desired output/result\\n\\n\\t//loop through the array and store the count/frequency in the object\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\t/*if num appears for the 1st time them map[nums[i]] will be undefined\\n\\tand undefined||0 will result in 0 and 0+1 will store 1 as count of that number */\\n\\t\\tmap[nums[i]] = (map[nums[i]] || 0) + 1;\\n\\t}\\n\\n\\t//loop through keys.In this case keys will be unique as they have the frequency of their occurrences\\n\\tObject.keys(map).forEach((key) => {\\n\\t\\t/* Now we need to check if target k is 0 or not \\n\\t\\tbecause in case k is 0 then only possible combination to get \\n\\t\\tdifference 0 will be when same num appear twice i.e \\n\\t\\t1-1=0 ,here 1 count has to be 2 in map to get diff 0\\n\\t\\t*/\\n\\t\\tif (k !== 0) {\\n\\t\\t\\t/* \\n\\t\\t\\tit is given that |a-b|=k\\n\\t\\t\\tso a=k+b i.e secondNum=k+key\\n\\t\\t\\tSince object stores key as string so we have to typecast it to integer\\n\\t\\t\\tand +k is shorthand of parseInt(k)\\n\\t\\t\\tso we can write  parseInt(k)+parseInt(key) as\\n\\t\\t\\t+k + +key (make sure there is space between +/add operator)\\n\\t\\t\\t*/\\n\\t\\t\\tlet secondNum = +k + +key;\\n\\t\\t\\tif (map[secondNum] !== undefined) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t/*So when k is 0 we check is num count is greater or equal\\n\\t\\t\\t to 2 because then only we will get difference of these two as 0\\n\\t\\t\\t */\\n\\t\\t\\tif (map[key] >= 2) count++;\\n\\t\\t}\\n\\t});\\n\\treturn count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747173,
                "title": "c-o-n-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> hash;\\n        for(int i=0;i<nums.size();i++) hash[nums[i]]++;\\n        \\n        int count =0; \\n        \\n        for(auto i: hash){\\n            if(k==0) {\\n                if(i.second>1) \\n                    count++;\\n            }\\n            \\n             else {\\n                 if (hash.find(i.first - k) != hash.end()) \\n                     count++;\\n             }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> hash;\\n        for(int i=0;i<nums.size();i++) hash[nums[i]]++;\\n        \\n        int count =0; \\n        \\n        for(auto i: hash){\\n            if(k==0) {\\n                if(i.second>1) \\n                    count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 876993,
                "title": "k-diff-pairs-c-6-liner-solution-with-explanation-o-nlogn-time-o-1-space",
                "content": "<b> Upvote this post, if you liked it. Happy Coding :)</b>\\n\\nApproach : \\n1) Sort the nums array.\\n2) Loop over the nums array using iterator\\n\\ta) maintain the previous value so that we can jump over duplicate values, to make sure that only unique pairs will be counted.\\n\\tb) perform binary search on elements from the next element (current\\'s next element) to last element,  to find the value\\n\\t\\twhich can satisfy the pair cond.\\n3) return count\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int prev_val, count = 0;\\n        sort(nums.begin(), nums.end());\\n        for(auto it = nums.begin(); it != nums.end(); it++) {\\n            if(it != nums.begin() and *it == prev_val) continue;\\n            if(binary_search(it+1, nums.end(), *it + k)) count++;\\n            prev_val = *it;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**I Hope you understood the solution, if you have any doubts regarding the solution or any suggestions to improve the solution,** then feel free to comment down below.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int prev_val, count = 0;\\n        sort(nums.begin(), nums.end());\\n        for(auto it = nums.begin(); it != nums.end(); it++) {\\n            if(it != nums.begin() and *it == prev_val) continue;\\n            if(binary_search(it+1, nums.end(), *it + k)) count++;\\n            prev_val = *it;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876378,
                "title": "c-solution-one-pass-beats-100-two-pointer-approach",
                "content": "Sort the vector.\\nHere 3 cases arise : \\n* **Case - 1 : When nums[j] - nums[i] > k**\\n\\tThe difference between element at j and element at i is greater than required, so to reduce it increment i.\\n* **Case - 2 : When nums[j] - nums[i] < k**\\n\\tThe difference between element at j and element at i is lesser than required, so to increase it increment j.\\n* **Case - 3 : When nums[j] - nums[i] == k**\\n\\t Required pair found. Increment ans, and skip similar elements for both i and j.\\n\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans = 0;\\n        int n = nums.size();\\n        int i = 0, j = 1;\\n        while(i<n && j<n){\\n            if(nums[j] - nums[i] == k && i!=j){\\n                while(i+1 < n && nums[i+1] == nums[i])\\n                    i++;\\n                i++;\\n                while(j+1<n && nums[j+1] == nums[j])\\n                    j++;\\n                j++;\\n                ans++;\\n            }\\n            else if(nums[j] - nums[i] > k){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans = 0;\\n        int n = nums.size();\\n        int i = 0, j = 1;\\n        while(i<n && j<n){\\n            if(nums[j] - nums[i] == k && i!=j){\\n                while(i+1 < n && nums[i+1] == nums[i])\\n                    i++;\\n                i++;\\n                while(j+1<n && nums[j+1] == nums[j])\\n                    j++;\\n                j++;\\n                ans++;\\n            }\\n            else if(nums[j] - nums[i] > k){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100148,
                "title": "simple-java-o-n-with-single-for-loop-single-hashmap",
                "content": "Solved it by One For-loop and One HashMap\\n```\\npublic int findPairs(int[] nums, int k) {\\n    if(k < 0) return 0;\\n    Map<Integer, Boolean> map = new HashMap<Integer, Boolean>();\\n    int ret = 0;\\n    for(int n : nums){\\n        /* if smaller matched value exists */\\n        if(map.containsKey(n-k) && !map.get(n-k)){\\n            map.put(n-k,true);\\n            ret++;\\n        }\\n        /* if larger matched value exists */\\n        if(map.containsKey(n+k) && (!map.containsKey(n) || !map.get(n))){\\n            map.put(n, true);\\n            ret++;\\n        }\\n        /* if current value has not yet been added*/\\n        if(!map.containsKey(n)){\\n            map.put(n, false);\\n        }\\n    }\\n    return ret;\\n}\\n````",
                "solutionTags": [],
                "code": "```\\npublic int findPairs(int[] nums, int k) {\\n    if(k < 0) return 0;\\n    Map<Integer, Boolean> map = new HashMap<Integer, Boolean>();\\n    int ret = 0;\\n    for(int n : nums){\\n        /* if smaller matched value exists */\\n        if(map.containsKey(n-k) && !map.get(n-k)){\\n            map.put(n-k,true);\\n            ret++;\\n        }\\n        /* if larger matched value exists */\\n        if(map.containsKey(n+k) && (!map.containsKey(n) || !map.get(n))){\\n            map.put(n, true);\\n            ret++;\\n        }\\n        /* if current value has not yet been added*/\\n        if(!map.containsKey(n)){\\n            map.put(n, false);\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1756781,
                "title": "python-o-n-solution-using-hashmap",
                "content": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        \\n        hashNums={}\\n        pairs=set()\\n        \\n        for n in nums: # O(n)\\n            hashNums[n]=hashNums.get(n,0)+1\\n            \\n            if n-k in hashNums:\\n                pairs.add(tuple(set([n,n-k])))\\n            \\n            if n+k in hashNums:\\n                pairs.add(tuple(set([n,n+k])))\\n        \\n        if k==0: # O(n)\\n            ct=0\\n            for n,f in hashNums.items():\\n                ct+=(f>=2)\\n            return ct\\n        \\n        return len(pairs)",
                "solutionTags": [],
                "code": "class Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        \\n        hashNums={}",
                "codeTag": "Java"
            },
            {
                "id": 881899,
                "title": "java-o-n-solution-with-hashmap",
                "content": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int kDiffs = 0;\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        \\n        for (int n: nums) {\\n            int countOfN = counter.getOrDefault(n, 0);\\n            countOfN++;\\n            counter.put(n, countOfN);\\n            \\n            if (k == 0) {\\n                if (countOfN == 2) kDiffs++;\\n            } else if (countOfN == 1) {\\n                if (counter.containsKey(n - k)) kDiffs++;\\n                if (counter.containsKey(n + k)) kDiffs++;           \\n            }\\n        }\\n        \\n        return kDiffs;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int kDiffs = 0;\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        \\n        for (int n: nums) {\\n            int countOfN = counter.getOrDefault(n, 0);\\n            countOfN++;\\n            counter.put(n, countOfN);\\n            \\n            if (k == 0) {\\n                if (countOfN == 2) kDiffs++;\\n            } else if (countOfN == 1) {\\n                if (counter.containsKey(n - k)) kDiffs++;\\n                if (counter.containsKey(n + k)) kDiffs++;           \\n            }\\n        }\\n        \\n        return kDiffs;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876356,
                "title": "c-self-explanatory-one-pass-o-n-use-hash-map",
                "content": "```cpp\\nint findPairs(vector<int>& nums, int k) {;\\n    unordered_map<int, int> freq;\\n    int ans = 0;\\n    for (int n : nums) {\\n        if (k == 0) {\\n            if (freq[n] == 1) ++ans; // only count once\\n        } else if (!freq.count(n)) { // only count when the first time n appears\\n            if (freq.count(n - k)) ++ans;\\n            if (freq.count(n + k)) ++ans;\\n        }\\n        ++freq[n];\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint findPairs(vector<int>& nums, int k) {;\\n    unordered_map<int, int> freq;\\n    int ans = 0;\\n    for (int n : nums) {\\n        if (k == 0) {\\n            if (freq[n] == 1) ++ans; // only count once\\n        } else if (!freq.count(n)) { // only count when the first time n appears\\n            if (freq.count(n - k)) ++ans;\\n            if (freq.count(n + k)) ++ans;\\n        }\\n        ++freq[n];\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876258,
                "title": "python-really-short-and-easy-explained",
                "content": "Let complementary number be a number that is equal to some given number minus k.\\nTo form at least one pair for any given number:\\n  If k is greater than zero, we only care if count of complementary number is bigger than zero.\\n  If k is zero, we only care if count of complementary number (that is the current number itself) is bigger than one.\\n\\nConveniently, both this cases can be expressed with k==0, that will return zero or one.\\n\\n```\\ndef findPairs(self, nums: List[int], k: int) -> int:\\n    c = collections.Counter(nums)\\n    return sum(c[n-k] > (k == 0) for n in c)\\n```",
                "solutionTags": [],
                "code": "```\\ndef findPairs(self, nums: List[int], k: int) -> int:\\n    c = collections.Counter(nums)\\n    return sum(c[n-k] > (k == 0) for n in c)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 815088,
                "title": "c-4-lines-simple-n-short-no-built-in-utils-data-structures-etc",
                "content": "```\\nint findPairs(int* nums, int numsSize, int k){\\n    char a[200000] = { 0 }, *m = &a[500];\\n    for (int i = 0, c = 0, *n = nums ; i < numsSize || (numsSize = c, 0) ; i++)\\n        for (int j = i, p ; ++j < numsSize ; abs(n[i] - n[j]) == k && !m[p = n[i] + n[j]] ? c += m[p] = 1 : 0);\\n    return numsSize;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findPairs(int* nums, int numsSize, int k){\\n    char a[200000] = { 0 }, *m = &a[500];\\n    for (int i = 0, c = 0, *n = nums ; i < numsSize || (numsSize = c, 0) ; i++)\\n        for (int j = i, p ; ++j < numsSize ; abs(n[i] - n[j]) == k && !m[p = n[i] + n[j]] ? c += m[p] = 1 : 0);\\n    return numsSize;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794950,
                "title": "java-o-n-solution-with-comments",
                "content": "class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n       int output=0;\\n       HashMap <Integer,Integer> hm = new HashMap<>(); \\n        \\n       //Storing the frequencies in the hashmpap\\n        for(int num: nums)\\n        {\\n            hm.put(num, hm.getOrDefault(num,0)+1);\\n        }\\n        \\n        \\n        //Traversing the hashmap\\n        for (Map.Entry <Integer, Integer> entry: hm.entrySet()) \\n        {\\n            int elem = entry.getKey();\\n            int value = entry.getValue();\\n            \\n            \\n            // finding some other element (elem+ other element=k)\\n            if(k>0 && hm.containsKey(elem+k))\\n                output++;\\n            \\n            // The number can be paired with itself. Hence, the value should be >1. We don\\'t care what value as long as the frequency is greater than one as the question says \"k-diff pair\".\\n            else if(k==0 && value >1)\\n                output++;\\n            \\n        }\\n        return output;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n       int output=0;\\n       HashMap <Integer,Integer> hm = new HashMap<>(); \\n        \\n       //Storing the frequencies in the hashmpap\\n        for(int num: nums)\\n        {\\n            hm.put(num, hm.getOrDefault(num,0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 498433,
                "title": "javascript-using-object-as-map",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar findPairs = function(nums, k) {\\n  if (!nums.length || k < 0) return 0;\\n  const map = {};\\n  let counter = 0;\\n  nums.forEach(n => {\\n    map[n] = (map[n] || 0) + 1;\\n  });\\n  Object.keys(map).forEach(key => {\\n    if (k === 0) {\\n      if (map[key] > 1) counter++;\\n    } else if (map[parseInt(key) + k]) {\\n      counter++;\\n    }\\n  });\\n  return counter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar findPairs = function(nums, k) {\\n  if (!nums.length || k < 0) return 0;\\n  const map = {};\\n  let counter = 0;\\n  nums.forEach(n => {\\n    map[n] = (map[n] || 0) + 1;\\n  });\\n  Object.keys(map).forEach(key => {\\n    if (k === 0) {\\n      if (map[key] > 1) counter++;\\n    } else if (map[parseInt(key) + k]) {\\n      counter++;\\n    }\\n  });\\n  return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466050,
                "title": "3-java-solutions-1-hashmap-without-sort-2-hashmap-sort-3-sort-two-points",
                "content": "1. HashMap without sort.\\nWe define a hashMap. The key element denotes the members of the array. The value has 3 types:\\nvalue 1: the key appears once in the array\\nvalue 2: the key appears more than once in the array\\nvalue 0: the key has been used, this value is used to avoid duplicated pairs.\\nWe use a for-loop to initial the hashMap. \\nIf k == 0, we just calculate the number which appears more than once in array.\\nif k != 0,  each number adds k and subtracts k, then using the result to match the map. \\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if(k<0)return 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0; i<nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],2);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        int count = 0;\\n        if(k==0){\\n            for(int i = 0; i<nums.length; i++){\\n                if(map.containsKey(nums[i]) && map.get(nums[i]) > 1){\\n                    count++;\\n                    map.replace(nums[i],0);\\n                }\\n            }\\n            return count;\\n        }\\n        for(int i = 0; i<nums.length; i++){\\n            if(map.containsKey(nums[i] + k) && map.get(nums[i] + k) > 0 && map.get(nums[i]) > 0){\\n                count++;\\n            }\\n            if(map.containsKey(nums[i] - k) && map.get(nums[i] - k) > 0 && map.get(nums[i]) > 0){\\n                count++;\\n            }\\n            map.replace(nums[i],0);\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n2. HashMap + Sort\\nThis solution is similar to the first solution. \\nWe firstly sort the array, so we don\\'t need to consider multiple situations(k==0 or k != 0 ; add or subtract). The sort reduces the complexity of this problem.\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if(k < 0)return 0;\\n        Map<Integer, Boolean> map = new HashMap<>();\\n        int count = 0;\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i++){\\n            if(map.containsKey(nums[i]) && map.get(nums[i])){\\n                count++;\\n                map.replace(nums[i],false);\\n            }\\n            if(!map.containsKey(nums[i] + k)){\\n                map.put(nums[i] + k, true);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n3.Sort + Two Points:\\nThis solution is based on the ordering of the array.\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if(k < 0) return 0;\\n        Arrays.sort(nums);\\n        int left = 0, right = 1, count = 0;\\n        while(right < nums.length){\\n            if(nums[right] - nums[left] > k){\\n                left++;\\n            }else if(nums[right] - nums[left] < k || right == left){\\n                right++;\\n            }else{\\n                count++;\\n                left++;\\n                right++;\\n                while(right < nums.length && nums[right] == nums[right - 1]) right++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if(k<0)return 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0; i<nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],2);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        int count = 0;\\n        if(k==0){\\n            for(int i = 0; i<nums.length; i++){\\n                if(map.containsKey(nums[i]) && map.get(nums[i]) > 1){\\n                    count++;\\n                    map.replace(nums[i],0);\\n                }\\n            }\\n            return count;\\n        }\\n        for(int i = 0; i<nums.length; i++){\\n            if(map.containsKey(nums[i] + k) && map.get(nums[i] + k) > 0 && map.get(nums[i]) > 0){\\n                count++;\\n            }\\n            if(map.containsKey(nums[i] - k) && map.get(nums[i] - k) > 0 && map.get(nums[i]) > 0){\\n                count++;\\n            }\\n            map.replace(nums[i],0);\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if(k < 0)return 0;\\n        Map<Integer, Boolean> map = new HashMap<>();\\n        int count = 0;\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i++){\\n            if(map.containsKey(nums[i]) && map.get(nums[i])){\\n                count++;\\n                map.replace(nums[i],false);\\n            }\\n            if(!map.containsKey(nums[i] + k)){\\n                map.put(nums[i] + k, true);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if(k < 0) return 0;\\n        Arrays.sort(nums);\\n        int left = 0, right = 1, count = 0;\\n        while(right < nums.length){\\n            if(nums[right] - nums[left] > k){\\n                left++;\\n            }else if(nums[right] - nums[left] < k || right == left){\\n                right++;\\n            }else{\\n                count++;\\n                left++;\\n                right++;\\n                while(right < nums.length && nums[right] == nums[right - 1]) right++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413636,
                "title": "7-lines-o-n-python3-fast-and-clear-and-easy-understand",
                "content": "make a dictory,and then when k>0 and k==0, we add res :\\n```python\\n  def findPairs(self, nums, k):\\n\\t\\tnums.sort()\\n        res , dic= 0 , {}\\n        for i in nums:\\n            dic[i] = dic[i]+1 if i in dic else 1\\n        for i in dic.keys():\\n            if (i+k in dic and k>0) or (k==0 and dic[i]>1):\\n                res += 1\\n        return res \\n```\\n\\nIf this code is not bad , welcome give me a star ,Thanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n  def findPairs(self, nums, k):\\n\\t\\tnums.sort()\\n        res , dic= 0 , {}\\n        for i in nums:\\n            dic[i] = dic[i]+1 if i in dic else 1\\n        for i in dic.keys():\\n            if (i+k in dic and k>0) or (k==0 and dic[i]>1):\\n                res += 1\\n        return res \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 228659,
                "title": "easy-to-understand-python-solution-using-hashmap",
                "content": "```\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if k < 0:\\n            return 0\\n        hashmap = {}\\n        count = 0\\n        for num in nums:\\n            # check num + k and num - k present in hashmap\\n            if num not in hashmap:  \\n                if num + k in hashmap:\\n                    count += 1\\n                if num - k in hashmap:\\n                    count += 1\\n                hashmap[num] = 1\\n            else:\\n                # handling k == 0 condition with by restricting occurances to 1\\n                if k == 0 and hashmap[num] == 1:\\n                    count += 1\\n                hashmap[num] += 1\\n                \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if k < 0:\\n            return 0\\n        hashmap = {}\\n        count = 0\\n        for num in nums:\\n            # check num + k and num - k present in hashmap\\n            if num not in hashmap:  \\n                if num + k in hashmap:\\n                    count += 1\\n                if num - k in hashmap:\\n                    count += 1\\n                hashmap[num] = 1\\n            else:\\n                # handling k == 0 condition with by restricting occurances to 1\\n                if k == 0 and hashmap[num] == 1:\\n                    count += 1\\n                hashmap[num] += 1\\n                \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 100193,
                "title": "simple-idea-o-nlogn-time-o-1-space-java-solution",
                "content": "guess this solution is intuitive.\\n```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if (nums == null || nums.length < 2) return 0;\\n        int res = 0;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\\n            if (helper(nums, i + 1, nums[i] + k)) res++;\\n        }\\n        return res;\\n    }\\n    private boolean helper(int[] nums, int l, int target) {\\n        int r = nums.length - 1;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums[mid] == target) return true;\\n            if (nums[mid] < target) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        if (nums == null || nums.length < 2) return 0;\\n        int res = 0;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\\n            if (helper(nums, i + 1, nums[i] + k)) res++;\\n        }\\n        return res;\\n    }\\n    private boolean helper(int[] nums, int l, int target) {\\n        int r = nums.length - 1;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums[mid] == target) return true;\\n            if (nums[mid] < target) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292897,
                "title": "532-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. First, check if k is less than 0, if yes then return 0.\\n2. Create a hash table freq to store the frequency of each number in the array.\\n3. Iterate through the array nums and for each number, update its frequency in the hash table freq.\\n4. Initialize a variable count to 0 to store the count of unique pairs.\\n5. Iterate through the keys in the hash table freq and check for each key if there exists a pair with difference k in the hash table.\\n6. If k is 0, then increment the count only if the frequency of the number is greater than 1.\\n7. If k is not 0, then check if num + k exists in the hash table. If yes, then increment the count.\\n8. Return the count of unique pairs.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        if k < 0:\\n            return 0\\n        \\n        # initialize hash table\\n        freq = {}\\n        for num in nums:\\n            freq[num] = freq.get(num, 0) + 1\\n        \\n        # iterate through array and find pairs\\n        count = 0\\n        for num in freq:\\n            if k == 0:\\n                if freq[num] > 1:\\n                    count += 1\\n            else:\\n                if num + k in freq:\\n                    count += 1\\n        \\n        # return count of unique pairs\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        if k < 0:\\n            return 0\\n        \\n        # initialize hash table\\n        freq = {}\\n        for num in nums:\\n            freq[num] = freq.get(num, 0) + 1\\n        \\n        # iterate through array and find pairs\\n        count = 0\\n        for num in freq:\\n            if k == 0:\\n                if freq[num] > 1:\\n                    count += 1\\n            else:\\n                if num + k in freq:\\n                    count += 1\\n        \\n        # return count of unique pairs\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757899,
                "title": "c-two-pointer-t-nlogn-and-hashmap-t-n",
                "content": "**TWO-POINTER APPROACH T(NLogN)**\\n\\n1. The approach that I used here is similar to two-sum problem.\\n2. In two-sum we select two numbers that sums-up to k, whereas here we have to select two numbers with difference k.\\n3. I have used two pointers i & j, in two-sum the we start i from 0 and j from n-1, but here we\\'ll start i from 0 and j from 1 because at this point the difference will be minimum b/w nums[i] and nums[j].\\n\\n**CODE**\\n```\\nint findPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i=0, j=1, count=0;\\n        while(j<n){\\n            if(i==j) j++;\\n            if(j>n-1) break;\\n            if(nums[i]+k == nums[j]){\\n                count++;\\n                while(j<n and nums[i]+k == nums[j]) j++;\\n            }else if(nums[i]+k < nums[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n```\\n\\n**HASHMAP APPROACH T(N)**\\n\\n**CODE**\\n```\\nint findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        int c=0;\\n        for(auto i: nums) m[i]++;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            if(k!=0){\\n                if(m[k+nums[i]]>0){\\n                    c++;\\n                    m[k+nums[i]]=0;\\n                }\\n            }else{\\n                if(m[nums[i]]>1) c++;\\n                m[nums[i]]=0;\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nint findPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i=0, j=1, count=0;\\n        while(j<n){\\n            if(i==j) j++;\\n            if(j>n-1) break;\\n            if(nums[i]+k == nums[j]){\\n                count++;\\n                while(j<n and nums[i]+k == nums[j]) j++;\\n            }else if(nums[i]+k < nums[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n```\n```\\nint findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        int c=0;\\n        for(auto i: nums) m[i]++;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            if(k!=0){\\n                if(m[k+nums[i]]>0){\\n                    c++;\\n                    m[k+nums[i]]=0;\\n                }\\n            }else{\\n                if(m[nums[i]]>1) c++;\\n                m[nums[i]]=0;\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757179,
                "title": "c-simple-easy-solution-o-n-hashmap",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int count =0;\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<nums.size();i++) mp[nums[i]]++; \\n        for(auto i: mp){\\n            if(k==0) {\\n                if(i.second>1) \\n                    count++;\\n            }\\n             else {\\n                 if (mp.find(i.first - k) != mp.end()) \\n                     count++;\\n             }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int count =0;\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<nums.size();i++) mp[nums[i]]++; \\n        for(auto i: mp){\\n            if(k==0) {\\n                if(i.second>1) \\n                    count++;\\n            }\\n             else {\\n                 if (mp.find(i.first - k) != mp.end()) \\n                     count++;\\n             }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756867,
                "title": "c-95-fast-and-easy-solution-explained-hashmap",
                "content": "**Welcome to abivilion\\'s solution. Kindly Upvote for supporting this article.**\\n\\n**SOLUTION**\\n**TC - O(n)**\\n**SC - O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int>st;\\n        int count=0;\\n        \\n\\t\\t//storing in map\\n        for(auto &it:nums)\\n            st[it]++;\\n\\n       // if k is 0, then which element FREQUENCY >1 can give 0\\n        if(k==0) \\n        {\\n            for(auto &ko:st) if(ko.second>1) count++;\\n                \\n        }\\n\\n   // if k is any other number then ,difference can currentnum+k is present then the pair can give k as a resultant\\n   // a-b = c\\n   // a= c+b\\n   // b =c-a\\n        else\\n        for(auto &ki:st)\\n        {\\n            if(st.count(ki.first+k)) count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int>st;\\n        int count=0;\\n        \\n\\t\\t//storing in map\\n        for(auto &it:nums)\\n            st[it]++;\\n\\n       // if k is 0, then which element FREQUENCY >1 can give 0\\n        if(k==0) \\n        {\\n            for(auto &ko:st) if(ko.second>1) count++;\\n                \\n        }\\n\\n   // if k is any other number then ,difference can currentnum+k is present then the pair can give k as a resultant\\n   // a-b = c\\n   // a= c+b\\n   // b =c-a\\n        else\\n        for(auto &ki:st)\\n        {\\n            if(st.count(ki.first+k)) count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003595,
                "title": "python-7-line-super-simple-and-short-solution",
                "content": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        if (k == 0):\\n            return len([item for item, count in collections.Counter(nums).items() if count > 1])\\n        \\n        nums = set(nums)\\n        res = 0\\n        for n in nums:\\n            res += 1 if n-k in nums else 0\\n        return res\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        if (k == 0):\\n            return len([item for item, count in collections.Counter(nums).items() if count > 1])\\n        \\n        nums = set(nums)\\n        res = 0\\n        for n in nums:\\n            res += 1 if n-k in nums else 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914187,
                "title": "python-faster-than-93",
                "content": "```\\nclass Solution:\\n    def findPairs(self, a: List[int], K: int) -> int:\\n        s = set(a)\\n        if K == 0: return sum(1 for x in s if a.count(x) > 1)\\n        return sum(1 for x in s if x + K in s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, a: List[int], K: int) -> int:\\n        s = set(a)\\n        if K == 0: return sum(1 for x in s if a.count(x) > 1)\\n        return sum(1 for x in s if x + K in s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876921,
                "title": "binary-search-solution-java",
                "content": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {  \\n            int low=i+1;\\n            int high=nums.length-1;\\n            while(low<=high)\\n            {\\n                int mid=low+(high-low)/2;\\n                if(nums[mid]-nums[i]==k)\\n                {count++;\\n                 break;\\n                }else if(nums[mid]-nums[i]>k)\\n                    high=mid-1;\\n                else\\n                    low=mid+1;\\n            }\\n            while(i!=nums.length-1 && nums[i+1]==nums[i])\\n                i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {  \\n            int low=i+1;\\n            int high=nums.length-1;\\n            while(low<=high)\\n            {\\n                int mid=low+(high-low)/2;\\n                if(nums[mid]-nums[i]==k)\\n                {count++;\\n                 break;\\n                }else if(nums[mid]-nums[i]>k)\\n                    high=mid-1;\\n                else\\n                    low=mid+1;\\n            }\\n            while(i!=nums.length-1 && nums[i+1]==nums[i])\\n                i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876438,
                "title": "java-soln-1-pass-o-n-time-and-space",
                "content": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        HashSet<Integer> set = new HashSet<>();\\n\\t\\tint count = 0;\\n\\t\\t\\n\\t\\tHashSet<Integer> duplicateset = new HashSet<>();\\n\\t\\t\\n\\t\\t\\n\\t\\tfor (int n : nums) {\\n\\t\\t\\tif (set.contains(n)) {\\n\\t\\t\\t\\tif(k==0 && !duplicateset.contains(n)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tduplicateset.add(n);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else {\\n\\t\\t\\t\\t//check diff of that number exist to find pair. \\n\\t\\t\\t\\t// It will not count (a,b) and (b,a) as 1 set of number is not added to set yet.\\n\\t\\t\\t\\tif(k!=0 && set.contains(n-k)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(k!=0 && set.contains(n+k)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tset.add(n);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        HashSet<Integer> set = new HashSet<>();\\n\\t\\tint count = 0;\\n\\t\\t\\n\\t\\tHashSet<Integer> duplicateset = new HashSet<>();\\n\\t\\t\\n\\t\\t\\n\\t\\tfor (int n : nums) {\\n\\t\\t\\tif (set.contains(n)) {\\n\\t\\t\\t\\tif(k==0 && !duplicateset.contains(n)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tduplicateset.add(n);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else {\\n\\t\\t\\t\\t//check diff of that number exist to find pair. \\n\\t\\t\\t\\t// It will not count (a,b) and (b,a) as 1 set of number is not added to set yet.\\n\\t\\t\\t\\tif(k!=0 && set.contains(n-k)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(k!=0 && set.contains(n+k)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tset.add(n);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 830216,
                "title": "easy-js-solution",
                "content": "```\\nvar findPairs = function(nums, k) {\\n    if (k < 0) return 0;   \\n    nums = (k === 0) ? nums : Array.from(new Set(nums));\\n    let m = new Map(), res = 0;\\n    for (let num of nums) {\\n        if (m.get(num+k) === 1) res++;\\n        if (num+k !== num-k && m.get(num-k) === 1) res++;\\n        m.set(num, m.get(num)+1 || 1);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findPairs = function(nums, k) {\\n    if (k < 0) return 0;   \\n    nums = (k === 0) ? nums : Array.from(new Set(nums));\\n    let m = new Map(), res = 0;\\n    for (let num of nums) {\\n        if (m.get(num+k) === 1) res++;\\n        if (num+k !== num-k && m.get(num-k) === 1) res++;\\n        m.set(num, m.get(num)+1 || 1);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 656980,
                "title": "o-n-very-easy-way-by-using-hashset",
                "content": "\\tfrom typing import List\\n\\n\\n\\tclass Solution:\\n\\t\\tdef findPairs(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tif k < 0:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\tsaw = set()\\n\\t\\t\\tpair = set()\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif num + k in saw:\\n\\t\\t\\t\\t\\tpair.add((min(num + k, num), max(num + k, num)))\\n\\n\\t\\t\\t\\tif num - k in saw:\\n\\t\\t\\t\\t\\tpair.add((min(num - k, num), max(num - k, num)))\\n\\n\\t\\t\\t\\tsaw.add(num)\\n\\n\\t\\t\\treturn len(pair)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tfrom typing import List\\n\\n\\n\\tclass Solution:\\n\\t\\tdef findPairs(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tif k < 0:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\tsaw = set()\\n\\t\\t\\tpair = set()\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif num + k in saw:\\n\\t\\t\\t\\t\\tpair.add((min(num + k, num), max(num + k, num)))\\n\\n\\t\\t\\t\\tif num - k in saw:\\n\\t\\t\\t\\t\\tpair.add((min(num - k, num), max(num - k, num)))\\n\\n\\t\\t\\t\\tsaw.add(num)\\n\\n\\t\\t\\treturn len(pair)\\n",
                "codeTag": "Java"
            },
            {
                "id": 584942,
                "title": "python-two-pointer-o-nlogn",
                "content": "```\\ndef find_pairs(L: List[int], k: int) -> int:\\n    \"\"\"\\n    K-diff Pairs in an Array\\n\\n    time: O(nlogn)\\n    space: O(1)\\n\\n    :param List[int] L:\\n    :param int k:\\n    :return int:\\n    \"\"\"\\n    L.sort()\\n\\n    N = len(L)\\n\\n    i = pairs = 0\\n    j = 1\\n\\n    while j < N:\\n        if j < N - 1 and L[j] == L[j + 1]:\\n            j += 1\\n\\n        elif L[j] == L[i] + k:\\n            pairs += 1\\n            i += 1\\n            j += 1\\n\\n        elif L[j] > L[i] + k:\\n            i += 1\\n\\n        elif L[j] < L[i] + k:\\n            j += 1\\n\\n        j = max(j, i + 1)\\n\\n    return pairs\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\ndef find_pairs(L: List[int], k: int) -> int:\\n    \"\"\"\\n    K-diff Pairs in an Array\\n\\n    time: O(nlogn)\\n    space: O(1)\\n\\n    :param List[int] L:\\n    :param int k:\\n    :return int:\\n    \"\"\"\\n    L.sort()\\n\\n    N = len(L)\\n\\n    i = pairs = 0\\n    j = 1\\n\\n    while j < N:\\n        if j < N - 1 and L[j] == L[j + 1]:\\n            j += 1\\n\\n        elif L[j] == L[i] + k:\\n            pairs += 1\\n            i += 1\\n            j += 1\\n\\n        elif L[j] > L[i] + k:\\n            i += 1\\n\\n        elif L[j] < L[i] + k:\\n            j += 1\\n\\n        j = max(j, i + 1)\\n\\n    return pairs\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 530096,
                "title": "python-reasonably-fast-99-4-short-and-readable-explained-different-options",
                "content": "Let\\'s start with something easy to read:\\n\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        r = 0\\n        if k >= 0:\\n            c = collections.Counter(nums)\\n            for i in c:\\n                if (k==0 and c[i]>1) or (k!=0 and i+k in c):\\n                    r += 1\\n        return r\\n```\\n\\nSo there are 3 things you need to take care of:\\n\\n1. The k value is the *absolute* difference, so it has to be a positive number, otherwise we return 0\\n2. k==0. this is a special case. let\\'s say we have [1,1,1,3,3,3,3,...] the 3x1 will produce 1 pair, 4x3 - another 1. So the logic is every non unique element adds a pair. That is a typical case where collections.Counter can be used.\\n3. for all other numbers - we just need to check for every i if i+k is also present.\\n\\nSo now we are putting it all together.\\n\\nr is the return value set to 0. If k<0, we return it right away - this is the first case.\\nnow we create `c = collections.Counter(nums)` and then as we go through the elements, we check for both cases: where k==0 is i is repeated or if k!=0 (we can use k>0 instead) and i+k is also in c.\\n\\nSo this program works just fine and it looks readable, but if you want to save a couple lines ... If you look at the main loop, it\\'s a combination of a `for` and an `if` and it adds either 1 or nothing. So it could be a good case to use a comprehension instead:\\n\\n\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        c = collections.Counter(nums)\\n        return 0 if k<0 else sum([ 1  for i in c if (k==0 and c[i]>1) or (k!=0 and i+k in c) ])\\n```\\n\\nThe logic is exactly the same, just different presentation.\\n\\nAnd if for some reason you don\\'t want to use collections,  you can replace it with:\\n\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        #c = collections.Counter(nums)     \\n        c={}\\n        for i in nums:\\n            c[i] = c.get(i, 0) + 1                \\n        return 0 if k<0 else sum([ 1  for i in c if (k==0 and c[i]>1) or (k!=0 and i+k in c) ])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        r = 0\\n        if k >= 0:\\n            c = collections.Counter(nums)\\n            for i in c:\\n                if (k==0 and c[i]>1) or (k!=0 and i+k in c):\\n                    r += 1\\n        return r\\n```\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        c = collections.Counter(nums)\\n        return 0 if k<0 else sum([ 1  for i in c if (k==0 and c[i]>1) or (k!=0 and i+k in c) ])\\n```\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        #c = collections.Counter(nums)     \\n        c={}\\n        for i in nums:\\n            c[i] = c.get(i, 0) + 1                \\n        return 0 if k<0 else sum([ 1  for i in c if (k==0 and c[i]>1) or (k!=0 and i+k in c) ])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100186,
                "title": "short-java-solution-but-two-hashsets",
                "content": "```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set<Integer> seenNum = new HashSet<>();\\n        Set<String> seenPair = new HashSet<>();\\n        int result = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int prev = nums[i] - k;\\n            if (seenNum.contains(prev) && !seenPair.contains(prev + \",\" + nums[i])) {\\n                result++;\\n                seenPair.add(prev + \",\" + nums[i]);\\n            }\\n            seenNum.add(nums[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set<Integer> seenNum = new HashSet<>();\\n        Set<String> seenPair = new HashSet<>();\\n        int result = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int prev = nums[i] - k;\\n            if (seenNum.contains(prev) && !seenPair.contains(prev + \",\" + nums[i])) {\\n                result++;\\n                seenPair.add(prev + \",\" + nums[i]);\\n            }\\n            seenNum.add(nums[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329845,
                "title": "java-very-easy-explanation-hashmap",
                "content": "# Intuition\\nVery easy approach to solve the problem with the help of single loop and hashmap\\n\\n# Approach\\n\\n* initiate a Map \\n* enter all elements and its frequency\\n* inside of entry loop of map ,check\\n1. if k==0 , it means any element which is occuring more then twice will always have diff ==0 , ex- 1-1=0 , 15-15 =0 ...\\n2. else if map contains element + k , then pair++  \\n\\n# Complexity\\n- Time complexity:\\no(n)\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int n =nums.length;\\n      HashMap<Integer,Integer> map = new HashMap<>();\\n      for(int i =0;i<n;i++){\\n          if(map.containsKey(nums[i]))\\n          map.put(nums[i],map.get(nums[i])+1);\\n          else\\n          map.put(nums[i],1);\\n      }\\n        int count =0;\\n\\n      for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n        int val = entry.getValue();\\n        int key = entry.getKey();\\n\\n        if(k==0){\\n          if(val>=2)\\n            count++;\\n        }\\n\\n        else if(map.containsKey(key+k))\\n        count++;\\n      }  \\n        return count;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int n =nums.length;\\n      HashMap<Integer,Integer> map = new HashMap<>();\\n      for(int i =0;i<n;i++){\\n          if(map.containsKey(nums[i]))\\n          map.put(nums[i],map.get(nums[i])+1);\\n          else\\n          map.put(nums[i],1);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1923803,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int c=0;\\n        for(int val:nums )\\n            {\\n                map.put(val,map.getOrDefault(val,0)+1);\\n            \\n            }\\n        for(int i:map.keySet())\\n            {\\n                if((k==0 && map.get(i)>1)||(k>0 && map.containsKey(i+k)))\\n                    c++;\\n            }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int c=0;\\n        for(int val:nums )\\n            {\\n                map.put(val,map.getOrDefault(val,0)+1);\\n            \\n            }\\n        for(int i:map.keySet())\\n            {\\n                if((k==0 && map.get(i)>1)||(k>0 && map.containsKey(i+k)))\\n                    c++;\\n            }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758373,
                "title": "python-3-60ms-o-n-counter-hashmap-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        count = Counter(nums)\\n        if k > 0:\\n            return sum([i + k in count for i in count])\\n        else:\\n            return sum([count[i] > 1 for i in count])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        count = Counter(nums)\\n        if k > 0:\\n            return sum([i + k in count for i in count])\\n        else:\\n            return sum([count[i] > 1 for i in count])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758183,
                "title": "java-simple-easy-set-no-sort",
                "content": "Simplified  Clean Coded Solution !\\uD83D\\uDE00\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int pairs = 0, n = nums.length;\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> repeatedElements = new HashSet<>();\\n        \\n        for(int ele : nums){\\n            if(set.contains(ele)) repeatedElements.add(ele);\\n            set.add(ele);\\n        }\\n        \\n        // SPECIAL CASE [K == 0]\\n        if(k == 0) return repeatedElements.size();\\n        \\n        // Traversing the SET not the array.\\n        for(int elementInSet : set)\\n            if(set.contains(elementInSet + k)) pairs++;\\n       \\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int pairs = 0, n = nums.length;\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> repeatedElements = new HashSet<>();\\n        \\n        for(int ele : nums){\\n            if(set.contains(ele)) repeatedElements.add(ele);\\n            set.add(ele);\\n        }\\n        \\n        // SPECIAL CASE [K == 0]\\n        if(k == 0) return repeatedElements.size();\\n        \\n        // Traversing the SET not the array.\\n        for(int elementInSet : set)\\n            if(set.contains(elementInSet + k)) pairs++;\\n       \\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757732,
                "title": "c-python-simple-and-clean-o-n-solutions",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> map;\\n        for(auto num:nums)\\n            map[num]++;\\n        \\n        int res = 0;\\n        if (k > 0) {\\n            for(auto a:map)\\n                if (map.find(a.first+k) != map.end()) \\n                    res++;\\n        }\\n        \\n        else {\\n            for(auto a:map)\\n                if (a.second > 1)\\n                    res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Python:**\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        if (k == 0):\\n            return len([item for item, count in collections.Counter(nums).items() if count > 1])\\n        \\n        nums = set(nums)\\n        res = 0\\n        for n in nums:\\n            res += 1 if n-k in nums else 0\\n        return res\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> map;\\n        for(auto num:nums)\\n            map[num]++;\\n        \\n        int res = 0;\\n        if (k > 0) {\\n            for(auto a:map)\\n                if (map.find(a.first+k) != map.end()) \\n                    res++;\\n        }\\n        \\n        else {\\n            for(auto a:map)\\n                if (a.second > 1)\\n                    res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        if (k == 0):\\n            return len([item for item, count in collections.Counter(nums).items() if count > 1])\\n        \\n        nums = set(nums)\\n        res = 0\\n        for n in nums:\\n            res += 1 if n-k in nums else 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757294,
                "title": "c-two-pointers-lower-bound-nlogn",
                "content": "### Using two pointer C++ | nlogn :\\n```\\nint findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1;\\n        int n=nums.size();\\n        while(i<n &&j<n){                                      \\n            if(i!=0 && nums[i]==nums[i-1]){i++;continue;}\\n            if(i==j) {j++;continue;}\\n            \\n            int dif=nums[j]-nums[i];\\n            if(dif==k){i++;ans++;}\\n            else if(dif<k) j++;\\n            else i++;\\n        }\\n      return ans;\\n}\\n```\\n\\n### Using Lower Bound C++ | nlogn :\\n```\\nint findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(auto it=nums.begin();it!=nums.end();it++){         \\n            if(it!=nums.begin() && *it==*(it-1)) continue; \\n            auto itr=lower_bound(it+1,nums.end(),k+(*it));\\n            if(itr==nums.end()) continue;\\n            if(*itr-*it==k){\\n                ans++;\\n            }\\n        }\\n         return ans;\\n  }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1;\\n        int n=nums.size();\\n        while(i<n &&j<n){                                      \\n            if(i!=0 && nums[i]==nums[i-1]){i++;continue;}\\n            if(i==j) {j++;continue;}\\n            \\n            int dif=nums[j]-nums[i];\\n            if(dif==k){i++;ans++;}\\n            else if(dif<k) j++;\\n            else i++;\\n        }\\n      return ans;\\n}\\n```\n```\\nint findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(auto it=nums.begin();it!=nums.end();it++){         \\n            if(it!=nums.begin() && *it==*(it-1)) continue; \\n            auto itr=lower_bound(it+1,nums.end(),k+(*it));\\n            if(itr==nums.end()) continue;\\n            if(*itr-*it==k){\\n                ans++;\\n            }\\n        }\\n         return ans;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757214,
                "title": "java-binary-search-easy-to-understand",
                "content": "Try search for each element because we need to find only unique element so discard those element that have been traversed,\\n```\\nclass Solution \\n{\\n    public int findPairs(int[] nums, int k) \\n    {\\n        int n = nums.length;\\n        int count =0;\\n        Arrays.sort(nums);\\n        if(k==0)\\n        {\\n           int pre = 100000001;\\n           for(int i=0;i<(n-1);i++)\\n           {\\n               if((nums[i]==nums[i+1]) && pre!=nums[i])\\n               {\\n                   count++;\\n               }\\n               pre = nums[i];\\n           }\\n           return count;\\n        }\\n        int pre = 100000001;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(pre!=nums[i])\\n            {\\n               count = count + search(nums,i,k,n-1);\\n               pre = nums[i]; \\n            }\\n        }  \\n        return count;\\n    }\\n    public int search(int[] nums,int l,int k,int r)\\n    {\\n        int target = nums[l];\\n        int t = (target+k);\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n          \\n            if(nums[mid]==t)\\n            {\\n                return 1;\\n            }\\n            else if(nums[mid]>t)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int findPairs(int[] nums, int k) \\n    {\\n        int n = nums.length;\\n        int count =0;\\n        Arrays.sort(nums);\\n        if(k==0)\\n        {\\n           int pre = 100000001;\\n           for(int i=0;i<(n-1);i++)\\n           {\\n               if((nums[i]==nums[i+1]) && pre!=nums[i])\\n               {\\n                   count++;\\n               }\\n               pre = nums[i];\\n           }\\n           return count;\\n        }\\n        int pre = 100000001;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(pre!=nums[i])\\n            {\\n               count = count + search(nums,i,k,n-1);\\n               pre = nums[i]; \\n            }\\n        }  \\n        return count;\\n    }\\n    public int search(int[] nums,int l,int k,int r)\\n    {\\n        int target = nums[l];\\n        int t = (target+k);\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n          \\n            if(nums[mid]==t)\\n            {\\n                return 1;\\n            }\\n            else if(nums[mid]>t)\\n            {\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756983,
                "title": "c-easy-understood-solution-map",
                "content": "We need to find pair whose differense is k.\\nSo that we can store frequency to map and we will find, whether another key is exist or not whose difference is k.\\nif exist, then we will increment our ans by 1.\\n\\nLet\\'s look at one example.\\n**nums = [1,3,5,1,4], k = 2**\\n\\nNow store frequency to map:\\n1-> 2\\n3-> 1\\n4-> 1\\n5-> 1\\n\\nNow, iterate to map and find key difference of k. If found then increment ans+1.\\n\\nHere, keys two keys found **(1,3), (3,5)** whose difference is 2. So that **ans = 2**;\\n\\nWe need to also take care when k=0 given.\\nSo that I have just decrement value by 1 and increment value by 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int ans = 0;\\n        map<int,int> mp;\\n        for(auto &x : nums){\\n            mp[x]++;\\n        }\\n        for(auto &x : mp){\\n            x.second--;\\n            if(mp.find(x.first+k) != mp.end() and mp[x.first+k] >= 1)\\n                ans++;\\n            x.second++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int ans = 0;\\n        map<int,int> mp;\\n        for(auto &x : nums){\\n            mp[x]++;\\n        }\\n        for(auto &x : mp){\\n            x.second--;\\n            if(mp.find(x.first+k) != mp.end() and mp[x.first+k] >= 1)\\n                ans++;\\n            x.second++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718359,
                "title": "c-two-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n    //      time O(nlgn) space O(1)\\n    //     sort(nums.begin(),nums.end());\\n    //     int n=nums.size();\\n    //     int count=0;\\n    //     for(int i=0;i<n;i++){\\n    //         if(i!=0&&nums[i]==nums[i-1])continue;\\n    //         bool res=binary_search(nums.begin()+i+1,nums.end(),nums[i]+k);\\n    //         if(res){\\n    //             count++;\\n    //         }     \\n    //     }\\n    //     return count;\\n    // }\\n        \\n        //      time O(n) space O(n)\\n        int n=nums.size();\\n        int count=0;\\n        unordered_map<int,int> lookup;\\n        if(k==0){\\n            for(int i=0;i<n;i++){\\n                if(lookup[nums[i]]==1){\\n                    count++;\\n                }    \\n                lookup[nums[i]] =lookup[nums[i]]+1;\\n            }\\n        }else{\\n            for(int i=0;i<n;i++){\\n                if(!lookup.count(nums[i])){\\n                    if(lookup.count(nums[i]-k)){\\n                        count++;\\n                    }\\n                    if(lookup.count(nums[i]+k)){\\n                        count++;\\n                    }\\n                    lookup[nums[i]]+=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n    //      time O(nlgn) space O(1)\\n    //     sort(nums.begin(),nums.end());\\n    //     int n=nums.size();\\n    //     int count=0;\\n    //     for(int i=0;i<n;i++){\\n    //         if(i!=0&&nums[i]==nums[i-1])continue;\\n    //         bool res=binary_search(nums.begin()+i+1,nums.end(),nums[i]+k);\\n    //         if(res){\\n    //             count++;\\n    //         }     \\n    //     }\\n    //     return count;\\n    // }\\n        \\n        //      time O(n) space O(n)\\n        int n=nums.size();\\n        int count=0;\\n        unordered_map<int,int> lookup;\\n        if(k==0){\\n            for(int i=0;i<n;i++){\\n                if(lookup[nums[i]]==1){\\n                    count++;\\n                }    \\n                lookup[nums[i]] =lookup[nums[i]]+1;\\n            }\\n        }else{\\n            for(int i=0;i<n;i++){\\n                if(!lookup.count(nums[i])){\\n                    if(lookup.count(nums[i]-k)){\\n                        count++;\\n                    }\\n                    if(lookup.count(nums[i]+k)){\\n                        count++;\\n                    }\\n                    lookup[nums[i]]+=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625606,
                "title": "100-faster-8-ms-without-using-map-worst-case-o-n-logn-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int slow = 0, fast = 1, ans = 0;\\n        while(slow < nums.size() && fast < nums.size()){\\n            if(nums[fast] - nums[slow] == k){\\n                slow++;\\n                fast++;\\n                ans++;\\n                while(fast < nums.size() && nums[fast] == nums[fast - 1]) fast++;\\n            }\\n            else if(nums[fast] - nums[slow] > k){\\n                slow++;\\n                if(fast - slow == 0) fast++;\\n            }\\n            else fast++;            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int slow = 0, fast = 1, ans = 0;\\n        while(slow < nums.size() && fast < nums.size()){\\n            if(nums[fast] - nums[slow] == k){\\n                slow++;\\n                fast++;\\n                ans++;\\n                while(fast < nums.size() && nums[fast] == nums[fast - 1]) fast++;\\n            }\\n            else if(nums[fast] - nums[slow] > k){\\n                slow++;\\n                if(fast - slow == 0) fast++;\\n            }\\n            else fast++;            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621521,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        unordered_map<int,int>mymap;\\n        int count=0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            mymap[nums[i]]++;\\n        }\\n        \\n        if(k==0){\\n            for(auto x:mymap){\\n                if(x.second>1){\\n                    count++;\\n                }\\n            }\\n             return count;\\n        }\\n    \\n        for(auto x:mymap){\\n            if(mymap.count(x.first-k)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        unordered_map<int,int>mymap;\\n        int count=0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            mymap[nums[i]]++;\\n        }\\n        \\n        if(k==0){\\n            for(auto x:mymap){\\n                if(x.second>1){\\n                    count++;\\n                }\\n            }\\n             return count;\\n        }\\n    \\n        for(auto x:mymap){\\n            if(mymap.count(x.first-k)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388185,
                "title": "c-o-n-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int> m;\\n        int c=0;\\n        \\n        if(k<0) return 0;\\n        \\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n        }\\n        \\n        if(k==0){\\n            for(auto x:m){\\n                if(x.second>1){\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n        \\n        for(auto x:m){\\n            if(m.count(x.first-k)){\\n                c++;\\n            }\\n            \\n        }\\n        return c;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int> m;\\n        int c=0;\\n        \\n        if(k<0) return 0;\\n        \\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n        }\\n        \\n        if(k==0){\\n            for(auto x:m){\\n                if(x.second>1){\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n        \\n        for(auto x:m){\\n            if(m.count(x.first-k)){\\n                c++;\\n            }\\n            \\n        }\\n        return c;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338044,
                "title": "c-simple-single-loop-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> freq;\\n        for(int i=0;i<nums.size();i++){\\n            freq[nums[i]]++;\\n        }\\n        int count=0;\\n        if(k!=0){\\n            for(auto itr:freq){\\n                if(freq.find(itr.first+k)!=freq.end()){\\n                    count++;\\n                }\\n            }\\n        }\\n        else{\\n            for(auto itr: freq){\\n                if(itr.second>1){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> freq;\\n        for(int i=0;i<nums.size();i++){\\n            freq[nums[i]]++;\\n        }\\n        int count=0;\\n        if(k!=0){\\n            for(auto itr:freq){\\n                if(freq.find(itr.first+k)!=freq.end()){\\n                    count++;\\n                }\\n            }\\n        }\\n        else{\\n            for(auto itr: freq){\\n                if(itr.second>1){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228679,
                "title": "easy-c-soln-nlogn-one-pointer-with-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    //one pointer with binary search nlogn\\n    int findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(i>0 && nums[i]==nums[i-1])continue;\\n            int x=nums[i];\\n            int l=i+1,r=nums.size()-1;\\n            while(l<=r){\\n                int m=(l+r)>>1;\\n                if(nums[m]-x==k){\\n                    ans++;\\n                    break;\\n                }\\n                else if(nums[m]-x>k)r=m-1;\\n                else l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //one pointer with binary search nlogn\\n    int findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(i>0 && nums[i]==nums[i-1])continue;\\n            int x=nums[i];\\n            int l=i+1,r=nums.size()-1;\\n            while(l<=r){\\n                int m=(l+r)>>1;\\n                if(nums[m]-x==k){\\n                    ans++;\\n                    break;\\n                }\\n                else if(nums[m]-x>k)r=m-1;\\n                else l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980705,
                "title": "python-o-n-96",
                "content": "```\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n  \\n        count = 0\\n    \\n\\n        dic= {}\\n        \\n        for num in nums:\\n            if num not in dic: dic[num] = 1\\n            else: dic[num] += 1\\n        \\n        if k == 0:\\n            for key in dic.keys():\\n                if dic[key] > 1: count += 1\\n        \\n        else:\\n            for key in dic.keys():\\n                if key + k in dic: count += 1\\n        \\n        return count",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n  \\n        count = 0\\n    \\n\\n        dic= {}",
                "codeTag": "Java"
            },
            {
                "id": 876956,
                "title": "java-k-diff-pair-100-2-pointer-well-explained-with-multiple-solution",
                "content": "I have explained basic solution below, but let\\'s start with the best approach, a **2 pointer approach. **\\n\\nWhy 2 pointer? \\nBecause we need to find a pair, Non repeatable and the brute force, basic approach is not time efficient.\\n\\nSince we want only unique pair, answer will do irrespective of order and its easier to calculate diff we know where to find larger number or smaller number when sorted, **we sort the array.**\\n\\nStart both left and right from one side.** Calculate diff **of each right val - left val, \\n\\n1. if value is less than k, we need to increase right pointer to take higher value (sorting helps)\\n2. if value is more than k, we increase left pointer to increase smaller val (of left) and sorting does help.. in  case left==right also, we need to increase right by 1, since obviously we need pairs.\\n3. if value == k, yay!! Increase your count by 1 and move left and right by 1. (let\\'s find another pair)\\n\\t In case of repeated value like, 1 1 2 2 or 1 1 2 for k == 1, we need to keep moving left pointer until we find a different value. (No need to check for right, cause if left is unique, right definitely won\\'t be the prev right value. \\n\\t \\n100%\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int l = nums.length;\\n        int left = 0, right = 1,count = 0;\\n        \\n        while(right<l && left<l){\\n            if(left==right || nums[right]-nums[left]<k)\\n                right++;\\n            else if(nums[right]-nums[left]==k){\\n                count++;\\n                left++;\\n                right++;\\n                while(left < l && nums[left] == nums[left-1])\\n                    left++;\\n            }\\n            else\\n                left++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n-------\\nBasic brute force approach: Consider all the possibilities of pair difference and return all,\\n19% Fast only\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Set<String> pairs = new HashSet<>();\\n        for(int one = 0;one<nums.length;one++){\\n            for(int two = one+1; two < nums.length;two++){\\n                int first = nums[one], second = nums[two];\\n                if(Math.abs(first-second)==Math.abs(k))\\n                    pairs.add(first>second ? first+\" \"+second : second+\" \"+first);\\n            }\\n        }\\n        return pairs.size();\\n    }\\n}\\n\\nAfter pruning: sort it, then you need only second-first (remove Math.abs and first>Secind condition as always second>first)\\nif sorted you can use 2 pointer approach, if right val-left val ==k, we move both forward, if right val -left val > k, we need to increase left val so it matches k,\\nif right val - left val < k, we need to increase right val so it matches k.\\n25% Fast\\n```\\npublic int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int l = nums.length;\\n        Set<String> pairs = new HashSet<>();\\n        int left = 0, right = 1;\\n        int count = 0;\\n        String prevVals = \"\";\\n        while(right<l && left<right){\\n            String currentVals = nums[right]+\" \"+nums[left];\\n            if(prevVals.equals(currentVals)){\\n                left++;right++;\\n                continue;\\n            }\\n            int diff = nums[right]-nums[left];\\n            if(diff==k){\\n                count++;\\n                left++;\\n                right++;\\n                prevVals = currentVals;\\n            }else if(diff>k){\\n                left++;\\n                if(right==left)\\n                    right++;\\n            }\\n            else\\n                right++;\\n        }\\n        return count;\\n    }\\n\\t\\n```\\nThese are also 2 pointer approaches but we add more pruning  in 100% solution, like how and when to left++ and when to do right++. Also it is easy tp understand.\\n**If we need to find a pair, I guess it is prety straighforward and easy with 2 pointer. And if the order does not matter, sorting should help**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int l = nums.length;\\n        int left = 0, right = 1,count = 0;\\n        \\n        while(right<l && left<l){\\n            if(left==right || nums[right]-nums[left]<k)\\n                right++;\\n            else if(nums[right]-nums[left]==k){\\n                count++;\\n                left++;\\n                right++;\\n                while(left < l && nums[left] == nums[left-1])\\n                    left++;\\n            }\\n            else\\n                left++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\npublic int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int l = nums.length;\\n        Set<String> pairs = new HashSet<>();\\n        int left = 0, right = 1;\\n        int count = 0;\\n        String prevVals = \"\";\\n        while(right<l && left<right){\\n            String currentVals = nums[right]+\" \"+nums[left];\\n            if(prevVals.equals(currentVals)){\\n                left++;right++;\\n                continue;\\n            }\\n            int diff = nums[right]-nums[left];\\n            if(diff==k){\\n                count++;\\n                left++;\\n                right++;\\n                prevVals = currentVals;\\n            }else if(diff>k){\\n                left++;\\n                if(right==left)\\n                    right++;\\n            }\\n            else\\n                right++;\\n        }\\n        return count;\\n    }\\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876727,
                "title": "java-k-diff-pairs-in-an-array-hashmap",
                "content": "We\\'re using hashmap to store the unique keys of the array, the value is the time those keys appear.\\nWe then loop all the HashMap, and check if the map contains the key = a + k => We have 1 pair.\\nRemember to check if k = 0, it is the number of keys has value > 1\\n\\n```\\npublic int findPairs(int[] nums, int k) {\\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\\n        int result = 0;\\n        for (int i : nums) {\\n            int count = hashMap.getOrDefault(i, 0);\\n            hashMap.put(i, count + 1);\\n        }\\n\\n        for (Map.Entry<Integer, Integer> i : hashMap.entrySet()) {\\n            if (k == 0) {\\n                if (i.getValue() > 1)\\n                    ++result;\\n            } else {\\n                int a = i.getKey();\\n                if (hashMap.containsKey(a + k)) {\\n                    ++result;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findPairs(int[] nums, int k) {\\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\\n        int result = 0;\\n        for (int i : nums) {\\n            int count = hashMap.getOrDefault(i, 0);\\n            hashMap.put(i, count + 1);\\n        }\\n\\n        for (Map.Entry<Integer, Integer> i : hashMap.entrySet()) {\\n            if (k == 0) {\\n                if (i.getValue() > 1)\\n                    ++result;\\n            } else {\\n                int a = i.getKey();\\n                if (hashMap.containsKey(a + k)) {\\n                    ++result;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876608,
                "title": "java-short-and-crisp-hasmap-and-binary-search-with-explanaiton",
                "content": "***Question:***\\nTo return the number of unique k-diff pairs in the array.\\nInput: nums = [3,1,4,1,5], k = 2\\nAnswer: 2. Two pairs (1,3) and (3,5)\\n\\n**Using HashMap:**\\nJust see for an element num, there exists num+k.\\nWe essentially need to store count of number,to not mis-intrepet same number as its pair when k=0.\\n\\n**TimeComplexity:** HashMap put and get operations are O(1) with assumption that key-value pairs are well distributed across the buckets. But in worst case, if we need to add multiple elements to one bucket so it can be O(n) .\\n\\n**Space complexity:** In worst case all elements may be unique,so O(n).\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        //HashMap to store value-count\\n        Map<Integer, Integer> hashmap = new HashMap();\\n\\n\\t\\tint result = 0;\\n        /*\\n        for every number ,\\n        if number is seen for the first time ,then put count=1\\n        else ,increment the count\\n        */\\n        for(int num : nums)\\n            hashmap.computeIfAbsent(num, hashmap.getOrDefault(num, 0) + 1);\\n        //For all the elements in hashmap\\n        for(int i : hashmap.keySet()){\\n            /*\\n            As contistion is given i != j && nums[j]-nums[i]=k,\\n            This make sure that same element is not counted \\n            */\\n\\t\\t\\tif(k==0 && hashmap.get(i) > 1) result++;\\n            else if (hashmap.containsKey(i + k)) result++;\\n\\t\\t}\\n        return result;\\n    }\\n}\\n```\\n\\n**Using Binary-Search:**\\n\\nInstead of using in-built methods of arrays.binarysearch(array,start,end,key), I used a utility function .\\n\\n1.To apply binary search we need to sort array. \\n2.After sorting we need to search for element \"num\" ,if there exists another element \"num+k\".\\n\\nImprovement 1:\\nAs we need unique pair,we dont search if current element is same as before.\\nImprovement 2:\\nAs we sorted array in ascending order, we just need to start our binary search from current_index+1.So searching space considerly reduces.\\nAs we are searching from index+1,this also make sure we are not considering same element when k=0.\\n\\n**Time complexity :** O(n log(n)) for sorting, and for searching in worst case O(log(n)) .As we are doing search operation for n elements, O(n log(n)). Resultant time complexity will be O(n log(n)).\\n\\n**Space complexity:**\\nO(1)[If not considering input array],beacuse we are using fixed number of variables.\\n\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int res=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n\\t\\t//To make sure all pairs are unique\\n            if(i==0||nums[i]!=nums[i-1])\\n                if(search(nums,i,k)) res++;\\n    \\n        return res;\\n    }\\n    private boolean search(int[] nums,int index,int k){\\n        int st=index+1,end=nums.length-1,val=nums[index]+k;\\n        while(st<=end){\\n            int mid=st+(end-st)/2;\\n            if(nums[mid]==val) return true;\\n            else if(nums[mid]>val) end=mid-1;\\n            else st=mid+1;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nHope this solution was useful.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        //HashMap to store value-count\\n        Map<Integer, Integer> hashmap = new HashMap();\\n\\n\\t\\tint result = 0;\\n        /*\\n        for every number ,\\n        if number is seen for the first time ,then put count=1\\n        else ,increment the count\\n        */\\n        for(int num : nums)\\n            hashmap.computeIfAbsent(num, hashmap.getOrDefault(num, 0) + 1);\\n        //For all the elements in hashmap\\n        for(int i : hashmap.keySet()){\\n            /*\\n            As contistion is given i != j && nums[j]-nums[i]=k,\\n            This make sure that same element is not counted \\n            */\\n\\t\\t\\tif(k==0 && hashmap.get(i) > 1) result++;\\n            else if (hashmap.containsKey(i + k)) result++;\\n\\t\\t}\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        int res=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n\\t\\t//To make sure all pairs are unique\\n            if(i==0||nums[i]!=nums[i-1])\\n                if(search(nums,i,k)) res++;\\n    \\n        return res;\\n    }\\n    private boolean search(int[] nums,int index,int k){\\n        int st=index+1,end=nums.length-1,val=nums[index]+k;\\n        while(st<=end){\\n            int mid=st+(end-st)/2;\\n            if(nums[mid]==val) return true;\\n            else if(nums[mid]>val) end=mid-1;\\n            else st=mid+1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876479,
                "title": "c-simple-double-solution-explained-100-time-100-space",
                "content": "While this problem does not seem to be a medium by any stretch of imagination, I think the real trick here is actually to understand that this problem is actually 2 problems:\\n* when `k == 0`, we go hunting for duplicates;\\n* in all the other cases, we go looking for pairs `{a, b}` so that `b - a == k` and we know that `a != b` (otherwise you would have again `k == 0`).\\n\\nNow, for the first case, working with a frequency map and then counting all the elements with frequency `> 1` just works like a charm.\\n\\nThe second case, being a different problem, demands another approach - using a `unordered_set`, for example - populating it and then going through it looking for each element `n` matched by another `k + n` element and increasing the result accordingly.\\n\\nWhatever is the way, in the end we just return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int res = 0;\\n        // edge case k == 0, we hunt for duplicates\\n        if (!k) {\\n            unordered_map<int, int> frequencies;\\n            for (int n: nums) frequencies[n]++;\\n            for (auto e: frequencies) if (e.second > 1) res++;\\n        }\\n        // all the other cases\\n        else {\\n            unordered_set<int> seen(begin(nums), end(nums));\\n            for (int n: seen) {\\n                res += seen.find(k + n) != end(seen);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int res = 0;\\n        // edge case k == 0, we hunt for duplicates\\n        if (!k) {\\n            unordered_map<int, int> frequencies;\\n            for (int n: nums) frequencies[n]++;\\n            for (auto e: frequencies) if (e.second > 1) res++;\\n        }\\n        // all the other cases\\n        else {\\n            unordered_set<int> seen(begin(nums), end(nums));\\n            for (int n: seen) {\\n                res += seen.find(k + n) != end(seen);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748774,
                "title": "c-3-approaches-97-faster",
                "content": "```\\n#Approach 1 :  without sorting 98% faster 47% space\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        if(k<0){return 0;}\\n        unordered_map<int,int> mp;      \\n        for(int i = 0; i<nums.size(); i++){\\n            mp[nums[i]]++;\\n        }\\n       int count = 0;\\n       for(auto x : mp){\\n           int diff = x.first - k;\\n           if(mp.find(diff)!=mp.end()){\\n               if(diff==x.first and x.second>1){\\n                   count++;\\n               }else if(diff!=x.first and x.second>=1){\\n                   count++;\\n               }\\n           }\\n       }\\n        return count;\\n       \\n    }\\n};\\n#Approach 2 : with sorting + map\\nclass Solution {\\npublic:\\n     int findPairs(vector<int>& nums, int k) {\\n\\t\\t  set<pair<int,int>> unq;\\n          unordered_map<int,int> m;\\n        \\n          sort(nums.begin(),nums.end());\\n        \\n          for(int i=0;i<nums.size();i++)\\n           {\\n            int temp=nums[i]-k;\\n            if(m.find(temp)!=m.end())\\n            {\\n                unq.insert(make_pair(nums[i],temp));\\n                \\n            }\\n            m[nums[i]]=0; // so we can use temp=nums[i]-k again but from next time nums[i] shouldn\\'t be same so we decreament its count  or make it equal to 0 \\n        }\\n        \\n        return unq.size();\\n     }\\n};\\n\\n// two pointers\\nclass Solution {\\npublic:\\n     int findPairs(vector<int>& nums, int k) {\\n          sort(nums.begin(),nums.end());\\n         int n =  nums.size();\\n         int count = 0;\\n         int i = 0; int j = 1;\\n         while(i<n and j<n){\\n             if(nums[j] - nums[i] == k){\\n                 i++;\\n                 j++;\\n                 count++;\\n                 // to handle duplicates\\n                 while(j<n and nums[j]==nums[j-1]){\\n                     j++;\\n                 }\\n             }else if(nums[j]-nums[i] > k){\\n                 i++;\\n                 if(j-i==0){\\n                     j++;\\n                 }\\n             }else{\\n                 j++;\\n             }\\n             \\n         }\\n        return count;\\n          \\n     }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#Approach 1 :  without sorting 98% faster 47% space\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        if(k<0){return 0;}\\n        unordered_map<int,int> mp;      \\n        for(int i = 0; i<nums.size(); i++){\\n            mp[nums[i]]++;\\n        }\\n       int count = 0;\\n       for(auto x : mp){\\n           int diff = x.first - k;\\n           if(mp.find(diff)!=mp.end()){\\n               if(diff==x.first and x.second>1){\\n                   count++;\\n               }else if(diff!=x.first and x.second>=1){\\n                   count++;\\n               }\\n           }\\n       }\\n        return count;\\n       \\n    }\\n};\\n#Approach 2 : with sorting + map\\nclass Solution {\\npublic:\\n     int findPairs(vector<int>& nums, int k) {\\n\\t\\t  set<pair<int,int>> unq;\\n          unordered_map<int,int> m;\\n        \\n          sort(nums.begin(),nums.end());\\n        \\n          for(int i=0;i<nums.size();i++)\\n           {\\n            int temp=nums[i]-k;\\n            if(m.find(temp)!=m.end())\\n            {\\n                unq.insert(make_pair(nums[i],temp));\\n                \\n            }\\n            m[nums[i]]=0; // so we can use temp=nums[i]-k again but from next time nums[i] shouldn\\'t be same so we decreament its count  or make it equal to 0 \\n        }\\n        \\n        return unq.size();\\n     }\\n};\\n\\n// two pointers\\nclass Solution {\\npublic:\\n     int findPairs(vector<int>& nums, int k) {\\n          sort(nums.begin(),nums.end());\\n         int n =  nums.size();\\n         int count = 0;\\n         int i = 0; int j = 1;\\n         while(i<n and j<n){\\n             if(nums[j] - nums[i] == k){\\n                 i++;\\n                 j++;\\n                 count++;\\n                 // to handle duplicates\\n                 while(j<n and nums[j]==nums[j-1]){\\n                     j++;\\n                 }\\n             }else if(nums[j]-nums[i] > k){\\n                 i++;\\n                 if(j-i==0){\\n                     j++;\\n                 }\\n             }else{\\n                 j++;\\n             }\\n             \\n         }\\n        return count;\\n          \\n     }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384530,
                "title": "c-112-ms",
                "content": "\\tpublic class Solution\\n    {\\n        public int FindPairs(int[] nums, int k)\\n        {\\n            if (k < 0)\\n            {\\n                return 0;\\n            }\\n            var counts = new Dictionary<int, int>();\\n            foreach (int n in nums)\\n            {\\n                counts[n] = counts.ContainsKey(n) ? counts[n] + 1 : 1;\\n            }\\n            return\\n                k == 0 ?\\n                counts.Count(i => i.Value > 1) :\\n                counts.Count(i => counts.ContainsKey(i.Key + k));\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        public int FindPairs(int[] nums, int k)\\n        {\\n            if (k < 0)\\n            {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 247508,
                "title": "javascript-solution-with-explanation-beats-100",
                "content": "\\n```\\nvar findPairs = function(nums, k) {\\n    let pairCount = 0;\\n    let uniques = new Set(nums);\\n    \\n    // Something can\\'t have a negative difference - diff is an absolute value \\n    if (k < 0) return 0;\\n    \\n    // If k is zero, we are basically finding which elements in nums are duplicates\\n    if (k === 0) return findDuplicates(nums).length;\\n    \\n    // Otherwise we find any values with a diff of k\\n    // Note: you can find this by adding or subtracting by k, no need to do both\\n    uniques.forEach(val => {\\n        if (uniques.has(val+k)) {\\n            pairCount++;\\n        }\\n    })\\n    return pairCount;\\n};\\n\\n// Utility method to find duplicate values in an array and return those values, once for each pair\\nvar findDuplicates = (nums) => {\\n\\tlet result = [];\\n\\tnums.forEach((num, index) => {\\n\\t\\tif (nums.indexOf(num, index + 1) > -1) {\\n            if (result.indexOf(num) === -1) {\\n                result.push(num);\\n            }\\n        }\\n    })\\n    return result;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar findPairs = function(nums, k) {\\n    let pairCount = 0;\\n    let uniques = new Set(nums);\\n    \\n    // Something can\\'t have a negative difference - diff is an absolute value \\n    if (k < 0) return 0;\\n    \\n    // If k is zero, we are basically finding which elements in nums are duplicates\\n    if (k === 0) return findDuplicates(nums).length;\\n    \\n    // Otherwise we find any values with a diff of k\\n    // Note: you can find this by adding or subtracting by k, no need to do both\\n    uniques.forEach(val => {\\n        if (uniques.has(val+k)) {\\n            pairCount++;\\n        }\\n    })\\n    return pairCount;\\n};\\n\\n// Utility method to find duplicate values in an array and return those values, once for each pair\\nvar findDuplicates = (nums) => {\\n\\tlet result = [];\\n\\tnums.forEach((num, index) => {\\n\\t\\tif (nums.indexOf(num, index + 1) > -1) {\\n            if (result.indexOf(num) === -1) {\\n                result.push(num);\\n            }\\n        }\\n    })\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 246361,
                "title": "c-clean-easy-to-follow-two-pointers-o-1-space-soln",
                "content": "The input array is sorted & two pointers are maintained; the left pointer is incremented if the diff > k, the right pointer is incremented if the diff < k and both if diff == k. \\n\\n```\\n   int findPairs(vector<int>& nums, int k) {\\n        if (nums.empty() || k < 0) {\\n            return 0;\\n        }\\n        \\n        std::sort(nums.begin(), nums.end());\\n        \\n        int p1 = 0;            // points to first member of the pair\\n        int p2 = p1 + 1;       // points to second member of the pair\\n        int result = 0;\\n\\t\\t\\n        while (p1 < nums.size() && p2 < nums.size()) {\\n            if (p1 == p2) {\\n                p2++;\\n                continue;\\n            }\\n            if (p1 > 0 && nums[p1] == nums[p1-1]) {\\n                // to avoid dupes\\n                p1++;\\n                continue;\\n            }\\n            auto diff = std::abs(nums[p1] - nums[p2]);\\n           \\n\\t\\t   if (diff == k) {\\n                result++;\\n                p1++;\\n                p2++;\\n            } else if (diff < k) {\\n                p2++;\\n            } else {\\n                p1++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   int findPairs(vector<int>& nums, int k) {\\n        if (nums.empty() || k < 0) {\\n            return 0;\\n        }\\n        \\n        std::sort(nums.begin(), nums.end());\\n        \\n        int p1 = 0;            // points to first member of the pair\\n        int p2 = p1 + 1;       // points to second member of the pair\\n        int result = 0;\\n\\t\\t\\n        while (p1 < nums.size() && p2 < nums.size()) {\\n            if (p1 == p2) {\\n                p2++;\\n                continue;\\n            }\\n            if (p1 > 0 && nums[p1] == nums[p1-1]) {\\n                // to avoid dupes\\n                p1++;\\n                continue;\\n            }\\n            auto diff = std::abs(nums[p1] - nums[p2]);\\n           \\n\\t\\t   if (diff == k) {\\n                result++;\\n                p1++;\\n                p2++;\\n            } else if (diff < k) {\\n                p2++;\\n            } else {\\n                p1++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 144919,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if k < 0:\\n            return 0\\n        res = 0\\n        counter = collections.Counter(nums)\\n        for key in counter:\\n            if k != 0:\\n                if key - k in counter:\\n                    res += 1\\n            else:\\n                if counter[key] > 1:\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if k < 0:\\n            return 0\\n        res = 0\\n        counter = collections.Counter(nums)\\n        for key in counter:\\n            if k != 0:\\n                if key - k in counter:\\n                    res += 1\\n            else:\\n                if counter[key] > 1:\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100172,
                "title": "python-solution-using-dictionary",
                "content": "```\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        count = []\\n        dict = {}\\n        for i in xrange(len(nums)):\\n            if nums[i] in dict:\\n                count.append((dict[nums[i]],nums[i]))\\n            dict[nums[i]+k] = nums[i]\\n        return len(set(count))\\n\\n````",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        count = []\\n        dict = {}\\n        for i in xrange(len(nums)):\\n            if nums[i] in dict:\\n                count.append((dict[nums[i]],nums[i]))\\n            dict[nums[i]+k] = nums[i]\\n        return len(set(count))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592588,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        for(int x: nums) mp[x]++;\\n        int ans = 0;\\n        for(auto x: mp) {\\n            if (k == 0) {    \\n                if(x.second > 1) ans++;\\n            }\\n            else if (mp.find(x.first + k) != mp.end()) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        for(int x: nums) mp[x]++;\\n        int ans = 0;\\n        for(auto x: mp) {\\n            if (k == 0) {    \\n                if(x.second > 1) ans++;\\n            }\\n            else if (mp.find(x.first + k) != mp.end()) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472579,
                "title": "easiest-way-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==0 || nums[i]!=nums[i-1]){\\n                for(int j=i+1;j<nums.length;j++){\\n                    if(Math.abs(nums[i]-nums[j])==k){\\n                        count++;\\n                        break;\\n                     \\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==0 || nums[i]!=nums[i-1]){\\n                for(int j=i+1;j<nums.length;j++){\\n                    if(Math.abs(nums[i]-nums[j])==k){\\n                        count++;\\n                        break;\\n                     \\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434673,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> set = new HashSet<>();\\n        Set<Integer> s = new HashSet<>();\\n\\n        for(int num : nums) {\\n            if(s.contains(num - k) || s.contains(num + k)) {\\n                set.add(new ArrayList<>(Arrays.asList(num, num - k)));\\n            } \\n            s.add(num);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> set = new HashSet<>();\\n        Set<Integer> s = new HashSet<>();\\n\\n        for(int num : nums) {\\n            if(s.contains(num - k) || s.contains(num + k)) {\\n                set.add(new ArrayList<>(Arrays.asList(num, num - k)));\\n            } \\n            s.add(num);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341162,
                "title": "easy-and-short-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n      unordered_map<int,int> m;\\n        for(auto it: nums)m[it]++;\\n        if(k!=0)\\n        {\\n            for(auto it: m)\\n            {\\n                if(m.find(it.first+k)!=m.end())\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(auto it: m)\\n            {\\n                if(it.second>1)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n      unordered_map<int,int> m;\\n        for(auto it: nums)m[it]++;\\n        if(k!=0)\\n        {\\n            for(auto it: m)\\n            {\\n                if(m.find(it.first+k)!=m.end())\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(auto it: m)\\n            {\\n                if(it.second>1)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270120,
                "title": "easy-c-solution-using-binary-search",
                "content": "\\n\\n# Code\\n```\\n//TC=O(nlogn)\\nclass Solution {\\npublic:\\nint search(vector<int>& nums,int t,int s){\\n    int e=nums.size()-1;\\n    while(s<=e){\\n        int mid=s+(e-s)/2;\\n        if(nums[mid]==t)\\n        return mid;\\n        else if(t>nums[mid])\\n        s=mid+1;\\n        else\\n        e=mid-1;\\n    }\\n    return -1;\\n}\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        set<pair<int,int>> ans;\\n        int i=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(search(nums,nums[i]+k,i+1)!=-1)\\n            ans.insert({nums[i],nums[i]+k});\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//TC=O(nlogn)\\nclass Solution {\\npublic:\\nint search(vector<int>& nums,int t,int s){\\n    int e=nums.size()-1;\\n    while(s<=e){\\n        int mid=s+(e-s)/2;\\n        if(nums[mid]==t)\\n        return mid;\\n        else if(t>nums[mid])\\n        s=mid+1;\\n        else\\n        e=mid-1;\\n    }\\n    return -1;\\n}\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        set<pair<int,int>> ans;\\n        int i=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(search(nums,nums[i]+k,i+1)!=-1)\\n            ans.insert({nums[i],nums[i]+k});\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270063,
                "title": "easy-c-solution-two-pointer-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        set<pair<int,int>> ans;\\n        int i=0,j=1;\\n        while(j<nums.size()){\\n            int diff=nums[j]-nums[i];\\n            if(diff==k)\\n            {\\n                ans.insert({nums[i],nums[j]});\\n                i++;j++;\\n            }\\n            else if(diff>k)\\n            i++;\\n            else\\n            j++;\\n            if(i==j)\\n            j++;\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        set<pair<int,int>> ans;\\n        int i=0,j=1;\\n        while(j<nums.size()){\\n            int diff=nums[j]-nums[i];\\n            if(diff==k)\\n            {\\n                ans.insert({nums[i],nums[j]});\\n                i++;j++;\\n            }\\n            else if(diff>k)\\n            i++;\\n            else\\n            j++;\\n            if(i==j)\\n            j++;\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736308,
                "title": "easiest-c-approach-using-hashmaps",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int findPairs(vector<int>& nums, int k) \\n    {\\n        int count=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;   //duplicates dont matters;\\n        }\\n        if(k==0)\\n        {\\n            int count=0;\\n            for(auto it=mp.begin();it!=mp.end();it++)\\n            {\\n                if(it->second>=2)\\n                {\\n                    count++;\\n                }\\n            }\\n            return count;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            int num = it->first;\\n            if(mp.find(num+k)!=mp.end())\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n//nums==  3 1 4 1 5   --- > 1 1 3 4 5\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int findPairs(vector<int>& nums, int k) \\n    {\\n        int count=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;   //duplicates dont matters;\\n        }\\n        if(k==0)\\n        {\\n            int count=0;\\n            for(auto it=mp.begin();it!=mp.end();it++)\\n            {\\n                if(it->second>=2)\\n                {\\n                    count++;\\n                }\\n            }\\n            return count;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            int num = it->first;\\n            if(mp.find(num+k)!=mp.end())\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n//nums==  3 1 4 1 5   --- > 1 1 3 4 5\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664398,
                "title": "easiest-c-approach-using-hashmaps",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int>hash;\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            hash[nums[i]]++;\\n        }\\n        for(auto it=hash.begin();it!=hash.end();it++){\\n            if(k==0){\\n                if(it->second>=2)\\n                    cnt++;\\n            }          \\n            else if(hash.find(it->first+k)!=hash.end())\\n                cnt++;\\n        }\\n        return cnt;\\n            \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int>hash;\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            hash[nums[i]]++;\\n        }\\n        for(auto it=hash.begin();it!=hash.end();it++){\\n            if(k==0){\\n                if(it->second>=2)\\n                    cnt++;\\n            }          \\n            else if(hash.find(it->first+k)!=hash.end())\\n                cnt++;\\n        }\\n        return cnt;\\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349814,
                "title": "c-hashmap-two-pointer-very-easy-code-80-faster",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        map<int,int> m;\\n        for(auto x:nums)\\n            m[x]++;\\n        \\n        vector<int> v;\\n        int sum=0;\\n        for(auto x:m)\\n        {\\n            v.push_back(x.first);// vector v has unique(nums) in sorted order;\\n            if(x.second>1)// counting for k==0\\n                sum++;\\n        }\\n        if(k==0)\\n            return sum;\\n        \\n        int res=0;\\n        int i=0,j=1;\\n        while(j<v.size())\\n        {\\n            if(v[j]-v[i] < k)\\n                j++;\\n            else if(v[j]-v[i] > k)\\n                i++;\\n            else\\n            {\\n                i++;\\n                j++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        map<int,int> m;\\n        for(auto x:nums)\\n            m[x]++;\\n        \\n        vector<int> v;\\n        int sum=0;\\n        for(auto x:m)\\n        {\\n            v.push_back(x.first);// vector v has unique(nums) in sorted order;\\n            if(x.second>1)// counting for k==0\\n                sum++;\\n        }\\n        if(k==0)\\n            return sum;\\n        \\n        int res=0;\\n        int i=0,j=1;\\n        while(j<v.size())\\n        {\\n            if(v[j]-v[i] < k)\\n                j++;\\n            else if(v[j]-v[i] > k)\\n                i++;\\n            else\\n            {\\n                i++;\\n                j++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957431,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int i = 0;\\n        int j = 1;\\n        int ans = 0;\\n        while(j<n){\\n            if(nums[j]-nums[i] <= k){\\n                if (nums[j]-nums[i] == k) ans++;\\n                do {\\n                   j++;\\n               } while(j < n && nums[j] == nums[j-1]);\\n            }\\n           else {\\n               do {\\n                   i++;\\n                   if (i == j) j++;\\n               } while(i < n && nums[i] == nums[i-1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int i = 0;\\n        int j = 1;\\n        int ans = 0;\\n        while(j<n){\\n            if(nums[j]-nums[i] <= k){\\n                if (nums[j]-nums[i] == k) ans++;\\n                do {\\n                   j++;\\n               } while(j < n && nums[j] == nums[j-1]);\\n            }\\n           else {\\n               do {\\n                   i++;\\n                   if (i == j) j++;\\n               } while(i < n && nums[i] == nums[i-1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787795,
                "title": "c-binary-search-12ms-97-o-nlogn-12mb-o-1-88",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int res = 0;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i = 0; i < n; ++i) {\\n            if(i-1 >= 0 && nums[i] == nums[i - 1]) continue;\\n            int x = nums[i] <= 0 ? nums[i] + k: abs(nums[i]+k);            \\n            if(binary_search(nums.begin() + i+1, nums.end(), x)) res++;\\n        }\\n        \\n        return res;        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int res = 0;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i = 0; i < n; ++i) {\\n            if(i-1 >= 0 && nums[i] == nums[i - 1]) continue;\\n            int x = nums[i] <= 0 ? nums[i] + k: abs(nums[i]+k);            \\n            if(binary_search(nums.begin() + i+1, nums.end(), x)) res++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1758819,
                "title": "python-o-n-using-counter",
                "content": "**Thought-Process:** The problem is all about search. Hash table is the first approach that comes in the mind when you see searching.  I took counter because, k can be zero, so you want to know that which element occurs more than once. I just see element + k to avoid repetition by limiting my search in unidirectional. \\n\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        c = collections.Counter(nums)\\n        ans = 0\\n        if k == 0:\\n            for e in c:\\n                if c[e] > 1:\\n                    ans += 1\\n        else:\\n            for e in c:\\n                if e+k in c:\\n                    ans += 1\\n        return ans\\n```\\n\\nNote: I am new in competitve programming. I do mistakes. If you have more insights than me, it would be better if you drop your idea in a comment. You can also ask me a question regarding this code, I would be more than happy to help! Happy coding.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        c = collections.Counter(nums)\\n        ans = 0\\n        if k == 0:\\n            for e in c:\\n                if c[e] > 1:\\n                    ans += 1\\n        else:\\n            for e in c:\\n                if e+k in c:\\n                    ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758777,
                "title": "c-simple-hashmap-solution-o-n",
                "content": "class Solution {\\npublic:\\n*     int findPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int>mp;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n           mp[nums[i]]++;\\n        }\\n         for(auto it:mp){\\n             if(k==0){\\n                if(it.second>=2){\\n                 cnt++;\\n               }\\n             }\\n             else if(k>0){\\n                 int rem=it.first+k;\\n                 if(mp.find(rem)!=mp.end()){\\n                     cnt++;\\n                 }\\n             }\\n         }\\n        \\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n*     int findPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int>mp;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n           mp[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1758446,
                "title": "python-o-n-solution-faster-than-99-88",
                "content": "\\'\\'\\'\\n\\n\\tdef findPairs(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        if k == 0:\\n            s = set()\\n            res_set = set()\\n            for n in nums:\\n                if n in s and n not in res_set:\\n                    res += 1\\n                    res_set.add(n)\\n                else:\\n                    s.add(n)\\n            return res\\n        \\n        s = set(nums)\\n        for n in s:\\n            if n+k in s:\\n                res+=1\\n        return res\\n    \\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "\\'\\'\\'\\n\\n\\tdef findPairs(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        if k == 0:\\n            s = set()\\n            res_set = set()\\n            for n in nums:\\n                if n in s and n not in res_set:\\n                    res += 1\\n                    res_set.add(n)\\n                else:\\n                    s.add(n)\\n            return res\\n        \\n        s = set(nums)\\n        for n in s:\\n            if n+k in s:\\n                res+=1\\n        return res\\n    \\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 1758296,
                "title": "c-hashmap-easy-understanding",
                "content": "**C++**\\n```\\nint findPairs(vector<int>& nums, int k) {\\n        //create a map to store the freq of all unique nums\\n        unordered_map<int,int> mp;\\n        for(auto n: nums) mp[n]++;\\n        \\n        int ans=0;\\n        \\n        for(auto N : mp){\\n            //if (k==0), for every N in map, check if count[N] > 1\\n            //if (k!=0), find if N + k,exists or not\\n            if( (k==0 && N.second > 1) ||\\n                (k!=0 && mp.count(N.first + k) > 0)){\\n                ans ++;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n**Please Upvote, If you find this solution helpful!**",
                "solutionTags": [],
                "code": "```\\nint findPairs(vector<int>& nums, int k) {\\n        //create a map to store the freq of all unique nums\\n        unordered_map<int,int> mp;\\n        for(auto n: nums) mp[n]++;\\n        \\n        int ans=0;\\n        \\n        for(auto N : mp){\\n            //if (k==0), for every N in map, check if count[N] > 1\\n            //if (k!=0), find if N + k,exists or not\\n            if( (k==0 && N.second > 1) ||\\n                (k!=0 && mp.count(N.first + k) > 0)){\\n                ans ++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1758086,
                "title": "easy-c-solution-with-map-and-set",
                "content": "```\\nint findPairs(vector<int>& nums, int k) {\\n        map<int ,int> mp;\\n        set<pair<int, int>> st;\\n        \\n        int size = nums.size();\\n        for(int i=0; i<size; i++){\\n                if(mp.count(nums[i]+k))\\n                    st.insert({nums[i], nums[i]+k});\\n                if(mp.count(nums[i]-k))\\n                     st.insert({nums[i]-k, nums[i]});\\n                mp[nums[i]]++;\\n        }\\n        \\n        return st.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findPairs(vector<int>& nums, int k) {\\n        map<int ,int> mp;\\n        set<pair<int, int>> st;\\n        \\n        int size = nums.size();\\n        for(int i=0; i<size; i++){\\n                if(mp.count(nums[i]+k))\\n                    st.insert({nums[i], nums[i]+k});\\n                if(mp.count(nums[i]-k))\\n                     st.insert({nums[i]-k, nums[i]});\\n                mp[nums[i]]++;\\n        }\\n        \\n        return st.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757876,
                "title": "java-easy-solution-hashmap",
                "content": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int pairsCount = 0;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i],0) + 1);\\n        }\\n        \\n        for(Integer key: map.keySet()) {\\n            \\n            if(k == 0 && map.get(key) > 1)\\n                pairsCount++;\\n            else if(k > 0 && map.containsKey(key-k))\\n                pairsCount++;\\n        }\\n     \\n        return pairsCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int pairsCount = 0;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i],0) + 1);\\n        }\\n        \\n        for(Integer key: map.keySet()) {\\n            \\n            if(k == 0 && map.get(key) > 1)\\n                pairsCount++;\\n            else if(k > 0 && map.containsKey(key-k))\\n                pairsCount++;\\n        }\\n     \\n        return pairsCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757697,
                "title": "k-diff-pairs-in-an-array-solution-java",
                "content": "class Solution {\\n  public int findPairs(int[] nums, int k) {\\n    int ans = 0;\\n    Map<Integer, Integer> numToIndex = new HashMap<>();\\n\\n    for (int i = 0; i < nums.length; ++i)\\n      numToIndex.put(nums[i], i);\\n\\n    for (int i = 0; i < nums.length; ++i) {\\n      final int target = nums[i] + k;\\n      if (numToIndex.containsKey(target) && numToIndex.get(target) != i) {\\n        ++ans;\\n        numToIndex.remove(target);\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n  public int findPairs(int[] nums, int k) {\\n    int ans = 0;\\n    Map<Integer, Integer> numToIndex = new HashMap<>();\\n\\n    for (int i = 0; i < nums.length; ++i)\\n      numToIndex.put(nums[i], i);\\n\\n    for (int i = 0; i < nums.length; ++i) {\\n      final int target = nums[i] + k;\\n      if (numToIndex.containsKey(target) && numToIndex.get(target) != i) {\\n        ++ans;\\n        numToIndex.remove(target);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1757628,
                "title": "python-explanation-hash-table-counter",
                "content": "The intuition/approach behind this solution involves simple **mathematics**. \\n\\nWe create a hash table of the elements of nums, using the Counter module. If the num of pairs to be sought is zero, we expect atleast an element to occur once, else we search for the same in the list including the element and its immediate k neighbors.\\n\\n```\\nclass Solution(object):  \\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        c=Counter(nums)\\n        pairs=0\\n        if k==0:\\n            for key,value in c.items():\\n                if value>1:\\n                    pairs+=1\\n        else:\\n            for key,value in c.items():\\n                if key+k in c:\\n                    pairs+=1\\n        return pairs\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):  \\n    def findPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        c=Counter(nums)\\n        pairs=0\\n        if k==0:\\n            for key,value in c.items():\\n                if value>1:\\n                    pairs+=1\\n        else:\\n            for key,value in c.items():\\n                if key+k in c:\\n                    pairs+=1\\n        return pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757348,
                "title": "simple-java-solution-with-explaination",
                "content": "we want to found pairs which follow below equation ->\\na-b=k OR it can be written as a=k+b;\\nIt is also mentioned to not consider duplicate pairs.\\ntake counter to hold answer.\\ntake map to store element as key and frequency as value. why we need frequency we will come back to it later.\\nloop and prepare map with required data.\\nnow if we iterate over map again instead of array we will be iterating only unique elements.\\nnow we need to check if map.containsKey(element+k) as entry. if it is true increase counter.\\nnow there is one special case where k=0. in such case, same element should be present atleast twice, then only we will have pair. so if k==0 check map.get(element)>1\\n```\\npublic int findPairs(int[] nums, int k) {\\n        int c=0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int x:nums) {\\n            map.put(x,map.getOrDefault(x,0)+1);\\n        }\\n        for(int x:map.keySet()) {\\n            Integer val = map.getOrDefault(x+k,0);\\n            if((k==0&&val>1)||(k>0 &&val>0)) {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findPairs(int[] nums, int k) {\\n        int c=0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int x:nums) {\\n            map.put(x,map.getOrDefault(x,0)+1);\\n        }\\n        for(int x:map.keySet()) {\\n            Integer val = map.getOrDefault(x+k,0);\\n            if((k==0&&val>1)||(k>0 &&val>0)) {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757274,
                "title": "c-o-n-hashmap-with-explanation",
                "content": "/***Daily Challenge:-09/02/2022.\\nApproach:- We are using Concept of Hashing.\\n-->step1:-Store all the frequency of elements in a Unordered_map.**\\n\\n**Now ,Understand the Concept:-\\n\\n**We are given abs(nums[i]-nums[j])==k\\n=>nums[i]=nums[j]+k ;  In this case we have to find nums[i] as required value\\n\\n**or =>nums[j]=nums[i]+k  ; In this case we have to find nums[j] as required value.\\nSo,in the map if we find any of the requird Value we, will increase our Count.**\\n\\n\\n\\n**-->Step2:-Traverse throughOut the map.\\n   ** -->Drecrement the frequency Count of a paticulat element.(Because it will avoid he case ,when finding element will equal to that element.)**\\n    **-->So, if we find our require element, and if its frquency count >=1,we increase our count. ** ***/\\n\\t\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int count=0;\\n        \\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        \\n        for(auto x:mp)\\n        {\\n                mp[x.first]--;\\n            int flag=x.first+k;\\n            \\n            if(mp.find(flag)!=mp.end())\\n            {\\n                if(mp[flag]>=1)\\n                    count++;\\n            }\\n                \\n            mp[x.first]++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int count=0;\\n        \\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1757271,
                "title": "c-binary-search-and-hashmap-easy-to-understand",
                "content": "**Please upvote if you find helpful:)**\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<nums.size(); i++)\\n            mp[nums[i]]++;\\n        int c=0, i=0;\\n        if(k==0)\\n        {\\n            for(auto it:mp)\\n                if(it.second>1)\\n                    c++;\\n            return c;\\n        }\\n        sort(nums.begin(), nums.end());\\n        while(i<nums.size())\\n        {\\n            while(i>0 && nums[i]==nums[i-1])\\n                i++;\\n            int find=k+nums[i];\\n            if(binary_search(nums.begin(), nums.end(), find))\\n            {\\n                int index=lower_bound(nums.begin(), nums.end(), find)-nums.begin();\\n                if(index==i)\\n                {\\n                    if(mp[nums[i]]>0)\\n                        c++;\\n                }\\n                else\\n                    c++;\\n            }\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<nums.size(); i++)\\n            mp[nums[i]]++;\\n        int c=0, i=0;\\n        if(k==0)\\n        {\\n            for(auto it:mp)\\n                if(it.second>1)\\n                    c++;\\n            return c;\\n        }\\n        sort(nums.begin(), nums.end());\\n        while(i<nums.size())\\n        {\\n            while(i>0 && nums[i]==nums[i-1])\\n                i++;\\n            int find=k+nums[i];\\n            if(binary_search(nums.begin(), nums.end(), find))\\n            {\\n                int index=lower_bound(nums.begin(), nums.end(), find)-nums.begin();\\n                if(index==i)\\n                {\\n                    if(mp[nums[i]]>0)\\n                        c++;\\n                }\\n                else\\n                    c++;\\n            }\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757245,
                "title": "c-two-versions-dictionary-and-sorting-with-hashset",
                "content": "This was actually asked to me in an interview in a top product based company as an internal candidate.\\n\\n1. This is an O(n) solution converted to C#, shared by others in Java.\\nLogic is very simple:\\nBuild a dictionary (or map) with unique numbers in the array and store their count.\\nEg. for the  input: `nums = [3,1,4,1,5] and k = 2`\\n3-1, there is only one 3\\n1-2, there are two 1s\\n4-1, there is only one 4\\n5-1, there is only one 5\\n\\n\\tNext loop through each key-value pair in this map and see if there exists a key with current key + k (equivalent to Math.Abs(current key - target key) == k)\\n\\n\\tAlso, there is an edge case, for k==0. If k in the input was 0, then just check if the there were duplicate keys in the dictionary/map. This can be done just by checking the count of current key > 1. In above example, if k was 0, then - whenever we are at the number 1 we can see that there were two occurence of 1 in the array and thus we have a pair.\\n\\n```\\npublic int FindPairsWithDictionary(int[] nums, int k) {\\n        var pairsCount = 0 ;\\n        var map = new Dictionary<int, int>();\\n        foreach(var num in nums)\\n        {\\n            if (!map.ContainsKey(num))\\n            {\\n                map.Add(num, 0);\\n            }\\n            map[num]++;\\n        }\\n        \\n        foreach(var pair in map)\\n        {\\n            if (k > 0 && map.ContainsKey(pair.Key + k)) {\\n                pairsCount ++;\\n            }\\n            // special case\\n            if (k == 0 && pair.Value > 1)\\n            {\\n                pairsCount ++;\\n            }\\n        }\\n        \\n        return pairsCount;\\n    }\\n    \\n```\\n\\n2. This is also a C# version for code shared by other people in the discussion. This one looks very simple, but has the overhead of sorting the array, going over the array multiple times. So, the time complexity is really high.\\n```\\npublic int FindPairsWithSorting(int[] nums, int k) {\\n        var count = 0;\\n        var n = nums.Length;\\n        var result = new HashSet<int>();\\n        Array.Sort(nums);\\n        for (int i=0; i<n-1; i++) {\\n            var firstNumber = nums[i];\\n            for (int j=i+1; j<n; j++) \\n            {\\n                if (nums[j] - firstNumber >  k) {\\n                    break;\\n                }\\n                \\n                if (nums[j] - firstNumber == k)\\n                {\\n                    if (!result.Contains(firstNumber) || !result.Contains(nums[j])) {\\n                        count++;\\n                    }\\n                    result.Add(firstNumber);\\n                    result.Add(nums[j]);                    \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int FindPairsWithDictionary(int[] nums, int k) {\\n        var pairsCount = 0 ;\\n        var map = new Dictionary<int, int>();\\n        foreach(var num in nums)\\n        {\\n            if (!map.ContainsKey(num))\\n            {\\n                map.Add(num, 0);\\n            }\\n            map[num]++;\\n        }\\n        \\n        foreach(var pair in map)\\n        {\\n            if (k > 0 && map.ContainsKey(pair.Key + k)) {\\n                pairsCount ++;\\n            }\\n            // special case\\n            if (k == 0 && pair.Value > 1)\\n            {\\n                pairsCount ++;\\n            }\\n        }\\n        \\n        return pairsCount;\\n    }\\n    \\n```\n```\\npublic int FindPairsWithSorting(int[] nums, int k) {\\n        var count = 0;\\n        var n = nums.Length;\\n        var result = new HashSet<int>();\\n        Array.Sort(nums);\\n        for (int i=0; i<n-1; i++) {\\n            var firstNumber = nums[i];\\n            for (int j=i+1; j<n; j++) \\n            {\\n                if (nums[j] - firstNumber >  k) {\\n                    break;\\n                }\\n                \\n                if (nums[j] - firstNumber == k)\\n                {\\n                    if (!result.Contains(firstNumber) || !result.Contains(nums[j])) {\\n                        count++;\\n                    }\\n                    result.Add(firstNumber);\\n                    result.Add(nums[j]);                    \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757151,
                "title": "my-java-code",
                "content": "```\\nclass Solution {\\n     public int findPairs(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i: nums) map.put(i,map.getOrDefault(i,0)+1);\\n        if(k==0) return (int)map.keySet().stream().filter(key->map.get(key)>1).count();\\n        return (int)map.keySet().stream().filter(key->map.containsKey(key+k)).count();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public int findPairs(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i: nums) map.put(i,map.getOrDefault(i,0)+1);\\n        if(k==0) return (int)map.keySet().stream().filter(key->map.get(key)>1).count();\\n        return (int)map.keySet().stream().filter(key->map.containsKey(key+k)).count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757137,
                "title": "c-solution-8-ms-faster-than-98-two-pointer-approach",
                "content": "```\\nint findPairs(vector<int>& nums, int k) {\\n        \\n        int low= 0, high = 1;\\n        int count = 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n  \\n        while(low<nums.size() && high<nums.size())\\n        {\\n            int diff=nums[high]-nums[low];\\n            if(diff==k)\\n            {\\n                count++;\\n                high++;\\n                \\n                //to avoid duplicates\\n                \\n                while(high<nums.size() && nums[high]==nums[high-1])\\n                    high++;        \\n                \\n            }\\n            else if(diff<k)\\n                high++;\\n            else if(diff>k)\\n            {\\n                low++;\\n                if(low==high)\\n                    high++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint findPairs(vector<int>& nums, int k) {\\n        \\n        int low= 0, high = 1;\\n        int count = 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n  \\n        while(low<nums.size() && high<nums.size())\\n        {\\n            int diff=nums[high]-nums[low];\\n            if(diff==k)\\n            {\\n                count++;\\n                high++;\\n                \\n                //to avoid duplicates\\n                \\n                while(high<nums.size() && nums[high]==nums[high-1])\\n                    high++;        \\n                \\n            }\\n            else if(diff<k)\\n                high++;\\n            else if(diff>k)\\n            {\\n                low++;\\n                if(low==high)\\n                    high++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757047,
                "title": "python3-runtime-58-ms-faster-than-99-40-memory-15-6-mb-less-than-89-25",
                "content": "```\\nclass Solution:\\n\\tdef findPairs(self, nums: List[int], k: int) -> int:\\n\\t\\tans,check = 0,{}\\n\\t\\tfor i in nums:\\n\\t\\t\\tif i not in check:\\n\\t\\t\\t\\tcheck[i]=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcheck[i]+=1\\n\\t\\tif k>0:\\n\\t\\t\\tfor j in check:\\n\\t\\t\\t\\tif j+k in check.keys():\\n\\t\\t\\t\\t\\tans+=1\\n\\t\\telse:\\n\\t\\t\\tfor j in check:\\n\\t\\t\\t\\tif check[j]>1:\\n\\t\\t\\t\\t\\tans+=1\\n\\t\\treturn ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\tdef findPairs(self, nums: List[int], k: int) -> int:\\n\\t\\tans,check = 0,{}\\n\\t\\tfor i in nums:\\n\\t\\t\\tif i not in check:\\n\\t\\t\\t\\tcheck[i]=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcheck[i]+=1\\n\\t\\tif k>0:\\n\\t\\t\\tfor j in check:\\n\\t\\t\\t\\tif j+k in check.keys():\\n\\t\\t\\t\\t\\tans+=1\\n\\t\\telse:\\n\\t\\t\\tfor j in check:\\n\\t\\t\\t\\tif check[j]>1:\\n\\t\\t\\t\\t\\tans+=1\\n\\t\\treturn ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704262,
                "title": "c-java-two-pointers-approach",
                "content": "Space complexity - `O(1)`\\nTime complexity - `O(n*log(n))`\\n\\n##### C++\\n```\\nint findPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i = 0, j = 1, ans = 0;\\n        while(i<n && j<n)\\n        {\\n            if(i==j)\\n            { j++; continue;}\\n            int x = nums[i], y = nums[j];\\n            if(abs(nums[i]-nums[j])==k)\\n            {\\n                ans++; i++; j++;\\n                while(i<n && x == nums[i]) i++;\\n                while(j<n && y == nums[j]) j++;\\n            }\\n            else if(abs(nums[i]-nums[j])<k)\\n            {\\n                j++;\\n                while(j<n && y == nums[j]) j++;\\n            }\\n            else\\n            {\\n                i++;\\n                while(i<n && x == nums[i]) i++;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n##### Java\\n```\\npublic int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int i = 0, j = 1, ans = 0;\\n        while(i<n && j<n)\\n        {\\n            if(i==j)\\n            { j++; continue;}\\n            int x = nums[i], y = nums[j];\\n            if(Math.abs(nums[i]-nums[j])==k)\\n            {\\n                ans++; i++; j++;\\n                while(i<n && x==nums[i]) i++;\\n                while(j<n && y == nums[j]) j++;\\n            }\\n            else if(Math.abs(nums[i]-nums[j])<k)\\n            {\\n                j++;\\n                while(j<n && y == nums[j]) j++;\\n            }\\n            else\\n            {\\n                i++;\\n                while(i<n && x == nums[i]) i++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nint findPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int i = 0, j = 1, ans = 0;\\n        while(i<n && j<n)\\n        {\\n            if(i==j)\\n            { j++; continue;}\\n            int x = nums[i], y = nums[j];\\n            if(abs(nums[i]-nums[j])==k)\\n            {\\n                ans++; i++; j++;\\n                while(i<n && x == nums[i]) i++;\\n                while(j<n && y == nums[j]) j++;\\n            }\\n            else if(abs(nums[i]-nums[j])<k)\\n            {\\n                j++;\\n                while(j<n && y == nums[j]) j++;\\n            }\\n            else\\n            {\\n                i++;\\n                while(i<n && x == nums[i]) i++;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\npublic int findPairs(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int i = 0, j = 1, ans = 0;\\n        while(i<n && j<n)\\n        {\\n            if(i==j)\\n            { j++; continue;}\\n            int x = nums[i], y = nums[j];\\n            if(Math.abs(nums[i]-nums[j])==k)\\n            {\\n                ans++; i++; j++;\\n                while(i<n && x==nums[i]) i++;\\n                while(j<n && y == nums[j]) j++;\\n            }\\n            else if(Math.abs(nums[i]-nums[j])<k)\\n            {\\n                j++;\\n                while(j<n && y == nums[j]) j++;\\n            }\\n            else\\n            {\\n                i++;\\n                while(i<n && x == nums[i]) i++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1688321,
                "title": "tanmay-taneja-c",
                "content": "``` \\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        map <int,int> m;\\n        for(int i=0; i<nums.size(); i++){\\n            m[nums[i]]++;\\n        }\\n        for(auto it: m){\\n            if(k==0){\\n                if(m[it.first]>1){\\n                    ans+=1;\\n                }\\n            }\\n            else if(m.find(it.first + k) != m.end()){\\n                ans+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        map <int,int> m;\\n        for(int i=0; i<nums.size(); i++){\\n            m[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1476335,
                "title": "python-solution-with-hashmap-a-different-approach",
                "content": "I have used hashmap to track each numbers occurances to check for (num + k) or (num - k) in the hashmap which has occured eariler to make a pair with diff k. The same hashmap can be counted to track if we have already visited a possible comination.\\nThis works fine except for when k == 0, for which i have added a check to allow until a particular number occurs twice, as thats when k is 0, when there are 2 occurances ateast.\\n\\nWorks 80% faster. May not be a great solution, just sharing my idea.\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        hmap = {}\\n        count = 0\\n        for i in range(len(nums)):\\n            \\'\\'\\' check in hmap if k is not zero if we have already visited that pair starting with that\\n                if k == 0 its allowed to add either of the case (+k or -k, ive chose to use nums[i]-k here) \\n                untill its count is 2 as when k == 0, we might need the same number twice.  \\'\\'\\'\\n            \\n            if (k!= 0 and nums[i] not in hmap) or (k == 0 and (nums[i] not in hmap or hmap[nums[i]] <2)): \\n                if nums[i] - k in hmap: count += 1\\n                if k!= 0 and nums[i] + k in hmap: count += 1\\n            # add to hmap for tracking visited or to check previous pair.    \\n            if nums[i] not in hmap: hmap[nums[i]] = 0 \\n            hmap[nums[i]] += 1\\n        return count\\n\\t\\t\\n\\t```\\n\\tTC: O(N)\\n\\tSC : O(N)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        hmap = {}\\n        count = 0\\n        for i in range(len(nums)):\\n            \\'\\'\\' check in hmap if k is not zero if we have already visited that pair starting with that\\n                if k == 0 its allowed to add either of the case (+k or -k, ive chose to use nums[i]-k here) \\n                untill its count is 2 as when k == 0, we might need the same number twice.  \\'\\'\\'\\n            \\n            if (k!= 0 and nums[i] not in hmap) or (k == 0 and (nums[i] not in hmap or hmap[nums[i]] <2)): \\n                if nums[i] - k in hmap: count += 1\\n                if k!= 0 and nums[i] + k in hmap: count += 1\\n            # add to hmap for tracking visited or to check previous pair.    \\n            if nums[i] not in hmap: hmap[nums[i]] = 0 \\n            hmap[nums[i]] += 1\\n        return count\\n\\t\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1453644,
                "title": "java-solution-using-hashmap",
                "content": "# We will count the frequnecy of all the elements in the array and ckeck if arr[i] + k is present in the hashmap. If present we will increment the count.\\n# if k == 0. this means same value exists in the array twice so we check if that values frequency is greater than 2 than we increment the count.\\n\\n```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n        if(k < 0)\\n            return 0;\\n        \\n        int len = nums.length;\\n        \\n        if(len < 2)\\n            return 0;\\n        \\n        int count = 0;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int num : nums)\\n            map.put(num, map.getOrDefault(num,0)+1);\\n        \\n        \\n        for(int n : map.keySet()) {\\n            if(k == 0) {\\n                if(map.get(n) >= 2) {\\n                    count++;\\n                }\\n            }\\n            else {\\n                if(map.containsKey(n + k))\\n                    count++;\\n            }\\n        }\\n            return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        \\n        if(k < 0)\\n            return 0;\\n        \\n        int len = nums.length;\\n        \\n        if(len < 2)\\n            return 0;\\n        \\n        int count = 0;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int num : nums)\\n            map.put(num, map.getOrDefault(num,0)+1);\\n        \\n        \\n        for(int n : map.keySet()) {\\n            if(k == 0) {\\n                if(map.get(n) >= 2) {\\n                    count++;\\n                }\\n            }\\n            else {\\n                if(map.containsKey(n + k))\\n                    count++;\\n            }\\n        }\\n            return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331507,
                "title": "c-easy-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        while(j<nums.size()){\\n            if(i!=j && abs(nums[i]-nums[j])==k){\\n                ans++;\\n                int ele=nums[j];\\n                while(nums[j]==ele)\\n                {\\n                    j++;\\n                    if(j>=nums.size()) return ans;\\n                }\\n            }\\n            else if(abs(nums[i]-nums[j])>k){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        while(j<nums.size()){\\n            if(i!=j && abs(nums[i]-nums[j])==k){\\n                ans++;\\n                int ele=nums[j];\\n                while(nums[j]==ele)\\n                {\\n                    j++;\\n                    if(j>=nums.size()) return ans;\\n                }\\n            }\\n            else if(abs(nums[i]-nums[j])>k){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297766,
                "title": "cpp-solution-beats-100-o-nlogn-two-pointer-approach-proof-attached",
                "content": "Hello World !!.  A two pointer based approach. Code is commented for better understanding. Hope it helps otherwise feel free to comment. \\nThanks.\\nHappy Coding.\\n```\\n     int n=nums.size();\\n\\t \\n\\t // Sort the given vector\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=1;\\n        int c=0;  // hold the final answer\\n        int prev=INT_MIN; // keeps tracks of previous element\\n        while(i<n && j<n){\\n\\t\\t\\n            if(nums[j]-nums[i] == k)\\n            {\\n                c++;\\n                prev=nums[i];  //  Whenever i is going to be incremented we should update the value of prev.\\n                i++;\\n                j++;\\n            }\\n\\t\\t\\t// if difference between values of both pointers is more than k, then increment j.\\n            else if (j<n && nums[j]-nums[i]<k  ) j++;\\n\\t\\t\\t\\n\\t\\t\\t// else increment i\\n            else{\\n                prev=nums[i]; //  Whenever i is going to be incremented we should update the value of prev.\\n                i++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Note this while loop carefully. It makes sure that value of current nums[i] is not equal to the previous one, \\n\\t\\t\\t\\t//because only unique difference pairs should be counted as per problem. So this while loop keep on moving \\n\\t\\t\\t\\t// until either i becomes equal to n or previous value is not equal to current value.\\n            while(i<n && nums[i]==prev  ) i++;\\n\\t\\t\\t\\n\\t\\t\\t// It makes sure that both i and j pointers are not pointing to same value. \\n\\t\\t\\t// This makes sure to pass the corner cases when k is 0.\\n            if(i==j) j++;\\n        }\\n        return c;\\n```\\n![image](https://assets.leetcode.com/users/images/a5baf2a4-409e-4870-bf26-de94d2b4930b_1624697454.0305192.png)\\n",
                "solutionTags": [],
                "code": "```\\n     int n=nums.size();\\n\\t \\n\\t // Sort the given vector\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=1;\\n        int c=0;  // hold the final answer\\n        int prev=INT_MIN; // keeps tracks of previous element\\n        while(i<n && j<n){\\n\\t\\t\\n            if(nums[j]-nums[i] == k)\\n            {\\n                c++;\\n                prev=nums[i];  //  Whenever i is going to be incremented we should update the value of prev.\\n                i++;\\n                j++;\\n            }\\n\\t\\t\\t// if difference between values of both pointers is more than k, then increment j.\\n            else if (j<n && nums[j]-nums[i]<k  ) j++;\\n\\t\\t\\t\\n\\t\\t\\t// else increment i\\n            else{\\n                prev=nums[i]; //  Whenever i is going to be incremented we should update the value of prev.\\n                i++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Note this while loop carefully. It makes sure that value of current nums[i] is not equal to the previous one, \\n\\t\\t\\t\\t//because only unique difference pairs should be counted as per problem. So this while loop keep on moving \\n\\t\\t\\t\\t// until either i becomes equal to n or previous value is not equal to current value.\\n            while(i<n && nums[i]==prev  ) i++;\\n\\t\\t\\t\\n\\t\\t\\t// It makes sure that both i and j pointers are not pointing to same value. \\n\\t\\t\\t// This makes sure to pass the corner cases when k is 0.\\n            if(i==j) j++;\\n        }\\n        return c;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1229829,
                "title": "one-pass-two-sets-92-speed",
                "content": "Runtime: 68 ms, faster than 92.38% of Python3 online submissions for K-diff Pairs in an Array.\\nMemory Usage: 17 MB, less than 8.57% of Python3 online submissions for K-diff Pairs in an Array.\\n```\\nclass Solution:\\n    def findPairs(self, nums, k: int) -> int:\\n        previous = {nums[0]}\\n        pairs = set()\\n        for n in nums[1:]:\\n            if n - k in previous:\\n                pairs.add((n - k, n))\\n            if n + k in previous:\\n                pairs.add((n, n + k))\\n            previous.add(n)\\n        return len(pairs)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums, k: int) -> int:\\n        previous = {nums[0]}\\n        pairs = set()\\n        for n in nums[1:]:\\n            if n - k in previous:\\n                pairs.add((n - k, n))\\n            if n + k in previous:\\n                pairs.add((n, n + k))\\n            previous.add(n)\\n        return len(pairs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225223,
                "title": "c-simple-easy-solution-two-pointer-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n       int count=0;\\n        int i=0;\\n        int j=1;\\n        while(i<n && j<n)\\n        {\\n            if(i!=j && nums[j]-nums[i]==k){\\n                while(i+1 < n && nums[i+1] == nums[i]) // to check for distinct pairs\\n                    i++;\\n                i++;\\n                while(j+1<n && nums[j+1] == nums[j]) //to check for distinct pairs\\n                    j++;\\n                j++;\\n                count++;\\n            }\\n            else if(nums[j]-nums[i]<k) j++;\\n            else i++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n       int count=0;\\n        int i=0;\\n        int j=1;\\n        while(i<n && j<n)\\n        {\\n            if(i!=j && nums[j]-nums[i]==k){\\n                while(i+1 < n && nums[i+1] == nums[i]) // to check for distinct pairs\\n                    i++;\\n                i++;\\n                while(j+1<n && nums[j+1] == nums[j]) //to check for distinct pairs\\n                    j++;\\n                j++;\\n                count++;\\n            }\\n            else if(nums[j]-nums[i]<k) j++;\\n            else i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208890,
                "title": "python-two-set-approach-time-and-space-o-n-no-sorting",
                "content": "|a-b| = k \\n=> a-b = k or a-b = -k \\n=> a+k = k or a-k = b\\n\\nSo if we have a and k, b could either be a + k or a -k, so just look for them. If found in nums and not already added to seen, ans += 1\\n```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        seen = set()\\n        num_set = set()\\n        ans = 0\\n        for i in nums:\\n            if i+k in num_set:\\n                if (i, i+k) not in seen:\\n                    ans += 1\\n                    seen.add((i, i+k))\\n                    seen.add((i+k, i))\\n            \\n            if i-k in num_set:\\n                if (i, i-k) not in seen:\\n                    ans += 1\\n                    seen.add((i, i-k))\\n                    seen.add((i-k, i))\\n            num_set.add(i)\\n                    \\n        return ans \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findPairs(self, nums: List[int], k: int) -> int:\\n        seen = set()\\n        num_set = set()\\n        ans = 0\\n        for i in nums:\\n            if i+k in num_set:\\n                if (i, i+k) not in seen:\\n                    ans += 1\\n                    seen.add((i, i+k))\\n                    seen.add((i+k, i))\\n            \\n            if i-k in num_set:\\n                if (i, i-k) not in seen:\\n                    ans += 1\\n                    seen.add((i, i-k))\\n                    seen.add((i-k, i))\\n            num_set.add(i)\\n                    \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173939,
                "title": "java-2-pointer-4ms-beats-91-t-c-o-nlogn-s-c-o-1",
                "content": "\\n    // O(nums.length) O(nums.length)\\n\\tpublic int findPairs(int[] nums, int k) {\\n\\n\\t\\tArrays.sort(nums);\\n\\t\\tint len = nums.length, left = 0, right = 1, ans = 0;\\n\\t\\tif (len == 1)\\n\\t\\t\\treturn ans;\\n\\n\\t\\twhile (left < len && right < len) {\\n\\n\\t\\t\\tif (nums[right] - nums[left] > k) {\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tif (left == right)\\n\\t\\t\\t\\t\\tright++;\\n\\t\\t\\t} else if (nums[right] - nums[left] < k)\\n\\t\\t\\t\\tright++;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright++;\\n\\t\\t\\t\\twhile (left < len && nums[left - 1] == nums[left])\\n\\t\\t\\t\\t\\tleft++;\\n\\n\\t\\t\\t\\tright = left+1;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    // O(nums.length) O(nums.length)\\n\\tpublic int findPairs(int[] nums, int k) {\\n\\n\\t\\tArrays.sort(nums);\\n\\t\\tint len = nums.length, left = 0, right = 1, ans = 0;\\n\\t\\tif (len == 1)\\n\\t\\t\\treturn ans;\\n\\n\\t\\twhile (left < len && right < len) {\\n\\n\\t\\t\\tif (nums[right] - nums[left] > k) {\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tif (left == right)\\n\\t\\t\\t\\t\\tright++;\\n\\t\\t\\t} else if (nums[right] - nums[left] < k)\\n\\t\\t\\t\\tright++;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright++;\\n\\t\\t\\t\\twhile (left < len && nums[left - 1] == nums[left])\\n\\t\\t\\t\\t\\tleft++;\\n\\n\\t\\t\\t\\tright = left+1;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1173901,
                "title": "java-hashset-6ms-t-c-o-n-s-c-o-n",
                "content": "\\n    // O(nums.length) O(nums.length)\\n\\tpublic int findPairs(int[] nums, int k) {\\n\\n\\t\\tint len = nums.length, ans = 0;\\n\\n\\t\\tif (k == 0) {\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\t\\tmap.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n\\n\\t\\t\\tIterator<Map.Entry<Integer, Integer>> iterator = map.entrySet().iterator();\\n\\t\\t\\twhile (iterator.hasNext()) {\\n\\t\\t\\t\\tMap.Entry<Integer, Integer> pair = (Map.Entry<Integer, Integer>) iterator.next();\\n\\t\\t\\t\\tint val = pair.getValue();\\n\\t\\t\\t\\tif (val >= 2)\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tHashSet<Integer> set = new HashSet<>();\\n\\t\\tset.add(nums[0]);\\n\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\n\\t\\t\\tint key1 = k + nums[i], key2 = -k + nums[i];\\n\\t\\t\\tif (set.contains(key1) && !set.contains(nums[i]))\\n\\t\\t\\t\\tans++;\\n\\t\\t\\tif (set.contains(key2) && !set.contains(nums[i]))\\n\\t\\t\\t\\tans++;\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(nums.length) O(nums.length)\\n\\tpublic int findPairs(int[] nums, int k) {\\n\\n\\t\\tint len = nums.length, ans = 0;\\n\\n\\t\\tif (k == 0) {\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\t\\tmap.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n\\n\\t\\t\\tIterator<Map.Entry<Integer, Integer>> iterator = map.entrySet().iterator();\\n\\t\\t\\twhile (iterator.hasNext()) {\\n\\t\\t\\t\\tMap.Entry<Integer, Integer> pair = (Map.Entry<Integer, Integer>) iterator.next();\\n\\t\\t\\t\\tint val = pair.getValue();\\n\\t\\t\\t\\tif (val >= 2)\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tHashSet<Integer> set = new HashSet<>();\\n\\t\\tset.add(nums[0]);\\n\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\n\\t\\t\\tint key1 = k + nums[i], key2 = -k + nums[i];\\n\\t\\t\\tif (set.contains(key1) && !set.contains(nums[i]))\\n\\t\\t\\t\\tans++;\\n\\t\\t\\tif (set.contains(key2) && !set.contains(nums[i]))\\n\\t\\t\\t\\tans++;\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1162305,
                "title": "c-solution-using-set-and-hashmap-tc-o-nlogn-and-sc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        \\n        int s = nums.size();\\n        \\n        for(int i=0;i<s;i++)\\n            mp[nums[i]] = i;\\n        \\n      \\n        int res = 0;\\n        \\n        set<pair<int,int>> st;\\n        \\n        for(int i=0;i<s;i++) {\\n            int d = nums[i]-k;\\n            \\n            if(mp.find(d)!=mp.end()  && i!=mp[d])\\n                st.insert({nums[i],d});\\n                \\n        }\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        \\n        int s = nums.size();\\n        \\n        for(int i=0;i<s;i++)\\n            mp[nums[i]] = i;\\n        \\n      \\n        int res = 0;\\n        \\n        set<pair<int,int>> st;\\n        \\n        for(int i=0;i<s;i++) {\\n            int d = nums[i]-k;\\n            \\n            if(mp.find(d)!=mp.end()  && i!=mp[d])\\n                st.insert({nums[i],d});\\n                \\n        }\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150983,
                "title": "java-hashmap-clean-solution",
                "content": "```\\nclass Solution {\\n    public int findPairs(int[] arr, int k) {\\n      Map<Integer,Integer> mp=new HashMap<>();\\n      int pairs=0;\\n      for(int val:arr){\\n        mp.put(val,mp.getOrDefault(val,0)+1);\\n      }\\n      \\n      for(int key:mp.keySet()){\\n        int val=mp.get(key);\\n        \\n        if(k>0 && mp.containsKey(key+k)) pairs++;\\n       else if(k==0 && val>1)            pairs++; //if arr=[1,1] & k=0  than pair will be {1,1}\\n      }\\n      \\n      return pairs;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] arr, int k) {\\n      Map<Integer,Integer> mp=new HashMap<>();\\n      int pairs=0;\\n      for(int val:arr){\\n        mp.put(val,mp.getOrDefault(val,0)+1);\\n      }\\n      \\n      for(int key:mp.keySet()){\\n        int val=mp.get(key);\\n        \\n        if(k>0 && mp.containsKey(key+k)) pairs++;\\n       else if(k==0 && val>1)            pairs++; //if arr=[1,1] & k=0  than pair will be {1,1}\\n      }\\n      \\n      return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090396,
                "title": "3-different-approach-c-clean-code",
                "content": "Method 1: Binary Search\\n\\nTime Complexity: O(nlogn)\\nSpace Complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int p=0;\\n        int ans=0;\\n        while(p<n){\\n            int val=nums[p]+k;\\n            bool f=binary_search(nums.begin()+p+1,nums.end(),val);\\n            if(f)\\n                ans++;\\n            int x=nums[p];\\n            while(p<n&&x==nums[p])p++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nMethod 2 :Hashing\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }\\n        int ans=0;\\n        for(auto x:mp){\\n            int val=x.first+k;\\n            if(k==0){\\n                if(x.second>1)\\n                ans++;\\n                continue;\\n            }\\n            if(mp.count(val)){\\n                ans++;\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n\\nMethod 3: Two Pointer\\nTime Complexity:  O(nlogn) //beacause of sorting\\nSpace complexity :  O(1)\\n\\n\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        if(n==1) return 0;\\n        sort(nums.begin(),nums.end());\\n        int p1=0,p2=1;\\n        int ans=0;\\n        for(int i=0;i<n&&p2<n;i++){\\n            \\n            p2=max(i+1,p2);\\n            while(p2<n&&(nums[p2]-nums[i])<k)p2++;\\n            if(p2<n&&nums[p2]-nums[i]==k)ans++;\\n            \\n            //skipping dublicates as we need unique pair\\n            while(i+1<n&&nums[i]==nums[i+1])i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int p=0;\\n        int ans=0;\\n        while(p<n){\\n            int val=nums[p]+k;\\n            bool f=binary_search(nums.begin()+p+1,nums.end(),val);\\n            if(f)\\n                ans++;\\n            int x=nums[p];\\n            while(p<n&&x==nums[p])p++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 878770,
                "title": "c-one-pass-solution-hashmap",
                "content": "One pass solution. TC 40 ms, beats 98.48% solution.\\n```\\nint findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        int res = 0;\\n        for (auto n : nums) {\\n            if (mp.find(n) == mp.end() ) {\\n                res += mp.count(n - k);\\n                res += mp.count(n + k);\\n            }\\n            else if (mp[n] == 1 && k == 0) res++; \\n            \\n            mp[n]++;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        int res = 0;\\n        for (auto n : nums) {\\n            if (mp.find(n) == mp.end() ) {\\n                res += mp.count(n - k);\\n                res += mp.count(n + k);\\n            }\\n            else if (mp[n] == 1 && k == 0) res++; \\n            \\n            mp[n]++;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877405,
                "title": "two-pointer-o-n-time-complexity-k-diff-pairs-in-an-array",
                "content": "**Explaination :**\\n\\n1. Use some kind of sorting mechanism. To sort the array. Also don\\'t include duplicates in this array.\\n2. Also store the frequency of each element in another Array.\\n3. Use two pointers (ptr1 and ptr2). And move these two according to the difference between the elements.\\n    while(untill ptr2 reaches the end of sorted array)\\n        - If difference == k  : increment ptr1 and ptr2 and sum++\\n        - if difference < k : increment ptr2\\n        - if difference >k : increment ptr1\\n        - Special case - if k==0 and difference == k and freq >1 :  increment ptr1 and ptr2 and sum++ \\n\\n**Approach :**\\n\\n**Contraints hint:**\\nFirstly, to get better understanding of how to proceed, I looked up to the contraints. And as the length of array will be always less than 10^4 . This means, we cannot use O(n^2) . We can use sorting because that would give O(nlogn) complexity, which is fair enough.\\n\\n**Examples hint:**\\nNow if we try some examples. we can think whether we need duplicate? How are duplicated causing any problem? And if we see, for the much part, it is of no use. We can ignore duplicates. Because questions asks to find **unique pairs** only. So if we have two 1s and single 3, like this : arr= [1,1,3] and k = 2;\\nthen (arr[0] , arr[2] ) and (arr[1] , arr[2]) are counted only once. And ans = 1.\\n\\nSimilarly , if arr= [1,1,3,3] and k =2;\\nStill ans = 1;\\n\\nSo, We dont need duplicates here. We can count them once. \\n\\n**Edge cases hint:**\\nOn, further trying out example, **if k= 0,**  then what are the challenges:\\nif k == 0 then the difference has to be 0. But , according to the question, in a k-diff pair : (arr[i] , arr[j]) , **i != j**\\nSo , it must be same integer but at different index in sorted array. Then we can consider it in our mighty Answer!\\nEx : arr= [1,1,2,3,4] and k = 0\\nans = 1 (arr[0] , arr[1])\\n\\nSo here we need to keep in mind the **role of duplicates, when k==0.**\\nAnd , knowing that a value freq is stricly more than 1, and k==0 , we can count it in the answer.\\n\\n*My mighty code:*\\n\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        map<int,int> mp;    //creating map with frequency as its value\\n        for(int i = 0; i<nums.size(); i++){\\n            mp[nums[i]]+=1;\\n        }\\n        int sum = 0;\\n       map<int,int>::iterator itl;   //ptr1\\n        map<int,int>::iterator itr;   //ptr2\\n        itl= mp.begin(); itr= mp.begin() ;\\n\\t\\t\\n        while(itr!=mp.end()){\\n            int f = itl->first;\\n            int s = itr -> first;\\n            if(s-f <k && s>=f){\\n                itr++;   //increment ptr2 -> increase window width\\n            }else if(s-f > k && s>=f){\\n                itl++;   //increment ptr1 -> decrease window width\\n            }else if(s-f == k){\\n                if((k==0 && itl->second >1 )|| (k>0)){\\n                    sum++;\\n                }\\n                itr++; itl++;  //increment both ptr1 and ptr2 -> sliding the window\\n            }\\n          \\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        map<int,int> mp;    //creating map with frequency as its value\\n        for(int i = 0; i<nums.size(); i++){\\n            mp[nums[i]]+=1;\\n        }\\n        int sum = 0;\\n       map<int,int>::iterator itl;   //ptr1\\n        map<int,int>::iterator itr;   //ptr2\\n        itl= mp.begin(); itr= mp.begin() ;\\n\\t\\t\\n        while(itr!=mp.end()){\\n            int f = itl->first;\\n            int s = itr -> first;\\n            if(s-f <k && s>=f){\\n                itr++;   //increment ptr2 -> increase window width\\n            }else if(s-f > k && s>=f){\\n                itl++;   //increment ptr1 -> decrease window width\\n            }else if(s-f == k){\\n                if((k==0 && itl->second >1 )|| (k>0)){\\n                    sum++;\\n                }\\n                itr++; itl++;  //increment both ptr1 and ptr2 -> sliding the window\\n            }\\n          \\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877271,
                "title": "c-super-simple-clear-solution-99-5-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) \\n    {\\n        unordered_map<int, int> myMap;\\n        size_t kDiffPairs = 0;\\n        \\n        for(auto num : nums)\\n        {   \\n            myMap[num]++;\\n        }\\n        \\n        if (k > 0) \\n        {\\n            for(auto iter : myMap)\\n            {\\n                kDiffPairs += myMap.find(k + iter.first) != myMap.end() ? 1 : 0;\\n            }\\n        }\\n        \\n        else \\n        {\\n            for(auto iter : myMap)\\n            {\\n                kDiffPairs += iter.second > 1 ? 1 : 0;\\n            }\\n        }\\n        \\n        return kDiffPairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) \\n    {\\n        unordered_map<int, int> myMap;\\n        size_t kDiffPairs = 0;\\n        \\n        for(auto num : nums)\\n        {   \\n            myMap[num]++;\\n        }\\n        \\n        if (k > 0) \\n        {\\n            for(auto iter : myMap)\\n            {\\n                kDiffPairs += myMap.find(k + iter.first) != myMap.end() ? 1 : 0;\\n            }\\n        }\\n        \\n        else \\n        {\\n            for(auto iter : myMap)\\n            {\\n                kDiffPairs += iter.second > 1 ? 1 : 0;\\n            }\\n        }\\n        \\n        return kDiffPairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877008,
                "title": "python-3-two-pointers-zero-diff-special-case",
                "content": "```\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def findPairs(self, nums, k: int) -> int:\\n        \"\"\"\\n        Given an array of integers (nums) and a non-negative\\n        target difference (k), this program counts the unique\\n        pairs within nums whose difference is k.\\n\\n        :param nums: array of integers\\n        :type nums: list[int]\\n        :param k: target difference\\n        :type k: int\\n        :return: number of unique pairs in nums with difference k\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Special Case: k = 0\\n        - Use the Python collections Counter to get the frequency\\n          of each value in nums.\\n        - Determine the number of zero differences by counting\\n          the number of values in nums with frequency > 1.\\n        \"\"\"\\n        if k == 0:\\n            freqs = Counter(nums)\\n            return sum(freqs[k] > 1 for k in freqs)\\n\\n        \"\"\"\\n        General Case: k > 0\\n        - Pre-process nums to produce a sorted list of values\\n          without duplicates.\\n        - Use two pointers (slow and fast) in a sliding window\\n          protocol to find all pairs whose difference is k.\\n          - If difference is smaller than k, advance fast pointer.\\n          - If difference is larger than k, advance slow pointer.\\n          - If difference equals k, advance both pointers and\\n            increment a counter that is later returned from this\\n            program.\\n        \"\"\"\\n        sorted_set_list = sorted(list(set(nums)))\\n        length = len(sorted_set_list)\\n        slow = 0\\n        fast = 0\\n        answer = 0\\n        while fast < length:\\n            difference = sorted_set_list[fast] - sorted_set_list[slow]\\n            if difference < k:\\n                fast += 1\\n            elif difference > k:\\n                slow += 1\\n            else:\\n                answer += 1\\n                slow += 1\\n                fast += 1\\n        return answer\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def findPairs(self, nums, k: int) -> int:\\n        \"\"\"\\n        Given an array of integers (nums) and a non-negative\\n        target difference (k), this program counts the unique\\n        pairs within nums whose difference is k.\\n\\n        :param nums: array of integers\\n        :type nums: list[int]\\n        :param k: target difference\\n        :type k: int\\n        :return: number of unique pairs in nums with difference k\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Special Case: k = 0\\n        - Use the Python collections Counter to get the frequency\\n          of each value in nums.\\n        - Determine the number of zero differences by counting\\n          the number of values in nums with frequency > 1.\\n        \"\"\"\\n        if k == 0:\\n            freqs = Counter(nums)\\n            return sum(freqs[k] > 1 for k in freqs)\\n\\n        \"\"\"\\n        General Case: k > 0\\n        - Pre-process nums to produce a sorted list of values\\n          without duplicates.\\n        - Use two pointers (slow and fast) in a sliding window\\n          protocol to find all pairs whose difference is k.\\n          - If difference is smaller than k, advance fast pointer.\\n          - If difference is larger than k, advance slow pointer.\\n          - If difference equals k, advance both pointers and\\n            increment a counter that is later returned from this\\n            program.\\n        \"\"\"\\n        sorted_set_list = sorted(list(set(nums)))\\n        length = len(sorted_set_list)\\n        slow = 0\\n        fast = 0\\n        answer = 0\\n        while fast < length:\\n            difference = sorted_set_list[fast] - sorted_set_list[slow]\\n            if difference < k:\\n                fast += 1\\n            elif difference > k:\\n                slow += 1\\n            else:\\n                answer += 1\\n                slow += 1\\n                fast += 1\\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876465,
                "title": "c-first-sort-then-two-pointers-concise-o-nlogn-runtime-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        auto i = 0, j = 1, pairs = 0;\\n        while (j < nums.size()) {\\n            if (nums[j] - nums[i] == k) {\\n                pairs++;\\n                i++;\\n                j++;\\n            }\\n            else if (nums[j] - nums[i] < k) j++;\\n            else i++;\\n            while (i > 0 && i < nums.size() && nums[i - 1] == nums[i]) i++;\\n            j = max(j, i + 1);\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        auto i = 0, j = 1, pairs = 0;\\n        while (j < nums.size()) {\\n            if (nums[j] - nums[i] == k) {\\n                pairs++;\\n                i++;\\n                j++;\\n            }\\n            else if (nums[j] - nums[i] < k) j++;\\n            else i++;\\n            while (i > 0 && i < nums.size() && nums[i - 1] == nums[i]) i++;\\n            j = max(j, i + 1);\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876413,
                "title": "c-o-n-map-solution-with-detailed-explanation-97-time-98-space",
                "content": "**HashMap Solution in C++:**\\n1. We keep a Hash Map to track the elements that we have encountered till now. We mark them as true in the HashMap.\\n1. Just iterate over the array and check for the element (num[i]+k) and (num[i]-k) in the hash. If they are present, add it in the answer set.\\n1. The size of the set would be the answer. Those are the unique number of pairs with \\'k\\' difference.\\n1. We need not sort the vector, and it happens in just one pass, so O(n) solution :)\\n\\n\\n```\\nclass Solution {\\npublic:\\n  int findPairs(vector<int>& nums, int k) {\\n    set<pair<int, int>> s; \\n    unordered_map <int, bool> m;\\n    int n = nums.size();\\n    \\n    for(int i=0;i<n;++i){\\n      if (m.find(nums[i]+k)!=m.end()){\\n        s.insert(make_pair(nums[i], nums[i]+k));\\n      }\\n      if (m.find(nums[i]-k)!=m.end()){\\n        s.insert(make_pair(nums[i]-k, nums[i]));\\n      }\\n      m[nums[i]] = true;\\n    }\\n    \\n    return s.size();\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int findPairs(vector<int>& nums, int k) {\\n    set<pair<int, int>> s; \\n    unordered_map <int, bool> m;\\n    int n = nums.size();\\n    \\n    for(int i=0;i<n;++i){\\n      if (m.find(nums[i]+k)!=m.end()){\\n        s.insert(make_pair(nums[i], nums[i]+k));\\n      }\\n      if (m.find(nums[i]-k)!=m.end()){\\n        s.insert(make_pair(nums[i]-k, nums[i]));\\n      }\\n      m[nums[i]] = true;\\n    }\\n    \\n    return s.size();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876312,
                "title": "k-diff-pairs-in-an-array-solution-java",
                "content": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n        for (int num: nums)\\n        {\\n            m.put(num, m.getOrDefault(num, 0) + 1);\\n        }\\n        int count = k == 0 ? 1 : 0;\\n        m.forEach((key, value)->{\\n            if (m.getOrDefault(key + k, 0) > count) res++;    \\n        });\\n        return res;\\n    }\\n    private int res = 0;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findPairs(int[] nums, int k) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n        for (int num: nums)\\n        {\\n            m.put(num, m.getOrDefault(num, 0) + 1);\\n        }\\n        int count = k == 0 ? 1 : 0;\\n        m.forEach((key, value)->{\\n            if (m.getOrDefault(key + k, 0) > count) res++;    \\n        });\\n        return res;\\n    }\\n    private int res = 0;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876261,
                "title": "c-binary-search-99",
                "content": "The problem states that\\n```\\nA k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:\\n- 0 <= i, j < nums.length\\n- i != j\\n- a <= b\\n- b - a == k\\n```\\nSo either `(nums[i],nums[j])` or `(nums[j],nums[i])` is a sufficient k-diff pair. That means, the order of elements doesn\\'t matter -> sort the array and use binary search.\\n\\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int prev = INT_MIN, ret = 0, n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            auto &v = nums[i];\\n            if (v != prev) {\\n                if (binary_search(nums.begin()+i+1,nums.end(),v+k)) {\\n                    ret++;\\n                }\\n                prev = v;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nA k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:\\n- 0 <= i, j < nums.length\\n- i != j\\n- a <= b\\n- b - a == k\\n```\n```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int prev = INT_MIN, ret = 0, n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            auto &v = nums[i];\\n            if (v != prev) {\\n                if (binary_search(nums.begin()+i+1,nums.end(),v+k)) {\\n                    ret++;\\n                }\\n                prev = v;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772006,
                "title": "o-n-solution-using-unordered-set",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& a, int k) {\\n        \\n        \\n        if(k==0){\\n            unordered_map<int,int> mp;\\n            for(int i=0;i<a.size();i++)\\n            {\\n                mp[a[i]]++;\\n            }\\n            \\n            int cnt=0;\\n            for(auto u : mp)\\n            {\\n                if(u.second> 1) cnt++;\\n            }\\n            \\n            return cnt;\\n        }\\n        \\n        else if(k<0) return 0;\\n        \\n        else\\n        {\\n        unordered_set<int> s;\\n        unordered_set<int> after;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            s.insert(a[i]);\\n        }\\n        \\n        int cnt=0;\\n        for(auto u : s)\\n        {\\n             if(s.count(u+k))\\n             {\\n                 if(!after.count(u))\\n                 {\\n                     cnt++;\\n                     after.insert(u);\\n                     \\n                 }\\n             }\\n            \\n           \\n        }\\n        \\n        \\n        return cnt;\\n        }\\n        \\n    }\\n    \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& a, int k) {\\n        \\n        \\n        if(k==0){\\n            unordered_map<int,int> mp;\\n            for(int i=0;i<a.size();i++)\\n            {\\n                mp[a[i]]++;\\n            }\\n            \\n            int cnt=0;\\n            for(auto u : mp)\\n            {\\n                if(u.second> 1) cnt++;\\n            }\\n            \\n            return cnt;\\n        }\\n        \\n        else if(k<0) return 0;\\n        \\n        else\\n        {\\n        unordered_set<int> s;\\n        unordered_set<int> after;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            s.insert(a[i]);\\n        }\\n        \\n        int cnt=0;\\n        for(auto u : s)\\n        {\\n             if(s.count(u+k))\\n             {\\n                 if(!after.count(u))\\n                 {\\n                     cnt++;\\n                     after.insert(u);\\n                     \\n                 }\\n             }\\n            \\n           \\n        }\\n        \\n        \\n        return cnt;\\n        }\\n        \\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749407,
                "title": "rust-solutions",
                "content": "\\n### 1. Set\\n```Rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn find_pairs(nums: Vec<i32>, k: i32) -> i32 {\\n        if k < 0 {\\n            return 0;\\n        }\\n\\n        let mut nums_set = HashSet::new();\\n        let mut pairs_j = HashSet::new();\\n\\n        for n in nums {\\n            if nums_set.contains(&(n - k)) {\\n                pairs_j.insert(n);\\n            }\\n            if nums_set.contains(&(n + k)) {\\n                pairs_j.insert(n + k);\\n            }\\n\\n            nums_set.insert(n);\\n        }\\n\\n        pairs_j.len() as i32\\n    }\\n}\\n```\\n\\n### 2. Binary Search\\n```Rust\\nimpl Solution {\\n    pub fn find_pairs(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n        let mut ret = 0;\\n\\n        for i in 0..nums.len() {\\n            if i > 0 && nums[i] == nums[i - 1] {\\n                continue;\\n            }\\n\\n            if nums[i + 1..].binary_search(&(nums[i] + k)).is_ok() {\\n                ret += 1;\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```Rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn find_pairs(nums: Vec<i32>, k: i32) -> i32 {\\n        if k < 0 {\\n            return 0;\\n        }\\n\\n        let mut nums_set = HashSet::new();\\n        let mut pairs_j = HashSet::new();\\n\\n        for n in nums {\\n            if nums_set.contains(&(n - k)) {\\n                pairs_j.insert(n);\\n            }\\n            if nums_set.contains(&(n + k)) {\\n                pairs_j.insert(n + k);\\n            }\\n\\n            nums_set.insert(n);\\n        }\\n\\n        pairs_j.len() as i32\\n    }\\n}\\n```\n```Rust\\nimpl Solution {\\n    pub fn find_pairs(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n        let mut ret = 0;\\n\\n        for i in 0..nums.len() {\\n            if i > 0 && nums[i] == nums[i - 1] {\\n                continue;\\n            }\\n\\n            if nums[i + 1..].binary_search(&(nums[i] + k)).is_ok() {\\n                ret += 1;\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745330,
                "title": "two-easy-solutions-in-c-using-hashing-and-two-pointer-approach",
                "content": "# **First:-**\\n**using set,pair and map**\\n```\\n        int findPairs(vector<int>& nums, int k) {\\n\\t\\t  set<pair<int,int>> unq;\\n          unordered_map<int,int> m;\\n        \\n          sort(nums.begin(),nums.end());\\n        \\n          for(int i=0;i<nums.size();i++)\\n           {\\n            int temp=nums[i]-k;\\n            if(m.find(temp)!=m.end())\\n            {\\n                unq.insert(make_pair(nums[i],k-nums[i]));\\n                \\n            }\\n            m[nums[i]]=1;\\n        }\\n        \\n        return unq.size();\\n     } \\n```  \\n        \\n# \\t**Second:-(more prefered)**\\n\\t\\n```\\nint findPairs(vector<int>& nums, int k) {\\n sort(nums.begin(),nums.end());\\n int fast=1;\\n int slow=0;\\n int ans=0;\\n while(slow<nums.size() && fast<nums.size()){\\n\\tif(nums[fast]-nums[slow]==k){\\n\\t\\tans++;\\n\\t\\tfast++;\\n\\t\\tslow++;\\n\\t\\t// For Duplicacy\\n\\t\\twhile(fast<nums.size() && nums[fast]==nums[fast-1]){\\n\\t\\t\\tfast++;\\n\\t\\t}\\n\\t}\\n\\telse if(nums[fast]-nums[slow]>k){\\n\\t\\tslow++;  \\n\\t\\tif(fast-slow==0){\\n\\t\\t\\tfast++;}\\n\\t}\\n\\telse{      \\n\\t\\tfast++;\\n\\t}         \\n}\\nreturn ans;\\n\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n        int findPairs(vector<int>& nums, int k) {\\n\\t\\t  set<pair<int,int>> unq;\\n          unordered_map<int,int> m;\\n        \\n          sort(nums.begin(),nums.end());\\n        \\n          for(int i=0;i<nums.size();i++)\\n           {\\n            int temp=nums[i]-k;\\n            if(m.find(temp)!=m.end())\\n            {\\n                unq.insert(make_pair(nums[i],k-nums[i]));\\n                \\n            }\\n            m[nums[i]]=1;\\n        }\\n        \\n        return unq.size();\\n     } \\n```\n```\\nint findPairs(vector<int>& nums, int k) {\\n sort(nums.begin(),nums.end());\\n int fast=1;\\n int slow=0;\\n int ans=0;\\n while(slow<nums.size() && fast<nums.size()){\\n\\tif(nums[fast]-nums[slow]==k){\\n\\t\\tans++;\\n\\t\\tfast++;\\n\\t\\tslow++;\\n\\t\\t// For Duplicacy\\n\\t\\twhile(fast<nums.size() && nums[fast]==nums[fast-1]){\\n\\t\\t\\tfast++;\\n\\t\\t}\\n\\t}\\n\\telse if(nums[fast]-nums[slow]>k){\\n\\t\\tslow++;  \\n\\t\\tif(fast-slow==0){\\n\\t\\t\\tfast++;}\\n\\t}\\n\\telse{      \\n\\t\\tfast++;\\n\\t}         \\n}\\nreturn ans;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739345,
                "title": "c-using-binary-search-and-set-bst-o-n-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) { \\n        int n = nums.size();  \\n        set<pair<int,int>> s;\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i = 0; i < n; i++){  \\n            int find = nums[i] - k; \\n            int ldx = i+1,rdx = n-1;  \\n                while(ldx <= rdx){\\n                    int mid = ldx + (rdx-ldx)/2; \\n                    if(nums[mid] == find)  \\n                         {s.insert({nums[i],nums[mid]}); break;} \\n                    else if(nums[mid] > find) ldx = mid+1; \\n                    else rdx = mid-1;\\n                } \\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) { \\n        int n = nums.size();  \\n        set<pair<int,int>> s;\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i = 0; i < n; i++){  \\n            int find = nums[i] - k; \\n            int ldx = i+1,rdx = n-1;  \\n                while(ldx <= rdx){\\n                    int mid = ldx + (rdx-ldx)/2; \\n                    if(nums[mid] == find)  \\n                         {s.insert({nums[i],nums[mid]}); break;} \\n                    else if(nums[mid] > find) ldx = mid+1; \\n                    else rdx = mid-1;\\n                } \\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726372,
                "title": "c-binary-search-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findPairs(vector<int>& nums, int k) {\\n\\t\\t\\tif(nums.size()<2) return 0;\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<nums.size()-1;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i>0 && nums[i]==nums[i-1]) continue;\\n\\t\\t\\t\\tint target=nums[i]+k;\\n\\t\\t\\t\\tauto it=lower_bound(nums.begin()+i+1,nums.end(),target);\\n\\t\\t\\t\\tif(it!=nums.end() && *it==target)\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findPairs(vector<int>& nums, int k) {\\n\\t\\t\\tif(nums.size()<2) return 0;\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<nums.size()-1;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i>0 && nums[i]==nums[i-1]) continue;\\n\\t\\t\\t\\tint target=nums[i]+k;\\n\\t\\t\\t\\tauto it=lower_bound(nums.begin()+i+1,nums.end(),target);\\n\\t\\t\\t\\tif(it!=nums.end() && *it==target)\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 701213,
                "title": "c-simple-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        if(k<0) return 0;\\n        unordered_map<int,int> x;\\n        for(int i : nums) x[i]++;\\n        int ans = 0;\\n        if(k==0) {for(auto itr : x) if(itr.second >1) ans++;}\\n        else {for(auto itr : x) if(x.count(itr.first +k)) ans++;}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findPairs(vector<int>& nums, int k) {\\n        if(k<0) return 0;\\n        unordered_map<int,int> x;\\n        for(int i : nums) x[i]++;\\n        int ans = 0;\\n        if(k==0) {for(auto itr : x) if(itr.second >1) ans++;}\\n        else {for(auto itr : x) if(x.count(itr.first +k)) ans++;}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585471,
                "title": "python-76-83-hash-set",
                "content": "```\\ndef findPairs(self, nums: List[int], k: int) -> int:\\n        # special case\\n        if k == 0:\\n            d = {}\\n            for e in nums:\\n                if e not in d:\\n                    d[e] = 1\\n                else:\\n                    d[e] += 1\\n            return len([v for v in d.values() if v >= 2])\\n            \\n        elif k < 0:\\n            return 0\\n        \\n        d = {}\\n        s = set()\\n        \\n        for e in nums:\\n            if e not in d:\\n                d[e] = 1\\n        \\n        for key in d.keys():\\n            up, down = key+k, key-k\\n            if up in d:\\n                s.add((up, key)) \\n            if down in d:\\n                s.add((key, down))\\n        # print(s)\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef findPairs(self, nums: List[int], k: int) -> int:\\n        # special case\\n        if k == 0:\\n            d = {}\\n            for e in nums:\\n                if e not in d:\\n                    d[e] = 1\\n                else:\\n                    d[e] += 1\\n            return len([v for v in d.values() if v >= 2])\\n            \\n        elif k < 0:\\n            return 0\\n        \\n        d = {}\\n        s = set()\\n        \\n        for e in nums:\\n            if e not in d:\\n                d[e] = 1\\n        \\n        for key in d.keys():\\n            up, down = key+k, key-k\\n            if up in d:\\n                s.add((up, key)) \\n            if down in d:\\n                s.add((key, down))\\n        # print(s)\\n        return len(s)\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1564992,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1565811,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1565385,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1568614,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1570793,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1567396,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1576362,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1572292,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1745310,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1571764,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1564992,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1565811,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1565385,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1568614,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1570793,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1567396,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1576362,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1572292,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1745310,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            },
            {
                "id": 1571764,
                "content": [
                    {
                        "username": "celticrocks",
                        "content": "The question clearly stated that k is the absolute difference, which means it must be non negative.\\nHow is [1,2,3,4,5] and -1 in test case?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is fixed now"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/k-diff-pairs-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Two Pointers\n\n  \n**Approach 3:** Hashmap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "snipper268",
                        "content": "Is this a valid testcase:\\nInput:\\n[1,2,3,4,5]\\n-1\\nExpected:\\n0"
                    },
                    {
                        "username": "manii15",
                        "content": "no .. see Constraints \\nit says 0<=k"
                    },
                    {
                        "username": "vsavkin",
                        "content": "Here is example 4:\\n\\nInput: nums = [1,2,4,4,3,3,0,9,2,3], k = 3\\nOutput: 2\\n\\nHowever, we can see 3 unique pairs here: (1,4), (3,0), (0,3). Apparently, they meant *unordered* pairs. In most programming languages, as in mathematics, syntax (a,b) means an ordered pair. I think the description should be reformulated here to make it more clear that unique unordered pairs are requested."
                    },
                    {
                        "username": "user0667jw",
                        "content": "agree"
                    },
                    {
                        "username": "LivingHell",
                        "content": "I faced the same issue"
                    },
                    {
                        "username": "milochen",
                        "content": "Hi, \\n\\nI know what k-diff is in this problem because this problem introduce it.\\nBut the in the problem, there is no definition about what **unique k-diff** it is. \\nEven check the examples, I still have no idea what the unique it is.\\n\\nI try to guess what unique k-diff it is from the example of this problem. but I\\'m still failed.\\n\\n\\nIs anyone have the same question like me?\\nCould anyone know how to describe the definition of **unique k-diff** ? \\n\\nWhen I use the testcase\\n[1,1,3,5,5,3]\\n2\\nThe expected from the system is 2. \\n\\nBut in my understanding, there are three unique k-diff  (1,3), (3,5), (5,3) \\nI\\'m not sure what happen. \\n\\nThanks for helps. \\n\\n\\n"
                    },
                    {
                        "username": "mayank-01",
                        "content": "(3,5) and (5,3) are identical, so I think they both considered as one......statement of the ques is not clear."
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "My solution failed on following test case:\\n[1,2,3,4,5]\\n-1\\n\\nThe definition of K is the absolute distance of two elements. So input K should be positive. Am I right?"
                    },
                    {
                        "username": "gregory-pevnev",
                        "content": "I really don\\'t get why there are more dislikes than likes for this problem.\\nJust curious."
                    },
                    {
                        "username": "mahender_681",
                        "content": "there were some invalid test cases. "
                    },
                    {
                        "username": "Gomez0_0",
                        "content": "The description says k is the absolute difference,How could it be negative???\\n![image](https://assets.leetcode.com/users/gomez0_0/image_1543137351.png)\\n"
                    },
                    {
                        "username": "MichaelCho1201",
                        "content": "Example 3 is incorrect. The question clearly stated that I must not equal j. However, in order for k to be 0, I has to equal j, as shown in example 3. "
                    },
                    {
                        "username": "mayank-01",
                        "content": "i != j (where i and j are index) .....not the num at that index "
                    },
                    {
                        "username": "SpicyZinc",
                        "content": "See if inputs are as follows:\\n[3,1,4,1,1,1,5]\\n0\\nthe result should be (4*3)/2.\\nGenerally speaking, n is the number of duplicate elements, for k == 0, it should be n * (n-1) / 2"
                    }
                ]
            }
        ]
    },
    {
        "title": "Lonely Pixel II",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1564877,
                "content": [
                    {
                        "username": "odingg",
                        "content": "I was very confused by the rule 2 before I read the solutions. Then I realized that the rule 2 means: \\n\"For all rows that have a black pixel at column C, they should be exactly the same as the row R ***in terms of looking***\"\\n\\nSo in the example, row 1 looks exactly the same as the row 0, but row 3 looks not the same as row 0.\\n\\nI got confused by thinking row 1 and row 0 being the same means that the number of black pixels they have are the same or all other possibilities. Maybe that's because English is not my native language."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "1. The description cannot be more confusing. I spent more than 10 minutes going through the description and the example and I still couldn\\'t understand the meaning. Only after I saw the solution when did I know the exact meaning.\\n\\n2. Why is this problem tagged DFS?\\n3. Quoted from description of the problem:\\n > Rule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2\\n \\n Seriously, even the grammer is not correct......"
                    },
                    {
                        "username": "ChrisC",
                        "content": "why is this problem tagged with DFS?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "What an embarrassment of a problem. Ridiculous that Leetcode allows this to remain as is. The second rule is extremely hard to parse, and none of the examples touch on the second rule being relevant. \\n\\nSometimes I regret paying for this service. Problems this bad make me reconsider continuing to pay for a premium account. "
                    },
                    {
                        "username": "sinfonia",
                        "content": "Once the size of column and the size of row are different ,how can they be the same?"
                    },
                    {
                        "username": "mkohar",
                        "content": "Read rule 2 carefully again:\\nall rows ..... should be exactly the same.\\n\\nIt doesn\\'t say that: column = row\\nBut it should be : R1=R2=Rn    in that particular column\\n\\nI know description is fucked up.\\n\\n"
                    },
                    {
                        "username": "strahd",
                        "content": "The second constraint is really incomprehensible. Leetcoders shouldn\\'t be wasting time deciphering such poorly written questions. Since this is question #533, it must be around since 2017. I can\\'t understand why this hasn\\'t been corrected yet.  "
                    }
                ]
            },
            {
                "id": 1565083,
                "content": [
                    {
                        "username": "odingg",
                        "content": "I was very confused by the rule 2 before I read the solutions. Then I realized that the rule 2 means: \\n\"For all rows that have a black pixel at column C, they should be exactly the same as the row R ***in terms of looking***\"\\n\\nSo in the example, row 1 looks exactly the same as the row 0, but row 3 looks not the same as row 0.\\n\\nI got confused by thinking row 1 and row 0 being the same means that the number of black pixels they have are the same or all other possibilities. Maybe that's because English is not my native language."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "1. The description cannot be more confusing. I spent more than 10 minutes going through the description and the example and I still couldn\\'t understand the meaning. Only after I saw the solution when did I know the exact meaning.\\n\\n2. Why is this problem tagged DFS?\\n3. Quoted from description of the problem:\\n > Rule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2\\n \\n Seriously, even the grammer is not correct......"
                    },
                    {
                        "username": "ChrisC",
                        "content": "why is this problem tagged with DFS?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "What an embarrassment of a problem. Ridiculous that Leetcode allows this to remain as is. The second rule is extremely hard to parse, and none of the examples touch on the second rule being relevant. \\n\\nSometimes I regret paying for this service. Problems this bad make me reconsider continuing to pay for a premium account. "
                    },
                    {
                        "username": "sinfonia",
                        "content": "Once the size of column and the size of row are different ,how can they be the same?"
                    },
                    {
                        "username": "mkohar",
                        "content": "Read rule 2 carefully again:\\nall rows ..... should be exactly the same.\\n\\nIt doesn\\'t say that: column = row\\nBut it should be : R1=R2=Rn    in that particular column\\n\\nI know description is fucked up.\\n\\n"
                    },
                    {
                        "username": "strahd",
                        "content": "The second constraint is really incomprehensible. Leetcoders shouldn\\'t be wasting time deciphering such poorly written questions. Since this is question #533, it must be around since 2017. I can\\'t understand why this hasn\\'t been corrected yet.  "
                    }
                ]
            },
            {
                "id": 1565284,
                "content": [
                    {
                        "username": "odingg",
                        "content": "I was very confused by the rule 2 before I read the solutions. Then I realized that the rule 2 means: \\n\"For all rows that have a black pixel at column C, they should be exactly the same as the row R ***in terms of looking***\"\\n\\nSo in the example, row 1 looks exactly the same as the row 0, but row 3 looks not the same as row 0.\\n\\nI got confused by thinking row 1 and row 0 being the same means that the number of black pixels they have are the same or all other possibilities. Maybe that's because English is not my native language."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "1. The description cannot be more confusing. I spent more than 10 minutes going through the description and the example and I still couldn\\'t understand the meaning. Only after I saw the solution when did I know the exact meaning.\\n\\n2. Why is this problem tagged DFS?\\n3. Quoted from description of the problem:\\n > Rule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2\\n \\n Seriously, even the grammer is not correct......"
                    },
                    {
                        "username": "ChrisC",
                        "content": "why is this problem tagged with DFS?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "What an embarrassment of a problem. Ridiculous that Leetcode allows this to remain as is. The second rule is extremely hard to parse, and none of the examples touch on the second rule being relevant. \\n\\nSometimes I regret paying for this service. Problems this bad make me reconsider continuing to pay for a premium account. "
                    },
                    {
                        "username": "sinfonia",
                        "content": "Once the size of column and the size of row are different ,how can they be the same?"
                    },
                    {
                        "username": "mkohar",
                        "content": "Read rule 2 carefully again:\\nall rows ..... should be exactly the same.\\n\\nIt doesn\\'t say that: column = row\\nBut it should be : R1=R2=Rn    in that particular column\\n\\nI know description is fucked up.\\n\\n"
                    },
                    {
                        "username": "strahd",
                        "content": "The second constraint is really incomprehensible. Leetcoders shouldn\\'t be wasting time deciphering such poorly written questions. Since this is question #533, it must be around since 2017. I can\\'t understand why this hasn\\'t been corrected yet.  "
                    }
                ]
            },
            {
                "id": 1752202,
                "content": [
                    {
                        "username": "odingg",
                        "content": "I was very confused by the rule 2 before I read the solutions. Then I realized that the rule 2 means: \\n\"For all rows that have a black pixel at column C, they should be exactly the same as the row R ***in terms of looking***\"\\n\\nSo in the example, row 1 looks exactly the same as the row 0, but row 3 looks not the same as row 0.\\n\\nI got confused by thinking row 1 and row 0 being the same means that the number of black pixels they have are the same or all other possibilities. Maybe that's because English is not my native language."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "1. The description cannot be more confusing. I spent more than 10 minutes going through the description and the example and I still couldn\\'t understand the meaning. Only after I saw the solution when did I know the exact meaning.\\n\\n2. Why is this problem tagged DFS?\\n3. Quoted from description of the problem:\\n > Rule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2\\n \\n Seriously, even the grammer is not correct......"
                    },
                    {
                        "username": "ChrisC",
                        "content": "why is this problem tagged with DFS?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "What an embarrassment of a problem. Ridiculous that Leetcode allows this to remain as is. The second rule is extremely hard to parse, and none of the examples touch on the second rule being relevant. \\n\\nSometimes I regret paying for this service. Problems this bad make me reconsider continuing to pay for a premium account. "
                    },
                    {
                        "username": "sinfonia",
                        "content": "Once the size of column and the size of row are different ,how can they be the same?"
                    },
                    {
                        "username": "mkohar",
                        "content": "Read rule 2 carefully again:\\nall rows ..... should be exactly the same.\\n\\nIt doesn\\'t say that: column = row\\nBut it should be : R1=R2=Rn    in that particular column\\n\\nI know description is fucked up.\\n\\n"
                    },
                    {
                        "username": "strahd",
                        "content": "The second constraint is really incomprehensible. Leetcoders shouldn\\'t be wasting time deciphering such poorly written questions. Since this is question #533, it must be around since 2017. I can\\'t understand why this hasn\\'t been corrected yet.  "
                    }
                ]
            },
            {
                "id": 1569134,
                "content": [
                    {
                        "username": "odingg",
                        "content": "I was very confused by the rule 2 before I read the solutions. Then I realized that the rule 2 means: \\n\"For all rows that have a black pixel at column C, they should be exactly the same as the row R ***in terms of looking***\"\\n\\nSo in the example, row 1 looks exactly the same as the row 0, but row 3 looks not the same as row 0.\\n\\nI got confused by thinking row 1 and row 0 being the same means that the number of black pixels they have are the same or all other possibilities. Maybe that's because English is not my native language."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "1. The description cannot be more confusing. I spent more than 10 minutes going through the description and the example and I still couldn\\'t understand the meaning. Only after I saw the solution when did I know the exact meaning.\\n\\n2. Why is this problem tagged DFS?\\n3. Quoted from description of the problem:\\n > Rule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2\\n \\n Seriously, even the grammer is not correct......"
                    },
                    {
                        "username": "ChrisC",
                        "content": "why is this problem tagged with DFS?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "What an embarrassment of a problem. Ridiculous that Leetcode allows this to remain as is. The second rule is extremely hard to parse, and none of the examples touch on the second rule being relevant. \\n\\nSometimes I regret paying for this service. Problems this bad make me reconsider continuing to pay for a premium account. "
                    },
                    {
                        "username": "sinfonia",
                        "content": "Once the size of column and the size of row are different ,how can they be the same?"
                    },
                    {
                        "username": "mkohar",
                        "content": "Read rule 2 carefully again:\\nall rows ..... should be exactly the same.\\n\\nIt doesn\\'t say that: column = row\\nBut it should be : R1=R2=Rn    in that particular column\\n\\nI know description is fucked up.\\n\\n"
                    },
                    {
                        "username": "strahd",
                        "content": "The second constraint is really incomprehensible. Leetcoders shouldn\\'t be wasting time deciphering such poorly written questions. Since this is question #533, it must be around since 2017. I can\\'t understand why this hasn\\'t been corrected yet.  "
                    }
                ]
            },
            {
                "id": 2067530,
                "content": [
                    {
                        "username": "odingg",
                        "content": "I was very confused by the rule 2 before I read the solutions. Then I realized that the rule 2 means: \\n\"For all rows that have a black pixel at column C, they should be exactly the same as the row R ***in terms of looking***\"\\n\\nSo in the example, row 1 looks exactly the same as the row 0, but row 3 looks not the same as row 0.\\n\\nI got confused by thinking row 1 and row 0 being the same means that the number of black pixels they have are the same or all other possibilities. Maybe that's because English is not my native language."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "1. The description cannot be more confusing. I spent more than 10 minutes going through the description and the example and I still couldn\\'t understand the meaning. Only after I saw the solution when did I know the exact meaning.\\n\\n2. Why is this problem tagged DFS?\\n3. Quoted from description of the problem:\\n > Rule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2\\n \\n Seriously, even the grammer is not correct......"
                    },
                    {
                        "username": "ChrisC",
                        "content": "why is this problem tagged with DFS?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "What an embarrassment of a problem. Ridiculous that Leetcode allows this to remain as is. The second rule is extremely hard to parse, and none of the examples touch on the second rule being relevant. \\n\\nSometimes I regret paying for this service. Problems this bad make me reconsider continuing to pay for a premium account. "
                    },
                    {
                        "username": "sinfonia",
                        "content": "Once the size of column and the size of row are different ,how can they be the same?"
                    },
                    {
                        "username": "mkohar",
                        "content": "Read rule 2 carefully again:\\nall rows ..... should be exactly the same.\\n\\nIt doesn\\'t say that: column = row\\nBut it should be : R1=R2=Rn    in that particular column\\n\\nI know description is fucked up.\\n\\n"
                    },
                    {
                        "username": "strahd",
                        "content": "The second constraint is really incomprehensible. Leetcoders shouldn\\'t be wasting time deciphering such poorly written questions. Since this is question #533, it must be around since 2017. I can\\'t understand why this hasn\\'t been corrected yet.  "
                    }
                ]
            }
        ]
    },
    {
        "title": "Game Play Analysis III",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565697,
                "content": [
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect a1.player_id, a1.event_date, sum(a2.games_played) as games_played_so_far \\nfrom Activity a1, Activity a2 \\nwhere a1.player_id = a2.player_id and a2.event_date <= a1.event_date \\ngroup by a1.player_id, a1.event_date\\norder by a1.player_id, a1.event_date\\n;\\n\\nPlease make sure the inequity is **a2**.event_date <= **a1**.event_date. Think in this way: a2 is the table you want to use to carry the running sum, so you have to constrain it in the range you want to sum."
                    },
                    {
                        "username": "KenanAtMorningside",
                        "content": "\\nSELECT \\n    player_id, event_date, sum(games_played) over (partition by player_id order by event_date) as games_played_so_far \\nFROM Activity"
                    },
                    {
                        "username": "KajalJaiswal",
                        "content": "\\'\\'\\'\\nselect player_id, \\nevent_date, \\nsum(games_played) over (partition by player_id order by player_id, event_date) as games_played_so_far\\nfrom activity\\n\\'\\'\\'"
                    },
                    {
                        "username": "codeleetr",
                        "content": "# Write your MySQL query statement below\\nwith tb as\\n(select * from Activity\\norder by player_id, games_played)\\n\\nselect t1.player_id, t1.event_date,sum(t2.games_played) as games_played_so_far from tb t1\\nleft join tb t2\\non t1.player_id = t2.player_id\\nwhere t1.event_date >= t2.event_date\\ngroup by t1.player_id, t1.event_date"
                    },
                    {
                        "username": "ZYYMY",
                        "content": "\\'\\'\\'Use a simple self join based on two conditions\\n\\nSELECT a.player_id,a.event_date, SUM(b.games_played) AS games_played_so_far\\nFROM Activity AS a JOIN Activity AS b ON (a.Player_id = b.Player_id AND b.event_date<=a.event_date)\\nGROUP BY a.player_id,a.event_date"
                    },
                    {
                        "username": "jayadurga",
                        "content": "\\nselect \\n    player_id,\\n    event_date,\\n    sum(games_played) over (partition by player_id order by event_date) as games_played_so_far\\nfrom activity"
                    },
                    {
                        "username": "hhharden13",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over(partition by player_id order by event_date asc) as games_played_so_far\\nfrom Activity\\norder by player_id, event_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "meng-y",
                        "content": " `select distinct a.player_id, a.event_date,\\nifnull(sum(b.games_played),0) as games_played_so_far\\nfrom Activity a \\nleft join Activity b \\non a.player_id=b.player_id and b.event_date <= a.event_date\\ngroup by a.player_id,a.event_date\\norder by a.player_id, a.event_date desc;`"
                    },
                    {
                        "username": "hehebaby",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over (partition by player_id order by event_date) games_played_so_far\\nfrom activity\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "disha92",
                        "content": "Hi, would you mind explaining how the \\'order by\\' clause inside the partition does not include all the event dates for the prticular player id but only the event dates less than that date"
                    }
                ]
            },
            {
                "id": 1576758,
                "content": [
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect a1.player_id, a1.event_date, sum(a2.games_played) as games_played_so_far \\nfrom Activity a1, Activity a2 \\nwhere a1.player_id = a2.player_id and a2.event_date <= a1.event_date \\ngroup by a1.player_id, a1.event_date\\norder by a1.player_id, a1.event_date\\n;\\n\\nPlease make sure the inequity is **a2**.event_date <= **a1**.event_date. Think in this way: a2 is the table you want to use to carry the running sum, so you have to constrain it in the range you want to sum."
                    },
                    {
                        "username": "KenanAtMorningside",
                        "content": "\\nSELECT \\n    player_id, event_date, sum(games_played) over (partition by player_id order by event_date) as games_played_so_far \\nFROM Activity"
                    },
                    {
                        "username": "KajalJaiswal",
                        "content": "\\'\\'\\'\\nselect player_id, \\nevent_date, \\nsum(games_played) over (partition by player_id order by player_id, event_date) as games_played_so_far\\nfrom activity\\n\\'\\'\\'"
                    },
                    {
                        "username": "codeleetr",
                        "content": "# Write your MySQL query statement below\\nwith tb as\\n(select * from Activity\\norder by player_id, games_played)\\n\\nselect t1.player_id, t1.event_date,sum(t2.games_played) as games_played_so_far from tb t1\\nleft join tb t2\\non t1.player_id = t2.player_id\\nwhere t1.event_date >= t2.event_date\\ngroup by t1.player_id, t1.event_date"
                    },
                    {
                        "username": "ZYYMY",
                        "content": "\\'\\'\\'Use a simple self join based on two conditions\\n\\nSELECT a.player_id,a.event_date, SUM(b.games_played) AS games_played_so_far\\nFROM Activity AS a JOIN Activity AS b ON (a.Player_id = b.Player_id AND b.event_date<=a.event_date)\\nGROUP BY a.player_id,a.event_date"
                    },
                    {
                        "username": "jayadurga",
                        "content": "\\nselect \\n    player_id,\\n    event_date,\\n    sum(games_played) over (partition by player_id order by event_date) as games_played_so_far\\nfrom activity"
                    },
                    {
                        "username": "hhharden13",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over(partition by player_id order by event_date asc) as games_played_so_far\\nfrom Activity\\norder by player_id, event_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "meng-y",
                        "content": " `select distinct a.player_id, a.event_date,\\nifnull(sum(b.games_played),0) as games_played_so_far\\nfrom Activity a \\nleft join Activity b \\non a.player_id=b.player_id and b.event_date <= a.event_date\\ngroup by a.player_id,a.event_date\\norder by a.player_id, a.event_date desc;`"
                    },
                    {
                        "username": "hehebaby",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over (partition by player_id order by event_date) games_played_so_far\\nfrom activity\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "disha92",
                        "content": "Hi, would you mind explaining how the \\'order by\\' clause inside the partition does not include all the event dates for the prticular player id but only the event dates less than that date"
                    }
                ]
            },
            {
                "id": 1573661,
                "content": [
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect a1.player_id, a1.event_date, sum(a2.games_played) as games_played_so_far \\nfrom Activity a1, Activity a2 \\nwhere a1.player_id = a2.player_id and a2.event_date <= a1.event_date \\ngroup by a1.player_id, a1.event_date\\norder by a1.player_id, a1.event_date\\n;\\n\\nPlease make sure the inequity is **a2**.event_date <= **a1**.event_date. Think in this way: a2 is the table you want to use to carry the running sum, so you have to constrain it in the range you want to sum."
                    },
                    {
                        "username": "KenanAtMorningside",
                        "content": "\\nSELECT \\n    player_id, event_date, sum(games_played) over (partition by player_id order by event_date) as games_played_so_far \\nFROM Activity"
                    },
                    {
                        "username": "KajalJaiswal",
                        "content": "\\'\\'\\'\\nselect player_id, \\nevent_date, \\nsum(games_played) over (partition by player_id order by player_id, event_date) as games_played_so_far\\nfrom activity\\n\\'\\'\\'"
                    },
                    {
                        "username": "codeleetr",
                        "content": "# Write your MySQL query statement below\\nwith tb as\\n(select * from Activity\\norder by player_id, games_played)\\n\\nselect t1.player_id, t1.event_date,sum(t2.games_played) as games_played_so_far from tb t1\\nleft join tb t2\\non t1.player_id = t2.player_id\\nwhere t1.event_date >= t2.event_date\\ngroup by t1.player_id, t1.event_date"
                    },
                    {
                        "username": "ZYYMY",
                        "content": "\\'\\'\\'Use a simple self join based on two conditions\\n\\nSELECT a.player_id,a.event_date, SUM(b.games_played) AS games_played_so_far\\nFROM Activity AS a JOIN Activity AS b ON (a.Player_id = b.Player_id AND b.event_date<=a.event_date)\\nGROUP BY a.player_id,a.event_date"
                    },
                    {
                        "username": "jayadurga",
                        "content": "\\nselect \\n    player_id,\\n    event_date,\\n    sum(games_played) over (partition by player_id order by event_date) as games_played_so_far\\nfrom activity"
                    },
                    {
                        "username": "hhharden13",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over(partition by player_id order by event_date asc) as games_played_so_far\\nfrom Activity\\norder by player_id, event_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "meng-y",
                        "content": " `select distinct a.player_id, a.event_date,\\nifnull(sum(b.games_played),0) as games_played_so_far\\nfrom Activity a \\nleft join Activity b \\non a.player_id=b.player_id and b.event_date <= a.event_date\\ngroup by a.player_id,a.event_date\\norder by a.player_id, a.event_date desc;`"
                    },
                    {
                        "username": "hehebaby",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over (partition by player_id order by event_date) games_played_so_far\\nfrom activity\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "disha92",
                        "content": "Hi, would you mind explaining how the \\'order by\\' clause inside the partition does not include all the event dates for the prticular player id but only the event dates less than that date"
                    }
                ]
            },
            {
                "id": 1574436,
                "content": [
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect a1.player_id, a1.event_date, sum(a2.games_played) as games_played_so_far \\nfrom Activity a1, Activity a2 \\nwhere a1.player_id = a2.player_id and a2.event_date <= a1.event_date \\ngroup by a1.player_id, a1.event_date\\norder by a1.player_id, a1.event_date\\n;\\n\\nPlease make sure the inequity is **a2**.event_date <= **a1**.event_date. Think in this way: a2 is the table you want to use to carry the running sum, so you have to constrain it in the range you want to sum."
                    },
                    {
                        "username": "KenanAtMorningside",
                        "content": "\\nSELECT \\n    player_id, event_date, sum(games_played) over (partition by player_id order by event_date) as games_played_so_far \\nFROM Activity"
                    },
                    {
                        "username": "KajalJaiswal",
                        "content": "\\'\\'\\'\\nselect player_id, \\nevent_date, \\nsum(games_played) over (partition by player_id order by player_id, event_date) as games_played_so_far\\nfrom activity\\n\\'\\'\\'"
                    },
                    {
                        "username": "codeleetr",
                        "content": "# Write your MySQL query statement below\\nwith tb as\\n(select * from Activity\\norder by player_id, games_played)\\n\\nselect t1.player_id, t1.event_date,sum(t2.games_played) as games_played_so_far from tb t1\\nleft join tb t2\\non t1.player_id = t2.player_id\\nwhere t1.event_date >= t2.event_date\\ngroup by t1.player_id, t1.event_date"
                    },
                    {
                        "username": "ZYYMY",
                        "content": "\\'\\'\\'Use a simple self join based on two conditions\\n\\nSELECT a.player_id,a.event_date, SUM(b.games_played) AS games_played_so_far\\nFROM Activity AS a JOIN Activity AS b ON (a.Player_id = b.Player_id AND b.event_date<=a.event_date)\\nGROUP BY a.player_id,a.event_date"
                    },
                    {
                        "username": "jayadurga",
                        "content": "\\nselect \\n    player_id,\\n    event_date,\\n    sum(games_played) over (partition by player_id order by event_date) as games_played_so_far\\nfrom activity"
                    },
                    {
                        "username": "hhharden13",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over(partition by player_id order by event_date asc) as games_played_so_far\\nfrom Activity\\norder by player_id, event_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "meng-y",
                        "content": " `select distinct a.player_id, a.event_date,\\nifnull(sum(b.games_played),0) as games_played_so_far\\nfrom Activity a \\nleft join Activity b \\non a.player_id=b.player_id and b.event_date <= a.event_date\\ngroup by a.player_id,a.event_date\\norder by a.player_id, a.event_date desc;`"
                    },
                    {
                        "username": "hehebaby",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over (partition by player_id order by event_date) games_played_so_far\\nfrom activity\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "disha92",
                        "content": "Hi, would you mind explaining how the \\'order by\\' clause inside the partition does not include all the event dates for the prticular player id but only the event dates less than that date"
                    }
                ]
            },
            {
                "id": 1573150,
                "content": [
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect a1.player_id, a1.event_date, sum(a2.games_played) as games_played_so_far \\nfrom Activity a1, Activity a2 \\nwhere a1.player_id = a2.player_id and a2.event_date <= a1.event_date \\ngroup by a1.player_id, a1.event_date\\norder by a1.player_id, a1.event_date\\n;\\n\\nPlease make sure the inequity is **a2**.event_date <= **a1**.event_date. Think in this way: a2 is the table you want to use to carry the running sum, so you have to constrain it in the range you want to sum."
                    },
                    {
                        "username": "KenanAtMorningside",
                        "content": "\\nSELECT \\n    player_id, event_date, sum(games_played) over (partition by player_id order by event_date) as games_played_so_far \\nFROM Activity"
                    },
                    {
                        "username": "KajalJaiswal",
                        "content": "\\'\\'\\'\\nselect player_id, \\nevent_date, \\nsum(games_played) over (partition by player_id order by player_id, event_date) as games_played_so_far\\nfrom activity\\n\\'\\'\\'"
                    },
                    {
                        "username": "codeleetr",
                        "content": "# Write your MySQL query statement below\\nwith tb as\\n(select * from Activity\\norder by player_id, games_played)\\n\\nselect t1.player_id, t1.event_date,sum(t2.games_played) as games_played_so_far from tb t1\\nleft join tb t2\\non t1.player_id = t2.player_id\\nwhere t1.event_date >= t2.event_date\\ngroup by t1.player_id, t1.event_date"
                    },
                    {
                        "username": "ZYYMY",
                        "content": "\\'\\'\\'Use a simple self join based on two conditions\\n\\nSELECT a.player_id,a.event_date, SUM(b.games_played) AS games_played_so_far\\nFROM Activity AS a JOIN Activity AS b ON (a.Player_id = b.Player_id AND b.event_date<=a.event_date)\\nGROUP BY a.player_id,a.event_date"
                    },
                    {
                        "username": "jayadurga",
                        "content": "\\nselect \\n    player_id,\\n    event_date,\\n    sum(games_played) over (partition by player_id order by event_date) as games_played_so_far\\nfrom activity"
                    },
                    {
                        "username": "hhharden13",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over(partition by player_id order by event_date asc) as games_played_so_far\\nfrom Activity\\norder by player_id, event_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "meng-y",
                        "content": " `select distinct a.player_id, a.event_date,\\nifnull(sum(b.games_played),0) as games_played_so_far\\nfrom Activity a \\nleft join Activity b \\non a.player_id=b.player_id and b.event_date <= a.event_date\\ngroup by a.player_id,a.event_date\\norder by a.player_id, a.event_date desc;`"
                    },
                    {
                        "username": "hehebaby",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over (partition by player_id order by event_date) games_played_so_far\\nfrom activity\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "disha92",
                        "content": "Hi, would you mind explaining how the \\'order by\\' clause inside the partition does not include all the event dates for the prticular player id but only the event dates less than that date"
                    }
                ]
            },
            {
                "id": 1572933,
                "content": [
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect a1.player_id, a1.event_date, sum(a2.games_played) as games_played_so_far \\nfrom Activity a1, Activity a2 \\nwhere a1.player_id = a2.player_id and a2.event_date <= a1.event_date \\ngroup by a1.player_id, a1.event_date\\norder by a1.player_id, a1.event_date\\n;\\n\\nPlease make sure the inequity is **a2**.event_date <= **a1**.event_date. Think in this way: a2 is the table you want to use to carry the running sum, so you have to constrain it in the range you want to sum."
                    },
                    {
                        "username": "KenanAtMorningside",
                        "content": "\\nSELECT \\n    player_id, event_date, sum(games_played) over (partition by player_id order by event_date) as games_played_so_far \\nFROM Activity"
                    },
                    {
                        "username": "KajalJaiswal",
                        "content": "\\'\\'\\'\\nselect player_id, \\nevent_date, \\nsum(games_played) over (partition by player_id order by player_id, event_date) as games_played_so_far\\nfrom activity\\n\\'\\'\\'"
                    },
                    {
                        "username": "codeleetr",
                        "content": "# Write your MySQL query statement below\\nwith tb as\\n(select * from Activity\\norder by player_id, games_played)\\n\\nselect t1.player_id, t1.event_date,sum(t2.games_played) as games_played_so_far from tb t1\\nleft join tb t2\\non t1.player_id = t2.player_id\\nwhere t1.event_date >= t2.event_date\\ngroup by t1.player_id, t1.event_date"
                    },
                    {
                        "username": "ZYYMY",
                        "content": "\\'\\'\\'Use a simple self join based on two conditions\\n\\nSELECT a.player_id,a.event_date, SUM(b.games_played) AS games_played_so_far\\nFROM Activity AS a JOIN Activity AS b ON (a.Player_id = b.Player_id AND b.event_date<=a.event_date)\\nGROUP BY a.player_id,a.event_date"
                    },
                    {
                        "username": "jayadurga",
                        "content": "\\nselect \\n    player_id,\\n    event_date,\\n    sum(games_played) over (partition by player_id order by event_date) as games_played_so_far\\nfrom activity"
                    },
                    {
                        "username": "hhharden13",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over(partition by player_id order by event_date asc) as games_played_so_far\\nfrom Activity\\norder by player_id, event_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "meng-y",
                        "content": " `select distinct a.player_id, a.event_date,\\nifnull(sum(b.games_played),0) as games_played_so_far\\nfrom Activity a \\nleft join Activity b \\non a.player_id=b.player_id and b.event_date <= a.event_date\\ngroup by a.player_id,a.event_date\\norder by a.player_id, a.event_date desc;`"
                    },
                    {
                        "username": "hehebaby",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over (partition by player_id order by event_date) games_played_so_far\\nfrom activity\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "disha92",
                        "content": "Hi, would you mind explaining how the \\'order by\\' clause inside the partition does not include all the event dates for the prticular player id but only the event dates less than that date"
                    }
                ]
            },
            {
                "id": 1575273,
                "content": [
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect a1.player_id, a1.event_date, sum(a2.games_played) as games_played_so_far \\nfrom Activity a1, Activity a2 \\nwhere a1.player_id = a2.player_id and a2.event_date <= a1.event_date \\ngroup by a1.player_id, a1.event_date\\norder by a1.player_id, a1.event_date\\n;\\n\\nPlease make sure the inequity is **a2**.event_date <= **a1**.event_date. Think in this way: a2 is the table you want to use to carry the running sum, so you have to constrain it in the range you want to sum."
                    },
                    {
                        "username": "KenanAtMorningside",
                        "content": "\\nSELECT \\n    player_id, event_date, sum(games_played) over (partition by player_id order by event_date) as games_played_so_far \\nFROM Activity"
                    },
                    {
                        "username": "KajalJaiswal",
                        "content": "\\'\\'\\'\\nselect player_id, \\nevent_date, \\nsum(games_played) over (partition by player_id order by player_id, event_date) as games_played_so_far\\nfrom activity\\n\\'\\'\\'"
                    },
                    {
                        "username": "codeleetr",
                        "content": "# Write your MySQL query statement below\\nwith tb as\\n(select * from Activity\\norder by player_id, games_played)\\n\\nselect t1.player_id, t1.event_date,sum(t2.games_played) as games_played_so_far from tb t1\\nleft join tb t2\\non t1.player_id = t2.player_id\\nwhere t1.event_date >= t2.event_date\\ngroup by t1.player_id, t1.event_date"
                    },
                    {
                        "username": "ZYYMY",
                        "content": "\\'\\'\\'Use a simple self join based on two conditions\\n\\nSELECT a.player_id,a.event_date, SUM(b.games_played) AS games_played_so_far\\nFROM Activity AS a JOIN Activity AS b ON (a.Player_id = b.Player_id AND b.event_date<=a.event_date)\\nGROUP BY a.player_id,a.event_date"
                    },
                    {
                        "username": "jayadurga",
                        "content": "\\nselect \\n    player_id,\\n    event_date,\\n    sum(games_played) over (partition by player_id order by event_date) as games_played_so_far\\nfrom activity"
                    },
                    {
                        "username": "hhharden13",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over(partition by player_id order by event_date asc) as games_played_so_far\\nfrom Activity\\norder by player_id, event_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "meng-y",
                        "content": " `select distinct a.player_id, a.event_date,\\nifnull(sum(b.games_played),0) as games_played_so_far\\nfrom Activity a \\nleft join Activity b \\non a.player_id=b.player_id and b.event_date <= a.event_date\\ngroup by a.player_id,a.event_date\\norder by a.player_id, a.event_date desc;`"
                    },
                    {
                        "username": "hehebaby",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over (partition by player_id order by event_date) games_played_so_far\\nfrom activity\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "disha92",
                        "content": "Hi, would you mind explaining how the \\'order by\\' clause inside the partition does not include all the event dates for the prticular player id but only the event dates less than that date"
                    }
                ]
            },
            {
                "id": 1707859,
                "content": [
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect a1.player_id, a1.event_date, sum(a2.games_played) as games_played_so_far \\nfrom Activity a1, Activity a2 \\nwhere a1.player_id = a2.player_id and a2.event_date <= a1.event_date \\ngroup by a1.player_id, a1.event_date\\norder by a1.player_id, a1.event_date\\n;\\n\\nPlease make sure the inequity is **a2**.event_date <= **a1**.event_date. Think in this way: a2 is the table you want to use to carry the running sum, so you have to constrain it in the range you want to sum."
                    },
                    {
                        "username": "KenanAtMorningside",
                        "content": "\\nSELECT \\n    player_id, event_date, sum(games_played) over (partition by player_id order by event_date) as games_played_so_far \\nFROM Activity"
                    },
                    {
                        "username": "KajalJaiswal",
                        "content": "\\'\\'\\'\\nselect player_id, \\nevent_date, \\nsum(games_played) over (partition by player_id order by player_id, event_date) as games_played_so_far\\nfrom activity\\n\\'\\'\\'"
                    },
                    {
                        "username": "codeleetr",
                        "content": "# Write your MySQL query statement below\\nwith tb as\\n(select * from Activity\\norder by player_id, games_played)\\n\\nselect t1.player_id, t1.event_date,sum(t2.games_played) as games_played_so_far from tb t1\\nleft join tb t2\\non t1.player_id = t2.player_id\\nwhere t1.event_date >= t2.event_date\\ngroup by t1.player_id, t1.event_date"
                    },
                    {
                        "username": "ZYYMY",
                        "content": "\\'\\'\\'Use a simple self join based on two conditions\\n\\nSELECT a.player_id,a.event_date, SUM(b.games_played) AS games_played_so_far\\nFROM Activity AS a JOIN Activity AS b ON (a.Player_id = b.Player_id AND b.event_date<=a.event_date)\\nGROUP BY a.player_id,a.event_date"
                    },
                    {
                        "username": "jayadurga",
                        "content": "\\nselect \\n    player_id,\\n    event_date,\\n    sum(games_played) over (partition by player_id order by event_date) as games_played_so_far\\nfrom activity"
                    },
                    {
                        "username": "hhharden13",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over(partition by player_id order by event_date asc) as games_played_so_far\\nfrom Activity\\norder by player_id, event_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "meng-y",
                        "content": " `select distinct a.player_id, a.event_date,\\nifnull(sum(b.games_played),0) as games_played_so_far\\nfrom Activity a \\nleft join Activity b \\non a.player_id=b.player_id and b.event_date <= a.event_date\\ngroup by a.player_id,a.event_date\\norder by a.player_id, a.event_date desc;`"
                    },
                    {
                        "username": "hehebaby",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over (partition by player_id order by event_date) games_played_so_far\\nfrom activity\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "disha92",
                        "content": "Hi, would you mind explaining how the \\'order by\\' clause inside the partition does not include all the event dates for the prticular player id but only the event dates less than that date"
                    }
                ]
            },
            {
                "id": 1575939,
                "content": [
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect a1.player_id, a1.event_date, sum(a2.games_played) as games_played_so_far \\nfrom Activity a1, Activity a2 \\nwhere a1.player_id = a2.player_id and a2.event_date <= a1.event_date \\ngroup by a1.player_id, a1.event_date\\norder by a1.player_id, a1.event_date\\n;\\n\\nPlease make sure the inequity is **a2**.event_date <= **a1**.event_date. Think in this way: a2 is the table you want to use to carry the running sum, so you have to constrain it in the range you want to sum."
                    },
                    {
                        "username": "KenanAtMorningside",
                        "content": "\\nSELECT \\n    player_id, event_date, sum(games_played) over (partition by player_id order by event_date) as games_played_so_far \\nFROM Activity"
                    },
                    {
                        "username": "KajalJaiswal",
                        "content": "\\'\\'\\'\\nselect player_id, \\nevent_date, \\nsum(games_played) over (partition by player_id order by player_id, event_date) as games_played_so_far\\nfrom activity\\n\\'\\'\\'"
                    },
                    {
                        "username": "codeleetr",
                        "content": "# Write your MySQL query statement below\\nwith tb as\\n(select * from Activity\\norder by player_id, games_played)\\n\\nselect t1.player_id, t1.event_date,sum(t2.games_played) as games_played_so_far from tb t1\\nleft join tb t2\\non t1.player_id = t2.player_id\\nwhere t1.event_date >= t2.event_date\\ngroup by t1.player_id, t1.event_date"
                    },
                    {
                        "username": "ZYYMY",
                        "content": "\\'\\'\\'Use a simple self join based on two conditions\\n\\nSELECT a.player_id,a.event_date, SUM(b.games_played) AS games_played_so_far\\nFROM Activity AS a JOIN Activity AS b ON (a.Player_id = b.Player_id AND b.event_date<=a.event_date)\\nGROUP BY a.player_id,a.event_date"
                    },
                    {
                        "username": "jayadurga",
                        "content": "\\nselect \\n    player_id,\\n    event_date,\\n    sum(games_played) over (partition by player_id order by event_date) as games_played_so_far\\nfrom activity"
                    },
                    {
                        "username": "hhharden13",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over(partition by player_id order by event_date asc) as games_played_so_far\\nfrom Activity\\norder by player_id, event_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "meng-y",
                        "content": " `select distinct a.player_id, a.event_date,\\nifnull(sum(b.games_played),0) as games_played_so_far\\nfrom Activity a \\nleft join Activity b \\non a.player_id=b.player_id and b.event_date <= a.event_date\\ngroup by a.player_id,a.event_date\\norder by a.player_id, a.event_date desc;`"
                    },
                    {
                        "username": "hehebaby",
                        "content": "\\'\\'\\'\\nselect player_id, event_date, sum(games_played) over (partition by player_id order by event_date) games_played_so_far\\nfrom activity\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "disha92",
                        "content": "Hi, would you mind explaining how the \\'order by\\' clause inside the partition does not include all the event dates for the prticular player id but only the event dates less than that date"
                    }
                ]
            }
        ]
    },
    {
        "title": "Encode and Decode TinyURL",
        "question_content": "<blockquote>Note: This is a companion problem to the <a href=\"https://leetcode.com/discuss/interview-question/system-design/\" target=\"_blank\">System Design</a> problem: <a href=\"https://leetcode.com/discuss/interview-question/124658/Design-a-URL-Shortener-(-TinyURL-)-System/\" target=\"_blank\">Design TinyURL</a>.</blockquote>\n\n<p>TinyURL is a URL shortening service where you enter a URL such as <code>https://leetcode.com/problems/design-tinyurl</code> and it returns a short URL such as <code>http://tinyurl.com/4e9iAk</code>. Design a class to encode a URL and decode a tiny URL.</p>\n\n<p>There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</p>\n\n<p>Implement the <code>Solution</code> class:</p>\n\n<ul>\n\t<li><code>Solution()</code> Initializes the object of the system.</li>\n\t<li><code>String encode(String longUrl)</code> Returns a tiny URL for the given <code>longUrl</code>.</li>\n\t<li><code>String decode(String shortUrl)</code> Returns the original long URL for the given <code>shortUrl</code>. It is guaranteed that the given <code>shortUrl</code> was encoded by the same object.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> url = &quot;https://leetcode.com/problems/design-tinyurl&quot;\n<strong>Output:</strong> &quot;https://leetcode.com/problems/design-tinyurl&quot;\n\n<strong>Explanation:</strong>\nSolution obj = new Solution();\nstring tiny = obj.encode(url); // returns the encoded tiny url.\nstring ans = obj.decode(tiny); // returns the original url after decoding it.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= url.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>url</code> is guranteed to be a valid URL.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 100268,
                "title": "two-solutions-and-thoughts",
                "content": "My first solution produces short URLs like `http://tinyurl.com/0`, `http://tinyurl.com/1`, etc, in that order.\\n```\\nclass Codec:\\n\\n    def __init__(self):\\n        self.urls = []\\n\\n    def encode(self, longUrl):\\n        self.urls.append(longUrl)\\n        return 'http://tinyurl.com/' + str(len(self.urls) - 1)\\n\\n    def decode(self, shortUrl):\\n        return self.urls[int(shortUrl.split('/')[-1])]\\n```\\nUsing increasing numbers as codes like that is simple but has some disadvantages, which the below solution fixes:\\n- If I'm asked to encode the same long URL several times, it will get several entries. That wastes codes and memory.\\n- People can find out how many URLs have already been encoded. Not sure I want them to know.\\n- People might try to get special numbers by spamming me with repeated requests shortly before their desired number comes up.\\n- Only using digits means the codes can grow unnecessarily large. Only offers a million codes with length 6 (or smaller). Using six digits or lower or upper case letters would offer (10+26*2)<sup>6</sup> = 56,800,235,584 codes with length 6.\\n\\nThe following solution doesn't have these problems. It produces short URLs like `http://tinyurl.com/KtLa2U`, using a random code of six digits or letters. If a long URL is already known, the existing short URL is used and no new entry is generated.\\n```\\nclass Codec:\\n\\n    alphabet = string.ascii_letters + '0123456789'\\n\\n    def __init__(self):\\n        self.url2code = {}\\n        self.code2url = {}\\n\\n    def encode(self, longUrl):\\n        while longUrl not in self.url2code:\\n            code = ''.join(random.choice(Codec.alphabet) for _ in range(6))\\n            if code not in self.code2url:\\n                self.code2url[code] = longUrl\\n                self.url2code[longUrl] = code\\n        return 'http://tinyurl.com/' + self.url2code[longUrl]\\n\\n    def decode(self, shortUrl):\\n        return self.code2url[shortUrl[-6:]]\\n```\\nIt's possible that a randomly generated code has already been generated before. In that case, another random code is generated instead. Repeat until we have a code that's not already in use. How long can this take? Well, even if we get up to using half of the code space, which is a whopping 62<sup>6</sup>/2 = 28,400,117,792 entries, then each code has a 50% chance of not having appeared yet. So the expected/average number of attempts is 2, and for example only one in a billion URLs takes more than 30 attempts. And if we ever get to an even larger number of entries and this does become a problem, then we can just use length 7. We'd need to anyway, as we'd be running out of available codes.",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n\\n    def __init__(self):\\n        self.urls = []\\n\\n    def encode(self, longUrl):\\n        self.urls.append(longUrl)\\n        return 'http://tinyurl.com/' + str(len(self.urls) - 1)\\n\\n    def decode(self, shortUrl):\\n        return self.urls[int(shortUrl.split('/')[-1])]\\n```\n```\\nclass Codec:\\n\\n    alphabet = string.ascii_letters + '0123456789'\\n\\n    def __init__(self):\\n        self.url2code = {}\\n        self.code2url = {}\\n\\n    def encode(self, longUrl):\\n        while longUrl not in self.url2code:\\n            code = ''.join(random.choice(Codec.alphabet) for _ in range(6))\\n            if code not in self.code2url:\\n                self.code2url[code] = longUrl\\n                self.url2code[longUrl] = code\\n        return 'http://tinyurl.com/' + self.url2code[longUrl]\\n\\n    def decode(self, shortUrl):\\n        return self.code2url[shortUrl[-6:]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100280,
                "title": "a-true-stateless-one-in-c-joke",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110551,
                "title": "js-python-java-c-easy-map-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSince the characters we can use in the short url are limited just as much as the characters that can be used to make up the long url, there\\'s not much legitimate compression that can realistically be done.\\n\\nThe only generally feasible option is to use a **map** to act as a lookup table for codes and either use a hashing function or a random code generator to generate the **code**. Since we\\'re storing the information anyway (hashes only work one-way), we might as well just use a random code generator (**getCode()**).\\n\\nBased on the example, we can create a function that creates a random **6**-character code, using the **62 alphanumeric characters**. We should make sure to come up with a new code in the rare case that we randomly create a duplicate.\\n\\nTo avoid having to **encode** the same url twice with different random codes, we can create a reverse lookup table (**urlDB**) to store already encoded urls.\\n\\nThe **decode** function will just **return** the entry from the code map (**codeDB**).\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython has predefined alphanumeric strings, so we can take advantage of that.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 40.3MB** (beats 99% / 61%).\\n```javascript\\nlet codeDB = new Map(), urlDB = new Map()\\nconst chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\\n\\nconst getCode = () => {\\n    let code = new Array(6).fill()\\n        .map(_ => chars.charAt(~~(Math.random() * 62)))\\n    return \"http://tinyurl.com/\" + code.join(\"\")\\n}\\n\\nconst encode = longUrl => {\\n    if (urlDB.has(longUrl)) return urlDB.get(longUrl)\\n    let code = getCode()\\n    while (codeDB.has(code)) code = getCode()\\n    codeDB.set(code, longUrl)\\n    urlDB.set(longUrl, code)\\n    return code\\n}\\n\\nconst decode = shortUrl => codeDB.get(shortUrl)\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.1MB** (beats 98% / 82%).\\n```python\\nclass Codec:\\n    codeDB, urlDB = defaultdict(), defaultdict()\\n    chars = string.ascii_letters + string.digits\\n\\n    def getCode(self) -> str:\\n        code = \\'\\'.join(random.choice(self.chars) for i in range(6))\\n        return \"http://tinyurl.com/\" + code\\n \\n    def encode(self, longUrl: str) -> str:\\n        if longUrl in self.urlDB: return self.urlDB[longUrl]\\n        code = self.getCode()\\n        while code in self.codeDB: code = getCode()\\n        self.codeDB[code] = longUrl\\n        self.urlDB[longUrl] = code\\n        return code\\n\\n    def decode(self, shortUrl: str) -> str:\\n        return self.codeDB[shortUrl]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **3ms / 38.7MB** (beats 83% / 99%).\\n```java\\npublic class Codec {\\n    Map<String, String> codeDB = new HashMap<>(), urlDB = new HashMap<>();\\n    static final String chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n\\n    private String getCode() {\\n        char[] code = new char[6];\\n        for (int i = 0; i < 6; i++) \\n            code[i] = chars.charAt((int)Math.random() * 62);\\n        return \"http://tinyurl.com/\" + String.valueOf(code);\\n    }\\n    \\n    public String encode(String longUrl) {\\n        if (urlDB.containsKey(longUrl)) return urlDB.get(longUrl);\\n        String code = getCode();\\n        while (codeDB.containsKey(code)) code = getCode();\\n        codeDB.put(code, longUrl);\\n        urlDB.put(longUrl, code);\\n        return code;\\n    }\\n\\n    public String decode(String shortUrl) {\\n        return codeDB.get(shortUrl);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.3MB** (beats 100% / 42%).\\n```c++\\nclass Solution {\\npublic:\\n    unordered_map<string, string> codeDB, urlDB;\\n    const string chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n    \\n    string getCode() {\\n        string code = \"\";\\n        for (int i = 0; i < 6; i++) code += chars[rand() % 62];\\n        return \"http://tinyurl.com/\" + code;\\n    }\\n    \\n    string encode(string longUrl) {\\n        if (urlDB.find(longUrl) != urlDB.end()) return urlDB[longUrl];\\n        string code = getCode();\\n        while (codeDB.find(code) != codeDB.end()) code = getCode();\\n        codeDB[code] = longUrl;\\n        urlDB[longUrl] = code;\\n        return code;\\n    }\\n\\n    string decode(string shortUrl) {\\n        return codeDB[shortUrl];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nlet codeDB = new Map(), urlDB = new Map()\\nconst chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\\n\\nconst getCode = () => {\\n    let code = new Array(6).fill()\\n        .map(_ => chars.charAt(~~(Math.random() * 62)))\\n    return \"http://tinyurl.com/\" + code.join(\"\")\\n}\\n\\nconst encode = longUrl => {\\n    if (urlDB.has(longUrl)) return urlDB.get(longUrl)\\n    let code = getCode()\\n    while (codeDB.has(code)) code = getCode()\\n    codeDB.set(code, longUrl)\\n    urlDB.set(longUrl, code)\\n    return code\\n}\\n\\nconst decode = shortUrl => codeDB.get(shortUrl)\\n```\n```python\\nclass Codec:\\n    codeDB, urlDB = defaultdict(), defaultdict()\\n    chars = string.ascii_letters + string.digits\\n\\n    def getCode(self) -> str:\\n        code = \\'\\'.join(random.choice(self.chars) for i in range(6))\\n        return \"http://tinyurl.com/\" + code\\n \\n    def encode(self, longUrl: str) -> str:\\n        if longUrl in self.urlDB: return self.urlDB[longUrl]\\n        code = self.getCode()\\n        while code in self.codeDB: code = getCode()\\n        self.codeDB[code] = longUrl\\n        self.urlDB[longUrl] = code\\n        return code\\n\\n    def decode(self, shortUrl: str) -> str:\\n        return self.codeDB[shortUrl]\\n```\n```java\\npublic class Codec {\\n    Map<String, String> codeDB = new HashMap<>(), urlDB = new HashMap<>();\\n    static final String chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n\\n    private String getCode() {\\n        char[] code = new char[6];\\n        for (int i = 0; i < 6; i++) \\n            code[i] = chars.charAt((int)Math.random() * 62);\\n        return \"http://tinyurl.com/\" + String.valueOf(code);\\n    }\\n    \\n    public String encode(String longUrl) {\\n        if (urlDB.containsKey(longUrl)) return urlDB.get(longUrl);\\n        String code = getCode();\\n        while (codeDB.containsKey(code)) code = getCode();\\n        codeDB.put(code, longUrl);\\n        urlDB.put(longUrl, code);\\n        return code;\\n    }\\n\\n    public String decode(String shortUrl) {\\n        return codeDB.get(shortUrl);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    unordered_map<string, string> codeDB, urlDB;\\n    const string chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n    \\n    string getCode() {\\n        string code = \"\";\\n        for (int i = 0; i < 6; i++) code += chars[rand() % 62];\\n        return \"http://tinyurl.com/\" + code;\\n    }\\n    \\n    string encode(string longUrl) {\\n        if (urlDB.find(longUrl) != urlDB.end()) return urlDB[longUrl];\\n        string code = getCode();\\n        while (codeDB.find(code) != codeDB.end()) code = getCode();\\n        codeDB[code] = longUrl;\\n        urlDB[longUrl] = code;\\n        return code;\\n    }\\n\\n    string decode(string shortUrl) {\\n        return codeDB[shortUrl];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974231,
                "title": "tell-this-to-interviewer-not-expected-at-all",
                "content": "DO NOT **DOWN** **VOTE** IT Please\\uD83D\\uDE02\\uD83D\\uDE02\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring encode(string longUrl) {\\n\\t\\t\\treturn longUrl;\\n\\t\\t}\\n\\t\\tstring decode(string shortUrl) {\\n\\t\\t   return shortUrl;   \\n\\t\\t}\\n\\t};\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring encode(string longUrl) {\\n\\t\\t\\treturn longUrl;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 100276,
                "title": "easy-solution-in-java-5-line-code",
                "content": "below is the tiny url solution in java, also this is the similar method in industry. In industry, most of shorten url service is by database, one auto increasing long number as primary key. whenever a long url need to be shorten, append to the database, and return the primary key number. (the database is very easy to distribute to multiple machine like HBase,  or even you can use the raw file system to store data and improve performance by shard and replica).\\nNote, it's meaningless to promise the same long url to be shorten as the same short url. if you do the promise and use something like hash to check existing, the benefit is must less than the cost.\\nNote: if you want the shorted url contains '0-9a-zA-Z' instead of '0-9', then you need to use 62 number system, not 10 number system(decimal) to convert the primary key number. like 123->'123' in decimal, 123->'1Z' in 62 number system (or '0001Z' for align).\\n\\n```\\npublic class Codec {\\n    List<String> urls = new ArrayList<String>();\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        urls.add(longUrl);\\n        return String.valueOf(urls.size()-1);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        int index = Integer.valueOf(shortUrl);\\n        return (index<urls.size())?urls.get(index):\"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    List<String> urls = new ArrayList<String>();\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        urls.add(longUrl);\\n        return String.valueOf(urls.size()-1);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        int index = Integer.valueOf(shortUrl);\\n        return (index<urls.size())?urls.get(index):\"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110529,
                "title": "python-use-two-dictionaries-explained",
                "content": "The idea of this problem is the following: let us keep `2` dictinoaries:\\n1. `self.long_short` to keep links between original long address and encoded short address.\\n2. `self.short_long` to keep the opposit connections.\\n\\nWhy we need to keep both dictionaries? Because we want to do fast encoding and decoding.\\n\\n1.`encode(self, longUrl)` will work like this: let us try to generate random `code`, say with `6` symbols, which consists of letters. If this code was not used for some other long link, we are happy: we put connections to our direct and inverse dictionaries. If it happen, that this code was used for some other long link, we are not happy, and we generate one more code and so on.\\n2.`decode(self, shortUrl)` is pretty straightforward: we just look at our `selfl.short_long` dictionary.\\n\\n**Complexity**: time complexity of one encoding and decoding is `O(n + m)`, where `n` is length of original string and `m` is length of encoded strigng, if we assume that probability of collision is small enough. So, what is probability of collision: we have `26^6` approx `N = 3*10^8` different options, and if we use **Birthday problem**, than if you have `T = 1000` different strings to encode we will have `(1-1/N)*(1-2/N)*...(1-(T-1)/N)` probability to not have a collision, which is very close to `1`. In fact, we need to choose `T`, such that `T^2 << N`, and in this case probability can be approximated as `exp(T^2/2*N)`, which in our case equal to `exp(-1/300)` approx `(1 - 1/300)`.\\n\\n```\\nclass Codec:\\n    def __init__(self):\\n        self.long_short = {}\\n        self.short_long = {}\\n        self.alphabet = \"abcdefghijklmnopqrstuvwzyz\"\\n\\n    def encode(self, longUrl):\\n        while longUrl not in self.long_short:\\n            code = \"\".join(choices(self.alphabet, k=6))\\n            if code not in self.short_long:\\n                self.short_long[code] = longUrl\\n                self.long_short[longUrl] = code\\n        return \\'http://tinyurl.com/\\' + self.long_short[longUrl]\\n\\n    def decode(self, shortUrl):\\n        return self.short_long[shortUrl[-6:]]\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n    def __init__(self):\\n        self.long_short = {}\\n        self.short_long = {}\\n        self.alphabet = \"abcdefghijklmnopqrstuvwzyz\"\\n\\n    def encode(self, longUrl):\\n        while longUrl not in self.long_short:\\n            code = \"\".join(choices(self.alphabet, k=6))\\n            if code not in self.short_long:\\n                self.short_long[code] = longUrl\\n                self.long_short[longUrl] = code\\n        return \\'http://tinyurl.com/\\' + self.long_short[longUrl]\\n\\n    def decode(self, shortUrl):\\n        return self.short_long[shortUrl[-6:]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100270,
                "title": "three-different-approaches-in-java",
                "content": "Approach 1- Using simple counter\\n```\\npublic class Codec {\\n    Map<Integer, String> map = new HashMap<>();\\n    int i=0;\\n    public String encode(String longUrl) {\\n        map.put(i,longUrl);\\n        return \"http://tinyurl.com/\"+i++;\\n    }\\n    public String decode(String shortUrl) {\\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\\n    }\\n}\\n```\\nApproach 2- using hashcode\\n```\\npublic class Codec {\\n    Map<Integer, String> map = new HashMap<>();\\n    public String encode(String longUrl) {\\n        map.put(longUrl.hashCode(),longUrl);\\n        return \"http://tinyurl.com/\"+longUrl.hashCode();\\n    }\\n    public String decode(String shortUrl) {\\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\\n    }\\n}\\n```\\n\\nApproach 3- using random function\\n\\n```\\npublic class Codec {\\n    Map<Integer, String> map = new HashMap<>();\\n    Random r=new Random();\\n    int key=r.nextInt(10000);\\n    public String encode(String longUrl) {\\n        while(map.containsKey(key))\\n            key= r.nextInt(10000);\\n        map.put(key,longUrl);\\n        return \"http://tinyurl.com/\"+key;\\n    }\\n    public String decode(String shortUrl) {\\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    Map<Integer, String> map = new HashMap<>();\\n    int i=0;\\n    public String encode(String longUrl) {\\n        map.put(i,longUrl);\\n        return \"http://tinyurl.com/\"+i++;\\n    }\\n    public String decode(String shortUrl) {\\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\\n    }\\n}\\n```\n```\\npublic class Codec {\\n    Map<Integer, String> map = new HashMap<>();\\n    public String encode(String longUrl) {\\n        map.put(longUrl.hashCode(),longUrl);\\n        return \"http://tinyurl.com/\"+longUrl.hashCode();\\n    }\\n    public String decode(String shortUrl) {\\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\\n    }\\n}\\n```\n```\\npublic class Codec {\\n    Map<Integer, String> map = new HashMap<>();\\n    Random r=new Random();\\n    int key=r.nextInt(10000);\\n    public String encode(String longUrl) {\\n        while(map.containsKey(key))\\n            key= r.nextInt(10000);\\n        map.put(key,longUrl);\\n        return \"http://tinyurl.com/\"+key;\\n    }\\n    public String decode(String shortUrl) {\\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973804,
                "title": "easyyyyyy-explaination",
                "content": "In the problem we have given something like this,\\n<hr>\\n<hr>\\n\\nActuall Url :- **`https://leetcode.com/problems/design-tinyurl`**\\n\\nShort Url :- **`http://tinyurl.com/4e9iAk`**\\n\\n<hr>\\n<hr>\\n\\nNow to short the url we don\\'t have to worry about this part ~~http://tinyurl.com/~~ **4e9iAk** just focus on this highlighted part. Because that one, will provided by itself. They are just confusing you, *to be honest*.\\n\\nNow, in order to short this url, we have 2 properties to keep in mind.\\n* We have to return **nLength**Random String. Where **n** is a variable\\n\\n\\n* The generated Random string has to be unique. What I mean is, it\\'s not has to be assigned with someone.\\n\\n```\\nlong  \\\\\\n        \\\\\\n\\t      Short         \"This is inValid\"                           long --> short        \"This is Valid\"\\n\\t    /\\nlong  /\\n```\\n\\nSo, if we solve these properties problem, we will generate our String.\\n\\n1. Our First job, is we have to do is 1 to 1 Mapping. And that is possible by our HashMap. \\n  HashMap<String, String> Where 1st String represent **tinyUrly** & 2nd String represent **longUrl**\\n   \\n    When we are generate random string, we have to keep few things in mind. \\n```\\nRandom String :- (a) check is this tinyUrl already exist in our map??\\nIf yes, then generate one more (a3), againcheck is this already exist??\\nIf yes, then again generate & if no, assigned it with a longUrl\\n```\\n**And if someone gives us Short Url, we go into the map & check the longUrl whatever present in correspond to it, return that**\\n\\n2. Now how we build random string!!\\n    So, firstly we create a empty string & create that using StringBuilder & we add random values into it.\\n\\t**Random ->** using `Math.random` what math.random gives us a range of random generated no. b/w `0 - 1` **E.g :-** 0.513, 0.214....\\n\\t\\n\\tBut we have to store something like let\\'s say **3**, so what we can do is multiply it by 10 & our range become from `0 - 10`\\n\\t\\n\\tBut, if we multiply it by 100 our range become `0 - 100` & if we typecast with **(char)** the range will falls in **`ASCII Value`**\\n\\t\\n\\tAs, if you look at the **`ASCII`** chart. You\\'ll se that in total we have 128 characters. But we are using approx. of 100\\n\\t\\n\\t![image](https://assets.leetcode.com/users/images/c549f919-8a61-45b8-bad1-99a5a67ce864_1650682086.0516636.png)\\n\\nBut, still there is a problem let\\'s say by random we get 0.5534 & we are X100. So, it will become 55.34 but no value is assign such as 55.34 in ASCII chart. So, for that we will round of it to 55.\\n\\n**And that\\'s how we solve the problem**\\n\\n*I hope ladie\\'s - n - gentlemen this problem is absolute clear.* **Let\\'s code it up**\\n```\\npublic class Codec {\\n    Map<String, String> map = new HashMap<>();\\n    StringBuilder sb = new StringBuilder();\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        sb.append((char)Math.floor(Math.random() * 100));\\n        while(map.containsKey(sb.toString())){\\n            sb.append((char)Math.floor(Math.random() * 100));\\n        }\\n        map.put(sb.toString(), longUrl);\\n        return sb.toString();\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong  \\\\\\n        \\\\\\n\\t      Short         \"This is inValid\"                           long --> short        \"This is Valid\"\\n\\t    /\\nlong  /\\n```\n```\\nRandom String :- (a) check is this tinyUrl already exist in our map??\\nIf yes, then generate one more (a3), againcheck is this already exist??\\nIf yes, then again generate & if no, assigned it with a longUrl\\n```\n```\\npublic class Codec {\\n    Map<String, String> map = new HashMap<>();\\n    StringBuilder sb = new StringBuilder();\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        sb.append((char)Math.floor(Math.random() * 100));\\n        while(map.containsKey(sb.toString())){\\n            sb.append((char)Math.floor(Math.random() * 100));\\n        }\\n        map.put(sb.toString(), longUrl);\\n        return sb.toString();\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254145,
                "title": "java-solutions",
                "content": "**Solution 1: Using hashCode**\\n\\n- A Simple Solution could be Hashing. We can use a hash function to convert long string to short string. \\n- In hashing, there may be collisions, i.e., two long `URLs` can map to same short `URL`. But we need a unique short `URL` for every long `URL` so that we can access long `URL` back.\\n\\nTime complexity: `O(n)` for `encode()` method and `O(1)` for `decode()` method. Since the `hashCode` method takes `O(n)` time to generate the `hashCode` of the string of length `n`.\\nSpace complexity: `O(m)` - where `m` is the number of entries in the `HashMap`. i.e., the number of `shortURLs` generated so far.\\n\\n```\\nclass Codec\\n{\\n\\tstatic final Map<String, String> map = new HashMap<>();\\n    static final String BASE_HOST = \"http://tinyurl.com/\";\\n\\n    public String encode(String longUrl)\\n\\t{\\n\\t\\tString shortUrl = BASE_HOST + longUrl.hashCode();\\n\\t\\tmap.put(shortUrl, longUrl);\\n\\t\\treturn shortUrl;\\n    }\\n\\n    public String decode(String shortUrl)\\n\\t{\\n\\t\\treturn map.get(shortUrl);\\n    }\\n}\\n```\\n\\n**Solution 2: Assign Unique Integer Id and Convert it to base-62**\\n\\n- A better idea is to assign a unique integer id to each long `URL` representation and convert this integer id to its `base-62` representation. \\n\\n- A URL character can be one of the following\\n  1. Lower case alphabet [`a` to `z`], total `26` characters\\n  2. Upper case alphabet [`A` to `Z`], total `26` characters\\n  3. Digit [`0` to `9`], total `10` characters\\n- So there are total `26 + 26 + 10 = 62` possible characters and hence the task is to convert a decimal number to base `62` number.\\n- To get the original long `URL`, we need to get `URL` stored in the `Map`.\\n\\nTime complexity: `O(log n)` for `encode()` method and `O(1)` for `decode()` method. To covert decimal integer id `n` to its `base-62` representation will take O(log<sub>62</sub>(n)) time.\\nSpace complexity: `O(m)` - where `m` is the number of entries in the `HashMap`. i.e., the number of `shortURLs` generated so far.\\n\\n```\\nclass Codec\\n{\\n\\tstatic final String BASE_HOST = \"http://tinyurl.com/\";\\n\\tstatic final Map<String, String> shortToLongMap = new HashMap<>();\\n    static final Map<String, String> longToShortMap = new HashMap<>();\\n    static int counter = 0;\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl)\\n\\t{\\n        if(longToShortMap.containsKey(longUrl))\\n            return longToShortMap.get(longUrl);\\n        \\n        String shortUrl = BASE_HOST + convertDecimalToBase62(counter++);\\n        shortToLongMap.put(shortUrl, longUrl);\\n        longToShortMap.put(longUrl, shortUrl);\\n        return shortUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl)\\n\\t{\\n        return shortToLongMap.get(shortUrl);\\n    }\\n    \\n    private String convertDecimalToBase62(int n)\\n    {\\n        final char[] BASE62 = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\".toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        \\n\\t\\twhile(n > 0)\\n\\t\\t{\\n            sb.append(BASE62[n % 62]);\\n            n /= 62;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n\\n**Solution 3: Assign a Random base-62 id of K digits.**\\n\\n```\\nimport java.util.concurrent.ThreadLocalRandom;\\n\\nclass Codec\\n{\\n    static final Map<String, String> shortToLongMap = new HashMap<String, String>();\\n    static final Map<String, String> LongToShortMap = new HashMap<String, String>();\\n    static final String BASE_HOST = \"http://tinyurl.com/\";\\n    static final int K = 6;\\n    \\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl)\\n\\t{\\n        if(LongToShortMap.containsKey(longUrl))\\n\\t\\t\\treturn LongToShortMap.get(longUrl);\\n\\n        String shortUrl = generateRandomShortUrl();\\n        \\n        while(shortToLongMap.containsKey(shortUrl));\\n            shortUrl = generateRandomShortUrl();\\n\\n\\t\\tshortToLongMap.put(shortUrl, longUrl);\\n        LongToShortMap.put(longUrl, shortUrl);\\n        return shortUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl)\\n\\t{\\n        return shortToLongMap.get(shortUrl);\\n    }\\n    \\n    private String generateRandomShortUrl()\\n    {\\n        final String BASE62 = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < K; i++)\\n        {\\n            int randomIndex = ThreadLocalRandom.current().nextInt(0, BASE62.length());\\n            sb.append(BASE62.charAt(randomIndex));\\n        }\\n        String shortUrl = BASE_HOST + sb.toString();\\n        return shortUrl;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec\\n{\\n\\tstatic final Map<String, String> map = new HashMap<>();\\n    static final String BASE_HOST = \"http://tinyurl.com/\";\\n\\n    public String encode(String longUrl)\\n\\t{\\n\\t\\tString shortUrl = BASE_HOST + longUrl.hashCode();\\n\\t\\tmap.put(shortUrl, longUrl);\\n\\t\\treturn shortUrl;\\n    }\\n\\n    public String decode(String shortUrl)\\n\\t{\\n\\t\\treturn map.get(shortUrl);\\n    }\\n}\\n```\n```\\nclass Codec\\n{\\n\\tstatic final String BASE_HOST = \"http://tinyurl.com/\";\\n\\tstatic final Map<String, String> shortToLongMap = new HashMap<>();\\n    static final Map<String, String> longToShortMap = new HashMap<>();\\n    static int counter = 0;\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl)\\n\\t{\\n        if(longToShortMap.containsKey(longUrl))\\n            return longToShortMap.get(longUrl);\\n        \\n        String shortUrl = BASE_HOST + convertDecimalToBase62(counter++);\\n        shortToLongMap.put(shortUrl, longUrl);\\n        longToShortMap.put(longUrl, shortUrl);\\n        return shortUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl)\\n\\t{\\n        return shortToLongMap.get(shortUrl);\\n    }\\n    \\n    private String convertDecimalToBase62(int n)\\n    {\\n        final char[] BASE62 = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\".toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        \\n\\t\\twhile(n > 0)\\n\\t\\t{\\n            sb.append(BASE62[n % 62]);\\n            n /= 62;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```\n```\\nimport java.util.concurrent.ThreadLocalRandom;\\n\\nclass Codec\\n{\\n    static final Map<String, String> shortToLongMap = new HashMap<String, String>();\\n    static final Map<String, String> LongToShortMap = new HashMap<String, String>();\\n    static final String BASE_HOST = \"http://tinyurl.com/\";\\n    static final int K = 6;\\n    \\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl)\\n\\t{\\n        if(LongToShortMap.containsKey(longUrl))\\n\\t\\t\\treturn LongToShortMap.get(longUrl);\\n\\n        String shortUrl = generateRandomShortUrl();\\n        \\n        while(shortToLongMap.containsKey(shortUrl));\\n            shortUrl = generateRandomShortUrl();\\n\\n\\t\\tshortToLongMap.put(shortUrl, longUrl);\\n        LongToShortMap.put(longUrl, shortUrl);\\n        return shortUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl)\\n\\t{\\n        return shortToLongMap.get(shortUrl);\\n    }\\n    \\n    private String generateRandomShortUrl()\\n    {\\n        final String BASE62 = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < K; i++)\\n        {\\n            int randomIndex = ThreadLocalRandom.current().nextInt(0, BASE62.length());\\n            sb.append(BASE62.charAt(randomIndex));\\n        }\\n        String shortUrl = BASE_HOST + sb.toString();\\n        return shortUrl;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110674,
                "title": "encode-and-decode-tinyurl-short-easy-w-explanation",
                "content": "***Solution - I (Just to pass)***\\n\\nIf you just want to solve the question, here you go -\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```\\n\\n----------\\n----------\\n\\n***Solution - II***\\n\\nHere\\'s a better, more practical and robust solution which could be applied in real-world - \\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, string>UrlToCode, codeToUrl;\\n    string alphanumeric, base;    \\n\\t//                   \\uD83D\\uDD3Bs = secure = important! :)\\n    Solution(): base(\"https://tinyurl.com/\"),\\n    alphanumeric(\"abcdefghijklmnopqrstuvwxyzAbCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\") {\\n        srand(time(0)); // seed for random generator used by rand()\\n    }\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        // if encoded url already exists for a given longUrl (dont want duplicates for same url)\\n        if(UrlToCode.count(longUrl)) return base + UrlToCode[longUrl];\\n        string code = \"\";\\n        // generate a random code from alphanumeric string\\n        while(1){\\n            for(int i = 0; i < 6; i++)\\n                code += alphanumeric[rand() % 62];\\n            // if new code is formed, break out of loop\\n            if(!codeToUrl.count(code)) break; \\n            code = \"\";   // loop back to generate a new unique code\\n        }\\n        string encoded = base + code;\\n        UrlToCode[longUrl] = code;    // store longUrl to code mapping to avoid duplicates        \\n        codeToUrl[encoded] = longUrl; // to decode shortened url back to original\\n        return encoded;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return codeToUrl[shortUrl];\\n    }\\n};\\n```\\n\\nThe above code would need to try and generate a new code every time the randomly generated string is found to be already allocated. In theory, it could be possible that the algorithm takes infinite time to generate a shortened Url but I would put the probability of that to be about the same as all the vibrating atoms in your chairs aligning sideways to make you fall \\uD83E\\uDD37\\u200D\\uD83D\\uDE47.\\n\\n\\nSince our code space is huge (`62^6`), it is very unlikely that it would many iterations. We could always increase the `code` length to 7 or 8 to reduce collisions even further but it\\'s not really unnecessary.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, string>UrlToCode, codeToUrl;\\n    string alphanumeric, base;    \\n\\t//                   \\uD83D\\uDD3Bs = secure = important! :)\\n    Solution(): base(\"https://tinyurl.com/\"),\\n    alphanumeric(\"abcdefghijklmnopqrstuvwxyzAbCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\") {\\n        srand(time(0)); // seed for random generator used by rand()\\n    }\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        // if encoded url already exists for a given longUrl (dont want duplicates for same url)\\n        if(UrlToCode.count(longUrl)) return base + UrlToCode[longUrl];\\n        string code = \"\";\\n        // generate a random code from alphanumeric string\\n        while(1){\\n            for(int i = 0; i < 6; i++)\\n                code += alphanumeric[rand() % 62];\\n            // if new code is formed, break out of loop\\n            if(!codeToUrl.count(code)) break; \\n            code = \"\";   // loop back to generate a new unique code\\n        }\\n        string encoded = base + code;\\n        UrlToCode[longUrl] = code;    // store longUrl to code mapping to avoid duplicates        \\n        codeToUrl[encoded] = longUrl; // to decode shortened url back to original\\n        return encoded;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return codeToUrl[shortUrl];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110539,
                "title": "c-super-simple-easy-hashing-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        long_to_short[longUrl] = \"http://tinyurl.com/\" + to_string(hash_function(longUrl));\\n        short_to_long[long_to_short[longUrl]] = longUrl;\\n        return long_to_short[longUrl];\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return short_to_long[shortUrl];\\n    }\\n    \\nprivate:\\n    uint64_t hash_function(const string& str) {\\n        uint64_t hash = 0x811c9dc5;\\n        uint64_t prime = 0x1000193;\\n\\n        for(int i = 0; i < str.size(); ++i) {\\n            uint8_t value = str[i];\\n            hash = hash ^ value;\\n            hash *= prime;\\n        }\\n\\n        return hash;\\n    }\\n    \\n    unordered_map<string, string> long_to_short;\\n    unordered_map<string, string> short_to_long;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        long_to_short[longUrl] = \"http://tinyurl.com/\" + to_string(hash_function(longUrl));\\n        short_to_long[long_to_short[longUrl]] = longUrl;\\n        return long_to_short[longUrl];\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return short_to_long[shortUrl];\\n    }\\n    \\nprivate:\\n    uint64_t hash_function(const string& str) {\\n        uint64_t hash = 0x811c9dc5;\\n        uint64_t prime = 0x1000193;\\n\\n        for(int i = 0; i < str.size(); ++i) {\\n            uint8_t value = str[i];\\n            hash = hash ^ value;\\n            hash *= prime;\\n        }\\n\\n        return hash;\\n    }\\n    \\n    unordered_map<string, string> long_to_short;\\n    unordered_map<string, string> short_to_long;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867053,
                "title": "huffman-tree-based-solution-java",
                "content": "**Huffman Encoding**\\n1. Create a priority queue PQ consisting of each unique character and its frequency.\\n2. Create a new node\\n3. Extract 2 minimum values from PQ\\n4. Calculate the sum of frequency  of these two minimum values and assign it to the frequency of new node \\n5. Assign 1st minimum node as left child and, 2nd minimum node as right child  of the newly created node\\n6. Insert this new node back into PQ\\n7. Repeat {2. to 6.} till there is only one node left in PQ\\n8. Remaining last node in PQ is our Huffman tree\\'s root node\\n\\n**Huffman Decoding**\\n1. Start from root node and move to left child for \\'0\\' and right child for \\'1\\'\\n2. As soon as leaf node is encountered, append its character to our output string.\\n3. Repeat {1. to 2.} till we reach end of the shortUrl string. \\n\\n<b>As the output url is pretty large, use this to get huge urls instead of tiny urls :).</b>\\n```\\npublic class Codec {\\n    \\n    HashMap<Character, String> huffmanTable;\\n    Node root;\\n    \\n    //Huffman Tree Node\\n    class Node {\\n        char c;\\n        int val;\\n        Node left, right;\\n        \\n        Node(char c, int val) {\\n            this.c = c;\\n            this.val = val;\\n            this.left = null;\\n            this.right = null;\\n        }\\n        Node(char c, int val, Node left, Node right) {\\n            this.c = c;\\n            this.val = val;\\n            this.left = left;\\n            this.right = right;\\n        }\\n    }\\n    \\n    void createHuffmanTable(Node node, String encoding) {\\n        if(node.left == null && node.right == null) {\\n            huffmanTable.put(node.c, encoding);\\n            // System.out.println(node.c + \" ~ \" + encoding + \" ~ \" + f.get(node.c)); // Prints all character\\'s encoding and frequency\\n            return;\\n        }\\n        \\n        createHuffmanTable(node.left, encoding + \"0\");\\n        createHuffmanTable(node.right, encoding + \"1\");\\n    }\\n    \\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        int len = longUrl.length();\\n\\n        huffmanTable = new HashMap<>(); // HashMap containing each unique character and its Huffman encoding (\\'a\\' -> \\'000\\', \\'b\\' -> \\'110\\' etc.)\\n        HashMap<Character,Integer> f = new HashMap<>(); // HashMap containing each unique character and its frequency (\\'a\\' -> 2, \\'b\\' -> 5 etc.)\\n        \\n        // Filling HashMap with each unique character and its frequency in longUrl\\n        for(int i = 0 ; i < len; i++) {\\n            char c = longUrl.charAt(i);\\n            if(!f.containsKey(c)) {\\n                f.put(c, 0);  // Create an entry for new unique character found in longUrl\\n            }\\n            f.put(c, f.get(c) + 1);  // Increase its frequency by 1\\n        }\\n        \\n        PriorityQueue<Node> pq = new PriorityQueue<>(len, (a,b) -> a.val - b.val); // For building Huffman Tree\\n        for(Map.Entry<Character, Integer> entry : f.entrySet()) {\\n            pq.add(new Node(entry.getKey(), entry.getValue())); // Add all unique characters present in url to priority queue (based on their frequency)\\n        }\\n        \\n        root = null; // Root of HuffmanTree\\n\\n        // We run this till we have only one node left in priority queue and this remaining last node will be the root of our Huffman tree\\n        while(pq.size() > 1) {\\n            Node a = pq.poll(); // 1st Minimum frequency character in Priority Queue\\n            Node b = pq.poll(); // 2nd Minimum frequency character in Priority Queue\\n            Node node = new Node(\\'\\\\u0000\\', a.val + b.val, a, b); // Create a new Node with frequency as \\'sum of a\\'s frequency and b\\'s frequency\\'\\n            root = node;\\n            pq.add(node);       // Push newly created node back into priority queue\\n        }\\n        \\n        createHuffmanTable(root, \"\"); // Filling huffmanTable to see our encodings\\n        \\n        StringBuilder url = new StringBuilder(\"http://tinyurl.com/\");\\n        for(int i = 0 ; i < len ; i++) {\\n            char c = longUrl.charAt(i);\\n            url.append(huffmanTable.get(c));\\n        }\\n\\n        return url.toString();\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        int len = shortUrl.length();\\n        StringBuilder url = new StringBuilder();\\n        \\n        // {0..18} is \"http://tinyurl.com/\" so ignore it during decoding\\n        for(int i = 19 ; i < len ;) {\\n            Node node = root; // Always start at root of Huffman tree\\n            \\n            // Only leaf nodes have valid characters rest are \\'\\\\u0000\\'\\n            while(node.left != null && node.right != null) {\\n                // If \\'0\\', go left in Huffman tree else go right\\n                if(shortUrl.charAt(i) == \\'0\\') {\\n                    node = node.left;\\n                } else {\\n                    node = node.right;\\n                }\\n                i++;\\n            }\\n            \\n            // Append leaf node\\'s character to the url\\n            url.append(node.c);\\n        }\\n        return url.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n    \\n    HashMap<Character, String> huffmanTable;\\n    Node root;\\n    \\n    //Huffman Tree Node\\n    class Node {\\n        char c;\\n        int val;\\n        Node left, right;\\n        \\n        Node(char c, int val) {\\n            this.c = c;\\n            this.val = val;\\n            this.left = null;\\n            this.right = null;\\n        }\\n        Node(char c, int val, Node left, Node right) {\\n            this.c = c;\\n            this.val = val;\\n            this.left = left;\\n            this.right = right;\\n        }\\n    }\\n    \\n    void createHuffmanTable(Node node, String encoding) {\\n        if(node.left == null && node.right == null) {\\n            huffmanTable.put(node.c, encoding);\\n            // System.out.println(node.c + \" ~ \" + encoding + \" ~ \" + f.get(node.c)); // Prints all character\\'s encoding and frequency\\n            return;\\n        }\\n        \\n        createHuffmanTable(node.left, encoding + \"0\");\\n        createHuffmanTable(node.right, encoding + \"1\");\\n    }\\n    \\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        int len = longUrl.length();\\n\\n        huffmanTable = new HashMap<>(); // HashMap containing each unique character and its Huffman encoding (\\'a\\' -> \\'000\\', \\'b\\' -> \\'110\\' etc.)\\n        HashMap<Character,Integer> f = new HashMap<>(); // HashMap containing each unique character and its frequency (\\'a\\' -> 2, \\'b\\' -> 5 etc.)\\n        \\n        // Filling HashMap with each unique character and its frequency in longUrl\\n        for(int i = 0 ; i < len; i++) {\\n            char c = longUrl.charAt(i);\\n            if(!f.containsKey(c)) {\\n                f.put(c, 0);  // Create an entry for new unique character found in longUrl\\n            }\\n            f.put(c, f.get(c) + 1);  // Increase its frequency by 1\\n        }\\n        \\n        PriorityQueue<Node> pq = new PriorityQueue<>(len, (a,b) -> a.val - b.val); // For building Huffman Tree\\n        for(Map.Entry<Character, Integer> entry : f.entrySet()) {\\n            pq.add(new Node(entry.getKey(), entry.getValue())); // Add all unique characters present in url to priority queue (based on their frequency)\\n        }\\n        \\n        root = null; // Root of HuffmanTree\\n\\n        // We run this till we have only one node left in priority queue and this remaining last node will be the root of our Huffman tree\\n        while(pq.size() > 1) {\\n            Node a = pq.poll(); // 1st Minimum frequency character in Priority Queue\\n            Node b = pq.poll(); // 2nd Minimum frequency character in Priority Queue\\n            Node node = new Node(\\'\\\\u0000\\', a.val + b.val, a, b); // Create a new Node with frequency as \\'sum of a\\'s frequency and b\\'s frequency\\'\\n            root = node;\\n            pq.add(node);       // Push newly created node back into priority queue\\n        }\\n        \\n        createHuffmanTable(root, \"\"); // Filling huffmanTable to see our encodings\\n        \\n        StringBuilder url = new StringBuilder(\"http://tinyurl.com/\");\\n        for(int i = 0 ; i < len ; i++) {\\n            char c = longUrl.charAt(i);\\n            url.append(huffmanTable.get(c));\\n        }\\n\\n        return url.toString();\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        int len = shortUrl.length();\\n        StringBuilder url = new StringBuilder();\\n        \\n        // {0..18} is \"http://tinyurl.com/\" so ignore it during decoding\\n        for(int i = 19 ; i < len ;) {\\n            Node node = root; // Always start at root of Huffman tree\\n            \\n            // Only leaf nodes have valid characters rest are \\'\\\\u0000\\'\\n            while(node.left != null && node.right != null) {\\n                // If \\'0\\', go left in Huffman tree else go right\\n                if(shortUrl.charAt(i) == \\'0\\') {\\n                    node = node.left;\\n                } else {\\n                    node = node.right;\\n                }\\n                i++;\\n            }\\n            \\n            // Append leaf node\\'s character to the url\\n            url.append(node.c);\\n        }\\n        return url.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152399,
                "title": "beats-100-java-2-lines",
                "content": "This is really bad problem.\\n\\n```\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return shortUrl;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return shortUrl;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 100290,
                "title": "javascript-solution",
                "content": "```\\nlet urls = {};\\n\\nvar encode = function(longUrl) {\\n    let uniqueKey = Date.now().toString(36);\\n    urls[uniqueKey] = longUrl;\\n    return \"http://tinyurl.com/\" + uniqueKey;\\n};\\n\\nvar decode = function(shortUrl) {\\n    return urls[shortUrl.split(\"com/\")[1]];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet urls = {};\\n\\nvar encode = function(longUrl) {\\n    let uniqueKey = Date.now().toString(36);\\n    urls[uniqueKey] = longUrl;\\n    return \"http://tinyurl.com/\" + uniqueKey;\\n};\\n\\nvar decode = function(shortUrl) {\\n    return urls[shortUrl.split(\"com/\")[1]];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1974337,
                "title": "0-ms-c-two-solutions",
                "content": "**Sol 1 : just to pass the test case**\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\t// Encodes a URL to a shortened URL.\\n\\t\\t\\tstring encode(string longUrl) {\\n\\t\\t\\t\\treturn longUrl;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Decodes a shortened URL to its original URL.\\n\\t\\t\\tstring decode(string shortUrl) {\\n\\t\\t\\t\\treturn shortUrl;\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\n\\n**Sol 2: using hashmap**\\n\\n\\t\\t\\t\\tclass Solution {\\n\\t\\t\\t\\tpublic:\\n\\t\\t\\t\\t\\tmap<string,string> mp;\\n\\t\\t\\t\\t\\tint n = 0;\\n\\t\\t\\t\\t\\t// Encodes a URL to a shortened URL.\\n\\t\\t\\t\\t\\tstring encode(string longUrl) {\\n\\t\\t\\t\\t\\t\\tstring res = \"http://tinyurl.com/\" + to_string(n);\\n\\t\\t\\t\\t\\t\\tn++;\\n\\t\\t\\t\\t\\t\\tmp[res] = longUrl;\\n\\t\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Decodes a shortened URL to its original URL.\\n\\t\\t\\t\\t\\tstring decode(string shortUrl) {\\n\\t\\t\\t\\t\\t\\treturn mp[shortUrl];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\t// Encodes a URL to a shortened URL.\\n\\t\\t\\tstring encode(string longUrl) {\\n\\t\\t\\t\\treturn longUrl;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 179934,
                "title": "c-100-base62",
                "content": "In this solution I assume that a site like TinyUrl would not have the need of converting a base62 ID back to base10, but simply store it. Therefore I mapped base62 ID\\'s to the full URL.\\n\\n```cpp\\nclass BaseConverter {\\npublic:\\n    static const string base62c;\\n    \\n    static string ToBase62(int base10) {\\n        string base62;\\n        if(base10 < 62)\\n            return string(1, base62c[base10]);\\n        \\n        while(base10)\\n            base62 += base62c[base10 % 62], base10 /= 62;\\n\\n        reverse(base62.begin(), base62.end());\\n        return base62;\\n    }\\n};\\n\\nconst string BaseConverter::base62c = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n\\nclass Solution {\\nprivate:\\n    int id = 0;\\n    map<string /*id*/, string /*url*/> urls;\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string sid = BaseConverter::ToBase62(id++);\\n        urls[sid] = longUrl;\\n        return \"http://tinyurl.com/\" + sid;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        int index = shortUrl.size() - 1;\\n        while(shortUrl[index] != \\'/\\') index -= 1;\\n        string sid = shortUrl.substr(index + 1);\\n        return urls[sid];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass BaseConverter {\\npublic:\\n    static const string base62c;\\n    \\n    static string ToBase62(int base10) {\\n        string base62;\\n        if(base10 < 62)\\n            return string(1, base62c[base10]);\\n        \\n        while(base10)\\n            base62 += base62c[base10 % 62], base10 /= 62;\\n\\n        reverse(base62.begin(), base62.end());\\n        return base62;\\n    }\\n};\\n\\nconst string BaseConverter::base62c = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n\\nclass Solution {\\nprivate:\\n    int id = 0;\\n    map<string /*id*/, string /*url*/> urls;\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string sid = BaseConverter::ToBase62(id++);\\n        urls[sid] = longUrl;\\n        return \"http://tinyurl.com/\" + sid;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        int index = shortUrl.size() - 1;\\n        while(shortUrl[index] != \\'/\\') index -= 1;\\n        string sid = shortUrl.substr(index + 1);\\n        return urls[sid];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100277,
                "title": "c-solution",
                "content": "```class Solution {\\npublic:\\n    string dict = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    int id = 0;\\n    unordered_map<string,string> m;  //key is longURL, value is shortURL\\n    unordered_map<int, string> idm;  //key is id in DB, value is longURL\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        if(m.find(longUrl) != m.end())return m[longUrl];\\n        string res = \"\";\\n        id++;\\n        int count = id;\\n        while(count > 0)\\n        {\\n            res = dict[count%62] + res;\\n            count /= 62;\\n        }\\n        while(res.size() < 6)\\n        {\\n            res = \"0\" + res;\\n        }\\n        m[longUrl] = res;\\n        idm[id] = longUrl;\\n        return res;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        int id = 0;\\n        for(int i = 0; i < shortUrl.size(); i++)\\n        {\\n            id = 62*id + (int)(dict.find(shortUrl[i]));\\n        }\\n        if(idm.find(id) != idm.end())return idm[id];\\n        return \"\";\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string dict = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    int id = 0;\\n    unordered_map<string,string> m;  //key is longURL, value is shortURL\\n    unordered_map<int, string> idm;  //key is id in DB, value is longURL\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        if(m.find(longUrl) != m.end())return m[longUrl];\\n        string res = \"\";\\n        id++;\\n        int count = id;\\n        while(count > 0)\\n        {\\n            res = dict[count%62] + res;\\n            count /= 62;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 100341,
                "title": "easy-to-understand-in-python",
                "content": "The main idea is to increase the global index, and transform the index into 26 * 2 + 10 based number in string format. \\nAnd I used 2-way dictionary to simulate database queries on backend.\\n```\\nclass Codec:\\n    import string\\n    letters = string.ascii_letters + string.digits\\n    full_tiny = {}\\n    tiny_full = {}\\n    global_counter = 0\\n    def encode(self, longUrl):\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \\n        :type longUrl: str\\n        :rtype: str\\n        \"\"\"\\n        def decto62(dec):\\n            ans = \"\"\\n            while 1:\\n                ans = self.letters[dec % 62] + ans\\n                dec //= 62\\n                if not dec:\\n                    break\\n            return ans\\n                \\n        suffix = decto62(self.global_counter)\\n        if longUrl not in self.full_tiny:\\n            self.full_tiny[longUrl] = suffix\\n            self.tiny_full[suffix] = longUrl\\n            self.global_counter += 1\\n        return \"http://tinyurl.com/\" + suffix\\n        \\n        \\n\\n    def decode(self, shortUrl):\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \\n        :type shortUrl: str\\n        :rtype: str\\n        \"\"\"\\n        idx = shortUrl.split('/')[-1]\\n        if idx in self.tiny_full:\\n            return self.tiny_full[idx]\\n        else:\\n            return None```",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n    import string\\n    letters = string.ascii_letters + string.digits\\n    full_tiny = {}\\n    tiny_full = {}\\n    global_counter = 0\\n    def encode(self, longUrl):\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \\n        :type longUrl: str\\n        :rtype: str\\n        \"\"\"\\n        def decto62(dec):\\n            ans = \"\"\\n            while 1:\\n                ans = self.letters[dec % 62] + ans\\n                dec //= 62\\n                if not dec:\\n                    break\\n            return ans\\n                \\n        suffix = decto62(self.global_counter)\\n        if longUrl not in self.full_tiny:\\n            self.full_tiny[longUrl] = suffix\\n            self.tiny_full[suffix] = longUrl\\n            self.global_counter += 1\\n        return \"http://tinyurl.com/\" + suffix\\n        \\n        \\n\\n    def decode(self, shortUrl):\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \\n        :type shortUrl: str\\n        :rtype: str\\n        \"\"\"\\n        idx = shortUrl.split('/')[-1]\\n        if idx in self.tiny_full:\\n            return self.tiny_full[idx]\\n        else:\\n            return None```",
                "codeTag": "Java"
            },
            {
                "id": 1975423,
                "title": "python3-proper-https-tin-e-url",
                "content": "using the md5 hashing to provide a proper tiny(er)url.\\n\\nMost implementations being posted are not even valid URLs, like wtf?\\n\\nProperly is like 3 extra lines compared to the just return the given value. smh\\n\\n\\n```\\nimport hashlib\\n\\n\\nclass Codec:\\n    def __init__(self):\\n        self.urls = {}\\n\\n    def hash_to(self, s):\\n        return \\'https://tin.e/\\' + hashlib.md5(s.encode()).hexdigest()\\n\\n    def encode(self, long_url: str) -> str:  # Encodes a URL to a shortened URL.\\n        hash_key = self.hash_to(long_url)\\n        self.urls[hash_key] = long_url\\n        return hash_key\\n        \\n    def decode(self, short_url: str) -> str:  # Decodes a shortened URL to its original URL.\\n        return self.urls[short_url]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport hashlib\\n\\n\\nclass Codec:\\n    def __init__(self):\\n        self.urls = {}\\n\\n    def hash_to(self, s):\\n        return \\'https://tin.e/\\' + hashlib.md5(s.encode()).hexdigest()\\n\\n    def encode(self, long_url: str) -> str:  # Encodes a URL to a shortened URL.\\n        hash_key = self.hash_to(long_url)\\n        self.urls[hash_key] = long_url\\n        return hash_key\\n        \\n    def decode(self, short_url: str) -> str:  # Decodes a shortened URL to its original URL.\\n        return self.urls[short_url]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973695,
                "title": "c-random-number-map-and-base62",
                "content": "**Here is my solution coded LIVE ON STREAM.  6pm PT.  EVERYDAY.  Link in profile.**\\n\\n```\\nclass Solution {\\npublic:\\n    string characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\\n    long long MOD = 56800235583; //6 ^62 \\n    unordered_map<string, string> urlMap;\\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        long long randomNum = rand() % MOD;\\n        string tinyThing = convertToB62(randomNum);\\n        while(urlMap.find(tinyThing) != urlMap.end()) {\\n            randomNum = rand() % MOD;\\n            tinyThing = convertToB62(randomNum);\\n        }\\n        urlMap[tinyThing] = longUrl;\\n        return tinyThing;\\n    }\\n\\n    string convertToB62(long long num) {\\n        string ans = \"\";\\n        while(num) {\\n            int mod = num % 62;\\n            ans += characters[mod];\\n            num /= 62;\\n        }\\n        return ans;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return urlMap[shortUrl];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\\n    long long MOD = 56800235583; //6 ^62 \\n    unordered_map<string, string> urlMap;\\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        long long randomNum = rand() % MOD;\\n        string tinyThing = convertToB62(randomNum);\\n        while(urlMap.find(tinyThing) != urlMap.end()) {\\n            randomNum = rand() % MOD;\\n            tinyThing = convertToB62(randomNum);\\n        }\\n        urlMap[tinyThing] = longUrl;\\n        return tinyThing;\\n    }\\n\\n    string convertToB62(long long num) {\\n        string ans = \"\";\\n        while(num) {\\n            int mod = num % 62;\\n            ans += characters[mod];\\n            num /= 62;\\n        }\\n        return ans;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return urlMap[shortUrl];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111557,
                "title": "java-simple-and-easy-to-understand-solution-using-random-uuid-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nimport java.util.UUID;\\n\\npublic class Codec {\\n    HashMap<String, String> map = new HashMap();\\n    \\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String uniqueId = getUniqueId();\\n        //save the uniqueId\\n        map.put(uniqueId, longUrl);\\n        return \"http://tinyurl.com/\" + uniqueId;\\n    }\\n    \\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        int index = shortUrl.indexOf(\".com/\");\\n\\t\\t\\n\\t\\t//last 6 character as unique id\\n        String uniqueId = shortUrl.substring(index + 5);\\n        return map.get(uniqueId);\\n    }\\n    \\n    private String getUniqueId(){\\n        UUID uuid = UUID.randomUUID();\\n        return uuid.toString().substring(6);\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.UUID;\\n\\npublic class Codec {\\n    HashMap<String, String> map = new HashMap();\\n    \\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String uniqueId = getUniqueId();\\n        //save the uniqueId\\n        map.put(uniqueId, longUrl);\\n        return \"http://tinyurl.com/\" + uniqueId;\\n    }\\n    \\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        int index = shortUrl.indexOf(\".com/\");\\n\\t\\t\\n\\t\\t//last 6 character as unique id\\n        String uniqueId = shortUrl.substring(index + 5);\\n        return map.get(uniqueId);\\n    }\\n    \\n    private String getUniqueId(){\\n        UUID uuid = UUID.randomUUID();\\n        return uuid.toString().substring(6);\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110653,
                "title": "cpp-simple-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    unordered_map<string,string> mp;\\n    unordered_map<string,int> cnt;\\n    \\n    string str=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\";\\n    \\n    string rstring()\\n    {\\n        string ans=\"\";\\n        srand(time(0));\\n        for(int i = 0; i<8; i++)\\n        {\\n            ans+=str[rand()%62];\\n        }\\n        return ans;\\n    }\\n    \\n    string encode(string longUrl) \\n    {\\n        string tmp=rstring();\\n        cout << tmp << endl;\\n        cnt[tmp]+=1;\\n        mp[tmp+to_string(cnt[tmp])]=longUrl;\\n        return tmp+to_string(cnt[tmp]);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) \\n    {\\n        return mp[shortUrl];\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```\\n**If You Like! Please Upvote**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    unordered_map<string,string> mp;\\n    unordered_map<string,int> cnt;\\n    \\n    string str=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\";\\n    \\n    string rstring()\\n    {\\n        string ans=\"\";\\n        srand(time(0));\\n        for(int i = 0; i<8; i++)\\n        {\\n            ans+=str[rand()%62];\\n        }\\n        return ans;\\n    }\\n    \\n    string encode(string longUrl) \\n    {\\n        string tmp=rstring();\\n        cout << tmp << endl;\\n        cnt[tmp]+=1;\\n        mp[tmp+to_string(cnt[tmp])]=longUrl;\\n        return tmp+to_string(cnt[tmp]);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) \\n    {\\n        return mp[shortUrl];\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "codeTag": "C++"
            },
            {
                "id": 100282,
                "title": "python-solution-with-comments-45ms",
                "content": "This solution got accepted with all tests passing and beat at least 72% of accepted solutions.\\n\\n```\\nimport random\\nimport string\\n\\nclass Codec:\\n    def __init__(self):\\n        self.url_pair = {}\\n\\n    def encode(self, longUrl):\\n        \"\"\"Encodes a URL to a shortened URL.\"\"\"\\n        # Get a set of characters that will make up the suffix\\n        suffix_set = string.ascii_letters + string.digits\\n\\n        # Make a tinyurl template\\n        tiny_url = \"http://tinyurl.com/\".join(random.choice(suffix_set) for _ in range(6))\\n        \\n        # Store the pair in the dictionary\\n        self.url_pair[tiny_url] = longUrl\\n\\n        return tiny_url\\n\\n    def decode(self, shortUrl):\\n        \"\"\"Decodes the shortened URL to its original URL.\"\"\"\\n        # Return the value from a given key from the dictionary\\n        return self.url_pair.get(shortUrl)\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\nimport string\\n\\nclass Codec:\\n    def __init__(self):\\n        self.url_pair = {}\\n\\n    def encode(self, longUrl):\\n        \"\"\"Encodes a URL to a shortened URL.\"\"\"\\n        # Get a set of characters that will make up the suffix\\n        suffix_set = string.ascii_letters + string.digits\\n\\n        # Make a tinyurl template\\n        tiny_url = \"http://tinyurl.com/\".join(random.choice(suffix_set) for _ in range(6))\\n        \\n        # Store the pair in the dictionary\\n        self.url_pair[tiny_url] = longUrl\\n\\n        return tiny_url\\n\\n    def decode(self, shortUrl):\\n        \"\"\"Decodes the shortened URL to its original URL.\"\"\"\\n        # Return the value from a given key from the dictionary\\n        return self.url_pair.get(shortUrl)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973787,
                "title": "python-simple-solution-using-fixed-length-key",
                "content": "The code creates a fixed-sized key of length 6. For this specific case, I am using the following char-set to generate each char of the key:\\n`0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`\\n\\nThe length  of char-set is **62**.  With this char-set, we would be able to generate **62^6** combinations i. e around 56 billion keys. The key is randomly generated using the ***random*** library. \\n\\n```\\nfrom random import choice \\nclass Codec:\\n    \\n    def __init__(self):\\n        self.charset = \\'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\n        self.urls = {}\\n        \\n    def get_key(self):\\n        return \\'\\'.join(choice(self.charset) for i in range(6))\\n            \\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        key = self.get_key() \\n        while key in self.urls: # generate a non-existing key\\n            key = self.get_key()\\n        \\n        self.urls[key] = longUrl\\n        return \"http://tinyurl.com/\" + key\\n\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n        key = shortUrl[shortUrl.rindex(\\'/\\')+1:]\\n        return self.urls[key] if key in self.urls else \\'\\'\\n\\t\\t\\n```\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom random import choice \\nclass Codec:\\n    \\n    def __init__(self):\\n        self.charset = \\'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\n        self.urls = {}\\n        \\n    def get_key(self):\\n        return \\'\\'.join(choice(self.charset) for i in range(6))\\n            \\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        key = self.get_key() \\n        while key in self.urls: # generate a non-existing key\\n            key = self.get_key()\\n        \\n        self.urls[key] = longUrl\\n        return \"http://tinyurl.com/\" + key\\n\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n        key = shortUrl[shortUrl.rindex(\\'/\\')+1:]\\n        return self.urls[key] if key in self.urls else \\'\\'\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169879,
                "title": "3-simple-python-solutions",
                "content": "1. Map index of the urls to the 62 digit system, 0,1...8,9,a,b...y,z,A,B...Y,Z. \\nI avoid 0 to simplfy the 0 case for while loop\\n```\\nimport string\\nimport random\\nfrom collections import OrderedDict\\n\\nclass Codec:\\n    def __init__(self):\\n        self.urls = []\\n        self.base = OrderedDict((k, i) for i, k in enumerate(string.digits + string.ascii_letters))\\n        \\n    def encode(self, longUrl):\\n        self.urls.append(longUrl)\\n        n = len(self.urls)\\n        code = []\\n        while n > 0:\\n            code.append(self.base.keys()[n % len(self.base)])\\n            n = n // len(self.base)\\n            \\n        return \\'http://tinyurl.com/\\' + \\'\\'.join(code)\\n\\n    def decode(self, shortUrl):\\n        code = shortUrl.split(\\'/\\')[-1]\\n        n = 0\\n        for ch in code:\\n            n = n * len(self.base) + self.base[ch]\\n        \\n        return self.urls[n-1]\\n```\\nIf just use number\\n```      \\nclass Codec1:\\n    def __init__(self):\\n        self.urls = []\\n        \\n    def encode(self, longUrl):\\n        self.urls.append(longUrl)\\n        return \\'http://tinyurl.com/\\' + str(len(self.urls)-1)\\n\\n    def decode(self, shortUrl):\\n        return self.urls[int(shortUrl.split(\\'/\\')[-1])]\\n```\\nIf use random\\n```      \\nclass Codec2:\\n    def __init__(self):\\n        self.code2url = {}\\n        self.url2code = {}\\n        \\n    def encode(self, longUrl):\\n        letter_set = string.ascii_letters + string.digits\\n        \\n        while longUrl not in self.url2code:\\n            code = \\'\\'.join([random.choice(letter_set) for _ in range(6)])\\n            if code not in self.code2url:\\n                self.code2url[code] = longUrl\\n                self.url2code[longUrl] = code\\n        \\n        return \\'http://tinyurl.com/\\' + self.url2code[longUrl]\\n\\n    def decode(self, shortUrl):\\n        return self.code2url[shortUrl[-6:]]\\n```",
                "solutionTags": [],
                "code": "```\\nimport string\\nimport random\\nfrom collections import OrderedDict\\n\\nclass Codec:\\n    def __init__(self):\\n        self.urls = []\\n        self.base = OrderedDict((k, i) for i, k in enumerate(string.digits + string.ascii_letters))\\n        \\n    def encode(self, longUrl):\\n        self.urls.append(longUrl)\\n        n = len(self.urls)\\n        code = []\\n        while n > 0:\\n            code.append(self.base.keys()[n % len(self.base)])\\n            n = n // len(self.base)\\n            \\n        return \\'http://tinyurl.com/\\' + \\'\\'.join(code)\\n\\n    def decode(self, shortUrl):\\n        code = shortUrl.split(\\'/\\')[-1]\\n        n = 0\\n        for ch in code:\\n            n = n * len(self.base) + self.base[ch]\\n        \\n        return self.urls[n-1]\\n```\n```      \\nclass Codec1:\\n    def __init__(self):\\n        self.urls = []\\n        \\n    def encode(self, longUrl):\\n        self.urls.append(longUrl)\\n        return \\'http://tinyurl.com/\\' + str(len(self.urls)-1)\\n\\n    def decode(self, shortUrl):\\n        return self.urls[int(shortUrl.split(\\'/\\')[-1])]\\n```\n```      \\nclass Codec2:\\n    def __init__(self):\\n        self.code2url = {}\\n        self.url2code = {}\\n        \\n    def encode(self, longUrl):\\n        letter_set = string.ascii_letters + string.digits\\n        \\n        while longUrl not in self.url2code:\\n            code = \\'\\'.join([random.choice(letter_set) for _ in range(6)])\\n            if code not in self.code2url:\\n                self.code2url[code] = longUrl\\n                self.url2code[longUrl] = code\\n        \\n        return \\'http://tinyurl.com/\\' + self.url2code[longUrl]\\n\\n    def decode(self, shortUrl):\\n        return self.code2url[shortUrl[-6:]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154331,
                "title": "0ms-easy-java-faster",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Codec {\\n\\n    private static String origionalUrl;\\n    private static String tinyUrl;\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        origionalUrl=longUrl;\\n        tinyUrl=\"http://tinyurl.com/4e9iAkl\";\\n        return tinyUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n\\n\\n        return origionalUrl;\\n    }\\n}\\n\\n```\\n![478xve.jpg](https://assets.leetcode.com/users/images/699a25fb-189d-4e03-a765-db6a9eea7485_1676026471.2204285.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\npublic class Codec {\\n\\n    private static String origionalUrl;\\n    private static String tinyUrl;\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        origionalUrl=longUrl;\\n        tinyUrl=\"http://tinyurl.com/4e9iAkl\";\\n        return tinyUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n\\n\\n        return origionalUrl;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645436,
                "title": "python-one-liner-beats-99-46-joke",
                "content": "```\\nclass Codec: encode = decode = str\\n```\\n![image](https://assets.leetcode.com/users/images/b9068aaf-dff0-4ef3-a403-a89932e3bfd7_1640384030.2501793.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Codec: encode = decode = str\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803450,
                "title": "give-the-idiot-author-a-idiot-answer",
                "content": "class Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1974328,
                "title": "java-xor-with-explaination-simple-solution",
                "content": "# XOR Approach\\n* XOR Properties :\\n\\t1. \\tT ^ T = F\\n\\t2. \\tT ^ F = T\\n\\t3. \\tF ^ T = T\\n\\t4. \\tF ^ F = F\\n\\t\\nFor Example :\\nStep 1: Let\\'s take a Number and a key  \\n\\t\\t`num = 4`\\n\\t\\t`key = 5`\\n* Encoding\\n\\t\\t\\t`encodedNumber = num ^ key`\\n\\t\\t\\t`encodedNumber = 4 ^ 5`\\n\\t\\t\\t`encodedNumber = 1`  \\n\\t\\t\\tThese Steps can be used in Encoding.\\n\\t\\t\\t\\n* Decoding\\n\\t\\t`decodedNumber = encodedNumber ^ key`\\n\\t\\t`decodedNumber = 1 ^ 5`\\n\\t\\t`decodedNumber = 4`\\n\\t\\tYou can see the `decodedNumber`  and original `num` are equal \\n\\t\\t( i.e `num == decodedNumber == 4` )\\n* We can use this property of XOR in Encryption-Decryption as well\\t\\t\\t\\t \\n\\n```\\nclass Codec {\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl)\\n    {\\n        StringBuilder url = new StringBuilder(longUrl);\\n        for(int i = 0; i < url.length(); i++)\\n        {\\n            char ch = (char)(url.charAt(i)^url.length());\\n            url.replace(i,i+1, Character.toString(ch));          \\n        }    \\n        return url.toString();\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        StringBuilder url = new StringBuilder(shortUrl);\\n        for(int i = 0; i < url.length(); i++)\\n        {\\n            char ch = (char)(url.charAt(i)^url.length());\\n            url.replace(i,i+1, Character.toString(ch));          \\n        }    \\n        return url.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Codec {\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl)\\n    {\\n        StringBuilder url = new StringBuilder(longUrl);\\n        for(int i = 0; i < url.length(); i++)\\n        {\\n            char ch = (char)(url.charAt(i)^url.length());\\n            url.replace(i,i+1, Character.toString(ch));          \\n        }    \\n        return url.toString();\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        StringBuilder url = new StringBuilder(shortUrl);\\n        for(int i = 0; i < url.length(); i++)\\n        {\\n            char ch = (char)(url.charAt(i)^url.length());\\n            url.replace(i,i+1, Character.toString(ch));          \\n        }    \\n        return url.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974286,
                "title": "python3-using-dictionary-faster-than-95-42",
                "content": "\\n\\n```\\nclass Codec:\\n    def __init__(self):\\n        self.dict = {}\\n        self.key = 1\\n    def encode(self, longUrl: str) -> str:\\n        self.dict[self.key] = longUrl\\n        self.key += 1\\n        return self.key-1\\n\\n    def decode(self, shortUrl: str) -> str:\\n        return self.dict[shortUrl]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n\\n```\\nclass Codec:\\n    def __init__(self):\\n        self.dict = {}\\n        self.key = 1\\n    def encode(self, longUrl: str) -> str:\\n        self.dict[self.key] = longUrl\\n        self.key += 1\\n        return self.key-1\\n\\n    def decode(self, shortUrl: str) -> str:\\n        return self.dict[shortUrl]",
                "codeTag": "Java"
            },
            {
                "id": 1974132,
                "title": "c-gradual-improvement-solution",
                "content": "\\nI was able to keep the original url using the map and the saved count.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    map<int, string> m;\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        m[m.size()] = longUrl;\\n        return \"http://tinyurl.com/\" + to_string(m.size() - 1);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        int idx = shortUrl.rfind(\\'/\\');\\n        return m[stoi(shortUrl.substr(idx + 1))];\\n    }\\n```\\n\\nIt could be solved by dividing the depth as follows.\\nIt is the separation of the domain (depth1) and the rest (depth2).\\nThis prevents duplicate storage of the same depth1..\\n\\n```\\nclass Solution {\\npublic:\\n    map<int, string> depth1;\\n    map<string, int> depth1Reverse;\\n    \\n    map<int, map<int, string>> depth2;\\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        int idx = getDepth1LastIdx(longUrl);\\n        \\n        string depth1Url = longUrl.substr(0, idx);\\n        string depth2Url = longUrl.substr(idx);\\n        \\n        int depth1Idx = insertDepth1(depth1Url);\\n        int depth2Idx = insertDepth2(depth1Idx, depth2Url);\\n        \\n        return \"http://tinyurl.com/\" + to_string(depth1Idx)\\n            + (depth2Idx == -1 ? \"\" : \"-\" + to_string(depth2Idx));\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string path = shortUrl.substr(shortUrl.rfind(\\'/\\') + 1);\\n        \\n        int idx = path.find(\\'-\\');\\n        int depth1Idx = stoi(path.substr(0, idx));\\n        int depth2Idx = stoi(path.substr(idx + 1));\\n        return depth1[depth1Idx] + depth2[depth1Idx][depth1Idx];\\n    }\\n    \\nprivate:\\n    int getDepth1LastIdx(string& url) {\\n        int c = 0;\\n        for(int i=0; i<url.size(); i++)\\n            if(url[i] == \\'/\\' && ++c == 3) return i;\\n        return url.size();\\n    }\\n    \\n    int insertDepth1(string& url) {\\n        auto f = depth1Reverse.find(url);\\n        if(f != depth1Reverse.end()) return f->second;\\n        depth1[depth1Reverse.size()] = url;\\n        depth1Reverse[url] = depth1Reverse.size();\\n        return depth1Reverse.size() - 1;\\n    }\\n    \\n    int insertDepth2(int depth1Idx, string& url) {\\n        if(url.size() == 0) return -1;\\n        \\n        if(depth2.find(depth1Idx) == depth2.end())\\n            depth2[depth1Idx] = map<int, string>();\\n        \\n        int depth2Idx = depth2[depth1Idx].size();\\n        depth2[depth1Idx][depth2Idx] = url;\\n        \\n        return depth2Idx;\\n    }\\n};\\n```\\nIf you want depth2 to also prevent duplicate storage, you can create a reverse map.\\n\\n\\nRaising to sequential numbers has some problems.\\nThe number of saved urls can be inferred, and an error may occur if it goes out of the range of the data type used as the key of the map.\\nIt could also be solved as follows by using characters as a key.\\nIt also prevents the storage of duplicate urls by using the reverse direction.\\n\\n```\\nclass Solution {\\npublic:\\n    map<string, string> encToDec;\\n    map<string, string> decToEnc;\\n    \\n    string characters = \"abcdeafghijklmnopABCDEFGHIJKLMNOP0123456789\";\\n    \\n    Solution() {\\n        srand((unsigned int)time(NULL));\\n    }\\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        if(decToEnc.find(longUrl) != decToEnc.end())\\n            return \"http://tinyurl.com/\" + decToEnc[longUrl];\\n        \\n        while(1) {\\n            string encodedUrl = \"\";\\n            for(int i=0; i<6; i++) {\\n                encodedUrl.push_back(characters[rand() % characters.size()]);\\n            }\\n            if(encToDec.find(encodedUrl) == encToDec.end()) {\\n                decToEnc[longUrl] = encodedUrl;\\n                encToDec[encodedUrl] = longUrl;\\n                break;\\n            }\\n        }\\n        return \"http://tinyurl.com/\" + decToEnc[longUrl];\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return encToDec[shortUrl.substr(shortUrl.rfind(\\'/\\') + 1)];\\n    }\\n};\\n```\\n\\nIn the above case as well, if the depth is separated, the storage space can be used more efficiently.\\n\\n \\n\\nSeparating the depth is done in the previous way, so we will omit it and improve it a bit in other aspects.\\n\\nBecause it encodes with a fixed number of characters,\\nIf you run out of all possible cases, you run the risk of endlessly crashing into an infinite loop.\\n\\nIt specifies the number of retries to be performed, and if it exceeds this limit, the number of characters is increased flexibly.\\n\\n```\\nclass Solution {\\npublic:\\n    map<string, string> encToDec;\\n    map<string, string> decToEnc;\\n    \\n    string characters = \"abcdeafghijklmnopABCDEFGHIJKLMNOP0123456789\";\\n    \\n    int RETRY = 3;\\n    int SIZE = 6;\\n    \\n    Solution() {\\n        srand((unsigned int)time(NULL));\\n    }\\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        if(decToEnc.find(longUrl) != decToEnc.end())\\n            return \"http://tinyurl.com/\" + decToEnc[longUrl];\\n        \\n        int count = 0;\\n        while(1) {\\n            string encodedUrl = \"\";\\n            for(int i=0; i<SIZE; i++) {\\n                encodedUrl.push_back(characters[rand() % characters.size()]);\\n            }\\n            if(encToDec.find(encodedUrl) == encToDec.end()) {\\n                decToEnc[longUrl] = encodedUrl;\\n                encToDec[encodedUrl] = longUrl;\\n                break;\\n            }\\n            if(++count == RETRY) {\\n                SIZE++;\\n                count = 0;\\n            }\\n        }\\n        return \"http://tinyurl.com/\" + decToEnc[longUrl];\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return encToDec[shortUrl.substr(shortUrl.rfind(\\'/\\') + 1)];\\n    }\\n};\\n```\\n\\nBecause the number of characters is variable, you can solve the conflicting problem.\\n\\n\\nIf you compress all your data, you will be able to use the storage space more efficiently.\\nInstead, you need more computation.\\n```\\nclass Solution {\\npublic:\\n    map<string, string> encToDec;\\n    map<string, string> decToEnc;\\n    \\n    string characters = \"abcdeafghijklmnopABCDEFGHIJKLMNOP0123456789\";\\n    \\n    int RETRY = 3;\\n    int SIZE = 6;\\n    \\n    Solution() {\\n        srand((unsigned int)time(NULL));\\n    }\\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string compressedLongUrl = compress(longUrl);\\n        if(decToEnc.find(compressedLongUrl) != decToEnc.end())\\n            return \"http://tinyurl.com/\" + recover(decToEnc[compressedLongUrl]);\\n        \\n        int count = 0;\\n        while(1) {\\n            string encodedUrl = \"\";\\n            for(int i=0; i<SIZE; i++) {\\n                encodedUrl.push_back(characters[rand() % characters.size()]);\\n            }\\n            string compressedEncodedUrl = compress(encodedUrl);\\n            if(encToDec.find(compressedEncodedUrl) == encToDec.end()) {\\n                decToEnc[compressedLongUrl] = compressedEncodedUrl;\\n                encToDec[compressedEncodedUrl] = compressedLongUrl;\\n                break;\\n            }\\n            if(++count == RETRY) {\\n                SIZE++;\\n                count = 0;\\n            }\\n        }\\n        return \"http://tinyurl.com/\" + recover(decToEnc[compressedLongUrl]);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return recover(\\n            encToDec[compress(shortUrl.substr(shortUrl.rfind(\\'/\\') + 1))]\\n        );\\n    }\\n    \\nprivate:\\n    string compress(string str) {\\n        return \"!\" + str;\\n    }\\n    \\n    string recover(string str) {\\n        return str.substr(1);\\n    }\\n};\\n```\\n\\nI didn\\'t actually write a compression algorithm.\\nBecause it\\'s too difficult.\\n\\n\\nThe above codes can use unordered_map instead of map to improve execution time.\\n\\nSorry if the english expression is weird.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, string> m;\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        m[m.size()] = longUrl;\\n        return \"http://tinyurl.com/\" + to_string(m.size() - 1);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        int idx = shortUrl.rfind(\\'/\\');\\n        return m[stoi(shortUrl.substr(idx + 1))];\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    map<int, string> depth1;\\n    map<string, int> depth1Reverse;\\n    \\n    map<int, map<int, string>> depth2;\\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        int idx = getDepth1LastIdx(longUrl);\\n        \\n        string depth1Url = longUrl.substr(0, idx);\\n        string depth2Url = longUrl.substr(idx);\\n        \\n        int depth1Idx = insertDepth1(depth1Url);\\n        int depth2Idx = insertDepth2(depth1Idx, depth2Url);\\n        \\n        return \"http://tinyurl.com/\" + to_string(depth1Idx)\\n            + (depth2Idx == -1 ? \"\" : \"-\" + to_string(depth2Idx));\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string path = shortUrl.substr(shortUrl.rfind(\\'/\\') + 1);\\n        \\n        int idx = path.find(\\'-\\');\\n        int depth1Idx = stoi(path.substr(0, idx));\\n        int depth2Idx = stoi(path.substr(idx + 1));\\n        return depth1[depth1Idx] + depth2[depth1Idx][depth1Idx];\\n    }\\n    \\nprivate:\\n    int getDepth1LastIdx(string& url) {\\n        int c = 0;\\n        for(int i=0; i<url.size(); i++)\\n            if(url[i] == \\'/\\' && ++c == 3) return i;\\n        return url.size();\\n    }\\n    \\n    int insertDepth1(string& url) {\\n        auto f = depth1Reverse.find(url);\\n        if(f != depth1Reverse.end()) return f->second;\\n        depth1[depth1Reverse.size()] = url;\\n        depth1Reverse[url] = depth1Reverse.size();\\n        return depth1Reverse.size() - 1;\\n    }\\n    \\n    int insertDepth2(int depth1Idx, string& url) {\\n        if(url.size() == 0) return -1;\\n        \\n        if(depth2.find(depth1Idx) == depth2.end())\\n            depth2[depth1Idx] = map<int, string>();\\n        \\n        int depth2Idx = depth2[depth1Idx].size();\\n        depth2[depth1Idx][depth2Idx] = url;\\n        \\n        return depth2Idx;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    map<string, string> encToDec;\\n    map<string, string> decToEnc;\\n    \\n    string characters = \"abcdeafghijklmnopABCDEFGHIJKLMNOP0123456789\";\\n    \\n    Solution() {\\n        srand((unsigned int)time(NULL));\\n    }\\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        if(decToEnc.find(longUrl) != decToEnc.end())\\n            return \"http://tinyurl.com/\" + decToEnc[longUrl];\\n        \\n        while(1) {\\n            string encodedUrl = \"\";\\n            for(int i=0; i<6; i++) {\\n                encodedUrl.push_back(characters[rand() % characters.size()]);\\n            }\\n            if(encToDec.find(encodedUrl) == encToDec.end()) {\\n                decToEnc[longUrl] = encodedUrl;\\n                encToDec[encodedUrl] = longUrl;\\n                break;\\n            }\\n        }\\n        return \"http://tinyurl.com/\" + decToEnc[longUrl];\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return encToDec[shortUrl.substr(shortUrl.rfind(\\'/\\') + 1)];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    map<string, string> encToDec;\\n    map<string, string> decToEnc;\\n    \\n    string characters = \"abcdeafghijklmnopABCDEFGHIJKLMNOP0123456789\";\\n    \\n    int RETRY = 3;\\n    int SIZE = 6;\\n    \\n    Solution() {\\n        srand((unsigned int)time(NULL));\\n    }\\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        if(decToEnc.find(longUrl) != decToEnc.end())\\n            return \"http://tinyurl.com/\" + decToEnc[longUrl];\\n        \\n        int count = 0;\\n        while(1) {\\n            string encodedUrl = \"\";\\n            for(int i=0; i<SIZE; i++) {\\n                encodedUrl.push_back(characters[rand() % characters.size()]);\\n            }\\n            if(encToDec.find(encodedUrl) == encToDec.end()) {\\n                decToEnc[longUrl] = encodedUrl;\\n                encToDec[encodedUrl] = longUrl;\\n                break;\\n            }\\n            if(++count == RETRY) {\\n                SIZE++;\\n                count = 0;\\n            }\\n        }\\n        return \"http://tinyurl.com/\" + decToEnc[longUrl];\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return encToDec[shortUrl.substr(shortUrl.rfind(\\'/\\') + 1)];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    map<string, string> encToDec;\\n    map<string, string> decToEnc;\\n    \\n    string characters = \"abcdeafghijklmnopABCDEFGHIJKLMNOP0123456789\";\\n    \\n    int RETRY = 3;\\n    int SIZE = 6;\\n    \\n    Solution() {\\n        srand((unsigned int)time(NULL));\\n    }\\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string compressedLongUrl = compress(longUrl);\\n        if(decToEnc.find(compressedLongUrl) != decToEnc.end())\\n            return \"http://tinyurl.com/\" + recover(decToEnc[compressedLongUrl]);\\n        \\n        int count = 0;\\n        while(1) {\\n            string encodedUrl = \"\";\\n            for(int i=0; i<SIZE; i++) {\\n                encodedUrl.push_back(characters[rand() % characters.size()]);\\n            }\\n            string compressedEncodedUrl = compress(encodedUrl);\\n            if(encToDec.find(compressedEncodedUrl) == encToDec.end()) {\\n                decToEnc[compressedLongUrl] = compressedEncodedUrl;\\n                encToDec[compressedEncodedUrl] = compressedLongUrl;\\n                break;\\n            }\\n            if(++count == RETRY) {\\n                SIZE++;\\n                count = 0;\\n            }\\n        }\\n        return \"http://tinyurl.com/\" + recover(decToEnc[compressedLongUrl]);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return recover(\\n            encToDec[compress(shortUrl.substr(shortUrl.rfind(\\'/\\') + 1))]\\n        );\\n    }\\n    \\nprivate:\\n    string compress(string str) {\\n        return \"!\" + str;\\n    }\\n    \\n    string recover(string str) {\\n        return str.substr(1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110864,
                "title": "c-simple-hashmap-approach-with-runtime-100-00-of-c",
                "content": "```\\nclass Solution {\\n    unordered_map<string,string> shortner;\\n    int counter=0;\\n    public:\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n\\t\\t//FOR MAKING UNIQUE URL EVERYTIME\\n        string shortUrl=\"http://tinyurl.com/\"+to_string(counter);\\n        shortner[shortUrl] = longUrl;\\n        counter++;\\n        return shortUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortner[shortUrl];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<string,string> shortner;\\n    int counter=0;\\n    public:\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n\\t\\t//FOR MAKING UNIQUE URL EVERYTIME\\n        string shortUrl=\"http://tinyurl.com/\"+to_string(counter);\\n        shortner[shortUrl] = longUrl;\\n        counter++;\\n        return shortUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortner[shortUrl];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110552,
                "title": "encode-and-decode-tinyurl-js-python-java-c-easy-map-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSince the characters we can use in the short url are limited just as much as the characters that can be used to make up the long url, there\\'s not much legitimate compression that can realistically be done.\\n\\nThe only generally feasible option is to use a **map** to act as a lookup table for codes and either use a hashing function or a random code generator to generate the **code**. Since we\\'re storing the information anyway (hashes only work one-way), we might as well just use a random code generator (**getCode()**).\\n\\nBased on the example, we can create a function that creates a random **6**-character code, using the **62 alphanumeric characters**. We should make sure to come up with a new code in the rare case that we randomly create a duplicate.\\n\\nTo avoid having to **encode** the same url twice with different random codes, we can create a reverse lookup table (**urlDB**) to store already encoded urls.\\n\\nThe **decode** function will just **return** the entry from the code map (**codeDB**).\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython has predefined alphanumeric strings, so we can take advantage of that.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 40.3MB** (beats 99% / 61%).\\n```javascript\\nlet codeDB = new Map(), urlDB = new Map()\\nconst chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\\n\\nconst getCode = () => {\\n    let code = new Array(6).fill()\\n        .map(_ => chars.charAt(~~(Math.random() * 62)))\\n    return \"http://tinyurl.com/\" + code.join(\"\")\\n}\\n\\nconst encode = longUrl => {\\n    if (urlDB.has(longUrl)) return urlDB.get(longUrl)\\n    let code = getCode()\\n    while (codeDB.has(code)) code = getCode()\\n    codeDB.set(code, longUrl)\\n    urlDB.set(longUrl, code)\\n    return code\\n}\\n\\nconst decode = shortUrl => codeDB.get(shortUrl)\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.1MB** (beats 98% / 82%).\\n```python\\nclass Codec:\\n    codeDB, urlDB = defaultdict(), defaultdict()\\n    chars = string.ascii_letters + string.digits\\n\\n    def getCode(self) -> str:\\n        code = \\'\\'.join(random.choice(self.chars) for i in range(6))\\n        return \"http://tinyurl.com/\" + code\\n \\n    def encode(self, longUrl: str) -> str:\\n        if longUrl in self.urlDB: return self.urlDB[longUrl]\\n        code = self.getCode()\\n        while code in self.codeDB: code = getCode()\\n        self.codeDB[code] = longUrl\\n        self.urlDB[longUrl] = code\\n        return code\\n\\n    def decode(self, shortUrl: str) -> str:\\n        return self.codeDB[shortUrl]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **3ms / 38.7MB** (beats 83% / 99%).\\n```java\\npublic class Codec {\\n    Map<String, String> codeDB = new HashMap<>(), urlDB = new HashMap<>();\\n    static final String chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n\\n    private String getCode() {\\n        char[] code = new char[6];\\n        for (int i = 0; i < 6; i++) \\n            code[i] = chars.charAt((int)Math.random() * 62);\\n        return \"http://tinyurl.com/\" + String.valueOf(code);\\n    }\\n    \\n    public String encode(String longUrl) {\\n        if (urlDB.containsKey(longUrl)) return urlDB.get(longUrl);\\n        String code = getCode();\\n        while (codeDB.containsKey(code)) code = getCode();\\n        codeDB.put(code, longUrl);\\n        urlDB.put(longUrl, code);\\n        return code;\\n    }\\n\\n    public String decode(String shortUrl) {\\n        return codeDB.get(shortUrl);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.3MB** (beats 100% / 42%).\\n```c++\\nclass Solution {\\npublic:\\n    unordered_map<string, string> codeDB, urlDB;\\n    const string chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n    \\n    string getCode() {\\n        string code = \"\";\\n        for (int i = 0; i < 6; i++) code += chars[rand() % 62];\\n        return \"http://tinyurl.com/\" + code;\\n    }\\n    \\n    string encode(string longUrl) {\\n        if (urlDB.find(longUrl) != urlDB.end()) return urlDB[longUrl];\\n        string code = getCode();\\n        while (codeDB.find(code) != codeDB.end()) code = getCode();\\n        codeDB[code] = longUrl;\\n        urlDB[longUrl] = code;\\n        return code;\\n    }\\n\\n    string decode(string shortUrl) {\\n        return codeDB[shortUrl];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nlet codeDB = new Map(), urlDB = new Map()\\nconst chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\\n\\nconst getCode = () => {\\n    let code = new Array(6).fill()\\n        .map(_ => chars.charAt(~~(Math.random() * 62)))\\n    return \"http://tinyurl.com/\" + code.join(\"\")\\n}\\n\\nconst encode = longUrl => {\\n    if (urlDB.has(longUrl)) return urlDB.get(longUrl)\\n    let code = getCode()\\n    while (codeDB.has(code)) code = getCode()\\n    codeDB.set(code, longUrl)\\n    urlDB.set(longUrl, code)\\n    return code\\n}\\n\\nconst decode = shortUrl => codeDB.get(shortUrl)\\n```\n```python\\nclass Codec:\\n    codeDB, urlDB = defaultdict(), defaultdict()\\n    chars = string.ascii_letters + string.digits\\n\\n    def getCode(self) -> str:\\n        code = \\'\\'.join(random.choice(self.chars) for i in range(6))\\n        return \"http://tinyurl.com/\" + code\\n \\n    def encode(self, longUrl: str) -> str:\\n        if longUrl in self.urlDB: return self.urlDB[longUrl]\\n        code = self.getCode()\\n        while code in self.codeDB: code = getCode()\\n        self.codeDB[code] = longUrl\\n        self.urlDB[longUrl] = code\\n        return code\\n\\n    def decode(self, shortUrl: str) -> str:\\n        return self.codeDB[shortUrl]\\n```\n```java\\npublic class Codec {\\n    Map<String, String> codeDB = new HashMap<>(), urlDB = new HashMap<>();\\n    static final String chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n\\n    private String getCode() {\\n        char[] code = new char[6];\\n        for (int i = 0; i < 6; i++) \\n            code[i] = chars.charAt((int)Math.random() * 62);\\n        return \"http://tinyurl.com/\" + String.valueOf(code);\\n    }\\n    \\n    public String encode(String longUrl) {\\n        if (urlDB.containsKey(longUrl)) return urlDB.get(longUrl);\\n        String code = getCode();\\n        while (codeDB.containsKey(code)) code = getCode();\\n        codeDB.put(code, longUrl);\\n        urlDB.put(longUrl, code);\\n        return code;\\n    }\\n\\n    public String decode(String shortUrl) {\\n        return codeDB.get(shortUrl);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    unordered_map<string, string> codeDB, urlDB;\\n    const string chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n    \\n    string getCode() {\\n        string code = \"\";\\n        for (int i = 0; i < 6; i++) code += chars[rand() % 62];\\n        return \"http://tinyurl.com/\" + code;\\n    }\\n    \\n    string encode(string longUrl) {\\n        if (urlDB.find(longUrl) != urlDB.end()) return urlDB[longUrl];\\n        string code = getCode();\\n        while (codeDB.find(code) != codeDB.end()) code = getCode();\\n        codeDB[code] = longUrl;\\n        urlDB[longUrl] = code;\\n        return code;\\n    }\\n\\n    string decode(string shortUrl) {\\n        return codeDB[shortUrl];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100307,
                "title": "directly-return-the-given-string-got-passed-and-beat-90",
                "content": "Maybe this question should restrict more.\\n\\n```\\n// Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return shortUrl;\\n    } \\n```",
                "solutionTags": [],
                "code": "```\\n// Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return shortUrl;\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2816315,
                "title": "java-straightforward-solution-hashmap",
                "content": "# Code\\n```\\npublic class Codec {\\n    static Map<String, String> cache;\\n    static int count;\\n    public Codec() {\\n        cache = new HashMap<>();\\n        count = 0;\\n    }\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String encoded = count + \"\";\\n            cache.put(encoded, longUrl);\\n            count++;\\n            return encoded;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return cache.get(shortUrl);\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n    static Map<String, String> cache;\\n    static int count;\\n    public Codec() {\\n        cache = new HashMap<>();\\n        count = 0;\\n    }\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String encoded = count + \"\";\\n            cache.put(encoded, longUrl);\\n            count++;\\n            return encoded;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return cache.get(shortUrl);\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974641,
                "title": "cpp-solution-using-map",
                "content": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tmap<string,string> m;\\n\\t\\t\\t\\tint num = 0;\\n\\t\\t\\t\\t// Encodes a URL to a shortened URL.\\n\\t\\t\\t\\tstring encode(string longUrl) {\\n\\t\\t\\t\\t\\tstring ans = \"http://tinyurl.com/\" + to_string(num);\\n\\t\\t\\t\\t\\tnum++;\\n\\t\\t\\t\\t\\tm[ans] = longUrl;\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Decodes a shortened URL to its original URL.\\n\\t\\t\\t\\tstring decode(string shortUrl) {\\n\\t\\t\\t\\t\\treturn m[shortUrl];\\n\\t\\t\\t\\t}\\n\\t\\t\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tmap<string,string> m;\\n\\t\\t\\t\\tint num = 0;\\n\\t\\t\\t\\t// Encodes a URL to a shortened URL.\\n\\t\\t\\t\\tstring encode(string longUrl) {\\n\\t\\t\\t\\t\\tstring ans = \"http://tinyurl.com/\" + to_string(num);\\n\\t\\t\\t\\t\\tnum++;\\n\\t\\t\\t\\t\\tm[ans] = longUrl;\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1110690,
                "title": "short-easy-w-explanation-beats-100",
                "content": "***Solution - I (Just to pass)***\\n\\nIf you just want to solve the question, here you go -\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```\\n\\n----------\\n----------\\n\\n***Solution - II***\\n\\nHere\\'s a better, more practical and robust solution which could be applied in real-world - \\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, string>UrlToCode, codeToUrl;\\n    string alphanumeric, base;    \\n\\t//                   \\uD83D\\uDD3Bs = secure = important! :)\\n    Solution(): base(\"https://tinyurl.com/\"),\\n    alphanumeric(\"abcdefghijklmnopqrstuvwxyzAbCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\") {\\n        srand(time(0)); // seed for random generator used by rand()\\n    }\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        // if encoded url already exists for a given longUrl (dont want duplicates for same url)\\n        if(UrlToCode.count(longUrl)) return base + UrlToCode[longUrl];\\n        string code = \"\";\\n        // generate a random code from alphanumeric string\\n        while(1){\\n            for(int i = 0; i < 6; i++)\\n                code += alphanumeric[rand() % 62];\\n            // if new code is formed, break out of loop\\n            if(!codeToUrl.count(code)) break; \\n            code = \"\";   // loop back to generate a new unique code\\n        }\\n        string encoded = base + code;\\n        UrlToCode[longUrl] = code;    // store longUrl to code mapping to avoid duplicates        \\n        codeToUrl[encoded] = longUrl; // to decode shortened url back to original\\n        return encoded;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return codeToUrl[shortUrl];\\n    }\\n};\\n```\\n\\nThe above code would need to try and generate a new code every time the randomly generated string is found to be already allocated. In theory, it could be possible that the algorithm takes infinite time to generate a shortened Url but I would put the probability of that to be about the same as all the vibrating atoms in your chairs aligning sideways to make you fall \\uD83E\\uDD37\\u200D\\uD83D\\uDE47.\\n\\n\\nSince our code space is huge (`62^6`), it is very unlikely that it would many iterations. We could always increase the `code` length to 7 or 8 to reduce collisions even further but it\\'s not really unnecessary.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, string>UrlToCode, codeToUrl;\\n    string alphanumeric, base;    \\n\\t//                   \\uD83D\\uDD3Bs = secure = important! :)\\n    Solution(): base(\"https://tinyurl.com/\"),\\n    alphanumeric(\"abcdefghijklmnopqrstuvwxyzAbCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\") {\\n        srand(time(0)); // seed for random generator used by rand()\\n    }\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        // if encoded url already exists for a given longUrl (dont want duplicates for same url)\\n        if(UrlToCode.count(longUrl)) return base + UrlToCode[longUrl];\\n        string code = \"\";\\n        // generate a random code from alphanumeric string\\n        while(1){\\n            for(int i = 0; i < 6; i++)\\n                code += alphanumeric[rand() % 62];\\n            // if new code is formed, break out of loop\\n            if(!codeToUrl.count(code)) break; \\n            code = \"\";   // loop back to generate a new unique code\\n        }\\n        string encoded = base + code;\\n        UrlToCode[longUrl] = code;    // store longUrl to code mapping to avoid duplicates        \\n        codeToUrl[encoded] = longUrl; // to decode shortened url back to original\\n        return encoded;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return codeToUrl[shortUrl];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160861,
                "title": "beats-91-10-thread-safe-java-with-explanations",
                "content": "Thanks @kishchenko for great ideas and explanations.\\n\\n**Logic**\\n* encode longUrl and store the mappings \\n* decode shortUrl using the mappings\\n\\n**Essence**\\nWe have to take care of thread safety whenever we have more than one thread accessing the same resources, for example, the map `encodedToUrl` which stores all mappings. Thus, we utilize **ConcurrentHashMap**, which is synchronized. \\n**java.util.concurrent.atomic** is a toolkit of classes that support lock-free thread-safe programming on single variables. In this case, we use an  **AtomicLong** to atomically increment a number as `domainUnique`.\\n\\n**Code**\\n```\\nimport java.util.concurrent.ConcurrentHashMap;\\nimport java.util.concurrent.atomic.AtomicLong;\\n\\npublic class Codec {\\n\\n    private static final String SHARED_URL = \"http://tinyurl.com/\";\\n    private static final AtomicLong atomicLong = new AtomicLong();    \\n    private static final ConcurrentHashMap<String, String> encodedToUrl = new ConcurrentHashMap<>();\\n    \\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String uniqueURL = String.valueOf(atomicLong.getAndIncrement());\\n        encodedToUrl.put(uniqueURL, longUrl);\\n        return SHARED_URL + uniqueURL;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return encodedToUrl.get(shortUrl.substring(SHARED_URL.length()));\\n    }\\n}\\n```\\n**I appreciate your VOTE UP (\\u25B0\\u2579\\u25E1\\u2579\\u25B0)**",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.ConcurrentHashMap;\\nimport java.util.concurrent.atomic.AtomicLong;\\n\\npublic class Codec {\\n\\n    private static final String SHARED_URL = \"http://tinyurl.com/\";\\n    private static final AtomicLong atomicLong = new AtomicLong();    \\n    private static final ConcurrentHashMap<String, String> encodedToUrl = new ConcurrentHashMap<>();\\n    \\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String uniqueURL = String.valueOf(atomicLong.getAndIncrement());\\n        encodedToUrl.put(uniqueURL, longUrl);\\n        return SHARED_URL + uniqueURL;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return encodedToUrl.get(shortUrl.substring(SHARED_URL.length()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148066,
                "title": "javascript-easy-to-understand-solution",
                "content": "```\\nlet hashMap = new Map()\\nvar encode = function(longUrl) {\\n    const code = Math.random().toString(32).slice(5)\\n    const tinyUrl = `https://tinyurl.com/${code}` \\n    hashMap.set(tinyUrl,longUrl)\\n    return tinyUrl\\n};\\nvar decode = function(shortUrl) {\\n    return hashMap.get(shortUrl)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet hashMap = new Map()\\nvar encode = function(longUrl) {\\n    const code = Math.random().toString(32).slice(5)\\n    const tinyUrl = `https://tinyurl.com/${code}` \\n    hashMap.set(tinyUrl,longUrl)\\n    return tinyUrl\\n};\\nvar decode = function(shortUrl) {\\n    return hashMap.get(shortUrl)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1974762,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\npublic class Codec {\\n    Map<Integer, String> map = new HashMap<>();\\n    int i=0;\\n    public String encode(String longUrl) {\\n        map.put(i,longUrl);\\n        return \"http://tinyurl.com/\"+i++;\\n    }\\n    public String decode(String shortUrl) {\\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n    Map<Integer, String> map = new HashMap<>();\\n    int i=0;\\n    public String encode(String longUrl) {\\n        map.put(i,longUrl);\\n        return \"http://tinyurl.com/\"+i++;\\n    }\\n    public String decode(String shortUrl) {\\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974255,
                "title": "super-easy-c-comments-100-easier",
                "content": "***DO UPVOTE IF THIS HELPS !!!!***\\n\\t\\n\\tstring base=\"http://tinyurl.com/\";  //base string\\n    string code=\"abcderfghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%0123456789\";  //unique characters\\n    \\n    unordered_map<string,string> mp1;  //key=longURL, value=encodedURL, used in encode function\\n    unordered_map<string,string> mp2;  //key=shortURL , value=longURL, used in decode function\\n    \\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        \\n        string encoded=convert();  //calling convert wich generates a unique url\\n        \\n        while(mp1.find(encoded)!=mp1.end()){  //checking if it alreday exists, then call convert func again\\n            string encoded=convert();\\n        }\\n        \\n        mp1[longUrl]=encoded;  //stroring value in map1\\n        mp2[encoded]=longUrl;  //stroring reverse of map1 in map2 for decode function\\n        \\n        return encoded;\\n    }\\n\\n    \\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        \\n        while(mp2.find(shortUrl)!=mp2.end()){  //checking in map2 if shortURL exists, if it does, then return\\n            return mp2[shortUrl];              //the corresponding orginal URL to it\\n        }\\n        return \"\";  //else return empty string\\n    }\\n    \\n    // Create a new encoded link\\n    string convert(){\\n        string s=\"\";\\n        \\n        for(int i=0;i<6;i++){   //for obtaining a unique 6 digit code\\n            s+=code[rand()%67];  //rand will generate any random number, so we take modulus in order to keep\\n        }                        //it within range of unique character string i.e. length = 67 \\n        \\n        return s;\\n    }",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "***DO UPVOTE IF THIS HELPS !!!!***\\n\\t\\n\\tstring base=\"http://tinyurl.com/\";  //base string\\n    string code=\"abcderfghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%0123456789\";  //unique characters\\n    \\n    unordered_map<string,string> mp1;  //key=longURL, value=encodedURL, used in encode function\\n    unordered_map<string,string> mp2;  //key=shortURL , value=longURL, used in decode function\\n    \\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        \\n        string encoded=convert();  //calling convert wich generates a unique url\\n        \\n        while(mp1.find(encoded)!=mp1.end()){  //checking if it alreday exists, then call convert func again\\n            string encoded=convert();\\n        }\\n        \\n        mp1[longUrl]=encoded;  //stroring value in map1\\n        mp2[encoded]=longUrl;  //stroring reverse of map1 in map2 for decode function\\n        \\n        return encoded;\\n    }\\n\\n    \\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        \\n        while(mp2.find(shortUrl)!=mp2.end()){  //checking in map2 if shortURL exists, if it does, then return\\n            return mp2[shortUrl];              //the corresponding orginal URL to it\\n        }\\n        return \"\";  //else return empty string\\n    }\\n    \\n    // Create a new encoded link\\n    string convert(){\\n        string s=\"\";\\n        \\n        for(int i=0;i<6;i++){   //for obtaining a unique 6 digit code\\n            s+=code[rand()%67];  //rand will generate any random number, so we take modulus in order to keep\\n        }                        //it within range of unique character string i.e. length = 67 \\n        \\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1973745,
                "title": "easy-python-solution-using-hashmap",
                "content": "Just a simple approach using hashmap.\\n```\\nclass Codec:\\n    def __init__(self):\\n        self.hm = {}\\n        self.count = -1\\n        \\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        self.count += 1\\n        self.hm[self.count] = longUrl\\n        return \"http://tinyurl.com/\" + str(self.count)\\n        \\n\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n        n = len(\"http://tinyurl.com/\")\\n        val = int(shortUrl[n:])\\n        return self.hm[val]\\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.decode(codec.encode(url))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Codec:\\n    def __init__(self):\\n        self.hm = {}\\n        self.count = -1\\n        \\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        self.count += 1\\n        self.hm[self.count] = longUrl\\n        return \"http://tinyurl.com/\" + str(self.count)\\n        \\n\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n        n = len(\"http://tinyurl.com/\")\\n        val = int(shortUrl[n:])\\n        return self.hm[val]\\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.decode(codec.encode(url))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145499,
                "title": "java-hashcode-easy-solution",
                "content": "```\\npublic class Codec {\\n    Map<String, String> mp = new HashMap<>();\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String hashCode=longUrl.hashCode()+\"\"; \\n        mp.put(hashCode,longUrl);\\n        return hashCode;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return mp.get(shortUrl);\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    Map<String, String> mp = new HashMap<>();\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String hashCode=longUrl.hashCode()+\"\"; \\n        mp.put(hashCode,longUrl);\\n        return hashCode;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return mp.get(shortUrl);\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491980,
                "title": "java-one-of-the-easiest-solutions",
                "content": "The code below uses two HashMaps so that in case a single url is fed to the system multiple times, it is not encoded again. Most of the other solutions here ignore that use-case. So, this can be asked as a question to the interviewer. If the there are not much repeated URLs, we can use a single HashMap or a List, but for repeated URLs, we should use 2 HashMaps. \\n```\\nHashMap<String, Integer> forwardMap = new HashMap<>();\\nHashMap<Integer, String> backwardMap = new HashMap<>();\\nint count = 0;\\n\\n// Encodes a URL to a shortened URL.\\npublic String encode(String longUrl) {\\n\\tString sol = \"\";\\n\\tif(!forwardMap.containsKey(longUrl)) {\\n\\t\\tforwardMap.put(longUrl, count);\\n\\t\\tbackwardMap.put(count, longUrl);\\n\\t\\tsol = count+\"\";\\n\\t\\tcount++;\\n\\t} else {\\n\\t\\tsol = forwardMap.get(longUrl)+\"\";\\n\\t}\\n\\treturn sol;\\n}\\n\\n// Decodes a shortened URL to its original URL.\\npublic String decode(String shortUrl) {\\n\\treturn backwardMap.get(Integer.valueOf(shortUrl));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nHashMap<String, Integer> forwardMap = new HashMap<>();\\nHashMap<Integer, String> backwardMap = new HashMap<>();\\nint count = 0;\\n\\n// Encodes a URL to a shortened URL.\\npublic String encode(String longUrl) {\\n\\tString sol = \"\";\\n\\tif(!forwardMap.containsKey(longUrl)) {\\n\\t\\tforwardMap.put(longUrl, count);\\n\\t\\tbackwardMap.put(count, longUrl);\\n\\t\\tsol = count+\"\";\\n\\t\\tcount++;\\n\\t} else {\\n\\t\\tsol = forwardMap.get(longUrl)+\"\";\\n\\t}\\n\\treturn sol;\\n}\\n\\n// Decodes a shortened URL to its original URL.\\npublic String decode(String shortUrl) {\\n\\treturn backwardMap.get(Integer.valueOf(shortUrl));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 100279,
                "title": "javascript-w-psuedo-random-short-url",
                "content": "It's always a good idea to separate out your generator from the rest of your functionality, such that you're able to unit test it.\\n\\nOne thing to note is that there still exists the possibility of a collision, but I'll leave it up to you to ask the interviewer about the level of entropy in the system. For now, this works very well.\\n\\n```\\nvar tinyURLs = {};\\n\\n/**\\n * Encodes a URL to a shortened URL.\\n *\\n * @param {string} longUrl\\n * @return {string}\\n */\\nvar encode = function(longUrl) {\\n    var newShortURL = generateHash(6);\\n    tinyURLs[newShortURL] = longUrl;\\n    return newShortURL;\\n};\\n\\n/**\\n * Generates a psuedo-random ID to use for the shortURL.\\n *\\n * @param {number} length\\n * @return {string}\\n */\\nvar generateHash = function(length) {\\n    var possibleChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\\n    var returnHash = '';\\n    \\n    for (var i = 0; i < length; i++) {\\n        returnHash += possibleChars.charAt(Math.floor(Math.random() * possibleChars.length));\\n    }\\n    \\n    return returnHash;\\n}\\n\\n/**\\n * Decodes a shortened URL to its original URL.\\n *\\n * @param {string} shortUrl\\n * @return {string}\\n */\\nvar decode = function(shortUrl) {\\n    return tinyURLs[shortUrl];\\n};\\n\\nconsole.log(decode(encode(url)));\\n```",
                "solutionTags": [],
                "code": "```\\nvar tinyURLs = {};\\n\\n/**\\n * Encodes a URL to a shortened URL.\\n *\\n * @param {string} longUrl\\n * @return {string}\\n */\\nvar encode = function(longUrl) {\\n    var newShortURL = generateHash(6);\\n    tinyURLs[newShortURL] = longUrl;\\n    return newShortURL;\\n};\\n\\n/**\\n * Generates a psuedo-random ID to use for the shortURL.\\n *\\n * @param {number} length\\n * @return {string}\\n */\\nvar generateHash = function(length) {\\n    var possibleChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\\n    var returnHash = '';\\n    \\n    for (var i = 0; i < length; i++) {\\n        returnHash += possibleChars.charAt(Math.floor(Math.random() * possibleChars.length));\\n    }\\n    \\n    return returnHash;\\n}\\n\\n/**\\n * Decodes a shortened URL to its original URL.\\n *\\n * @param {string} shortUrl\\n * @return {string}\\n */\\nvar decode = function(shortUrl) {\\n    return tinyURLs[shortUrl];\\n};\\n\\nconsole.log(decode(encode(url)));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 100310,
                "title": "complete-c-solution-with-base62-conversions",
                "content": "```\\nclass Solution {\\n    vector<string> indexEncodes; \\n    const string base = \"http://tinyurl.com/\";\\n    \\n    public:\\n    char map62(int x) {\\n        if(x < 10) return (char)('0' + x);\\n        else if(x < 36) return (char)(x + 'a' - 10);\\n        else return (char)(x + 'A' - 36);\\n    }\\n    \\n    int rev62(char c) {\\n        if(c >= '0' && c <= '9') return (c - '0');\\n        else if(c >= 'a' && c <= 'z') return (c - 'a' + 10);\\n        else if(c >= 'A' && c <= 'Z') return (c - 'A' + 36);\\n    }\\n    \\n    string encode62(int x){\\n        string res;\\n        while(x) {\\n            int rem = x % 62;\\n            res += map62(rem);\\n            x /= 62;\\n        }\\n        return res;\\n    }\\n    \\n    int decode62(string s) {\\n        int x = 0;\\n        for(int i = s.size() - 1; i >= 0; i--) {\\n            x *= 62;\\n            x += rev62(s[i]);\\n        }\\n        return x;\\n    }\\n\\n    string encode(string longUrl) {\\n        indexEncodes.push_back(longUrl);\\n        return base + encode62(indexEncodes.size() - 1);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return indexEncodes[decode62(shortUrl.substr(19))];\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<string> indexEncodes; \\n    const string base = \"http://tinyurl.com/\";\\n    \\n    public:\\n    char map62(int x) {\\n        if(x < 10) return (char)('0' + x);\\n        else if(x < 36) return (char)(x + 'a' - 10);\\n        else return (char)(x + 'A' - 36);\\n    }\\n    \\n    int rev62(char c) {\\n        if(c >= '0' && c <= '9') return (c - '0');\\n        else if(c >= 'a' && c <= 'z') return (c - 'a' + 10);\\n        else if(c >= 'A' && c <= 'Z') return (c - 'A' + 36);\\n    }\\n    \\n    string encode62(int x){\\n        string res;\\n        while(x) {\\n            int rem = x % 62;\\n            res += map62(rem);\\n            x /= 62;\\n        }\\n        return res;\\n    }\\n    \\n    int decode62(string s) {\\n        int x = 0;\\n        for(int i = s.size() - 1; i >= 0; i--) {\\n            x *= 62;\\n            x += rev62(s[i]);\\n        }\\n        return x;\\n    }\\n\\n    string encode(string longUrl) {\\n        indexEncodes.push_back(longUrl);\\n        return base + encode62(indexEncodes.size() - 1);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return indexEncodes[decode62(shortUrl.substr(19))];\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359860,
                "title": "single-line-sol",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974030,
                "title": "java-easy-solution-using-hash-map",
                "content": "\\'\\'\\'\\n public class Codec {\\n\\tint key = 1;\\n\\tHashMap<Integer,String> map = new HashMap<>();\\n\\t// Encodes a URL to a shortened URL.\\n\\tpublic String encode(String longUrl) {\\n\\t\\tmap.put(key,longUrl);\\n\\t\\tkey++;\\n\\t\\treturn Integer.toString(key-1);\\n\\t}\\n\\n\\t// Decodes a shortened URL to its original URL.\\n\\tpublic String decode(String shortUrl) {\\n\\t\\tint tmp = Integer.parseInt(shortUrl);\\n\\t\\treturn map.get(tmp);\\n\\t}\\n}",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n public class Codec {\\n\\tint key = 1;\\n\\tHashMap<Integer,String> map = new HashMap<>();\\n\\t// Encodes a URL to a shortened URL.\\n\\tpublic String encode(String longUrl) {\\n\\t\\tmap.put(key,longUrl);\\n\\t\\tkey++;\\n\\t\\treturn Integer.toString(key-1);\\n\\t}\\n\\n\\t// Decodes a shortened URL to its original URL.\\n\\tpublic String decode(String shortUrl) {\\n\\t\\tint tmp = Integer.parseInt(shortUrl);\\n\\t\\treturn map.get(tmp);\\n\\t}\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1110835,
                "title": "python-c-hash-solution",
                "content": "**Python**\\n```\\nclass Codec:\\n    def __init__(self):\\n        self.decode_map = {}\\n    \\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        shortUrl = \"http://tinyurl.com/\" + str(hash(longUrl))\\n        self.decode_map[shortUrl] = longUrl\\n        return shortUrl\\n\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n        return self.decode_map[shortUrl]\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string shortUrl =  \"http://tinyurl.com/\" + to_string(hashFunc(longUrl));\\n        decode_map[shortUrl] = longUrl;\\n        return shortUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return decode_map[shortUrl];\\n    }\\n    \\nprivate:\\n    unordered_map<string, string> decode_map;\\n    unordered_map<string, string>::hasher hashFunc = decode_map.hash_function(); \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n    def __init__(self):\\n        self.decode_map = {}\\n    \\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        shortUrl = \"http://tinyurl.com/\" + str(hash(longUrl))\\n        self.decode_map[shortUrl] = longUrl\\n        return shortUrl\\n\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n        return self.decode_map[shortUrl]\\n```\n```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string shortUrl =  \"http://tinyurl.com/\" + to_string(hashFunc(longUrl));\\n        decode_map[shortUrl] = longUrl;\\n        return shortUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return decode_map[shortUrl];\\n    }\\n    \\nprivate:\\n    unordered_map<string, string> decode_map;\\n    unordered_map<string, string>::hasher hashFunc = decode_map.hash_function(); \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013395,
                "title": "c-0ms-obvious",
                "content": "```\\nclass Solution {\\npublic:\\n  unordered_map<int,string> mp;\\n  int key = 0;\\n    \\n  // Encodes a URL to a shortened URL.\\n  string encode(string longUrl) {\\n    mp[key++] = longUrl;\\n    return to_string(key-1);\\n  }\\n\\n    // Decodes a shortened URL to its original URL.\\n  string decode(string shortUrl) {\\n    return mp[stoi(shortUrl)];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  unordered_map<int,string> mp;\\n  int key = 0;\\n    \\n  // Encodes a URL to a shortened URL.\\n  string encode(string longUrl) {\\n    mp[key++] = longUrl;\\n    return to_string(key-1);\\n  }\\n\\n    // Decodes a shortened URL to its original URL.\\n  string decode(string shortUrl) {\\n    return mp[stoi(shortUrl)];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741274,
                "title": "stupid-question-hence-here-is-my-stupid-but-beating-100-of-them-c-solution",
                "content": "**No checks for verifying shortening LOL :P**\\n```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731699,
                "title": "java-using-decode-function-on-object",
                "content": "```\\npublic class Codec {\\n\\n    // Encodes a URL to a shortened URL.\\n    HashMap<String, String> DB = new HashMap();\\n    String BASE_URL = \"http://tinyurl.com/\";\\n    public String encode(String longUrl) {\\n        String smallUrl = BASE_URL + longUrl.hashCode();\\n        DB.put(smallUrl, longUrl);\\n        return smallUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return DB.get(shortUrl);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a URL to a shortened URL.\\n    HashMap<String, String> DB = new HashMap();\\n    String BASE_URL = \"http://tinyurl.com/\";\\n    public String encode(String longUrl) {\\n        String smallUrl = BASE_URL + longUrl.hashCode();\\n        DB.put(smallUrl, longUrl);\\n        return smallUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return DB.get(shortUrl);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 473622,
                "title": "simplest-python-solution",
                "content": "Simple Python solution:\\n\\nCaveat: the `hash()` funciton in python is reset every time python is restarted. One must use more sophisticated methods to deploy this in the real world. The naive workaround for this would be to re-seed the rng in python so that `hash()` becomes \"deterministic\".\\n\\n```\\nclass Codec:\\n    def __init__(self):\\n        self.dict = {}\\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        shortUrl = hash(longUrl)\\n        self.dict[shortUrl] = longUrl\\n        return shortUrl\\n\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n        return self.dict[shortUrl]\\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.decode(codec.encode(url))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n    def __init__(self):\\n        self.dict = {}\\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        shortUrl = hash(longUrl)\\n        self.dict[shortUrl] = longUrl\\n        return shortUrl\\n\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n        return self.dict[shortUrl]\\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.decode(codec.encode(url))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450592,
                "title": "javascript-base64-encoding",
                "content": "You can use Base64 encoding in JavaScript, but since LC is running Node, you have to use Buffer to do so: \\n\\n```\\n/**\\n * Encodes a URL to a shortened URL.\\n *\\n * @param {string} longUrl\\n * @return {string}\\n */\\nvar encode = function(longUrl) {\\n    let encodedUrl = Buffer.from(longUrl, \\'binary\\').toString(\\'base64\\');\\n    return \"http://tinyurl.com/\" + encodedUrl;\\n};\\n\\n/**\\n * Decodes a shortened URL to its original URL.\\n *\\n * @param {string} shortUrl\\n * @return {string}\\n */\\nvar decode = function(shortUrl) {\\n    let encodedUrl = shortUrl.split(\\'tinyurl.com/\\')[1];\\n    return Buffer.from(encodedUrl, \\'base64\\').toString();\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * decode(encode(url));\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Encodes a URL to a shortened URL.\\n *\\n * @param {string} longUrl\\n * @return {string}\\n */\\nvar encode = function(longUrl) {\\n    let encodedUrl = Buffer.from(longUrl, \\'binary\\').toString(\\'base64\\');\\n    return \"http://tinyurl.com/\" + encodedUrl;\\n};\\n\\n/**\\n * Decodes a shortened URL to its original URL.\\n *\\n * @param {string} shortUrl\\n * @return {string}\\n */\\nvar decode = function(shortUrl) {\\n    let encodedUrl = shortUrl.split(\\'tinyurl.com/\\')[1];\\n    return Buffer.from(encodedUrl, \\'base64\\').toString();\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * decode(encode(url));\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 378720,
                "title": "very-straightforward-python-solution",
                "content": "```python\\nimport string\\nimport random\\n\\nclass Codec:\\n    \\n    def __init__(self):\\n        self.urls_db = {}\\n        self.base_url = \\'http://tinyurl.com/\\'\\n        self.hash_size = 6\\n\\n    def encode(self, longUrl):\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \\n        :type longUrl: str\\n        :rtype: str\\n        \"\"\"\\n        generated_str = \\'\\'.join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(self.hash_size))\\n        while generated_str in self.urls_db:\\n            generated_str = \\'\\'.join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(self.hash_size))\\n        \\n        self.urls_db[generated_str] = longUrl\\n        return self.base_url + generated_str\\n\\n    def decode(self, shortUrl):\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \\n        :type shortUrl: str\\n        :rtype: str\\n        \"\"\"\\n        code = shortUrl.split(\\'/\\')[-1]\\n        return self.urls_db[code]\\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.decode(codec.encode(url))\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nimport string\\nimport random\\n\\nclass Codec:\\n    \\n    def __init__(self):\\n        self.urls_db = {}\\n        self.base_url = \\'http://tinyurl.com/\\'\\n        self.hash_size = 6\\n\\n    def encode(self, longUrl):\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \\n        :type longUrl: str\\n        :rtype: str\\n        \"\"\"\\n        generated_str = \\'\\'.join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(self.hash_size))\\n        while generated_str in self.urls_db:\\n            generated_str = \\'\\'.join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(self.hash_size))\\n        \\n        self.urls_db[generated_str] = longUrl\\n        return self.base_url + generated_str\\n\\n    def decode(self, shortUrl):\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \\n        :type shortUrl: str\\n        :rtype: str\\n        \"\"\"\\n        code = shortUrl.split(\\'/\\')[-1]\\n        return self.urls_db[code]\\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.decode(codec.encode(url))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299963,
                "title": "c-using-base-62-hashing",
                "content": "```\\nclass Solution {\\n    unordered_map<string,string>database;\\n    string b64Converter(string s) {\\n\\tstring temp = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\\n\\tstring hash = \"\";\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tint code = s[i] % 62;\\n\\t\\thash += temp[code];\\n\\t}\\n\\treturn hash;\\n}\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string hashedval = b64Converter(longUrl);\\n        string startVal = hashedval.substr(0,7);\\n        database[\"http://tinyurl.com/\"+startVal] = longUrl;\\n        return \"http://tinyurl.com/\"+startVal;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        if(database.find(shortUrl)==database.end())\\n            return \"\";\\n        return database[shortUrl];\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    unordered_map<string,string>database;\\n    string b64Converter(string s) {\\n\\tstring temp = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\\n\\tstring hash = \"\";\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tint code = s[i] % 62;\\n\\t\\thash += temp[code];\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 144047,
                "title": "c-intuitive-solution-easy-to-read-and-understand-accepted",
                "content": "```\\npublic class Codec {\\n    const string TinyUrlPrefix = @\"http://tinyurl.com/\";\\n    const string KeyCharacterSet = @\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";   //62^6 unique keys possible.\\n    private Random random;\\n    private Dictionary<string, string> urlToKey;\\n    private Dictionary<string, string> keyToUrl;\\n\\t\\t\\n    public Codec()\\n    {\\n        this.random = new Random();\\n        this.urlToKey = new Dictionary<string, string>();\\n        this.keyToUrl = new Dictionary<string, string>();\\n    }\\n\\n    // Encodes a URL to a shortened URL\\n    public string encode(string longUrl) {\\n        string key;\\n        if (!this.urlToKey.TryGetValue(longUrl, out key))\\n        {\\n            while (true)    //To make sure that the generated key is unique.\\n            {\\n                StringBuilder keyBuilder = new StringBuilder();\\n                for (int i = 0; i < 6; i++)\\n                {\\n                    int index = this.random.Next(0, KeyCharacterSet.Length);\\n                    keyBuilder.Append(KeyCharacterSet[index]);\\n                }\\n\\n                key = keyBuilder.ToString();\\n                if (!keyToUrl.ContainsKey(key))   //To make sure that the generated key is unique.\\n                {\\n                    this.keyToUrl[key] = longUrl;\\n                    this.urlToKey[longUrl] = key;\\n                    break;\\n                }\\n            }\\n        }\\n        return Codec.TinyUrlPrefix + key;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public string decode(string shortUrl) {\\n        string key = shortUrl.Replace(Codec.TinyUrlPrefix, string.Empty);            \\n        return this.keyToUrl[key];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    const string TinyUrlPrefix = @\"http://tinyurl.com/\";\\n    const string KeyCharacterSet = @\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";   //62^6 unique keys possible.\\n    private Random random;\\n    private Dictionary<string, string> urlToKey;\\n    private Dictionary<string, string> keyToUrl;\\n\\t\\t\\n    public Codec()\\n    {\\n        this.random = new Random();\\n        this.urlToKey = new Dictionary<string, string>();\\n        this.keyToUrl = new Dictionary<string, string>();\\n    }\\n\\n    // Encodes a URL to a shortened URL\\n    public string encode(string longUrl) {\\n        string key;\\n        if (!this.urlToKey.TryGetValue(longUrl, out key))\\n        {\\n            while (true)    //To make sure that the generated key is unique.\\n            {\\n                StringBuilder keyBuilder = new StringBuilder();\\n                for (int i = 0; i < 6; i++)\\n                {\\n                    int index = this.random.Next(0, KeyCharacterSet.Length);\\n                    keyBuilder.Append(KeyCharacterSet[index]);\\n                }\\n\\n                key = keyBuilder.ToString();\\n                if (!keyToUrl.ContainsKey(key))   //To make sure that the generated key is unique.\\n                {\\n                    this.keyToUrl[key] = longUrl;\\n                    this.urlToKey[longUrl] = key;\\n                    break;\\n                }\\n            }\\n        }\\n        return Codec.TinyUrlPrefix + key;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public string decode(string shortUrl) {\\n        string key = shortUrl.Replace(Codec.TinyUrlPrefix, string.Empty);            \\n        return this.keyToUrl[key];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100322,
                "title": "simple-java-solution-with-base62-conversion",
                "content": "public class Codec {\\n    Long counter = 1L;\\n    Map<Long, String> indexToUrl = new HashMap<Long, String>();\\n    Map<String, Long> urlToIndex = new HashMap<String, Long>();\\n    String base62 = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    \\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        if (urlToIndex.containsKey(longUrl)) {\\n            return \"http://tinyurl.com/\"+base62Encode(urlToIndex.get(longUrl));\\n        }\\n        else {\\n            indexToUrl.put(counter, longUrl);\\n            urlToIndex.put(longUrl, counter);\\n            counter++;\\n            return \"http://tinyurl.com/\"+base62Encode(urlToIndex.get(longUrl));\\n        }\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        String base62Encoded = shortUrl.substring(shortUrl.lastIndexOf(\"/\") + 1);\\n        long decode = 0;\\n        for(int i = 0; i < base62Encoded.length(); i++) {\\n            decode = decode * 62 + base62.indexOf(\"\" + base62Encoded.charAt(i));\\n        }\\n        return indexToUrl.get(decode);\\n    }\\n    \\n    private String base62Encode(long value) {\\n        StringBuilder sb = new StringBuilder();\\n        while (value != 0) {\\n            sb.append(base62.charAt((int)(value % 62)));\\n            value /= 62;\\n        }\\n        while (sb.length() < 6) {\\n            sb.append(0);\\n        }\\n        return sb.reverse().toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "public class Codec {\\n    Long counter = 1L;\\n    Map<Long, String> indexToUrl = new HashMap<Long, String>();\\n    Map<String, Long> urlToIndex = new HashMap<String, Long>();\\n    String base62 = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    \\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        if (urlToIndex.containsKey(longUrl)) {\\n            return \"http://tinyurl.com/\"+base62Encode(urlToIndex.get(longUrl));\\n        }\\n        else {\\n            indexToUrl.put(counter, longUrl);\\n            urlToIndex.put(longUrl, counter);\\n            counter++;\\n            return \"http://tinyurl.com/\"+base62Encode(urlToIndex.get(longUrl));\\n        }\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        String base62Encoded = shortUrl.substring(shortUrl.lastIndexOf(\"/\") + 1);\\n        long decode = 0;\\n        for(int i = 0; i < base62Encoded.length(); i++) {\\n            decode = decode * 62 + base62.indexOf(\"\" + base62Encoded.charAt(i));\\n        }\\n        return indexToUrl.get(decode);\\n    }\\n    \\n    private String base62Encode(long value) {\\n        StringBuilder sb = new StringBuilder();\\n        while (value != 0) {\\n            sb.append(base62.charAt((int)(value % 62)));\\n            value /= 62;\\n        }\\n        while (sb.length() < 6) {\\n            sb.append(0);\\n        }\\n        return sb.reverse().toString();\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 100331,
                "title": "accepted-python-solution-152ms",
                "content": "```python\\nimport random\\n\\nclass Codec:\\n    STRING = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n    map = {}\\n\\n    def encode(self, longUrl):\\n        tag = self.gen_tag()\\n        self.map[tag] = longUrl\\n        return \"http://tinyurl.com/\" + tag\\n\\n    def gen_tag(self):\\n        tag = self.gen_random_str()\\n        while self.map.has_key(tag):\\n            tag = self.gen_random_str()\\n        return tag\\n\\n    def gen_random_str(self):\\n        result = \"\"\\n        for i in xrange(6):\\n            result += self.STRING[random.randint(0,61)]\\n        return result\\n\\n    def decode(self, shortUrl):\\n        return self.map[shortUrl[-6:]]\\n```",
                "solutionTags": [],
                "code": "```python\\nimport random\\n\\nclass Codec:\\n    STRING = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n    map = {}\\n\\n    def encode(self, longUrl):\\n        tag = self.gen_tag()\\n        self.map[tag] = longUrl\\n        return \"http://tinyurl.com/\" + tag\\n\\n    def gen_tag(self):\\n        tag = self.gen_random_str()\\n        while self.map.has_key(tag):\\n            tag = self.gen_random_str()\\n        return tag\\n\\n    def gen_random_str(self):\\n        result = \"\"\\n        for i in xrange(6):\\n            result += self.STRING[random.randint(0,61)]\\n        return result\\n\\n    def decode(self, shortUrl):\\n        return self.map[shortUrl[-6:]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100350,
                "title": "can-anyone-help-me-to-understand-the-question",
                "content": "The questions states:\\n```Note: Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.```\\n\\nMaybe I misunderstand the question, but does it means we are not allowed to use hashtable/database to store the original and shortened url? As I understand the url shortening services are rely on database and cache to store the hash to the original url, otherwise this is more like a string compression algorithm.\\n\\nAny comments are highly appreciated.",
                "solutionTags": [],
                "code": "```Note: Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.```",
                "codeTag": "Java"
            },
            {
                "id": 3293029,
                "title": "535-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nlong_to_short: a dictionary to store the mapping between long and short URLs.\\nshort_to_long: a dictionary to store the mapping between short and long URLs.\\nchar_set: a string of characters used to generate short codes.\\nbase_url: the base URL used to construct the short URL.\\nImplement the encode() method, which takes a long URL as input and returns a short URL as output. The method works as follows:\\n\\nIf the long URL has already been encoded, return the existing short URL.\\nOtherwise, generate a new short URL by randomly selecting 6 characters from the character set and appending them to the base URL.\\nIf the short URL has not been used yet, store the mapping between long and short URLs and return the short URL.\\nIf the short URL has already been used, generate a new short URL and repeat the process.\\nImplement the decode() method, which takes a short URL as input and returns the original long URL as output. The method works by looking up the long URL in the short_to_long dictionary using the short URL as the key.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Codec:\\n    # Initialize the object of the system\\n    def __init__(self):\\n        self.long_to_short = {}\\n        self.short_to_long = {}\\n        self.char_set = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\\n        self.base_url = \"http://tinyurl.com/\"\\n\\n    # Returns a tiny URL for the given longUrl\\n    def encode(self, longUrl: str) -> str:\\n        if longUrl in self.long_to_short:\\n            # If the long URL has already been encoded, return the existing short URL\\n            return self.long_to_short[longUrl]\\n        else:\\n            # Otherwise, generate a new short URL\\n            while True:\\n                # Generate a random 6-character string from the character set\\n                short_code = \"\".join(random.choice(self.char_set) for _ in range(6))\\n                short_url = self.base_url + short_code\\n                if short_url not in self.short_to_long:\\n                    # If the short URL has not been used yet, store the mapping between long and short URLs\\n                    self.long_to_short[longUrl] = short_url\\n                    self.short_to_long[short_url] = longUrl\\n                    return short_url\\n\\n    # Returns the original long URL for the given shortUrl\\n    def decode(self, shortUrl: str) -> str:\\n        return self.short_to_long[shortUrl]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\nclass Codec:\\n    # Initialize the object of the system\\n    def __init__(self):\\n        self.long_to_short = {}\\n        self.short_to_long = {}\\n        self.char_set = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\\n        self.base_url = \"http://tinyurl.com/\"\\n\\n    # Returns a tiny URL for the given longUrl\\n    def encode(self, longUrl: str) -> str:\\n        if longUrl in self.long_to_short:\\n            # If the long URL has already been encoded, return the existing short URL\\n            return self.long_to_short[longUrl]\\n        else:\\n            # Otherwise, generate a new short URL\\n            while True:\\n                # Generate a random 6-character string from the character set\\n                short_code = \"\".join(random.choice(self.char_set) for _ in range(6))\\n                short_url = self.base_url + short_code\\n                if short_url not in self.short_to_long:\\n                    # If the short URL has not been used yet, store the mapping between long and short URLs\\n                    self.long_to_short[longUrl] = short_url\\n                    self.short_to_long[short_url] = longUrl\\n                    return short_url\\n\\n    # Returns the original long URL for the given shortUrl\\n    def decode(self, shortUrl: str) -> str:\\n        return self.short_to_long[shortUrl]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197460,
                "title": "100-perfect-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Codec {\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return shortUrl;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return shortUrl;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903968,
                "title": "solution-using-pickle-module",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYour are given a string and you need to convert it into  a specific format where you should be able to retrieve the original string using the formatted data. We can use the $$pickle module$$ to do such kind of things\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple , In the encode function your are given a string (longUrl) dump it into a variable and return it. \\nIn the decode function you get the formatted or byte stream(shortUrl) . Use the loads method to retrieve the original data and return it that simple !!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity depends on the length of the string . Hence the time complexity is $$O(n)$$.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe haven\\'t used any extra spaces so the space complexity $$O(1)$$.\\n\\n# Code\\n```\\nfrom pickle import dumps,loads\\nclass Codec:\\n    def encode(self, longUrl: str) -> str:\\n        string1  = dumps(longUrl)\\n        return string1\\n    def decode(self, shortUrl: str) -> str:\\n        string1 = loads(shortUrl)\\n        return string1\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.decode(codec.encode(url))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nfrom pickle import dumps,loads\\nclass Codec:\\n    def encode(self, longUrl: str) -> str:\\n        string1  = dumps(longUrl)\\n        return string1\\n    def decode(self, shortUrl: str) -> str:\\n        string1 = loads(shortUrl)\\n        return string1\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.decode(codec.encode(url))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860906,
                "title": "allahu-would-be-proud-of-this-solution",
                "content": "```rs\\nstruct Codec {\\n\\t\\n}\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Codec {\\n    fn new() -> Self {\\n     Codec {}   \\n    }\\n\\t\\n    // Encodes a URL to a shortened URL.\\n    fn encode(&self, longURL: String) -> String {\\n        longURL\\n    }\\n\\t\\n    // Decodes a shortened URL to its original URL.\\n    fn decode(&self, shortURL: String) -> String {\\n        shortURL   \\n    }\\n}\\n\\n/**\\n * Your Codec object will be instantiated and called as such:\\n * let obj = Codec::new();\\n * let s: String = obj.encode(strs);\\n * let ans: VecVec<String> = obj.decode(s);\\n */\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rs\\nstruct Codec {\\n\\t\\n}\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Codec {\\n    fn new() -> Self {\\n     Codec {}   \\n    }\\n\\t\\n    // Encodes a URL to a shortened URL.\\n    fn encode(&self, longURL: String) -> String {\\n        longURL\\n    }\\n\\t\\n    // Decodes a shortened URL to its original URL.\\n    fn decode(&self, shortURL: String) -> String {\\n        shortURL   \\n    }\\n}\\n\\n/**\\n * Your Codec object will be instantiated and called as such:\\n * let obj = Codec::new();\\n * let s: String = obj.encode(strs);\\n * let ans: VecVec<String> = obj.decode(s);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2276768,
                "title": "c-after-solving-this-10-comapnies-are-fighting-over-me",
                "content": "![image](https://assets.leetcode.com/users/images/c6f048aa-a036-427a-bba2-18edba6c0397_1657712748.2732515.png)\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring encode(string longUrl) {\\n\\t\\t   return longUrl; \\n\\t\\t}\\n\\t\\tstring decode(string shortUrl) {\\n\\t\\t\\treturn shortUrl; \\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring encode(string longUrl) {\\n\\t\\t   return longUrl; \\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1975701,
                "title": "sequential-id-generator-o-1-time-to-generate-id-n-factorial-unique-ids",
                "content": "Intution : Idea is to write a id generator that can generate next permutation in constant time (atleast for our use case for smaller values of n lets say 26 we will have 4.0329146e+26 ids which are\\nmore then suffienent for tiny url service)\\n\\nn is number of alphabatic characters, when n=26 you will have ids that contains a-to-z characters.\\n\\n\\nIn id generator if you provide n then it can generate n! unique ids.\\n\\n\\nPlease have a look at this problem before understanding code:\\n\\nhttps://leetcode.com/problems/next-permutation/\\n\\n```\\nimport java.util.StringJoiner;\\n\\nclass IDGenerator {\\n    int codePoints[];\\n    \\n    //n is length of id\\n    public IDGenerator(int n) {\\n    codePoints = new int[n];\\n     for(int i=0;i<codePoints.length;i++) {\\n         codePoints[i]=97+i;\\n     }\\n    }\\n    \\n    public String getId() {\\n        StringJoiner joinNames = new StringJoiner(\"\");\\n        for(int i=0;i<codePoints.length;i++) {\\n            joinNames.add(String.valueOf((char)codePoints[i]));\\n        }\\n        nextPermutation(codePoints);\\n        return joinNames.toString();\\n    }\\n    private void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\\n            i--;\\n        }\\n        if (i >= 0) {\\n            int j = nums.length - 1;\\n            while (nums[j] <= nums[i]) {\\n                j--;\\n            }\\n            swap(nums, i, j);\\n        }\\n        reverse(nums, i + 1);\\n    }\\n\\n    private void reverse(int[] nums, int start) {\\n        int i = start, j = nums.length - 1;\\n        while (i < j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n\\n}\\npublic class Codec {\\n    \\n    static IDGenerator idGenerator;    \\n    static {\\n        /**\\n        with 9 character you will 9! unique ids i.e. (362880)\\n        which i guess is more then sufficent.\\n        \\n        **/\\n        idGenerator = new IDGenerator(9);\\n    }\\n    /*storage is static because test cases are using are creating alway new instance of CODEC so \\n     there will be no ways of identifying is some id is already used or not. \\n     Test verification logic is buggy.\\n     */\\n    static Map<String,String> storeage = new HashMap<>();\\n    \\n    static String BASE=\"http://tinyurl.com/\";\\n    \\n    public String encode(String longUrl) {\\n        String id = idGenerator.getId();\\n        storeage.put(id,longUrl);\\n        return BASE+id;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        String splitedShortUrl[] = shortUrl.split(\"/\");\\n        return storeage.get(splitedShortUrl[splitedShortUrl.length-1]);\\n    }\\n}\\n```\\n\\nI think many modification can be done for proudction ready code.\\n1. Consider server ip or instance id\\n2. Take time stamp or mili sec into consideration which can increse in the current date. which can increase range of ids to 1000 folds.\\n3. return encode ids so that  pattern of ids are wont be visible to attacker if any.\\n\\n\\n\\nPlease upvote if it helps\\nLet me know if some clarification is needed, most of the code is self explantory :-)",
                "solutionTags": [],
                "code": "```\\nimport java.util.StringJoiner;\\n\\nclass IDGenerator {\\n    int codePoints[];\\n    \\n    //n is length of id\\n    public IDGenerator(int n) {\\n    codePoints = new int[n];\\n     for(int i=0;i<codePoints.length;i++) {\\n         codePoints[i]=97+i;\\n     }\\n    }\\n    \\n    public String getId() {\\n        StringJoiner joinNames = new StringJoiner(\"\");\\n        for(int i=0;i<codePoints.length;i++) {\\n            joinNames.add(String.valueOf((char)codePoints[i]));\\n        }\\n        nextPermutation(codePoints);\\n        return joinNames.toString();\\n    }\\n    private void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\\n            i--;\\n        }\\n        if (i >= 0) {\\n            int j = nums.length - 1;\\n            while (nums[j] <= nums[i]) {\\n                j--;\\n            }\\n            swap(nums, i, j);\\n        }\\n        reverse(nums, i + 1);\\n    }\\n\\n    private void reverse(int[] nums, int start) {\\n        int i = start, j = nums.length - 1;\\n        while (i < j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n\\n}\\npublic class Codec {\\n    \\n    static IDGenerator idGenerator;    \\n    static {\\n        /**\\n        with 9 character you will 9! unique ids i.e. (362880)\\n        which i guess is more then sufficent.\\n        \\n        **/\\n        idGenerator = new IDGenerator(9);\\n    }\\n    /*storage is static because test cases are using are creating alway new instance of CODEC so \\n     there will be no ways of identifying is some id is already used or not. \\n     Test verification logic is buggy.\\n     */\\n    static Map<String,String> storeage = new HashMap<>();\\n    \\n    static String BASE=\"http://tinyurl.com/\";\\n    \\n    public String encode(String longUrl) {\\n        String id = idGenerator.getId();\\n        storeage.put(id,longUrl);\\n        return BASE+id;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        String splitedShortUrl[] = shortUrl.split(\"/\");\\n        return storeage.get(splitedShortUrl[splitedShortUrl.length-1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975452,
                "title": "java-zero-allocation-and-constant-time-complexity",
                "content": ":D Sorry interviewers :D \\n\\n```java\\npublic class Codec {\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return shortUrl;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Codec {\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return shortUrl;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974738,
                "title": "c-daily-leetcoding-challenge-april-day-23",
                "content": "```\\nclass Solution {\\n    \\n    unordered_map<string, string> encodeBase;\\n    unordered_map<string, string> decodeBase;\\n    \\n    string getAlphabet(){\\n        \\n        string ans;\\n        \\n        int num = (rand() % (122 - 97 + 1)) + 97;\\n        \\n        ans = char(num);\\n        \\n        return ans;\\n        \\n    }\\n    \\n    string getCode(){\\n        \\n        string code = \"\";\\n        \\n        code += to_string(rand()%10) + getAlphabet() + to_string(rand()%10) + getAlphabet() + to_string(rand()%10) + getAlphabet();\\n        \\n        return code;    \\n        \\n    }\\n    \\npublic:\\n    \\n    Solution(){\\n        decodeBase[\"\"] = \"\";\\n    }\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {       \\n        \\n        if(encodeBase.find(longUrl)!=encodeBase.end()){\\n            return encodeBase[longUrl];\\n        }\\n        \\n        string code = \"\";\\n        \\n        while(decodeBase.find(code)!=decodeBase.end()){\\n            \\n            code = getCode();\\n            \\n        }\\n        \\n        string encodedString = \"http://tinyurl.com/\" + code;\\n        encodeBase[longUrl] = encodedString;\\n        decodeBase[encodedString] = longUrl;       \\n        \\n        return encodedString;\\n        \\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        \\n        return decodeBase[shortUrl];\\n        \\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\n    unordered_map<string, string> encodeBase;\\n    unordered_map<string, string> decodeBase;\\n    \\n    string getAlphabet(){\\n        \\n        string ans;\\n        \\n        int num = (rand() % (122 - 97 + 1)) + 97;\\n        \\n        ans = char(num);\\n        \\n        return ans;\\n        \\n    }\\n    \\n    string getCode(){\\n        \\n        string code = \"\";\\n        \\n        code += to_string(rand()%10) + getAlphabet() + to_string(rand()%10) + getAlphabet() + to_string(rand()%10) + getAlphabet();\\n        \\n        return code;    \\n        \\n    }\\n    \\npublic:\\n    \\n    Solution(){\\n        decodeBase[\"\"] = \"\";\\n    }\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {       \\n        \\n        if(encodeBase.find(longUrl)!=encodeBase.end()){\\n            return encodeBase[longUrl];\\n        }\\n        \\n        string code = \"\";\\n        \\n        while(decodeBase.find(code)!=decodeBase.end()){\\n            \\n            code = getCode();\\n            \\n        }\\n        \\n        string encodedString = \"http://tinyurl.com/\" + code;\\n        encodeBase[longUrl] = encodedString;\\n        decodeBase[encodedString] = longUrl;       \\n        \\n        return encodedString;\\n        \\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        \\n        return decodeBase[shortUrl];\\n        \\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974688,
                "title": "c-has-its-function-to-do-these-operations-c-one-line-code",
                "content": "class Solution {\\npublic:\\n// Encodes a URL to a shortened URL.\\nstring encode(string longUrl) {\\nreturn longUrl;\\n}\\n\\n// Decodes a shortened URL to its original URL.\\nstring decode(string shortUrl) {\\n    return shortUrl;\\n}\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n// Encodes a URL to a shortened URL.\\nstring encode(string longUrl) {\\nreturn longUrl;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1974314,
                "title": "java-python-hashmap-easy-small-solution-time-on-space-on",
                "content": "Runtime: 4 ms, faster than 69.60% of Java online submissions for Encode and Decode TinyURL.\\nMemory Usage: 44.2 MB, less than 11.31% of Java online submissions for Encode and Decode TinyURL.\\n```\\npublic class Codec { \\n  Map<Long, String> table = new HashMap<>();\\n  long id = 1;\\n\\n  public String encode(String longUrl) {\\n    table.put(id, longUrl);\\n    return Long.toString(id++);\\n  }\\n\\n  public String decode(String shortUrl) {\\n    return table.get(Long.parseLong(shortUrl));    \\n  }\\n}\\n```\\n\\nRuntime: 35 ms, faster than 86.51% of Python3 online submissions for Encode and Decode TinyURL.\\nMemory Usage: 14 MB, less than 10.89% of Python3 online submissions for Encode and Decode TinyURL.\\n```\\nclass Codec:\\n  def __init__(self):\\n    self.table = dict()\\n    self.id = 0\\n\\n  def encode(self, longUrl: str) -> str:\\n    self.table[self.id] = longUrl\\n    self.id += 1\\n    return str(self.id - 1)\\n\\n  def decode(self, shortUrl: str) -> str:\\n    return self.table[int(shortUrl)]  \\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\npublic class Codec { \\n  Map<Long, String> table = new HashMap<>();\\n  long id = 1;\\n\\n  public String encode(String longUrl) {\\n    table.put(id, longUrl);\\n    return Long.toString(id++);\\n  }\\n\\n  public String decode(String shortUrl) {\\n    return table.get(Long.parseLong(shortUrl));    \\n  }\\n}\\n```\n```\\nclass Codec:\\n  def __init__(self):\\n    self.table = dict()\\n    self.id = 0\\n\\n  def encode(self, longUrl: str) -> str:\\n    self.table[self.id] = longUrl\\n    self.id += 1\\n    return str(self.id - 1)\\n\\n  def decode(self, shortUrl: str) -> str:\\n    return self.table[int(shortUrl)]  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974211,
                "title": "c-url-shortner-code-for-interviews",
                "content": "```\\nclass Solution {\\n    unordered_map<string, string> um;\\n    int len = 6;\\n    \\n    string generate_random_code(string longUrl) {\\n        string code = \"\";\\n        \\n        for(int i=0; i<len; i++) {\\n            bool type = rand() % 3;\\n            \\n            if(type == 0) { // number\\n                code += char(rand() % 10 + 48);\\n            } else if(type == 1) { // lowercase char\\n                code += char(rand() % 26 + 97);\\n            } else { // uppercase char\\n                code += char(rand() % 26 + 65);\\n            }\\n        }\\n        \\n        if(um.find(code) != um.end()) {\\n            return generate_random_code(longUrl);\\n        } else {\\n            um[code] = longUrl;\\n            return code;\\n        }\\n    }\\n    \\n    string get_code(string shortUrl) {\\n        int n = shortUrl.size();\\n        return shortUrl.substr(n-len, len);\\n    }\\n    \\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string tiny_url = \"http://tinyurl.com/\";\\n        string suffix = generate_random_code(longUrl);\\n        return tiny_url += suffix;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string code = get_code(shortUrl);\\n        return um[code];\\n    }\\n};\\n```\\n\\nThe generate_random_code() generate a 6 digit code for e.g. \"4hTs5Y\" to suffix it after the const url \"http://tinyurl.com/\" for our longUrl e.g. \"https://leetcode.com/problems/encode-and-decode-tinyurl\" and in our hashmap we will it store as pair \\n\\ncode: longUrl \\nlike\\n\"4hTs5Y\": \"https://leetcode.com/problems/encode-and-decode-tinyurl\"\\n\\nThe get_code() gets the last 6 char i.e. the generated code and return the value corresponding to it in the hash-map.\\n\\n**Note:** *If the code generated was already present in our hash-map then, we will again call  generate_random_code() method to generate a new code.*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<string, string> um;\\n    int len = 6;\\n    \\n    string generate_random_code(string longUrl) {\\n        string code = \"\";\\n        \\n        for(int i=0; i<len; i++) {\\n            bool type = rand() % 3;\\n            \\n            if(type == 0) { // number\\n                code += char(rand() % 10 + 48);\\n            } else if(type == 1) { // lowercase char\\n                code += char(rand() % 26 + 97);\\n            } else { // uppercase char\\n                code += char(rand() % 26 + 65);\\n            }\\n        }\\n        \\n        if(um.find(code) != um.end()) {\\n            return generate_random_code(longUrl);\\n        } else {\\n            um[code] = longUrl;\\n            return code;\\n        }\\n    }\\n    \\n    string get_code(string shortUrl) {\\n        int n = shortUrl.size();\\n        return shortUrl.substr(n-len, len);\\n    }\\n    \\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string tiny_url = \"http://tinyurl.com/\";\\n        string suffix = generate_random_code(longUrl);\\n        return tiny_url += suffix;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string code = get_code(shortUrl);\\n        return um[code];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973768,
                "title": "c-super-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944847,
                "title": "c-simple-solution",
                "content": "```\\npublic class Codec \\n{\\n    Dictionary<int,string> map = new();\\n\\n    // Encodes a URL to a shortened URL\\n    public string encode(string longUrl) \\n    {\\n        int hashCode = longUrl.GetHashCode();\\n        map.TryAdd(hashCode,longUrl);\\n        return $\"http://tinyurl.com/{hashCode}\";\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public string decode(string shortUrl) \\n    {\\n        string[] arr= shortUrl.Split(\\'/\\',StringSplitOptions.RemoveEmptyEntries);\\n        int hashCode = int.Parse(arr[arr.Length-1]);\\n        return map[hashCode];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Codec \\n{\\n    Dictionary<int,string> map = new();\\n\\n    // Encodes a URL to a shortened URL\\n    public string encode(string longUrl) \\n    {\\n        int hashCode = longUrl.GetHashCode();\\n        map.TryAdd(hashCode,longUrl);\\n        return $\"http://tinyurl.com/{hashCode}\";\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public string decode(string shortUrl) \\n    {\\n        string[] arr= shortUrl.Split(\\'/\\',StringSplitOptions.RemoveEmptyEntries);\\n        int hashCode = int.Parse(arr[arr.Length-1]);\\n        return map[hashCode];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875626,
                "title": "funny-approach-beat-100-0-ms-solution-c-very-easy-solution",
                "content": "```\\n// Well in this question I didnt encode anything i just take the value from input then just return it\\n\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string a = longUrl;\\n        return a;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        \\n        string b = shortUrl;\\n        return b;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Well in this question I didnt encode anything i just take the value from input then just return it\\n\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string a = longUrl;\\n        return a;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        \\n        string b = shortUrl;\\n        return b;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249789,
                "title": "c-generic-solution-works-for-all-strings",
                "content": "```\\n#define MAX 36\\n#define default 6\\n\\nchar alpha[MAX] = { \\'0\\', \\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\',\\n                    \\'8\\', \\'9\\',\\n                    \\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\',\\n                    \\'h\\', \\'i\\', \\'j\\', \\'k\\', \\'l\\', \\'m\\', \\'n\\', \\n                    \\'o\\', \\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\', \\'u\\',\\n                    \\'v\\', \\'w\\', \\'x\\', \\'y\\', \\'z\\' };\\nclass Solution {\\n    unordered_map<string, string> u;\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        \\n        int val = default;\\n        \\n    //Lets generate a long URL\\n        string encodeURL = \"http://tinyurl.com/\";\\n        do{\\n            \\n            for(int i=0; i< val; i++)\\n            {\\n                encodeURL = encodeURL + alpha[rand() % MAX];\\n            }\\n            \\n            val = val + 1;\\n            \\n        }while(u.find(encodeURL) != u.end());\\n        \\n        u.insert({encodeURL, longUrl});\\n        cout << encodeURL << \"\\\\n\";\\n        \\n        return encodeURL;\\n            \\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        \\n        string str = u[shortUrl];\\n        return str;\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "solutionTags": [],
                "code": "```\\n#define MAX 36\\n#define default 6\\n\\nchar alpha[MAX] = { \\'0\\', \\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\',\\n                    \\'8\\', \\'9\\',\\n                    \\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\',\\n                    \\'h\\', \\'i\\', \\'j\\', \\'k\\', \\'l\\', \\'m\\', \\'n\\', \\n                    \\'o\\', \\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\', \\'u\\',\\n                    \\'v\\', \\'w\\', \\'x\\', \\'y\\', \\'z\\' };\\nclass Solution {\\n    unordered_map<string, string> u;\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        \\n        int val = default;\\n        \\n    //Lets generate a long URL\\n        string encodeURL = \"http://tinyurl.com/\";\\n        do{\\n            \\n            for(int i=0; i< val; i++)\\n            {\\n                encodeURL = encodeURL + alpha[rand() % MAX];\\n            }\\n            \\n            val = val + 1;\\n            \\n        }while(u.find(encodeURL) != u.end());\\n        \\n        u.insert({encodeURL, longUrl});\\n        cout << encodeURL << \"\\\\n\";\\n        \\n        return encodeURL;\\n            \\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        \\n        string str = u[shortUrl];\\n        return str;\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1110799,
                "title": "rust-solution",
                "content": "```rust\\nuse std::cell::RefCell;\\nuse std::collections::hash_map::DefaultHasher;\\nuse std::{\\n    collections::HashMap,\\n    hash::{Hash, Hasher},\\n};\\n\\n#[derive(Default)]\\nstruct Codec {\\n    dict: RefCell<HashMap<String, String>>,\\n}\\n\\nimpl Codec {\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n\\n    fn encode(&self, longURL: String) -> String {\\n        let hex_digest = {\\n            let mut s = DefaultHasher::new();\\n            longURL.hash(&mut s);\\n            let s = s.finish();\\n            format!(\"{:x}\", s)\\n        };\\n        self.dict.borrow_mut().insert(hex_digest.clone(), longURL);\\n        format!(\"http://tinyurl.com/{}\", hex_digest)\\n    }\\n\\n    fn decode(&self, shortURL: String) -> String {\\n        let hex_digest = shortURL.replace(\"http://tinyurl.com/\", \"\");\\n        if let Some(a) = self.dict.borrow().get(&hex_digest) {\\n            return a.clone();\\n        }\\n        return \"\".to_owned();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cell::RefCell;\\nuse std::collections::hash_map::DefaultHasher;\\nuse std::{\\n    collections::HashMap,\\n    hash::{Hash, Hasher},\\n};\\n\\n#[derive(Default)]\\nstruct Codec {\\n    dict: RefCell<HashMap<String, String>>,\\n}\\n\\nimpl Codec {\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n\\n    fn encode(&self, longURL: String) -> String {\\n        let hex_digest = {\\n            let mut s = DefaultHasher::new();\\n            longURL.hash(&mut s);\\n            let s = s.finish();\\n            format!(\"{:x}\", s)\\n        };\\n        self.dict.borrow_mut().insert(hex_digest.clone(), longURL);\\n        format!(\"http://tinyurl.com/{}\", hex_digest)\\n    }\\n\\n    fn decode(&self, shortURL: String) -> String {\\n        let hex_digest = shortURL.replace(\"http://tinyurl.com/\", \"\");\\n        if let Some(a) = self.dict.borrow().get(&hex_digest) {\\n            return a.clone();\\n        }\\n        return \"\".to_owned();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110654,
                "title": "c-simplest-solution-with-explaination",
                "content": "1. Create a map for storing long and short urls.\\n2. To generate a random key, we combine a random number with system\\'s current time.\\n3. store the long url as value for this key.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    map<string,string> m;\\n    string encode(string longUrl) {\\n        \\n        string random = to_string(rand()%10000007) ; // generates a random number\\n        string t = to_string(time(0));  // generates current system time\\n        string key = random+t; // add both to get a unique key\\n        m[key] = longUrl; \\n        return key;        \\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        \\n        return m[shortUrl];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    map<string,string> m;\\n    string encode(string longUrl) {\\n        \\n        string random = to_string(rand()%10000007) ; // generates a random number\\n        string t = to_string(time(0));  // generates current system time\\n        string key = random+t; // add both to get a unique key\\n        m[key] = longUrl; \\n        return key;        \\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        \\n        return m[shortUrl];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110546,
                "title": "easy-c-only-one-map-5-lines-of-code",
                "content": "I don\\'t know about **System Design**, so it **might not be the good solution** according to System Design.\\n\\nHowever I thought it is one of the easiest way to from problem solving point of view.\\n\\nIdea: Storing each url with a number and incrementing the value of that number.\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, string> mp;\\n    int cnt;\\n    Solution(){  cnt = 1;  }\\n\\n    string encode(string longUrl) {\\n        mp[cnt++] = longUrl;\\n        return to_string(cnt-1);\\n    }\\n\\n    string decode(string shortUrl) {  \\n      stringstream ss;  ss<<shortUrl;   // converting string to integer\\n      int i;  ss>>i;\\n      return mp[i];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, string> mp;\\n    int cnt;\\n    Solution(){  cnt = 1;  }\\n\\n    string encode(string longUrl) {\\n        mp[cnt++] = longUrl;\\n        return to_string(cnt-1);\\n    }\\n\\n    string decode(string shortUrl) {  \\n      stringstream ss;  ss<<shortUrl;   // converting string to integer\\n      int i;  ss>>i;\\n      return mp[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110515,
                "title": "encode-and-decode-tinyurl-c-easy-solution-simple-code-with-explanation",
                "content": "The idea is for every` LongUrl` we generate a six random alphanumeric charecters and add to our `shortUrl`, we store it in a `unordered_map` and while decoding we can direcly return the `longUrl` \\n\\n```\\nclass Solution {\\npublic:\\n    vector<char> alphanum= {\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\',\\n                            \\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\n                            \\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\n                            \\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\',\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\n                            \\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\n                            \\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\'};\\n    \\n    unordered_map<string, string> code_Url;\\n    string encode(string longUrl) {\\n        string shortUrl=\"http://tinyurl.com/\";\\n        int t=alphanum.size();\\n        for(int i = 0; i <6; i++) {\\n            int idx=rand()%t;\\n            shortUrl+= alphanum[idx];\\n        }\\n        code_Url[shortUrl] = longUrl;\\n        return shortUrl;\\n    }\\n    string decode(string shortUrl) {\\n        return code_Url[shortUrl];\\n    }\\n};\\n\\n```\\n\\nThis question seems to be not correctly framed by the problem setter, some stupid solutions are also got accepted!!!\\n\\n```\\nclass Solution {\\npublic:\\n    string encode(string longUrl) {\\n       return longUrl;\\n    }\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```\\n\\n**Please Upvote** if you like the code.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<char> alphanum= {\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\',\\n                            \\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\n                            \\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\n                            \\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\',\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\n                            \\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\n                            \\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\'};\\n    \\n    unordered_map<string, string> code_Url;\\n    string encode(string longUrl) {\\n        string shortUrl=\"http://tinyurl.com/\";\\n        int t=alphanum.size();\\n        for(int i = 0; i <6; i++) {\\n            int idx=rand()%t;\\n            shortUrl+= alphanum[idx];\\n        }\\n        code_Url[shortUrl] = longUrl;\\n        return shortUrl;\\n    }\\n    string decode(string shortUrl) {\\n        return code_Url[shortUrl];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string encode(string longUrl) {\\n       return longUrl;\\n    }\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746219,
                "title": "swift-best-solution",
                "content": "```\\nfinal class Codec {\\n    var has = [String: String]()\\n    private let charStr = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\\n\\n     // Encodes a URL to a shortened URL.\\n     func encode(_ longUrl: String) -> String {\\n        var rand = \"\"\\n        for _ in 0...4 {\\n            rand.append(charStr.randomElement()!)\\n        }\\n        has[rand] = longUrl\\n        return \"http://tinyurl.com/\\\\(rand)\"\\n     }\\n\\n     // Decodes a shortened URL to its original URL.\\n     func decode(_ shortUrl: String) -> String {\\n        let lastPath = shortUrl.split(separator: \"/\").last!\\n        return has[String(lastPath)]!\\n     }\\n }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfinal class Codec {\\n    var has = [String: String]()\\n    private let charStr = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\\n\\n     // Encodes a URL to a shortened URL.\\n     func encode(_ longUrl: String) -> String {\\n        var rand = \"\"\\n        for _ in 0...4 {\\n            rand.append(charStr.randomElement()!)\\n        }\\n        has[rand] = longUrl\\n        return \"http://tinyurl.com/\\\\(rand)\"\\n     }\\n\\n     // Decodes a shortened URL to its original URL.\\n     func decode(_ shortUrl: String) -> String {\\n        let lastPath = shortUrl.split(separator: \"/\").last!\\n        return has[String(lastPath)]!\\n     }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654726,
                "title": "python3-simple-solution-using-dict",
                "content": "```\\nimport random\\nclass Codec:\\n    \\n    def __init__(self):\\n        self.url_dict = {}\\n        self.string_length = 6\\n        self.letters = (\"abcdefghijklmnopqrstuvwxyzABCDEF\"\\n                        \"GHIJKLMNOPQRSTUVWXYZ0123456789\")\\n\\n    def generate_short_url(self):\\n        short_url = \"\"\\n        for i in range(self.string_length):\\n            short_url += random.choice(self.letters)\\n        \\n        while short_url in self.url_dict:\\n            short_url = self.generate_short_url()\\n        return short_url\\n\\n    def encode(self, longUrl: str) -> str:\\n        short_url = self.generate_short_url()\\n        self.url_dict[short_url] = longUrl\\n        return short_url\\n\\n    def decode(self, shortUrl: str) -> str:\\n        if shortUrl in self.url_dict:\\n            return self.url_dict[shortUrl]\\n        return None\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport random\\nclass Codec:\\n    \\n    def __init__(self):\\n        self.url_dict = {}\\n        self.string_length = 6\\n        self.letters = (\"abcdefghijklmnopqrstuvwxyzABCDEF\"\\n                        \"GHIJKLMNOPQRSTUVWXYZ0123456789\")\\n\\n    def generate_short_url(self):\\n        short_url = \"\"\\n        for i in range(self.string_length):\\n            short_url += random.choice(self.letters)\\n        \\n        while short_url in self.url_dict:\\n            short_url = self.generate_short_url()\\n        return short_url\\n\\n    def encode(self, longUrl: str) -> str:\\n        short_url = self.generate_short_url()\\n        self.url_dict[short_url] = longUrl\\n        return short_url\\n\\n    def decode(self, shortUrl: str) -> str:\\n        if shortUrl in self.url_dict:\\n            return self.url_dict[shortUrl]\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476746,
                "title": "java-solution-to-help-you-during-interviews-not-a-joke",
                "content": "```\\npublic class Codec {\\n    private final String URL = \"http://tinyurl.com/\";\\n    Map<String, String> encodeMap = new HashMap<>();\\n    Map<String, String> decodeMap = new HashMap<>();\\n    Set<String> encodedUrls = new HashSet<>();\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        if (encodedUrls.contains(longUrl)) {\\n            return URL + decodeMap.get(longUrl);\\n        }\\n        boolean newKeyFound = false;\\n        String key = \"\";\\n        while (!newKeyFound) {\\n            if (!encodeMap.containsKey(URL + key)) {\\n                key = getKey();\\n                newKeyFound = true;\\n            }\\n        }\\n        encodeMap.put(URL + key, longUrl);\\n        decodeMap.put(longUrl, key);\\n        encodedUrls.add(longUrl);\\n        return URL + key;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return encodeMap.get(shortUrl);\\n    }\\n\\n\\n    private String getKey() {\\n        final String alphanumeric = \"ABCDEFGHIJKLMNOPQRSTUVQXYZ0123456789abcdefghijklmnopqrstuvwxyz\";\\n        StringBuilder sb = new StringBuilder(6);\\n        for (int i = 0; i < 6; i++) {\\n            int index = (int) (Math.random() * alphanumeric.length());\\n            sb.append(alphanumeric.charAt(index));\\n        }\\n        return sb.toString();\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    private final String URL = \"http://tinyurl.com/\";\\n    Map<String, String> encodeMap = new HashMap<>();\\n    Map<String, String> decodeMap = new HashMap<>();\\n    Set<String> encodedUrls = new HashSet<>();\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        if (encodedUrls.contains(longUrl)) {\\n            return URL + decodeMap.get(longUrl);\\n        }\\n        boolean newKeyFound = false;\\n        String key = \"\";\\n        while (!newKeyFound) {\\n            if (!encodeMap.containsKey(URL + key)) {\\n                key = getKey();\\n                newKeyFound = true;\\n            }\\n        }\\n        encodeMap.put(URL + key, longUrl);\\n        decodeMap.put(longUrl, key);\\n        encodedUrls.add(longUrl);\\n        return URL + key;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return encodeMap.get(shortUrl);\\n    }\\n\\n\\n    private String getKey() {\\n        final String alphanumeric = \"ABCDEFGHIJKLMNOPQRSTUVQXYZ0123456789abcdefghijklmnopqrstuvwxyz\";\\n        StringBuilder sb = new StringBuilder(6);\\n        for (int i = 0; i < 6; i++) {\\n            int index = (int) (Math.random() * alphanumeric.length());\\n            sb.append(alphanumeric.charAt(index));\\n        }\\n        return sb.toString();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416773,
                "title": "c-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    map<string,string> m;\\n    string h = \"123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    unsigned long long counter=0;\\n    string encode(string longUrl) {\\n        counter=counter+1;\\n        string s = get(counter);\\n        m[s] = longUrl;\\n        return s;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string s) {\\n        return m[s];\\n    }\\n    string get(int c)\\n    {\\n        string s = \"\";\\n        while(c)\\n        {\\n            s.push_back(h[c%64]);\\n            //cout << c << endl;\\n            c /= 64;\\n        }\\n        return s;\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<string,string> m;\\n    string h = \"123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    unsigned long long counter=0;\\n    string encode(string longUrl) {\\n        counter=counter+1;\\n        string s = get(counter);\\n        m[s] = longUrl;\\n        return s;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string s) {\\n        return m[s];\\n    }\\n    string get(int c)\\n    {\\n        string s = \"\";\\n        while(c)\\n        {\\n            s.push_back(h[c%64]);\\n            //cout << c << endl;\\n            c /= 64;\\n        }\\n        return s;\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "codeTag": "C++"
            },
            {
                "id": 405676,
                "title": "easy-to-understand-c-solution-0ms-beats-100",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Encode and Decode TinyURL.\\nMemory Usage: 9.2 MB, less than 71.43% of C++ online submissions for Encode and Decode TinyURL.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    uint64_t id;\\n    unordered_map<string, string> table;\\n    \\n    Solution() : id(1), table() {}\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        \\n        static string charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-\";\\n        string shortUrl;\\n        uint64_t newId = id++;\\n        \\n        while(newId)\\n        {\\n            shortUrl += charset[newId%64];\\n            newId >>= 6;\\n        }\\n        \\n        reverse(shortUrl.begin(), shortUrl.end());\\n        table[shortUrl] = longUrl;\\n        return shortUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        \\n        return table[shortUrl];\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    uint64_t id;\\n    unordered_map<string, string> table;\\n    \\n    Solution() : id(1), table() {}",
                "codeTag": "Java"
            },
            {
                "id": 402341,
                "title": "not-really-an-answer-solution",
                "content": "Highly sneaky, and a horrible way overall. But it just shows that this is indeed possible, though not in spirit of the question I admit.\\n\\n```\\npublic class Codec {\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return shortUrl;\\n    }\\n}\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return shortUrl;\\n    }\\n}\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 235024,
                "title": "using-map-and-date-as-a-key-generator",
                "content": "Get the idea from the forum to use Date.now().toString() as a key generator together with Map\\n```\\n/**\\n * Encodes a URL to a shortened URL.\\n *\\n * @param {string} longUrl\\n * @return {string}\\n */\\nlet map = new Map();\\nlet url = \"http://tinyurl.com/\";\\nvar encode = function(longUrl) {\\n    let key = Date.now().toString();\\n    map.set(key,longUrl);\\n    return url + key;\\n};\\n\\n/**\\n * Decodes a shortened URL to its original URL.\\n *\\n * @param {string} shortUrl\\n * @return {string}\\n */\\nvar decode = function(shortUrl) {\\n    let key = shortUrl.split(url);\\n    return map.get(key[1]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Encodes a URL to a shortened URL.\\n *\\n * @param {string} longUrl\\n * @return {string}\\n */\\nlet map = new Map();\\nlet url = \"http://tinyurl.com/\";\\nvar encode = function(longUrl) {\\n    let key = Date.now().toString();\\n    map.set(key,longUrl);\\n    return url + key;\\n};\\n\\n/**\\n * Decodes a shortened URL to its original URL.\\n *\\n * @param {string} shortUrl\\n * @return {string}\\n */\\nvar decode = function(shortUrl) {\\n    let key = shortUrl.split(url);\\n    return map.get(key[1]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 183171,
                "title": "python-md5-convert-to-base-62-28-ms",
                "content": "1. We can use a-z, A-Z, 0-9 alphabet which makes 62 possible characters for encoding.\n2. We don't want to use plain randomization, since the same long URLs will result in different tiny URLs and we don't want to waste space by storing two maps to keep track of both mappings.\n3. Instead, we will use md5 hash for a long URL and get a hexadecimal hash as a string.\n4. To reduce the length of resulting suffix of tiny URL we get 3 slices of 10 bytes each of original md5 hash  -> convert each of them to integer -> xor them -> convert to base 62 (size of our alphabet) to get the corresponding characters.\n\nNote: Even though we could just use a single 1/3 slice of original md5 hash, we could potentially introduce a collision when 2 different long URLs share the same md5 hash prefix.\n```\nimport hashlib\nimport string\n\n\nclass Codec:\n    _PREFIX = 'http://tinyurl.com'\n    _ALPHABET = string.letters + string.digits\n    _BASE = len(_ALPHABET)\n\n    def __init__(self):\n        self.tiny_to_long = {}\n\n    def _convert_to_base(self, x):\n        result = []\n        while x:\n            x, r = divmod(x, Codec._BASE)\n            result.append(Codec._ALPHABET[r])\n        return ''.join(result)\n\n    def encode(self, longUrl):\n        \"\"\"Encodes a URL to a shortened URL.\n\n        :type longUrl: str\n        :rtype: str\n        \"\"\"\n        md5_hash = hashlib.md5(longUrl).hexdigest()\n        # md5_hash has 32 bytes\n        # get 3 slices of 10 bytes each and xor them so we end up with a shorter URL suffix of len 8\n        size = len(md5_hash)\n\n        x = md5_hash[:size/3]\n        y = md5_hash[size/3:-size/3]\n        z = md5_hash[-size/3:]\n        x_as_int = int(x, 16)\n        y_as_int = int(y, 16)\n        z_as_int = int(z, 16)\n        xored = x_as_int ^ y_as_int ^ z_as_int\n\n        suffix = self._convert_to_base(xored)\n        tiny_url = Codec._PREFIX + '/' + suffix\n        if tiny_url not in self.tiny_to_long:\n            self.tiny_to_long[tiny_url] = longUrl\n\n        return tiny_url\n\t\t\t\t\n    def decode(self, shortUrl):\n        \"\"\"Decodes a shortened URL to its original URL.\n\n        :type shortUrl: str\n        :rtype: str\n        \"\"\"\n        return self.tiny_to_long.get(shortUrl)\n```",
                "solutionTags": [],
                "code": "```\nimport hashlib\nimport string\n\n\nclass Codec:\n    _PREFIX = 'http://tinyurl.com'\n    _ALPHABET = string.letters + string.digits\n    _BASE = len(_ALPHABET)\n\n    def __init__(self):\n        self.tiny_to_long = {}\n\n    def _convert_to_base(self, x):\n        result = []\n        while x:\n            x, r = divmod(x, Codec._BASE)\n            result.append(Codec._ALPHABET[r])\n        return ''.join(result)\n\n    def encode(self, longUrl):\n        \"\"\"Encodes a URL to a shortened URL.\n\n        :type longUrl: str\n        :rtype: str\n        \"\"\"\n        md5_hash = hashlib.md5(longUrl).hexdigest()\n        # md5_hash has 32 bytes\n        # get 3 slices of 10 bytes each and xor them so we end up with a shorter URL suffix of len 8\n        size = len(md5_hash)\n\n        x = md5_hash[:size/3]\n        y = md5_hash[size/3:-size/3]\n        z = md5_hash[-size/3:]\n        x_as_int = int(x, 16)\n        y_as_int = int(y, 16)\n        z_as_int = int(z, 16)\n        xored = x_as_int ^ y_as_int ^ z_as_int\n\n        suffix = self._convert_to_base(xored)\n        tiny_url = Codec._PREFIX + '/' + suffix\n        if tiny_url not in self.tiny_to_long:\n            self.tiny_to_long[tiny_url] = longUrl\n\n        return tiny_url\n\t\t\t\t\n    def decode(self, shortUrl):\n        \"\"\"Decodes a shortened URL to its original URL.\n\n        :type shortUrl: str\n        :rtype: str\n        \"\"\"\n        return self.tiny_to_long.get(shortUrl)\n```",
                "codeTag": "Java"
            },
            {
                "id": 100330,
                "title": "c-hash-table-easy-clear-answer",
                "content": "If this is a standard interview question, it has to have some other restrictions, such as limitation on the total number of key-pairs, in which case we have to consider some scheduling mthods (FIFO, Round Robin, Lottery, etc.)\\n\\n```\\nclass Solution {\\npublic:\\n    int now;\\n    unordered_map<int, string> mp;\\n    \\n    Solution() { now = 0; }\\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        mp[now] = longUrl;\\n        now += 1;\\n        return to_string(now-1);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return mp[stoi(shortUrl)];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int now;\\n    unordered_map<int, string> mp;\\n    \\n    Solution() { now = 0; }\\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        mp[now] = longUrl;\\n        now += 1;\\n        return to_string(now-1);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return mp[stoi(shortUrl)];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866915,
                "title": "beats-100-java-one-line-code-easy-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Codec {\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return shortUrl;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return shortUrl;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501259,
                "title": "java-hashmap",
                "content": "```\\npublic class Codec {\\n\\n    HashMap<String, Integer> stringnum = new HashMap<>();\\n    HashMap<Integer, String> numstring = new HashMap<>();\\n    // Encodes a URL to a shortened URL.\\n    int num = 0;\\n    public String encode(String longUrl) {\\n        // List<String> list = new ArrayList<>();\\n        String s = \"\";\\n        String ans = \"\"; \\n        int j = 0;\\n        for(int i = 0; i < longUrl.length(); i++){\\n            char c = longUrl.charAt(i);\\n            ans+=c;\\n            if(c == \\'/\\' && longUrl.charAt(i+1) == \\'/\\'){\\n                ans+=\\'/\\';\\n                j = i+2;\\n                break;\\n            }\\n        }\\n        for( int i  = j; i<longUrl.length(); i++){\\n            char c = longUrl.charAt(i);\\n            if(c == \\'/\\'){\\n                if(!stringnum.containsKey(s)){\\n                    stringnum.put(s,num++);\\n                    numstring.put(num-1, s);\\n                }\\n                int use = stringnum.get(s);\\n                ans+=use;\\n                ans+=\"-\";\\n                s=\"\";\\n            }\\n            s+=c;\\n        }\\n        if(!stringnum.containsKey(s)){\\n            stringnum.put(s,num++);\\n            numstring.put(num-1, s);\\n        }\\n        int use = stringnum.get(s);\\n        ans+=use;\\n        System.out.println(stringnum);\\n        System.out.println(numstring);\\n        return ans;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        String s = \"\";\\n        String ans = \"\";\\n         int j = 0;\\n        for(int i = 0; i < shortUrl.length(); i++){\\n            char c = shortUrl.charAt(i);\\n            ans+=c;\\n            if(c == \\'/\\' && shortUrl.charAt(i+1) == \\'/\\'){\\n                ans+=\\'/\\';\\n                j = i+2;\\n                break;\\n            }\\n        }\\n        for( int i = j ; i < shortUrl.length() ; i++){\\n            char c = shortUrl.charAt(i);\\n            if(c == \\'-\\'){\\n                String add = numstring.get(Integer.parseInt(s));\\n                ans+=add;\\n                s=\"\";\\n                continue;\\n            }\\n            s+=c;\\n        }\\n        String add = numstring.get(Integer.parseInt(s));\\n        ans+=add;\\n        return ans;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n\\n    HashMap<String, Integer> stringnum = new HashMap<>();\\n    HashMap<Integer, String> numstring = new HashMap<>();\\n    // Encodes a URL to a shortened URL.\\n    int num = 0;\\n    public String encode(String longUrl) {\\n        // List<String> list = new ArrayList<>();\\n        String s = \"\";\\n        String ans = \"\"; \\n        int j = 0;\\n        for(int i = 0; i < longUrl.length(); i++){\\n            char c = longUrl.charAt(i);\\n            ans+=c;\\n            if(c == \\'/\\' && longUrl.charAt(i+1) == \\'/\\'){\\n                ans+=\\'/\\';\\n                j = i+2;\\n                break;\\n            }\\n        }\\n        for( int i  = j; i<longUrl.length(); i++){\\n            char c = longUrl.charAt(i);\\n            if(c == \\'/\\'){\\n                if(!stringnum.containsKey(s)){\\n                    stringnum.put(s,num++);\\n                    numstring.put(num-1, s);\\n                }\\n                int use = stringnum.get(s);\\n                ans+=use;\\n                ans+=\"-\";\\n                s=\"\";\\n            }\\n            s+=c;\\n        }\\n        if(!stringnum.containsKey(s)){\\n            stringnum.put(s,num++);\\n            numstring.put(num-1, s);\\n        }\\n        int use = stringnum.get(s);\\n        ans+=use;\\n        System.out.println(stringnum);\\n        System.out.println(numstring);\\n        return ans;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        String s = \"\";\\n        String ans = \"\";\\n         int j = 0;\\n        for(int i = 0; i < shortUrl.length(); i++){\\n            char c = shortUrl.charAt(i);\\n            ans+=c;\\n            if(c == \\'/\\' && shortUrl.charAt(i+1) == \\'/\\'){\\n                ans+=\\'/\\';\\n                j = i+2;\\n                break;\\n            }\\n        }\\n        for( int i = j ; i < shortUrl.length() ; i++){\\n            char c = shortUrl.charAt(i);\\n            if(c == \\'-\\'){\\n                String add = numstring.get(Integer.parseInt(s));\\n                ans+=add;\\n                s=\"\";\\n                continue;\\n            }\\n            s+=c;\\n        }\\n        String add = numstring.get(Integer.parseInt(s));\\n        ans+=add;\\n        return ans;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421280,
                "title": "explained-random-python3-easy-understanding",
                "content": "Random string from string.ascii_lowercase + string.digits\\n\\n# Complexity \\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Codec:\\n    def __init__(self):\\n                                                                                            #Explaination \\n        self.url_map = {}                                               # dictionary \\n        self.pool = string.ascii_lowercase + string.digits              # pool = abcdefghijklmnopqrstuvwxyz1234567890\\n        self.random_chars = random.choices(self.pool, k = 5)            # random.choices will chose length(k) = 5 string which will be different every time and return in array\\n        self.random_string = \\'\\'.join(self.random_chars)                 # random_string is the len 5 string that we can store to url_map\\n    \\n    def encode(self, longUrl: str) -> str:\\n        \\n        shortUrl = self.random_string                                   \\n        self.url_map[shortUrl] = longUrl                                # Insert in shorturl as key and value = longURL \\n        return \"http://tinyurl.com/\" + shortUrl                         \\n    \\n\\n    def decode(self, shortUrl: str) -> str:\\n\\n        shortUrl = shortUrl.split(\\'/\\')[-1]                              # spliting at 1st occurance of \\'/\\' from right to left\\n        return self.url_map[shortUrl]\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Design",
                    "Hash Function"
                ],
                "code": "```\\nclass Codec:\\n    def __init__(self):\\n                                                                                            #Explaination \\n        self.url_map = {}                                               # dictionary \\n        self.pool = string.ascii_lowercase + string.digits              # pool = abcdefghijklmnopqrstuvwxyz1234567890\\n        self.random_chars = random.choices(self.pool, k = 5)            # random.choices will chose length(k) = 5 string which will be different every time and return in array\\n        self.random_string = \\'\\'.join(self.random_chars)                 # random_string is the len 5 string that we can store to url_map\\n    \\n    def encode(self, longUrl: str) -> str:\\n        \\n        shortUrl = self.random_string                                   \\n        self.url_map[shortUrl] = longUrl                                # Insert in shorturl as key and value = longURL \\n        return \"http://tinyurl.com/\" + shortUrl                         \\n    \\n\\n    def decode(self, shortUrl: str) -> str:\\n\\n        shortUrl = shortUrl.split(\\'/\\')[-1]                              # spliting at 1st occurance of \\'/\\' from right to left\\n        return self.url_map[shortUrl]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393471,
                "title": "c-very-easy-to-understand-very-easy-approach",
                "content": "# Code\\n```\\npublic class Codec\\n{\\n    Dictionary<string, string> shortKey = new Dictionary<string, string>();\\n    int unique = 0;\\n\\n    public string encode(string longUrl)\\n    {\\n        string shortUrl = \"http://our-service.com/\" + unique;\\n        unique++;\\n        \\n        shortKey.Add(shortUrl, longUrl);\\n\\n        return shortUrl;\\n    }\\n\\n    public string decode(string shortUrl)\\n    {\\n        return shortKey[shortUrl];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\npublic class Codec\\n{\\n    Dictionary<string, string> shortKey = new Dictionary<string, string>();\\n    int unique = 0;\\n\\n    public string encode(string longUrl)\\n    {\\n        string shortUrl = \"http://our-service.com/\" + unique;\\n        unique++;\\n        \\n        shortKey.Add(shortUrl, longUrl);\\n\\n        return shortUrl;\\n    }\\n\\n    public string decode(string shortUrl)\\n    {\\n        return shortKey[shortUrl];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392687,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n\\n    unordered_map<string, string> um;\\n    vector<int> digits;\\n    Solution(): digits(4) {}\\n\\n    string hex = \"0123456789abcdef\";\\n    string encode(string longUrl) {\\n        string encoded;\\n        for(int d: digits)\\n            encoded += hex[d];\\n        int r = 1;\\n        for(int i=3; i>=0; i--) {\\n            int s = r+digits[i];\\n            digits[i] = s%16;\\n            r = s/16;\\n        }\\n        um[encoded] = longUrl;\\n        cout << encoded << \" \";\\n        return \"https://tiny.com/\" + encoded;\\n    }\\n    string decode(string shortUrl) {\\n        string encoding = shortUrl.substr(shortUrl.find_last_of(\"/\")+1);\\n        cout << encoding << \" \";\\n        return um[encoding];\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Codec:\\n    def __init__(self):\\n        self.encodeUrl = {}\\n        self.decodeUrl = {}\\n        self.base = \"https://tinyurl.com/\"\\n\\n    def encode(self, longUrl: str) -> str:\\n        if longUrl not in self.encodeUrl:\\n            tinyurl = self.base + str(len(self.encodeUrl)+1)\\n            self.encodeUrl[longUrl] = tinyurl\\n            self.decodeUrl[tinyurl] = longUrl\\n\\n        return self.encodeUrl[longUrl]\\n        \\n    def decode(self, shortUrl: str) -> str:\\n        return self.decodeUrl[shortUrl]\\n```\\n\\n```Java []\\nclass Codec {\\n    Map<String, String> map = new HashMap<>();\\n\\n    public String encode(String longUrl) {\\n        String key = \"bruh69\";\\n        map.put(key, longUrl);\\n        return key;\\n    }\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n\\n    unordered_map<string, string> um;\\n    vector<int> digits;\\n    Solution(): digits(4) {}\\n\\n    string hex = \"0123456789abcdef\";\\n    string encode(string longUrl) {\\n        string encoded;\\n        for(int d: digits)\\n            encoded += hex[d];\\n        int r = 1;\\n        for(int i=3; i>=0; i--) {\\n            int s = r+digits[i];\\n            digits[i] = s%16;\\n            r = s/16;\\n        }\\n        um[encoded] = longUrl;\\n        cout << encoded << \" \";\\n        return \"https://tiny.com/\" + encoded;\\n    }\\n    string decode(string shortUrl) {\\n        string encoding = shortUrl.substr(shortUrl.find_last_of(\"/\")+1);\\n        cout << encoding << \" \";\\n        return um[encoding];\\n    }\\n};\\n```\n```Python3 []\\nclass Codec:\\n    def __init__(self):\\n        self.encodeUrl = {}\\n        self.decodeUrl = {}\\n        self.base = \"https://tinyurl.com/\"\\n\\n    def encode(self, longUrl: str) -> str:\\n        if longUrl not in self.encodeUrl:\\n            tinyurl = self.base + str(len(self.encodeUrl)+1)\\n            self.encodeUrl[longUrl] = tinyurl\\n            self.decodeUrl[tinyurl] = longUrl\\n\\n        return self.encodeUrl[longUrl]\\n        \\n    def decode(self, shortUrl: str) -> str:\\n        return self.decodeUrl[shortUrl]\\n```\n```Java []\\nclass Codec {\\n    Map<String, String> map = new HashMap<>();\\n\\n    public String encode(String longUrl) {\\n        String key = \"bruh69\";\\n        map.put(key, longUrl);\\n        return key;\\n    }\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl);\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3204731,
                "title": "straightforward-approach",
                "content": "```\\nimport random\\n\\nclass Codec:\\n    \\n    def __init__(self):\\n        self.decoder = dict()\\n        self.encoder = dict()\\n        self.letters = list(\\'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\')\\n        self.digits = list(\\'0123456789\\')\\n\\n    def encode(self, longUrl: str) -> str:\\n        if self.encoder.get(longUrl):\\n            return self.encoder.get(longUrl)\\n        while True:\\n            shortUrl = \\'http://tinyurl.com/\\' + self.algorithm()\\n            if self.decoder.get(shortUrl) is None:\\n                self.encoder[longUrl] = shortUrl\\n                self.decoder[shortUrl] = longUrl\\n                return shortUrl\\n\\n    def decode(self, shortUrl: str) -> str:\\n        return self.decoder.get(shortUrl)\\n\\n    def algorithm(self):\\n        random_chars = \\'\\'\\n        for _ in range(6):\\n            random_chars += random.choice(self.letters+self.digits)\\n        return random_chars\\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.decode(codec.encode(url))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport random\\n\\nclass Codec:\\n    \\n    def __init__(self):\\n        self.decoder = dict()\\n        self.encoder = dict()\\n        self.letters = list(\\'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\')\\n        self.digits = list(\\'0123456789\\')\\n\\n    def encode(self, longUrl: str) -> str:\\n        if self.encoder.get(longUrl):\\n            return self.encoder.get(longUrl)\\n        while True:\\n            shortUrl = \\'http://tinyurl.com/\\' + self.algorithm()\\n            if self.decoder.get(shortUrl) is None:\\n                self.encoder[longUrl] = shortUrl\\n                self.decoder[shortUrl] = longUrl\\n                return shortUrl\\n\\n    def decode(self, shortUrl: str) -> str:\\n        return self.decoder.get(shortUrl)\\n\\n    def algorithm(self):\\n        random_chars = \\'\\'\\n        for _ in range(6):\\n            random_chars += random.choice(self.letters+self.digits)\\n        return random_chars\\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.decode(codec.encode(url))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051234,
                "title": "simple-beginner-friendly-c-code-hasmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    int coded_value=256;\\n    unordered_map<string,string>mp;\\n    string encode(string longUrl) {\\n        string res=\"http://tinyurl.com/\"+to_string(coded_value);\\n        coded_value++;\\n        mp[res]=longUrl;\\n        return res;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return mp[shortUrl];\\n        \\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    int coded_value=256;\\n    unordered_map<string,string>mp;\\n    string encode(string longUrl) {\\n        string res=\"http://tinyurl.com/\"+to_string(coded_value);\\n        coded_value++;\\n        mp[res]=longUrl;\\n        return res;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return mp[shortUrl];\\n        \\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018115,
                "title": "java-hashmap-easy-solutions",
                "content": "\\n\\n# Code\\n```\\npublic class Codec {\\n    HashMap<String,String> map=new HashMap<>();\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String key=\"mansi53\";\\n        map.put(key,longUrl);\\n        return key;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl);\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n    HashMap<String,String> map=new HashMap<>();\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String key=\"mansi53\";\\n        map.put(key,longUrl);\\n        return key;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl);\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010649,
                "title": "do-you-think-the-randomgenerator-function-is-redundant-or-is-it-necessary",
                "content": "Do you think the RandomGenerator function is redundant or is it necessary?\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,string> URLs ;\\n\\n    string RandomGenerator(){\\n        string str = \"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890\" , ans = \"\";\\n        int c = time(0);\\n        while(c){\\n            ans = ans + str[c%str.size()];  c/=str.size();\\n        }\\n        return ans ;\\n    }\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string shortUrl = RandomGenerator();\\n        URLs[shortUrl] = longUrl ; \\n        return shortUrl ; \\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n         return URLs[shortUrl] ; \\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,string> URLs ;\\n\\n    string RandomGenerator(){\\n        string str = \"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890\" , ans = \"\";\\n        int c = time(0);\\n        while(c){\\n            ans = ans + str[c%str.size()];  c/=str.size();\\n        }\\n        return ans ;\\n    }\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string shortUrl = RandomGenerator();\\n        URLs[shortUrl] = longUrl ; \\n        return shortUrl ; \\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n         return URLs[shortUrl] ; \\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893348,
                "title": "easiest-solution-with-easy-hack",
                "content": "# Intuition\\n<!--  -->\\n\\n# Approach\\n<!--Just concatinate longUrl with \"http://tinyurl.com/\" and encode is done and decode is just remove \"http://tinyurl.com/\" from shortUrl and you\\'re done \\uD83E\\uDD23 -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- for decode O(n) for encode time required for concatination -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string res = \"http://tinyurl.com/\"+longUrl;\\n        return res;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string res=\"\";\\n        for(int i=19;i<shortUrl.size();i++){\\n            res.push_back(shortUrl[i]);\\n        }\\n        return res;\\n    }\\n\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string res = \"http://tinyurl.com/\"+longUrl;\\n        return res;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string res=\"\";\\n        for(int i=19;i<shortUrl.size();i++){\\n            res.push_back(shortUrl[i]);\\n        }\\n        return res;\\n    }\\n\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879809,
                "title": "python-solution-with-randint-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt First I thought we could implement by hashing index and incease it on regular basis. But I realize that is impossible if declare the index by int and the testcases goes more than that then we need to switch int to long otherwise we can\\'t get shorten Url. \\n\\nThen, I throught we could randomize the value using some randomize function then hash that value against given URL. It help to reduce the problem come from my previous intuition.\\n\\n\\n# Code\\n```\\nclass Codec:\\n    def __init__(self):\\n        self.hashTable = {}\\n\\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        val = -1\\n        while True:\\n            val = randint(0,1000)\\n            if val not in self.hashTable:\\n                self.hashTable[val] = longUrl\\n                break\\n\\n        return str(val)\\n        \\n\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n        return self.hashTable[int(shortUrl)]\\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.decode(codec.encode(url))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Codec:\\n    def __init__(self):\\n        self.hashTable = {}\\n\\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        val = -1\\n        while True:\\n            val = randint(0,1000)\\n            if val not in self.hashTable:\\n                self.hashTable[val] = longUrl\\n                break\\n\\n        return str(val)\\n        \\n\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n        return self.hashTable[int(shortUrl)]\\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.decode(codec.encode(url))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831253,
                "title": "java-hashmap-very-easy-some-nonsense-stalling",
                "content": "### **Please Upvote** :D\\nNo one is actually gonna look what your encoded URL looks like so encode it any way you want.\\nLeave the key with a static value and it\\'d still work because I think that the whole class is called with only one longUrl at a time. The methods `encode()` and `decode()` get called only once and the job\\'s done. It\\'s not like some design question where multiple calls will be made to a function, but if that had happened then we gotta have unique encoded URLs for a particular long URL.\\n\\nIn short, you\\'ll be given a string (long URL) to encode. You need to give back the same string (long URL - in decoded fashion) when asked for it (You\\'ll be offered the key (small URL i.e. the encoded URL) for that job to get the decoded URL back). \\n\\nSo, as we are using a map, just return the value of the key.\\n\\n`key = small URL (encoded)`\\n`value = long URL (our original URL - decoded)`\\n\\nIf you have read this far, you\\'ll realise that none of the things said above has made any sense.\\n\\n**This is the solution:**\\n```\\npublic class Codec {\\n    Map<String, String> map = new HashMap<>();\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String key = \"bruh69\";\\n        map.put(key, longUrl);\\n        return key;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl);\\n    }\\n}\\n\\n// TC: O(1), SC: O(1)\\n```\\nIf you think of this question in a medium way then it is a medium one, because a particular URL needs to have a unique (or encoded) small URL and there would be multiple long URLs so we need to store all of them properly in a map etc. The code can be definitely modified for that case but as legends say, I am lazy.\\n\\nIf you want to have unique enoded strings then you can do something like this:\\n```\\nString key = \"elonmuskisgay.com/\" + Math.random() * 69;\\n```\\nThis will give you a unique string at every call, yeah there are numerous ways you can get this job done. (This string concatenation would cost some runtime).",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n    Map<String, String> map = new HashMap<>();\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String key = \"bruh69\";\\n        map.put(key, longUrl);\\n        return key;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl);\\n    }\\n}\\n\\n// TC: O(1), SC: O(1)\\n```\n```\\nString key = \"elonmuskisgay.com/\" + Math.random() * 69;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638412,
                "title": "2-line-code-simple-and-easy-to-understand-unexpected-c",
                "content": "class Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return decode(longUrl);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return decode(longUrl);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2602145,
                "title": "java-string-hash-code-method",
                "content": "We can use ```hashCode()``` method of String class to get the unique number every time.\\n```\\npublic class Codec {\\n\\n    Map<String,String> map = new HashMap();\\n    \\n    public String encode(String longUrl) {\\n        String code = String.valueOf(longUrl.hashCode());\\n        \\n        map.put(code,longUrl);\\n        return code;  \\n    }\\n\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl);\\n    }\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```hashCode()```\n```\\npublic class Codec {\\n\\n    Map<String,String> map = new HashMap();\\n    \\n    public String encode(String longUrl) {\\n        String code = String.valueOf(longUrl.hashCode());\\n        \\n        map.put(code,longUrl);\\n        return code;  \\n    }\\n\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136924,
                "title": "kotlin-solution",
                "content": "```\\nclass Codec() {\\n    val map = mutableMapOf<String, String>()\\n    var inc = 100\\n\\n    fun encode(longUrl: String): String {\\n        val key = Integer.toHexString(inc++)\\n        map[key] = longUrl\\n        return \"http://tinyurl.com/\" + key\\n\\n    }\\n\\n    fun decode(shortUrl: String): String {\\n        val key = shortUrl.substring(shortUrl.indexOfLast { it==\\'/\\' }+1)\\n        return map[key]!!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Codec() {\\n    val map = mutableMapOf<String, String>()\\n    var inc = 100\\n\\n    fun encode(longUrl: String): String {\\n        val key = Integer.toHexString(inc++)\\n        map[key] = longUrl\\n        return \"http://tinyurl.com/\" + key\\n\\n    }\\n\\n    fun decode(shortUrl: String): String {\\n        val key = shortUrl.substring(shortUrl.indexOfLast { it==\\'/\\' }+1)\\n        return map[key]!!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978652,
                "title": "another-ac-java-solution",
                "content": "```\\npublic class Codec {\\n    Map<String, String> map;\\n    public Codec(){\\n        map = new HashMap<>();\\n    }\\n    public String encode(String longUrl) {\\n        StringBuilder sb = new StringBuilder();\\n        Random r = new Random();\\n        char ch = (char)r.nextInt(100);\\n        sb.append(ch);\\n        while(map.containsKey(sb.toString())){\\n            ch = (char)r.nextInt(100);\\n            sb.append(ch);\\n        }\\n        map.put(sb.toString(),longUrl);\\n        return sb.toString();\\n    }\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n    Map<String, String> map;\\n    public Codec(){\\n        map = new HashMap<>();\\n    }\\n    public String encode(String longUrl) {\\n        StringBuilder sb = new StringBuilder();\\n        Random r = new Random();\\n        char ch = (char)r.nextInt(100);\\n        sb.append(ch);\\n        while(map.containsKey(sb.toString())){\\n            ch = (char)r.nextInt(100);\\n            sb.append(ch);\\n        }\\n        map.put(sb.toString(),longUrl);\\n        return sb.toString();\\n    }\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976301,
                "title": "c-just-a-joke-dlc-april-24",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975818,
                "title": "c-simple-solution",
                "content": "Here\\'s the approach I used -\\n\\n* Firstly, take a **string of subset of all the possible values** that can be allowed in the tinyUrl ([0-9][a-z][A-Z]).\\n* Then take an **unordered map** to store key value pair. (**tinyURL as key and longURL as value** ).\\n* Also define a **generateURL function** which generate **7 digits long tinyUrl** to assign.\\n* Now when encoding the URL, try to **generate the random UR**L until you find a unique URL which isn\\'t already present in the map. then **map longUrl to this tinyUrl.**\\n* In decoding, simply r**eturn the longUrl stored as a value** at tinyUrl key.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n/* A string of subset of all the possible values that can be allowed in the tinyUrl */\\nstring urlWord = \"0123456789abcdefghijklmnopqrstuvABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n\\n/* A map to store tinyURL as key and longURL as value  */\\n    unordered_map<string,string> mp;\\n    string generateShortURL(){\\n        string s = \"\";\\n        for(int i=0;i<7;i++){\\n            s+=to_string((int)(((float)rand()/RAND_MAX)*62));\\n        }\\n        return s;\\n    }\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n       string s =  generateShortURL();\\n\\t   /* checking if the tinyUrl is already present in the map or not */\\n        while(mp.find(s)!=mp.end()){\\n            s =  generateShortURL();\\n        }\\n        mp[s]=longUrl;\\n        return s;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n       return mp[shortUrl];\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```\\n\\nHope it\\'s helpful",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/* A string of subset of all the possible values that can be allowed in the tinyUrl */\\nstring urlWord = \"0123456789abcdefghijklmnopqrstuvABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n\\n/* A map to store tinyURL as key and longURL as value  */\\n    unordered_map<string,string> mp;\\n    string generateShortURL(){\\n        string s = \"\";\\n        for(int i=0;i<7;i++){\\n            s+=to_string((int)(((float)rand()/RAND_MAX)*62));\\n        }\\n        return s;\\n    }\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n       string s =  generateShortURL();\\n\\t   /* checking if the tinyUrl is already present in the map or not */\\n        while(mp.find(s)!=mp.end()){\\n            s =  generateShortURL();\\n        }\\n        mp[s]=longUrl;\\n        return s;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n       return mp[shortUrl];\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975293,
                "title": "using-hashfunction-and-dictionary-easy-explanation-python",
                "content": "### what does hash() function do?\\n* hash function generate hash value of an object.\\n* hash value can be thought of as fingerprint to an object (that means it will be unique for every objects).\\nNote: There is prebuilt hash function in other languages too.\\n\\nI think you might have guessed what we are going to do next.\\n1. Create dictionary (map)\\n2. use the inbuilt hash function to generate hash value for the given url which will be our tiny url.\\n3. store tiny url and given url in dictionary as key and value respectively and return tiny url. ( that will be written in Encode fucntion )\\n4. simply pass the tiny url to dictionary it will give long url and then return that long url. ( that will be in Decode fucntion)\\n\\n```\\nclass Codec:\\n    def __init__(self):\\n        self.dict={}\\n\\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        \\n        shortUrl+=hash(longUrl)\\n        self.dict[shortUrl]=longUrl\\n        return shortUrl\\n        \\n        \\n\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n        return self.dict[shortUrl]\\n        \\n```\\n\\n\\n**Please Upvote, if you find it helpful :)**",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n    def __init__(self):\\n        self.dict={}\\n\\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        \\n        shortUrl+=hash(longUrl)\\n        self.dict[shortUrl]=longUrl\\n        return shortUrl\\n        \\n        \\n\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n        return self.dict[shortUrl]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975004,
                "title": "genuine-solution-using-random-string-map-easy",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    unordered_map<string, string> map;\\n    string tinyUrl = \"http://tinyurl.com/\";\\n\\n    string encode(string longUrl)\\n    {\\n        srand(time(0));\\n        string urlCode = to_string(rand());\\n        string preFix = \"aaaaa\";\\n        for (auto &i : urlCode) i = \\'z\\' - i;\\n\\n        if (map.find(urlCode) == map.end())\\n        {\\n            map[urlCode] = longUrl;\\n            return tinyUrl + urlCode;\\n        }\\n        return encode(longUrl);\\n    }\\n\\n    string decode(string shortUrl)\\n    {\\n        return map[shortUrl.substr(19)];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    unordered_map<string, string> map;\\n    string tinyUrl = \"http://tinyurl.com/\";\\n\\n    string encode(string longUrl)\\n    {\\n        srand(time(0));\\n        string urlCode = to_string(rand());\\n        string preFix = \"aaaaa\";\\n        for (auto &i : urlCode) i = \\'z\\' - i;\\n\\n        if (map.find(urlCode) == map.end())\\n        {\\n            map[urlCode] = longUrl;\\n            return tinyUrl + urlCode;\\n        }\\n        return encode(longUrl);\\n    }\\n\\n    string decode(string shortUrl)\\n    {\\n        return map[shortUrl.substr(19)];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973662,
                "title": "python-java-javascript-a-solution-that-works-but-is-not-a-solution-test-cases-error",
                "content": "I\\'ve seen many easy answers like this on Python made by my friend @TQL in a discord channel:\\n```py\\nclass Codec:\\n\\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        return longUrl\\n\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n        return shortUrl\\n```\\nThis works also in Java:\\n```java\\nclass Solution {\\npublic:\\n\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```\\nThis is also true in JavaScript\\n```js\\n/**\\n * Encodes a URL to a shortened URL.\\n *\\n * @param {string} longUrl\\n * @return {string}\\n */\\n\\nvar encode = function(longUrl) {\\n    return longUrl;\\n};\\n\\n/**\\n * Decodes a shortened URL to its original URL.\\n *\\n * @param {string} shortUrl\\n * @return {string}\\n */\\nvar decode = function(shortUrl) {\\n    return shortUrl;\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * decode(encode(url));\\n */\\n```\\nWell, this is not a good solution. Even when it is accepted returning the original input, this solution is not making any encoding/decoding stuff. This question is so fun! there are aproches using a counter, a hashmap, using in build hashing functions.\\n\\nI would like to see better test for this questions, I don\\'t really know if my approach is trully working or not.\\n\\nI\\'ve enjoyed reading other amazing ideas, however, I\\'m not sure if those appriaches are good enough for this question.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```py\\nclass Codec:\\n\\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        return longUrl\\n\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n        return shortUrl\\n```\n```java\\nclass Solution {\\npublic:\\n\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```\n```js\\n/**\\n * Encodes a URL to a shortened URL.\\n *\\n * @param {string} longUrl\\n * @return {string}\\n */\\n\\nvar encode = function(longUrl) {\\n    return longUrl;\\n};\\n\\n/**\\n * Decodes a shortened URL to its original URL.\\n *\\n * @param {string} shortUrl\\n * @return {string}\\n */\\nvar decode = function(shortUrl) {\\n    return shortUrl;\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * decode(encode(url));\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973639,
                "title": "javascript",
                "content": "```\\n/**\\n * Encodes a URL to a shortened URL.\\n *\\n * @param {string} longUrl\\n * @return {string}\\n */\\nconst map = {};\\nvar encode = function (longUrl) {\\n  let randomHash = \\'\\';\\n  while (!randomHash || randomHash in map) {\\n    randomHash = Math.random().toString(32).slice(-5);\\n  }\\n\\n  const shortUrl = `http://tinyurl.com/${randomHash}`;\\n  map[shortUrl] = longUrl;\\n\\n  return shortUrl;\\n};\\n\\n/**\\n * Decodes a shortened URL to its original URL.\\n *\\n * @param {string} shortUrl\\n * @return {string}\\n */\\nvar decode = function (shortUrl) {\\n  return map[shortUrl];\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * decode(encode(url));\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Encodes a URL to a shortened URL.\\n *\\n * @param {string} longUrl\\n * @return {string}\\n */\\nconst map = {};\\nvar encode = function (longUrl) {\\n  let randomHash = \\'\\';\\n  while (!randomHash || randomHash in map) {\\n    randomHash = Math.random().toString(32).slice(-5);\\n  }\\n\\n  const shortUrl = `http://tinyurl.com/${randomHash}`;\\n  map[shortUrl] = longUrl;\\n\\n  return shortUrl;\\n};\\n\\n/**\\n * Decodes a shortened URL to its original URL.\\n *\\n * @param {string} shortUrl\\n * @return {string}\\n */\\nvar decode = function (shortUrl) {\\n  return map[shortUrl];\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * decode(encode(url));\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1973637,
                "title": "rot13-twice-for-extra-security",
                "content": "```\\ntype Codec struct {\\n}\\n\\n\\nfunc Constructor() Codec {\\n    return Codec{}\\n}\\n\\n// Encodes a URL to a shortened URL.\\nfunc (this *Codec) encode(longUrl string) string {\\n\\treturn longUrl\\n}\\n\\n// Decodes a shortened URL to its original URL.\\nfunc (this *Codec) decode(shortUrl string) string {\\n    return shortUrl\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Codec struct {\\n}\\n\\n\\nfunc Constructor() Codec {\\n    return Codec{}\\n}\\n\\n// Encodes a URL to a shortened URL.\\nfunc (this *Codec) encode(longUrl string) string {\\n\\treturn longUrl\\n}\\n\\n// Decodes a shortened URL to its original URL.\\nfunc (this *Codec) decode(shortUrl string) string {\\n    return shortUrl\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1973627,
                "title": "super-easy",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859728,
                "title": "python-really-simple-solution-using-hashmap",
                "content": "```\\nclass Codec:\\n    def __init__(self):\\n        \\n        self.store = {}\\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        v = hash(longUrl)\\n        self.store[\\'http://tinyurl.com/\\' + str(v)] = longUrl\\n        return \\'http://tinyurl.com/\\' + str(v)\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n       \\n        return self.store[shortUrl]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Codec:\\n    def __init__(self):\\n        \\n        self.store = {}\\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        v = hash(longUrl)\\n        self.store[\\'http://tinyurl.com/\\' + str(v)] = longUrl\\n        return \\'http://tinyurl.com/\\' + str(v)\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n       \\n        return self.store[shortUrl]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840655,
                "title": "python-easy-to-read-and-understand-hashmap",
                "content": "```\\nclass Codec:\\n    def __init__(self):\\n        self.d = {}\\n        self.index = 0\\n\\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        self.index += 1\\n        short = \\'http://tinyurl.com/\\' + str(self.index)\\n        self.d[short] = longUrl\\n        return short\\n\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n        return self.d[shortUrl]\\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.decode(codec.encode(url))",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Codec:\\n    def __init__(self):\\n        self.d = {}\\n        self.index = 0\\n\\n    def encode(self, longUrl: str) -> str:\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \"\"\"\\n        self.index += 1\\n        short = \\'http://tinyurl.com/\\' + str(self.index)\\n        self.d[short] = longUrl\\n        return short\\n\\n    def decode(self, shortUrl: str) -> str:\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \"\"\"\\n        return self.d[shortUrl]\\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.decode(codec.encode(url))",
                "codeTag": "Java"
            },
            {
                "id": 1735746,
                "title": "beginner-friendly-java-solution",
                "content": "```\\npublic class Codec {\\n    \\n    HashMap<String, String> map = new HashMap<>();\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String small = \"http://tinyurl.com/\" + longUrl.hashCode();\\n        map.put(small, longUrl);\\n        return small;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl);\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n    \\n    HashMap<String, String> map = new HashMap<>();\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String small = \"http://tinyurl.com/\" + longUrl.hashCode();\\n        map.put(small, longUrl);\\n        return small;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl);\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684487,
                "title": "c-using-strings-only-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    // Encodes a URL to a shortened URL.\\n    string s;\\n    string tinyUrl;\\n    string encode(string longUrl) {\\n        int sz = longUrl.size();\\n        tinyUrl = longUrl;\\n        int i = sz  - 1;\\n        while(tinyUrl[i] != \\'/\\')\\n        {\\n            s = tinyUrl[i--] + s;\\n            tinyUrl.pop_back();\\n        }\\n        tinyUrl = tinyUrl + \\'$\\';\\n        return tinyUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n            tinyUrl.pop_back(); // popping $ \\n            tinyUrl += s;       // adding the deleted string\\n            return tinyUrl;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    // Encodes a URL to a shortened URL.\\n    string s;\\n    string tinyUrl;\\n    string encode(string longUrl) {\\n        int sz = longUrl.size();\\n        tinyUrl = longUrl;\\n        int i = sz  - 1;\\n        while(tinyUrl[i] != \\'/\\')\\n        {\\n            s = tinyUrl[i--] + s;\\n            tinyUrl.pop_back();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1422107,
                "title": "c-simple-counter-4ms",
                "content": "```cpp\\nclass Solution\\n{\\npublic:\\n  // Encodes a URL to a shortened URL.\\n  string encode(string longUrl)\\n  {\\n    urls[count] = longUrl;\\n    return \"http://tinyurl.com/\" + to_string(count++);\\n  }\\n\\n  // Decodes a shortened URL to its original URL.\\n  string decode(string shortUrl)\\n  {\\n    return urls[std::stoi(shortUrl.substr(19))];\\n  }\\n\\nprivate:\\n  unordered_map<int, string> urls;\\n  int count = 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution\\n{\\npublic:\\n  // Encodes a URL to a shortened URL.\\n  string encode(string longUrl)\\n  {\\n    urls[count] = longUrl;\\n    return \"http://tinyurl.com/\" + to_string(count++);\\n  }\\n\\n  // Decodes a shortened URL to its original URL.\\n  string decode(string shortUrl)\\n  {\\n    return urls[std::stoi(shortUrl.substr(19))];\\n  }\\n\\nprivate:\\n  unordered_map<int, string> urls;\\n  int count = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286545,
                "title": "easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115436,
                "title": "go-two-map-random-string",
                "content": "This is my solution using two map and random string for shorten url.\\n\\n```go\\ntype Codec struct {\\n    str string\\n    url2code map[string]string\\n    code2url map[string]string\\n    \\n}\\n\\nfunc Constructor() Codec {\\n    return Codec{\\n        str:\"abcdefghijklmnopqrstuvwxyz\" + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\",\\n        url2code: make(map[string]string),\\n        code2url: make(map[string]string),\\n    }\\n}\\n\\n// Encodes a URL to a shortened URL.\\nfunc (this *Codec) encode(longUrl string) string {\\n    if code, ok := this.url2code[longUrl]; ok {\\n        return \"http://tinyurl.com/\" + code\\n    }\\n    arr := make([]string, 6)\\n    for i := 0; i < 6; i++ {\\n        arr[i] = string(this.str[rand.Intn(len(this.str))])\\n    }\\n    code := strings.Join(arr, \"\")\\n    this.url2code[longUrl] = code\\n    this.code2url[code] = longUrl\\n    return \"http://tinyurl.com/\" + code\\n}\\n\\n// Decodes a shortened URL to its original URL.\\nfunc (this *Codec) decode(shortUrl string) string {\\n    code := shortUrl[len(shortUrl)-6:]\\n    if url, ok := this.code2url[code]; ok {\\n        return url\\n    }\\n    return \"\"\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype Codec struct {\\n    str string\\n    url2code map[string]string\\n    code2url map[string]string\\n    \\n}\\n\\nfunc Constructor() Codec {\\n    return Codec{\\n        str:\"abcdefghijklmnopqrstuvwxyz\" + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\",\\n        url2code: make(map[string]string),\\n        code2url: make(map[string]string),\\n    }\\n}\\n\\n// Encodes a URL to a shortened URL.\\nfunc (this *Codec) encode(longUrl string) string {\\n    if code, ok := this.url2code[longUrl]; ok {\\n        return \"http://tinyurl.com/\" + code\\n    }\\n    arr := make([]string, 6)\\n    for i := 0; i < 6; i++ {\\n        arr[i] = string(this.str[rand.Intn(len(this.str))])\\n    }\\n    code := strings.Join(arr, \"\")\\n    this.url2code[longUrl] = code\\n    this.code2url[code] = longUrl\\n    return \"http://tinyurl.com/\" + code\\n}\\n\\n// Decodes a shortened URL to its original URL.\\nfunc (this *Codec) decode(shortUrl string) string {\\n    code := shortUrl[len(shortUrl)-6:]\\n    if url, ok := this.code2url[code]; ok {\\n        return url\\n    }\\n    return \"\"\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1112080,
                "title": "c-detailed-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_map<string, string> codeMap, urlMap;\\n    const string chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n    const int len = chars.length();\\n    const string tinyURL = \"http://tinyurl.com/\";\\n    // private method to generate a random 6-char code.\\n    string genCode() {\\n        string code = \"\";\\n        for(int i = 0; i < 6; i++) {\\n            code += chars[rand() % len];\\n        }\\n        return tinyURL + code;\\n    }\\n    \\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        if(longUrl.empty()) return \"\";\\n        // URL already encoded before.\\n        if(urlMap.find(longUrl) != urlMap.end()) {\\n            return urlMap[longUrl];\\n        }\\n        \\n        // generate new unique code.\\n        string code;\\n        do {\\n            code = genCode();\\n        } while(codeMap.find(code) != codeMap.end());\\n        \\n        // Encode Url and return.\\n        codeMap[code] = longUrl;\\n        urlMap[longUrl] = code;\\n        return code;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        if(shortUrl.empty()) return \"\";\\n        // shortUrl expects an entry in CodeMap, return the encoded url.\\n        return codeMap[shortUrl];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<string, string> codeMap, urlMap;\\n    const string chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n    const int len = chars.length();\\n    const string tinyURL = \"http://tinyurl.com/\";\\n    // private method to generate a random 6-char code.\\n    string genCode() {\\n        string code = \"\";\\n        for(int i = 0; i < 6; i++) {\\n            code += chars[rand() % len];\\n        }\\n        return tinyURL + code;\\n    }\\n    \\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        if(longUrl.empty()) return \"\";\\n        // URL already encoded before.\\n        if(urlMap.find(longUrl) != urlMap.end()) {\\n            return urlMap[longUrl];\\n        }\\n        \\n        // generate new unique code.\\n        string code;\\n        do {\\n            code = genCode();\\n        } while(codeMap.find(code) != codeMap.end());\\n        \\n        // Encode Url and return.\\n        codeMap[code] = longUrl;\\n        urlMap[longUrl] = code;\\n        return code;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        if(shortUrl.empty()) return \"\";\\n        // shortUrl expects an entry in CodeMap, return the encoded url.\\n        return codeMap[shortUrl];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111280,
                "title": "rust-0ms-generate-random-unique-short-urls",
                "content": "This approach ensures that the random `shortUrl`s we generate for our `longUrl`s are **unique**.\\nIf we generate a `shortUrl` that already exists (_**very**_ unlikely, but possible), our `loop` within `encode()` will ensure we try again.\\n\\nUnfortunately, we have to use `RefCell` here, as the test code creates an immutable `Codec`.\\nThis means that we can\\'t make our methods take a `&mut Codec` (even though Leetcode says we can - _leetcode pls fix_).\\n\\n```\\nuse rand::{distributions::Alphanumeric, Rng};\\nuse std::{\\n    cell::RefCell,\\n    collections::{hash_map::Entry, HashMap},\\n};\\n\\n#[derive(Default)]\\nstruct Codec {\\n    to_long: RefCell<HashMap<String, String>>,\\n    to_short: RefCell<HashMap<String, String>>,\\n}\\n\\nimpl Codec {\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n\\n    fn encode(&self, longUrl: String) -> String {\\n        let (mut to_short, mut to_long) = (self.to_short.borrow_mut(), self.to_long.borrow_mut());\\n\\n        match to_short.entry(longUrl.clone()) {\\n            Entry::Occupied(o) => o.get().clone(),\\n            Entry::Vacant(v_short) => loop {\\n                let shortUrl: String = \"https://tinyurl.com/\"\\n                    .chars()\\n                    .chain(rand::thread_rng().sample_iter(&Alphanumeric).take(6))\\n                    .collect();\\n\\n                if let Entry::Vacant(v_long) = to_long.entry(shortUrl.clone()) {\\n                    v_long.insert(longUrl);\\n                    break v_short.insert(shortUrl).clone();\\n                }\\n            },\\n        }\\n    }\\n\\n    fn decode(&self, shortUrl: String) -> String {\\n        self.to_long.borrow()[&shortUrl].clone()\\n    }\\n}\\n```\\n\\nIf you have spare time on your hands, you can make this implementation even more robust:\\n\\nConsider the case where we have many, _many_, _**many**_ URLs encoded.\\n(Possibly _**billions**_; we have 6 random alphanumeric (`a-z`, `A-Z`, `0-9`) characters in our `shortUrl`s, giving us `(26 + 26 + 10) ^ 6 == 56 800 235 584` possible uniques!)\\n\\nDue to the large number of URLs, we may require multiple `loop` iterations before we generate a unique `shortUrl`.\\nIn this case, we\\'ll want to implement some logic to increase the number of random characters we generate for our `shortUrl`s dynamically (or maybe we want to include some non-alphanumeric characters too).\\n\\nMaybe this can be an exercise for the reader? :)\\n(Of course, by this point, you\\'ll want to store your URLs in some sort of database instead, and not all-at-once in memory \\uD83D\\uDE02)",
                "solutionTags": [],
                "code": "```\\nuse rand::{distributions::Alphanumeric, Rng};\\nuse std::{\\n    cell::RefCell,\\n    collections::{hash_map::Entry, HashMap},\\n};\\n\\n#[derive(Default)]\\nstruct Codec {\\n    to_long: RefCell<HashMap<String, String>>,\\n    to_short: RefCell<HashMap<String, String>>,\\n}\\n\\nimpl Codec {\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n\\n    fn encode(&self, longUrl: String) -> String {\\n        let (mut to_short, mut to_long) = (self.to_short.borrow_mut(), self.to_long.borrow_mut());\\n\\n        match to_short.entry(longUrl.clone()) {\\n            Entry::Occupied(o) => o.get().clone(),\\n            Entry::Vacant(v_short) => loop {\\n                let shortUrl: String = \"https://tinyurl.com/\"\\n                    .chars()\\n                    .chain(rand::thread_rng().sample_iter(&Alphanumeric).take(6))\\n                    .collect();\\n\\n                if let Entry::Vacant(v_long) = to_long.entry(shortUrl.clone()) {\\n                    v_long.insert(longUrl);\\n                    break v_short.insert(shortUrl).clone();\\n                }\\n            },\\n        }\\n    }\\n\\n    fn decode(&self, shortUrl: String) -> String {\\n        self.to_long.borrow()[&shortUrl].clone()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110722,
                "title": "java-easy-solution-fast-100-0ms",
                "content": "```\\npublic class Codec {\\n\\n    // Encodes a URL to a shortened URL.\\n    public Map<String,String>m1=new HashMap<String,String>();\\n    static int i=0;\\n    public String encode(String longUrl) {\\n        String s=\"http://tinyurl.com/\";\\n        s+=String.valueOf(i);\\n       \\n        m1.put(s,longUrl);\\n        \\n        i++;\\n          \\n        return s;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return m1.get(shortUrl);\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a URL to a shortened URL.\\n    public Map<String,String>m1=new HashMap<String,String>();\\n    static int i=0;\\n    public String encode(String longUrl) {\\n        String s=\"http://tinyurl.com/\";\\n        s+=String.valueOf(i);\\n       \\n        m1.put(s,longUrl);\\n        \\n        i++;\\n          \\n        return s;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return m1.get(shortUrl);\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.decode(codec.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110509,
                "title": "python",
                "content": "If we use a codeword of length 6 and only small letters form English alphabet we can have roughly 309 million different combinations. It depends how fast this table will be filled but if we assume that only a smaller subset will be used we can simply use random codeword generation (with rejection if the codeword is already allocated). Otherwise we can also increment one-by-one; but I chose the simpler route here. We can also use `collections.defautdict` to check if the codeword is in use, in constant time.\\n\\n```python\\nimport random\\nclass Codec:\\n    def __init__(self):\\n        self.lookup = collections.defaultdict(str)\\n        \\n        \\n    def encode(self, longUrl):\\n        while True:\\n            short = \\'\\'.join(chr(97 + random.randint(0, 25)) for _ in range(6))\\n            if not self.lookup[short]: break\\n        shortUrl = \\'http://tinyurl.com/\\' + short\\n        self.lookup[shortUrl] = longUrl\\n        return shortUrl\\n        \\n        \\n    def decode(self, shortUrl):\\n        return self.lookup[shortUrl]\\n```",
                "solutionTags": [],
                "code": "```python\\nimport random\\nclass Codec:\\n    def __init__(self):\\n        self.lookup = collections.defaultdict(str)\\n        \\n        \\n    def encode(self, longUrl):\\n        while True:\\n            short = \\'\\'.join(chr(97 + random.randint(0, 25)) for _ in range(6))\\n            if not self.lookup[short]: break\\n        shortUrl = \\'http://tinyurl.com/\\' + short\\n        self.lookup[shortUrl] = longUrl\\n        return shortUrl\\n        \\n        \\n    def decode(self, shortUrl):\\n        return self.lookup[shortUrl]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044283,
                "title": "swift-using-uuid",
                "content": "```\\nclass Codec {\\n    // Encodes a URL to a shortened URL.\\n    var map = [String: String]()\\n    func encode(_ longUrl: String) -> String {\\n        var uuid = UUID().uuidString\\n        // making sure that we havent already used the same\\n        // UUID before\\n        while map[uuid] != nil {\\n            uuid = UUID().uuidString\\n        }\\n        map[uuid] = longUrl\\n        return \"http://tinyurl.com/\\\\(uuid)\"\\n    }\\n    \\n    // Decodes a shortened URL to its original URL.\\n    func decode(_ shortUrl: String) -> String {\\n        let uuidString = shortUrl.split(separator:\"/\").last!\\n        return map[String(uuidString)]!\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec {\\n    // Encodes a URL to a shortened URL.\\n    var map = [String: String]()\\n    func encode(_ longUrl: String) -> String {\\n        var uuid = UUID().uuidString\\n        // making sure that we havent already used the same\\n        // UUID before\\n        while map[uuid] != nil {\\n            uuid = UUID().uuidString\\n        }\\n        map[uuid] = longUrl\\n        return \"http://tinyurl.com/\\\\(uuid)\"\\n    }\\n    \\n    // Decodes a shortened URL to its original URL.\\n    func decode(_ shortUrl: String) -> String {\\n        let uuidString = shortUrl.split(separator:\"/\").last!\\n        return map[String(uuidString)]!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019145,
                "title": "java-solution-generate-short-url-string-of-length-6",
                "content": "```\\n//below soln is based on https://leetcode.com/problems/encode-and-decode-tinyurl/discuss/160861/Beats-91.10-Thread-safe-Java-with-Explanations\\n\\n\\n\\npublic class Codec {\\n   \\n    // use concurrentHashMap to take care of concurrent requests\\n    //https://leetcode.com/problems/encode-and-decode-tinyurl/discuss/160861/Beats-91.10-Thread-safe-Java-with-Explanations\\n    \\n    Map <String,String> tinyURLFwdMap = new ConcurrentHashMap <>();\\n    Map <String,String> tinyURLRevMap = new ConcurrentHashMap <>();\\n    int SHORT_URL_LEN = 6;\\n    \\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n\\n        //if mapping already exist, return the encoded string\\n\\t\\t//continue otherwise\\n        if(tinyURLFwdMap.containsKey(longUrl)){\\n          return (String)tinyURLFwdMap.get(longUrl);  \\n        } \\n\\n        Random rand = new Random();        \\n        String charSet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\\n        StringBuffer sb = new StringBuffer();\\n        String shortUrl = null;\\n\\t\\t\\n        do {\\n        \\n\\t\\t//create a random string of length 6 usingthe charSet and random function\\n        for(int i = 0 ; i < SHORT_URL_LEN; i++){            \\n            //rand.nextInt(36) => returns 0 - 35                     \\n            sb.append(charSet.charAt(rand.nextInt(36)));\\n        }\\n            \\n        shortUrl = sb.toString();\\n        //repeat until we find a unique short url\\n        }while(tinyURLRevMap.containsKey(shortUrl));\\n        \\n\\t\\t//keep both forward and reverse mapping to facilitate dup check\\n        tinyURLFwdMap.put(longUrl,shortUrl);\\n        tinyURLRevMap.put(shortUrl,longUrl);\\n        \\n        return shortUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n       return tinyURLRevMap.get(shortUrl);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//below soln is based on https://leetcode.com/problems/encode-and-decode-tinyurl/discuss/160861/Beats-91.10-Thread-safe-Java-with-Explanations\\n\\n\\n\\npublic class Codec {\\n   \\n    // use concurrentHashMap to take care of concurrent requests\\n    //https://leetcode.com/problems/encode-and-decode-tinyurl/discuss/160861/Beats-91.10-Thread-safe-Java-with-Explanations\\n    \\n    Map <String,String> tinyURLFwdMap = new ConcurrentHashMap <>();\\n    Map <String,String> tinyURLRevMap = new ConcurrentHashMap <>();\\n    int SHORT_URL_LEN = 6;\\n    \\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n\\n        //if mapping already exist, return the encoded string\\n\\t\\t//continue otherwise\\n        if(tinyURLFwdMap.containsKey(longUrl)){\\n          return (String)tinyURLFwdMap.get(longUrl);  \\n        } \\n\\n        Random rand = new Random();        \\n        String charSet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\\n        StringBuffer sb = new StringBuffer();\\n        String shortUrl = null;\\n\\t\\t\\n        do {\\n        \\n\\t\\t//create a random string of length 6 usingthe charSet and random function\\n        for(int i = 0 ; i < SHORT_URL_LEN; i++){            \\n            //rand.nextInt(36) => returns 0 - 35                     \\n            sb.append(charSet.charAt(rand.nextInt(36)));\\n        }\\n            \\n        shortUrl = sb.toString();\\n        //repeat until we find a unique short url\\n        }while(tinyURLRevMap.containsKey(shortUrl));\\n        \\n\\t\\t//keep both forward and reverse mapping to facilitate dup check\\n        tinyURLFwdMap.put(longUrl,shortUrl);\\n        tinyURLRevMap.put(shortUrl,longUrl);\\n        \\n        return shortUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n       return tinyURLRevMap.get(shortUrl);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997628,
                "title": "c-one-hashmap-time-space-discussed",
                "content": "**Unordered_map**\\nTime Complexity: \\nIn `encode`, \\n* `find` complexity is O (1) according to [this](http://www.cplusplus.com/reference/unordered_map/unordered_map/find/)\\n* The possibility of it hitting a code which is already existing is really less, so you can take the time complexity to map shortUrl and longUrl as O (1). Would love your thoughts on this.\\n\\nIn `decode`\\n* I am not sure about the time complexity of find_last_of, as of today, the time complexity is unspecified or linear (?). Refer [this](http://www.cplusplus.com/reference/string/string/find_last_of/) for more.\\n\\nSpace Complexity: O(n)\\nLinear, directly proportional to the amount of URLs you input. \\n```\\nclass Solution {\\npublic:\\n    string chars=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\\n    unordered_map<string, string> umap;\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string code;\\n        while (umap.find(code)==umap.end()) {\\n            random_shuffle (chars.begin(), chars.end());\\n            code=chars.substr (0,6);\\n            if (umap.find(code)==umap.end()) umap[code]=longUrl;\\n        }\\n        return \"http://tinyurl.com/\"+code;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        int pos=shortUrl.find_last_of(\\'/\\');\\n        return umap[shortUrl.substr(pos+1)];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string chars=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\\n    unordered_map<string, string> umap;\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string code;\\n        while (umap.find(code)==umap.end()) {\\n            random_shuffle (chars.begin(), chars.end());\\n            code=chars.substr (0,6);\\n            if (umap.find(code)==umap.end()) umap[code]=longUrl;\\n        }\\n        return \"http://tinyurl.com/\"+code;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        int pos=shortUrl.find_last_of(\\'/\\');\\n        return umap[shortUrl.substr(pos+1)];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953953,
                "title": "go-generate-random-string",
                "content": "```\\nconst charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\\n\\nvar seededRand *rand.Rand = rand.New(\\n\\trand.NewSource(time.Now().UnixNano()))\\n\\ntype Codec struct {\\n\\tbase string\\n\\turls map[string]string\\n}\\n\\nfunc Constructor() Codec {\\n\\treturn Codec{\\n\\t\\tbase:\"http://tinyurl.com\",\\n\\t\\turls: map[string]string{},\\n\\t}\\n}\\n\\n// Encodes a URL to a shortened URL.\\nfunc (this *Codec) encode(longUrl string) string {\\n\\tb := make([]byte, 8)\\n\\tfor i := range b {\\n\\t\\tb[i] = charset[seededRand.Intn(len(charset))]\\n\\t}\\n\\thash := \"/\" + string(b)\\n\\tthis.urls[hash] = longUrl\\n\\treturn this.base + hash\\n}\\n\\n// Decodes a shortened URL to its original URL.\\nfunc (this *Codec) decode(shortUrl string) string {\\n\\tu, err := url.Parse(shortUrl)\\n\\tif err != nil {\\n\\t\\tpanic(err)\\n\\t}\\n\\treturn  this.urls[u.Path]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\\n\\nvar seededRand *rand.Rand = rand.New(\\n\\trand.NewSource(time.Now().UnixNano()))\\n\\ntype Codec struct {\\n\\tbase string\\n\\turls map[string]string\\n}\\n\\nfunc Constructor() Codec {\\n\\treturn Codec{\\n\\t\\tbase:\"http://tinyurl.com\",\\n\\t\\turls: map[string]string{},\\n\\t}\\n}\\n\\n// Encodes a URL to a shortened URL.\\nfunc (this *Codec) encode(longUrl string) string {\\n\\tb := make([]byte, 8)\\n\\tfor i := range b {\\n\\t\\tb[i] = charset[seededRand.Intn(len(charset))]\\n\\t}\\n\\thash := \"/\" + string(b)\\n\\tthis.urls[hash] = longUrl\\n\\treturn this.base + hash\\n}\\n\\n// Decodes a shortened URL to its original URL.\\nfunc (this *Codec) decode(shortUrl string) string {\\n\\tu, err := url.Parse(shortUrl)\\n\\tif err != nil {\\n\\t\\tpanic(err)\\n\\t}\\n\\treturn  this.urls[u.Path]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 765054,
                "title": "very-stupid-question-no-checking-and-my-two-answer-in-java",
                "content": "public class Codec {\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return shortUrl;\\n    }\\n}\\n``\\n2.\\npublic class Codec {\\n    Map<String,String>map=new HashMap();\\n     int val=0;\\n   \\n    public String encode(String longUrl) {\\n        String enc=\"http://tinyurl.com/\"+ val++;\\n        map.put(enc,longUrl);\\n        return enc;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        if(map.containsKey(shortUrl))\\n        {\\n            return map.get(shortUrl);\\n        }\\n        return \"\";\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "public class Codec {\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return shortUrl;\\n    }\\n}\\n``\\n2.\\npublic class Codec {\\n    Map<String,String>map=new HashMap();\\n     int val=0;\\n   \\n    public String encode(String longUrl) {\\n        String enc=\"http://tinyurl.com/\"+ val++;\\n        map.put(enc,longUrl);\\n        return enc;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        if(map.containsKey(shortUrl))\\n        {\\n            return map.get(shortUrl);\\n        }\\n        return \"\";\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 748054,
                "title": "two-simple-solutions-with-hashmap-0-ms-beats-100",
                "content": "First thought is having a map of random keys and returning from the map.\\n**Note: Here we need to handle the collisions.**\\n```\\nclass Solution {\\n     unordered_map<string, string> shorttolong;\\n\\n     public:\\n\\n     string gen_random(int len) {\\n         string s = \"\";\\n         for (int i = 0; i < len; ++i) {\\n             int randomChar = rand() % (26 + 26 + 10);\\n             if (randomChar < 26)\\n                 s += string(1, \\'a\\' + randomChar);\\n             else if (randomChar < 26 + 26)\\n                 s += string(1, \\'A\\' + randomChar - 26);\\n             else\\n                 s += string(1, \\'0\\' + randomChar - 26 - 26);\\n         }\\n         return s;\\n    }\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string key = gen_random(4);\\n        while(shorttolong.find(key) != shorttolong.end()) {\\n            key = gen_random(4);\\n        }\\n        \\n        shorttolong[key] = longUrl;\\n        return key;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shorttolong[shortUrl];\\n    }\\n};\\n\\n```\\n\\nIf you think about it, we can just keep a mapping of an auto incremented variable as the key. This way we **do not** have to handle collisions.\\n\\n```\\nclass Solution {\\n    unordered_map<int, string> shorttolong;\\n    int count = 0;\\n\\n    public:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        count++;\\n        shorttolong[count] = longUrl;\\n        return to_string(count);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shorttolong[stoi(shortUrl)];\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n     unordered_map<string, string> shorttolong;\\n\\n     public:\\n\\n     string gen_random(int len) {\\n         string s = \"\";\\n         for (int i = 0; i < len; ++i) {\\n             int randomChar = rand() % (26 + 26 + 10);\\n             if (randomChar < 26)\\n                 s += string(1, \\'a\\' + randomChar);\\n             else if (randomChar < 26 + 26)\\n                 s += string(1, \\'A\\' + randomChar - 26);\\n             else\\n                 s += string(1, \\'0\\' + randomChar - 26 - 26);\\n         }\\n         return s;\\n    }\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string key = gen_random(4);\\n        while(shorttolong.find(key) != shorttolong.end()) {\\n            key = gen_random(4);\\n        }\\n        \\n        shorttolong[key] = longUrl;\\n        return key;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shorttolong[shortUrl];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    unordered_map<int, string> shorttolong;\\n    int count = 0;\\n\\n    public:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        count++;\\n        shorttolong[count] = longUrl;\\n        return to_string(count);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shorttolong[stoi(shortUrl)];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603114,
                "title": "java-easy-best-solution",
                "content": "```\\npublic class Codec {\\n    \\n    String string = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    \\n        String key;\\n    Map<String, String> map = new HashMap<>();\\n    \\n    Random rand = new Random();\\n    \\n    private String getKey(){\\n        \\n        StringBuilder s = new StringBuilder();\\n        for(int ind = 0; ind < 6; ind++){\\n            s.append(string.charAt(rand.nextInt(62)));\\n        }\\n        \\n        return s.toString();\\n    }\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        \\n        key = getKey();\\n        while(map.containsKey(key)){\\n            key = getKey();\\n        }\\n        map.put(key, longUrl);\\n        return \"http://tinyurl.com/\" + key;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        \\n        int ind = shortUrl.length() - 1;\\n        \\n        while(ind >= 0){\\n            if(shortUrl.charAt(ind) == \\'/\\')\\n                break;\\n            ind--;\\n        }\\n        \\n        return map.get(shortUrl.substring(ind + 1, shortUrl.length()));\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    \\n    String string = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    \\n        String key;\\n    Map<String, String> map = new HashMap<>();\\n    \\n    Random rand = new Random();\\n    \\n    private String getKey(){\\n        \\n        StringBuilder s = new StringBuilder();\\n        for(int ind = 0; ind < 6; ind++){\\n            s.append(string.charAt(rand.nextInt(62)));\\n        }\\n        \\n        return s.toString();\\n    }\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        \\n        key = getKey();\\n        while(map.containsKey(key)){\\n            key = getKey();\\n        }\\n        map.put(key, longUrl);\\n        return \"http://tinyurl.com/\" + key;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        \\n        int ind = shortUrl.length() - 1;\\n        \\n        while(ind >= 0){\\n            if(shortUrl.charAt(ind) == \\'/\\')\\n                break;\\n            ind--;\\n        }\\n        \\n        return map.get(shortUrl.substring(ind + 1, shortUrl.length()));\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 469048,
                "title": "python3-simple-solution-using-count-variable-and-hashmap",
                "content": "```\\nclass Codec:\\n\\n    counter = 0\\n    dic = {}\\n    def encode(self, longUrl: str) -> str:\\n        if longUrl not in self.dic:\\n            self.dic[self.counter] = longUrl\\n            self.counter+=1\\n            return str(self.counter)\\n        \\n\\n    def decode(self, shortUrl: str) -> str:\\n        return self.dic[int(shortUrl)-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n\\n    counter = 0\\n    dic = {}\\n    def encode(self, longUrl: str) -> str:\\n        if longUrl not in self.dic:\\n            self.dic[self.counter] = longUrl\\n            self.counter+=1\\n            return str(self.counter)\\n        \\n\\n    def decode(self, shortUrl: str) -> str:\\n        return self.dic[int(shortUrl)-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345839,
                "title": "ruby-100-100",
                "content": "```\\nrequire \\'base64\\'\\n\\n@urls = {}\\n\\ndef encode(longUrl)\\n  coded_url = Base64.encode64(longUrl)\\n  url_key = coded_url[0..5]\\n  @urls[url_key] = longUrl  \\n    \\n  \\'www.tinyurl.com/\\' + url_key\\nend\\n\\ndef decode(shortUrl)\\n  url_key = shortUrl.match(/^.*.com\\\\/(.*)/).captures.first\\n  @urls[url_key]\\nend\\n```",
                "solutionTags": [],
                "code": "```\\nrequire \\'base64\\'\\n\\n@urls = {}\\n\\ndef encode(longUrl)\\n  coded_url = Base64.encode64(longUrl)\\n  url_key = coded_url[0..5]\\n  @urls[url_key] = longUrl  \\n    \\n  \\'www.tinyurl.com/\\' + url_key\\nend\\n\\ndef decode(shortUrl)\\n  url_key = shortUrl.match(/^.*.com\\\\/(.*)/).captures.first\\n  @urls[url_key]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 343921,
                "title": "the-best-hack-ever-beats-100-both-in-space-and-time",
                "content": "```\\npublic class Codec {\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return shortUrl;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return shortUrl;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 331887,
                "title": "a-true-solution-no-joke",
                "content": "```\\npublic class Codec {\\n    HashMap hm = new HashMap();\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String s = String.valueOf(System.currentTimeMillis()); \\n        hm.put(s,longUrl);\\n        return s;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return String.valueOf(hm.get(shortUrl));   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    HashMap hm = new HashMap();\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String s = String.valueOf(System.currentTimeMillis()); \\n        hm.put(s,longUrl);\\n        return s;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return String.valueOf(hm.get(shortUrl));   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319369,
                "title": "share-my-python3-solution-easy-to-understand",
                "content": "```\\nimport random\\nclass Codec:\\n    base62 = \\'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\n    baseurl = \\'http://tinyurl.com/\\'\\n    tinyTolong = {\\'1\\':\\'1\\'}\\n    longTotiny = {}\\n    def encode(self, longUrl):\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \\n        :type longUrl: str\\n        :rtype: str\\n        \"\"\"\\n        if longUrl in Codec.longTotiny:\\n            return Codec.longTotiny[longUrl]\\n\\n        shortUrl = \\'1\\'\\n        while shortUrl in Codec.tinyTolong:\\n            shortUrl = \\'\\'.join(random.choice(Codec.base62) for i in range(6))\\n\\n        shortUrl = Codec.baseurl + shortUrl\\n        Codec.tinyTolong[shortUrl] = longUrl\\n        Codec.longTotiny[longUrl] = shortUrl\\n\\n        return shortUrl\\n\\n    def decode(self, shortUrl):\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \\n        :type shortUrl: str\\n        :rtype: str\\n        \"\"\"\\n        longUrl = Codec.tinyTolong[shortUrl]\\n        return longUrl\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\nclass Codec:\\n    base62 = \\'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\n    baseurl = \\'http://tinyurl.com/\\'\\n    tinyTolong = {\\'1\\':\\'1\\'}\\n    longTotiny = {}\\n    def encode(self, longUrl):\\n        \"\"\"Encodes a URL to a shortened URL.\\n        \\n        :type longUrl: str\\n        :rtype: str\\n        \"\"\"\\n        if longUrl in Codec.longTotiny:\\n            return Codec.longTotiny[longUrl]\\n\\n        shortUrl = \\'1\\'\\n        while shortUrl in Codec.tinyTolong:\\n            shortUrl = \\'\\'.join(random.choice(Codec.base62) for i in range(6))\\n\\n        shortUrl = Codec.baseurl + shortUrl\\n        Codec.tinyTolong[shortUrl] = longUrl\\n        Codec.longTotiny[longUrl] = shortUrl\\n\\n        return shortUrl\\n\\n    def decode(self, shortUrl):\\n        \"\"\"Decodes a shortened URL to its original URL.\\n        \\n        :type shortUrl: str\\n        :rtype: str\\n        \"\"\"\\n        longUrl = Codec.tinyTolong[shortUrl]\\n        return longUrl\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302761,
                "title": "c-using-huffman-coding",
                "content": "**Having a Huffman coding table based on input string and shown below:**\\n```\\n- => 000110\\n. => 000111\\n/ => 01100\\n: => 001000\\nb => 001001\\nc => 011100\\nd => 011101\\ne => 0011\\ng => 001010\\nh => 001011\\ni => 011110\\nl => 01001\\nm => 011111\\nn => 00000\\no => 01010\\np => 00001\\nr => 00010\\ns => 01011\\nt => 01101\\nu => 010000\\ny => 010001\\n```\\n\\n\\n```\\n#define CHAR_VERTEX \\'*\\'\\n\\nclass Solution {\\nclass Model {\\npublic:\\n    char c;\\n    int prob;\\n    Model():c(0),  prob(0) {}\\n    Model(int character, int probability):c(character),  prob(probability) {}\\n    ~Model() {}\\n    bool operator==(Model& node) {\\n        bool ret = (prob==node.prob && c==node.c) ? true : false;\\n        return ret;\\n    }\\n    bool operator<(Model& node) {\\n        bool ret = (prob < node.prob) ? true : false;\\n        return ret;\\n    }\\n    bool operator>(Model& node) {\\n        bool ret = (prob > node.prob) ? true : false;\\n        return ret;\\n    }\\n    \\nfriend std::ostream& operator<<(std::ostream& os, const Model& node) {\\n    os  << \"[\" << node.c << \"]\";\\n    os  << \"[\" << node.prob << \"]\" << endl;\\n    return os;\\n}\\n};\\ntemplate<typename T>\\nclass BinNode { \\nprivate:\\npublic:\\n    T data;\\n    int height;\\n    int npl;\\n    BinNode<T>* parent;\\n    BinNode<T>* lchild;\\n    BinNode<T>* rchild;\\n    \\n    BinNode(): height(0), npl(1), parent(NULL), lchild(NULL), rchild(NULL) {}\\n    BinNode(const T& e, BinNode<T>* p=NULL, BinNode<T>* lc=NULL, BinNode<T>* rc=NULL, int h=0, int l=1): \\n        data(e), parent(p), lchild(lc), rchild(rc), height(h), npl(l){\\n    }\\n    ~BinNode() {\\n    }\\n    BinNode<T>* insertLeftChild(const T& t);\\n    BinNode<T>* insertRightChild(const T& t);\\n    bool operator==(const BinNode<T>& node);\\n    bool operator<(const BinNode<T>& node);\\n    bool operator>(const BinNode<T>& node);\\n    BinNode<T>& operator=(const BinNode& node);\\n    bool isRoot() {\\n        return !parent ? true : false;\\n    }\\n    bool isLeftChild() {\\n        if (!isRoot()) {\\n            if (this == parent->lchild) return true;\\n            return false;\\n        }\\n        else return false;\\n    }\\n    bool isRightChild() {\\n        if (!isRoot()) {\\n            if (this == parent->rchild) return true;\\n            return false;\\n        }\\n        else return false;\\n    }\\n    bool isLeaf() {\\n        return !hasChild();        \\n    }\\n    bool hasParent()  {\\n        return parent ? true : false;\\n    }\\n    bool hasChild()  {\\n        return hasLeftChild() || hasRightChild();\\n    }\\n    bool hasBothChild();\\n    bool hasLeftChild() { return lchild != NULL ? true : false; }\\n    bool hasRightChild() { return rchild != NULL ? true : false; }\\n    void traverse() {\\n        std::queue<BinNode<T>*> queue;\\n        BinNode<T>* node = this;\\n        queue.push(node);\\n        std::cout << \"--- TREE TOP ------\" << std::endl;\\n        while (true) {\\n            if (queue.empty()) break;\\n            node = queue.front();\\n            queue.pop();\\n            cout << (*node);\\n            if (node->hasLeftChild()) queue.push(node->lchild);\\n            if (node->hasRightChild()) queue.push(node->rchild);\\n        }\\n        std::cout << \"\\\\n--- TREE BOTTOM ------\" << std::endl;\\n    }\\n    \\nfriend std::ostream& operator<<(std::ostream& os, const BinNode<T>& node) {\\n    os << node.data;\\n    return os;\\n}\\n\\n};    \\npublic:\\n    BinNode<Model>* _root;\\n    std::map<char, string> codes;\\n    // Encodes a URL to a shortened URL.\\n    void grow(std::list<Model*>& list) {\\n        std::list<BinNode<Model>*> subs; //synthetically created vertexes for growing Huffman tree\\n        std::list<Model*>::iterator it = list.begin();\\n        std::list<BinNode<Model>*>::iterator it_subs;        \\n        Model* l;\\n        Model* r;\\n        Model* m;\\n        BinNode<Model>* lchild;\\n        BinNode<Model>* rchild;\\n        BinNode<Model>* vertex;\\n        while (it!=list.end()) {\\n            lchild = NULL;\\n            rchild = NULL;\\n            vertex = NULL;\\n            if (std::next(it, 1) == list.end()) {\\n                //cout << \"ending...\" << endl;\\n                if (subs.size() != 1) { \\n                    cout << \"!!! error\" << endl;\\n                    break;\\n                }\\n                l = NULL;\\n                r = *it;\\n                rchild = new BinNode<Model>(*r);\\n                lchild = subs.back();\\n                subs.pop_back();\\n                m = new Model(CHAR_VERTEX, lchild->data.prob+r->prob);\\n                vertex = new BinNode<Model>(*m);\\n                rchild->parent = vertex;\\n                lchild->parent = vertex;\\n                vertex->lchild = lchild;\\n                vertex->rchild = rchild;\\n                _root = vertex;\\n                break;\\n            }\\n            else {\\n                l = *it;\\n                it++;\\n                r = *it;\\n                m = new Model(CHAR_VERTEX, (l->prob)+(r->prob));\\n                for (it_subs=subs.begin(); it_subs!=subs.end();it_subs++) {\\n                    if (*l == (*it_subs)->data) { //a copy, not the same address\\n                        lchild = *it_subs;\\n                        subs.erase(it_subs);\\n                        break;\\n                    }\\n                }\\n                \\n                for (it_subs=subs.begin(); it_subs!=subs.end();it_subs++) {\\n                    if (*r == (*it_subs)->data) { \\n                        rchild = *it_subs;\\n                        subs.erase(it_subs);\\n                        break;\\n                    } \\n                }\\n                \\n                if (lchild == NULL) lchild = new BinNode(*l);\\n                if (rchild == NULL) rchild = new BinNode(*r);\\n                vertex = new BinNode(*m);\\n                rchild->parent = vertex;\\n                lchild->parent = vertex;\\n                vertex->lchild = lchild;\\n                vertex->rchild = rchild;\\n                subs.push_back(vertex);\\n                for (std::list<Model*>::iterator itt=it; it!=list.end(); itt++) {\\n                    if (*m < **itt || *m == **itt) {\\n                        list.insert(itt, m);\\n                        break;\\n                    }\\n                    else if (std::next(itt, 1) == list.end()) {\\n                        list.push_back(m);\\n                        break;\\n                    }\\n                }\\n                it++;\\n            }\\n            \\n        }\\n    }\\n    void generate() {\\n        std::queue<BinNode<Model>*> queue;\\n        BinNode<Model>* node = _root;\\n        BinNode<Model>* tmp;\\n        queue.push(node);\\n        std::string code;\\n        \\n        while (true) {\\n            if (queue.empty()) break;\\n            node = queue.front();\\n            queue.pop();\\n            if (node->data.c == CHAR_VERTEX) {\\n                \\n            }\\n            else {\\n                if (node->isLeaf()) code.clear();\\n                tmp = node;\\n                while (tmp) {\\n                    if (tmp->isLeftChild()) code.insert(0, \"0\");\\n                    else if (tmp->isRightChild()) code.insert(0, \"1\");\\n                    tmp = tmp->parent;\\n                }\\n                if (node->data.c != CHAR_VERTEX) codes[node->data.c] = code;\\n            }\\n            if (node->hasLeftChild()) queue.push(node->lchild);\\n            if (node->hasRightChild()) queue.push(node->rchild);\\n        }\\n       \\n    }\\n    string encode(string longUrl) {\\n        std::map<char,int> probs;\\n        std::list<Model*> table;\\n        std::string encoded;\\n        for (string::iterator it=longUrl.begin(); it!=longUrl.end(); it++) {\\n            probs[*it]++;\\n        }\\n        for (std::map<char,int>::iterator it=probs.begin(); it!=probs.end(); it++) {\\n            Model* m = new Model(it->first, it->second);\\n            table.push_back(m);\\n        }\\n        struct comp {\\n            bool operator() (Model* m1, Model* m2) {\\n                return *m1 < *m2;\\n            }\\n        };\\n        //cout << \"AFTER SORT\" << endl;\\n        struct comp functor;\\n        table.sort(functor);\\n        //for (std::list<Model*>::iterator it=table.begin(); it!=table.end(); it++) cout << **it;\\n        grow(table);\\n        //cout << \"AFTER GROW\" << endl;\\n        //_root->traverse();\\n        generate();\\n        //cout << \"AFTER GENERATE\" << endl;\\n        //for (std::map<char,string>::iterator it=codes.begin(); it!=codes.end(); it++) \\n        //  cout << it->first << \" => \" << it->second << endl; \\n        \\n        for (string::iterator it=longUrl.begin(); it!=longUrl.end(); it++) {\\n            char c = *it;\\n            string code = codes[c];\\n            encoded.append(code);\\n        }\\n        return encoded;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string decoded;\\n        string str;\\n        for (string::iterator it=shortUrl.begin(); it!=shortUrl.end(); it++) {\\n            char c = *it;\\n            str += c;\\n            for (std::map<char,string>::iterator it=codes.begin(); it!=codes.end(); it++) {\\n                if (!str.compare(it->second)) {\\n                    char c = it->first;\\n                    decoded.insert(decoded.end(), c);\\n                    str.clear();\\n                    break;\\n                }\\n            }   \\n        }\\n        return decoded;\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "solutionTags": [],
                "code": "```\\n- => 000110\\n. => 000111\\n/ => 01100\\n: => 001000\\nb => 001001\\nc => 011100\\nd => 011101\\ne => 0011\\ng => 001010\\nh => 001011\\ni => 011110\\nl => 01001\\nm => 011111\\nn => 00000\\no => 01010\\np => 00001\\nr => 00010\\ns => 01011\\nt => 01101\\nu => 010000\\ny => 010001\\n```\n```\\n#define CHAR_VERTEX \\'*\\'\\n\\nclass Solution {\\nclass Model {\\npublic:\\n    char c;\\n    int prob;\\n    Model():c(0),  prob(0) {}\\n    Model(int character, int probability):c(character),  prob(probability) {}\\n    ~Model() {}\\n    bool operator==(Model& node) {\\n        bool ret = (prob==node.prob && c==node.c) ? true : false;\\n        return ret;\\n    }\\n    bool operator<(Model& node) {\\n        bool ret = (prob < node.prob) ? true : false;\\n        return ret;\\n    }\\n    bool operator>(Model& node) {\\n        bool ret = (prob > node.prob) ? true : false;\\n        return ret;\\n    }\\n    \\nfriend std::ostream& operator<<(std::ostream& os, const Model& node) {\\n    os  << \"[\" << node.c << \"]\";\\n    os  << \"[\" << node.prob << \"]\" << endl;\\n    return os;\\n}\\n};\\ntemplate<typename T>\\nclass BinNode { \\nprivate:\\npublic:\\n    T data;\\n    int height;\\n    int npl;\\n    BinNode<T>* parent;\\n    BinNode<T>* lchild;\\n    BinNode<T>* rchild;\\n    \\n    BinNode(): height(0), npl(1), parent(NULL), lchild(NULL), rchild(NULL) {}\\n    BinNode(const T& e, BinNode<T>* p=NULL, BinNode<T>* lc=NULL, BinNode<T>* rc=NULL, int h=0, int l=1): \\n        data(e), parent(p), lchild(lc), rchild(rc), height(h), npl(l){\\n    }\\n    ~BinNode() {\\n    }\\n    BinNode<T>* insertLeftChild(const T& t);\\n    BinNode<T>* insertRightChild(const T& t);\\n    bool operator==(const BinNode<T>& node);\\n    bool operator<(const BinNode<T>& node);\\n    bool operator>(const BinNode<T>& node);\\n    BinNode<T>& operator=(const BinNode& node);\\n    bool isRoot() {\\n        return !parent ? true : false;\\n    }\\n    bool isLeftChild() {\\n        if (!isRoot()) {\\n            if (this == parent->lchild) return true;\\n            return false;\\n        }\\n        else return false;\\n    }\\n    bool isRightChild() {\\n        if (!isRoot()) {\\n            if (this == parent->rchild) return true;\\n            return false;\\n        }\\n        else return false;\\n    }\\n    bool isLeaf() {\\n        return !hasChild();        \\n    }\\n    bool hasParent()  {\\n        return parent ? true : false;\\n    }\\n    bool hasChild()  {\\n        return hasLeftChild() || hasRightChild();\\n    }\\n    bool hasBothChild();\\n    bool hasLeftChild() { return lchild != NULL ? true : false; }\\n    bool hasRightChild() { return rchild != NULL ? true : false; }\\n    void traverse() {\\n        std::queue<BinNode<T>*> queue;\\n        BinNode<T>* node = this;\\n        queue.push(node);\\n        std::cout << \"--- TREE TOP ------\" << std::endl;\\n        while (true) {\\n            if (queue.empty()) break;\\n            node = queue.front();\\n            queue.pop();\\n            cout << (*node);\\n            if (node->hasLeftChild()) queue.push(node->lchild);\\n            if (node->hasRightChild()) queue.push(node->rchild);\\n        }\\n        std::cout << \"\\\\n--- TREE BOTTOM ------\" << std::endl;\\n    }\\n    \\nfriend std::ostream& operator<<(std::ostream& os, const BinNode<T>& node) {\\n    os << node.data;\\n    return os;\\n}\\n\\n};    \\npublic:\\n    BinNode<Model>* _root;\\n    std::map<char, string> codes;\\n    // Encodes a URL to a shortened URL.\\n    void grow(std::list<Model*>& list) {\\n        std::list<BinNode<Model>*> subs; //synthetically created vertexes for growing Huffman tree\\n        std::list<Model*>::iterator it = list.begin();\\n        std::list<BinNode<Model>*>::iterator it_subs;        \\n        Model* l;\\n        Model* r;\\n        Model* m;\\n        BinNode<Model>* lchild;\\n        BinNode<Model>* rchild;\\n        BinNode<Model>* vertex;\\n        while (it!=list.end()) {\\n            lchild = NULL;\\n            rchild = NULL;\\n            vertex = NULL;\\n            if (std::next(it, 1) == list.end()) {\\n                //cout << \"ending...\" << endl;\\n                if (subs.size() != 1) { \\n                    cout << \"!!! error\" << endl;\\n                    break;\\n                }\\n                l = NULL;\\n                r = *it;\\n                rchild = new BinNode<Model>(*r);\\n                lchild = subs.back();\\n                subs.pop_back();\\n                m = new Model(CHAR_VERTEX, lchild->data.prob+r->prob);\\n                vertex = new BinNode<Model>(*m);\\n                rchild->parent = vertex;\\n                lchild->parent = vertex;\\n                vertex->lchild = lchild;\\n                vertex->rchild = rchild;\\n                _root = vertex;\\n                break;\\n            }\\n            else {\\n                l = *it;\\n                it++;\\n                r = *it;\\n                m = new Model(CHAR_VERTEX, (l->prob)+(r->prob));\\n                for (it_subs=subs.begin(); it_subs!=subs.end();it_subs++) {\\n                    if (*l == (*it_subs)->data) { //a copy, not the same address\\n                        lchild = *it_subs;\\n                        subs.erase(it_subs);\\n                        break;\\n                    }\\n                }\\n                \\n                for (it_subs=subs.begin(); it_subs!=subs.end();it_subs++) {\\n                    if (*r == (*it_subs)->data) { \\n                        rchild = *it_subs;\\n                        subs.erase(it_subs);\\n                        break;\\n                    } \\n                }\\n                \\n                if (lchild == NULL) lchild = new BinNode(*l);\\n                if (rchild == NULL) rchild = new BinNode(*r);\\n                vertex = new BinNode(*m);\\n                rchild->parent = vertex;\\n                lchild->parent = vertex;\\n                vertex->lchild = lchild;\\n                vertex->rchild = rchild;\\n                subs.push_back(vertex);\\n                for (std::list<Model*>::iterator itt=it; it!=list.end(); itt++) {\\n                    if (*m < **itt || *m == **itt) {\\n                        list.insert(itt, m);\\n                        break;\\n                    }\\n                    else if (std::next(itt, 1) == list.end()) {\\n                        list.push_back(m);\\n                        break;\\n                    }\\n                }\\n                it++;\\n            }\\n            \\n        }\\n    }\\n    void generate() {\\n        std::queue<BinNode<Model>*> queue;\\n        BinNode<Model>* node = _root;\\n        BinNode<Model>* tmp;\\n        queue.push(node);\\n        std::string code;\\n        \\n        while (true) {\\n            if (queue.empty()) break;\\n            node = queue.front();\\n            queue.pop();\\n            if (node->data.c == CHAR_VERTEX) {\\n                \\n            }\\n            else {\\n                if (node->isLeaf()) code.clear();\\n                tmp = node;\\n                while (tmp) {\\n                    if (tmp->isLeftChild()) code.insert(0, \"0\");\\n                    else if (tmp->isRightChild()) code.insert(0, \"1\");\\n                    tmp = tmp->parent;\\n                }\\n                if (node->data.c != CHAR_VERTEX) codes[node->data.c] = code;\\n            }\\n            if (node->hasLeftChild()) queue.push(node->lchild);\\n            if (node->hasRightChild()) queue.push(node->rchild);\\n        }\\n       \\n    }\\n    string encode(string longUrl) {\\n        std::map<char,int> probs;\\n        std::list<Model*> table;\\n        std::string encoded;\\n        for (string::iterator it=longUrl.begin(); it!=longUrl.end(); it++) {\\n            probs[*it]++;\\n        }\\n        for (std::map<char,int>::iterator it=probs.begin(); it!=probs.end(); it++) {\\n            Model* m = new Model(it->first, it->second);\\n            table.push_back(m);\\n        }\\n        struct comp {\\n            bool operator() (Model* m1, Model* m2) {\\n                return *m1 < *m2;\\n            }\\n        };\\n        //cout << \"AFTER SORT\" << endl;\\n        struct comp functor;\\n        table.sort(functor);\\n        //for (std::list<Model*>::iterator it=table.begin(); it!=table.end(); it++) cout << **it;\\n        grow(table);\\n        //cout << \"AFTER GROW\" << endl;\\n        //_root->traverse();\\n        generate();\\n        //cout << \"AFTER GENERATE\" << endl;\\n        //for (std::map<char,string>::iterator it=codes.begin(); it!=codes.end(); it++) \\n        //  cout << it->first << \" => \" << it->second << endl; \\n        \\n        for (string::iterator it=longUrl.begin(); it!=longUrl.end(); it++) {\\n            char c = *it;\\n            string code = codes[c];\\n            encoded.append(code);\\n        }\\n        return encoded;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string decoded;\\n        string str;\\n        for (string::iterator it=shortUrl.begin(); it!=shortUrl.end(); it++) {\\n            char c = *it;\\n            str += c;\\n            for (std::map<char,string>::iterator it=codes.begin(); it!=codes.end(); it++) {\\n                if (!str.compare(it->second)) {\\n                    char c = it->first;\\n                    decoded.insert(decoded.end(), c);\\n                    str.clear();\\n                    break;\\n                }\\n            }   \\n        }\\n        return decoded;\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "codeTag": "C++"
            },
            {
                "id": 292297,
                "title": "c-easy-understand-solution",
                "content": "```\\n    string prefix = \"http://tinyurl.com\";\\n    unordered_map<int, string> p; \\n    int key = 0;\\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        p[key ++] = longUrl;\\n        return prefix + to_string(key - 1);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string k = shortUrl.substr(prefix.length());\\n        int m = stoi(k);\\n        return p[m];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string prefix = \"http://tinyurl.com\";\\n    unordered_map<int, string> p; \\n    int key = 0;\\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        p[key ++] = longUrl;\\n        return prefix + to_string(key - 1);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string k = shortUrl.substr(prefix.length());\\n        int m = stoi(k);\\n        return p[m];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 269854,
                "title": "java-solution-base64-2nd-opinion-needed",
                "content": "I see most of the people have encoded the url and put the code and url in a hashmap, and simply retrieved it from hahsmap when decode is called, I dont think that is the purpose of the question. I think the question wants you to first encode the url and then decode it probably by doing the opposite steps on encoding. Here is a very simple solution using Base64:\\n```\\nimport java.util.Base64;\\npublic class Codec {\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String baseStr = Base64.getEncoder().encodeToString(longUrl.getBytes());\\n        return baseStr;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        String converted = new String(Base64.getDecoder().decode(shortUrl));\\n        return converted;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Base64;\\npublic class Codec {\\n\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String baseStr = Base64.getEncoder().encodeToString(longUrl.getBytes());\\n        return baseStr;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        String converted = new String(Base64.getDecoder().decode(shortUrl));\\n        return converted;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 263568,
                "title": "javascript-solution",
                "content": "```\\nconst temp = {};\\n\\nvar encode = function(longUrl) {\\n    let encodeString = \"ABCDEFGHIJJKMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\\n    let id = \"\";\\n    for (let i = 0; i < 6; i++) \\n        id += encodeString[Math.floor(Math.random() * encodeString.length)];\\n    temp.id = longUrl;\\n    return \"http://tinyurl.com/\" + id;\\n};\\n\\nvar decode = function(shortUrl) {\\n    let urlArray = shortUrl.split(\\'/\\');\\n    let id = urlArray[urlArray.length - 1];\\n    return temp.id\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst temp = {};\\n\\nvar encode = function(longUrl) {\\n    let encodeString = \"ABCDEFGHIJJKMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\\n    let id = \"\";\\n    for (let i = 0; i < 6; i++) \\n        id += encodeString[Math.floor(Math.random() * encodeString.length)];\\n    temp.id = longUrl;\\n    return \"http://tinyurl.com/\" + id;\\n};\\n\\nvar decode = function(shortUrl) {\\n    let urlArray = shortUrl.split(\\'/\\');\\n    let id = urlArray[urlArray.length - 1];\\n    return temp.id\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 254085,
                "title": "everyone-trying-to-give-really-short-solution-here-is-a-readable-one",
                "content": "```\\npublic class Codec {\\n\\n    HashMap<String, String> randomCodeToURL = new HashMap<>();\\n    static final String AB = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n    static final String domain = \"http://tinyurl.com/\";\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        \\n        boolean isCodeExist = false;\\n        String code = \"\";\\n        \\n        while (!isCodeExist) {\\n            code = getRandomCode();\\n            if (!randomCodeToURL.containsKey(code)) isCodeExist = true;\\n        }\\n        \\n        randomCodeToURL.put(code, longUrl);\\n        \\n        return domain + code;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return randomCodeToURL.get(shortUrl.substring(shortUrl.lastIndexOf(\\'/\\') + 1));\\n    }\\n    \\n    public String getRandomCode() {\\n        StringBuilder sb = new StringBuilder();\\n        Random rnd = new Random();\\n        \\n        for( int i = 0; i < 6; i++ ) \\n              sb.append(AB.charAt(rnd.nextInt(AB.length())));\\n          \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    HashMap<String, String> randomCodeToURL = new HashMap<>();\\n    static final String AB = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n    static final String domain = \"http://tinyurl.com/\";\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        \\n        boolean isCodeExist = false;\\n        String code = \"\";\\n        \\n        while (!isCodeExist) {\\n            code = getRandomCode();\\n            if (!randomCodeToURL.containsKey(code)) isCodeExist = true;\\n        }\\n        \\n        randomCodeToURL.put(code, longUrl);\\n        \\n        return domain + code;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return randomCodeToURL.get(shortUrl.substring(shortUrl.lastIndexOf(\\'/\\') + 1));\\n    }\\n    \\n    public String getRandomCode() {\\n        StringBuilder sb = new StringBuilder();\\n        Random rnd = new Random();\\n        \\n        for( int i = 0; i < 6; i++ ) \\n              sb.append(AB.charAt(rnd.nextInt(AB.length())));\\n          \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192939,
                "title": "c-4ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        stringstream ss;\\n        ss << std::hex << hash(longUrl);\\n        string hv = ss.str();\\n        \\n        if( lookup.find(ss.str()) != lookup.end()  ) {\\n            lookup[hv].push_back(longUrl);\\n            ss << \"-\" << lookup[hv].size()-1;\\n        } else {\\n            lookup[hv].push_back(longUrl);\\n            ss << \"-\" << \"0\";\\n        }\\n        return ss.str();\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string hv=\"\";\\n        int id = 0;\\n        if(shortUrl.rfind(\"-\") != string::npos) {\\n            stringstream ss;\\n            ss << shortUrl.substr( shortUrl.rfind(\"-\")+1);;\\n            ss >> id;\\n            hv = shortUrl.substr(0, shortUrl.rfind(\"-\"));\\n            if(lookup.find(hv) != lookup.end() ) {\\n                if(id < lookup[hv].size() ) \\n                    return lookup[hv][id];\\n                \\n            }\\n        }\\n        return \"\";\\n    }\\nprivate:\\n    unordered_map<string,vector<string> > lookup;\\n    \\n    int hash(std::string const & key) {\\n\\tint hashVal = 0, len = key.length();\\n\\tfor(int i=0; i<len; i++) {\\n\\t\\thashVal += key[i];\\t}\\n\\treturn hashVal;\\n}\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        stringstream ss;\\n        ss << std::hex << hash(longUrl);\\n        string hv = ss.str();\\n        \\n        if( lookup.find(ss.str()) != lookup.end()  ) {\\n            lookup[hv].push_back(longUrl);\\n            ss << \"-\" << lookup[hv].size()-1;\\n        } else {\\n            lookup[hv].push_back(longUrl);\\n            ss << \"-\" << \"0\";\\n        }\\n        return ss.str();\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string hv=\"\";\\n        int id = 0;\\n        if(shortUrl.rfind(\"-\") != string::npos) {\\n            stringstream ss;\\n            ss << shortUrl.substr( shortUrl.rfind(\"-\")+1);;\\n            ss >> id;\\n            hv = shortUrl.substr(0, shortUrl.rfind(\"-\"));\\n            if(lookup.find(hv) != lookup.end() ) {\\n                if(id < lookup[hv].size() ) \\n                    return lookup[hv][id];\\n                \\n            }\\n        }\\n        return \"\";\\n    }\\nprivate:\\n    unordered_map<string,vector<string> > lookup;\\n    \\n    int hash(std::string const & key) {\\n\\tint hashVal = 0, len = key.length();\\n\\tfor(int i=0; i<len; i++) {\\n\\t\\thashVal += key[i];\\t}\\n\\treturn hashVal;\\n}\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 174920,
                "title": "java-solution",
                "content": "```class Solution {\\npublic:\\n    string s;\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        s=longUrl;\\n        return \"URL http://tinyurl.com/4e9iAk\";\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    string s;\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        s=longUrl;\\n        return \"URL http://tinyurl.com/4e9iAk\";\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164673,
                "title": "java-solution-with-random-string-generation",
                "content": "```\\nimport java.util.UUID;\\npublic class Codec {\\n    public String host = \"http://tinyurl.com/\";\\n    public HashMap <String, String> map = new HashMap();\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String newU = host + UUID.randomUUID().toString().replace(\"-\", \"\");\\n        map.put(newU, longUrl);\\n        return newU;\\n        \\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.UUID;\\npublic class Codec {\\n    public String host = \"http://tinyurl.com/\";\\n    public HashMap <String, String> map = new HashMap();\\n    // Encodes a URL to a shortened URL.\\n    public String encode(String longUrl) {\\n        String newU = host + UUID.randomUUID().toString().replace(\"-\", \"\");\\n        map.put(newU, longUrl);\\n        return newU;\\n        \\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140979,
                "title": "simple-javascript-solution-good-runtime",
                "content": "```\\nlet hashTable = [];\\n\\nvar encode = function(longUrl) {\\nhashTable.push(longUrl);\\nreturn \"http://tinyurl.com/\" + (hashTable.length-1).toString();\\n};\\n\\nvar decode = function(shortUrl) {\\nreturn hashTable[Number(shortUrl.replace(\"http://tinyurl.com/\" , \"\"))];\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nlet hashTable = [];\\n\\nvar encode = function(longUrl) {\\nhashTable.push(longUrl);\\nreturn \"http://tinyurl.com/\" + (hashTable.length-1).toString();\\n};\\n\\nvar decode = function(shortUrl) {\\nreturn hashTable[Number(shortUrl.replace(\"http://tinyurl.com/\" , \"\"))];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 136957,
                "title": "easiest-python3-solution-beats-94",
                "content": "lol\\n```\\nclass Codec:\\n    def encode(self, longUrl):\\n        return longUrl\\n    def decode(self, shortUrl):\\n        return shortUrl\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n    def encode(self, longUrl):\\n        return longUrl\\n    def decode(self, shortUrl):\\n        return shortUrl\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100308,
                "title": "python-solution",
                "content": "```\\nclass Codec:\\n    def __init__(self):\\n        self.d = {}\\n        self.r = {}\\n\\n    def encode(self, longUrl):\\n        self.d[longUrl] = longUrl.__hash__()\\n        self.r[longUrl.__hash__()] = longUrl\\n        return longUrl.__hash__()\\n\\n    def decode(self, shortUrl):\\n        return self.r[shortUrl]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n    def __init__(self):\\n        self.d = {}\\n        self.r = {}\\n\\n    def encode(self, longUrl):\\n        self.d[longUrl] = longUrl.__hash__()\\n        self.r[longUrl.__hash__()] = longUrl\\n        return longUrl.__hash__()\\n\\n    def decode(self, shortUrl):\\n        return self.r[shortUrl]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100336,
                "title": "simple-4-lines-in-java-6ms",
                "content": "```\\npublic class Codec {\\n    // Encodes a URL to a shortened URL.\\n    HashMap<String, String> map = new HashMap<String, String>();\\n    \\n    public String encode(String longUrl) {\\n        map.put(Integer.toString(map.size()), longUrl);\\n        return Integer.toString(map.size() - 1);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return map.get(String.valueOf(shortUrl));\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    // Encodes a URL to a shortened URL.\\n    HashMap<String, String> map = new HashMap<String, String>();\\n    \\n    public String encode(String longUrl) {\\n        map.put(Integer.toString(map.size()), longUrl);\\n        return Integer.toString(map.size() - 1);\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    public String decode(String shortUrl) {\\n        return map.get(String.valueOf(shortUrl));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100344,
                "title": "std-hash-c-soln",
                "content": "Important to note, if some day the test cases increase and collision occurs, we can simply change the str.resize(size) to new size, right now it is 8.\\n```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    unordered_map<string, string> umap;\\n    string encode(string longUrl) {\\n        auto hashx = std::hash<std::string>()(longUrl);\\n        string str = \"\";\\n        str = to_string(hashx);\\n        str.resize(8);\\n        umap.emplace(str, longUrl);\\n        return \"http://tinyurl.com/\" + str;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        shortUrl = shortUrl.substr(19,8);\\n        return umap[shortUrl];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    unordered_map<string, string> umap;\\n    string encode(string longUrl) {\\n        auto hashx = std::hash<std::string>()(longUrl);\\n        string str = \"\";\\n        str = to_string(hashx);\\n        str.resize(8);\\n        umap.emplace(str, longUrl);\\n        return \"http://tinyurl.com/\" + str;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 100345,
                "title": "c-solution-using-random-just-for-fun",
                "content": "Well, personally, I think this question is a sort of system design one that should include some other software like database, memory cache and etc. System design interviews usually target at system architect level design rather than algorithm design and analysis. The below solution of course is not stateless and not scalable unless the `unordered_map` becomes a `distributed memcache`. \\nFor a stateless solution, I think this [stackoverflow link](http://stackoverflow.com/questions/742013/how-to-code-a-url-shortener) can be helpful (But it stills somewhat relies on database :-( ). Or we can just use some classic reversible encryption algorithm like `DES` and `RSA` of which the tinyUrl returned is the encrypted message of longUrl.\\n```\\nclass Solution {\\npublic:\\n    Solution(){\\n        shortToLongUrlMapping.clear();\\n        srand (time(NULL));\\n    }\\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string shortUrl('a',5);\\n        int idx = 0, randomVal = 0;\\n        while(shortToLongUrlMapping.find(shortUrl) != shortToLongUrlMapping.end()){\\n            randomVal = rand() % 62;\\n            if(randomVal >= 0 && randomVal < 26)\\n                shortUrl[idx] = ('A' + randomVal);\\n            else if(randomVal >= 26 && randomVal < 52)\\n                shortUrl[idx] = ('a' + (randomVal - 26));\\n            else\\n                shortUrl[idx] = ('0' + (randomVal - 52));\\n            idx = (idx + 1)%5;\\n        }\\n        shortToLongUrlMapping[shortUrl] = longUrl;\\n        return shortUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string longUrl = shortToLongUrlMapping.find(shortUrl) != shortToLongUrlMapping.end() ? shortToLongUrlMapping[shortUrl] : shortUrl;\\n        return longUrl;\\n    }\\nprivate:\\n    unordered_map<string,string> shortToLongUrlMapping;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(){\\n        shortToLongUrlMapping.clear();\\n        srand (time(NULL));\\n    }\\n    \\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        string shortUrl('a',5);\\n        int idx = 0, randomVal = 0;\\n        while(shortToLongUrlMapping.find(shortUrl) != shortToLongUrlMapping.end()){\\n            randomVal = rand() % 62;\\n            if(randomVal >= 0 && randomVal < 26)\\n                shortUrl[idx] = ('A' + randomVal);\\n            else if(randomVal >= 26 && randomVal < 52)\\n                shortUrl[idx] = ('a' + (randomVal - 26));\\n            else\\n                shortUrl[idx] = ('0' + (randomVal - 52));\\n            idx = (idx + 1)%5;\\n        }\\n        shortToLongUrlMapping[shortUrl] = longUrl;\\n        return shortUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string longUrl = shortToLongUrlMapping.find(shortUrl) != shortToLongUrlMapping.end() ? shortToLongUrlMapping[shortUrl] : shortUrl;\\n        return longUrl;\\n    }\\nprivate:\\n    unordered_map<string,string> shortToLongUrlMapping;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065742,
                "title": "very-easy-two-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar encode = function(longUrl) { return longUrl };\\nvar decode = function(shortUrl) { return shortUrl };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar encode = function(longUrl) { return longUrl };\\nvar decode = function(shortUrl) { return shortUrl };\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565779,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1805324,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1576666,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1571765,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1567125,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1569954,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1849933,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1779553,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1575033,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1999443,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1565779,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1805324,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1576666,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1571765,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1567125,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1569954,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1849933,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1779553,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1575033,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            },
            {
                "id": 1999443,
                "content": [
                    {
                        "username": "softnrajkumar1994",
                        "content": "Look at the image i have not done anything i just returned method parameters , it works . i understands this will work even incase if we design tiny url system in this way it will solve the problem.But the question is to test the ability of the programmers to come up with good logic.\\n\\nCan @LeetCode just add not equals check between originalUrl and encoded Url?\\n![image](https://assets.leetcode.com/users/softnrajkumar1994/image_1586420923.png)\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Sir, though your program is accepted but it is logically incorrect to return the same thing as in the argument. Logically the encoding function should return shortUrl and the decoding function should return longUrl, but doing this the solution is not accepted. What are the possible reasons of it do you think?"
                    },
                    {
                        "username": "TarekAyk",
                        "content": "They must have added this to troll us, right? Right!?"
                    },
                    {
                        "username": "Rom1deTroyes",
                        "content": "Well, it may be a good idea to check if the encode function returns something different than the input, because...\\n... You know, lazy in the morning :-$"
                    },
                    {
                        "username": "yuletide",
                        "content": "I did the same and was amazed it worked. "
                    },
                    {
                        "username": "bogdan17",
                        "content": "As a joke, I tried just returning the argument given. Passed all tescases(73%).\\nThe testcases need to be updated to check that the encoding/decoding is actually done."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I like when the questions have a shortcut answer. It challenges you to read the requirements carefully, which is honestly a crucial skill as a professional. And if you still want the dev challenge, you can always come back and try to solve it according to the spirit of the problem :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/encode-and-decode-tinyurl/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Simple Counter\n\n  \n**Approach 2:** Variable-length Encoding\n\n  \n**Approach 3:** Using hashcode\n\n  \n**Approach 4:** Using random number\n\n  \n**Approach 5:** Random fixed-length encoding\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rattanece",
                        "content": "https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "what a joke LMAO , solving this question on 1 APRIL  after reading question again and again for 15 minutes .  \\nALL FOOLS DAY\\uD83E\\uDD23\\uD83D\\uDE02\\uD83D\\uDE01 "
                    },
                    {
                        "username": "zuhriddinzayniddinov",
                        "content": "The length should be checked every time. The length of the outgoing input must be less than its own length."
                    },
                    {
                        "username": "fellipessanha",
                        "content": "![image](https://assets.leetcode.com/users/images/207edbb5-fce1-4d2e-b915-e73bc30c573a_1615833757.0898995.jpeg)\\nHey I think I found a bug in today\\'s challenge. When I do the example \\'locally\\' in the run code it says I\\'m right. I try to submit the same code and it returns an error. I can\\'t even debug it properly \\'cause I have no idea what\\'s causing it D:"
                    },
                    {
                        "username": "Avinash_kumar2020",
                        "content": "input and output should be same right?! but your output is coming wrong"
                    },
                    {
                        "username": "salmon77577",
                        "content": "Test cases for this problem are a joke."
                    }
                ]
            }
        ]
    },
    {
        "title": "Construct Binary Tree from String",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1568349,
                "content": [
                    {
                        "username": "serendipity0903",
                        "content": "Seems like the problem did not mention what it will look like for the case where the left tree is null while right tree is not. For example, I tried the test case \"1(2()(4))(3)\" and got invalid testcase error. But in 606. Construct String from Binary Tree, there is such case. What does the problem exactly mean?"
                    },
                    {
                        "username": "xtermx",
                        "content": "Is the input of \"4()(3)\" a valid case? \\nThe reference produce \"Line -27: TypeError: t() takes at least 1 argument (0 given)\""
                    },
                    {
                        "username": "tolinwei",
                        "content": "Anyone has the same confusion as me??"
                    }
                ]
            },
            {
                "id": 1566798,
                "content": [
                    {
                        "username": "serendipity0903",
                        "content": "Seems like the problem did not mention what it will look like for the case where the left tree is null while right tree is not. For example, I tried the test case \"1(2()(4))(3)\" and got invalid testcase error. But in 606. Construct String from Binary Tree, there is such case. What does the problem exactly mean?"
                    },
                    {
                        "username": "xtermx",
                        "content": "Is the input of \"4()(3)\" a valid case? \\nThe reference produce \"Line -27: TypeError: t() takes at least 1 argument (0 given)\""
                    },
                    {
                        "username": "tolinwei",
                        "content": "Anyone has the same confusion as me??"
                    }
                ]
            },
            {
                "id": 1569824,
                "content": [
                    {
                        "username": "serendipity0903",
                        "content": "Seems like the problem did not mention what it will look like for the case where the left tree is null while right tree is not. For example, I tried the test case \"1(2()(4))(3)\" and got invalid testcase error. But in 606. Construct String from Binary Tree, there is such case. What does the problem exactly mean?"
                    },
                    {
                        "username": "xtermx",
                        "content": "Is the input of \"4()(3)\" a valid case? \\nThe reference produce \"Line -27: TypeError: t() takes at least 1 argument (0 given)\""
                    },
                    {
                        "username": "tolinwei",
                        "content": "Anyone has the same confusion as me??"
                    }
                ]
            }
        ]
    },
    {
        "title": "Complex Number Multiplication",
        "question_content": "<p>A <a href=\"https://en.wikipedia.org/wiki/Complex_number\" target=\"_blank\">complex number</a> can be represented as a string on the form <code>&quot;<strong>real</strong>+<strong>imaginary</strong>i&quot;</code> where:</p>\n\n<ul>\n\t<li><code>real</code> is the real part and is an integer in the range <code>[-100, 100]</code>.</li>\n\t<li><code>imaginary</code> is the imaginary part and is an integer in the range <code>[-100, 100]</code>.</li>\n\t<li><code>i<sup>2</sup> == -1</code>.</li>\n</ul>\n\n<p>Given two complex numbers <code>num1</code> and <code>num2</code> as strings, return <em>a string of the complex number that represents their multiplications</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num1 = &quot;1+1i&quot;, num2 = &quot;1+1i&quot;\n<strong>Output:</strong> &quot;0+2i&quot;\n<strong>Explanation:</strong> (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num1 = &quot;1+-1i&quot;, num2 = &quot;1+-1i&quot;\n<strong>Output:</strong> &quot;0+-2i&quot;\n<strong>Explanation:</strong> (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>num1</code> and <code>num2</code> are valid complex numbers.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 100440,
                "title": "c-using-stringstream",
                "content": "stringstream is very useful to extract num from a string\\n\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        int ra, ia, rb, ib;\\n        char buff;\\n        stringstream aa(a), bb(b), ans;\\n        aa >> ra >> buff >> ia >> buff;\\n        bb >> rb >> buff >> ib >> buff;\\n        ans << ra*rb - ia*ib << \"+\" << ra*ib + rb*ia << \"i\";\\n        return ans.str();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        int ra, ia, rb, ib;\\n        char buff;\\n        stringstream aa(a), bb(b), ans;\\n        aa >> ra >> buff >> ia >> buff;\\n        bb >> rb >> buff >> ib >> buff;\\n        ans << ra*rb - ia*ib << \"+\" << ra*ib + rb*ia << \"i\";\\n        return ans.str();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 100430,
                "title": "java-3-liner",
                "content": "This solution relies on the fact that (a+bi)(c+di) = (ac - bd) + (ad+bc)i.\\n\\n```\\npublic String complexNumberMultiply(String a, String b) {\\n    int[] coefs1 = Stream.of(a.split(\"\\\\\\\\+|i\")).mapToInt(Integer::parseInt).toArray(), \\n          coefs2 = Stream.of(b.split(\"\\\\\\\\+|i\")).mapToInt(Integer::parseInt).toArray();\\n    return (coefs1[0]*coefs2[0] - coefs1[1]*coefs2[1]) + \"+\" + (coefs1[0]*coefs2[1] + coefs1[1]*coefs2[0]) + \"i\";\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String complexNumberMultiply(String a, String b) {\\n    int[] coefs1 = Stream.of(a.split(\"\\\\\\\\+|i\")).mapToInt(Integer::parseInt).toArray(), \\n          coefs2 = Stream.of(b.split(\"\\\\\\\\+|i\")).mapToInt(Integer::parseInt).toArray();\\n    return (coefs1[0]*coefs2[0] - coefs1[1]*coefs2[1]) + \"+\" + (coefs1[0]*coefs2[1] + coefs1[1]*coefs2[0]) + \"i\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 100500,
                "title": "python-simple-3-lines-solution",
                "content": "```\\nclass Solution(object):\\n    def complexNumberMultiply(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: str\\n        \"\"\"\\n        a1, a2 = map(int, a[:-1].split('+'))\\n        b1, b2 = map(int, b[:-1].split('+'))\\n        return '%d+%di' % (a1 * b1 - a2 * b2, a1 * b2 + a2 * b1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def complexNumberMultiply(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: str\\n        \"\"\"\\n        a1, a2 = map(int, a[:-1].split('+'))\\n        b1, b2 = map(int, b[:-1].split('+'))\\n        return '%d+%di' % (a1 * b1 - a2 * b2, a1 * b2 + a2 * b1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423419,
                "title": "c-two-simple-and-short-solutions-0ms-faster-than-100",
                "content": "**Solution I - Using Built-in**\\nWe can use the built-in std::complex class.\\nFirst we need to parse the given string to the real part and imaginary part.\\nThen we can just multiply the parsed results and build the string result.\\n```\\nclass Solution {\\npublic:\\n    complex<int> parse(string num) {\\n        int i = num.find(\\'+\\');\\n        int real = stoi(num.substr(0, i));\\n        int imaginary = stoi(num.substr(i+1, num.size()-i-2));\\n        complex<int> res(real, imaginary);\\n        return res;\\n    }\\n    \\n    string complexNumberMultiply(string num1, string num2) {\\n        complex<int> a = parse(num1), b = parse(num2);\\n        complex<int> res = a * b;        \\n        \\n        return to_string(real(res)) + \"+\" + to_string(imag(res)) + \"i\";\\n    }\\n};\\n```\\n**Solution II - Without Built-in**\\nIf we don\\'t want to use the built-in class, we can just use pairs to store real and imaginary values, and multiply them.\\n```\\nclass Solution {\\npublic:\\n    pair<int, int> parse(string num) {\\n        int i = num.find(\\'+\\');\\n        double real = stoi(num.substr(0, i));\\n        double imaginary = stoi(num.substr(i+1, num.size()-i-2));\\n        pair<int, int> res(real, imaginary);\\n        return res;\\n    }\\n    \\n    string complexNumberMultiply(string num1, string num2) {\\n        pair<int, int> a = parse(num1), b = parse(num2);\\n        int real_a = a.first, imag_a = a.second;\\n        int real_b = b.first, imag_b = b.second;\\n        \\n        return to_string(real_a * real_b - imag_a * imag_b) + \\'+\\' + to_string(real_a * imag_b  + real_b * imag_a)+\\'i\\' ;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    complex<int> parse(string num) {\\n        int i = num.find(\\'+\\');\\n        int real = stoi(num.substr(0, i));\\n        int imaginary = stoi(num.substr(i+1, num.size()-i-2));\\n        complex<int> res(real, imaginary);\\n        return res;\\n    }\\n    \\n    string complexNumberMultiply(string num1, string num2) {\\n        complex<int> a = parse(num1), b = parse(num2);\\n        complex<int> res = a * b;        \\n        \\n        return to_string(real(res)) + \"+\" + to_string(imag(res)) + \"i\";\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    pair<int, int> parse(string num) {\\n        int i = num.find(\\'+\\');\\n        double real = stoi(num.substr(0, i));\\n        double imaginary = stoi(num.substr(i+1, num.size()-i-2));\\n        pair<int, int> res(real, imaginary);\\n        return res;\\n    }\\n    \\n    string complexNumberMultiply(string num1, string num2) {\\n        pair<int, int> a = parse(num1), b = parse(num2);\\n        int real_a = a.first, imag_a = a.second;\\n        int real_b = b.first, imag_b = b.second;\\n        \\n        return to_string(real_a * real_b - imag_a * imag_b) + \\'+\\' + to_string(real_a * imag_b  + real_b * imag_a)+\\'i\\' ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100431,
                "title": "java-a1-b1-a2-b2-a1a2-b1b2-a1b2-b1a2",
                "content": "    public String complexNumberMultiply(String a, String b) {\\n        String result = \"\";\\n        String[] A = a.split(\"\\\\\\\\+\");\\n        String[] B = b.split(\"\\\\\\\\+\");\\n        int a1 = Integer.parseInt(A[0]);\\n        int b1 = Integer.parseInt(A[1].replace(\"i\",\"\"));\\n\\n        int a2 = Integer.parseInt(B[0]);\\n        int b2 = Integer.parseInt(B[1].replace(\"i\",\"\"));\\n\\n        int a1a2 = a1 * a2;\\n        int b1b2 = b1 * b2;\\n        int a1b2a2b1 = (a1 * b2) + (b1 * a2);\\n\\n        String afinal = (a1a2 + (-1 * b1b2)) + \"\";\\n        String bfinal = a1b2a2b1 + \"i\";\\n        result = afinal+\"+\"+bfinal;\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    public String complexNumberMultiply(String a, String b) {\\n        String result = \"\";\\n        String[] A = a.split(\"\\\\\\\\+\");\\n        String[] B = b.split(\"\\\\\\\\+\");\\n        int a1 = Integer.parseInt(A[0]);\\n        int b1 = Integer.parseInt(A[1].replace(\"i\",\"\"));\\n\\n        int a2 = Integer.parseInt(B[0]);\\n        int b2 = Integer.parseInt(B[1].replace(\"i\",\"\"));\\n\\n        int a1a2 = a1 * a2;\\n        int b1b2 = b1 * b2;\\n        int a1b2a2b1 = (a1 * b2) + (b1 * a2);\\n\\n        String afinal = (a1a2 + (-1 * b1b2)) + \"\";\\n        String bfinal = a1b2a2b1 + \"i\";\\n        result = afinal+\"+\"+bfinal;\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 163190,
                "title": "why-this-problem-is-marked-with-medium-level",
                "content": "I think it should be in `easy` cate\\u4E2Aory.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1422817,
                "title": "python-short-solution-explained",
                "content": "First, we need to parse our numbers, just find symbol `+` inside. For this we can use python functionality with function `.index`: we can be sure that this index exists. Then we create real and imaginary parts for both of numbers, using found indexes.\\nFinally we use definition of complex numbers multiplication and return answer. \\n\\n#### Complexity\\nTime and space complexity is `O(1)`, because numbers are restricted to be in range `[-100, 100]`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def complexNumberMultiply(self, a, b):\\n        ind1 = a.index(\"+\")\\n        ind2 = b.index(\"+\")\\n        x1, y1 = int(a[:ind1]), int(a[ind1+1:-1])\\n        x2, y2 = int(b[:ind2]), int(b[ind2+1:-1])\\n        return str(x1*x2-y1*y2) + \"+\" + str(x1*y2+x2*y1)+\"i\"\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def complexNumberMultiply(self, a, b):\\n        ind1 = a.index(\"+\")\\n        ind2 = b.index(\"+\")\\n        x1, y1 = int(a[:ind1]), int(a[ind1+1:-1])\\n        x2, y2 = int(b[:ind2]), int(b[ind2+1:-1])\\n        return str(x1*x2-y1*y2) + \"+\" + str(x1*y2+x2*y1)+\"i\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100493,
                "title": "2-lines-python",
                "content": "We can leverage that Python already has complex numbers and can `eval` expressions.\\n\\n    def complexNumberMultiply(self, a, b):\\n        z = eval(('(%s)*(%s)' % (a, b)).replace('i', 'j'))\\n        return '%d+%di' % (z.real, z.imag)\\n\\nEdit: Oh well, turns out it's not much work to calculate it myself:\\n\\n    def complexNumberMultiply(self, a, b):\\n        a, ai, b, bi = map(int, re.findall('-?\\\\d+', a+b))\\n        return '%d+%di' % (a*b - ai*bi, a*bi + ai*b)",
                "solutionTags": [],
                "code": "We can leverage that Python already has complex numbers and can `eval` expressions.\\n\\n    def complexNumberMultiply(self, a, b):\\n        z = eval(('(%s)*(%s)' % (a, b)).replace('i', 'j'))\\n        return '%d+%di' % (z.real, z.imag)\\n\\nEdit: Oh well, turns out it's not much work to calculate it myself:\\n\\n    def complexNumberMultiply(self, a, b):\\n        a, ai, b, bi = map(int, re.findall('-?\\\\d+', a+b))\\n        return '%d+%di' % (a*b - ai*bi, a*bi + ai*b)",
                "codeTag": "Python3"
            },
            {
                "id": 1422786,
                "title": "complex-number-multiplication-2-implementations-c-python-java",
                "content": "Given two complex numbers `a + ib` And `x + iy`\\nMultiplication of two complex numbers can be done as:\\n```\\n(a+ib)*(x+iy) = a*x + (i^2*b*y) + i*(bx+ay) = a*x - b*y +i*(bx+ay)\\n```\\nOr in english\\n```\\n(Product of real parts - product of imaginary parts) +\\ni*(product of imaginary part of first and real part of second + product of imaginary part of second and real part of first\\n```\\nSome rules to remember\\n```\\ni = i \\ni^2 = -1 \\ni^3 = -i \\ni^4 = 1\\n```\\n**IDEA**\\n* We make a function to find the values of the imaginary and the real part of the given complex numbers.\\n* We then perform the mathematical operation on these and combine the resultant value to get the answer\\n* Everything is explained in the comments of the C++ code which itself is self-explanatory. \\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        pair<int, int> av = solve(a);\\n        pair<int, int> bv = solve(b);\\n        int re = av.first * bv.first - av.second * bv.second;\\n        int im = av.first * bv.second + av.second * bv.first;\\n        return to_string(re) + \"+\" + to_string(im) + \"i\" ; // Real + i*(Imaginary)\\n    }\\n    pair<int, int> solve(const string& a) {\\n        int plus = find(a.begin(), a.end(), \\'+\\') - a.begin(); // Find Where the plus sign is\\n        int i = find(a.begin(), a.end(), \\'i\\') - a.begin(); // Find where the imaginary part is\\n        int real = stoi(a.substr(0, plus)); // Real Part (string to int)\\n        int img = stoi(a.substr(plus + 1, i - plus)); // Imaginary Part (string to int)\\n        return {real, img};\\n    }\\n};\\n```\\n`In Python3`\\n```\\nclass Solution:\\n    def solve(self, num):\\n        f1 = num.find(\"+\", 0 ,len(num))        \\n        return int(num[0:f1]), int(num[f1+1:len(num)-1])\\n    \\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        a, b = self.solve(num1) #Getting the values for first pair\\n        x, y = self.solve(num2) #Getting the values for second pair\\n        return str(x*a - b*y)+\"+\"+str(a*y + b*x)+\"i\"\\n```\\n\\n**Using the function Split**\\n`In JAVA`\\n```\\nclass Solution {\\n    public String complexNumberMultiply(String a, String b) {\\n        String x[] = a.split(\"\\\\\\\\+|i\") ;\\n        String y[] = b.split(\"\\\\\\\\+|i\") ;\\n        int x1 = Integer.parseInt(x[0]) ;\\n        int y1 = Integer.parseInt(x[1]) ;\\n        int x2 = Integer.parseInt(y[0]) ;\\n        int y2 = Integer.parseInt(y[1]) ;\\n        return (x1*x2 - y1*y2) + \"+\" + (x1*y2 + y1*x2) + \"i\";\\n    }\\n}\\n```\\n`In Python3`\\n```\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        x1, y1 = a[:-1].split(\\'+\\')\\n        x1 = int(x1)\\n        y1 = int(y1)\\n\\n        x2, y2 = b[:-1].split(\\'+\\')\\n        x2 = int(x2)\\n        y2 = int(y2)\\n\\n        return str(x1*x2 - y1*y2)+\"+\"+str(x1*y2 + y1*x2)+\"i\"\\n```\\n\\n**TIME COMPLEXITY-** `O(1)` since range on numbers is `[-100,100]`",
                "solutionTags": [],
                "code": "```\\n(a+ib)*(x+iy) = a*x + (i^2*b*y) + i*(bx+ay) = a*x - b*y +i*(bx+ay)\\n```\n```\\n(Product of real parts - product of imaginary parts) +\\ni*(product of imaginary part of first and real part of second + product of imaginary part of second and real part of first\\n```\n```\\ni = i \\ni^2 = -1 \\ni^3 = -i \\ni^4 = 1\\n```\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        pair<int, int> av = solve(a);\\n        pair<int, int> bv = solve(b);\\n        int re = av.first * bv.first - av.second * bv.second;\\n        int im = av.first * bv.second + av.second * bv.first;\\n        return to_string(re) + \"+\" + to_string(im) + \"i\" ; // Real + i*(Imaginary)\\n    }\\n    pair<int, int> solve(const string& a) {\\n        int plus = find(a.begin(), a.end(), \\'+\\') - a.begin(); // Find Where the plus sign is\\n        int i = find(a.begin(), a.end(), \\'i\\') - a.begin(); // Find where the imaginary part is\\n        int real = stoi(a.substr(0, plus)); // Real Part (string to int)\\n        int img = stoi(a.substr(plus + 1, i - plus)); // Imaginary Part (string to int)\\n        return {real, img};\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def solve(self, num):\\n        f1 = num.find(\"+\", 0 ,len(num))        \\n        return int(num[0:f1]), int(num[f1+1:len(num)-1])\\n    \\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        a, b = self.solve(num1) #Getting the values for first pair\\n        x, y = self.solve(num2) #Getting the values for second pair\\n        return str(x*a - b*y)+\"+\"+str(a*y + b*x)+\"i\"\\n```\n```\\nclass Solution {\\n    public String complexNumberMultiply(String a, String b) {\\n        String x[] = a.split(\"\\\\\\\\+|i\") ;\\n        String y[] = b.split(\"\\\\\\\\+|i\") ;\\n        int x1 = Integer.parseInt(x[0]) ;\\n        int y1 = Integer.parseInt(x[1]) ;\\n        int x2 = Integer.parseInt(y[0]) ;\\n        int y2 = Integer.parseInt(y[1]) ;\\n        return (x1*x2 - y1*y2) + \"+\" + (x1*y2 + y1*x2) + \"i\";\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        x1, y1 = a[:-1].split(\\'+\\')\\n        x1 = int(x1)\\n        y1 = int(y1)\\n\\n        x2, y2 = b[:-1].split(\\'+\\')\\n        x2 = int(x2)\\n        y2 = int(y2)\\n\\n        return str(x1*x2 - y1*y2)+\"+\"+str(x1*y2 + y1*x2)+\"i\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100502,
                "title": "python-straightforward-with-explanation",
                "content": "This is a straightforward string manipulation problem.  Our goal is to extract the integers from the strings, deduce the answer, then output the answer in the required format.\\n\\nFirst, we should extract the integers from the string representation of the complex number.  We split a string like \"a+bi\" into parts **first** = \"a\", **second** = \"bi\", then truncate the \"i\" part in **second**.  We return these as integers.\\n\\nAfter, we perform the complex number multiplication:  (ar + i * ai) * (br + i * bi) = ar * br + i^2 * ai * bi + (ar * bi + ai * br) i.  Of course, i^2 can be simplified to -1.  We then format the output correctly using 'format'.\\n\\n```\\ndef convert_to_tuple(S):\\n  first, second = S.split('+')\\n  second = second[:-1]\\n  return int(first), int(second)\\n\\nar, ai = convert_to_tuple(a)\\nbr, bi = convert_to_tuple(b)\\nreal = ar * br - ai * bi\\nimag = ar * bi + br * ai\\nreturn \"{}+{}i\".format(real, imag)\\n```\\n*Note: I try to focus my editorials on the most repeatable and instructive solutions, not the most clever or short.*",
                "solutionTags": [],
                "code": "```\\ndef convert_to_tuple(S):\\n  first, second = S.split('+')\\n  second = second[:-1]\\n  return int(first), int(second)\\n\\nar, ai = convert_to_tuple(a)\\nbr, bi = convert_to_tuple(b)\\nreal = ar * br - ai * bi\\nimag = ar * bi + br * ai\\nreturn \"{}+{}i\".format(real, imag)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 100504,
                "title": "c-solution",
                "content": "    class Solution {\\n    public:\\n        string complexNumberMultiply(string a, string b) {\\n            pair<int, int> av = parse(a);\\n            pair<int, int> bv = parse(b);\\n            int ra = av.first * bv.first - av.second * bv.second;\\n            int rb = av.first * bv.second + av.second * bv.first;\\n            return to_string(ra) + \"+\" + to_string(rb) + \"i\";\\n        }\\n    \\n        pair<int, int> parse(const string& a) {\\n            int plus = find(a.begin(), a.end(), '+') - a.begin();\\n            int i = find(a.begin(), a.end(), 'i') - a.begin();\\n            int ra = stoi(a.substr(0, plus));\\n            int rb = stoi(a.substr(plus + 1, i - plus));\\n            return {ra, rb};\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string complexNumberMultiply(string a, string b) {\\n            pair<int, int> av = parse(a);\\n            pair<int, int> bv = parse(b);\\n            int ra = av.first * bv.first - av.second * bv.second;\\n            int rb = av.first * bv.second + av.second * bv.first;\\n            return to_string(ra) + \"+\" + to_string(rb) + \"i\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 533397,
                "title": "c-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int real(string str){\\n        int i = 0 ;\\n        string real = \"\" ;\\n        \\n        while(str[i]!=\\'+\\'){\\n            real += str[i] ;\\n            i++ ;\\n        }\\n        return stoi(real) ;\\n    }\\n    \\n    int complex(string str){\\n        int i = 0 ;\\n        string complex = \"\" ;\\n        \\n        while(str[i]!=\\'+\\'){\\n            i++ ;\\n        }\\n        \\n        i++ ;\\n        \\n        while(str[i]!=\\'i\\'){\\n            complex += str[i] ;\\n            i++ ;\\n        }\\n        \\n        return stoi(complex) ;\\n    }\\n    \\n    string complexNumberMultiply(string a, string b) {\\n        string res = \"\" ;\\n        int a1 = real(a) ;\\n        int a2 = real(b) ;\\n        int b1 = complex(a) ;\\n        int b2 = complex(b) ;\\n        \\n        res = res + to_string(a1*a2-b1*b2)+\\'+\\'+to_string(a1*b2+a2*b1)+\\'i\\' ;\\n        \\n        return res ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int real(string str){\\n        int i = 0 ;\\n        string real = \"\" ;\\n        \\n        while(str[i]!=\\'+\\'){\\n            real += str[i] ;\\n            i++ ;\\n        }\\n        return stoi(real) ;\\n    }\\n    \\n    int complex(string str){\\n        int i = 0 ;\\n        string complex = \"\" ;\\n        \\n        while(str[i]!=\\'+\\'){\\n            i++ ;\\n        }\\n        \\n        i++ ;\\n        \\n        while(str[i]!=\\'i\\'){\\n            complex += str[i] ;\\n            i++ ;\\n        }\\n        \\n        return stoi(complex) ;\\n    }\\n    \\n    string complexNumberMultiply(string a, string b) {\\n        string res = \"\" ;\\n        int a1 = real(a) ;\\n        int a2 = real(b) ;\\n        int b1 = complex(a) ;\\n        int b2 = complex(b) ;\\n        \\n        res = res + to_string(a1*a2-b1*b2)+\\'+\\'+to_string(a1*b2+a2*b1)+\\'i\\' ;\\n        \\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100428,
                "title": "java-7ms-easy-to-understand-solution",
                "content": "```\\npublic class Solution {\\n    public String complexNumberMultiply(String a, String b) {\\n        int[] valA = getValue(a);\\n        int[] valB = getValue(b);\\n        \\n        int real = valA[0] * valB[0] - valA[1] * valB[1];\\n        int img = valA[0] * valB[1] + valA[1] * valB[0];\\n        \\n        return real + \"+\" + img + \"i\";\\n    }\\n    \\n    private int[] getValue(String s) {\\n        String[] str = s.split(\"\\\\\\\\+\");\\n        int[] val = new int[2];\\n        val[0] = Integer.valueOf(str[0]);\\n        int indexOfI = str[1].indexOf(\"i\");\\n        val[1] = Integer.valueOf(str[1].substring(0, indexOfI));\\n        \\n        return val;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String complexNumberMultiply(String a, String b) {\\n        int[] valA = getValue(a);\\n        int[] valB = getValue(b);\\n        \\n        int real = valA[0] * valB[0] - valA[1] * valB[1];\\n        int img = valA[0] * valB[1] + valA[1] * valB[0];\\n        \\n        return real + \"+\" + img + \"i\";\\n    }\\n    \\n    private int[] getValue(String s) {\\n        String[] str = s.split(\"\\\\\\\\+\");\\n        int[] val = new int[2];\\n        val[0] = Integer.valueOf(str[0]);\\n        int indexOfI = str[1].indexOf(\"i\");\\n        val[1] = Integer.valueOf(str[1].substring(0, indexOfI));\\n        \\n        return val;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187864,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        a1,b1 = num1.split(\\'+\\')\\n        a1 = int(a1)\\n        b1 = int(b1[:-1])\\n        a2,b2 = num2.split(\\'+\\')\\n        a2 = int(a2)\\n        b2 = int(b2[:-1])\\n        return str(a1*a2 + b1*b2*(-1)) + \\'+\\' + str(a1*b2 + a2*b1) + \\'i\\'\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        a1,b1 = num1.split(\\'+\\')\\n        a1 = int(a1)\\n        b1 = int(b1[:-1])\\n        a2,b2 = num2.split(\\'+\\')\\n        a2 = int(a2)\\n        b2 = int(b2[:-1])\\n        return str(a1*a2 + b1*b2*(-1)) + \\'+\\' + str(a1*b2 + a2*b1) + \\'i\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422893,
                "title": "python-simple-math-clean-concise",
                "content": "**Idea**\\n- Let `num1` as `a + bi`, let `num2` as `c + di`.\\n- Then `num1 * num2` = `(a + bi) * (c + di)` = `a*c + b*d*i^2 + (a*d + b*c)` = `a*c - b*d + (a*d + b*c)`, since `i^2 = -1`.\\n```python\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        def getParams(num):\\n            parts = num.split(\"+\")\\n            return int(parts[0]), int(parts[1][:-1])\\n        \\n        a, b = getParams(num1)\\n        c, d = getParams(num2)\\n        return \"{}+{}i\".format(a*c-b*d, a*d+c*b)\\n```\\nComplexity:\\n- Time: `O(M+N)` where `N` is the length of `num1`, `M` is the length of `num2`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        def getParams(num):\\n            parts = num.split(\"+\")\\n            return int(parts[0]), int(parts[1][:-1])\\n        \\n        a, b = getParams(num1)\\n        c, d = getParams(num2)\\n        return \"{}+{}i\".format(a*c-b*d, a*d+c*b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782736,
                "title": "c-istringstream-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        int ra, ia, rb, ib;\\n        char buff;\\n        istringstream is1(a), is2(b);\\n        is1 >> ra >> buff >> ia >> buff;\\n        is2 >> rb >> buff >> ib >> buff;\\n        int real = ra*rb - ia*ib;\\n        int img = ra*ib + rb*ia;\\n        return to_string(real) + \"+\" + to_string(img) + \"i\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        int ra, ia, rb, ib;\\n        char buff;\\n        istringstream is1(a), is2(b);\\n        is1 >> ra >> buff >> ia >> buff;\\n        is2 >> rb >> buff >> ib >> buff;\\n        int real = ra*rb - ia*ib;\\n        int img = ra*ib + rb*ia;\\n        return to_string(real) + \"+\" + to_string(img) + \"i\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423329,
                "title": "c-python-java-2-implementation-w-approach-and-other-rules",
                "content": "Given two complex numbers `a + ib` And `x + iy`\\nMultiplication of two complex numbers can be done as:\\n```\\n(a+ib)*(x+iy) = a*x + (i^2*b*y) + i*(bx+ay) = a*x - b*y +i*(bx+ay)\\n```\\nOr in english\\n```\\n(Product of real parts - product of imaginary parts) +\\ni*(product of imaginary part of first and real part of second + product of imaginary part of second and real part of first\\n```\\nSome rules to remember\\n```\\ni = i \\ni^2 = -1 \\ni^3 = -i \\ni^4 = 1\\n```\\n**IDEA**\\n* We make a function to find the values of the imaginary and the real part of the given complex numbers.\\n* We then perform the mathematical operation on these and combine the resultant value to get the answer\\n* Everything is explained in the comments of the C++ code which itself is self-explanatory. \\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        pair<int, int> av = solve(a);\\n        pair<int, int> bv = solve(b);\\n        int re = av.first * bv.first - av.second * bv.second;\\n        int im = av.first * bv.second + av.second * bv.first;\\n        return to_string(re) + \"+\" + to_string(im) + \"i\" ; // Real + i*(Imaginary)\\n    }\\n    pair<int, int> solve(const string& a) {\\n        int plus = find(a.begin(), a.end(), \\'+\\') - a.begin(); // Find Where the plus sign is\\n        int i = find(a.begin(), a.end(), \\'i\\') - a.begin(); // Find where the imaginary part is\\n        int real = stoi(a.substr(0, plus)); // Real Part (string to int)\\n        int img = stoi(a.substr(plus + 1, i - plus)); // Imaginary Part (string to int)\\n        return {real, img};\\n    }\\n};\\n```\\n`In Python3`\\n```\\nclass Solution:\\n    def solve(self, num):\\n        f1 = num.find(\"+\", 0 ,len(num))        \\n        return int(num[0:f1]), int(num[f1+1:len(num)-1])\\n    \\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        a, b = self.solve(num1) #Getting the values for first pair\\n        x, y = self.solve(num2) #Getting the values for second pair\\n        return str(x*a - b*y)+\"+\"+str(a*y + b*x)+\"i\"\\n```\\n\\n**Using the function Split**\\n`In JAVA`\\n```\\nclass Solution {\\n    public String complexNumberMultiply(String a, String b) {\\n        String x[] = a.split(\"\\\\\\\\+|i\") ;\\n        String y[] = b.split(\"\\\\\\\\+|i\") ;\\n        int x1 = Integer.parseInt(x[0]) ;\\n        int y1 = Integer.parseInt(x[1]) ;\\n        int x2 = Integer.parseInt(y[0]) ;\\n        int y2 = Integer.parseInt(y[1]) ;\\n        return (x1*x2 - y1*y2) + \"+\" + (x1*y2 + y1*x2) + \"i\";\\n    }\\n}\\n```\\n`In Python3`\\n```\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        x1, y1 = a[:-1].split(\\'+\\')\\n        x1 = int(x1)\\n        y1 = int(y1)\\n\\n        x2, y2 = b[:-1].split(\\'+\\')\\n        x2 = int(x2)\\n        y2 = int(y2)\\n\\n        return str(x1*x2 - y1*y2)+\"+\"+str(x1*y2 + y1*x2)+\"i\"\\n```\\n\\n**TIME COMPLEXITY-** `O(1)` since range on numbers is `[-100,100]`",
                "solutionTags": [],
                "code": "```\\n(a+ib)*(x+iy) = a*x + (i^2*b*y) + i*(bx+ay) = a*x - b*y +i*(bx+ay)\\n```\n```\\n(Product of real parts - product of imaginary parts) +\\ni*(product of imaginary part of first and real part of second + product of imaginary part of second and real part of first\\n```\n```\\ni = i \\ni^2 = -1 \\ni^3 = -i \\ni^4 = 1\\n```\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        pair<int, int> av = solve(a);\\n        pair<int, int> bv = solve(b);\\n        int re = av.first * bv.first - av.second * bv.second;\\n        int im = av.first * bv.second + av.second * bv.first;\\n        return to_string(re) + \"+\" + to_string(im) + \"i\" ; // Real + i*(Imaginary)\\n    }\\n    pair<int, int> solve(const string& a) {\\n        int plus = find(a.begin(), a.end(), \\'+\\') - a.begin(); // Find Where the plus sign is\\n        int i = find(a.begin(), a.end(), \\'i\\') - a.begin(); // Find where the imaginary part is\\n        int real = stoi(a.substr(0, plus)); // Real Part (string to int)\\n        int img = stoi(a.substr(plus + 1, i - plus)); // Imaginary Part (string to int)\\n        return {real, img};\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def solve(self, num):\\n        f1 = num.find(\"+\", 0 ,len(num))        \\n        return int(num[0:f1]), int(num[f1+1:len(num)-1])\\n    \\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        a, b = self.solve(num1) #Getting the values for first pair\\n        x, y = self.solve(num2) #Getting the values for second pair\\n        return str(x*a - b*y)+\"+\"+str(a*y + b*x)+\"i\"\\n```\n```\\nclass Solution {\\n    public String complexNumberMultiply(String a, String b) {\\n        String x[] = a.split(\"\\\\\\\\+|i\") ;\\n        String y[] = b.split(\"\\\\\\\\+|i\") ;\\n        int x1 = Integer.parseInt(x[0]) ;\\n        int y1 = Integer.parseInt(x[1]) ;\\n        int x2 = Integer.parseInt(y[0]) ;\\n        int y2 = Integer.parseInt(y[1]) ;\\n        return (x1*x2 - y1*y2) + \"+\" + (x1*y2 + y1*x2) + \"i\";\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        x1, y1 = a[:-1].split(\\'+\\')\\n        x1 = int(x1)\\n        y1 = int(y1)\\n\\n        x2, y2 = b[:-1].split(\\'+\\')\\n        x2 = int(x2)\\n        y2 = int(y2)\\n\\n        return str(x1*x2 - y1*y2)+\"+\"+str(x1*y2 + y1*x2)+\"i\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240672,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    void split_re_im(string& s, int& re, int& im)\\n    {\\n        int l = s.length();\\n        int i=0;\\n        string t1 = \"\", t2 = \"\";\\n        while(i<l && s[i] != \\'+\\')\\n        {\\n            t1 += s[i];\\n            ++i;\\n        }\\n        ++i;\\n        re = stoi(t1);\\n        while(i<l && s[i] != \\'i\\')\\n        {\\n            t2 += s[i];\\n            ++i;\\n        }\\n        im = stoi(t2);\\n    }\\npublic:\\n    string complexNumberMultiply(string num1, string num2)\\n     {\\n        int re1, im1, re2, im2, re, im;\\n        split_re_im(num1,re1,im1);\\n        split_re_im(num2,re2,im2);\\n        re = (re1*re2-im1*im2);\\n        im = (re1*im2+im1*re2);\\n        string s1,s2,s=\"\";\\n        s1 = to_string(re);\\n        s2 = to_string(im);\\n        s  = s1 + \\'+\\'+ s2 + \\'i\\';\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void split_re_im(string& s, int& re, int& im)\\n    {\\n        int l = s.length();\\n        int i=0;\\n        string t1 = \"\", t2 = \"\";\\n        while(i<l && s[i] != \\'+\\')\\n        {\\n            t1 += s[i];\\n            ++i;\\n        }\\n        ++i;\\n        re = stoi(t1);\\n        while(i<l && s[i] != \\'i\\')\\n        {\\n            t2 += s[i];\\n            ++i;\\n        }\\n        im = stoi(t2);\\n    }\\npublic:\\n    string complexNumberMultiply(string num1, string num2)\\n     {\\n        int re1, im1, re2, im2, re, im;\\n        split_re_im(num1,re1,im1);\\n        split_re_im(num2,re2,im2);\\n        re = (re1*re2-im1*im2);\\n        im = (re1*im2+im1*re2);\\n        string s1,s2,s=\"\";\\n        s1 = to_string(re);\\n        s2 = to_string(im);\\n        s  = s1 + \\'+\\'+ s2 + \\'i\\';\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675779,
                "title": "c-solution-complex-number-multiplication-100-faster-easy-to-understand",
                "content": "**Using String Operations & Math**\\n* Time Complexity - O( N )\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        string real1 , img1, real2, img2;\\n        // calculating 1st complex number\\n        int i = 0;\\n        while(num1[i] != \\'+\\'){\\n            real1 += num1[i];\\n            i++;\\n        }\\n        img1 = num1.substr(i + 1, num1.length() -  i);\\n        \\n        // calculating 2nd complex number\\n        i = 0;\\n        while(num2[i] != \\'+\\'){\\n            real2 += num2[i];\\n            i++;\\n        }\\n        img2 = num2.substr(i + 1, num2.length() - i );\\n        \\n        //converting string into integers\\n        int r1 = stoi(real1), r2 = stoi(real2);\\n        int i1 = stoi(img1), i2 = stoi(img2);\\n        \\n        // product of complex number\\n        int real = (r1 * r2) - (i1 * i2 );\\n        int img  = (r1 * i2) + (r2 * i1);\\n        \\n        string ans = to_string(real) + \"+\" + to_string(img) + \"i\";\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPlease Upvote If it helps : )",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        string real1 , img1, real2, img2;\\n        // calculating 1st complex number\\n        int i = 0;\\n        while(num1[i] != \\'+\\'){\\n            real1 += num1[i];\\n            i++;\\n        }\\n        img1 = num1.substr(i + 1, num1.length() -  i);\\n        \\n        // calculating 2nd complex number\\n        i = 0;\\n        while(num2[i] != \\'+\\'){\\n            real2 += num2[i];\\n            i++;\\n        }\\n        img2 = num2.substr(i + 1, num2.length() - i );\\n        \\n        //converting string into integers\\n        int r1 = stoi(real1), r2 = stoi(real2);\\n        int i1 = stoi(img1), i2 = stoi(img2);\\n        \\n        // product of complex number\\n        int real = (r1 * r2) - (i1 * i2 );\\n        int img  = (r1 * i2) + (r2 * i1);\\n        \\n        string ans = to_string(real) + \"+\" + to_string(img) + \"i\";\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614656,
                "title": "c-solution-using-string-find-and-stoi",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        int pos1=num1.find(\\'+\\');\\n        int a=stoi(num1.substr(0,pos1+1));\\n        \\n        int i=num1.find(\\'i\\');\\n        int b=stoi(num1.substr(pos1+1,i+1));\\n        \\n        pos1=num2.find(\\'+\\');\\n        int c=stoi(num2.substr(0,pos1+1));\\n        \\n        i=num2.find(\\'i\\');\\n        int d=stoi(num2.substr(pos1+1,i+1));\\n        \\n        \\n        int a1 = (a*c - b*d);\\n        int b1 = (a*d + b*c);\\n        \\n        return to_string(a1)+\"+\"+to_string(b1)+\"i\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        int pos1=num1.find(\\'+\\');\\n        int a=stoi(num1.substr(0,pos1+1));\\n        \\n        int i=num1.find(\\'i\\');\\n        int b=stoi(num1.substr(pos1+1,i+1));\\n        \\n        pos1=num2.find(\\'+\\');\\n        int c=stoi(num2.substr(0,pos1+1));\\n        \\n        i=num2.find(\\'i\\');\\n        int d=stoi(num2.substr(pos1+1,i+1));\\n        \\n        \\n        int a1 = (a*c - b*d);\\n        int b1 = (a*d + b*c);\\n        \\n        return to_string(a1)+\"+\"+to_string(b1)+\"i\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425006,
                "title": "c-easy-solution",
                "content": "pair<int, int> extract(string s) {``\\n\\t\\tint ind = s.find(\\'+\\');\\n\\t\\tauto real = stoi(s.substr(0, ind));\\n\\t\\tauto imag = stoi(s.substr(ind + 1, s.length() - 2 - 1));\\n\\t\\treturn { real, imag};\\n}\\n\\nstring complexNumberMultiply(string num1, string num2) {\\n\\t\\t\\t //extract the imaginary and real numbers from string \\n\\t\\t\\tauto a = extract(num1);\\n\\t\\t\\tauto b = extract(num2);\\n\\t\\t\\t// take all the value from pair \\n\\t\\t\\tint realA = a.first, realB = b.first, imagA = a.second, imagB = b.second;\\n\\t\\t\\t//(a+ci)(b+di) = a*b + a*di + b*ci + ci*di\\n\\t\\t\\t//i^2 = -1 so\\n\\t\\t\\t// a*b + a*di + b*ci - cd => a*b - c*d + a*di + b*ci => (a*b - c*d) + (a*d + b*c)*i\\n\\t\\t\\tstring res = to_string(realA * realB - imagA * imagB) + \\'+\\' + to_string(realA * imagB + realB * imagA) + \\'i\\';****\\n\\t\\t\\treturn res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "pair<int, int> extract(string s) {``\\n\\t\\tint ind = s.find(\\'+\\');\\n\\t\\tauto real = stoi(s.substr(0, ind));\\n\\t\\tauto imag = stoi(s.substr(ind + 1, s.length() - 2 - 1));\\n\\t\\treturn { real, imag};\\n}\\n\\nstring complexNumberMultiply(string num1, string num2) {\\n\\t\\t\\t //extract the imaginary and real numbers from string \\n\\t\\t\\tauto a = extract(num1);\\n\\t\\t\\tauto b = extract(num2);\\n\\t\\t\\t// take all the value from pair \\n\\t\\t\\tint realA = a.first, realB = b.first, imagA = a.second, imagB = b.second;\\n\\t\\t\\t//(a+ci)(b+di) = a*b + a*di + b*ci + ci*di\\n\\t\\t\\t//i^2 = -1 so\\n\\t\\t\\t// a*b + a*di + b*ci - cd => a*b - c*d + a*di + b*ci => (a*b - c*d) + (a*d + b*c)*i\\n\\t\\t\\tstring res = to_string(realA * realB - imagA * imagB) + \\'+\\' + to_string(realA * imagB + realB * imagA) + \\'i\\';****\\n\\t\\t\\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1423766,
                "title": "easy-to-understand-regex-explanation-with-solution",
                "content": "The regex which is the core of this solution is \\n```\\nString x[] = a.split(\"\\\\\\\\+|i\");\\nint a_real = Integer.parseInt(x[0]);\\nint a_img  = Integer.parseInt(x[1]);\\n```\\n**Regex Explanation:**\\n\\n***Why `\\\\\\\\+`?***\\n`+` aka plus is a metacharacter. Metacharacters in Java regular expressions have a special meaning. If you really want to match these characters in their literal form, and not their metacharacter meaning, you must \"escape\" the metacharacer you want to match. To escape a metacharacter you use the Java regular expression escape character - the backslash character. Escaping a character means preceding it with the backslash character. For instance, like this:\\n`\\\\+`\\nIn this example the `+` character is preceded (escaped) by the \\\\ character. When escaped the plus character will actually match a plus character in the input text. The special metacharacter meaning of an escaped metacharacter is ignored - only its actual literal value (e.g. a plus) is used.\\nJava regular expression syntax uses the backslash character as escape character, just like Java Strings do. This gives a little challenge when writing a regular expression in a Java string. Look at this regular expression example:\\n\\n`String regex = \"\\\\\\\\+\";`\\n\\nNotice that the regular expression String contains two backslashes after each other, and then a `+` . The reason is, that first the Java compiler interprets the two \\\\\\\\ characters as an escaped Java String character. After the Java compiler is done, only one \\\\ is left, as \\\\\\\\ means the character \\\\. The string thus looks like this:\\n`\\\\+`\\nNow the Java regular expression interpreter kicks in, and interprets the remaining backslash as an escape character. The following character `+` is now interpreted to mean an actual plus, not to have the special regular expression meaning it otherwise has. The remaining regular expression thus matches for the plus character and nothing more.\\n\\n\\n***Why `|`?***\\n`|` aka pipe is the representation of logical or operator. When we are splitting our complex number we want to first split it till `+` and then in next time by `i`. Thus if we want to split the string by either by `+` or by `i`.\\n\\n**References : **\\n1. http://tutorials.jenkov.com/java-regex/index.html\\n2. Regex tool : https://regex101.com/\\n\\n**Solution**\\n```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        String[] a = num1.split(\"\\\\\\\\+|i\");\\n        String[] b = num2.split(\"\\\\\\\\+|i\");\\n        int ar = Integer.parseInt(a[0]), ai = Integer.parseInt(a[1]);\\n        int br = Integer.parseInt(b[0]), bi = Integer.parseInt(b[1]);\\n        return String.format(\"%d+%di\",ar*br -ai*bi, ar*bi + ai*br);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nString x[] = a.split(\"\\\\\\\\+|i\");\\nint a_real = Integer.parseInt(x[0]);\\nint a_img  = Integer.parseInt(x[1]);\\n```\n```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        String[] a = num1.split(\"\\\\\\\\+|i\");\\n        String[] b = num2.split(\"\\\\\\\\+|i\");\\n        int ar = Integer.parseInt(a[0]), ai = Integer.parseInt(a[1]);\\n        int br = Integer.parseInt(b[0]), bi = Integer.parseInt(b[1]);\\n        return String.format(\"%d+%di\",ar*br -ai*bi, ar*bi + ai*br);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423406,
                "title": "c-clean-easy-solution-brute-force-basic-mathematics",
                "content": "**Solution:**\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        //from the string we must extract the real and imaginary parts to perform individual multiplication.\\n        string r1 = \"\", r2 = \"\", img1 = \"\", img2 = \"\";\\n        int f = 0;\\n        for(int i = 0; i < num1.size(); i++){\\n            if(num1[i] == \\'+\\')\\n                f = 1;\\n            \\n            if(f and num1[i] != \\'+\\' and num1[i] != \\'i\\')\\n                img1 += num1[i];\\n            else if(f == 0)\\n                r1 += num1[i];        \\n        }\\n        f = 0;\\n        for(int i = 0; i < num2.size(); i++){\\n            if(num2[i] == \\'+\\')\\n                f = 1;\\n            \\n            if(f and num2[i] != \\'+\\' and num2[i] != \\'i\\')\\n                img2 += num2[i];\\n            else if(f == 0)\\n                r2 += num2[i];        \\n        }\\n        \\n        \\n \\xA0 \\xA0 \\xA0 \\xA0//stoi function is used to convert small strings directly to integers\\n \\xA0 \\xA0 \\xA0 int real1 = stoi(r1);\\n \\xA0 \\xA0 \\xA0 \\xA0int real2 = stoi(r2);\\n \\xA0 \\xA0 \\xA0 \\xA0int imaginary1 = stoi(img1);\\n        int imaginary2 = stoi(img2);\\n        \\n        //This way we tend to extract the real and imaginary parts in integer from their respective strings.\\n        \\n        string ans = \"\";\\n        //Now, mathematically the real part equals to\\n        ans += to_string((real1 * real2) - (imaginary1 * imaginary2));\\n        \\n        ans += \\'+\\';\\n        \\n        //Now, mathematically the imaginary part equals to\\n        ans += to_string((real1 * imaginary2) + (real2 * imaginary1));\\n        ans += \\'i\\';\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Feel free to share ideas or any improvements as well.**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        //from the string we must extract the real and imaginary parts to perform individual multiplication.\\n        string r1 = \"\", r2 = \"\", img1 = \"\", img2 = \"\";\\n        int f = 0;\\n        for(int i = 0; i < num1.size(); i++){\\n            if(num1[i] == \\'+\\')\\n                f = 1;\\n            \\n            if(f and num1[i] != \\'+\\' and num1[i] != \\'i\\')\\n                img1 += num1[i];\\n            else if(f == 0)\\n                r1 += num1[i];        \\n        }\\n        f = 0;\\n        for(int i = 0; i < num2.size(); i++){\\n            if(num2[i] == \\'+\\')\\n                f = 1;\\n            \\n            if(f and num2[i] != \\'+\\' and num2[i] != \\'i\\')\\n                img2 += num2[i];\\n            else if(f == 0)\\n                r2 += num2[i];        \\n        }\\n        \\n        \\n \\xA0 \\xA0 \\xA0 \\xA0//stoi function is used to convert small strings directly to integers\\n \\xA0 \\xA0 \\xA0 int real1 = stoi(r1);\\n \\xA0 \\xA0 \\xA0 \\xA0int real2 = stoi(r2);\\n \\xA0 \\xA0 \\xA0 \\xA0int imaginary1 = stoi(img1);\\n        int imaginary2 = stoi(img2);\\n        \\n        //This way we tend to extract the real and imaginary parts in integer from their respective strings.\\n        \\n        string ans = \"\";\\n        //Now, mathematically the real part equals to\\n        ans += to_string((real1 * real2) - (imaginary1 * imaginary2));\\n        \\n        ans += \\'+\\';\\n        \\n        //Now, mathematically the imaginary part equals to\\n        ans += to_string((real1 * imaginary2) + (real2 * imaginary1));\\n        ans += \\'i\\';\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294549,
                "title": "537-space-99-29-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Split num1 and num2 into their real and imaginary parts by finding the position of the + and i symbols in the strings using the index() method.\\n\\n2. Convert the real and imaginary parts of num1 and num2 from strings to integers using the int() function.\\n\\n3. Compute the real and imaginary parts of the product using the formula:\\n```\\nreal_part = (a * c) - (b * d)\\nimag_part = (a * d) + (b * c)\\n```\\nwhere a, b, c, and d are the integers representing the real and imaginary parts of num1 and num2.\\n\\n4. Combine the real and imaginary parts into a string on the form \"real+imaginaryi\" using the str() function, where real_part and imag_part are the computed real and imaginary parts of the product.\\n\\n5. Return the combined string as the output of the complexNumberMultiply method.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        # Split num1 and num2 into real and imaginary parts\\n        a, b = int(num1[:num1.index(\"+\")]), int(num1[num1.index(\"+\")+1:-1])\\n        c, d = int(num2[:num2.index(\"+\")]), int(num2[num2.index(\"+\")+1:-1])\\n        \\n        # Compute the real and imaginary parts of the product\\n        real_part = a * c - b * d\\n        imag_part = a * d + b * c\\n        \\n        # Combine the real and imaginary parts to form the result\\n        result = str(real_part) + \"+\" + str(imag_part) + \"i\"\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nreal_part = (a * c) - (b * d)\\nimag_part = (a * d) + (b * c)\\n```\n```\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        # Split num1 and num2 into real and imaginary parts\\n        a, b = int(num1[:num1.index(\"+\")]), int(num1[num1.index(\"+\")+1:-1])\\n        c, d = int(num2[:num2.index(\"+\")]), int(num2[num2.index(\"+\")+1:-1])\\n        \\n        # Compute the real and imaginary parts of the product\\n        real_part = a * c - b * d\\n        imag_part = a * d + b * c\\n        \\n        # Combine the real and imaginary parts to form the result\\n        result = str(real_part) + \"+\" + str(imag_part) + \"i\"\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737160,
                "title": "java-faster-than-92-magic-of-regex",
                "content": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        String arr1[] = num1.split(\"\\\\\\\\+\");\\n        String arr2[] = num2.split(\"\\\\\\\\+\");\\n        int realPart = 0, imaginaryPart = 0;\\n        int temp1 = Integer.parseInt(arr1[0]);\\n        int temp2 = Integer.parseInt(arr1[1].replace(\"i\", \"\"));\\n        int temp3 = Integer.parseInt(arr2[0]);\\n        int temp4 = Integer.parseInt(arr2[1].replace(\"i\", \"\"));\\n        realPart = temp1*temp3 - temp2*temp4;\\n        imaginaryPart = temp1*temp4 + temp2*temp3;\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(realPart);\\n        sb.append(\"+\");\\n        sb.append(imaginaryPart);\\n        sb.append(\"i\");\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        String arr1[] = num1.split(\"\\\\\\\\+\");\\n        String arr2[] = num2.split(\"\\\\\\\\+\");\\n        int realPart = 0, imaginaryPart = 0;\\n        int temp1 = Integer.parseInt(arr1[0]);\\n        int temp2 = Integer.parseInt(arr1[1].replace(\"i\", \"\"));\\n        int temp3 = Integer.parseInt(arr2[0]);\\n        int temp4 = Integer.parseInt(arr2[1].replace(\"i\", \"\"));\\n        realPart = temp1*temp3 - temp2*temp4;\\n        imaginaryPart = temp1*temp4 + temp2*temp3;\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(realPart);\\n        sb.append(\"+\");\\n        sb.append(imaginaryPart);\\n        sb.append(\"i\");\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424552,
                "title": "python-clean-solution-using-object-oriented-design",
                "content": "One liners are cute but it\\'s much better to write understandable code\\n\\n```python\\nclass ComplexNumber:\\n        def __init__(self, string):\\n            real, imaginary = string.split(\\'+\\')\\n            self.real = int(real)\\n            self.imaginary = int(imaginary[:-1])\\n            \\n        def __mul__(self, other):\\n            if type(other) is not ComplexNumber:\\n                raise NotImplementedError\\n            real = self.real*other.real+self.imaginary*other.imaginary*-1\\n            imaginary = self.real*other.imaginary+self.imaginary*other.real\\n            return ComplexNumber(f\\'{real}+{imaginary}i\\')\\n\\t\\t\\t\\n\\t\\t__rmul__ = __mul__\\n        \\n        def __str__(self):\\n            return f\\'{self.real}+{self.imaginary}i\\'\\n            \\nclass Solution:\\n                \\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        return str(ComplexNumber(num1)*ComplexNumber(num2))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass ComplexNumber:\\n        def __init__(self, string):\\n            real, imaginary = string.split(\\'+\\')\\n            self.real = int(real)\\n            self.imaginary = int(imaginary[:-1])\\n            \\n        def __mul__(self, other):\\n            if type(other) is not ComplexNumber:\\n                raise NotImplementedError\\n            real = self.real*other.real+self.imaginary*other.imaginary*-1\\n            imaginary = self.real*other.imaginary+self.imaginary*other.real\\n            return ComplexNumber(f\\'{real}+{imaginary}i\\')\\n\\t\\t\\t\\n\\t\\t__rmul__ = __mul__\\n        \\n        def __str__(self):\\n            return f\\'{self.real}+{self.imaginary}i\\'\\n            \\nclass Solution:\\n                \\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        return str(ComplexNumber(num1)*ComplexNumber(num2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423600,
                "title": "easy-math-equation-explained-c-code",
                "content": "#### **iota i, i*i=-1**\\n    //(a+ib)x(c+id)=(a*c+i^2*b*d)+(a*d+b*c)*i \\n    //(a+ib)x(c+id)=(a*c+(-1)*b*d)+(a*d+b*c)*i  (i*i=-1)\\n    //(a+ib)x(c+id)=(a*c-*b*d)+(a*d+b*c)*i;\\n    string complexNumberMultiply(string num1, string num2) {\\n        int a,b,c,d;\\n        //convert num1 to a+ib\\n        int it1=num1.find(\\'+\\');\\n        a=stoi(num1.substr(0,it1));\\n        b=stoi(num1.substr(it1+1,num1.size()-2)); //num1.size()-2 to skip \\'i\\' character at last index\\n        //convert num2 to c+ib\\n        int it2=num2.find(\\'+\\');\\n        c=stoi(num2.substr(0,it2));\\n        d=stoi(num2.substr(it2+1,num2.size()-2));\\n        \\n        return to_string(a*c-b*d)+\\'+\\'+to_string(a*d+c*b)+\\'i\\';\\n    }\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "#### **iota i, i*i=-1**\\n    //(a+ib)x(c+id)=(a*c+i^2*b*d)+(a*d+b*c)*i \\n    //(a+ib)x(c+id)=(a*c+(-1)*b*d)+(a*d+b*c)*i  (i*i=-1)\\n    //(a+ib)x(c+id)=(a*c-*b*d)+(a*d+b*c)*i;\\n    string complexNumberMultiply(string num1, string num2) {\\n        int a,b,c,d;\\n        //convert num1 to a+ib\\n        int it1=num1.find(\\'+\\');\\n        a=stoi(num1.substr(0,it1));\\n        b=stoi(num1.substr(it1+1,num1.size()-2)); //num1.size()-2 to skip \\'i\\' character at last index\\n        //convert num2 to c+ib\\n        int it2=num2.find(\\'+\\');\\n        c=stoi(num2.substr(0,it2));\\n        d=stoi(num2.substr(it2+1,num2.size()-2));\\n        \\n        return to_string(a*c-b*d)+\\'+\\'+to_string(a*d+c*b)+\\'i\\';\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1423216,
                "title": "0-ms-faster-than-100-java-online-solutions",
                "content": "class Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        \\n        int[] dm1=new int[2];\\n        int[] dm2=new int[2];\\n        StringBuilder s=new StringBuilder();\\n        dm1=checkInt(num1);\\n        dm2=checkInt(num2);\\n        int int1=dm1[0];\\n        int int2=dm2[0];\\n        int img1=checkImg(num1,dm1[1]);\\n        int img2=checkImg(num2,dm2[1]);\\n        int prodin=int1*int2-img1*img2;\\n        int prodim=int1*img2+int2*img1;\\n        s.append(prodin);\\n\\t\\ts.append(\"+\");\\n        s.append(prodim);\\n        s.append(\"i\");\\n        return s.toString(); \\n    }\\n     public int[] checkInt(String num){\\n         int[] intp=new int[2];\\n         String s=new String();\\n        for(int i=0;i<=4;i++){\\n            if(num.charAt(i)==\\'-\\' && i==0){\\n                continue;\\n            }\\n            if(num.charAt(i)==\\'+\\'){\\n                s=num.substring(0,i);\\n                intp[0]=Integer.parseInt(s);\\n                intp[1]=i;\\n                break;\\n            }\\n            \\n        }\\n         return intp;\\n     }\\n    public int checkImg(String num,int imin){\\n         int img=0;\\n         String s=new String();\\n         s=num.substring(imin+1,num.length()-1);\\n         img=Integer.parseInt(s);\\n        \\n         return img;\\n     }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        \\n        int[] dm1=new int[2];\\n        int[] dm2=new int[2];\\n        StringBuilder s=new StringBuilder();\\n        dm1=checkInt(num1);\\n        dm2=checkInt(num2);\\n        int int1=dm1[0];\\n        int int2=dm2[0];\\n        int img1=checkImg(num1,dm1[1]);\\n        int img2=checkImg(num2,dm2[1]);\\n        int prodin=int1*int2-img1*img2;\\n        int prodim=int1*img2+int2*img1;\\n        s.append(prodin);\\n\\t\\ts.append(\"+\");\\n        s.append(prodim);\\n        s.append(\"i\");\\n        return s.toString(); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1422981,
                "title": "java-easy-way",
                "content": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        int a1 = Integer.parseInt(num1.substring(0, num1.indexOf(\"+\")));\\n        int b1 = Integer.parseInt(num1.substring(num1.indexOf(\"+\") + 1, num1.length()-1));\\n        int a2 = Integer.parseInt(num2.substring(0, num2.indexOf(\"+\")));\\n        int b2 = Integer.parseInt(num2.substring(num2.indexOf(\"+\")+1, num2.length()-1));\\n        \\n        int a3 = a1*a2 + b1*b2*-1;\\n        int b3 = a1*b2 + a2*b1;\\n        \\n        return a3 + \"+\" + b3 + \"i\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        int a1 = Integer.parseInt(num1.substring(0, num1.indexOf(\"+\")));\\n        int b1 = Integer.parseInt(num1.substring(num1.indexOf(\"+\") + 1, num1.length()-1));\\n        int a2 = Integer.parseInt(num2.substring(0, num2.indexOf(\"+\")));\\n        int b2 = Integer.parseInt(num2.substring(num2.indexOf(\"+\")+1, num2.length()-1));\\n        \\n        int a3 = a1*a2 + b1*b2*-1;\\n        int b3 = a1*b2 + a2*b1;\\n        \\n        return a3 + \"+\" + b3 + \"i\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522131,
                "title": "python-100-100",
                "content": "```Python\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        def getData(s):\\n            s = s.split(\"+\")\\n            return (s[0],s[1][:-1])\\n        \\n        realA,imagininaryA = getData(a)\\n        realB,imagininaryB = getData(b)\\n        \\n        one = int(realA)*int(realB)\\n        two = int(realA)*int(imagininaryB)\\n        three = int(imagininaryA)*int(realB)\\n        four = -1*int(imagininaryA)*int(imagininaryB)\\n        \\n        return (str(one+four)+\"+\" + str(two+three)+\"i\")\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        def getData(s):\\n            s = s.split(\"+\")\\n            return (s[0],s[1][:-1])\\n        \\n        realA,imagininaryA = getData(a)\\n        realB,imagininaryB = getData(b)\\n        \\n        one = int(realA)*int(realB)\\n        two = int(realA)*int(imagininaryB)\\n        three = int(imagininaryA)*int(realB)\\n        four = -1*int(imagininaryA)*int(imagininaryB)\\n        \\n        return (str(one+four)+\"+\" + str(two+three)+\"i\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138808,
                "title": "java-solution-5ms-beats-100",
                "content": "Wow\\uD83D\\uDE31 It\\'s the first time I beat 100%, glad to share it\\n```\\npublic String complexNumberMultiply(String a, String b) {\\n        int[] paramA = getParam(a);\\n        int[] paramB = getParam(b);\\n        int[] ans = new int[2];\\n        ans[0]=paramA[0]*paramB[0] - paramA[1]*paramB[1];\\n        ans[1]=paramA[0]*paramB[1] + paramA[1]*paramB[0];\\n        return ans[0]+\"+\"+ans[1]+\"i\";\\n    }\\n    \\n    private int[] getParam(String complexNumber){\\n        int[] param = new int[2];\\n        int plusPos = complexNumber.indexOf(\"+\");\\n        param[0]=Integer.valueOf(complexNumber.substring(0,plusPos));\\n        param[1]=Integer.valueOf(complexNumber.substring(plusPos+1,complexNumber.length()-1));\\n        return param;\\n    }\\n```\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\npublic String complexNumberMultiply(String a, String b) {\\n        int[] paramA = getParam(a);\\n        int[] paramB = getParam(b);\\n        int[] ans = new int[2];\\n        ans[0]=paramA[0]*paramB[0] - paramA[1]*paramB[1];\\n        ans[1]=paramA[0]*paramB[1] + paramA[1]*paramB[0];\\n        return ans[0]+\"+\"+ans[1]+\"i\";\\n    }\\n    \\n    private int[] getParam(String complexNumber){\\n        int[] param = new int[2];\\n        int plusPos = complexNumber.indexOf(\"+\");\\n        param[0]=Integer.valueOf(complexNumber.substring(0,plusPos));\\n        param[1]=Integer.valueOf(complexNumber.substring(plusPos+1,complexNumber.length()-1));\\n        return param;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 114068,
                "title": "c-7-lines-using-sscanf-ssprintf",
                "content": "```\\nstring complexNumberMultiply(string a, string b) {\\n    char t[200];\\n    int m, n, p, q;\\n    sscanf(a.c_str(), \"%d+%di\", &m, &n);\\n    sscanf(b.c_str(), \"%d+%di\", &p, &q);\\n    sprintf(t, \"%d+%di\", (m*p-n*q), (n*p+m*q));\\n    string ans = t;\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring complexNumberMultiply(string a, string b) {\\n    char t[200];\\n    int m, n, p, q;\\n    sscanf(a.c_str(), \"%d+%di\", &m, &n);\\n    sscanf(b.c_str(), \"%d+%di\", &p, &q);\\n    sprintf(t, \"%d+%di\", (m*p-n*q), (n*p+m*q));\\n    string ans = t;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3557916,
                "title": "image-explained-easy-java-beginner-friendly-6-line",
                "content": "![image](https://assets.leetcode.com/users/images/280c4f2e-e512-4af8-b976-a266791790fd_1684912077.0871441.jpeg)\\n\\n\\n```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        String str1[]=num1.split(\"\\\\\\\\+\");\\n        String str2[]=num2.split(\"\\\\\\\\+\");\\n\\t\\t\\n        int a=Integer.valueOf(str1[0]);    // real part of num1\\n        int b=Integer.valueOf(str1[1].replace(\"i\",\"\"));    // imaginary part of num1 after removing i from it\\n        int c=Integer.valueOf(str2[0]);                                   // real part of num2\\n        int d=Integer.valueOf(str2[1].replace(\"i\",\"\"));    // imaginary part of num1 after removing i from it\\n\\t\\t\\n         int ansreal=a*c-b*d;      // calculation for real part\\n         int ansimaginary=b*c+a*d;    // calculation for imaginary part\\n\\t\\t \\n         String ans=\"\";       \\n         ans+=ansreal+\"+\"+ansimaginary+\"i\";   // append it in result with i in imaginary part calculation\\n         return ans;\\n\\t\\t \\n\\t\\t // comment above 5 lines and return just one line below for less memory\\n       //return String.valueOf(a*c-b*d)+\"+\"+String.valueOf(b*c+a*d)+\"i\";\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        String str1[]=num1.split(\"\\\\\\\\+\");\\n        String str2[]=num2.split(\"\\\\\\\\+\");\\n\\t\\t\\n        int a=Integer.valueOf(str1[0]);    // real part of num1\\n        int b=Integer.valueOf(str1[1].replace(\"i\",\"\"));    // imaginary part of num1 after removing i from it\\n        int c=Integer.valueOf(str2[0]);                                   // real part of num2\\n        int d=Integer.valueOf(str2[1].replace(\"i\",\"\"));    // imaginary part of num1 after removing i from it\\n\\t\\t\\n         int ansreal=a*c-b*d;      // calculation for real part\\n         int ansimaginary=b*c+a*d;    // calculation for imaginary part\\n\\t\\t \\n         String ans=\"\";       \\n         ans+=ansreal+\"+\"+ansimaginary+\"i\";   // append it in result with i in imaginary part calculation\\n         return ans;\\n\\t\\t \\n\\t\\t // comment above 5 lines and return just one line below for less memory\\n       //return String.valueOf(a*c-b*d)+\"+\"+String.valueOf(b*c+a*d)+\"i\";\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509348,
                "title": "easy-solution-for-beginners",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        extract real and img part for both complex number \\n        and do the simple multiplication \\n        and finally append i and return as a string\\n\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        // extract real and img part\\n        int real1= Integer.parseInt(num1.substring(0,num1.indexOf(\\'+\\')));\\n        int img1= Integer.parseInt(num1.substring(num1.indexOf(\\'+\\')+1, num1.length()-1));\\n        //similarly extract for second com  number\\n        int real2= Integer.parseInt(num2.substring(0,num2.indexOf(\\'+\\')));\\n        int img2= Integer.parseInt(num2.substring(num2.indexOf(\\'+\\')+1, num2.length()-1));\\n\\n        int real= real1*real2-img1*img2;\\n        int img= real1*img2+real2*img1;\\n\\n        String res= real+\"+\"+img+\"i\";\\n\\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        // extract real and img part\\n        int real1= Integer.parseInt(num1.substring(0,num1.indexOf(\\'+\\')));\\n        int img1= Integer.parseInt(num1.substring(num1.indexOf(\\'+\\')+1, num1.length()-1));\\n        //similarly extract for second com  number\\n        int real2= Integer.parseInt(num2.substring(0,num2.indexOf(\\'+\\')));\\n        int img2= Integer.parseInt(num2.substring(num2.indexOf(\\'+\\')+1, num2.length()-1));\\n\\n        int real= real1*real2-img1*img2;\\n        int img= real1*img2+real2*img1;\\n\\n        String res= real+\"+\"+img+\"i\";\\n\\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205195,
                "title": "simple-javascript-solution",
                "content": "# Approach\\nUse the following identity: $$(a+bi)(c+di)=(ac\\u2212bd)+(ad+bc)i$$\\n\\n# Code\\n```\\n/**\\n * @param {string} num1\\n * @param {string} num2\\n * @return {string}\\n */\\nvar complexNumberMultiply = function (num1, num2) {\\n\\tvar a = parseInt(num1.split(\"+\")[0]);\\n\\tvar b = parseInt(num1.split(\"+\")[1].replace(\"i\", \"\"));\\n\\tvar c = parseInt(num2.split(\"+\")[0]);\\n\\tvar d = parseInt(num2.split(\"+\")[1].replace(\"i\", \"\"));\\n\\treturn `${a * c - b * d}+${a * d + b * c}i`;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num1\\n * @param {string} num2\\n * @return {string}\\n */\\nvar complexNumberMultiply = function (num1, num2) {\\n\\tvar a = parseInt(num1.split(\"+\")[0]);\\n\\tvar b = parseInt(num1.split(\"+\")[1].replace(\"i\", \"\"));\\n\\tvar c = parseInt(num2.split(\"+\")[0]);\\n\\tvar d = parseInt(num2.split(\"+\")[1].replace(\"i\", \"\"));\\n\\treturn `${a * c - b * d}+${a * d + b * c}i`;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2715516,
                "title": "c-easy-solution-faster-that-100-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  void returnParts(int8_t& realPart, int8_t& imagPart, const string& num) {\\n  uint8_t pos = num.find(\\'+\\');\\n  uint8_t ipos = num.find(\\'i\\');\\n  string str_re;\\n  string str_im;\\n  uint8_t min_pos = num.find(\\'-\\');\\n  if (min_pos == 0) {\\n    str_re = num.substr(1, pos);\\n    if (num.find(\\'-\\', min_pos + 1) == pos + 1) {\\n      str_im = num.substr(pos+2, ipos - pos - 1);\\n    }\\n    str_im = num.substr(pos+1, ipos - pos - 1);\\n  } else if (min_pos == pos + 1){\\n    str_re = num.substr(0, pos);\\n    str_im = num.substr(pos+2, ipos - pos - 1);\\n  }\\n  str_re = num.substr(0, pos);\\n  str_im = num.substr(pos+1, ipos - pos - 1);\\n  int8_t real = stoi(str_re);\\n  int8_t imaginary = stoi(str_im);\\n  realPart = real;\\n  imagPart = imaginary;\\n}\\nstring complexNumberMultiply(string num1, string num2) {\\n  int8_t real_1 = 0;\\n  int8_t imag_1 = 0;\\n  int8_t real_2 = 0;\\n  int8_t imag_2 = 0;\\n  returnParts(real_1, imag_1, num1);\\n  returnParts(real_2, imag_2, num2);\\n  int reMul = real_1 * real_2 - imag_1 * imag_2;\\n  int imMul = real_1 * imag_2 + real_2 * imag_1;\\n  string ans = to_string(reMul) + \\'+\\' + to_string(imMul) + \\'i\\';\\n  return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void returnParts(int8_t& realPart, int8_t& imagPart, const string& num) {\\n  uint8_t pos = num.find(\\'+\\');\\n  uint8_t ipos = num.find(\\'i\\');\\n  string str_re;\\n  string str_im;\\n  uint8_t min_pos = num.find(\\'-\\');\\n  if (min_pos == 0) {\\n    str_re = num.substr(1, pos);\\n    if (num.find(\\'-\\', min_pos + 1) == pos + 1) {\\n      str_im = num.substr(pos+2, ipos - pos - 1);\\n    }\\n    str_im = num.substr(pos+1, ipos - pos - 1);\\n  } else if (min_pos == pos + 1){\\n    str_re = num.substr(0, pos);\\n    str_im = num.substr(pos+2, ipos - pos - 1);\\n  }\\n  str_re = num.substr(0, pos);\\n  str_im = num.substr(pos+1, ipos - pos - 1);\\n  int8_t real = stoi(str_re);\\n  int8_t imaginary = stoi(str_im);\\n  realPart = real;\\n  imagPart = imaginary;\\n}\\nstring complexNumberMultiply(string num1, string num2) {\\n  int8_t real_1 = 0;\\n  int8_t imag_1 = 0;\\n  int8_t real_2 = 0;\\n  int8_t imag_2 = 0;\\n  returnParts(real_1, imag_1, num1);\\n  returnParts(real_2, imag_2, num2);\\n  int reMul = real_1 * real_2 - imag_1 * imag_2;\\n  int imMul = real_1 * imag_2 + real_2 * imag_1;\\n  string ans = to_string(reMul) + \\'+\\' + to_string(imMul) + \\'i\\';\\n  return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634959,
                "title": "c-0ms-solution-faster-than-100-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        \\n        string r1 , r2 , c1 , c2;\\n        \\n        int i = 0 ;\\n        while(num1[i] != \\'+\\')\\n            r1.push_back(num1[i++]);\\n        i++;\\n        \\n        while(num1[i] != \\'i\\')\\n            c1.push_back(num1[i++]);\\n        \\n        i = 0;\\n        \\n        while( num2[i] != \\'+\\')\\n            r2.push_back(num2[i++]);\\n        i++;\\n        \\n        while(num2[i] != \\'i\\')\\n            c2.push_back(num2[i++]);\\n        \\n        \\n        int x1 = stoi(r1);\\n        int x2 = stoi(r2);\\n        int y1 = stoi(c1);\\n        int y2 = stoi(c2);\\n        \\n        int ans_real = x1 * x2 - y1 * y2;\\n        int ans_img  = x1 * y2 + x2 * y1;\\n        \\n        string ans = to_string(ans_real)+ \"+\" + to_string(ans_img)+\"i\";\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        \\n        string r1 , r2 , c1 , c2;\\n        \\n        int i = 0 ;\\n        while(num1[i] != \\'+\\')\\n            r1.push_back(num1[i++]);\\n        i++;\\n        \\n        while(num1[i] != \\'i\\')\\n            c1.push_back(num1[i++]);\\n        \\n        i = 0;\\n        \\n        while( num2[i] != \\'+\\')\\n            r2.push_back(num2[i++]);\\n        i++;\\n        \\n        while(num2[i] != \\'i\\')\\n            c2.push_back(num2[i++]);\\n        \\n        \\n        int x1 = stoi(r1);\\n        int x2 = stoi(r2);\\n        int y1 = stoi(c1);\\n        int y2 = stoi(c2);\\n        \\n        int ans_real = x1 * x2 - y1 * y2;\\n        int ans_img  = x1 * y2 + x2 * y1;\\n        \\n        string ans = to_string(ans_real)+ \"+\" + to_string(ans_img)+\"i\";\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522477,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Math***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for finding the real part of a complex number\\n    \\n    int find_real(string num)\\n    {\\n        int real = 1;\\n        \\n        char sign = \\'+\\';\\n        \\n        string str = \"\";\\n        \\n        int i = 0;\\n        \\n        if(num[0] == \\'-\\')\\n        {\\n            sign = \\'-\\';\\n            \\n            i++;\\n        }\\n        \\n        while(i < num.size() && isdigit(num[i]))\\n        {\\n            str += num[i];\\n            \\n            i++;\\n        }\\n        \\n        real= stoi(str);\\n        \\n        if(sign == \\'-\\')\\n        {\\n            real = -real;\\n        }\\n        \\n        return real;\\n    }\\n    \\n    // function for finding the imaginary part of a complex number\\n    \\n    int find_img(string num)\\n    {\\n        int img = 1;\\n        \\n        char sign = \\'+\\';\\n        \\n        string str = \"\";\\n        \\n        int i = num.size() - 2;\\n        \\n        while(i >= 0 && isdigit(num[i]))\\n        {\\n            str = num[i] + str;\\n            \\n            i--;\\n        }\\n        \\n        if(num[i] == \\'-\\')\\n        {\\n            sign = \\'-\\';\\n        }\\n        \\n        img = stoi(str);\\n        \\n        if(sign == \\'-\\')\\n        {\\n            img = -img;\\n        }\\n        \\n        return img;\\n    }\\n    \\n    string complexNumberMultiply(string num1, string num2) {\\n        \\n        // find the real and img part of num1\\n        \\n        int a1 = find_real(num1);\\n        \\n        int b1 = find_img(num1);\\n        \\n        // find the real and img part of num2\\n        \\n        int a2 = find_real(num2);\\n        \\n        int b2 = find_img(num2);\\n        \\n        // find the real part after multiplication\\n        \\n        int real = (a1 * a2 - b1 * b2);\\n        \\n        // find the img part after multiplication\\n        \\n        int img = (a1 * b2 + a2 * b1);\\n        \\n        // form res\\n        \\n        string res = \"\";\\n        \\n        res += to_string(real);\\n        \\n        res += \"+\";\\n        \\n        res += to_string(img);\\n        \\n        res += \"i\";\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for finding the real part of a complex number\\n    \\n    int find_real(string num)\\n    {\\n        int real = 1;\\n        \\n        char sign = \\'+\\';\\n        \\n        string str = \"\";\\n        \\n        int i = 0;\\n        \\n        if(num[0] == \\'-\\')\\n        {\\n            sign = \\'-\\';\\n            \\n            i++;\\n        }\\n        \\n        while(i < num.size() && isdigit(num[i]))\\n        {\\n            str += num[i];\\n            \\n            i++;\\n        }\\n        \\n        real= stoi(str);\\n        \\n        if(sign == \\'-\\')\\n        {\\n            real = -real;\\n        }\\n        \\n        return real;\\n    }\\n    \\n    // function for finding the imaginary part of a complex number\\n    \\n    int find_img(string num)\\n    {\\n        int img = 1;\\n        \\n        char sign = \\'+\\';\\n        \\n        string str = \"\";\\n        \\n        int i = num.size() - 2;\\n        \\n        while(i >= 0 && isdigit(num[i]))\\n        {\\n            str = num[i] + str;\\n            \\n            i--;\\n        }\\n        \\n        if(num[i] == \\'-\\')\\n        {\\n            sign = \\'-\\';\\n        }\\n        \\n        img = stoi(str);\\n        \\n        if(sign == \\'-\\')\\n        {\\n            img = -img;\\n        }\\n        \\n        return img;\\n    }\\n    \\n    string complexNumberMultiply(string num1, string num2) {\\n        \\n        // find the real and img part of num1\\n        \\n        int a1 = find_real(num1);\\n        \\n        int b1 = find_img(num1);\\n        \\n        // find the real and img part of num2\\n        \\n        int a2 = find_real(num2);\\n        \\n        int b2 = find_img(num2);\\n        \\n        // find the real part after multiplication\\n        \\n        int real = (a1 * a2 - b1 * b2);\\n        \\n        // find the img part after multiplication\\n        \\n        int img = (a1 * b2 + a2 * b1);\\n        \\n        // form res\\n        \\n        string res = \"\";\\n        \\n        res += to_string(real);\\n        \\n        res += \"+\";\\n        \\n        res += to_string(img);\\n        \\n        res += \"i\";\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445856,
                "title": "java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        String[] one = num1.split(\"\\\\\\\\+\");\\n        String[] two = num2.split(\"\\\\\\\\+\");\\n        int a = Integer.valueOf(one[0]);\\n        int b = Integer.valueOf(one[1].replace(\"i\",\"\"));\\n        int c = Integer.valueOf(two[0]);\\n        int d = Integer.valueOf(two[1].replace(\"i\",\"\"));\\n        return String.valueOf(a*c-b*d)+\"+\"+String.valueOf(b*c+a*d)+\"i\";\\n    }\\n}\\n```\\n\\n```\\nEXPLANATION\\nEquation : (a+ib)*(c+id)\\n=>(c+id)(a+ib)\\n=>c(a+ib)+id(a+ib)\\n=>ac+i.bc+i.ad-bd           (-bd since i*i = -1)\\n\\nresult ===> (ac-bd)+i(bc+ad)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        String[] one = num1.split(\"\\\\\\\\+\");\\n        String[] two = num2.split(\"\\\\\\\\+\");\\n        int a = Integer.valueOf(one[0]);\\n        int b = Integer.valueOf(one[1].replace(\"i\",\"\"));\\n        int c = Integer.valueOf(two[0]);\\n        int d = Integer.valueOf(two[1].replace(\"i\",\"\"));\\n        return String.valueOf(a*c-b*d)+\"+\"+String.valueOf(b*c+a*d)+\"i\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155963,
                "title": "0ms-100-faster-simple-logic-c",
                "content": "let num1 = a1+ a2i;\\nand num2 = b1+b2i;\\nThe basic idea behind this question is that we get ***real part*** of ***answer string*** by multiplying (a1*b1 - a2*b2 ) ***(-negative sign because power(i,2) =-1 )***  and ***imaginary part*** by multiplying (a1*b2 + a2*b1);\\nHere is my Code:\\n\\n\\n\\t\\tstring temp;\\n        int a1=0,a2=0,b1=0,b2=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'+\\')  {a1= (!temp.empty())?stoi(temp):0; temp.clear(); continue; }\\n            if(s[i]==\\'i\\') break;\\n            temp+= s[i];\\n            \\n        }\\n        if(!temp.empty()) a2 = stoi(temp);\\n        \\n        \\n        temp.clear();\\n        for(int i=0;i<t.size();i++){\\n            if(t[i]==\\'+\\')  {\\n                b1= (!temp.empty())?stoi(temp):0;\\n                temp.clear();\\n                continue; \\n            }\\n            if(t[i]==\\'i\\') break;\\n            temp+= t[i];\\n            \\n        }\\n        if(!temp.empty()) b2 = stoi(temp);\\n        int x = a1*b1 - a2*b2;\\n        int y = a1*b2 + a2*b1;\\n        string ans;\\n        ans+= to_string(x)+ \\'+\\' + to_string(y) + \\'i\\';\\n        return ans;\\n",
                "solutionTags": [
                    "String",
                    "Iterator"
                ],
                "code": "let num1 = a1+ a2i;\\nand num2 = b1+b2i;\\nThe basic idea behind this question is that we get ***real part*** of ***answer string*** by multiplying (a1*b1 - a2*b2 ) ***(-negative sign because power(i,2) =-1 )***  and ***imaginary part*** by multiplying (a1*b2 + a2*b1);\\nHere is my Code:\\n\\n\\n\\t\\tstring temp;\\n        int a1=0,a2=0,b1=0,b2=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'+\\')  {a1= (!temp.empty())?stoi(temp):0; temp.clear(); continue; }\\n            if(s[i]==\\'i\\') break;\\n            temp+= s[i];\\n            \\n        }\\n        if(!temp.empty()) a2 = stoi(temp);\\n        \\n        \\n        temp.clear();\\n        for(int i=0;i<t.size();i++){\\n            if(t[i]==\\'+\\')  {\\n                b1= (!temp.empty())?stoi(temp):0;\\n                temp.clear();\\n                continue; \\n            }\\n            if(t[i]==\\'i\\') break;\\n            temp+= t[i];\\n            \\n        }\\n        if(!temp.empty()) b2 = stoi(temp);\\n        int x = a1*b1 - a2*b2;\\n        int y = a1*b2 + a2*b1;\\n        string ans;\\n        ans+= to_string(x)+ \\'+\\' + to_string(y) + \\'i\\';\\n        return ans;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1616556,
                "title": "c-0-ms-100-faster-easy",
                "content": "Use (a+ib)(c+id)=(ac-bd)+i(ad+bc) and use stoi function to convert string to int and to_string function for vice-versa !\\n\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n       string a,b,c,d;\\n        for(int i=0;i<num1.length();i++)\\n        {\\n            if(num1[i]!=\\'+\\')\\n                a+=num1[i];\\n            else if(num1[i]==\\'+\\')\\n            {\\n                b=num1.substr(i+1,num1.length()-2);\\n                break;\\n            }\\n        }\\n        for(int i=0;i<num2.length();i++)\\n        {\\n            if(num2[i]!=\\'+\\')\\n                c+=num2[i];\\n            else if(num2[i]==\\'+\\')\\n            {\\n                d=num2.substr(i+1,num2.length()-2);\\n                break;\\n            }\\n        }\\n        string res=to_string(stoi(a)*stoi(c)-stoi(b)*stoi(d))+ \"+\" + to_string(stoi(a)*stoi(d)+stoi(b)*stoi(c)) + \"i\";\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n       string a,b,c,d;\\n        for(int i=0;i<num1.length();i++)\\n        {\\n            if(num1[i]!=\\'+\\')\\n                a+=num1[i];\\n            else if(num1[i]==\\'+\\')\\n            {\\n                b=num1.substr(i+1,num1.length()-2);\\n                break;\\n            }\\n        }\\n        for(int i=0;i<num2.length();i++)\\n        {\\n            if(num2[i]!=\\'+\\')\\n                c+=num2[i];\\n            else if(num2[i]==\\'+\\')\\n            {\\n                d=num2.substr(i+1,num2.length()-2);\\n                break;\\n            }\\n        }\\n        string res=to_string(stoi(a)*stoi(c)-stoi(b)*stoi(d))+ \"+\" + to_string(stoi(a)*stoi(d)+stoi(b)*stoi(c)) + \"i\";\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588849,
                "title": "c-brute-force-beat-100-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        vector<int> num1vec = getNums(num1), num2vec = getNums(num2);\\n        // cout << num1vec[0] << \" \" << num1vec[1] << endl;\\n        // cout << num2vec[0] << \" \" << num2vec[1] << endl;\\n        int val1 = num1vec[0] * num2vec[0] - num1vec[1] * num2vec[1];\\n        int val2 = num1vec[0] * num2vec[1] + num1vec[1] * num2vec[0];\\n        return to_string(val1) + \"+\" + to_string(val2) + \"i\";\\n    }\\nprivate:\\n    vector<int> getNums(string s) {\\n        vector<int> res;\\n        int i = 0;\\n        res.push_back(getNum(s, i));\\n        i++;\\n        res.push_back(getNum(s, i));\\n        return res;\\n    }\\n    int getNum(string s, int& i) {\\n        int sign = 1, num = 0;\\n        if (s[i] == \\'-\\' || s[i] == \\'+\\') {\\n            sign = s[i] == \\'-\\' ? -1 : 1;\\n            i++;\\n        }\\n        while (i < s.length() && s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            num = num * 10 + (s[i] - \\'0\\');\\n            i++;\\n        }\\n        return num *= sign;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        vector<int> num1vec = getNums(num1), num2vec = getNums(num2);\\n        // cout << num1vec[0] << \" \" << num1vec[1] << endl;\\n        // cout << num2vec[0] << \" \" << num2vec[1] << endl;\\n        int val1 = num1vec[0] * num2vec[0] - num1vec[1] * num2vec[1];\\n        int val2 = num1vec[0] * num2vec[1] + num1vec[1] * num2vec[0];\\n        return to_string(val1) + \"+\" + to_string(val2) + \"i\";\\n    }\\nprivate:\\n    vector<int> getNums(string s) {\\n        vector<int> res;\\n        int i = 0;\\n        res.push_back(getNum(s, i));\\n        i++;\\n        res.push_back(getNum(s, i));\\n        return res;\\n    }\\n    int getNum(string s, int& i) {\\n        int sign = 1, num = 0;\\n        if (s[i] == \\'-\\' || s[i] == \\'+\\') {\\n            sign = s[i] == \\'-\\' ? -1 : 1;\\n            i++;\\n        }\\n        while (i < s.length() && s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            num = num * 10 + (s[i] - \\'0\\');\\n            i++;\\n        }\\n        return num *= sign;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1425330,
                "title": "not-an-easy-one-but-easy-to-understand-for-beginners-brute-force",
                "content": "**idea is to get the numerical values and multiply accordingly**\\nlittle long but easy to write.\\nsuppose two numbers be\\na+bi;\\nc+di;\\nafter mutiplication real part will be (a* c+ b * d*(-1));\\nand complex part will be (a* d+ b* c)i;\\nwe will return the answer string accordingly.\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        string a=\"\";\\n        string b=\"\";\\n        if(num1[0]==\\'-\\'){\\n            a=a+num1[0];\\n            int i=1;\\n            while(num1[i]!=\\'+\\'){\\n                a=a+num1[i];\\n                i++;\\n            }\\n            i++;\\n            if(num1[i]==\\'-\\'){\\n                b=b+num1[i];\\n                i++;\\n                while(num1[i]!=\\'i\\'){\\n                    b=b+num1[i];\\n                    i++;\\n                }\\n            }\\n            else{\\n                while(num1[i]!=\\'i\\'){\\n                    b=b+num1[i];\\n                    i++;\\n                }\\n            }\\n        }\\n        else{\\n            int i=0;\\n            while(num1[i]!=\\'+\\'){\\n                a=a+num1[i];\\n                i++;\\n            } \\n            i++;\\n            if(num1[i]==\\'-\\'){\\n                b=b+num1[i];\\n                i++;\\n                while(num1[i]!=\\'i\\'){\\n                    b=b+num1[i];\\n                    i++;\\n                }\\n            }\\n            else{\\n                while(num1[i]!=\\'i\\'){\\n                    b=b+num1[i];\\n                    i++;\\n                }\\n            }\\n        }\\n        string c=\"\";\\n        string d=\"\";\\n        if(num2[0]==\\'-\\'){\\n            c=c+num2[0];\\n            int i=1;\\n            while(num2[i]!=\\'+\\'){\\n                c=c+num2[i];\\n                i++;\\n            }\\n            i++;\\n            if(num2[i]==\\'-\\'){\\n                d=d+num2[i];\\n                i++;\\n                while(num2[i]!=\\'i\\'){\\n                    d=d+num2[i];\\n                    i++;\\n                }\\n            }\\n            else{\\n                while(num2[i]!=\\'i\\'){\\n                    d=d+num2[i];\\n                    i++;\\n                }\\n            }\\n        }\\n        else{\\n            int i=0;\\n            while(num2[i]!=\\'+\\'){\\n                c=c+num2[i];\\n                i++;\\n            }\\n            i++;\\n            if(num2[i]==\\'-\\'){\\n                d=d+num2[i];\\n                i++;\\n                while(num2[i]!=\\'i\\'){\\n                    d=d+num2[i];\\n                    i++;\\n                }\\n            }\\n            else{\\n                while(num2[i]!=\\'i\\'){\\n                    d=d+num2[i];\\n                    i++;\\n                }\\n            }\\n        }\\n        int p=(stoi(a)*stoi(c))+(stoi(b)*stoi(d))*(-1);\\n        int q=(stoi(d)*stoi(a))+(stoi(b)*stoi(c));\\n        string ans=\"\";\\n        string k=to_string(p);\\n        string l=to_string(q);\\n        ans=ans+k;\\n        ans=ans+\\'+\\';\\n        ans=ans+l;\\n        ans=ans+\\'i\\';\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        string a=\"\";\\n        string b=\"\";\\n        if(num1[0]==\\'-\\'){\\n            a=a+num1[0];\\n            int i=1;\\n            while(num1[i]!=\\'+\\'){\\n                a=a+num1[i];\\n                i++;\\n            }\\n            i++;\\n            if(num1[i]==\\'-\\'){\\n                b=b+num1[i];\\n                i++;\\n                while(num1[i]!=\\'i\\'){\\n                    b=b+num1[i];\\n                    i++;\\n                }\\n            }\\n            else{\\n                while(num1[i]!=\\'i\\'){\\n                    b=b+num1[i];\\n                    i++;\\n                }\\n            }\\n        }\\n        else{\\n            int i=0;\\n            while(num1[i]!=\\'+\\'){\\n                a=a+num1[i];\\n                i++;\\n            } \\n            i++;\\n            if(num1[i]==\\'-\\'){\\n                b=b+num1[i];\\n                i++;\\n                while(num1[i]!=\\'i\\'){\\n                    b=b+num1[i];\\n                    i++;\\n                }\\n            }\\n            else{\\n                while(num1[i]!=\\'i\\'){\\n                    b=b+num1[i];\\n                    i++;\\n                }\\n            }\\n        }\\n        string c=\"\";\\n        string d=\"\";\\n        if(num2[0]==\\'-\\'){\\n            c=c+num2[0];\\n            int i=1;\\n            while(num2[i]!=\\'+\\'){\\n                c=c+num2[i];\\n                i++;\\n            }\\n            i++;\\n            if(num2[i]==\\'-\\'){\\n                d=d+num2[i];\\n                i++;\\n                while(num2[i]!=\\'i\\'){\\n                    d=d+num2[i];\\n                    i++;\\n                }\\n            }\\n            else{\\n                while(num2[i]!=\\'i\\'){\\n                    d=d+num2[i];\\n                    i++;\\n                }\\n            }\\n        }\\n        else{\\n            int i=0;\\n            while(num2[i]!=\\'+\\'){\\n                c=c+num2[i];\\n                i++;\\n            }\\n            i++;\\n            if(num2[i]==\\'-\\'){\\n                d=d+num2[i];\\n                i++;\\n                while(num2[i]!=\\'i\\'){\\n                    d=d+num2[i];\\n                    i++;\\n                }\\n            }\\n            else{\\n                while(num2[i]!=\\'i\\'){\\n                    d=d+num2[i];\\n                    i++;\\n                }\\n            }\\n        }\\n        int p=(stoi(a)*stoi(c))+(stoi(b)*stoi(d))*(-1);\\n        int q=(stoi(d)*stoi(a))+(stoi(b)*stoi(c));\\n        string ans=\"\";\\n        string k=to_string(p);\\n        string l=to_string(q);\\n        ans=ans+k;\\n        ans=ans+\\'+\\';\\n        ans=ans+l;\\n        ans=ans+\\'i\\';\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424046,
                "title": "c-step-by-step-solution-explained-100-time-65-space",
                "content": "Nice beginner string parsing problem.\\n\\nIn order to solve it, we will declare a few support variable:\\n* `res` is our accumlator variable for the final result;\\n* `r1`, `i1`, `r2`, `i2`, `res1` and `res2` are our container for the extracted and computed real and imaginary parts.\\n\\nWe will start with a simple extraction, calling `getReal` on `n1` and `n2`.\\n\\nThis helper function will get a string `s`and declare a few support variables, all initialised to `0`/`false`:\\n* `r` and `i` will store the real and imaginary part, respectively;\\n* `j` will be our pointer while parsing the input string;\\n* `isNeg` is a boolean to keep track of the initial sign.\\n\\nWe will then:\\n* iterate while `s[j] != \\'+\\'` (which is guaranted to be there and:\\n\\t* if `s[j]` is `\\'-\\'`, we will flag `isNeg` to be `true`;\\n\\t* otherwise we will increase `r` to be `10` times its previous value plus `s[j] - \\'0\\'`;\\n\\t* increase `j` by `1`;\\n* if `isNeg` was flagged, we will flip `r`\\'s sign and reset `isNeg` to be `false`;\\n* increase `j` by `1`, to skip `\\'+\\'`;\\n* iterate while `s[j] != \\'+\\'` (which is guaranted to be there and:\\n\\t* if `s[j]` is `\\'-\\'`, we will flag `isNeg` to be `true`;\\n\\t* otherwise we will increase `i` to be `10` times its previous value plus `s[j] - \\'0\\'`;\\n\\t* increase `j` by `1`;\\n* if `isNeg` was flagged, we will flip `i`\\'s sign;\\n* `return` `r` and `i` as a pair.\\n\\nOnce we are done with the parsing part, we can store the real and imaginary part of the result into `res1` and `res2` respectively, turn them into strings and finally join them together with `\\'+\\'` and appending `\\'i\\'` to `res` before returning it. :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\n    pair<int, int> getReal(string s) {\\n        // support variables\\n        int r = 0, i = 0, j = 0;\\n        bool isNeg = false;\\n        // getting the real part\\n        while (s[j] != \\'+\\') {\\n            if (s[j] == \\'-\\') isNeg = true;\\n            else r = r * 10 + s[j] - \\'0\\';\\n            j++;\\n        }\\n        if (isNeg) r *= -1, isNeg = false;\\n        // getting the imaginary part\\n        j++;\\n        while (s[j] != \\'i\\') {\\n            if (s[j] == \\'-\\') isNeg = true;\\n            else i = i * 10 + s[j] - \\'0\\';\\n            j++;\\n        }\\n        if (isNeg) i *= -1;\\n        return {r, i};\\n    }\\npublic:\\n    string complexNumberMultiply(string n1, string n2) {\\n        // support variables\\n        string res;\\n        int r1, i1, r2, i2, res1, res2;\\n        // reading the input\\n        tie(r1, i1) = getReal(n1);\\n        tie(r2, i2) = getReal(n2);\\n        // res1 is now the real part of the result\\n        res1 = r1 * r2 - i1 * i2;\\n        // res2 is now the imaginary part of the result\\n        res2 = r1 * i2 + i1 * r2;\\n        // composing res\\n        res = to_string(res1);\\n        res.push_back(\\'+\\');\\n        res += to_string(res2);\\n        res.push_back(\\'i\\');\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\n    pair<int, int> getReal(string s) {\\n        // support variables\\n        int r = 0, i = 0, j = 0;\\n        bool isNeg = false;\\n        // getting the real part\\n        while (s[j] != \\'+\\') {\\n            if (s[j] == \\'-\\') isNeg = true;\\n            else r = r * 10 + s[j] - \\'0\\';\\n            j++;\\n        }\\n        if (isNeg) r *= -1, isNeg = false;\\n        // getting the imaginary part\\n        j++;\\n        while (s[j] != \\'i\\') {\\n            if (s[j] == \\'-\\') isNeg = true;\\n            else i = i * 10 + s[j] - \\'0\\';\\n            j++;\\n        }\\n        if (isNeg) i *= -1;\\n        return {r, i};\\n    }\\npublic:\\n    string complexNumberMultiply(string n1, string n2) {\\n        // support variables\\n        string res;\\n        int r1, i1, r2, i2, res1, res2;\\n        // reading the input\\n        tie(r1, i1) = getReal(n1);\\n        tie(r2, i2) = getReal(n2);\\n        // res1 is now the real part of the result\\n        res1 = r1 * r2 - i1 * i2;\\n        // res2 is now the imaginary part of the result\\n        res2 = r1 * i2 + i1 * r2;\\n        // composing res\\n        res = to_string(res1);\\n        res.push_back(\\'+\\');\\n        res += to_string(res2);\\n        res.push_back(\\'i\\');\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423324,
                "title": "easy-java-solution",
                "content": "\\n\\n```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n      \\n        String[] parts = num1.split(\"\\\\\\\\+\");\\n        String r1 = parts[0];\\n        String i1 = parts[1];\\n        i1 = i1.substring(0,i1.length()-1);\\n        \\n        String[] parts2 = num2.split(\"\\\\\\\\+\");\\n        String r2 = parts2[0];\\n        String i2 = parts2[1];\\n        i2 = i2.substring(0,i2.length()-1);\\n        \\n        int real = (Integer.parseInt(r1)*Integer.parseInt(r2)) - (Integer.parseInt(i1)*Integer.parseInt(i2));\\n            \\n         int imaginary = (Integer.parseInt(r1)*Integer.parseInt(i2)) + (Integer.parseInt(r2)*Integer.parseInt(i1)); \\n        \\n        String ans = \"\";\\n        ans += real;\\n        ans += \\'+\\';\\n        ans += imaginary;\\n        ans += \\'i\\';\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n      \\n        String[] parts = num1.split(\"\\\\\\\\+\");\\n        String r1 = parts[0];\\n        String i1 = parts[1];\\n        i1 = i1.substring(0,i1.length()-1);\\n        \\n        String[] parts2 = num2.split(\"\\\\\\\\+\");\\n        String r2 = parts2[0];\\n        String i2 = parts2[1];\\n        i2 = i2.substring(0,i2.length()-1);\\n        \\n        int real = (Integer.parseInt(r1)*Integer.parseInt(r2)) - (Integer.parseInt(i1)*Integer.parseInt(i2));\\n            \\n         int imaginary = (Integer.parseInt(r1)*Integer.parseInt(i2)) + (Integer.parseInt(r2)*Integer.parseInt(i1)); \\n        \\n        String ans = \"\";\\n        ans += real;\\n        ans += \\'+\\';\\n        ans += imaginary;\\n        ans += \\'i\\';\\n        \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1423070,
                "title": "c-simple-solution-0ms-100-faster",
                "content": "**class Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        \\n        string real1 = \"\" , real2 = \"\" , img1 = \"\" , img2 = \"\";\\n        int a = 0  , b = 1 , c = 1 ;\\n        \\n       // Extract the real and img part from num1 \\n        for(char j : num1){\\n            if(j != \\'+\\' && a == 0) real1 = real1 + j ;\\n            else if(j == \\'+\\')  a = 1 ;\\n            else if(j == \\'-\\' ) b = -1 ;\\n            else if(a == 1 && j != \\'i\\') img1 = img1 + j ;\\n        }\\n        a = 0 ;\\n       // Extract the real and img part from num2\\n        for(char j : num2){\\n            if(j != \\'+\\' && a == 0) real2 = real2 + j ;\\n            else if(j == \\'+\\')  a = 1 ;\\n            else if(j == \\'-\\' ) c = -1 ;\\n            else if(a == 1 && j != \\'i\\') img2 = img2 + j ;\\n        }\\n        //(a + ib) * (c + id) = (ac - bd) + (ad + cb) * i\\n        //using the above line we calculate and find the ans and convert it into a string.\\n        int a1 = stoi(real1) ; // (stoi) convert a string to an int\\n        int b1 = b * stoi(img1) ;\\n        int c1 = stoi(real2) ;\\n        int d1 = c * stoi(img2) ;\\n        string ans1 = to_string((a1 * c1) - (b1 * d1)) ;//(to_string) --> convert an int to a string\\n        string ans2 = to_string((a1 * d1) + (c1 * b1)) ;\\n        ans1 = ans1 + \\'+\\' + ans2 + \\'i\\' ;\\n        return ans1 ;\\n    }\\n};**",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        \\n        string real1 = \"\" , real2 = \"\" , img1 = \"\" , img2 = \"\";\\n        int a = 0  , b = 1 , c = 1 ;\\n        \\n       // Extract the real and img part from num1 \\n        for(char j : num1){\\n            if(j != \\'+\\' && a == 0) real1 = real1 + j ;\\n            else if(j == \\'+\\')  a = 1 ;\\n            else if(j == \\'-\\' ) b = -1 ;\\n            else if(a == 1 && j != \\'i\\') img1 = img1 + j ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1422999,
                "title": "simple-javascript-solution-explained",
                "content": "```\\n/**\\n * @param {string} num1\\n * @param {string} num2\\n * @return {string}\\n */\\nvar complexNumberMultiply = function(num1, num2) {\\n        /*\\n        Approach: By doing maths we know that\\n        (a+b)*(c+d) \\n        => ac + (ad)i + (bc)i + -(db)\\n        => ac - db + (ad+bc)i\\n        Now we just need to find a,b,c,d and then calculate ac - db + (ad+bc)i\\n        */\\n        let num1Parts=num1.split(\"+\");\\n        let num2Parts=num2.split(\"+\");\\n        let a = parseInt(num1Parts[0]);\\n        let b = parseInt(num1Parts[1]);\\n        let c = parseInt(num2Parts[0]);\\n        let d = parseInt(num2Parts[1]);\\n        let realPart = a*c - b*d;\\n        let imaginaryPart = a*d + b*c;\\n        let ans = \"\"+realPart+\"+\"+imaginaryPart+\"i\";\\n        return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num1\\n * @param {string} num2\\n * @return {string}\\n */\\nvar complexNumberMultiply = function(num1, num2) {\\n        /*\\n        Approach: By doing maths we know that\\n        (a+b)*(c+d) \\n        => ac + (ad)i + (bc)i + -(db)\\n        => ac - db + (ad+bc)i\\n        Now we just need to find a,b,c,d and then calculate ac - db + (ad+bc)i\\n        */\\n        let num1Parts=num1.split(\"+\");\\n        let num2Parts=num2.split(\"+\");\\n        let a = parseInt(num1Parts[0]);\\n        let b = parseInt(num1Parts[1]);\\n        let c = parseInt(num2Parts[0]);\\n        let d = parseInt(num2Parts[1]);\\n        let realPart = a*c - b*d;\\n        let imaginaryPart = a*d + b*c;\\n        let ans = \"\"+realPart+\"+\"+imaginaryPart+\"i\";\\n        return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1205292,
                "title": "java-memory-usage-less-than-91-19",
                "content": "Create additional class Complex to reduce memory usage.\\n```\\npublic String complexNumberMultiply(String num1, String num2) {      \\n        Complex comp1 = new Complex(num1);\\n        Complex comp2 = new Complex(num2);\\n\\n        int real = comp1.real * comp2.real - comp1.img * comp2.img;\\n        int img = comp1.real * comp2.img + comp1.img * comp2.real;\\n\\n        return real + \"+\" + img + \"i\";\\n    }\\n\\n    class Complex {\\n        int real; // the real part\\n        int img; // the imaginary part\\n\\n        public Complex(String number) {\\n            String real = number.substring(0, number.indexOf(\"+\"));\\n            String img = number.substring(number.indexOf(\"+\") + 1, number.indexOf(\"i\"));\\n\\n            this.real = Integer.valueOf(real);\\n            this.img = Integer.valueOf(img);\\n        }\\n    }\\n\\t",
                "solutionTags": [],
                "code": "Create additional class Complex to reduce memory usage.\\n```\\npublic String complexNumberMultiply(String num1, String num2) {      \\n        Complex comp1 = new Complex(num1);\\n        Complex comp2 = new Complex(num2);\\n\\n        int real = comp1.real * comp2.real - comp1.img * comp2.img;\\n        int img = comp1.real * comp2.img + comp1.img * comp2.real;\\n\\n        return real + \"+\" + img + \"i\";\\n    }\\n\\n    class Complex {\\n        int real; // the real part\\n        int img; // the imaginary part\\n\\n        public Complex(String number) {\\n            String real = number.substring(0, number.indexOf(\"+\"));\\n            String img = number.substring(number.indexOf(\"+\") + 1, number.indexOf(\"i\"));\\n\\n            this.real = Integer.valueOf(real);\\n            this.img = Integer.valueOf(img);\\n        }\\n    }\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 761500,
                "title": "java-regex-match",
                "content": "ref: https://leetcode.com/problems/complex-number-multiplication/discuss/100430/Java-3-liner\\n```\\n    public String complexNumberMultiply(String a, String b) {\\n        int[] arr = Stream.of((a + b).split(\"\\\\\\\\+|i\")).mapToInt(Integer::parseInt).toArray();\\n        return (arr[0] * arr[2] - arr[1] * arr[3]) + \"+\" + (arr[0] * arr[3] + arr[2] * arr[1]) + \"i\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String complexNumberMultiply(String a, String b) {\\n        int[] arr = Stream.of((a + b).split(\"\\\\\\\\+|i\")).mapToInt(Integer::parseInt).toArray();\\n        return (arr[0] * arr[2] - arr[1] * arr[3]) + \"+\" + (arr[0] * arr[3] + arr[2] * arr[1]) + \"i\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 667147,
                "title": "c-o-1-time-o-1-space-easy-to-understand",
                "content": "**Up-Votes are encouraging... Thanks**\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        string n1, n2, c1, c2;\\n        int i = 0;\\n        while (a[i] != \\'+\\')\\n            n1 += a[i++];\\n        c1 = a.substr(i + 1, a.size() - i - 2);\\n        i = 0;\\n        while (b[i] != \\'+\\')\\n            n2 += b[i++];\\n        c2 = b.substr(i + 1, b.size() - i - 2);\\n        int n = stoi(n1), m = stoi(n2);\\n        int c = stoi(c1), d = stoi(c2);\\n        string ans = to_string(n * m - c * d) + \"+\" + to_string(m * c + n * d) + \"i\";\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        string n1, n2, c1, c2;\\n        int i = 0;\\n        while (a[i] != \\'+\\')\\n            n1 += a[i++];\\n        c1 = a.substr(i + 1, a.size() - i - 2);\\n        i = 0;\\n        while (b[i] != \\'+\\')\\n            n2 += b[i++];\\n        c2 = b.substr(i + 1, b.size() - i - 2);\\n        int n = stoi(n1), m = stoi(n2);\\n        int c = stoi(c1), d = stoi(c2);\\n        string ans = to_string(n * m - c * d) + \"+\" + to_string(m * c + n * d) + \"i\";\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459616,
                "title": "easy-python-solution",
                "content": "\\tclass Solution(object):\\n\\t\\tdef complexNumberMultiply(self, a, b):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type a: str\\n\\t\\t\\t:type b: str\\n\\t\\t\\t:rtype: str\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\ta_re, a_im = a.split(\\'+\\')\\n\\t\\t\\tb_re, b_im = b.split(\\'+\\')\\n\\t\\t\\ta_im, b_im = a_im[:-1], b_im[:-1]\\n\\n\\t\\t\\tres_re = int(a_re)*int(b_re)-int(a_im)*int(b_im)\\n\\t\\t\\tres_im = int(a_re)*int(b_im)+int(a_im)*int(b_re)\\n\\n\\t\\t\\treturn str(res_re)+\\'+\\'+str(res_im)+\\'i\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef complexNumberMultiply(self, a, b):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type a: str\\n\\t\\t\\t:type b: str\\n\\t\\t\\t:rtype: str\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\ta_re, a_im = a.split(\\'+\\')\\n\\t\\t\\tb_re, b_im = b.split(\\'+\\')\\n\\t\\t\\ta_im, b_im = a_im[:-1], b_im[:-1]\\n\\n\\t\\t\\tres_re = int(a_re)*int(b_re)-int(a_im)*int(b_im)\\n\\t\\t\\tres_im = int(a_re)*int(b_im)+int(a_im)*int(b_re)\\n\\n\\t\\t\\treturn str(res_re)+\\'+\\'+str(res_im)+\\'i\\'",
                "codeTag": "Java"
            },
            {
                "id": 453974,
                "title": "python-3-two-lines-beats-100",
                "content": "```\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        [A1,B1,A2,B2] = map(int,(a+\\'+\\'+b).replace(\\'i\\',\\'\\').split(\\'+\\'))\\n        return str(A1*A2-B1*B2)+\\'+\\'+str(A1*B2+A2*B1)+\\'i\\'\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        [A1,B1,A2,B2] = map(int,(a+\\'+\\'+b).replace(\\'i\\',\\'\\').split(\\'+\\'))\\n        return str(A1*A2-B1*B2)+\\'+\\'+str(A1*B2+A2*B1)+\\'i\\'\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 209311,
                "title": "python-solution",
                "content": "Time complexity: `O(1)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution:\\n    def complexNumberMultiply(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: str\\n        \"\"\"\\n        ar, ai = a.split(\\'+\\')\\n        ar = int(ar)\\n        ai = int(ai[:-1])\\n        br, bi = b.split(\\'+\\')\\n        br = int(br)\\n        bi = int(bi[:-1])\\n        \\n        resr = ar*br - ai*bi\\n        resi = ar*bi + ai*br\\n        return str(resr)+\\'+\\'+str(resi)+\\'i\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def complexNumberMultiply(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: str\\n        \"\"\"\\n        ar, ai = a.split(\\'+\\')\\n        ar = int(ar)\\n        ai = int(ai[:-1])\\n        br, bi = b.split(\\'+\\')\\n        br = int(br)\\n        bi = int(bi[:-1])\\n        \\n        resr = ar*br - ai*bi\\n        resi = ar*bi + ai*br\\n        return str(resr)+\\'+\\'+str(resi)+\\'i\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183230,
                "title": "python-100-solution",
                "content": "    def complexNumberMultiply(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        aRe, aIm = a.split(\"+\")\n        aRe, aIm = int(aRe), int(aIm.split(\"i\")[0])\n        bRe, bIm = b.split(\"+\")\n        bRe, bIm = int(bRe), int(bIm.split(\"i\")[0])\n\n        resultRe = aRe * bRe - aIm * bIm\n        resultIm = aRe * bIm + bRe * aIm\n        return str(resultRe) + \"+\" + str(resultIm) + \"i\"",
                "solutionTags": [],
                "code": "    def complexNumberMultiply(self, a, b):\n        aRe, aIm = a.split(\"+\")\n        aRe, aIm = int(aRe), int(aIm.split(\"i\")[0])\n        bRe, bIm = b.split(\"+\")\n        bRe, bIm = int(bRe), int(bIm.split(\"i\")[0])\n        resultRe = aRe * bRe - aIm * bIm\n        resultIm = aRe * bIm + bRe * aIm\n        return str(resultRe) + \"+\" + str(resultIm) + \"i\"",
                "codeTag": "Python3"
            },
            {
                "id": 128916,
                "title": "javascript-solution-beats-100",
                "content": "```\\nvar complexNumberMultiply = function(a, b) {\\n    let aArray = a.split(\\'+\\')\\n    let bArray = b.split(\\'+\\')\\n    let imagNumA = aArray[1].substring(0, aArray[1].length-1)\\n    let imagNumB = bArray[1].substring(0, bArray[1].length-1)\\n    let realPart = (Number(aArray[0])*Number(bArray[0])) - (Number(imagNumA)*Number(imagNumB))\\n    let imagPart = (Number(imagNumA)*Number(bArray[0]) + Number(aArray[0])*Number(imagNumB))\\n    \\n    return `${String(realPart)}+${String(imagPart)}i`\\n};",
                "solutionTags": [],
                "code": "```\\nvar complexNumberMultiply = function(a, b) {\\n    let aArray = a.split(\\'+\\')\\n    let bArray = b.split(\\'+\\')\\n    let imagNumA = aArray[1].substring(0, aArray[1].length-1)\\n    let imagNumB = bArray[1].substring(0, bArray[1].length-1)\\n    let realPart = (Number(aArray[0])*Number(bArray[0])) - (Number(imagNumA)*Number(imagNumB))\\n    let imagPart = (Number(imagNumA)*Number(bArray[0]) + Number(aArray[0])*Number(imagNumB))\\n    \\n    return `${String(realPart)}+${String(imagPart)}i`\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 100487,
                "title": "cpp-solution-with-sscanf",
                "content": "    string complexNumberMultiply(string a, string b) {\\n        int ar, ai, br, bi; \\n        sscanf(a.c_str(),\"%d+%di\", &ar, &ai);\\n        sscanf(b.c_str(), \"%d+%di\", &br, &bi);\\n        return to_string(ar*br-ai*bi) + \"+\" + to_string(ar*bi+br*ai) + \"i\";\\n    }",
                "solutionTags": [],
                "code": "    string complexNumberMultiply(string a, string b) {\\n        int ar, ai, br, bi; \\n        sscanf(a.c_str(),\"%d+%di\", &ar, &ai);\\n        sscanf(b.c_str(), \"%d+%di\", &br, &bi);\\n        return to_string(ar*br-ai*bi) + \"+\" + to_string(ar*bi+br*ai) + \"i\";\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4010288,
                "title": "simple-clean-c-string-processing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple implementation and string processing to produce the product.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlet num1 be a+bi, num2 be c+di\\n\\n    (a +bi) * ( c+di)\\n    = (a*c-b*d) + (b*c +a*d)i\\n\\nto parse the string to integer representation, first **find the \"+\" in each number**, seperate the substring\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        string ans = \"\";\\n        int i1 = 0, i2=0;\\n\\n        int n = num1.size(),m = num2.size();\\n\\n        for(int i=0;i<n;++i){\\n            if(num1[i]==\\'+\\'){\\n                i1 = i;\\n                break;\\n            }\\n        }\\n        for(int i=0;i<m;++i){\\n            if(num2[i]==\\'+\\'){\\n                i2 = i;\\n                break;\\n            }\\n        }\\n\\n        int a,b,c,d;\\n        // parse the string\\n        a = stoi(num1.substr(0,i1));\\n        b = stoi(num1.substr(i1+1));\\n        c = stoi(num2.substr(0,i2));\\n        d = stoi(num2.substr(i2+1));\\n\\n        int real = a*c - b*d;\\n        int img = b*c+a*d;\\n\\n        ans += to_string(real);\\n        ans +=\"+\";\\n        ans += to_string(img);\\n        ans +=\"i\";\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        string ans = \"\";\\n        int i1 = 0, i2=0;\\n\\n        int n = num1.size(),m = num2.size();\\n\\n        for(int i=0;i<n;++i){\\n            if(num1[i]==\\'+\\'){\\n                i1 = i;\\n                break;\\n            }\\n        }\\n        for(int i=0;i<m;++i){\\n            if(num2[i]==\\'+\\'){\\n                i2 = i;\\n                break;\\n            }\\n        }\\n\\n        int a,b,c,d;\\n        // parse the string\\n        a = stoi(num1.substr(0,i1));\\n        b = stoi(num1.substr(i1+1));\\n        c = stoi(num2.substr(0,i2));\\n        d = stoi(num2.substr(i2+1));\\n\\n        int real = a*c - b*d;\\n        int img = b*c+a*d;\\n\\n        ans += to_string(real);\\n        ans +=\"+\";\\n        ans += to_string(img);\\n        ans +=\"i\";\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788651,
                "title": "python-solution-easy-and-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code  \\nsolution 1 - easy \\n```\\nclass Solution(object):\\n    def complexNumberMultiply(self, n1, n2):\\n        \"\"\"\\n        :type num1: str\\n        :type num2: str\\n        :rtype: str\\n        \"\"\"\\n        a1,b1=n1.split(\\'+\\')\\n        a1=int(a1)\\n        b1=int(b1[:-1])\\n        a2,b2=n2.split(\\'+\\')\\n        a2=int(a2)\\n        b2=int(b2[:-1])\\n        return str(a1*a2-b1*b2)+\\'+\\'+str(a1*b2+a2*b1)+\\'i\\'\\n```\\n\\n\\n\\nsolution 2  - when we need to make our question hard deliberately\\uD83E\\uDD23\\n```\\nclass Solution:\\n    def complexNumberMultiply(self, n1: str, n2: str) -> str:\\n        n1=n1.split(\\'+\\')\\n        n2=n2.split(\\'+\\')\\n        a=[n1[0]]\\n        b=[n2[0]]\\n        c=\\'\\'\\n        d=\\'\\'\\n        for i in n1[1]:\\n            if i==\\'i\\':\\n                break\\n            else:\\n                c+=i\\n        for i in n2[1]:\\n            if i==\\'i\\':\\n                break\\n            else:\\n                d+=i\\n        a.append(c)\\n        b.append(d)\\n        a1=int(a[0])*int(b[0])-int(a[1])*int(b[1])\\n        a2=int(a[0])*int(b[1])+int(a[1])*int(b[0])\\n        c1=str(a1)+\\'+\\'+str(a2)+\\'i\\'\\n        return c1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution(object):\\n    def complexNumberMultiply(self, n1, n2):\\n        \"\"\"\\n        :type num1: str\\n        :type num2: str\\n        :rtype: str\\n        \"\"\"\\n        a1,b1=n1.split(\\'+\\')\\n        a1=int(a1)\\n        b1=int(b1[:-1])\\n        a2,b2=n2.split(\\'+\\')\\n        a2=int(a2)\\n        b2=int(b2[:-1])\\n        return str(a1*a2-b1*b2)+\\'+\\'+str(a1*b2+a2*b1)+\\'i\\'\\n```\n```\\nclass Solution:\\n    def complexNumberMultiply(self, n1: str, n2: str) -> str:\\n        n1=n1.split(\\'+\\')\\n        n2=n2.split(\\'+\\')\\n        a=[n1[0]]\\n        b=[n2[0]]\\n        c=\\'\\'\\n        d=\\'\\'\\n        for i in n1[1]:\\n            if i==\\'i\\':\\n                break\\n            else:\\n                c+=i\\n        for i in n2[1]:\\n            if i==\\'i\\':\\n                break\\n            else:\\n                d+=i\\n        a.append(c)\\n        b.append(d)\\n        a1=int(a[0])*int(b[0])-int(a[1])*int(b[1])\\n        a2=int(a[0])*int(b[1])+int(a[1])*int(b[0])\\n        c1=str(a1)+\\'+\\'+str(a2)+\\'i\\'\\n        return c1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392694,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  string complexNumberMultiply(string a, string b) {\\n    const auto& [A, B] = getRealAndImag(a);\\n    const auto& [C, D] = getRealAndImag(b);\\n    return to_string(A * C - B * D) + \"+\" + to_string(A * D + B * C) + \"i\";\\n  }\\n private:\\n  pair<int, int> getRealAndImag(const string& s) {\\n    const string& real = s.substr(0, s.find_first_of(\\'+\\'));\\n    const string& imag = s.substr(s.find_first_of(\\'+\\') + 1);\\n    return {stoi(real), stoi(imag)};\\n  };\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        real1,imag1=map(int,num1[:-1].split(\\'+\\'))\\n        real2,imag2=map(int,num2[:-1].split(\\'+\\'))\\n        real=real1*real2-imag1*imag2\\n        imag=real1*imag2+real2*imag1\\n        return str(real)+\\'+\\'+str(imag)+\\'i\\'\\n```\\n\\n```Java []\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        StringBuilder sb=new StringBuilder();\\n        \\n        int a=Integer.parseInt(num1.substring(0,num1.indexOf(\\'+\\')));\\n        int b=Integer.parseInt(num1.substring(num1.indexOf(\\'+\\')+1,num1.indexOf(\\'i\\')));//for number a+ib\\n        \\n        int c=Integer.parseInt(num2.substring(0,num2.indexOf(\\'+\\')));\\n        int d=Integer.parseInt(num2.substring(num2.indexOf(\\'+\\')+1,num2.indexOf(\\'i\\')));//for number c+id\\n        \\n        sb.append(a*c-b*d);\\n        sb.append(\\'+\\'+\"\");\\n        sb.append(b*c+a*d);\\n        sb.append(\\'i\\');\\n        \\n        return sb.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  string complexNumberMultiply(string a, string b) {\\n    const auto& [A, B] = getRealAndImag(a);\\n    const auto& [C, D] = getRealAndImag(b);\\n    return to_string(A * C - B * D) + \"+\" + to_string(A * D + B * C) + \"i\";\\n  }\\n private:\\n  pair<int, int> getRealAndImag(const string& s) {\\n    const string& real = s.substr(0, s.find_first_of(\\'+\\'));\\n    const string& imag = s.substr(s.find_first_of(\\'+\\') + 1);\\n    return {stoi(real), stoi(imag)};\\n  };\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        real1,imag1=map(int,num1[:-1].split(\\'+\\'))\\n        real2,imag2=map(int,num2[:-1].split(\\'+\\'))\\n        real=real1*real2-imag1*imag2\\n        imag=real1*imag2+real2*imag1\\n        return str(real)+\\'+\\'+str(imag)+\\'i\\'\\n```\n```Java []\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        StringBuilder sb=new StringBuilder();\\n        \\n        int a=Integer.parseInt(num1.substring(0,num1.indexOf(\\'+\\')));\\n        int b=Integer.parseInt(num1.substring(num1.indexOf(\\'+\\')+1,num1.indexOf(\\'i\\')));//for number a+ib\\n        \\n        int c=Integer.parseInt(num2.substring(0,num2.indexOf(\\'+\\')));\\n        int d=Integer.parseInt(num2.substring(num2.indexOf(\\'+\\')+1,num2.indexOf(\\'i\\')));//for number c+id\\n        \\n        sb.append(a*c-b*d);\\n        sb.append(\\'+\\'+\"\");\\n        sb.append(b*c+a*d);\\n        sb.append(\\'i\\');\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365452,
                "title": "simple-c-solution-basic-maths",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        auto it1=num1.find(\\'+\\');\\n        auto it2=num2.find(\\'+\\');\\n        auto it3=num1.find(\\'i\\');\\n        auto it4=num2.find(\\'i\\');\\n        int real1=stoi(num1.substr(0,it1));\\n        int real2=stoi(num2.substr(0,it2));\\n        int img1=stoi(num1.substr(it1+1,it3));\\n        int img2=stoi(num2.substr(it2+1,it4));\\n        int rtotal=(real1*real2+(-1*(img1*img2)));\\n        int imgtotal=real1*img2+real2*img1;\\n        string ans=\"\";\\n        ans+=to_string(rtotal)+\"+\"+to_string(imgtotal)+\"i\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        auto it1=num1.find(\\'+\\');\\n        auto it2=num2.find(\\'+\\');\\n        auto it3=num1.find(\\'i\\');\\n        auto it4=num2.find(\\'i\\');\\n        int real1=stoi(num1.substr(0,it1));\\n        int real2=stoi(num2.substr(0,it2));\\n        int img1=stoi(num1.substr(it1+1,it3));\\n        int img2=stoi(num2.substr(it2+1,it4));\\n        int rtotal=(real1*real2+(-1*(img1*img2)));\\n        int imgtotal=real1*img2+real2*img1;\\n        string ans=\"\";\\n        ans+=to_string(rtotal)+\"+\"+to_string(imgtotal)+\"i\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276277,
                "title": "python-splitting-the-number",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        x1,x2 = int(num1.split(\"+\")[0]),int(num2.split(\"+\")[0])\\n        y1,y2 = int(num1.split(\"+\")[1][:-1]),int(num2.split(\"+\")[1][:-1])\\n    \\n        sayi = (x1*x2) - (y1*y2)\\n        i = (x1*y2) + (x2*y1)\\n        \\n        return str(sayi) + \"+\" + str(i) + \"i\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        x1,x2 = int(num1.split(\"+\")[0]),int(num2.split(\"+\")[0])\\n        y1,y2 = int(num1.split(\"+\")[1][:-1]),int(num2.split(\"+\")[1][:-1])\\n    \\n        sayi = (x1*x2) - (y1*y2)\\n        i = (x1*y2) + (x2*y1)\\n        \\n        return str(sayi) + \"+\" + str(i) + \"i\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025072,
                "title": "easy-c-solution-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    pair<string,string> complexNos(string s){\\n        int i=0; \\n        while(s[i]!=\\'+\\'){\\n            i++;\\n        }\\n        string x=s.substr(0, i);\\n        string y=s.substr(i+1,s.length()-i-2);\\n        pair<string,string> p=make_pair(x,y);\\n        return p;\\n    }\\n\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        pair<string, string> x,y;\\n        x=complexNos(num1);\\n        y=complexNos(num2);\\n        int a=stoi(x.first);\\n        int b=stoi(x.second);\\n        int c=stoi(y.first);\\n        int d=stoi(y.second);\\n        int p=(a*c)-(b*d);\\n        int q=(a*d)+(b*c);\\n\\n        string s=to_string(p)+\"+\"+to_string(q)+\"i\";\\n        return s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    pair<string,string> complexNos(string s){\\n        int i=0; \\n        while(s[i]!=\\'+\\'){\\n            i++;\\n        }\\n        string x=s.substr(0, i);\\n        string y=s.substr(i+1,s.length()-i-2);\\n        pair<string,string> p=make_pair(x,y);\\n        return p;\\n    }\\n\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        pair<string, string> x,y;\\n        x=complexNos(num1);\\n        y=complexNos(num2);\\n        int a=stoi(x.first);\\n        int b=stoi(x.second);\\n        int c=stoi(y.first);\\n        int d=stoi(y.second);\\n        int p=(a*c)-(b*d);\\n        int q=(a*d)+(b*c);\\n\\n        string s=to_string(p)+\"+\"+to_string(q)+\"i\";\\n        return s;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839454,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string s, string t) {\\n        int a=0,b=0,x=0,y=0;\\n        int idx=0;\\n        bool isneg=false;\\n        while(s[idx]!=\\'+\\')\\n        {\\n            if(s[idx]==\\'-\\')\\n            {\\n                isneg=true;\\n            }\\n            else if(s[idx]>=\\'0\\' and s[idx]<=\\'9\\')\\n            {\\n                int n=s[idx]-\\'0\\';\\n                a=a*10+n;\\n            }\\n            idx++;\\n        }\\n        if(isneg==true)\\n        {\\n            a=a*(-1);\\n        }\\n        isneg=false;\\n        idx++;\\n        while(idx<s.length())\\n        {\\n            if(s[idx]==\\'-\\')\\n            {\\n                isneg=true;\\n            }\\n            else if(s[idx]>=\\'0\\' and s[idx]<=\\'9\\')\\n            {\\n                int n=s[idx]-\\'0\\';\\n                b=b*10+n;\\n            }\\n            idx++;\\n        }\\n        if(isneg==true)\\n        {\\n            b=b*-1;\\n        }\\n        isneg=false;\\n        idx=0;\\n        while(t[idx]!=\\'+\\')\\n        {\\n            if(t[idx]==\\'-\\')\\n            {\\n                isneg=true;\\n            }\\n            else if(t[idx]>=\\'0\\' and t[idx]<=\\'9\\')\\n            {\\n                int n=t[idx]-\\'0\\';\\n                x=x*10+n;\\n            }\\n            idx++;\\n        }\\n        if(isneg==true)\\n        {\\n            x=x*(-1);\\n        }\\n        isneg=false;\\n        idx++;\\n        while(idx<t.length())\\n        {\\n            if(t[idx]==\\'-\\')\\n            {\\n                isneg=true;\\n            }\\n            else if(t[idx]>=\\'0\\' and t[idx]<=\\'9\\')\\n            {\\n                int n=t[idx]-\\'0\\';\\n                y=y*10+n;\\n            }\\n            idx++;\\n        }\\n        if(isneg==true)\\n        {\\n            y=y*-1;\\n        }\\n        int c=(a*x)-(b*y);\\n        int d=(a*y)+(b*x);\\n        string ans=\"\";\\n        ans.append(to_string(c));\\n        ans.push_back(\\'+\\');\\n        ans.append(to_string(d));\\n        ans.push_back(\\'i\\');\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string s, string t) {\\n        int a=0,b=0,x=0,y=0;\\n        int idx=0;\\n        bool isneg=false;\\n        while(s[idx]!=\\'+\\')\\n        {\\n            if(s[idx]==\\'-\\')\\n            {\\n                isneg=true;\\n            }\\n            else if(s[idx]>=\\'0\\' and s[idx]<=\\'9\\')\\n            {\\n                int n=s[idx]-\\'0\\';\\n                a=a*10+n;\\n            }\\n            idx++;\\n        }\\n        if(isneg==true)\\n        {\\n            a=a*(-1);\\n        }\\n        isneg=false;\\n        idx++;\\n        while(idx<s.length())\\n        {\\n            if(s[idx]==\\'-\\')\\n            {\\n                isneg=true;\\n            }\\n            else if(s[idx]>=\\'0\\' and s[idx]<=\\'9\\')\\n            {\\n                int n=s[idx]-\\'0\\';\\n                b=b*10+n;\\n            }\\n            idx++;\\n        }\\n        if(isneg==true)\\n        {\\n            b=b*-1;\\n        }\\n        isneg=false;\\n        idx=0;\\n        while(t[idx]!=\\'+\\')\\n        {\\n            if(t[idx]==\\'-\\')\\n            {\\n                isneg=true;\\n            }\\n            else if(t[idx]>=\\'0\\' and t[idx]<=\\'9\\')\\n            {\\n                int n=t[idx]-\\'0\\';\\n                x=x*10+n;\\n            }\\n            idx++;\\n        }\\n        if(isneg==true)\\n        {\\n            x=x*(-1);\\n        }\\n        isneg=false;\\n        idx++;\\n        while(idx<t.length())\\n        {\\n            if(t[idx]==\\'-\\')\\n            {\\n                isneg=true;\\n            }\\n            else if(t[idx]>=\\'0\\' and t[idx]<=\\'9\\')\\n            {\\n                int n=t[idx]-\\'0\\';\\n                y=y*10+n;\\n            }\\n            idx++;\\n        }\\n        if(isneg==true)\\n        {\\n            y=y*-1;\\n        }\\n        int c=(a*x)-(b*y);\\n        int d=(a*y)+(b*x);\\n        string ans=\"\";\\n        ans.append(to_string(c));\\n        ans.push_back(\\'+\\');\\n        ans.append(to_string(d));\\n        ans.push_back(\\'i\\');\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555075,
                "title": "c-0ms-stringstream",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        stringstream ss(num1) ;\\n        string str = \"\" ;\\n        \\n        int a = INT_MAX , b = INT_MAX , c = INT_MAX,  d = INT_MAX ;\\n        while(getline(ss,str,\\'+\\')){\\n            if(a == INT_MAX) a = stoi(str) ;\\n            else if(b == INT_MAX){\\n                str.pop_back() ;\\n                bool neg = false ;\\n                if(str[0] == \\'-\\') neg = true , str.erase(begin(str)) ;\\n                b = stoi(str) ;\\n                b *= neg ? -1 : 1 ;\\n            }\\n        }\\n        \\n        ss.clear() ;\\n        ss = stringstream(num2) ;\\n        \\n        while(getline(ss,str,\\'+\\')){\\n            if(c == INT_MAX) c = stoi(str) ;\\n            else if(d == INT_MAX){\\n                str.pop_back() ;\\n                bool neg = false ;\\n                if(str[0] == \\'-\\') neg = true , str.erase(begin(str)) ;\\n                d = stoi(str) ;\\n                d *= neg ? -1 : 1 ;\\n            }\\n        }\\n        \\n        int A = a*c - b*d ;\\n        int B = a*d + b*c ;\\n        \\n        return to_string(A) + \"+\" + to_string(B) + \"i\" ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        stringstream ss(num1) ;\\n        string str = \"\" ;\\n        \\n        int a = INT_MAX , b = INT_MAX , c = INT_MAX,  d = INT_MAX ;\\n        while(getline(ss,str,\\'+\\')){\\n            if(a == INT_MAX) a = stoi(str) ;\\n            else if(b == INT_MAX){\\n                str.pop_back() ;\\n                bool neg = false ;\\n                if(str[0] == \\'-\\') neg = true , str.erase(begin(str)) ;\\n                b = stoi(str) ;\\n                b *= neg ? -1 : 1 ;\\n            }\\n        }\\n        \\n        ss.clear() ;\\n        ss = stringstream(num2) ;\\n        \\n        while(getline(ss,str,\\'+\\')){\\n            if(c == INT_MAX) c = stoi(str) ;\\n            else if(d == INT_MAX){\\n                str.pop_back() ;\\n                bool neg = false ;\\n                if(str[0] == \\'-\\') neg = true , str.erase(begin(str)) ;\\n                d = stoi(str) ;\\n                d *= neg ? -1 : 1 ;\\n            }\\n        }\\n        \\n        int A = a*c - b*d ;\\n        int B = a*d + b*c ;\\n        \\n        return to_string(A) + \"+\" + to_string(B) + \"i\" ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416983,
                "title": "c-0ms-100-faster-very-easy-approach-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        int real1, real2, img1, img2;\\n        string s;\\n        real1 = stoi(num1);             // Stores number before \\'+\\'. i.e. real part\\n        real2 = stoi(num2);\\n        \\n        while(num1[0] != \\'+\\') {         // Erases the real part in the string num1\\n            num1.erase(0, 1);\\n        }\\n        num1.erase(0, 1);\\n        img1 = stoi(num1);              // Stores number after \\'+\\'. i.e. imaginary part\\n        \\n        while(num2[0] != \\'+\\') {         // Erases the real part in the string num2\\n            num2.erase(0, 1);\\n        }\\n        num2.erase(0, 1);\\n        img2 = stoi(num2);              // Stores number after \\'+\\'. i.e. imaginary part\\n        \\n        int real = (real1*real2)+(-1*(img1*img2));      // Apply the multiplication formula\\n        int img = (real1*img2)+(real2*img1);\\n        \\n        s += to_string(real);           // Convert the answer to string\\n        s += \\'+\\';\\n        s += to_string(img);\\n        s += \\'i\\';\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        int real1, real2, img1, img2;\\n        string s;\\n        real1 = stoi(num1);             // Stores number before \\'+\\'. i.e. real part\\n        real2 = stoi(num2);\\n        \\n        while(num1[0] != \\'+\\') {         // Erases the real part in the string num1\\n            num1.erase(0, 1);\\n        }\\n        num1.erase(0, 1);\\n        img1 = stoi(num1);              // Stores number after \\'+\\'. i.e. imaginary part\\n        \\n        while(num2[0] != \\'+\\') {         // Erases the real part in the string num2\\n            num2.erase(0, 1);\\n        }\\n        num2.erase(0, 1);\\n        img2 = stoi(num2);              // Stores number after \\'+\\'. i.e. imaginary part\\n        \\n        int real = (real1*real2)+(-1*(img1*img2));      // Apply the multiplication formula\\n        int img = (real1*img2)+(real2*img1);\\n        \\n        s += to_string(real);           // Convert the answer to string\\n        s += \\'+\\';\\n        s += to_string(img);\\n        s += \\'i\\';\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2367905,
                "title": "easy-brute-force-approach-c-runtime-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        string a=\"\",b=\"\",c=\"\",d=\"\";\\n        int i=0;\\n        while(num1[i]!=\\'+\\')\\n        {\\n            a+=num1[i];\\n            i++;\\n        }\\n        i++;\\n        while(num1[i]!=\\'i\\')\\n        {\\n            b+=num1[i];\\n            i++;\\n        }\\n        int j=0;\\n        while(num2[j]!=\\'+\\')\\n        {\\n            c+=num2[j];\\n            j++;\\n        }\\n        j++;\\n        while(num2[j]!=\\'i\\')\\n        {\\n            d+=num2[j];\\n            j++;\\n        }\\n        int p=stoi(a);\\n        int q=stoi(b);\\n        int r=stoi(c);\\n        int s=stoi(d);\\n        int x=p*r-q*s;\\n        int y=p*s+q*r;\\n        return to_string(x)+\"+\"+to_string(y)+\"i\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        string a=\"\",b=\"\",c=\"\",d=\"\";\\n        int i=0;\\n        while(num1[i]!=\\'+\\')\\n        {\\n            a+=num1[i];\\n            i++;\\n        }\\n        i++;\\n        while(num1[i]!=\\'i\\')\\n        {\\n            b+=num1[i];\\n            i++;\\n        }\\n        int j=0;\\n        while(num2[j]!=\\'+\\')\\n        {\\n            c+=num2[j];\\n            j++;\\n        }\\n        j++;\\n        while(num2[j]!=\\'i\\')\\n        {\\n            d+=num2[j];\\n            j++;\\n        }\\n        int p=stoi(a);\\n        int q=stoi(b);\\n        int r=stoi(c);\\n        int s=stoi(d);\\n        int x=p*r-q*s;\\n        int y=p*s+q*r;\\n        return to_string(x)+\"+\"+to_string(y)+\"i\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2341379,
                "title": "java-easiest-solution-liner-approach-constant-space-complexity-7ms-runtime",
                "content": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        int val1 = Integer.parseInt(num1.substring(0, num1.indexOf(\\'+\\')));\\n        int val2 = Integer.parseInt(num1.substring(num1.indexOf(\\'+\\')+1,num1.length()-1));\\n        int val3 = Integer.parseInt(num2.substring(0, num2.indexOf(\\'+\\')));\\n        int val4 = Integer.parseInt(num2.substring(num2.indexOf(\\'+\\')+1,num2.length()-1));\\n        \\n        return \"\" + (val1*val3 - val2*val4) + \"+\" + (val1*val4 + val3*val2) + \"i\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        int val1 = Integer.parseInt(num1.substring(0, num1.indexOf(\\'+\\')));\\n        int val2 = Integer.parseInt(num1.substring(num1.indexOf(\\'+\\')+1,num1.length()-1));\\n        int val3 = Integer.parseInt(num2.substring(0, num2.indexOf(\\'+\\')));\\n        int val4 = Integer.parseInt(num2.substring(num2.indexOf(\\'+\\')+1,num2.length()-1));\\n        \\n        return \"\" + (val1*val3 - val2*val4) + \"+\" + (val1*val4 + val3*val2) + \"i\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340363,
                "title": "c-stringstream",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        \\n        string real1=\"\",im1=\"\",real2=\"\",im2=\"\";\\n        stringstream ss(num1);\\n        \\n        getline(ss,real1,\\'+\\');\\n        getline(ss,im1,\\'+\\');\\n        \\n        stringstream ss2(num2);\\n        \\n        getline(ss2,real2,\\'+\\');\\n        getline(ss2,im2,\\'+\\');\\n        \\n        im1.pop_back();\\n        im2.pop_back();\\n        \\n        int a1=stoi(real1);\\n        int b1=stoi(im1);\\n        int a2=stoi(real2);\\n        int b2=stoi(im2);\\n        \\n        int r=(a1*a2)-(b1*b2);\\n        int img=(a1*b2)+(a2*b1);\\n        \\n        \\n        return to_string(r)+\"+\"+to_string(img)+\"i\";\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        \\n        string real1=\"\",im1=\"\",real2=\"\",im2=\"\";\\n        stringstream ss(num1);\\n        \\n        getline(ss,real1,\\'+\\');\\n        getline(ss,im1,\\'+\\');\\n        \\n        stringstream ss2(num2);\\n        \\n        getline(ss2,real2,\\'+\\');\\n        getline(ss2,im2,\\'+\\');\\n        \\n        im1.pop_back();\\n        im2.pop_back();\\n        \\n        int a1=stoi(real1);\\n        int b1=stoi(im1);\\n        int a2=stoi(real2);\\n        int b2=stoi(im2);\\n        \\n        int r=(a1*a2)-(b1*b2);\\n        int img=(a1*b2)+(a2*b1);\\n        \\n        \\n        return to_string(r)+\"+\"+to_string(img)+\"i\";\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2328572,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n\\n        \\n        \\n         vector<int> stringToInt(string num1){\\nvector<int> v;\\n                string real1=\"\",real2=\"\";\\n        string img1=\"\",img2=\"\";\\n        int index=0;\\n        for(int i=0;i<num1.length();i++){\\n            if(num1[i]==\\'+\\' && i!=0 && num1[i+1]==\\'-\\'){\\n                index=i+1;\\n                break;\\n            }\\n            else if(num1[i]==\\'+\\' && i!=0 && num1[i+1]!=\\'-\\'){\\n                index=i;\\n                break;\\n            }\\n            real1=real1+num1[i];\\n        }\\n        if(num1[0]==\\'+\\' && num1[1]==\\'-\\'){\\n            real1=\"-\"+real1;\\n        }\\n        img1=num1.substr(index,num1.length());\\n         int a=stoi(real1);\\n        int b=stoi(img1);\\n        v.push_back(a);\\n        v.push_back(b);\\n        return v;\\n    }\\n    string complexNumberMultiply(string num1, string num2) {\\n\\n      vector<int> v1,v2;\\n        v1=stringToInt(num1);\\n        v2=stringToInt(num2);\\n        int real=(v1[0]*v2[0])-(v1[1]*v2[1]);\\n        int img=(v1[0]*v2[1])+(v1[1]*v2[0]);\\n        \\n        string output=\"\"+to_string(real)+\"+\"+to_string(img)+\"i\";\\n        return output;\\n        \\n    }\\n    \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n        \\n        \\n         vector<int> stringToInt(string num1){\\nvector<int> v;\\n                string real1=\"\",real2=\"\";\\n        string img1=\"\",img2=\"\";\\n        int index=0;\\n        for(int i=0;i<num1.length();i++){\\n            if(num1[i]==\\'+\\' && i!=0 && num1[i+1]==\\'-\\'){\\n                index=i+1;\\n                break;\\n            }\\n            else if(num1[i]==\\'+\\' && i!=0 && num1[i+1]!=\\'-\\'){\\n                index=i;\\n                break;\\n            }\\n            real1=real1+num1[i];\\n        }\\n        if(num1[0]==\\'+\\' && num1[1]==\\'-\\'){\\n            real1=\"-\"+real1;\\n        }\\n        img1=num1.substr(index,num1.length());\\n         int a=stoi(real1);\\n        int b=stoi(img1);\\n        v.push_back(a);\\n        v.push_back(b);\\n        return v;\\n    }\\n    string complexNumberMultiply(string num1, string num2) {\\n\\n      vector<int> v1,v2;\\n        v1=stringToInt(num1);\\n        v2=stringToInt(num2);\\n        int real=(v1[0]*v2[0])-(v1[1]*v2[1]);\\n        int img=(v1[0]*v2[1])+(v1[1]*v2[0]);\\n        \\n        string output=\"\"+to_string(real)+\"+\"+to_string(img)+\"i\";\\n        return output;\\n        \\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321957,
                "title": "python-6-liner-simple-math-string",
                "content": "```python\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        a1, b1 = num1[:-1].split(\"+\")\\n        a2, b2 = num2[:-1].split(\"+\")\\n        a1, b1, a2, b2 = int(a1), int(b1), int(a2), int(b2)\\n        real = a1*a2-b1*b2\\n        imaginary = a1*b2+a2*b1\\n        return str(real)+\"+\"+str(imaginary)+\"i\"\\n```\\n\\nPlease commnet below if you have any further questions and **UPVOTE** if you like it!\\nAll the solutions that I\\'ve been through are archived here: https://github.com/hyeseonko/LeetCode",
                "solutionTags": [
                    "Python",
                    "Math",
                    "String"
                ],
                "code": "```python\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        a1, b1 = num1[:-1].split(\"+\")\\n        a2, b2 = num2[:-1].split(\"+\")\\n        a1, b1, a2, b2 = int(a1), int(b1), int(a2), int(b2)\\n        real = a1*a2-b1*b2\\n        imaginary = a1*b2+a2*b1\\n        return str(real)+\"+\"+str(imaginary)+\"i\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214413,
                "title": "simple-solution-using-maths-c",
                "content": "```\\nclass Solution {\\npublic:\\n    // function to get imaginary part from string \\n    int imaginary(string s){\\n        string k=\"\";int i=0;\\n        while(s[i]!=\\'+\\')\\n            i++;\\n        i++;\\n        while(s[i]!=\\'i\\')\\n            k+=s[i++];\\n        int num=stoi(k);\\n         return num;\\n    }\\n    // function to get real part of string\\n    int real(string s){\\n        int i=0;string k=\"\";\\n        while(s[i]!=\\'+\\')\\n        k+=s[i++];\\n        int num=stoi(k);\\n        return num;\\n    }\\n    string complexNumberMultiply(string num1, string num2) {\\n         int a1=real(num1),a2=real(num2),b1=imaginary(num1),b2=imaginary(num2);\\n         int r= (a1*a2-(b1*b2));// real part of answer string\\n        int i=((b1*a2)+(a1*b2)); // imaginary part of answer string\\n        string ans=\"\";\\n        ans+=to_string(r)+\\'+\\'+to_string(i)+\\'i\\'; \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // function to get imaginary part from string \\n    int imaginary(string s){\\n        string k=\"\";int i=0;\\n        while(s[i]!=\\'+\\')\\n            i++;\\n        i++;\\n        while(s[i]!=\\'i\\')\\n            k+=s[i++];\\n        int num=stoi(k);\\n         return num;\\n    }\\n    // function to get real part of string\\n    int real(string s){\\n        int i=0;string k=\"\";\\n        while(s[i]!=\\'+\\')\\n        k+=s[i++];\\n        int num=stoi(k);\\n        return num;\\n    }\\n    string complexNumberMultiply(string num1, string num2) {\\n         int a1=real(num1),a2=real(num2),b1=imaginary(num1),b2=imaginary(num2);\\n         int r= (a1*a2-(b1*b2));// real part of answer string\\n        int i=((b1*a2)+(a1*b2)); // imaginary part of answer string\\n        string ans=\"\";\\n        ans+=to_string(r)+\\'+\\'+to_string(i)+\\'i\\'; \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116782,
                "title": "easy-c-solutions-0-ms",
                "content": "![image](https://assets.leetcode.com/users/images/a40504bf-3f0b-4b09-9279-a754e542db27_1654491212.192629.png)\\n```\\nclass Solution {\\n    void split_re_im(string& s, int& re, int& im){\\n        int l = s.length();\\n        int i=0;\\n        string t1 = \"\", t2 = \"\";\\n        while(i<l && s[i] != \\'+\\'){\\n            t1 += s[i];\\n            ++i;\\n        }\\n        ++i;\\n        re = stoi(t1);\\n        while(i<l && s[i] != \\'i\\'){\\n            t2 += s[i];\\n            ++i;\\n        }\\n        im = stoi(t2);\\n    }\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        int re1, im1, re2, im2, re, im;\\n        split_re_im(num1,re1,im1);\\n        split_re_im(num2,re2,im2);\\n        re = (re1*re2-im1*im2);\\n        im = (re1*im2+im1*re2);\\n        string s1,s2,s=\"\";\\n        s1 = to_string(re);\\n        s2 = to_string(im);\\n        s  = s1 + \\'+\\'+ s2 + \\'i\\';\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void split_re_im(string& s, int& re, int& im){\\n        int l = s.length();\\n        int i=0;\\n        string t1 = \"\", t2 = \"\";\\n        while(i<l && s[i] != \\'+\\'){\\n            t1 += s[i];\\n            ++i;\\n        }\\n        ++i;\\n        re = stoi(t1);\\n        while(i<l && s[i] != \\'i\\'){\\n            t2 += s[i];\\n            ++i;\\n        }\\n        im = stoi(t2);\\n    }\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        int re1, im1, re2, im2, re, im;\\n        split_re_im(num1,re1,im1);\\n        split_re_im(num2,re2,im2);\\n        re = (re1*re2-im1*im2);\\n        im = (re1*im2+im1*re2);\\n        string s1,s2,s=\"\";\\n        s1 = to_string(re);\\n        s2 = to_string(im);\\n        s  = s1 + \\'+\\'+ s2 + \\'i\\';\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971330,
                "title": "c-beats-100-0ms-easy-using-stringstream-and-getline",
                "content": "class Solution {\\npublic:\\n    \\n    string complexNumberMultiply(string num1, string num2) {\\n        stringstream ss1(num1), ss2(num2);\\n        string s;\\n        int a,b, x,y, ans;\\n        \\n        getline(ss1, s, \\'+\\'); a = stoi(s);\\n        getline(ss1, s, \\'i\\'); b = stoi(s);\\n        \\n        getline(ss2, s, \\'+\\'); x = stoi(s);\\n        getline(ss2, s, \\'i\\'); y = stoi(s);\\n        \\n        s=\"\";\\n        ans = a*x - b*y;\\n        s += to_string(ans);\\n        ans = a*y + b*x;\\n        s += \"+\" + to_string(ans) + \"i\";\\n        return s;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    string complexNumberMultiply(string num1, string num2) {\\n        stringstream ss1(num1), ss2(num2);\\n        string s;\\n        int a,b, x,y, ans;\\n        \\n        getline(ss1, s, \\'+\\'); a = stoi(s);\\n        getline(ss1, s, \\'i\\'); b = stoi(s);\\n        \\n        getline(ss2, s, \\'+\\'); x = stoi(s);\\n        getline(ss2, s, \\'i\\'); y = stoi(s);\\n        \\n        s=\"\";\\n        ans = a*x - b*y;\\n        s += to_string(ans);\\n        ans = a*y + b*x;\\n        s += \"+\" + to_string(ans) + \"i\";\\n        return s;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1881489,
                "title": "easy-string-stream-solution-c-0-ms-faster-than-100-00",
                "content": "Self explainatory easy C++ solution\\n\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        // strings to extract real and img parts\\n        string real1, img1, real2, img2;\\n        // ints to store integer values of real and img parts\\n        int r1, i1, r2, i2;\\n        int len1 = 0, len2 = 0;\\n        \\n        //extracting real part from num1\\n        while(num1[len1] != \\'+\\'){\\n            real1 += num1[len1];\\n            len1++;\\n        }\\n        \\n        len1++;\\n        \\n        //extracting img part from num1\\n        while(num1[len1] != \\'i\\'){\\n            img1 += num1[len1];\\n            len1++;\\n        }\\n        \\n        //extracting real part from num2\\n        while(num2[len2] != \\'+\\'){\\n            real2 += num2[len2];\\n            len2++;\\n        }\\n        \\n        len2++;\\n        \\n        //extracting img part from num2\\n        while(num2[len2] != \\'i\\'){\\n            img2 += num2[len2];\\n            len2++;\\n        }\\n        \\n        // converting strings of real and img parts to int\\n        // for multiplication purpose using stringstream\\n        stringstream s1, s2, s3, s4;\\n        s1<<real1;\\n        s1>>r1;\\n        s2<<img1;\\n        s2>>i1;\\n        s3<<real2;\\n        s3>>r2;\\n        s4<<img2;\\n        s4>>i2;\\n        \\n        // returning the resultant multiplication\\n        return to_string(r1*r2 - i1*i2) + \\'+\\' + to_string(r1*i2 + i1*r2) + \\'i\\';\\n        \\n    }\\n};\\n```\\n\\nPlease consider upvoting if found helpful.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        // strings to extract real and img parts\\n        string real1, img1, real2, img2;\\n        // ints to store integer values of real and img parts\\n        int r1, i1, r2, i2;\\n        int len1 = 0, len2 = 0;\\n        \\n        //extracting real part from num1\\n        while(num1[len1] != \\'+\\'){\\n            real1 += num1[len1];\\n            len1++;\\n        }\\n        \\n        len1++;\\n        \\n        //extracting img part from num1\\n        while(num1[len1] != \\'i\\'){\\n            img1 += num1[len1];\\n            len1++;\\n        }\\n        \\n        //extracting real part from num2\\n        while(num2[len2] != \\'+\\'){\\n            real2 += num2[len2];\\n            len2++;\\n        }\\n        \\n        len2++;\\n        \\n        //extracting img part from num2\\n        while(num2[len2] != \\'i\\'){\\n            img2 += num2[len2];\\n            len2++;\\n        }\\n        \\n        // converting strings of real and img parts to int\\n        // for multiplication purpose using stringstream\\n        stringstream s1, s2, s3, s4;\\n        s1<<real1;\\n        s1>>r1;\\n        s2<<img1;\\n        s2>>i1;\\n        s3<<real2;\\n        s3>>r2;\\n        s4<<img2;\\n        s4>>i2;\\n        \\n        // returning the resultant multiplication\\n        return to_string(r1*r2 - i1*i2) + \\'+\\' + to_string(r1*i2 + i1*r2) + \\'i\\';\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850398,
                "title": "c-100-fast-lengthy-but-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        num1+=\\'+\\';\\n        num2+=\\'+\\';\\n        int x1,x2,y1,y2,resx,resy;\\n        string temp=\"\";\\n        for(int i=0,j=0;i<num1.size();i++){\\n            if(num1[i]==\\'+\\' && j==0){\\n                x1=stoi(temp);\\n                temp=\"\";\\n                j++;\\n            }else if(num1[i]==\\'+\\' && j==1){\\n                y1=stoi(temp);\\n                temp=\"\";\\n                break;\\n            }else{\\n                temp+=num1[i];\\n            }\\n        }\\n        for(int i=0,j=0;i<num2.size();i++){\\n            if(num2[i]==\\'+\\' && j==0){\\n                x2=stoi(temp);\\n                temp=\"\";\\n                j++;\\n            }else if(num2[i]==\\'+\\' && j==1){\\n                y2=stoi(temp);\\n                temp=\"\";\\n                break;\\n            }else{\\n                temp+=num2[i];\\n            }\\n        }\\n        resx=(x1*x2)-(y1*y2);\\n        resy=(x1*y2)+(x2*y1);\\n        string res=\"\";\\n        res+=(to_string(resx)+\\'+\\'+to_string(resy)+\\'i\\');\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        num1+=\\'+\\';\\n        num2+=\\'+\\';\\n        int x1,x2,y1,y2,resx,resy;\\n        string temp=\"\";\\n        for(int i=0,j=0;i<num1.size();i++){\\n            if(num1[i]==\\'+\\' && j==0){\\n                x1=stoi(temp);\\n                temp=\"\";\\n                j++;\\n            }else if(num1[i]==\\'+\\' && j==1){\\n                y1=stoi(temp);\\n                temp=\"\";\\n                break;\\n            }else{\\n                temp+=num1[i];\\n            }\\n        }\\n        for(int i=0,j=0;i<num2.size();i++){\\n            if(num2[i]==\\'+\\' && j==0){\\n                x2=stoi(temp);\\n                temp=\"\";\\n                j++;\\n            }else if(num2[i]==\\'+\\' && j==1){\\n                y2=stoi(temp);\\n                temp=\"\";\\n                break;\\n            }else{\\n                temp+=num2[i];\\n            }\\n        }\\n        resx=(x1*x2)-(y1*y2);\\n        resy=(x1*y2)+(x2*y1);\\n        string res=\"\";\\n        res+=(to_string(resx)+\\'+\\'+to_string(resy)+\\'i\\');\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799168,
                "title": "java-3ms-easiest-solution",
                "content": "# public String complexNumberMultiply(String num1, String num2) {\\n        int a = Integer.parseInt(num1.substring(0, num1.indexOf(\\'+\\')));\\n        int b = Integer.parseInt(num1.substring(num1.indexOf(\\'+\\') + 1, num1.length() - 1));\\n        int c = Integer.parseInt(num2.substring(0, num2.indexOf(\\'+\\')));\\n        int d = Integer.parseInt(num2.substring(num2.indexOf(\\'+\\') + 1, num2.length() - 1));\\n        String real = String.valueOf((a * c) - (b * d));\\n        String imaginary = String.valueOf((a * d) + (b * c));\\n        return (real + \"+\" + imaginary + \"i\");\\n    }",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "# public String complexNumberMultiply(String num1, String num2) {\\n        int a = Integer.parseInt(num1.substring(0, num1.indexOf(\\'+\\')));\\n        int b = Integer.parseInt(num1.substring(num1.indexOf(\\'+\\') + 1, num1.length() - 1));\\n        int c = Integer.parseInt(num2.substring(0, num2.indexOf(\\'+\\')));\\n        int d = Integer.parseInt(num2.substring(num2.indexOf(\\'+\\') + 1, num2.length() - 1));\\n        String real = String.valueOf((a * c) - (b * d));\\n        String imaginary = String.valueOf((a * d) + (b * c));\\n        return (real + \"+\" + imaginary + \"i\");\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1780004,
                "title": "do-what-questions-asks-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        stringstream ss1(num1),ss2(num2);\\n        string a1,b1,a2,b2;\\n        getline(ss1,a1,\\'+\\');\\n        getline(ss1,b1,\\'i\\');\\n        getline(ss2,a2,\\'+\\');\\n        getline(ss2,b2,\\'i\\');\\n        int x1 = stoi(a1);\\n        int y1 = stoi(b1);\\n        int x2 = stoi(a2);\\n        int y2 = stoi(b2);\\n        int z1 = x1*x2 - y1*y2;\\n        int z2 = x1*y2 + x2*y1;\\n        return to_string(z1)+\"+\"+to_string(z2)+\"i\";\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        stringstream ss1(num1),ss2(num2);\\n        string a1,b1,a2,b2;\\n        getline(ss1,a1,\\'+\\');\\n        getline(ss1,b1,\\'i\\');\\n        getline(ss2,a2,\\'+\\');\\n        getline(ss2,b2,\\'i\\');\\n        int x1 = stoi(a1);\\n        int y1 = stoi(b1);\\n        int x2 = stoi(a2);\\n        int y2 = stoi(b2);\\n        int z1 = x1*x2 - y1*y2;\\n        int z2 = x1*y2 + x2*y1;\\n        return to_string(z1)+\"+\"+to_string(z2)+\"i\";\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1751673,
                "title": "c-easy-to-understand-100-faster",
                "content": "class Solution {\\npublic:\\n\\n    string complexNumberMultiply(string num1, string num2) {\\n        int i=num1.find(\\'+\\');\\n        int real_a=stoi(num1.substr(0,i));\\n       int img_a=stoi(num1.substr(i+1,num1.size()-i-2));\\n        \\n        i=num2.find(\\'+\\');\\n        int real_b=stoi(num2.substr(0,i));\\n        int img_b=stoi(num2.substr(i+1,num2.size()-i-2));\\n        \\n        return to_string(real_a*real_b-img_a*img_b)+\"+\"+to_string(real_a*img_b+real_b*img_a)+\"i\";\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    string complexNumberMultiply(string num1, string num2) {\\n        int i=num1.find(\\'+\\');\\n        int real_a=stoi(num1.substr(0,i));\\n       int img_a=stoi(num1.substr(i+1,num1.size()-i-2));\\n        \\n        i=num2.find(\\'+\\');\\n        int real_b=stoi(num2.substr(0,i));\\n        int img_b=stoi(num2.substr(i+1,num2.size()-i-2));\\n        \\n        return to_string(real_a*real_b-img_a*img_b)+\"+\"+to_string(real_a*img_b+real_b*img_a)+\"i\";\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1726125,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n    \\n    int a = convert(0, num1.indexOf(\\'+\\'), num1);\\n\\n\\n    int b = convert(num1.indexOf(\\'+\\') + 1, num1.length() - 1, num1);\\n\\n    int c = convert(0, num2.indexOf(\\'+\\'), num2);\\n\\n    int d = convert(num2.indexOf(\\'+\\') + 1, num2.length() - 1, num2);\\n\\n\\n\\n\\n    return \"\" + (a * c - b * d) + \"+\" + (b * c + a * d) + \"i\";\\n    \\n    }\\n    \\npublic static int convert(int i, int j, String s)\\n  {\\n    int sign = 1;\\n\\n    if (s.charAt(i) == \\'-\\')\\n    {\\n      sign = -1;\\n\\n      i++;\\n    }\\n\\n    int n = 0;\\n    while ( i < j )\\n    {\\n      n = n * 10 + (s.charAt(i) - \\'0\\');\\n      i++;\\n    }\\n\\n    return sign * n;\\n  }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n    \\n    int a = convert(0, num1.indexOf(\\'+\\'), num1);\\n\\n\\n    int b = convert(num1.indexOf(\\'+\\') + 1, num1.length() - 1, num1);\\n\\n    int c = convert(0, num2.indexOf(\\'+\\'), num2);\\n\\n    int d = convert(num2.indexOf(\\'+\\') + 1, num2.length() - 1, num2);\\n\\n\\n\\n\\n    return \"\" + (a * c - b * d) + \"+\" + (b * c + a * d) + \"i\";\\n    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1719629,
                "title": "c-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string nums1, string nums2)\\n    {\\n        string Xr = \"\", Xi = \"\", Yr = \"\", Yi = \"\";\\n        int i;\\n        for(i=nums1.size()-2; nums1[i]!=\\'+\\'; i--)\\n            Xi = nums1[i] + Xi;\\n        i--;\\n        for( ;i>=0; i--)\\n            Xr = nums1[i] + Xr;\\n        \\n        for(i=nums2.size()-2; nums2[i]!=\\'+\\'; i--)\\n            Yi = nums2[i] + Yi;\\n        i--;\\n        for( ;i>=0; i--)\\n            Yr = nums2[i] + Yr;\\n        \\n        int a = stoll(Xr), b = stoll(Xi), c = stoll(Yr), d = stoll(Yi);\\n        \\n        int real = a*c-b*d;\\n        int imaginary = a*d + b*c;\\n        \\n        Xr = to_string(real);\\n        Xi = to_string(imaginary);\\n                cout << Xr << \" \"<< Xi;\\n        \\n        return (Xr + \\'+\\' + Xi + \\'i\\');\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string nums1, string nums2)\\n    {\\n        string Xr = \"\", Xi = \"\", Yr = \"\", Yi = \"\";\\n        int i;\\n        for(i=nums1.size()-2; nums1[i]!=\\'+\\'; i--)\\n            Xi = nums1[i] + Xi;\\n        i--;\\n        for( ;i>=0; i--)\\n            Xr = nums1[i] + Xr;\\n        \\n        for(i=nums2.size()-2; nums2[i]!=\\'+\\'; i--)\\n            Yi = nums2[i] + Yi;\\n        i--;\\n        for( ;i>=0; i--)\\n            Yr = nums2[i] + Yr;\\n        \\n        int a = stoll(Xr), b = stoll(Xi), c = stoll(Yr), d = stoll(Yi);\\n        \\n        int real = a*c-b*d;\\n        int imaginary = a*d + b*c;\\n        \\n        Xr = to_string(real);\\n        Xi = to_string(imaginary);\\n                cout << Xr << \" \"<< Xi;\\n        \\n        return (Xr + \\'+\\' + Xi + \\'i\\');\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1678129,
                "title": "simple-java-easy",
                "content": "```\\npublic String complexNumberMultiply(String num1, String num2) {\\n        // num1 = a + bi\\n        // num2 = c + di\\n        // result = (a * c - b * d) + (a * d + c * b)i\\n\\n        int a = Integer.parseInt(num1.substring(0, num1.indexOf(\"+\")));\\n        int b = Integer.parseInt(num1.substring(num1.indexOf(\"+\") + 1, num1.length() - 1));\\n        int c = Integer.parseInt(num2.substring(0, num2.indexOf(\"+\")));\\n        int d = Integer.parseInt(num2.substring(num2.indexOf(\"+\") + 1, num2.length() - 1));\\n\\n        return \"\" + (a * c - b * d) + \"+\" + (a * d + c * b) + \"i\";\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String complexNumberMultiply(String num1, String num2) {\\n        // num1 = a + bi\\n        // num2 = c + di\\n        // result = (a * c - b * d) + (a * d + c * b)i\\n\\n        int a = Integer.parseInt(num1.substring(0, num1.indexOf(\"+\")));\\n        int b = Integer.parseInt(num1.substring(num1.indexOf(\"+\") + 1, num1.length() - 1));\\n        int c = Integer.parseInt(num2.substring(0, num2.indexOf(\"+\")));\\n        int d = Integer.parseInt(num2.substring(num2.indexOf(\"+\") + 1, num2.length() - 1));\\n\\n        return \"\" + (a * c - b * d) + \"+\" + (a * d + c * b) + \"i\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675113,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        // num1 = a + bi\\n    // num2 = c + di\\n    // result = (a * c - b * d) + (a * d + c * b)i\\n\\n    int a = Integer.parseInt(num1.substring(0, num1.indexOf(\"+\")));\\n    int b = Integer.parseInt(num1.substring(num1.indexOf(\"+\") + 1, num1.length() - 1));\\n    int c = Integer.parseInt(num2.substring(0, num2.indexOf(\"+\")));\\n    int d = Integer.parseInt(num2.substring(num2.indexOf(\"+\") + 1, num2.length() - 1));\\n\\n    return \"\" + (a * c - b * d) + \"+\" + (a * d + c * b) + \"i\";\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        // num1 = a + bi\\n    // num2 = c + di\\n    // result = (a * c - b * d) + (a * d + c * b)i\\n\\n    int a = Integer.parseInt(num1.substring(0, num1.indexOf(\"+\")));\\n    int b = Integer.parseInt(num1.substring(num1.indexOf(\"+\") + 1, num1.length() - 1));\\n    int c = Integer.parseInt(num2.substring(0, num2.indexOf(\"+\")));\\n    int d = Integer.parseInt(num2.substring(num2.indexOf(\"+\") + 1, num2.length() - 1));\\n\\n    return \"\" + (a * c - b * d) + \"+\" + (a * d + c * b) + \"i\";\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1664276,
                "title": "worst-time-and-space-logic-in-python-but-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def complexNumberMultiply(self, n1: str, n2: str) -> str:\\n        arr1=n1.split(\\'+\\')\\n        arr2=n2.split(\\'+\\')\\n        \\n        for i in range(len(arr1)):\\n            if(\\'i\\' in arr1[i]):\\n                arr1[i]=int(arr1[i][0:len(arr1[i])-1])\\n            else:\\n                arr1[i]=int(arr1[i])\\n           \\n        for i in range(len(arr2)):\\n            if(\\'i\\' in arr2[i]):\\n                arr2[i]=int(arr2[i][0:len(arr2[i])-1])\\n            else:\\n                arr2[i]=int(arr2[i])\\n                \\n        a=arr1[0]*arr2[0]-arr1[1]*arr2[1]\\n        b=arr1[1]*arr2[0]+ arr1[0]*arr2[1]\\n        return str(a)+\"+\"+str(b)+\"i\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def complexNumberMultiply(self, n1: str, n2: str) -> str:\\n        arr1=n1.split(\\'+\\')\\n        arr2=n2.split(\\'+\\')\\n        \\n        for i in range(len(arr1)):\\n            if(\\'i\\' in arr1[i]):\\n                arr1[i]=int(arr1[i][0:len(arr1[i])-1])\\n            else:\\n                arr1[i]=int(arr1[i])\\n           \\n        for i in range(len(arr2)):\\n            if(\\'i\\' in arr2[i]):\\n                arr2[i]=int(arr2[i][0:len(arr2[i])-1])\\n            else:\\n                arr2[i]=int(arr2[i])\\n                \\n        a=arr1[0]*arr2[0]-arr1[1]*arr2[1]\\n        b=arr1[1]*arr2[0]+ arr1[0]*arr2[1]\\n        return str(a)+\"+\"+str(b)+\"i\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658627,
                "title": "c-0ms-100-faster-simple-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        string a = \"\";\\n        string b = \"\";\\n        string c = \"\";\\n        string d = \"\";\\n        int j=0;\\n        while(num1[j] != \\'+\\')\\n        {\\n            a = a + num1[j]; \\n            j++;\\n        }\\n        j++;\\n        while(num1[j] != \\'i\\')\\n        {\\n            b = b + num1[j];\\n            j++;\\n        }\\n        j =0;\\n        while(num2[j] != \\'+\\')\\n        {\\n            c = c + num2[j]; \\n            j++;\\n        }\\n        j++;\\n        while(num2[j] != \\'i\\')\\n        {\\n            d = d + num2[j];\\n            j++;\\n        }\\n        int real = stoi(a)*stoi(c) - stoi(b)*stoi(d);\\n        int img = stoi(a)*stoi(d) + stoi(b)*stoi(c);\\n        return (to_string(real) + \\'+\\' + to_string(img) + \\'i\\');\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        string a = \"\";\\n        string b = \"\";\\n        string c = \"\";\\n        string d = \"\";\\n        int j=0;\\n        while(num1[j] != \\'+\\')\\n        {\\n            a = a + num1[j]; \\n            j++;\\n        }\\n        j++;\\n        while(num1[j] != \\'i\\')\\n        {\\n            b = b + num1[j];\\n            j++;\\n        }\\n        j =0;\\n        while(num2[j] != \\'+\\')\\n        {\\n            c = c + num2[j]; \\n            j++;\\n        }\\n        j++;\\n        while(num2[j] != \\'i\\')\\n        {\\n            d = d + num2[j];\\n            j++;\\n        }\\n        int real = stoi(a)*stoi(c) - stoi(b)*stoi(d);\\n        int img = stoi(a)*stoi(d) + stoi(b)*stoi(c);\\n        return (to_string(real) + \\'+\\' + to_string(img) + \\'i\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596150,
                "title": "python-implementation-of-operator-overloading-and-parsing",
                "content": "```\\nclass Complex:\\n    def __init__(self, string):\\n        real, img = self._parse(string)\\n        self.real = real\\n        self.img = img\\n        \\n    def __mul__(self, other):\\n        real = self.real*other.real - self.img * other.img\\n        img = self.real * other.img + self.img * other.real\\n        return Complex(f\"{real}+{img}i\")\\n    \\n    def __str__(self):\\n        return f\"{self.real}+{self.img}i\"\\n    \\n    def _parse(self, string):\\n        string = string[:-1]\\n        real = img = 0\\n        if \\'+\\' in string:\\n            real, img = map(int, string.split(\\'+\\'))\\n        else:\\n            real, img = map(int, string.split(\\'-\\'))\\n        return real, img\\n    \\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        c1 = Complex(num1)\\n        c2 = Complex(num2)\\n        return str(c1*c2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Complex:\\n    def __init__(self, string):\\n        real, img = self._parse(string)\\n        self.real = real\\n        self.img = img\\n        \\n    def __mul__(self, other):\\n        real = self.real*other.real - self.img * other.img\\n        img = self.real * other.img + self.img * other.real\\n        return Complex(f\"{real}+{img}i\")\\n    \\n    def __str__(self):\\n        return f\"{self.real}+{self.img}i\"\\n    \\n    def _parse(self, string):\\n        string = string[:-1]\\n        real = img = 0\\n        if \\'+\\' in string:\\n            real, img = map(int, string.split(\\'+\\'))\\n        else:\\n            real, img = map(int, string.split(\\'-\\'))\\n        return real, img\\n    \\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        c1 = Complex(num1)\\n        c2 = Complex(num2)\\n        return str(c1*c2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449316,
                "title": "kotlin-time-1-space-1",
                "content": "```\\nfun complexNumberMultiply(num1: String, num2: String): String {\\n\\tval array1 = num1.split(\"+\")\\n\\tval real1 = array1[0].toInt()\\n\\tval img1 = array1[1].dropLast(1).toInt()\\n\\n\\tval array2 = num2.split(\"+\")\\n\\tval real2 = array2[0].toInt()\\n\\tval img2 = array2[1].dropLast(1).toInt()\\n\\n\\tval real = (real1 * real2) - (img1 * img2)\\n\\tval img = (real1 * img2) +(real2 * img1)\\n\\n\\treturn \"${real}+${img}i\"\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun complexNumberMultiply(num1: String, num2: String): String {\\n\\tval array1 = num1.split(\"+\")\\n\\tval real1 = array1[0].toInt()\\n\\tval img1 = array1[1].dropLast(1).toInt()\\n\\n\\tval array2 = num2.split(\"+\")\\n\\tval real2 = array2[0].toInt()\\n\\tval img2 = array2[1].dropLast(1).toInt()\\n\\n\\tval real = (real1 * real2) - (img1 * img2)\\n\\tval img = (real1 * img2) +(real2 * img1)\\n\\n\\treturn \"${real}+${img}i\"\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1424905,
                "title": "python",
                "content": "Well, there are only 3 possible states that can occur\\n\\n- imaginary * imaginary\\n- real * imaginary\\n- real * real\\n\\nMine is slower because i am using \\n> if i in x\\n\\n```\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        \\n        input1 = num1.split(\"+\")\\n        input2 = num2.split(\"+\")\\n        print(input1,input2)\\n        \\n        ans1real = 0\\n        ans1imaginary = 0\\n        for i in input1:\\n            for j in input2:\\n                idigit = int(i.split(\"i\")[0])\\n                jdigit = int(j.split(\"i\")[0])\\n                finalval = idigit*jdigit\\n                if \"i\" in i and \"i\" in j:\\n                    ans1real+=finalval*(-1)\\n                elif \"i\" in i or \"i\" in j:\\n                    ans1imaginary+=finalval\\n                elif not (\"i\" in i or \"i\" in j):\\n                    ans1real+=finalval\\n                    \\n        return str(ans1real) + \"+\" + str(ans1imaginary) + \"i\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        \\n        input1 = num1.split(\"+\")\\n        input2 = num2.split(\"+\")\\n        print(input1,input2)\\n        \\n        ans1real = 0\\n        ans1imaginary = 0\\n        for i in input1:\\n            for j in input2:\\n                idigit = int(i.split(\"i\")[0])\\n                jdigit = int(j.split(\"i\")[0])\\n                finalval = idigit*jdigit\\n                if \"i\" in i and \"i\" in j:\\n                    ans1real+=finalval*(-1)\\n                elif \"i\" in i or \"i\" in j:\\n                    ans1imaginary+=finalval\\n                elif not (\"i\" in i or \"i\" in j):\\n                    ans1real+=finalval\\n                    \\n        return str(ans1real) + \"+\" + str(ans1imaginary) + \"i\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423691,
                "title": "c-simple-solution-faster-than-100",
                "content": "class Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        \\n        int n = num1.length();\\n        int m = num2.length();\\n        \\n        int real1=0;\\n        int imag1=0;\\n        \\n        int real2 = 0;\\n        int imag2 = 0;\\n        \\n        int sign1 = 1;\\n        int sign2 = 1;\\n        \\n        int i = 0;\\n        \\n        if(num1[i]==\\'-\\')\\n        {\\n            sign1 = -1;\\n            i++;\\n        }\\n        \\n        while(i<n and num1[i]!=\\'+\\')\\n        {\\n            real1 = (real1*10) + (num1[i]-\\'0\\');\\n            i++;\\n        }\\n        i++;\\n            \\n        real1 = real1*sign1;\\n        \\n        sign1 = 1;\\n            \\n        if(num1[i]==\\'-\\')\\n        {\\n            sign1 = -1;\\n            i++;\\n        }\\n        \\n        while(i<n and num1[i]!=\\'i\\')\\n        {\\n            imag1 = (imag1*10) + (num1[i]-\\'0\\');\\n            i++;\\n        }\\n        \\n        imag1 = imag1*sign1;\\n        \\n        i=0;\\n        \\n        if(num2[i]==\\'-\\')\\n        {\\n            sign2 = -1;\\n            i++;\\n        }\\n        \\n        while(i<m and num2[i]!=\\'+\\')\\n        {\\n            real2 = (real2*10) + (num2[i]-\\'0\\');\\n            i++;\\n        }\\n        \\n        real2 = real2*sign2;\\n        i++;\\n            \\n        sign2 = 1;\\n            \\n        if(num2[i]==\\'-\\')\\n        {\\n            sign2 = -1;\\n            i++;\\n        }\\n        \\n        while(i<m and num2[i]!=\\'i\\')\\n        {\\n            imag2 = (imag2*10) + (num2[i]-\\'0\\');\\n            i++;\\n        }\\n        \\n        imag2 = imag2*sign2;\\n        \\n        int real = (real1*real2) - (imag1*imag2);\\n        \\n        int imag = (real1*imag2) + (real2*imag1);\\n        \\n        string str=\"\";\\n        \\n        str += to_string(real);\\n        str += \\'+\\';\\n        str+= to_string(imag);\\n        str += \\'i\\';\\n        return str;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        \\n        int n = num1.length();\\n        int m = num2.length();\\n        \\n        int real1=0;\\n        int imag1=0;\\n        \\n        int real2 = 0;\\n        int imag2 = 0;\\n        \\n        int sign1 = 1;\\n        int sign2 = 1;\\n        \\n        int i = 0;\\n        \\n        if(num1[i]==\\'-\\')\\n        {\\n            sign1 = -1;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1423431,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn complex_number_multiply(num1: String, num2: String) -> String {\\n        let n = [num1, num2]\\n            .iter()\\n            .map(|s| {\\n                s.trim_end_matches(\\'i\\')\\n                    .split(\\'+\\')\\n                    .filter_map(|s| s.parse::<i32>().ok())\\n                    .collect::<Vec<_>>()\\n            })\\n            .collect::<Vec<_>>();\\n        format!(\\n            \"{}+{}i\",\\n            n[0][0] * n[1][0] - n[0][1] * n[1][1],\\n            n[0][0] * n[1][1] + n[0][1] * n[1][0]\\n        )\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn complex_number_multiply(num1: String, num2: String) -> String {\\n        let n = [num1, num2]\\n            .iter()\\n            .map(|s| {\\n                s.trim_end_matches(\\'i\\')\\n                    .split(\\'+\\')\\n                    .filter_map(|s| s.parse::<i32>().ok())\\n                    .collect::<Vec<_>>()\\n            })\\n            .collect::<Vec<_>>();\\n        format!(\\n            \"{}+{}i\",\\n            n[0][0] * n[1][0] - n[0][1] * n[1][1],\\n            n[0][0] * n[1][1] + n[0][1] * n[1][0]\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1423415,
                "title": "go-short-code-using-sscanf-ssprintf",
                "content": "```\\nfunc get(s string) (int, int){\\n\\ta, b := 0, 0\\n\\n\\t//num1 = \"1+1i\", num2 = \"1+1i\"\\n\\tfmt.Sscanf(s, \"%d+%di\", &a, &b)\\n\\treturn a, b\\n}\\n\\nfunc complexNumberMultiply(num1 string, num2 string) string {\\n\\ta, b := get(num1)\\n\\tc, d := get(num2)\\n\\n\\t//(ab - bd) + (ad+bc)i\\n\\treturn fmt.Sprintf(\"%d+%di\", a * b - b * d, a * d + b * c)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc get(s string) (int, int){\\n\\ta, b := 0, 0\\n\\n\\t//num1 = \"1+1i\", num2 = \"1+1i\"\\n\\tfmt.Sscanf(s, \"%d+%di\", &a, &b)\\n\\treturn a, b\\n}\\n\\nfunc complexNumberMultiply(num1 string, num2 string) string {\\n\\ta, b := get(num1)\\n\\tc, d := get(num2)\\n\\n\\t//(ab - bd) + (ad+bc)i\\n\\treturn fmt.Sprintf(\"%d+%di\", a * b - b * d, a * d + b * c)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1423253,
                "title": "a-simple-java-ac-solution",
                "content": "\\n```\\nclass Solution {\\n    class ComplexNumber {\\n        int real = 0;\\n        int imaginary = 0;\\n        \\n        public ComplexNumber(int r, int i) {\\n            this.real = r;\\n            this.imaginary = i;\\n        }\\n        \\n        public ComplexNumber(String s) {\\n            int i = 0;\\n            int sign = s.charAt(i) == \\'-\\' ? -1 : 1;\\n            if(sign == -1) {\\n                i++;   \\n            }\\n            while(s.charAt(i) != \\'+\\') {\\n                real = real * 10 + (int)(s.charAt(i)-\\'0\\');\\n                i++;\\n            }\\n            real *= sign;\\n            sign = 0;\\n            i++;\\n            sign = s.charAt(i) == \\'-\\' ? -1 : 1;\\n            if(sign == -1) {\\n                i++;   \\n            }\\n            while(s.charAt(i) != \\'i\\') {\\n                imaginary = imaginary * 10 + (int)(s.charAt(i) -\\'0\\');\\n                i++;\\n            }\\n            imaginary *= sign;\\n        }\\n        \\n        public ComplexNumber multiply(ComplexNumber c) {\\n            int newReal =  this.real * c.real;\\n            int newImaginary = this.real * c.imaginary + this.imaginary * c.real;\\n            newReal += (-1 * this.imaginary * c.imaginary);\\n            return new ComplexNumber(newReal, newImaginary);\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            StringBuilder sb = new StringBuilder();\\n            /*if(real < 0) {\\n                sb.append(\"-\");   \\n            }*/\\n            sb.append(real);\\n            sb.append(\"+\");\\n            /*if(imaginary < 0) {\\n                sb.append(\"-\");\\n            }*/\\n            sb.append(imaginary);\\n            sb.append(\"i\");\\n            return sb.toString();\\n        }   \\n    }\\n    \\n    \\n    public String complexNumberMultiply(String num1, String num2) {\\n        ComplexNumber c1 = new ComplexNumber(num1);\\n        ComplexNumber c2 = new ComplexNumber(num2);\\n        return c1.multiply(c2).toString();\\n    }\\n    \\n   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class ComplexNumber {\\n        int real = 0;\\n        int imaginary = 0;\\n        \\n        public ComplexNumber(int r, int i) {\\n            this.real = r;\\n            this.imaginary = i;\\n        }\\n        \\n        public ComplexNumber(String s) {\\n            int i = 0;\\n            int sign = s.charAt(i) == \\'-\\' ? -1 : 1;\\n            if(sign == -1) {\\n                i++;   \\n            }\\n            while(s.charAt(i) != \\'+\\') {\\n                real = real * 10 + (int)(s.charAt(i)-\\'0\\');\\n                i++;\\n            }\\n            real *= sign;\\n            sign = 0;\\n            i++;\\n            sign = s.charAt(i) == \\'-\\' ? -1 : 1;\\n            if(sign == -1) {\\n                i++;   \\n            }\\n            while(s.charAt(i) != \\'i\\') {\\n                imaginary = imaginary * 10 + (int)(s.charAt(i) -\\'0\\');\\n                i++;\\n            }\\n            imaginary *= sign;\\n        }\\n        \\n        public ComplexNumber multiply(ComplexNumber c) {\\n            int newReal =  this.real * c.real;\\n            int newImaginary = this.real * c.imaginary + this.imaginary * c.real;\\n            newReal += (-1 * this.imaginary * c.imaginary);\\n            return new ComplexNumber(newReal, newImaginary);\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            StringBuilder sb = new StringBuilder();\\n            /*if(real < 0) {\\n                sb.append(\"-\");   \\n            }*/\\n            sb.append(real);\\n            sb.append(\"+\");\\n            /*if(imaginary < 0) {\\n                sb.append(\"-\");\\n            }*/\\n            sb.append(imaginary);\\n            sb.append(\"i\");\\n            return sb.toString();\\n        }   \\n    }\\n    \\n    \\n    public String complexNumberMultiply(String num1, String num2) {\\n        ComplexNumber c1 = new ComplexNumber(num1);\\n        ComplexNumber c2 = new ComplexNumber(num2);\\n        return c1.multiply(c2).toString();\\n    }\\n    \\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423134,
                "title": "c-2-solutions",
                "content": "```\\n    /* Approach is a greedy solution where we parse each input string,\\n     * retrieve the real part and imaginary parts.\\n     */\\n    string complexNumberMultiply(string num1, string num2) {\\n        // variables to store the real and imaginary parts of num1\\n        int r1 = 0;\\n        int i1 = 0;\\n        \\n        // temp variable to store the current number\\n        int curr = 0;\\n        // temp variable helps to determine whether the current number is\\n        // -ve or not\\n        bool isneg = false;\\n        \\n        // Parse num1 string and retrieve the real and imaginary numbers\\n        for (char& ch : num1) {\\n            // Check if the current char is either i or +\\n            if (ch == \\'+\\' || ch == \\'i\\') {\\n                // Check if needs to be a -ve number\\n                curr = isneg ? -curr : curr;\\n                \\n                // If the current char is \\'+\\', then the current number\\n                // extracted is a real number else imaginary\\n                (ch == \\'+\\' ? r1 : i1) = curr;\\n                curr = 0;\\n                isneg = false;\\n            }\\n            else if (ch == \\'-\\') {\\n                // Set the flag\\n                isneg = true;\\n            }\\n            else {\\n                // Append to the current number\\n                curr = curr * 10 + (ch - \\'0\\');\\n            }\\n        }\\n        \\n        // variables to store the real and imaginary parts of num2\\n        int r2 = 0;\\n        int i2 = 0;\\n        \\n        // Reset the curr number, isneg\\n        curr = 0;\\n        isneg = false;\\n        \\n        // Parse num2 string and retrieve the real and imaginary numbers\\n        for (char& ch : num2) {\\n            // Check if the current char is either i or +\\n            if (ch == \\'+\\' || ch == \\'i\\') {\\n                // Check if needs to be a -ve number\\n                curr = isneg ? -curr : curr;\\n                \\n                // If the current char is \\'+\\', then the current number\\n                // extracted is a real number else imaginary\\n                (ch == \\'+\\' ? r2 : i2) = curr;\\n                curr = 0;\\n                isneg = false;\\n            }\\n            else if (ch == \\'-\\') {\\n                // Set the flag\\n                isneg = true;\\n            }\\n            else {\\n                // Append to the current number\\n                curr = curr * 10 + (ch - \\'0\\');\\n            }\\n        }\\n        \\n        // Perform the complex multiplication\\n        return to_string(r1 * r2 - i1 * i2) + \"+\" + to_string(r1 * i2 + r2 * i1) + \"i\";\\n    }\\n\\t\\n    // Approach used is to use the sscanf function to retrieve the real\\n    // and imaginary numbers\\n    string complexNumberMultiply(string num1, string num2) {\\n        // variables to store the real and imaginary parts of num1\\n        int r1 = 0;\\n        int i1 = 0;\\n        \\n        // variables to store the real and imaginary parts of num2\\n        int r2 = 0;\\n        int i2 = 0;\\n        \\n        // Retrieve the real and imaginary values from the strings\\n        sscanf(num1.c_str(), \"%d+%di\", &r1, &i1);\\n        sscanf(num2.c_str(), \"%d+%di\", &r2, &i2);\\n        \\n        // Perform the complex multiplication\\n        return to_string(r1 * r2 - i1 * i2) + \"+\" + to_string(r1 * i2 + r2 * i1) + \"i\";\\n\\n    }\\n\\t\\n```",
                "solutionTags": [],
                "code": "```\\n    /* Approach is a greedy solution where we parse each input string,\\n     * retrieve the real part and imaginary parts.\\n     */\\n    string complexNumberMultiply(string num1, string num2) {\\n        // variables to store the real and imaginary parts of num1\\n        int r1 = 0;\\n        int i1 = 0;\\n        \\n        // temp variable to store the current number\\n        int curr = 0;\\n        // temp variable helps to determine whether the current number is\\n        // -ve or not\\n        bool isneg = false;\\n        \\n        // Parse num1 string and retrieve the real and imaginary numbers\\n        for (char& ch : num1) {\\n            // Check if the current char is either i or +\\n            if (ch == \\'+\\' || ch == \\'i\\') {\\n                // Check if needs to be a -ve number\\n                curr = isneg ? -curr : curr;\\n                \\n                // If the current char is \\'+\\', then the current number\\n                // extracted is a real number else imaginary\\n                (ch == \\'+\\' ? r1 : i1) = curr;\\n                curr = 0;\\n                isneg = false;\\n            }\\n            else if (ch == \\'-\\') {\\n                // Set the flag\\n                isneg = true;\\n            }\\n            else {\\n                // Append to the current number\\n                curr = curr * 10 + (ch - \\'0\\');\\n            }\\n        }\\n        \\n        // variables to store the real and imaginary parts of num2\\n        int r2 = 0;\\n        int i2 = 0;\\n        \\n        // Reset the curr number, isneg\\n        curr = 0;\\n        isneg = false;\\n        \\n        // Parse num2 string and retrieve the real and imaginary numbers\\n        for (char& ch : num2) {\\n            // Check if the current char is either i or +\\n            if (ch == \\'+\\' || ch == \\'i\\') {\\n                // Check if needs to be a -ve number\\n                curr = isneg ? -curr : curr;\\n                \\n                // If the current char is \\'+\\', then the current number\\n                // extracted is a real number else imaginary\\n                (ch == \\'+\\' ? r2 : i2) = curr;\\n                curr = 0;\\n                isneg = false;\\n            }\\n            else if (ch == \\'-\\') {\\n                // Set the flag\\n                isneg = true;\\n            }\\n            else {\\n                // Append to the current number\\n                curr = curr * 10 + (ch - \\'0\\');\\n            }\\n        }\\n        \\n        // Perform the complex multiplication\\n        return to_string(r1 * r2 - i1 * i2) + \"+\" + to_string(r1 * i2 + r2 * i1) + \"i\";\\n    }\\n\\t\\n    // Approach used is to use the sscanf function to retrieve the real\\n    // and imaginary numbers\\n    string complexNumberMultiply(string num1, string num2) {\\n        // variables to store the real and imaginary parts of num1\\n        int r1 = 0;\\n        int i1 = 0;\\n        \\n        // variables to store the real and imaginary parts of num2\\n        int r2 = 0;\\n        int i2 = 0;\\n        \\n        // Retrieve the real and imaginary values from the strings\\n        sscanf(num1.c_str(), \"%d+%di\", &r1, &i1);\\n        sscanf(num2.c_str(), \"%d+%di\", &r2, &i2);\\n        \\n        // Perform the complex multiplication\\n        return to_string(r1 * r2 - i1 * i2) + \"+\" + to_string(r1 * i2 + r2 * i1) + \"i\";\\n\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1423015,
                "title": "write-clean-code",
                "content": "```\\npublic String complexNumberMultiply(String num1, String num2) {\\n\\treturn Complex.mult(new Complex(num1), new Complex(num2)).toString();\\n}\\n\\nstatic class Complex{\\n\\tint a, b; // a+bi\\n\\n\\tpublic Complex(String num){\\n\\t\\tString[] arr= num.split(\"\\\\\\\\+\");\\n\\t\\tthis.a= Integer.valueOf(arr[0]);\\n\\t\\tthis.b= Integer.valueOf(arr[1].substring(0, arr[1].length()-1));\\n\\t}\\n\\n\\tpublic Complex(int a, int b){\\n\\t\\tthis.a= a;\\n\\t\\tthis.b= b;\\n\\t}\\n\\n\\tpublic static Complex mult(Complex c1, Complex c2){\\n\\t\\treturn new Complex(c1.a*c2.a-c1.b*c2.b, c1.a*c2.b+c1.b*c2.a);\\n\\t}\\n\\n\\tpublic String toString(){\\n\\t\\treturn new StringBuilder().append(a).append(\\'+\\').append(b).append(\\'i\\').toString();\\n\\t\\t//return String.format(\"%d+%di\", a, b);  // StringBuilder is much faster\\n\\t}\\n}",
                "solutionTags": [],
                "code": "```\\npublic String complexNumberMultiply(String num1, String num2) {\\n\\treturn Complex.mult(new Complex(num1), new Complex(num2)).toString();\\n}\\n\\nstatic class Complex{\\n\\tint a, b; // a+bi\\n\\n\\tpublic Complex(String num){\\n\\t\\tString[] arr= num.split(\"\\\\\\\\+\");\\n\\t\\tthis.a= Integer.valueOf(arr[0]);\\n\\t\\tthis.b= Integer.valueOf(arr[1].substring(0, arr[1].length()-1));\\n\\t}\\n\\n\\tpublic Complex(int a, int b){\\n\\t\\tthis.a= a;\\n\\t\\tthis.b= b;\\n\\t}\\n\\n\\tpublic static Complex mult(Complex c1, Complex c2){\\n\\t\\treturn new Complex(c1.a*c2.a-c1.b*c2.b, c1.a*c2.b+c1.b*c2.a);\\n\\t}\\n\\n\\tpublic String toString(){\\n\\t\\treturn new StringBuilder().append(a).append(\\'+\\').append(b).append(\\'i\\').toString();\\n\\t\\t//return String.format(\"%d+%di\", a, b);  // StringBuilder is much faster\\n\\t}\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1422815,
                "title": "swift-readable-solution",
                "content": "```\\nclass Solution {\\n\\n    private struct Complex {\\n        let real: Int\\n        let imaginary: Int\\n    }\\n\\n    func complexNumberMultiply(_ num1: String, _ num2: String) -> String {\\n        guard \\n            let complex1 = complex(from: num1),\\n            let complex2 = complex(from: num2)\\n        else { return \"\" }\\n        let real = complex1.real * complex2.real - complex1.imaginary * complex2.imaginary\\n        let imaginary = complex1.real * complex2.imaginary + complex1.imaginary * complex2.real\\n        return \"\\\\(real)+\\\\(imaginary)i\"\\n    }\\n\\n    private func complex(from string: String) -> Complex? {\\n        let components = string.split(separator: \"+\")\\n        guard\\n            components.count == 2,\\n            let real = Int(components[0]),\\n            let imaginary = Int(components[1].dropLast())\\n        else { return nil }\\n        return Complex(real: real, imaginary: imaginary)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    private struct Complex {\\n        let real: Int\\n        let imaginary: Int\\n    }\\n\\n    func complexNumberMultiply(_ num1: String, _ num2: String) -> String {\\n        guard \\n            let complex1 = complex(from: num1),\\n            let complex2 = complex(from: num2)\\n        else { return \"\" }\\n        let real = complex1.real * complex2.real - complex1.imaginary * complex2.imaginary\\n        let imaginary = complex1.real * complex2.imaginary + complex1.imaginary * complex2.real\\n        return \"\\\\(real)+\\\\(imaginary)i\"\\n    }\\n\\n    private func complex(from string: String) -> Complex? {\\n        let components = string.split(separator: \"+\")\\n        guard\\n            components.count == 2,\\n            let real = Int(components[0]),\\n            let imaginary = Int(components[1].dropLast())\\n        else { return nil }\\n        return Complex(real: real, imaginary: imaginary)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372689,
                "title": "a-straight-forward-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2)\\n    {\\n        string a, b, c, d;\\n        int s1=num1.size(), s2=num2.size();\\n        for(int i=0;i<s1;i++)\\n        {\\n            while(num1[i] != \\'+\\')\\n            {\\n                a += num1[i];\\n                i++;\\n            }\\n            i++;\\n            while(num1[i] != \\'i\\')\\n            {\\n                b += num1[i];\\n                i++;\\n            }\\n        }\\n        for(int i=0;i<s2;i++)\\n        {\\n            while(num2[i] != \\'+\\')\\n            {\\n                c += num2[i];\\n                i++;\\n            }\\n            i++;\\n            while(num2[i] != \\'i\\')\\n            {\\n                d += num2[i];\\n                i++;\\n            }\\n        }\\n        int a_r = stoi(a);\\n        int b_i = stoi(b);\\n        int c_r = stoi(c);\\n        int d_i = stoi(d);\\n        int sol1 = (a_r*c_r)-(b_i*d_i);\\n        int sol2 = (a_r*d_i)+(b_i*c_r);\\n        string k = to_string(sol1);\\n        string l = to_string(sol2);\\n        string answer;\\n        answer += k;\\n        answer += \\'+\\';\\n        answer += l;\\n        answer += \\'i\\';\\n        return answer;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2)\\n    {\\n        string a, b, c, d;\\n        int s1=num1.size(), s2=num2.size();\\n        for(int i=0;i<s1;i++)\\n        {\\n            while(num1[i] != \\'+\\')\\n            {\\n                a += num1[i];\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1352840,
                "title": "simple-java-code",
                "content": "```java\\n// AC: Runtime: 3 ms, faster than 86.05% of Java online submissions for Complex Number Multiplication.\\n// Memory Usage: 37.3 MB, less than 75.87% of Java online submissions for Complex Number Multiplication.\\n// .\\n// T:O(max(len1, len2)), S:O(1)\\n// \\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        int index1 = num1.indexOf(\"+\"), index2 = num2.indexOf(\"+\");\\n        int real1 = Integer.parseInt(num1.substring(0, index1));\\n        int imagine1 = Integer.parseInt(num1.substring(index1 + 1, num1.length() - 1));\\n        int real2 = Integer.parseInt(num2.substring(0, index2));\\n        int imagine2 = Integer.parseInt(num2.substring(index2 + 1, num2.length() - 1));\\n        \\n        int real = real1 * real2 - imagine1 * imagine2;\\n        int imagine = real1 * imagine2 + real2 * imagine1;\\n\\n        return real + \"+\" + imagine + \"i\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n// AC: Runtime: 3 ms, faster than 86.05% of Java online submissions for Complex Number Multiplication.\\n// Memory Usage: 37.3 MB, less than 75.87% of Java online submissions for Complex Number Multiplication.\\n// .\\n// T:O(max(len1, len2)), S:O(1)\\n// \\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        int index1 = num1.indexOf(\"+\"), index2 = num2.indexOf(\"+\");\\n        int real1 = Integer.parseInt(num1.substring(0, index1));\\n        int imagine1 = Integer.parseInt(num1.substring(index1 + 1, num1.length() - 1));\\n        int real2 = Integer.parseInt(num2.substring(0, index2));\\n        int imagine2 = Integer.parseInt(num2.substring(index2 + 1, num2.length() - 1));\\n        \\n        int real = real1 * real2 - imagine1 * imagine2;\\n        int imagine = real1 * imagine2 + real2 * imagine1;\\n\\n        return real + \"+\" + imagine + \"i\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275954,
                "title": "easy-python-solution-faster-than-82",
                "content": "```\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        num1=num1.replace(\"i\",\"\")\\n        num2=num2.replace(\"i\",\"\")\\n        x1,y1=num1.split(\"+\")\\n        x2,y2=num2.split(\"+\")\\n        x=int(x1)*int(x2)-(int(y1)*int(y2))\\n        y=int(x1)*int(y2)+int(x2)*int(y1)\\n        return str(x)+\"+\"+str(y)+\"i\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        num1=num1.replace(\"i\",\"\")\\n        num2=num2.replace(\"i\",\"\")\\n        x1,y1=num1.split(\"+\")\\n        x2,y2=num2.split(\"+\")\\n        x=int(x1)*int(x2)-(int(y1)*int(y2))\\n        y=int(x1)*int(y2)+int(x2)*int(y1)\\n        return str(x)+\"+\"+str(y)+\"i\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162967,
                "title": "c-solution-o-n-runtime-100",
                "content": "```\\npair<int,int> get_ri(string& s) {\\n\\tstringstream ss(s);\\n\\tint r,i;\\n\\tchar ch;\\n\\tss >> r >> ch >> i;\\n\\treturn {r,i};\\n}\\nstring complexNumberMultiply(string a, string b) {\\n\\tauto [r1,i1]=get_ri(a);\\n\\tauto [r2,i2]=get_ri(b);\\n\\n\\tauto r = r1*r2 - i1*i2;\\n\\tauto i = r1*i2 + r2*i1;\\n\\treturn to_string(r) + \"+\" + to_string(i)+\"i\";\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npair<int,int> get_ri(string& s) {\\n\\tstringstream ss(s);\\n\\tint r,i;\\n\\tchar ch;\\n\\tss >> r >> ch >> i;\\n\\treturn {r,i};\\n}\\nstring complexNumberMultiply(string a, string b) {\\n\\tauto [r1,i1]=get_ri(a);\\n\\tauto [r2,i2]=get_ri(b);\\n\\n\\tauto r = r1*r2 - i1*i2;\\n\\tauto i = r1*i2 + r2*i1;\\n\\treturn to_string(r) + \"+\" + to_string(i)+\"i\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1161058,
                "title": "c-without-using-regex-or-stringstream",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int findIndex(string a) \\n    {\\n        for ( int i=0; i<a.length(); i++ ) {\\n            if ( a[i] == \\'+\\' ) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    string complexNumberMultiply(string a, string b) \\n    {\\n        // finding i, j for the complex number\\n        int i1 = findIndex(a);\\n        int a1 = stoi(a.substr(0,i1));\\n        string aa2 = a.substr(i1+1);\\n        aa2.pop_back();\\n        int a2 = stoi(aa2);\\n        \\n        // finding i, j for the complex number\\n        int i2 = findIndex(b);\\n        int b1 = stoi(b.substr(0,i2));\\n        string bb2 = b.substr(i2+1);\\n        bb2.pop_back();\\n        int b2 = stoi(bb2);\\n                        \\n        // display final result\\n        string res = to_string(a1*b1 - a2*b2) + \"+\" + to_string(a1*b2 + a2*b1) + \"i\";           \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int findIndex(string a) \\n    {\\n        for ( int i=0; i<a.length(); i++ ) {\\n            if ( a[i] == \\'+\\' ) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    string complexNumberMultiply(string a, string b) \\n    {\\n        // finding i, j for the complex number\\n        int i1 = findIndex(a);\\n        int a1 = stoi(a.substr(0,i1));\\n        string aa2 = a.substr(i1+1);\\n        aa2.pop_back();\\n        int a2 = stoi(aa2);\\n        \\n        // finding i, j for the complex number\\n        int i2 = findIndex(b);\\n        int b1 = stoi(b.substr(0,i2));\\n        string bb2 = b.substr(i2+1);\\n        bb2.pop_back();\\n        int b2 = stoi(bb2);\\n                        \\n        // display final result\\n        string res = to_string(a1*b1 - a2*b2) + \"+\" + to_string(a1*b2 + a2*b1) + \"i\";           \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153679,
                "title": "100-faster-c-using-stoi-and-to-string",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string l, string m) {\\n        int pos = l.find(\\'+\\');\\n        string r1 = l.substr(0,pos);\\n        string i1 = l.substr(pos+1);\\n        i1.pop_back();\\n        int pos1 = m.find(\\'+\\');\\n        string r2 = m.substr(0,pos1);\\n        string i2 = m.substr(pos1+1);\\n        i2.pop_back();\\n        int a = stoi(r1);\\n        int b = stoi(i1);\\n        int x = stoi(r2);\\n        int y = stoi(i2);\\n        string aa = to_string(a*x-b*y);\\n        string bb = to_string(b*x+a*y);\\n        return aa+\"+\"+bb+\"i\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string l, string m) {\\n        int pos = l.find(\\'+\\');\\n        string r1 = l.substr(0,pos);\\n        string i1 = l.substr(pos+1);\\n        i1.pop_back();\\n        int pos1 = m.find(\\'+\\');\\n        string r2 = m.substr(0,pos1);\\n        string i2 = m.substr(pos1+1);\\n        i2.pop_back();\\n        int a = stoi(r1);\\n        int b = stoi(i1);\\n        int x = stoi(r2);\\n        int y = stoi(i2);\\n        string aa = to_string(a*x-b*y);\\n        string bb = to_string(b*x+a*y);\\n        return aa+\"+\"+bb+\"i\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057528,
                "title": "simple-and-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        arr1=a.split(\"+\")\\n        arr2=b.split(\"+\")\\n        x=int(arr1[0])\\n        y=int(arr1[1][:-1])\\n        z=int(arr2[0])\\n        w=int(arr2[1][:-1])\\n        ans=str(x*z-y*w)+\"+\"+str(x*w+y*z)+\"i\"\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        arr1=a.split(\"+\")\\n        arr2=b.split(\"+\")\\n        x=int(arr1[0])\\n        y=int(arr1[1][:-1])\\n        z=int(arr2[0])\\n        w=int(arr2[1][:-1])\\n        ans=str(x*z-y*w)+\"+\"+str(x*w+y*z)+\"i\"\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983385,
                "title": "java-o-1-simple-maths",
                "content": "```class Solution {\\n    public String complexNumberMultiply(String a, String b) {\\n        \\n        int one = Integer.parseInt(a.substring(0,a.indexOf(\\'+\\')));\\n        int two = Integer.parseInt(a.substring(a.indexOf(\\'+\\')+1,a.indexOf(\\'i\\')));\\n        \\n        int three = Integer.parseInt(b.substring(0,b.indexOf(\\'+\\')));\\n        int four = Integer.parseInt(b.substring(b.indexOf(\\'+\\')+1,b.indexOf(\\'i\\')));\\n        \\n        int ans1 = (one*three)-(two*four);\\n        int ans2 =(one * four) + (two*three);\\n        \\n        return Integer.toString(ans1)+\"+\"+Integer.toString(ans2)+\"i\";\\n        \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String complexNumberMultiply(String a, String b) {\\n        \\n        int one = Integer.parseInt(a.substring(0,a.indexOf(\\'+\\')));\\n        int two = Integer.parseInt(a.substring(a.indexOf(\\'+\\')+1,a.indexOf(\\'i\\')));\\n        \\n        int three = Integer.parseInt(b.substring(0,b.indexOf(\\'+\\')));\\n        int four = Integer.parseInt(b.substring(b.indexOf(\\'+\\')+1,b.indexOf(\\'i\\')));\\n        \\n        int ans1 = (one*three)-(two*four);\\n        int ans2 =(one * four) + (two*three);\\n        \\n        return Integer.toString(ans1)+\"+\"+Integer.toString(ans2)+\"i\";\\n        \\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 958497,
                "title": "c-solution-using-sscanf",
                "content": "```cpp\\nclass Solution {\\n    char ans[20]{};\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        int a_re, a_im, b_re, b_im;\\n        sscanf(a.c_str(), \"%d+%di\", &a_re, &a_im);\\n        sscanf(b.c_str(), \"%d+%di\", &b_re, &b_im);\\n        \\n        int ans_re = a_re * b_re - a_im * b_im;\\n        int ans_im = a_re * b_im + a_im * b_re;\\n        \\n        sprintf(ans, \"%d+%di\", ans_re, ans_im);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\n    char ans[20]{};\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        int a_re, a_im, b_re, b_im;\\n        sscanf(a.c_str(), \"%d+%di\", &a_re, &a_im);\\n        sscanf(b.c_str(), \"%d+%di\", &b_re, &b_im);\\n        \\n        int ans_re = a_re * b_re - a_im * b_im;\\n        int ans_im = a_re * b_im + a_im * b_re;\\n        \\n        sprintf(ans, \"%d+%di\", ans_re, ans_im);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941852,
                "title": "runtime-0-ms-faster-than-100-00-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        int pluspos = a.find(\"+-\");\\n        int minuspos = b.find(\"+-\");\\n        char star1,star2,star3,star4;\\n        if(pluspos>0)\\n          star1 = \\'-\\';\\n        else star1=\\'+\\';\\n        \\n        if(minuspos>0)\\n            star2 = \\'-\\';\\n        else star2=\\'+\\';\\n\\n        string x1,y1,x2,y2;\\n        if(pluspos>0){\\n              y1 = a.substr(pluspos+1);\\n              y1.pop_back();\\n              x1 = a.substr(0,pluspos);\\n        }\\n        else{\\n             pluspos = a.find(\"+\");\\n              y1 = a.substr(pluspos+1);\\n              y1.pop_back();\\n              x1 = a.substr(0,pluspos);\\n        }\\n       if(minuspos>0){\\n              y2 = b.substr(minuspos+1);\\n              y2.pop_back();\\n              x2 = b.substr(0,minuspos);\\n        }\\n        else{\\n             minuspos = b.find(\"+\");\\n              y2 = b.substr(minuspos+1);\\n              y2.pop_back();\\n              x2 = b.substr(0,minuspos);\\n        }\\n\\n        bool neg = false;\\n        if(star1!=star2) neg = true;\\n        \\n        int left = 0;\\n        left = stoi(x1)*stoi(x2) - stoi(y1)*stoi(y2) ;\\n        int right =0;\\n        right = stoi(x1)*stoi(y2) + stoi(y1)*stoi(x2);\\n        string op = \"\";\\n        op += to_string(left) + \"+\" + to_string(right) + \"i\";\\n        return op;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        int pluspos = a.find(\"+-\");\\n        int minuspos = b.find(\"+-\");\\n        char star1,star2,star3,star4;\\n        if(pluspos>0)\\n          star1 = \\'-\\';\\n        else star1=\\'+\\';\\n        \\n        if(minuspos>0)\\n            star2 = \\'-\\';\\n        else star2=\\'+\\';\\n\\n        string x1,y1,x2,y2;\\n        if(pluspos>0){\\n              y1 = a.substr(pluspos+1);\\n              y1.pop_back();\\n              x1 = a.substr(0,pluspos);\\n        }\\n        else{\\n             pluspos = a.find(\"+\");\\n              y1 = a.substr(pluspos+1);\\n              y1.pop_back();\\n              x1 = a.substr(0,pluspos);\\n        }\\n       if(minuspos>0){\\n              y2 = b.substr(minuspos+1);\\n              y2.pop_back();\\n              x2 = b.substr(0,minuspos);\\n        }\\n        else{\\n             minuspos = b.find(\"+\");\\n              y2 = b.substr(minuspos+1);\\n              y2.pop_back();\\n              x2 = b.substr(0,minuspos);\\n        }\\n\\n        bool neg = false;\\n        if(star1!=star2) neg = true;\\n        \\n        int left = 0;\\n        left = stoi(x1)*stoi(x2) - stoi(y1)*stoi(y2) ;\\n        int right =0;\\n        right = stoi(x1)*stoi(y2) + stoi(y1)*stoi(x2);\\n        string op = \"\";\\n        op += to_string(left) + \"+\" + to_string(right) + \"i\";\\n        return op;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849636,
                "title": "c-0ms-extremely-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        string ar(a.begin(), a.begin() + a.find(\\'+\\')); // real a\\n        string br(b.begin(), b.begin() + b.find(\\'+\\')); // real b\\n        string ai, bi; // imaginary a, b\\n        \\n        int s = a.find(\\'+\\');\\n        if (a[s+1] == \\'-\\') s++;\\n        ai.assign(a.begin() + s, a.end() - 1);\\n        s = b.find(\\'+\\');\\n        if (b[s+1] == \\'-\\') s++;\\n        bi.assign(b.begin() + s, b.end() - 1);\\n            \\n        int real = stoi(ar) * stoi(br) + stoi(ai) * stoi(bi) * -1;\\n        int imaginary = stoi(ai) * stoi(br) + stoi(bi) * stoi(ar);\\n        return to_string(real) + \"+\" + to_string(imaginary) + \"i\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        string ar(a.begin(), a.begin() + a.find(\\'+\\')); // real a\\n        string br(b.begin(), b.begin() + b.find(\\'+\\')); // real b\\n        string ai, bi; // imaginary a, b\\n        \\n        int s = a.find(\\'+\\');\\n        if (a[s+1] == \\'-\\') s++;\\n        ai.assign(a.begin() + s, a.end() - 1);\\n        s = b.find(\\'+\\');\\n        if (b[s+1] == \\'-\\') s++;\\n        bi.assign(b.begin() + s, b.end() - 1);\\n            \\n        int real = stoi(ar) * stoi(br) + stoi(ai) * stoi(bi) * -1;\\n        int imaginary = stoi(ai) * stoi(br) + stoi(bi) * stoi(ar);\\n        return to_string(real) + \"+\" + to_string(imaginary) + \"i\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848546,
                "title": "rust",
                "content": "* Runtime: 0 ms, faster than 100.00% of Rust online submissions for Complex Number Multiplication.\\n* Memory Usage: 2.1 MB, less than 66.67% of Rust online submissions for Complex Number Multiplication.\\n\\n```rust\\ntype Sol=Solution;\\n\\nimpl Solution {\\n\\n    // Leetcode is running an old version of the compiler where `std::string::String`\\n    // doesn\\'t have `strip_prefix` method\\n    /*pub fn deserialize(s: &String) -> (i32, i32) {\\n        let mut a = s.clone();\\n        let b = a.split_off(\\n                s.find(\\'+\\')\\n\\t\\t\\t\\t.unwrap());\\n        let b = b.strip_prefix(\"+\")\\n            .unwrap();\\n        let b = b.strip_suffix(\"i\")\\n            .unwrap();\\n\\n        (a.parse::<i32>().unwrap(), b.parse::<i32>().unwrap())\\n    }*/\\n\\n    pub fn deserialize(s: &String) -> (i32, i32) {\\n        let v: Vec<&str> = s.trim_end_matches(\"i\")\\n            .split(\\'+\\')\\n            .collect();\\n\\n        (v[0].parse::<i32>().unwrap(), v[1].parse::<i32>().unwrap())\\n    }\\n    \\n    \\n    pub fn serialize(num: &(i32, i32)) -> String {\\n        let (a, b) = num;\\n        format!(\"{}+{}i\", a, b)\\n    }\\n\\n\\n    pub fn complex_number_multiply(a: String, b: String) -> String {\\n        let (a_real, a_i) = Sol::deserialize(&a);\\n        let (b_real, b_i) = Sol::deserialize(&b);\\n\\n        let c_real = a_real * b_real - a_i * b_i; \\n        let c_i = a_real * b_i + a_i * b_real;\\n\\n        Sol::serialize(&(c_real, c_i))\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\ntype Sol=Solution;\\n\\nimpl Solution {\\n\\n    // Leetcode is running an old version of the compiler where `std::string::String`\\n    // doesn\\'t have `strip_prefix` method\\n    /*pub fn deserialize(s: &String) -> (i32, i32) {\\n        let mut a = s.clone();\\n        let b = a.split_off(\\n                s.find(\\'+\\')\\n\\t\\t\\t\\t.unwrap());\\n        let b = b.strip_prefix(\"+\")\\n            .unwrap();\\n        let b = b.strip_suffix(\"i\")\\n            .unwrap();\\n\\n        (a.parse::<i32>().unwrap(), b.parse::<i32>().unwrap())\\n    }*/\\n\\n    pub fn deserialize(s: &String) -> (i32, i32) {\\n        let v: Vec<&str> = s.trim_end_matches(\"i\")\\n            .split(\\'+\\')\\n            .collect();\\n\\n        (v[0].parse::<i32>().unwrap(), v[1].parse::<i32>().unwrap())\\n    }\\n    \\n    \\n    pub fn serialize(num: &(i32, i32)) -> String {\\n        let (a, b) = num;\\n        format!(\"{}+{}i\", a, b)\\n    }\\n\\n\\n    pub fn complex_number_multiply(a: String, b: String) -> String {\\n        let (a_real, a_i) = Sol::deserialize(&a);\\n        let (b_real, b_i) = Sol::deserialize(&b);\\n\\n        let c_real = a_real * b_real - a_i * b_i; \\n        let c_i = a_real * b_i + a_i * b_real;\\n\\n        Sol::serialize(&(c_real, c_i))\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 844439,
                "title": "java-simple",
                "content": "```\\nStringBuilder res=new StringBuilder();\\n        int i=0,j=0;\\n        int r1=0,r2=0;\\n        int i1=0,i2=0;\\n        while(i<a.length()&&a.charAt(i)!=\\'+\\'){i++;}\\n        while(j<b.length()&&b.charAt(j)!=\\'+\\'){j++;}\\n        r1=Integer.parseInt(a.substring(0,i));\\n        r2=Integer.parseInt(b.substring(0,j));\\n        i1=Integer.parseInt(a.substring(i+1,a.length()-1));\\n        i2=Integer.parseInt(b.substring(j+1,b.length()-1));\\n        res.append(r1*r2-(i1*i2)+\"+\"+(r1*i2+r2*i1)+\"i\");\\n        return res.toString();\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nStringBuilder res=new StringBuilder();\\n        int i=0,j=0;\\n        int r1=0,r2=0;\\n        int i1=0,i2=0;\\n        while(i<a.length()&&a.charAt(i)!=\\'+\\'){i++;}\\n        while(j<b.length()&&b.charAt(j)!=\\'+\\'){j++;}\\n        r1=Integer.parseInt(a.substring(0,i));\\n        r2=Integer.parseInt(b.substring(0,j));\\n        i1=Integer.parseInt(a.substring(i+1,a.length()-1));\\n        i2=Integer.parseInt(b.substring(j+1,b.length()-1));\\n        res.append(r1*r2-(i1*i2)+\"+\"+(r1*i2+r2*i1)+\"i\");\\n        return res.toString();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 841911,
                "title": "c-clear-object-oriented-solution-best-for-an-interview-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        Complex num1(a);\\n        Complex num2(b);\\n        return (num1 * num2).toString();\\n    }\\n    \\n    class Complex {\\n        public:\\n            int real = 0;\\n            int imag = 0;\\n            Complex() = default;\\n            Complex(string s) {\\n                int operatorIndex = s.find(\"+\");\\n                this->real = stoi(s);\\n                if(s[operatorIndex+1] == \\'-\\')\\n                    this->imag = stoi(s.substr(operatorIndex+1));\\n                else\\n                    this->imag = stoi(s.substr(operatorIndex+1));\\n            }\\n            Complex operator* (Complex const &rhs) { \\n                Complex res;\\n                res.real = (this->real*rhs.real - this->imag*rhs.imag);\\n                res.imag = (this->real*rhs.imag + this->imag*rhs.real);\\n                return res;\\n            }\\n            string toString() {\\n                string res = \"\";\\n                res += to_string(this->real);\\n                res += \"+\";\\n                res += to_string(this->imag);\\n                res+=\"i\";\\n                return res;\\n            }\\n            \\n    };\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        Complex num1(a);\\n        Complex num2(b);\\n        return (num1 * num2).toString();\\n    }\\n    \\n    class Complex {\\n        public:\\n            int real = 0;\\n            int imag = 0;\\n            Complex() = default;\\n            Complex(string s) {\\n                int operatorIndex = s.find(\"+\");\\n                this->real = stoi(s);\\n                if(s[operatorIndex+1] == \\'-\\')\\n                    this->imag = stoi(s.substr(operatorIndex+1));\\n                else\\n                    this->imag = stoi(s.substr(operatorIndex+1));\\n            }\\n            Complex operator* (Complex const &rhs) { \\n                Complex res;\\n                res.real = (this->real*rhs.real - this->imag*rhs.imag);\\n                res.imag = (this->real*rhs.imag + this->imag*rhs.real);\\n                return res;\\n            }\\n            string toString() {\\n                string res = \"\";\\n                res += to_string(this->real);\\n                res += \"+\";\\n                res += to_string(this->imag);\\n                res+=\"i\";\\n                return res;\\n            }\\n            \\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833204,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        a = a.replace(\"+-\", \"-\")\\n        b = b.replace(\"+-\", \"-\")\\n        a = a.replace(\"i\", \"j\")\\n        a_comp = complex(a)\\n        b = b.replace(\"i\", \"j\")\\n        b_comp = complex(b)\\n        \\n        \\n        comp_mult = a_comp * b_comp\\n        real = comp_mult.real\\n        \\n        comp_mult = str(comp_mult).replace(\"j\", \"i\")\\n        if real == 0:\\n            comp_mult = \"0+\" +  comp_mult \\n            \\n        if \"-\" in comp_mult and \"+\" not in comp_mult:\\n            comp_mult = comp_mult.replace(\"-\", \"+-\")\\n            \\n            \\n        comp_mult = comp_mult.replace(\"(\", \"\")\\n        comp_mult = comp_mult.replace(\")\", \"\")\\n        \\n        return comp_mult[1:] if comp_mult[0] == \"+\" else comp_mult\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        a = a.replace(\"+-\", \"-\")\\n        b = b.replace(\"+-\", \"-\")\\n        a = a.replace(\"i\", \"j\")\\n        a_comp = complex(a)\\n        b = b.replace(\"i\", \"j\")\\n        b_comp = complex(b)\\n        \\n        \\n        comp_mult = a_comp * b_comp\\n        real = comp_mult.real\\n        \\n        comp_mult = str(comp_mult).replace(\"j\", \"i\")\\n        if real == 0:\\n            comp_mult = \"0+\" +  comp_mult \\n            \\n        if \"-\" in comp_mult and \"+\" not in comp_mult:\\n            comp_mult = comp_mult.replace(\"-\", \"+-\")\\n            \\n            \\n        comp_mult = comp_mult.replace(\"(\", \"\")\\n        comp_mult = comp_mult.replace(\")\", \"\")\\n        \\n        return comp_mult[1:] if comp_mult[0] == \"+\" else comp_mult\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712343,
                "title": "javascript-simple-solution",
                "content": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar complexNumberMultiply = function(a, b) {\\n    const aValues = a.split(\\'+\\');\\n    const bValues = b.split(\\'+\\');\\n\\n    aValues[1] = aValues[1].replace(\\'i\\', \\'\\');\\n    bValues[1] = bValues[1].replace(\\'i\\', \\'\\');\\n\\n    // First\\n    const first = parseInt(aValues[0]) * parseInt(bValues[0]);\\n\\n    // Outer\\n    const outer = parseInt(aValues[0]) * parseInt(bValues[1]);\\n\\n    // Inner\\n    const inner = parseInt(aValues[1]) * parseInt(bValues[0]);\\n\\n    // Last\\n    const last = parseInt(aValues[1]) * parseInt(bValues[1]) * -1;\\n\\n    return `${first+last}+${outer+inner}i`;\\n};\\n\\n// Runtime (60ms) - Faster than 81.48% of Javascript solutions\\n// Memory (33MB) - Less than 85% of Javascript Solutions\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar complexNumberMultiply = function(a, b) {\\n    const aValues = a.split(\\'+\\');\\n    const bValues = b.split(\\'+\\');\\n\\n    aValues[1] = aValues[1].replace(\\'i\\', \\'\\');\\n    bValues[1] = bValues[1].replace(\\'i\\', \\'\\');\\n\\n    // First\\n    const first = parseInt(aValues[0]) * parseInt(bValues[0]);\\n\\n    // Outer\\n    const outer = parseInt(aValues[0]) * parseInt(bValues[1]);\\n\\n    // Inner\\n    const inner = parseInt(aValues[1]) * parseInt(bValues[0]);\\n\\n    // Last\\n    const last = parseInt(aValues[1]) * parseInt(bValues[1]) * -1;\\n\\n    return `${first+last}+${outer+inner}i`;\\n};\\n\\n// Runtime (60ms) - Faster than 81.48% of Javascript solutions\\n// Memory (33MB) - Less than 85% of Javascript Solutions\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 618339,
                "title": "c-0ms-simple-and-short",
                "content": "```\\ninline void pi(char *s, char *a, char *b){\\n    char *p = strchr(s, \\'+\\'), *i = strchr(p + 1, \\'i\\');\\n    *a = atoi((*p = 0, s));    \\n    *b = atoi((*i = 0, p + 1));\\n}\\n\\nchar * complexNumberMultiply(char * a, char * b){\\n    char x, y, l, m, *p = calloc(1, 100);\\n    pi(a, &x, &y);\\n    pi(b, &l, &m);\\n    snprintf(p, 100, \"%d+%di\", x * l + -(y * m), x * m + y * l);\\n    return p;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ninline void pi(char *s, char *a, char *b){\\n    char *p = strchr(s, \\'+\\'), *i = strchr(p + 1, \\'i\\');\\n    *a = atoi((*p = 0, s));    \\n    *b = atoi((*i = 0, p + 1));\\n}\\n\\nchar * complexNumberMultiply(char * a, char * b){\\n    char x, y, l, m, *p = calloc(1, 100);\\n    pi(a, &x, &y);\\n    pi(b, &l, &m);\\n    snprintf(p, 100, \"%d+%di\", x * l + -(y * m), x * m + y * l);\\n    return p;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 523563,
                "title": "java-clean-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String complexNumberMultiply(String a, String b) {\\n        return new Complex(a).mult(new Complex(b)).toStringFormat();\\n    }\\n    \\n    class Complex {\\n        int a;\\n        int b;\\n        \\n        Complex(String v) {\\n            String[] s = v.split(\"\\\\\\\\+\");\\n            this.a = Integer.parseInt(s[0]);\\n            this.b = Integer.parseInt(s[1].substring(0, s[1].length() - 1));\\n        }\\n        \\n        Complex(int a, int b) {\\n            this.a = a;\\n            this.b = b;\\n        }\\n        \\n        Complex mult(Complex c) {\\n            int a1 = a * c.a;\\n            int b1 = a * c.b;\\n            int b2 = b * c.a;\\n            int a2 = -(b * c.b);\\n            \\n            return new Complex(a1 + a2, b1 + b2);\\n        }\\n        \\n        String toStringFormat() {\\n            return String.format(\"%d+%di\", a, b);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String complexNumberMultiply(String a, String b) {\\n        return new Complex(a).mult(new Complex(b)).toStringFormat();\\n    }\\n    \\n    class Complex {\\n        int a;\\n        int b;\\n        \\n        Complex(String v) {\\n            String[] s = v.split(\"\\\\\\\\+\");\\n            this.a = Integer.parseInt(s[0]);\\n            this.b = Integer.parseInt(s[1].substring(0, s[1].length() - 1));\\n        }\\n        \\n        Complex(int a, int b) {\\n            this.a = a;\\n            this.b = b;\\n        }\\n        \\n        Complex mult(Complex c) {\\n            int a1 = a * c.a;\\n            int b1 = a * c.b;\\n            int b2 = b * c.a;\\n            int a2 = -(b * c.b);\\n            \\n            return new Complex(a1 + a2, b1 + b2);\\n        }\\n        \\n        String toStringFormat() {\\n            return String.format(\"%d+%di\", a, b);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499284,
                "title": "python-cute-solution",
                "content": "```\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        a = ComplexNum(a)\\n        b = ComplexNum(b)\\n        re = a.re * b.re - (a.im * b.im) \\n        im = a.re * b.im + a.im * b.re\\n        return str(re)+\\'+\\'+str(im) + \\'i\\'\\n        \\nclass ComplexNum:\\n    def __init__(self, strr):\\n        parsed = strr.split(\\'+\\')\\n        self.re = int(parsed[0])\\n        self.im = int(parsed[1][:-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        a = ComplexNum(a)\\n        b = ComplexNum(b)\\n        re = a.re * b.re - (a.im * b.im) \\n        im = a.re * b.im + a.im * b.re\\n        return str(re)+\\'+\\'+str(im) + \\'i\\'\\n        \\nclass ComplexNum:\\n    def __init__(self, strr):\\n        parsed = strr.split(\\'+\\')\\n        self.re = int(parsed[0])\\n        self.im = int(parsed[1][:-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485289,
                "title": "python-3-90-100-easy-code",
                "content": "```\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        ca, cb = [int(x) for x in a[:-1].split(\\'+\\')], [int(x) for x in b[:-1].split(\\'+\\')]\\n        cp = [str(ca[0]*cb[0] - ca[1]*cb[1]), str(ca[0]*cb[1] + ca[1]*cb[0])]\\n        return \\'+\\'.join(cp) + \\'i\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        ca, cb = [int(x) for x in a[:-1].split(\\'+\\')], [int(x) for x in b[:-1].split(\\'+\\')]\\n        cp = [str(ca[0]*cb[0] - ca[1]*cb[1]), str(ca[0]*cb[1] + ca[1]*cb[0])]\\n        return \\'+\\'.join(cp) + \\'i\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458946,
                "title": "extremely-easy-to-understand-python-code",
                "content": "```\\n\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        def decode(s):\\n            temp=s.split(\\'+\\')\\n            return int(temp[0]), int(temp[1].replace(\\'i\\', \\'\\'))\\n        a1,a2=decode(a)\\n        b1,b2=decode(b)\\n        new1=a1*b1-a2*b2\\n        new2=a1*b2+b1*a2\\n        return str(new1)+\\'+\\'+str(new2)+\\'i\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def complexNumberMultiply(self, a: str, b: str) -> str:\\n        def decode(s):\\n            temp=s.split(\\'+\\')\\n            return int(temp[0]), int(temp[1].replace(\\'i\\', \\'\\'))\\n        a1,a2=decode(a)\\n        b1,b2=decode(b)\\n        new1=a1*b1-a2*b2\\n        new2=a1*b2+b1*a2\\n        return str(new1)+\\'+\\'+str(new2)+\\'i\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399854,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar complexNumberMultiply = function(a, b) {\\n    const process = (x) => {\\n        x = x.split(\\'+\\');\\n        const a = x[0];\\n        const b = x[1].slice(0, -1);\\n        return [a, b];\\n    }\\n    const aa = process(a);\\n    const bb = process(b);\\n    const xx = aa[0] * bb[0] - aa[1] * bb[1];\\n    const yy = aa[0] * bb[1] + aa[1] * bb[0];\\n    return `${xx}+${yy}i`;\\n};\\n```\\nTaken from [here](https://helloacm.com/the-complex-number-multiplication-function/)",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar complexNumberMultiply = function(a, b) {\\n    const process = (x) => {\\n        x = x.split(\\'+\\');\\n        const a = x[0];\\n        const b = x[1].slice(0, -1);\\n        return [a, b];\\n    }\\n    const aa = process(a);\\n    const bb = process(b);\\n    const xx = aa[0] * bb[0] - aa[1] * bb[1];\\n    const yy = aa[0] * bb[1] + aa[1] * bb[0];\\n    return `${xx}+${yy}i`;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383682,
                "title": "c-beats-100-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int, int> getNumbers(string & S)\\n    {\\n        int i = 0;\\n        for(; S[i] != \\'+\\'; ++i);\\n        int a = stoi(S.substr(0, i++));\\n        int b = stoi(S.substr(i, S.size() - i - 1));\\n        return {a, b};\\n    }\\n    string complexNumberMultiply(string a, string b)\\n    {\\n        auto first = getNumbers(a);\\n        auto second = getNumbers(b);\\n        return to_string(first.first * second.first - first.second * second.second) + \"+\" + to_string(first.first * second.second + first.second * second.first) + \"i\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int, int> getNumbers(string & S)\\n    {\\n        int i = 0;\\n        for(; S[i] != \\'+\\'; ++i);\\n        int a = stoi(S.substr(0, i++));\\n        int b = stoi(S.substr(i, S.size() - i - 1));\\n        return {a, b};\\n    }\\n    string complexNumberMultiply(string a, string b)\\n    {\\n        auto first = getNumbers(a);\\n        auto second = getNumbers(b);\\n        return to_string(first.first * second.first - first.second * second.second) + \"+\" + to_string(first.first * second.second + first.second * second.first) + \"i\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 215564,
                "title": "rust-solution",
                "content": "```Rust\\nimpl Solution {\\n    pub fn complex_number_multiply(a: String, b: String) -> String {\\n        let a_num = a.trim_end_matches(\"i\").split(\\'+\\').collect::<Vec<&str>>();\\n        let b_num = b.trim_end_matches(\"i\").split(\\'+\\').collect::<Vec<&str>>();\\n        \\n        let a_real = a_num[0].parse::<i32>().unwrap();\\n        let a_img = a_num[1].parse::<i32>().unwrap();\\n        let b_real = b_num[0].parse::<i32>().unwrap();\\n        let b_img = b_num[1].parse::<i32>().unwrap();\\n        \\n        return format!(\"{}+{}i\", (a_real * b_real - a_img * b_img), (a_real * b_img + a_img * b_real));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn complex_number_multiply(a: String, b: String) -> String {\\n        let a_num = a.trim_end_matches(\"i\").split(\\'+\\').collect::<Vec<&str>>();\\n        let b_num = b.trim_end_matches(\"i\").split(\\'+\\').collect::<Vec<&str>>();\\n        \\n        let a_real = a_num[0].parse::<i32>().unwrap();\\n        let a_img = a_num[1].parse::<i32>().unwrap();\\n        let b_real = b_num[0].parse::<i32>().unwrap();\\n        let b_img = b_num[1].parse::<i32>().unwrap();\\n        \\n        return format!(\"{}+{}i\", (a_real * b_real - a_img * b_img), (a_real * b_img + a_img * b_real));\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 180297,
                "title": "c-tiny-complexint-type-100",
                "content": "I created a tiny ComplexInt type for this problem, which simplified things for myself.\\n\\n```cpp\\nstruct ComplexInt {\\n    int real;\\n    int imag;\\n    \\n    ComplexInt(string c) {\\n        int ppos = 0;\\n        while(c[ppos] != \\'+\\') ppos += 1;\\n        real = stoi(c.substr(0, ppos));\\n        imag = stoi(c.substr(ppos + 1, c.size() - ppos - 2)); // start after \\'+\\' and end before \\'i\\'\\n    }\\n    \\n    ComplexInt(int r, int i) : real(r), imag(i) {}\\n    \\n    string ToString() {\\n        return to_string(real) + \"+\" + to_string(imag) + \"i\";\\n    }\\n    \\n    ComplexInt operator *(const ComplexInt& rhs) const {\\n        return ComplexInt((real * rhs.real) - (imag * rhs.imag), (real * rhs.imag) + (imag * rhs.real));\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        return (ComplexInt(a) * ComplexInt(b)).ToString();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstruct ComplexInt {\\n    int real;\\n    int imag;\\n    \\n    ComplexInt(string c) {\\n        int ppos = 0;\\n        while(c[ppos] != \\'+\\') ppos += 1;\\n        real = stoi(c.substr(0, ppos));\\n        imag = stoi(c.substr(ppos + 1, c.size() - ppos - 2)); // start after \\'+\\' and end before \\'i\\'\\n    }\\n    \\n    ComplexInt(int r, int i) : real(r), imag(i) {}\\n    \\n    string ToString() {\\n        return to_string(real) + \"+\" + to_string(imag) + \"i\";\\n    }\\n    \\n    ComplexInt operator *(const ComplexInt& rhs) const {\\n        return ComplexInt((real * rhs.real) - (imag * rhs.imag), (real * rhs.imag) + (imag * rhs.real));\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        return (ComplexInt(a) * ComplexInt(b)).ToString();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168560,
                "title": "functional-js-solution",
                "content": "```\\nconst complexNumberMultiply = (a, b) =>\\n    ((a, b) => String((a[0] * b[0]) - (a[1] * b[1]))\\n\\t\\t+ \\'+\\'\\n\\t\\t+ String((a[0] * b[1]) + (a[1] * b[0]))\\n\\t\\t+ \\'i\\'\\n    )(...[a, b].map(str => str.slice(0, -1).split(\\'+\\')));\\n```\\nMy JavaScript solution using a single pure function. Type casting helpers are first defined to convert the string into a 2D vector of real and complex values, stored as an Array of Numbers.\\n\\nI then do the complex multiplication, calculating real and imaginary parts separately, to form a new vector.\\n\\nThen I typecast it back to String for the problem specifications.",
                "solutionTags": [],
                "code": "```\\nconst complexNumberMultiply = (a, b) =>\\n    ((a, b) => String((a[0] * b[0]) - (a[1] * b[1]))\\n\\t\\t+ \\'+\\'\\n\\t\\t+ String((a[0] * b[1]) + (a[1] * b[0]))\\n\\t\\t+ \\'i\\'\\n    )(...[a, b].map(str => str.slice(0, -1).split(\\'+\\')));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 156660,
                "title": "2-lines-c-solution-with-regex",
                "content": "```\\npublic string ComplexNumberMultiply(string a, string b) {\\n    var n = Regex.Split(a + b, @\"\\\\+|i\").Take(4).Select(int.Parse).ToArray();\\n    return $\"{n[0] * n[2] - n[1] * n[3]}+{n[0] * n[3] + n[1] * n[2]}i\";\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic string ComplexNumberMultiply(string a, string b) {\\n    var n = Regex.Split(a + b, @\"\\\\+|i\").Take(4).Select(int.Parse).ToArray();\\n    return $\"{n[0] * n[2] - n[1] * n[3]}+{n[0] * n[3] + n[1] * n[2]}i\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 156634,
                "title": "6-lines-c-solutions-using-regex-stringstream",
                "content": "Using regular expression:\\n```\\nstring complexNumberMultiply(string a, string b) {\\n    smatch ma, mb;\\n    regex pattern(R\"((-?\\\\d+)\\\\+(-?\\\\d+)i)\");\\n    regex_match(a, ma, pattern);\\n    regex_match(b, mb, pattern);\\n    int r1 = stoi(ma[1]), i1 = stoi(ma[2]), r2 = stoi(mb[1]), i2 = stoi(mb[2]);\\n    return to_string(r1 * r2 - i1 * i2) + \\'+\\' + to_string(r1 * i2 + r2 * i1) + \\'i\\';\\n}\\n```\\nUsing i/o stringstream:\\n```\\nstring complexNumberMultiply(string a, string b) {\\n    stringstream is(a + b), os;\\n    int r1, i1, r2, i2;\\n    char ch;\\n    is >> r1 >> ch >> i1 >> ch >> r2 >> ch >> i2;\\n    os << r1 * r2 - i1 * i2 << \\'+\\' << r1 * i2 + r2 * i1 << \\'i\\';\\n    return os.str();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring complexNumberMultiply(string a, string b) {\\n    smatch ma, mb;\\n    regex pattern(R\"((-?\\\\d+)\\\\+(-?\\\\d+)i)\");\\n    regex_match(a, ma, pattern);\\n    regex_match(b, mb, pattern);\\n    int r1 = stoi(ma[1]), i1 = stoi(ma[2]), r2 = stoi(mb[1]), i2 = stoi(mb[2]);\\n    return to_string(r1 * r2 - i1 * i2) + \\'+\\' + to_string(r1 * i2 + r2 * i1) + \\'i\\';\\n}\\n```\n```\\nstring complexNumberMultiply(string a, string b) {\\n    stringstream is(a + b), os;\\n    int r1, i1, r2, i2;\\n    char ch;\\n    is >> r1 >> ch >> i1 >> ch >> r2 >> ch >> i2;\\n    os << r1 * r2 - i1 * i2 << \\'+\\' << r1 * i2 + r2 * i1 << \\'i\\';\\n    return os.str();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 129342,
                "title": "simple-java-solution",
                "content": "```\\npublic static String complexNumberMultiply(String a, String b) {\\n        String[]arr1 = a.substring(0, a.length()-1).split(\"\\\\\\\\+\");\\n        String[]arr2 = b.substring(0,b.length()-1).split(\"\\\\\\\\+\");\\n        int real = Integer.valueOf(arr1[0])*Integer.valueOf(arr2[0]) - Integer.valueOf(arr1[1])*Integer.valueOf(arr2[1]);\\n        int imaginary = Integer.valueOf(arr1[0])*Integer.valueOf(arr2[1]) + Integer.valueOf(arr1[1])*Integer.valueOf(arr2[0]);\\n        String sign = \"\";\\n        return real+\"+\"+sign+imaginary+\"i\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static String complexNumberMultiply(String a, String b) {\\n        String[]arr1 = a.substring(0, a.length()-1).split(\"\\\\\\\\+\");\\n        String[]arr2 = b.substring(0,b.length()-1).split(\"\\\\\\\\+\");\\n        int real = Integer.valueOf(arr1[0])*Integer.valueOf(arr2[0]) - Integer.valueOf(arr1[1])*Integer.valueOf(arr2[1]);\\n        int imaginary = Integer.valueOf(arr1[0])*Integer.valueOf(arr2[1]) + Integer.valueOf(arr1[1])*Integer.valueOf(arr2[0]);\\n        String sign = \"\";\\n        return real+\"+\"+sign+imaginary+\"i\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 127138,
                "title": "readable-c-with-oop",
                "content": "```\\npublic class Solution \\n{\\n    public struct ComplexNumber\\n    {\\n        public int A { get; set; }\\n        public int B { get; set; }\\n        \\n        public ComplexNumber(string input)\\n        {\\n            string[] equation = input.Split(\\'+\\');\\n            A = int.Parse(equation[0]);\\n            B = int.Parse(equation[1].Substring(0, equation[1].Length - 1));\\n        }\\n        \\n        public ComplexNumber(int a, int b)\\n        {\\n            A = a;\\n            B = b;\\n        }\\n        \\n        public static ComplexNumber operator *(ComplexNumber c1, ComplexNumber c2)\\n        {\\n           int aa = c1.A * c2.A;\\n           int ab = c1.A * c2.B; // i\\n           int ba = c1.B * c2.A; // i\\n           int bb = c1.B * c2.B; // i^2 = -1\\n                        \\n           int a = aa + (bb * -1);\\n           int b = ab + ba;\\n            \\n            return new ComplexNumber(a, b);\\n        }\\n        \\n        public override string ToString()\\n        {\\n            return $\"{A}+{B}i\";\\n        }\\n    }\\n    \\n    \\n    public string ComplexNumberMultiply(string a, string b) \\n    {\\n        ComplexNumber c1 = new ComplexNumber(a);\\n        ComplexNumber c2 = new ComplexNumber(b);\\n        \\n        ComplexNumber mult = c1 * c2;\\n        \\n        return mult.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public struct ComplexNumber\\n    {\\n        public int A { get; set; }\\n        public int B { get; set; }\\n        \\n        public ComplexNumber(string input)\\n        {\\n            string[] equation = input.Split(\\'+\\');\\n            A = int.Parse(equation[0]);\\n            B = int.Parse(equation[1].Substring(0, equation[1].Length - 1));\\n        }\\n        \\n        public ComplexNumber(int a, int b)\\n        {\\n            A = a;\\n            B = b;\\n        }\\n        \\n        public static ComplexNumber operator *(ComplexNumber c1, ComplexNumber c2)\\n        {\\n           int aa = c1.A * c2.A;\\n           int ab = c1.A * c2.B; // i\\n           int ba = c1.B * c2.A; // i\\n           int bb = c1.B * c2.B; // i^2 = -1\\n                        \\n           int a = aa + (bb * -1);\\n           int b = ab + ba;\\n            \\n            return new ComplexNumber(a, b);\\n        }\\n        \\n        public override string ToString()\\n        {\\n            return $\"{A}+{B}i\";\\n        }\\n    }\\n    \\n    \\n    public string ComplexNumberMultiply(string a, string b) \\n    {\\n        ComplexNumber c1 = new ComplexNumber(a);\\n        ComplexNumber c2 = new ComplexNumber(b);\\n        \\n        ComplexNumber mult = c1 * c2;\\n        \\n        return mult.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100441,
                "title": "java-oop-solution",
                "content": "```\\npublic class Solution {\\n    public class ComplexNumber {\\n        public int a;\\n        public int b;\\n        public ComplexNumber(int a, int b) {\\n            this.a = a;\\n            this.b = b;\\n        }\\n        public ComplexNumber(String s) {\\n            String[] tokens = s.split(\"[+i]\");\\n            a = Integer.parseInt(tokens[0]);\\n            b = Integer.parseInt(tokens[1]);\\n        }\\n        public ComplexNumber multiply(ComplexNumber o) {\\n            return new ComplexNumber(this.a * o.a - this.b * o.b, this.a * o.b + this.b * o.a);\\n        }\\n        public String toString() {\\n            return String.format(\"%d+%di\", a, b);    \\n        }\\n    }\\n    \\n    public String complexNumberMultiply(String a, String b) {\\n        ComplexNumber ca = new ComplexNumber(a);\\n        ComplexNumber cb = new ComplexNumber(b);\\n        return ca.multiply(cb).toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public class ComplexNumber {\\n        public int a;\\n        public int b;\\n        public ComplexNumber(int a, int b) {\\n            this.a = a;\\n            this.b = b;\\n        }\\n        public ComplexNumber(String s) {\\n            String[] tokens = s.split(\"[+i]\");\\n            a = Integer.parseInt(tokens[0]);\\n            b = Integer.parseInt(tokens[1]);\\n        }\\n        public ComplexNumber multiply(ComplexNumber o) {\\n            return new ComplexNumber(this.a * o.a - this.b * o.b, this.a * o.b + this.b * o.a);\\n        }\\n        public String toString() {\\n            return String.format(\"%d+%di\", a, b);    \\n        }\\n    }\\n    \\n    public String complexNumberMultiply(String a, String b) {\\n        ComplexNumber ca = new ComplexNumber(a);\\n        ComplexNumber cb = new ComplexNumber(b);\\n        return ca.multiply(cb).toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100448,
                "title": "python-3-oop-solution-with-multiplication-overriding",
                "content": "```python\\nclass Complex(object):\\n    def __init__(self, real, imaginary):\\n        self.real = real\\n        self.imaginary = imaginary\\n    \\n    def __mul__(self, other):\\n        #assuming other is a Complex object. Though we can run a check if we want\\n        real = (self.real*other.real - self.imaginary*other.imaginary)\\n        imaginary = (self.real*other.imaginary+other.real*self.imaginary)\\n        return Complex(real, imaginary)\\n        \\n    @staticmethod\\n    def from_string(text):\\n        parts = text.split('+')\\n        real = int(parts[0])\\n        imaginary = int(parts[1][:-1])\\n        return Complex(real, imaginary)\\n        \\n    def __repr__(self):\\n        return \"{}+{}i\".format(self.real, self.imaginary)\\n        \\nclass Solution(object):\\n    def complexNumberMultiply(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: str\\n        \"\"\"\\n        a = Complex.from_string(a)\\n        b = Complex.from_string(b)\\n        return str(a*b)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Complex(object):\\n    def __init__(self, real, imaginary):\\n        self.real = real\\n        self.imaginary = imaginary\\n    \\n    def __mul__(self, other):\\n        #assuming other is a Complex object. Though we can run a check if we want\\n        real = (self.real*other.real - self.imaginary*other.imaginary)\\n        imaginary = (self.real*other.imaginary+other.real*self.imaginary)\\n        return Complex(real, imaginary)\\n        \\n    @staticmethod\\n    def from_string(text):\\n        parts = text.split('+')\\n        real = int(parts[0])\\n        imaginary = int(parts[1][:-1])\\n        return Complex(real, imaginary)\\n        \\n    def __repr__(self):\\n        return \"{}+{}i\".format(self.real, self.imaginary)\\n        \\nclass Solution(object):\\n    def complexNumberMultiply(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: str\\n        \"\"\"\\n        a = Complex.from_string(a)\\n        b = Complex.from_string(b)\\n        return str(a*b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100451,
                "title": "javascript-simple-solution",
                "content": "match the `a + bi` pattern, so there must be only 1 `+` sign. split and then parse numbers.\\n\\n**javascript solution**\\n\\n```js\\nconst matchVars = (str) => str.slice(0, -1).split('+').map(n => Number.parseInt(n, 10))\\n\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nconst complexNumberMultiply = function(a, b) {\\n  const [arl, aim] = matchVars(a)\\n  const [brl, bim] = matchVars(b)\\n\\n  const [r, i] = [arl * brl + aim * bim * -1, arl * bim + aim * brl]\\n  return `${r}+${i}i`\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nconst matchVars = (str) => str.slice(0, -1).split('+').map(n => Number.parseInt(n, 10))\\n\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nconst complexNumberMultiply = function(a, b) {\\n  const [arl, aim] = matchVars(a)\\n  const [brl, bim] = matchVars(b)\\n\\n  const [r, i] = [arl * brl + aim * bim * -1, arl * bim + aim * brl]\\n  return `${r}+${i}i`\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 100452,
                "title": "python-regex-solution",
                "content": "\\n```\\n\\t\\timport re\\n\\t\\tpattern = '([-]?\\\\d+)\\\\+([-]?\\\\d+)i'\\n\\t\\tmatch = re.search(pattern, a)\\n\\t\\tx,y = int(match.group(1)),int(match.group(2))\\n\\t\\tmatch = re.search(pattern, b)\\n\\t\\tm,n = int(match.group(1)),int(match.group(2))\\n\\t\\treturn '%d+%di'%(x*m-y*n, y*m+x*n)\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\timport re\\n\\t\\tpattern = '([-]?\\\\d+)\\\\+([-]?\\\\d+)i'\\n\\t\\tmatch = re.search(pattern, a)\\n\\t\\tx,y = int(match.group(1)),int(match.group(2))\\n\\t\\tmatch = re.search(pattern, b)\\n\\t\\tm,n = int(match.group(1)),int(match.group(2))\\n\\t\\treturn '%d+%di'%(x*m-y*n, y*m+x*n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 100454,
                "title": "python-2-lines",
                "content": "```\\nclass Solution(object):\\n    def complexNumberMultiply(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: str\\n        \"\"\"\\n        (ar, ac), (br, bc) = map(int, a[:-1].split(\"+\")), map(int, b[:-1].split(\"+\"))\\n        return \"{}+{}i\".format(str(ar*br - ac*bc), str(ar*bc + br*ac))\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def complexNumberMultiply(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: str\\n        \"\"\"\\n        (ar, ac), (br, bc) = map(int, a[:-1].split(\"+\")), map(int, b[:-1].split(\"+\"))\\n        return \"{}+{}i\".format(str(ar*br - ac*bc), str(ar*bc + br*ac))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 100474,
                "title": "c-solution-with-sscanf-snprintf-strdup",
                "content": "```\\n#define FORMAT \"%d+%di\"\\n#define BUF_SIZE 128\\n\\nchar* complexNumberMultiply(char* a, char* b) {\\n\\tint a1, a2, b1, b2;\\n\\tchar buf[BUF_SIZE];\\n\\tsscanf(a, FORMAT, &a1, &a2);\\n\\tsscanf(b, FORMAT, &b1, &b2);\\n\\tsnprintf(buf, BUF_SIZE, FORMAT, a1 * b1 - a2 * b2, a1 * b2 + a2 * b1);\\n\\treturn strdup(buf);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#define FORMAT \"%d+%di\"\\n#define BUF_SIZE 128\\n\\nchar* complexNumberMultiply(char* a, char* b) {\\n\\tint a1, a2, b1, b2;\\n\\tchar buf[BUF_SIZE];\\n\\tsscanf(a, FORMAT, &a1, &a2);\\n\\tsscanf(b, FORMAT, &b1, &b2);\\n\\tsnprintf(buf, BUF_SIZE, FORMAT, a1 * b1 - a2 * b2, a1 * b2 + a2 * b1);\\n\\treturn strdup(buf);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 100438,
                "title": "0-ms-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        // (a1 + a2 i) * (b1 + b2 i) = (a1b1 - a2b2) + (a1b2 + a2b1) i\\n        size_t pos = a.find('+');\\n        int a1 = stoi(a.substr(0, pos)), a2 = stoi(a.substr(pos + 1, a.size() - pos - 2));\\n        pos = b.find('+');\\n        int b1 = stoi(b.substr(0, pos)), b2 = stoi(b.substr(pos + 1, b.size() - pos - 2));\\n        int c1 = a1 * b1 - a2 * b2, c2 = a1 * b2 + a2 * b1;\\n        return to_string(c1) + \"+\" + to_string(c2) + \"i\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        // (a1 + a2 i) * (b1 + b2 i) = (a1b1 - a2b2) + (a1b2 + a2b1) i\\n        size_t pos = a.find('+');\\n        int a1 = stoi(a.substr(0, pos)), a2 = stoi(a.substr(pos + 1, a.size() - pos - 2));\\n        pos = b.find('+');\\n        int b1 = stoi(b.substr(0, pos)), b2 = stoi(b.substr(pos + 1, b.size() - pos - 2));\\n        int c1 = a1 * b1 - a2 * b2, c2 = a1 * b2 + a2 * b1;\\n        return to_string(c1) + \"+\" + to_string(c2) + \"i\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100497,
                "title": "java-solution-cross-products",
                "content": "```\\npublic class Solution {\\n    public String complexNumberMultiply(String a, String b) {\\n        int[] aa = parseComplex(a);\\n        int[] bb = parseComplex(b);\\n        \\n        int real = aa[0] * bb[0] - aa[1] * bb[1];\\n        int imag = aa[0] * bb[1] + aa[1] * bb[0];\\n        \\n        String result = real + \"+\" + imag + \"i\";\\n        \\n        return result;\\n    }\\n    \\n    private int[] parseComplex(String s) {\\n        int[] res = new int[2];\\n        \\n        int i = 0, j = 1;\\n        while (j < s.length() && s.charAt(j) != '+') j++;\\n        res[0] = Integer.parseInt(s.substring(i, j));\\n        \\n        j++; i = j;\\n        while (j < s.length() && s.charAt(j) != 'i') j++;\\n        res[1] = Integer.parseInt(s.substring(i, j));\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String complexNumberMultiply(String a, String b) {\\n        int[] aa = parseComplex(a);\\n        int[] bb = parseComplex(b);\\n        \\n        int real = aa[0] * bb[0] - aa[1] * bb[1];\\n        int imag = aa[0] * bb[1] + aa[1] * bb[0];\\n        \\n        String result = real + \"+\" + imag + \"i\";\\n        \\n        return result;\\n    }\\n    \\n    private int[] parseComplex(String s) {\\n        int[] res = new int[2];\\n        \\n        int i = 0, j = 1;\\n        while (j < s.length() && s.charAt(j) != '+') j++;\\n        res[0] = Integer.parseInt(s.substring(i, j));\\n        \\n        j++; i = j;\\n        while (j < s.length() && s.charAt(j) != 'i') j++;\\n        res[1] = Integer.parseInt(s.substring(i, j));\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086701,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} num1\\n * @param {string} num2\\n * @return {string}\\n */\\nvar complexNumberMultiply = function(num1, num2) {\\n    num1 = num1.split(\\'+\\');\\n    num2 = num2.split(\\'+\\');\\n    \\n    num1[1] = num1[1].substring(0, num1[1].length - 1);\\n    num2[1] = num2[1].substring(0, num2[1].length - 1);\\n    \\n    let a = (Number(num1[0]) * Number(num2[0])) + (Number(num1[1]) * Number(num2[1]) * -1);\\n    let b = (Number(num1[0]) * Number(num2[1])) + Number(num1[1]) * Number(num2[0]);\\n    \\n    return a + \\'+\\' + b + \\'i\\';\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num1\\n * @param {string} num2\\n * @return {string}\\n */\\nvar complexNumberMultiply = function(num1, num2) {\\n    num1 = num1.split(\\'+\\');\\n    num2 = num2.split(\\'+\\');\\n    \\n    num1[1] = num1[1].substring(0, num1[1].length - 1);\\n    num2[1] = num2[1].substring(0, num2[1].length - 1);\\n    \\n    let a = (Number(num1[0]) * Number(num2[0])) + (Number(num1[1]) * Number(num2[1]) * -1);\\n    let b = (Number(num1[0]) * Number(num2[1])) + Number(num1[1]) * Number(num2[0]);\\n    \\n    return a + \\'+\\' + b + \\'i\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060097,
                "title": "java-two-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        int plusId1 = num1.indexOf(\\'+\\'), plusId2 = num2.indexOf(\\'+\\'), r1 = Integer.parseInt(num1.substring(0, plusId1)), r2 = Integer.parseInt(num2.substring(0, plusId2)), i1 = Integer.parseInt(num1.substring(plusId1+1, num1.length() - 1)), i2 = Integer.parseInt(num2.substring(plusId2+1, num2.length() - 1));\\n        return Integer.toString(r1 * r2 - i1 * i2) + \"+\" + Integer.toString(r1 * i2 + r2 * i1) + \"i\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        int plusId1 = num1.indexOf(\\'+\\'), plusId2 = num2.indexOf(\\'+\\'), r1 = Integer.parseInt(num1.substring(0, plusId1)), r2 = Integer.parseInt(num2.substring(0, plusId2)), i1 = Integer.parseInt(num1.substring(plusId1+1, num1.length() - 1)), i2 = Integer.parseInt(num2.substring(plusId2+1, num2.length() - 1));\\n        return Integer.toString(r1 * r2 - i1 * i2) + \"+\" + Integer.toString(r1 * i2 + r2 * i1) + \"i\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047777,
                "title": "easiest-solution-with-constant-time-complexity-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        StringBuilder sb = new StringBuilder();\\n\\n// for num1 = a + bi --> real1 = a && img1 = b\\n        int real1 = Integer.parseInt(num1.substring(0,num1.indexOf(\\'+\\')));\\n        int img1 = Integer.parseInt(num1.substring(num1.indexOf(\\'+\\')+1, num1.indexOf(\\'i\\')));\\n\\n// for num2 = a + bi --> real2 = a && img2 = b\\n        int real2 = Integer.parseInt(num2.substring(0,num2.indexOf(\\'+\\')));\\n        int img2 = Integer.parseInt(num2.substring(num2.indexOf(\\'+\\')+1, num2.indexOf(\\'i\\')));\\n\\n        sb.append(real1*real2 - img1*img2); //\\n        sb.append(\\'+\\' + \"\");\\n        sb.append(img1*real2 + img2*real1);\\n        sb.append(\\'i\\');\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        StringBuilder sb = new StringBuilder();\\n\\n// for num1 = a + bi --> real1 = a && img1 = b\\n        int real1 = Integer.parseInt(num1.substring(0,num1.indexOf(\\'+\\')));\\n        int img1 = Integer.parseInt(num1.substring(num1.indexOf(\\'+\\')+1, num1.indexOf(\\'i\\')));\\n\\n// for num2 = a + bi --> real2 = a && img2 = b\\n        int real2 = Integer.parseInt(num2.substring(0,num2.indexOf(\\'+\\')));\\n        int img2 = Integer.parseInt(num2.substring(num2.indexOf(\\'+\\')+1, num2.indexOf(\\'i\\')));\\n\\n        sb.append(real1*real2 - img1*img2); //\\n        sb.append(\\'+\\' + \"\");\\n        sb.append(img1*real2 + img2*real1);\\n        sb.append(\\'i\\');\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037410,
                "title": "easy-c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        int a,b,c,d;\\n        int pi1=num1.find(\\'+\\');\\n        a=stoi(num1.substr(0,pi1));\\n        b=stoi(num1.substr(pi1+1,num1.size()-2-pi1));\\n        int pi2=num2.find(\\'+\\');\\n        c=stoi(num2.substr(0,pi2));\\n        d=stoi(num2.substr(pi2+1,num2.size()-2-pi2));\\n        return to_string(a*c - b*d) + \"+\" + to_string(a*d + b*c) + \"i\";\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F IF YOU LIKE THE SOLUTION !!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        int a,b,c,d;\\n        int pi1=num1.find(\\'+\\');\\n        a=stoi(num1.substr(0,pi1));\\n        b=stoi(num1.substr(pi1+1,num1.size()-2-pi1));\\n        int pi2=num2.find(\\'+\\');\\n        c=stoi(num2.substr(0,pi2));\\n        d=stoi(num2.substr(pi2+1,num2.size()-2-pi2));\\n        return to_string(a*c - b*d) + \"+\" + to_string(a*d + b*c) + \"i\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026050,
                "title": "clean-and-intuitive-java-code-with-and-without-split-split-indexof-math-explained-easy",
                "content": "# Math :\\n```\\n\\nc1=a1+ib1 and c2=a2+ib2\\n\\nc1*c2=(a1+ib1)*(a2+ib2)\\n\\nc1*c2=a1*(a2+ib2)+ib1*(a2+ib2)\\n\\nc1*c2=a1*a2 + i*a1*b2 + i*a2*b1 + i^2*b1*b2\\n\\nc1*c2=a1*a2 + i*a1*b2 + 1*a2*b1 - b1*b2    (i^2=-1)\\n\\nc1*c2= (a1*a2 - b1*b2) + i(a1*b2 + a2*b1)\\n\\nReal part = (a1*a2 - b1*b2)\\n\\nImaginary Part = (a1*b2 + a2*b1)\\n\\n```\\n\\n# Code\\n\\n```\\n//Using .split() Method\\n\\n//Intuitive Implementation\\n\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        String[] arr1=num1.split(\"\\\\\\\\+\");\\n        String[] arr2=num2.split(\"\\\\\\\\+\");\\n        \\n        int a1=Integer.parseInt(arr1[0]); \\n        int a2=Integer.parseInt(arr2[0]);\\n        \\n        int idx=arr1[1].indexOf(\"i\");\\n        String subStr1=arr1[1].substring(0,idx);\\n        int b1=Integer. parseInt(subStr1); \\n        \\n                \\n        idx=arr2[1].indexOf(\"i\");\\n        String subStr2=arr2[1].substring(0,idx);\\n        int b2=Integer. parseInt(subStr2);\\n        \\n        int real=(a1*a2)-(b1*b2);\\n        int imaginary=(a1*b2)+(a2*b1);\\n        \\n        String res=real+\"+\"+imaginary+\"i\";\\n        return res;\\n    }\\n}\\n\\n\\n//Optimised Implementation\\n\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        String[] arr1=num1.split(\"\\\\\\\\+\");\\n        String[] arr2=num2.split(\"\\\\\\\\+\");\\n        \\n        int a1=Integer. parseInt(arr1[0]); \\n        int a2=Integer. parseInt(arr2[0]);\\n        \\n        int b1=Integer. parseInt(arr1[1].substring(0,arr1[1].indexOf(\"i\"))); \\n        int b2=Integer. parseInt(arr2[1].substring(0,arr2[1].indexOf(\"i\"))); \\n                \\n        int real=(a1*a2)-(b1*b2);\\n        int imaginary=(a1*b2)+(a2*b1);\\n        \\n        String res=real+\"+\"+imaginary+\"i\";\\n        return res;\\n    }\\n}\\n\\n```\\n\\n```\\n//Without .split() Method\\n\\n//Intuitive Implementation\\n\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        int idx1=num1.indexOf(\"+\");\\n        String str1=num1.substring(0,idx1);\\n        \\n        int idx2=num1.indexOf(\"i\");\\n        String str2=num1.substring(idx1+1,idx2);\\n        \\n        idx1=num2.indexOf(\"+\");\\n        String str3=num2.substring(0,idx1);\\n        \\n        idx2=num2.indexOf(\"i\");\\n        String str4=num2.substring(idx1+1,idx2);\\n        \\n        \\n        int a1=Integer. parseInt(str1); \\n        int a2=Integer. parseInt(str3);\\n        \\n     \\n        int b1=Integer. parseInt(str2);\\n        int b2=Integer. parseInt(str4); \\n                \\n        int real=(a1*a2)-(b1*b2);\\n        int imaginary=(a1*b2)+(a2*b1);\\n        \\n        String res=real+\"+\"+imaginary+\"i\";\\n        return res;\\n    }\\n}\\n\\n\\n//Optimised Implementation\\n\\n\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        int a1=Integer. parseInt(num1.substring(0,num1.indexOf(\"+\"))); \\n        int a2=Integer. parseInt(num2.substring(0,num2.indexOf(\"+\")));\\n        \\n     \\n        int b1=Integer. parseInt(num1.substring(num1.indexOf(\"+\")+1,num1.indexOf(\"i\")));\\n        int b2=Integer. parseInt(num2.substring(num2.indexOf(\"+\")+1,num2.indexOf(\"i\"))); \\n                \\n        int real=(a1*a2)-(b1*b2);\\n        int imaginary=(a1*b2)+(a2*b1);\\n        \\n        String res=real+\"+\"+imaginary+\"i\";\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "String",
                    "String Matching"
                ],
                "code": "```\\n\\nc1=a1+ib1 and c2=a2+ib2\\n\\nc1*c2=(a1+ib1)*(a2+ib2)\\n\\nc1*c2=a1*(a2+ib2)+ib1*(a2+ib2)\\n\\nc1*c2=a1*a2 + i*a1*b2 + i*a2*b1 + i^2*b1*b2\\n\\nc1*c2=a1*a2 + i*a1*b2 + 1*a2*b1 - b1*b2    (i^2=-1)\\n\\nc1*c2= (a1*a2 - b1*b2) + i(a1*b2 + a2*b1)\\n\\nReal part = (a1*a2 - b1*b2)\\n\\nImaginary Part = (a1*b2 + a2*b1)\\n\\n```\n```\\n//Using .split() Method\\n\\n//Intuitive Implementation\\n\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        String[] arr1=num1.split(\"\\\\\\\\+\");\\n        String[] arr2=num2.split(\"\\\\\\\\+\");\\n        \\n        int a1=Integer.parseInt(arr1[0]); \\n        int a2=Integer.parseInt(arr2[0]);\\n        \\n        int idx=arr1[1].indexOf(\"i\");\\n        String subStr1=arr1[1].substring(0,idx);\\n        int b1=Integer. parseInt(subStr1); \\n        \\n                \\n        idx=arr2[1].indexOf(\"i\");\\n        String subStr2=arr2[1].substring(0,idx);\\n        int b2=Integer. parseInt(subStr2);\\n        \\n        int real=(a1*a2)-(b1*b2);\\n        int imaginary=(a1*b2)+(a2*b1);\\n        \\n        String res=real+\"+\"+imaginary+\"i\";\\n        return res;\\n    }\\n}\\n\\n\\n//Optimised Implementation\\n\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        String[] arr1=num1.split(\"\\\\\\\\+\");\\n        String[] arr2=num2.split(\"\\\\\\\\+\");\\n        \\n        int a1=Integer. parseInt(arr1[0]); \\n        int a2=Integer. parseInt(arr2[0]);\\n        \\n        int b1=Integer. parseInt(arr1[1].substring(0,arr1[1].indexOf(\"i\"))); \\n        int b2=Integer. parseInt(arr2[1].substring(0,arr2[1].indexOf(\"i\"))); \\n                \\n        int real=(a1*a2)-(b1*b2);\\n        int imaginary=(a1*b2)+(a2*b1);\\n        \\n        String res=real+\"+\"+imaginary+\"i\";\\n        return res;\\n    }\\n}\\n\\n```\n```\\n//Without .split() Method\\n\\n//Intuitive Implementation\\n\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        int idx1=num1.indexOf(\"+\");\\n        String str1=num1.substring(0,idx1);\\n        \\n        int idx2=num1.indexOf(\"i\");\\n        String str2=num1.substring(idx1+1,idx2);\\n        \\n        idx1=num2.indexOf(\"+\");\\n        String str3=num2.substring(0,idx1);\\n        \\n        idx2=num2.indexOf(\"i\");\\n        String str4=num2.substring(idx1+1,idx2);\\n        \\n        \\n        int a1=Integer. parseInt(str1); \\n        int a2=Integer. parseInt(str3);\\n        \\n     \\n        int b1=Integer. parseInt(str2);\\n        int b2=Integer. parseInt(str4); \\n                \\n        int real=(a1*a2)-(b1*b2);\\n        int imaginary=(a1*b2)+(a2*b1);\\n        \\n        String res=real+\"+\"+imaginary+\"i\";\\n        return res;\\n    }\\n}\\n\\n\\n//Optimised Implementation\\n\\n\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        int a1=Integer. parseInt(num1.substring(0,num1.indexOf(\"+\"))); \\n        int a2=Integer. parseInt(num2.substring(0,num2.indexOf(\"+\")));\\n        \\n     \\n        int b1=Integer. parseInt(num1.substring(num1.indexOf(\"+\")+1,num1.indexOf(\"i\")));\\n        int b2=Integer. parseInt(num2.substring(num2.indexOf(\"+\")+1,num2.indexOf(\"i\"))); \\n                \\n        int real=(a1*a2)-(b1*b2);\\n        int imaginary=(a1*b2)+(a2*b1);\\n        \\n        String res=real+\"+\"+imaginary+\"i\";\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021633,
                "title": "java-easy-logic-4-ms-only",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        int rl1 = Integer.parseInt(num1.substring(0, num1.indexOf(\\'+\\')));\\n        int rl2 = Integer.parseInt(num2.substring(0, num2.indexOf(\\'+\\')));\\n        int cmp1 = Integer.parseInt(num1.substring(num1.indexOf(\\'+\\')+1, num1.length()-1));\\n        int cmp2 = Integer.parseInt(num2.substring(num2.indexOf(\\'+\\')+1, num2.length()-1));\\n        int real = rl1*rl2-cmp1*cmp2;\\n        int complex = rl1*cmp2+rl2*cmp1;\\n        String as = Integer.toString(real)+\"+\"+Integer.toString(complex)+\"i\";\\n        return as;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        int rl1 = Integer.parseInt(num1.substring(0, num1.indexOf(\\'+\\')));\\n        int rl2 = Integer.parseInt(num2.substring(0, num2.indexOf(\\'+\\')));\\n        int cmp1 = Integer.parseInt(num1.substring(num1.indexOf(\\'+\\')+1, num1.length()-1));\\n        int cmp2 = Integer.parseInt(num2.substring(num2.indexOf(\\'+\\')+1, num2.length()-1));\\n        int real = rl1*rl2-cmp1*cmp2;\\n        int complex = rl1*cmp2+rl2*cmp1;\\n        String as = Integer.toString(real)+\"+\"+Integer.toString(complex)+\"i\";\\n        return as;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012019,
                "title": "46ms-41-95mb-javascript-solution-beats-92-60",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} num1\\n * @param {string} num2\\n * @return {string}\\n */\\nvar complexNumberMultiply = function(num1, num2) {\\n    const [a1, a2] = num1.split(\\'+\\')\\n    const [b1, b2] = num2.split(\\'+\\')\\n\\n    let first = a1 * b1\\n    let second = a1 * b2.slice(0, -1)\\n    let third = a2.slice(0, -1) * b1\\n    let fourth = -a2.slice(0, -1) * b2.slice(0, -1)\\n\\n    return `${first + fourth}+${second + third}i`\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num1\\n * @param {string} num2\\n * @return {string}\\n */\\nvar complexNumberMultiply = function(num1, num2) {\\n    const [a1, a2] = num1.split(\\'+\\')\\n    const [b1, b2] = num2.split(\\'+\\')\\n\\n    let first = a1 * b1\\n    let second = a1 * b2.slice(0, -1)\\n    let third = a2.slice(0, -1) * b1\\n    let fourth = -a2.slice(0, -1) * b2.slice(0, -1)\\n\\n    return `${first + fourth}+${second + third}i`\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008031,
                "title": "small-string-stream-code-c",
                "content": "# Intuition\\nGiven two strings representing complex numbers, our task is to multiply them and return the result as a string. A complex number can be represented as a + bi, where a and b are real numbers and i is the imaginary unit. The product of two complex numbers (a + bi) * (c + di) can be calculated using the formula (ac - bd) + (ad + bc)i.\\n# Approach\\nParse the input strings to extract the real and imaginary parts of the complex numbers.\\nCalculate the real and imaginary parts of the product using the formula (ac - bd) + (ad + bc)i.\\nConstruct the result string in the format a + bi.\\nTo parse the input strings, we can use the stringstream class to read data from the strings into integer and character variables. We can then perform the multiplication and construct the result string using another stringstream.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        int a1, a2, b1, b2;\\n        char op;\\n        stringstream sa(a), sb(b), ans;\\n        sa >> a1 >> op >> a2 >> op;\\n        sb >> b1 >> op >> b2 >> op;\\n        ans << a1 * b1 - a2 * b2 << \"+\" << a1 * b2 + a2 * b1 << \"i\";\\n        return ans.str();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        int a1, a2, b1, b2;\\n        char op;\\n        stringstream sa(a), sb(b), ans;\\n        sa >> a1 >> op >> a2 >> op;\\n        sb >> b1 >> op >> b2 >> op;\\n        ans << a1 * b1 - a2 * b2 << \"+\" << a1 * b2 + a2 * b1 << \"i\";\\n        return ans.str();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996317,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPurely Intutive\\n\\n# Approach\\nString Traversal\\n\\n# Complexity\\n- Time complexity:\\n2*O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        int n1 =0, n2 =0, c1=0, c2=0, neg1=1, neg2 =1, neg3 =1, neg4=1;\\n        if(num1[0]==\\'-\\')\\n        neg1 =-1;\\n        if(num2[0]==\\'-\\')\\n        neg3 =-1;\\n        int f =0;\\n        for(int i=0;i<num1.size();i++)\\n        {\\n            if(num1[i]!=\\'+\\')\\n            {\\n                if(f==0)\\n                {\\n                    if(num1[i]!=\\'-\\')\\n                    n1 = n1*10 + num1[i]-\\'0\\';\\n                }\\n                else \\n                {\\n                    if(num1[i]==\\'-\\')\\n                    neg2=-1;\\n                    if(num1[i]!=\\'i\\' && num1[i]!=\\'-\\')\\n                    c1 = c1*10 + num1[i]-\\'0\\';\\n                }\\n            }\\n            else\\n            f=1;\\n        }\\n        f =0;\\n        for(int i=0;i<num2.size();i++)\\n        {\\n            if(num2[i]!=\\'+\\')\\n            {\\n                if(f==0)\\n                {\\n                    if(num2[i]!=\\'-\\')\\n                    n2 = n2*10 + num2[i]-\\'0\\';\\n                }\\n                else\\n                {\\n                    if(num2[i]==\\'-\\')\\n                    neg4=-1;\\n                    if(num2[i]!=\\'i\\' && num2[i]!=\\'-\\')\\n                    c2 = c2*10 + num2[i]-\\'0\\';\\n                }\\n            }\\n            else\\n            f=1;\\n        }\\n        n1 = n1* neg1;\\n        n2 = n2 * neg3;\\n        c1 = c1*neg2;\\n        c2 = c2*neg4;\\n        cout<<n1<<\" \"<<c1<<\" \"<<n2<<\" \"<<c2;\\n        int real = n1*n2 - c1*c2;\\n        int comp = n1*c2 + n2*c1;\\n        string ans =  to_string(real);\\n        string ans2 = \"+\"+ to_string(comp)+\"i\";\\n        ans= ans+ans2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        int n1 =0, n2 =0, c1=0, c2=0, neg1=1, neg2 =1, neg3 =1, neg4=1;\\n        if(num1[0]==\\'-\\')\\n        neg1 =-1;\\n        if(num2[0]==\\'-\\')\\n        neg3 =-1;\\n        int f =0;\\n        for(int i=0;i<num1.size();i++)\\n        {\\n            if(num1[i]!=\\'+\\')\\n            {\\n                if(f==0)\\n                {\\n                    if(num1[i]!=\\'-\\')\\n                    n1 = n1*10 + num1[i]-\\'0\\';\\n                }\\n                else \\n                {\\n                    if(num1[i]==\\'-\\')\\n                    neg2=-1;\\n                    if(num1[i]!=\\'i\\' && num1[i]!=\\'-\\')\\n                    c1 = c1*10 + num1[i]-\\'0\\';\\n                }\\n            }\\n            else\\n            f=1;\\n        }\\n        f =0;\\n        for(int i=0;i<num2.size();i++)\\n        {\\n            if(num2[i]!=\\'+\\')\\n            {\\n                if(f==0)\\n                {\\n                    if(num2[i]!=\\'-\\')\\n                    n2 = n2*10 + num2[i]-\\'0\\';\\n                }\\n                else\\n                {\\n                    if(num2[i]==\\'-\\')\\n                    neg4=-1;\\n                    if(num2[i]!=\\'i\\' && num2[i]!=\\'-\\')\\n                    c2 = c2*10 + num2[i]-\\'0\\';\\n                }\\n            }\\n            else\\n            f=1;\\n        }\\n        n1 = n1* neg1;\\n        n2 = n2 * neg3;\\n        c1 = c1*neg2;\\n        c2 = c2*neg4;\\n        cout<<n1<<\" \"<<c1<<\" \"<<n2<<\" \"<<c2;\\n        int real = n1*n2 - c1*c2;\\n        int comp = n1*c2 + n2*c1;\\n        string ans =  to_string(real);\\n        string ans2 = \"+\"+ to_string(comp)+\"i\";\\n        ans= ans+ans2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3982088,
                "title": "0-ms-beats-100-tc-o-n-sc-1-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntry to get the values \\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        int i=0;\\n        int a=0,b=0,c=0,d=0;\\n        int mi=0,mi1=0,mi2=0,mi3=0;\\n        while(num1[i]!=\\'+\\')\\n        {\\n            if(num1[i]==\\'-\\')\\n        {\\n            mi=1;\\n        }\\n        else{\\n            a=a*10+(num1[i]-\\'0\\');\\n        }\\n        i++;\\n        }\\n        if(mi==1)\\n        a=-a;\\n        i++;\\n        for(;i<num1.size()-1;i++)\\n        {\\n            if(num1[i]==\\'-\\')\\n            {\\n                mi1=1;\\n            }\\n            else\\n            b=b*10+(num1[i]-\\'0\\');\\n        }\\n        if(mi1==1)\\n        b=-b;\\n        i=0;\\n        while(num2[i]!=\\'+\\')\\n        {\\n            if(num2[i]==\\'-\\')\\n                mi2=1;\\n            else{\\n            c=c*10+(num2[i]-\\'0\\');\\n            }\\n            i++;\\n        }\\n        i++;\\n        if(mi2==1)\\n        c=-c;\\n        for(;i<num2.size()-1;i++)\\n        {\\n            if(num2[i]==\\'-\\')\\n            {\\n                mi3=1;\\n            }\\n            else\\n            d=d*10+(num2[i]-\\'0\\');\\n        }\\n        if(mi3==1)\\n        d=-d;\\n        cout<<a<<endl<<b<<endl<<c<<endl<<d;\\n        int real=a*c-d*b;\\n        int imagi=a*d+b*c;\\n        string s=to_string(real);\\n        string p=to_string(imagi);\\n        s=s+\"+\";\\n        p=p+\"i\";\\n        string t=s+p;\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        int i=0;\\n        int a=0,b=0,c=0,d=0;\\n        int mi=0,mi1=0,mi2=0,mi3=0;\\n        while(num1[i]!=\\'+\\')\\n        {\\n            if(num1[i]==\\'-\\')\\n        {\\n            mi=1;\\n        }\\n        else{\\n            a=a*10+(num1[i]-\\'0\\');\\n        }\\n        i++;\\n        }\\n        if(mi==1)\\n        a=-a;\\n        i++;\\n        for(;i<num1.size()-1;i++)\\n        {\\n            if(num1[i]==\\'-\\')\\n            {\\n                mi1=1;\\n            }\\n            else\\n            b=b*10+(num1[i]-\\'0\\');\\n        }\\n        if(mi1==1)\\n        b=-b;\\n        i=0;\\n        while(num2[i]!=\\'+\\')\\n        {\\n            if(num2[i]==\\'-\\')\\n                mi2=1;\\n            else{\\n            c=c*10+(num2[i]-\\'0\\');\\n            }\\n            i++;\\n        }\\n        i++;\\n        if(mi2==1)\\n        c=-c;\\n        for(;i<num2.size()-1;i++)\\n        {\\n            if(num2[i]==\\'-\\')\\n            {\\n                mi3=1;\\n            }\\n            else\\n            d=d*10+(num2[i]-\\'0\\');\\n        }\\n        if(mi3==1)\\n        d=-d;\\n        cout<<a<<endl<<b<<endl<<c<<endl<<d;\\n        int real=a*c-d*b;\\n        int imagi=a*d+b*c;\\n        string s=to_string(real);\\n        string p=to_string(imagi);\\n        s=s+\"+\";\\n        p=p+\"i\";\\n        string t=s+p;\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3968554,
                "title": "beats-100-easiest-approach-must-vote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    string checkfirst(string num1){\\n        string fnumf=\"\";\\n        for(int i=0;i<num1.length();i++){\\n            if(num1[i]!=\\'+\\'){\\n                fnumf+=num1[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return fnumf;\\n    }\\n    string checklast(string num1,int plus){\\n        string fnumf=\"\";\\n        for(int i=plus+1;i<num1.length();i++){\\n            if(num1[i]!=\\'i\\'){\\n                fnumf+=num1[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return fnumf;\\n    }\\n    int convert(string num1){\\n        int mul=1,rem=0,dumy=0;\\n        if(num1[0]==\\'-\\'){\\n            mul=-1;\\n            for(int i=1;i<num1.length();i++){\\n                rem=num1[i]-\\'0\\';\\n                dumy=dumy*10+rem;\\n            }\\n        }\\n        else{\\n            mul=1;\\n            for(int i=0;i<num1.length();i++){\\n                rem=num1[i]-\\'0\\';\\n                dumy=dumy*10+rem;\\n            }\\n        }\\n        dumy=mul*dumy;;\\n        return dumy;\\n    }\\n    string convertstr(int newstr){\\n        string str=\"\";\\n        int rem;\\n        if(newstr==0){\\n            return \"0\";\\n        }\\n        if(newstr<0){\\n            newstr=newstr*-1;\\n        }\\n        while(newstr){\\n            rem=newstr%10;\\n            newstr/=10;\\n            switch(rem){\\n                case 0:\\n                    str+=\\'0\\';\\n                    break;\\n                case 1:\\n                    str+=\\'1\\';\\n                    break;\\n                case 2:\\n                    str+=\\'2\\';\\n                    break;\\n                case 3:\\n                    str+=\\'3\\';\\n                    break;\\n                case 4:\\n                    str+=\\'4\\';\\n                    break;\\n                case 5:\\n                    str+=\\'5\\';\\n                    break;\\n                case 6:\\n                    str+=\\'6\\';\\n                    break;\\n                case 7:\\n                    str+=\\'7\\';\\n                    break;\\n                case 8:\\n                    str+=\\'8\\';\\n                    break;\\n                case 9:\\n                    str+=\\'9\\';\\n                    break;\\n            }\\n        }\\n        return str;\\n    }\\n    string rotate(string num){\\n        string rot=\"\";\\n        for(int i=num.length()-1;i>=0;i--){\\n            rot+=num[i];\\n        }\\n        return rot;\\n    }\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        string fnumf=\"\",fnuml=\"\",snumf=\"\",snuml=\"\";\\n        fnumf=checkfirst(num1);\\n        snumf=checkfirst(num2);\\n        int plus=fnumf.length();\\n        fnuml=checklast(num1,plus);\\n         plus=snumf.length();\\n        snuml=checklast(num2,plus);\\n        int intfnumf=convert(fnumf);\\n        int intsnumf=convert(snumf);\\n        int intfnuml=convert(fnuml);\\n        int intsnuml=convert(snuml);\\n        \\n        \\n        int first=intfnumf*intsnumf;        ;\\n        int second=(intfnuml*intsnuml)*(-1);\\n        int third=intfnumf*intsnuml;\\n        int fourth=intsnumf*intfnuml;\\n        first=first+second;\\n        third=third+fourth;\\n        string fir=convertstr(first);\\n        string sec=convertstr(third);\\n        fir=rotate(fir);\\n        sec=rotate(sec);\\n        if(first<0){\\n            fir=\\'-\\'+fir;\\n        }\\n        if(third<0){\\n            sec=\\'-\\'+sec;\\n        }\\n        fir=fir+\\'+\\'+sec+\\'i\\';\\n        return fir;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    string checkfirst(string num1){\\n        string fnumf=\"\";\\n        for(int i=0;i<num1.length();i++){\\n            if(num1[i]!=\\'+\\'){\\n                fnumf+=num1[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return fnumf;\\n    }\\n    string checklast(string num1,int plus){\\n        string fnumf=\"\";\\n        for(int i=plus+1;i<num1.length();i++){\\n            if(num1[i]!=\\'i\\'){\\n                fnumf+=num1[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return fnumf;\\n    }\\n    int convert(string num1){\\n        int mul=1,rem=0,dumy=0;\\n        if(num1[0]==\\'-\\'){\\n            mul=-1;\\n            for(int i=1;i<num1.length();i++){\\n                rem=num1[i]-\\'0\\';\\n                dumy=dumy*10+rem;\\n            }\\n        }\\n        else{\\n            mul=1;\\n            for(int i=0;i<num1.length();i++){\\n                rem=num1[i]-\\'0\\';\\n                dumy=dumy*10+rem;\\n            }\\n        }\\n        dumy=mul*dumy;;\\n        return dumy;\\n    }\\n    string convertstr(int newstr){\\n        string str=\"\";\\n        int rem;\\n        if(newstr==0){\\n            return \"0\";\\n        }\\n        if(newstr<0){\\n            newstr=newstr*-1;\\n        }\\n        while(newstr){\\n            rem=newstr%10;\\n            newstr/=10;\\n            switch(rem){\\n                case 0:\\n                    str+=\\'0\\';\\n                    break;\\n                case 1:\\n                    str+=\\'1\\';\\n                    break;\\n                case 2:\\n                    str+=\\'2\\';\\n                    break;\\n                case 3:\\n                    str+=\\'3\\';\\n                    break;\\n                case 4:\\n                    str+=\\'4\\';\\n                    break;\\n                case 5:\\n                    str+=\\'5\\';\\n                    break;\\n                case 6:\\n                    str+=\\'6\\';\\n                    break;\\n                case 7:\\n                    str+=\\'7\\';\\n                    break;\\n                case 8:\\n                    str+=\\'8\\';\\n                    break;\\n                case 9:\\n                    str+=\\'9\\';\\n                    break;\\n            }\\n        }\\n        return str;\\n    }\\n    string rotate(string num){\\n        string rot=\"\";\\n        for(int i=num.length()-1;i>=0;i--){\\n            rot+=num[i];\\n        }\\n        return rot;\\n    }\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        string fnumf=\"\",fnuml=\"\",snumf=\"\",snuml=\"\";\\n        fnumf=checkfirst(num1);\\n        snumf=checkfirst(num2);\\n        int plus=fnumf.length();\\n        fnuml=checklast(num1,plus);\\n         plus=snumf.length();\\n        snuml=checklast(num2,plus);\\n        int intfnumf=convert(fnumf);\\n        int intsnumf=convert(snumf);\\n        int intfnuml=convert(fnuml);\\n        int intsnuml=convert(snuml);\\n        \\n        \\n        int first=intfnumf*intsnumf;        ;\\n        int second=(intfnuml*intsnuml)*(-1);\\n        int third=intfnumf*intsnuml;\\n        int fourth=intsnumf*intfnuml;\\n        first=first+second;\\n        third=third+fourth;\\n        string fir=convertstr(first);\\n        string sec=convertstr(third);\\n        fir=rotate(fir);\\n        sec=rotate(sec);\\n        if(first<0){\\n            fir=\\'-\\'+fir;\\n        }\\n        if(third<0){\\n            sec=\\'-\\'+sec;\\n        }\\n        fir=fir+\\'+\\'+sec+\\'i\\';\\n        return fir;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966382,
                "title": "intutive-easy-c-solution",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNum(string str){\\n        int  num = 0 ;\\n        bool pos = true; \\n        for(int i = 0 ; i < str.size() ; i++){\\n            if(i == 0 && (str[i] == \\'-\\' || str[i]== \\'+\\')){\\n                if(str[i] == \\'-\\') pos = false;\\n            }else{\\n                num = num*10 + (str[i]-\\'0\\') ;\\n            }\\n        }\\n        return (pos)?num:-1*num ;\\n    }\\n    string complexNumberMultiply(string num1, string num2) {\\n        int i = 0 , j = 0 , n1 = num1.size(), n2 = num2.size(), r1 = 0 , i1 = 0 , r2 = 0 , i2 = 0 ;\\n        while(i<num1.size()){\\n            if(num1[i] == \\'+\\'){\\n                r1 = findNum(num1.substr(0,i)) ;\\n                i1 = findNum(num1.substr(i+1, n1-i-2)) ;\\n                break;\\n            }\\n            i++;\\n        }\\n        while(j<num2.size()){\\n            if(num2[j] == \\'+\\'){\\n                r2 = findNum(num2.substr(0,j)) ;\\n                i2 = findNum(num2.substr(j+1, n2-j-2)) ;\\n                break;\\n            }\\n            j++;\\n        }\\n        int real = (r1*r2)-(i1*i2) ;\\n        int img  = (r1*i2)+(r2*i1)  ;\\n        return ((real<0)?\"-\":\"\") + to_string(abs(real)) +\"+\"+ ((img<0)?\"-\":\"\") +to_string(abs(img)) +\"i\" ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNum(string str){\\n        int  num = 0 ;\\n        bool pos = true; \\n        for(int i = 0 ; i < str.size() ; i++){\\n            if(i == 0 && (str[i] == \\'-\\' || str[i]== \\'+\\')){\\n                if(str[i] == \\'-\\') pos = false;\\n            }else{\\n                num = num*10 + (str[i]-\\'0\\') ;\\n            }\\n        }\\n        return (pos)?num:-1*num ;\\n    }\\n    string complexNumberMultiply(string num1, string num2) {\\n        int i = 0 , j = 0 , n1 = num1.size(), n2 = num2.size(), r1 = 0 , i1 = 0 , r2 = 0 , i2 = 0 ;\\n        while(i<num1.size()){\\n            if(num1[i] == \\'+\\'){\\n                r1 = findNum(num1.substr(0,i)) ;\\n                i1 = findNum(num1.substr(i+1, n1-i-2)) ;\\n                break;\\n            }\\n            i++;\\n        }\\n        while(j<num2.size()){\\n            if(num2[j] == \\'+\\'){\\n                r2 = findNum(num2.substr(0,j)) ;\\n                i2 = findNum(num2.substr(j+1, n2-j-2)) ;\\n                break;\\n            }\\n            j++;\\n        }\\n        int real = (r1*r2)-(i1*i2) ;\\n        int img  = (r1*i2)+(r2*i1)  ;\\n        return ((real<0)?\"-\":\"\") + to_string(abs(real)) +\"+\"+ ((img<0)?\"-\":\"\") +to_string(abs(img)) +\"i\" ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924212,
                "title": "python-one-liner-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        return str(int(num1.split(\"+\")[0])*int(num2.split(\"+\")[0])+(-1*int(num1.replace(\"i\", \"\").split(\"+\")[1])*int(num2.replace(\"i\", \"\").split(\"+\")[1]))) + \"+\" + str(int(num2.split(\"+\")[0])*int(num1.replace(\"i\", \"\").split(\"+\")[1])+int(num1.split(\"+\")[0])*int(num2.replace(\"i\", \"\").split(\"+\")[1])) + \"i\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        return str(int(num1.split(\"+\")[0])*int(num2.split(\"+\")[0])+(-1*int(num1.replace(\"i\", \"\").split(\"+\")[1])*int(num2.replace(\"i\", \"\").split(\"+\")[1]))) + \"+\" + str(int(num2.split(\"+\")[0])*int(num1.replace(\"i\", \"\").split(\"+\")[1])+int(num1.split(\"+\")[0])*int(num2.replace(\"i\", \"\").split(\"+\")[1])) + \"i\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894649,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        int a = Integer.parseInt(num1.substring(0,num1.indexOf(\"+\")));\\n        int b = Integer.parseInt(num1.substring(num1.indexOf(\"+\")+1,num1.length()-1));\\n        int c = Integer.parseInt(num2.substring(0,num2.indexOf(\"+\")));\\n        int d = Integer.parseInt(num2.substring(num2.indexOf(\"+\")+1,num2.length()-1));\\n        \\n\\n        return \"\"+(a*c-b*d)+\"+\"+(a*d+c*b)+\"i\";\\n        \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        int a = Integer.parseInt(num1.substring(0,num1.indexOf(\"+\")));\\n        int b = Integer.parseInt(num1.substring(num1.indexOf(\"+\")+1,num1.length()-1));\\n        int c = Integer.parseInt(num2.substring(0,num2.indexOf(\"+\")));\\n        int d = Integer.parseInt(num2.substring(num2.indexOf(\"+\")+1,num2.length()-1));\\n        \\n\\n        return \"\"+(a*c-b*d)+\"+\"+(a*d+c*b)+\"i\";\\n        \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890103,
                "title": "complex-number-multilication",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- extract real and imaginary number and do the proper arithmatic multiplication andthen concatenate real nd imaginary with + sign and img with i sign \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Brute Force Approach:\\nIn the brute force approach, the complex numbers are directly parsed using istringstream, and arithmetic operations are applied for multiplication. It involves string manipulation for extracting real and imaginary parts, leading to O(N) time complexity. The arithmetic calculations are straightforward, but using streams can lead to code complexity.\\n\\nOptimal Solution 1 (Using Direct Arithmetic):\\nThe first optimal solution eliminates the use of streams, directly parsing real and imaginary parts using string manipulation. Arithmetic operations are then applied to calculate the multiplication. This version maintains a similar O(N) time complexity as it avoids intermediate stream operations. Code clarity is improved, and fewer objects are created.\\n\\nOptimal Solution 2 (Parsing via Function):\\nThe second optimal solution introduces a parsing function for both real and imaginary parts, promoting code reusability. The multiplication is carried out using arithmetic, and the result is constructed using string manipulation. The approach maintains the same time complexity as the previous one but enhances code organization and readability.\\n\\nBoth optimal solutions maintain efficient O(N) time complexity, simplify the parsing process, and provide cleaner code organization compared to the brute force approach.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n# Code\\n```\\n// class Solution {\\n// public:\\n//     string complexNumberMultiply(string a, string b) {\\n//         // Initialize variables for real and imaginary parts of both complex numbers\\n//         int ar, br, ai, bi;\\n        \\n//         // Character to hold the plus sign (\\'+\\')\\n//         char sign;\\n\\n//         // Create istringstream objects to parse the input strings\\n//         istringstream iss(a), iss1(b);\\n\\n//         // Extract real and imaginary parts of the first complex number\\n//         iss >> ar >> sign >> ai >> sign;\\n        \\n//         // Extract real and imaginary parts of the second complex number\\n//         iss1 >> br >> sign >> bi >> sign;\\n\\n//         // Calculate real and imaginary parts of the product\\n//         int real = (ar * br) - (ai * bi);\\n//         int img = (ar * bi) + (ai * br);\\n\\n//         // Create an ostringstream object to build the result string\\n//         ostringstream oss;\\n//         oss << real << \\'+\\' << img << \\'i\\';\\n        \\n//         // Return the result as a string\\n//         return oss.str(); \\n//     }\\n// };\\n\\n\\nclass Solution {                             //using PAIRSSSSZZZZ\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        // Parse the input strings to extract the complex numbers\\n        pair<int, int> num1 = parseComplex(a);\\n        pair<int, int> num2 = parseComplex(b);\\n\\n        // Calculate the real and imaginary parts of the product\\n        int realPart = (num1.first * num2.first) - (num1.second * num2.second);\\n        int imagPart = (num1.first * num2.second) + (num1.second * num2.first);\\n\\n        // Construct the result string in the format \"realPart + imagPart i\"\\n        return to_string(realPart) + \"+\" + to_string(imagPart) + \"i\";\\n    }\\n\\nprivate:\\n    // Function to parse a complex number string and return its real and imaginary parts\\n    pair<int, int> parseComplex(string& s) {\\n        // Find the index of the plus sign separating real and imaginary parts\\n        int plusPos = s.find(\\'+\\');\\n        \\n        // Extract the real part from the beginning to the plus sign\\n        int real = stoi(s.substr(0, plusPos));\\n        \\n        // Extract the imaginary part after the plus sign and before the \\'i\\' character\\n        int imag = stoi(s.substr(plusPos + 1, s.size() - plusPos - 2));\\n        \\n        // Return the real and imaginary parts as a pair\\n        return make_pair(real, imag);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "String"
                ],
                "code": "```\\n// class Solution {\\n// public:\\n//     string complexNumberMultiply(string a, string b) {\\n//         // Initialize variables for real and imaginary parts of both complex numbers\\n//         int ar, br, ai, bi;\\n        \\n//         // Character to hold the plus sign (\\'+\\')\\n//         char sign;\\n\\n//         // Create istringstream objects to parse the input strings\\n//         istringstream iss(a), iss1(b);\\n\\n//         // Extract real and imaginary parts of the first complex number\\n//         iss >> ar >> sign >> ai >> sign;\\n        \\n//         // Extract real and imaginary parts of the second complex number\\n//         iss1 >> br >> sign >> bi >> sign;\\n\\n//         // Calculate real and imaginary parts of the product\\n//         int real = (ar * br) - (ai * bi);\\n//         int img = (ar * bi) + (ai * br);\\n\\n//         // Create an ostringstream object to build the result string\\n//         ostringstream oss;\\n//         oss << real << \\'+\\' << img << \\'i\\';\\n        \\n//         // Return the result as a string\\n//         return oss.str(); \\n//     }\\n// };\\n\\n\\nclass Solution {                             //using PAIRSSSSZZZZ\\npublic:\\n    string complexNumberMultiply(string a, string b) {\\n        // Parse the input strings to extract the complex numbers\\n        pair<int, int> num1 = parseComplex(a);\\n        pair<int, int> num2 = parseComplex(b);\\n\\n        // Calculate the real and imaginary parts of the product\\n        int realPart = (num1.first * num2.first) - (num1.second * num2.second);\\n        int imagPart = (num1.first * num2.second) + (num1.second * num2.first);\\n\\n        // Construct the result string in the format \"realPart + imagPart i\"\\n        return to_string(realPart) + \"+\" + to_string(imagPart) + \"i\";\\n    }\\n\\nprivate:\\n    // Function to parse a complex number string and return its real and imaginary parts\\n    pair<int, int> parseComplex(string& s) {\\n        // Find the index of the plus sign separating real and imaginary parts\\n        int plusPos = s.find(\\'+\\');\\n        \\n        // Extract the real part from the beginning to the plus sign\\n        int real = stoi(s.substr(0, plusPos));\\n        \\n        // Extract the imaginary part after the plus sign and before the \\'i\\' character\\n        int imag = stoi(s.substr(plusPos + 1, s.size() - plusPos - 2));\\n        \\n        // Return the real and imaginary parts as a pair\\n        return make_pair(real, imag);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870888,
                "title": "solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        StringBuilder sb=new StringBuilder();\\n        \\n        int a=Integer.parseInt(num1.substring(0,num1.indexOf(\\'+\\')));\\n        int b=Integer.parseInt(num1.substring(num1.indexOf(\\'+\\')+1,num1.indexOf(\\'i\\')));//for number a+ib\\n        \\n        int c=Integer.parseInt(num2.substring(0,num2.indexOf(\\'+\\')));\\n        int d=Integer.parseInt(num2.substring(num2.indexOf(\\'+\\')+1,num2.indexOf(\\'i\\')));//for number c+id\\n        \\n        sb.append(a*c-b*d);\\n        sb.append(\\'+\\'+\"\");\\n        sb.append(b*c+a*d);\\n        sb.append(\\'i\\');\\n        \\n        return sb.toString();\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\n public:\\n  string complexNumberMultiply(string a, string b) {\\n    const auto& [A, B] = getRealAndImag(a);\\n    const auto& [C, D] = getRealAndImag(b);\\n    return to_string(A * C - B * D) + \"+\" + to_string(A * D + B * C) + \"i\";\\n  }\\n private:\\n  pair<int, int> getRealAndImag(const string& s) {\\n    const string& real = s.substr(0, s.find_first_of(\\'+\\'));\\n    const string& imag = s.substr(s.find_first_of(\\'+\\') + 1);\\n    return {stoi(real), stoi(imag)};\\n  };\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        real1,imag1=map(int,num1[:-1].split(\\'+\\'))\\n        real2,imag2=map(int,num2[:-1].split(\\'+\\'))\\n        real=real1*real2-imag1*imag2\\n        imag=real1*imag2+real2*imag1\\n        return str(real)+\\'+\\'+str(imag)+\\'i\\'\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public String complexNumberMultiply(String num1, String num2) {\\n        StringBuilder sb=new StringBuilder();\\n        \\n        int a=Integer.parseInt(num1.substring(0,num1.indexOf(\\'+\\')));\\n        int b=Integer.parseInt(num1.substring(num1.indexOf(\\'+\\')+1,num1.indexOf(\\'i\\')));//for number a+ib\\n        \\n        int c=Integer.parseInt(num2.substring(0,num2.indexOf(\\'+\\')));\\n        int d=Integer.parseInt(num2.substring(num2.indexOf(\\'+\\')+1,num2.indexOf(\\'i\\')));//for number c+id\\n        \\n        sb.append(a*c-b*d);\\n        sb.append(\\'+\\'+\"\");\\n        sb.append(b*c+a*d);\\n        sb.append(\\'i\\');\\n        \\n        return sb.toString();\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\n public:\\n  string complexNumberMultiply(string a, string b) {\\n    const auto& [A, B] = getRealAndImag(a);\\n    const auto& [C, D] = getRealAndImag(b);\\n    return to_string(A * C - B * D) + \"+\" + to_string(A * D + B * C) + \"i\";\\n  }\\n private:\\n  pair<int, int> getRealAndImag(const string& s) {\\n    const string& real = s.substr(0, s.find_first_of(\\'+\\'));\\n    const string& imag = s.substr(s.find_first_of(\\'+\\') + 1);\\n    return {stoi(real), stoi(imag)};\\n  };\\n};\\n```\n```python3 []\\nclass Solution:\\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\\n        real1,imag1=map(int,num1[:-1].split(\\'+\\'))\\n        real2,imag2=map(int,num2[:-1].split(\\'+\\'))\\n        real=real1*real2-imag1*imag2\\n        imag=real1*imag2+real2*imag1\\n        return str(real)+\\'+\\'+str(imag)+\\'i\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862830,
                "title": "simplest-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string n1 , string n2){\\n        int x1 , y1 , x2 , y2;\\n        char c;\\n        istringstream s1(n1) , s2(n2);\\n        s1 >> x1 >> c >> y1 >> c; \\n        s2 >> x2 >> c >> y2 >> c;\\n        return to_string(x1*x2-y1*y2)+\\'+\\'+to_string(x1*y2+x2*y1)+\\'i\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string n1 , string n2){\\n        int x1 , y1 , x2 , y2;\\n        char c;\\n        istringstream s1(n1) , s2(n2);\\n        s1 >> x1 >> c >> y1 >> c; \\n        s2 >> x2 >> c >> y2 >> c;\\n        return to_string(x1*x2-y1*y2)+\\'+\\'+to_string(x1*y2+x2*y1)+\\'i\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862485,
                "title": "easy-solution-using-getline",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        stringstream ss1(num1);\\n        stringstream ss2(num2);\\n        string temp;\\n        int fr;\\n        int fi;\\n        int sr;\\n        int si;\\n        while(getline(ss1,temp,\\'+\\'))\\n        {\\n            if(temp.back()!=\\'i\\')\\n            fr = stoi(temp);\\n            else\\n            fi = stoi(temp.substr(0,temp.length()-1));\\n        }\\n\\n        while(getline(ss2,temp,\\'+\\'))\\n        {\\n            if(temp.back()!=\\'i\\')\\n            sr = stoi(temp);\\n            else\\n            si = stoi(temp.substr(0,temp.length()-1));\\n        }\\n\\n        int real = (fr*sr)-(fi*si);\\n        int imag = (fr*si)+(sr*fi);\\n        string ans = \"\";\\n        ans+=to_string(real);\\n        ans+=\"+\";\\n        ans+=to_string(imag);\\n        ans+=\"i\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string complexNumberMultiply(string num1, string num2) {\\n        stringstream ss1(num1);\\n        stringstream ss2(num2);\\n        string temp;\\n        int fr;\\n        int fi;\\n        int sr;\\n        int si;\\n        while(getline(ss1,temp,\\'+\\'))\\n        {\\n            if(temp.back()!=\\'i\\')\\n            fr = stoi(temp);\\n            else\\n            fi = stoi(temp.substr(0,temp.length()-1));\\n        }\\n\\n        while(getline(ss2,temp,\\'+\\'))\\n        {\\n            if(temp.back()!=\\'i\\')\\n            sr = stoi(temp);\\n            else\\n            si = stoi(temp.substr(0,temp.length()-1));\\n        }\\n\\n        int real = (fr*sr)-(fi*si);\\n        int imag = (fr*si)+(sr*fi);\\n        string ans = \"\";\\n        ans+=to_string(real);\\n        ans+=\"+\";\\n        ans+=to_string(imag);\\n        ans+=\"i\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570566,
                "content": [
                    {
                        "username": "YehudisK",
                        "content": "Attention leetcode -\\nSome guy is using fake accounts to down-vote all the good posts, not letting them reach people and discouraging to post more!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "num1=1+1i    ,    num2=2+-1i\na1=1 ,  a2=2 ,  b1=1,  b2=-1\n\nBasic Math:-)\n\nFor real =  a1a2-b1b2\nFor complex = a1b2+a2b1\nComplex number = real+complex*(i)"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This problem looks easy on a surface level, but it is not so easy!"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I think it is easy. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem have so many dislikes? Totally don't understand. 🤕 Think it is a good problem. Because it is easy but tagged as medium?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/537_Complex_Number_Multiplication.cpp\\nPLS LEAVE A STAR\\n"
                    },
                    {
                        "username": "kislaykaushik",
                        "content": "firstly find real and imaginary number\\nnow after that  use basic `math concept` of \\nreal = real * real  and real = -(img * img)\\nimg = real * img\\n\\nthen finally return the result.\\nIn java:\\n\\n        int r1=0,r2=0,i1=0,i2=0;\\n        int idx1=num1.indexOf(\"+\");\\n        int idx2=num2.indexOf(\"+\");\\n        r1=Integer.valueOf(num1.substring(0,idx1));\\n        r2=Integer.valueOf(num2.substring(0,idx2));\\n        i1=Integer.valueOf(num1.substring(idx1+1,num1.length()-1));\\n        i2=Integer.valueOf(num2.substring(idx2+1,num2.length()-1));\\n        int real=-(i1*i2)+r1*r2;\\n        int img=i2*r1+i1*r2;\\n        String ans=real+\"+\"+img+\"i\";\\n        return ans;\\n\\n"
                    }
                ]
            },
            {
                "id": 1824049,
                "content": [
                    {
                        "username": "YehudisK",
                        "content": "Attention leetcode -\\nSome guy is using fake accounts to down-vote all the good posts, not letting them reach people and discouraging to post more!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "num1=1+1i    ,    num2=2+-1i\na1=1 ,  a2=2 ,  b1=1,  b2=-1\n\nBasic Math:-)\n\nFor real =  a1a2-b1b2\nFor complex = a1b2+a2b1\nComplex number = real+complex*(i)"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This problem looks easy on a surface level, but it is not so easy!"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I think it is easy. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem have so many dislikes? Totally don't understand. 🤕 Think it is a good problem. Because it is easy but tagged as medium?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/537_Complex_Number_Multiplication.cpp\\nPLS LEAVE A STAR\\n"
                    },
                    {
                        "username": "kislaykaushik",
                        "content": "firstly find real and imaginary number\\nnow after that  use basic `math concept` of \\nreal = real * real  and real = -(img * img)\\nimg = real * img\\n\\nthen finally return the result.\\nIn java:\\n\\n        int r1=0,r2=0,i1=0,i2=0;\\n        int idx1=num1.indexOf(\"+\");\\n        int idx2=num2.indexOf(\"+\");\\n        r1=Integer.valueOf(num1.substring(0,idx1));\\n        r2=Integer.valueOf(num2.substring(0,idx2));\\n        i1=Integer.valueOf(num1.substring(idx1+1,num1.length()-1));\\n        i2=Integer.valueOf(num2.substring(idx2+1,num2.length()-1));\\n        int real=-(i1*i2)+r1*r2;\\n        int img=i2*r1+i1*r2;\\n        String ans=real+\"+\"+img+\"i\";\\n        return ans;\\n\\n"
                    }
                ]
            },
            {
                "id": 1747639,
                "content": [
                    {
                        "username": "YehudisK",
                        "content": "Attention leetcode -\\nSome guy is using fake accounts to down-vote all the good posts, not letting them reach people and discouraging to post more!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "num1=1+1i    ,    num2=2+-1i\na1=1 ,  a2=2 ,  b1=1,  b2=-1\n\nBasic Math:-)\n\nFor real =  a1a2-b1b2\nFor complex = a1b2+a2b1\nComplex number = real+complex*(i)"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This problem looks easy on a surface level, but it is not so easy!"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I think it is easy. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem have so many dislikes? Totally don't understand. 🤕 Think it is a good problem. Because it is easy but tagged as medium?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/537_Complex_Number_Multiplication.cpp\\nPLS LEAVE A STAR\\n"
                    },
                    {
                        "username": "kislaykaushik",
                        "content": "firstly find real and imaginary number\\nnow after that  use basic `math concept` of \\nreal = real * real  and real = -(img * img)\\nimg = real * img\\n\\nthen finally return the result.\\nIn java:\\n\\n        int r1=0,r2=0,i1=0,i2=0;\\n        int idx1=num1.indexOf(\"+\");\\n        int idx2=num2.indexOf(\"+\");\\n        r1=Integer.valueOf(num1.substring(0,idx1));\\n        r2=Integer.valueOf(num2.substring(0,idx2));\\n        i1=Integer.valueOf(num1.substring(idx1+1,num1.length()-1));\\n        i2=Integer.valueOf(num2.substring(idx2+1,num2.length()-1));\\n        int real=-(i1*i2)+r1*r2;\\n        int img=i2*r1+i1*r2;\\n        String ans=real+\"+\"+img+\"i\";\\n        return ans;\\n\\n"
                    }
                ]
            },
            {
                "id": 1929850,
                "content": [
                    {
                        "username": "YehudisK",
                        "content": "Attention leetcode -\\nSome guy is using fake accounts to down-vote all the good posts, not letting them reach people and discouraging to post more!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "num1=1+1i    ,    num2=2+-1i\na1=1 ,  a2=2 ,  b1=1,  b2=-1\n\nBasic Math:-)\n\nFor real =  a1a2-b1b2\nFor complex = a1b2+a2b1\nComplex number = real+complex*(i)"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This problem looks easy on a surface level, but it is not so easy!"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I think it is easy. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem have so many dislikes? Totally don't understand. 🤕 Think it is a good problem. Because it is easy but tagged as medium?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/537_Complex_Number_Multiplication.cpp\\nPLS LEAVE A STAR\\n"
                    },
                    {
                        "username": "kislaykaushik",
                        "content": "firstly find real and imaginary number\\nnow after that  use basic `math concept` of \\nreal = real * real  and real = -(img * img)\\nimg = real * img\\n\\nthen finally return the result.\\nIn java:\\n\\n        int r1=0,r2=0,i1=0,i2=0;\\n        int idx1=num1.indexOf(\"+\");\\n        int idx2=num2.indexOf(\"+\");\\n        r1=Integer.valueOf(num1.substring(0,idx1));\\n        r2=Integer.valueOf(num2.substring(0,idx2));\\n        i1=Integer.valueOf(num1.substring(idx1+1,num1.length()-1));\\n        i2=Integer.valueOf(num2.substring(idx2+1,num2.length()-1));\\n        int real=-(i1*i2)+r1*r2;\\n        int img=i2*r1+i1*r2;\\n        String ans=real+\"+\"+img+\"i\";\\n        return ans;\\n\\n"
                    }
                ]
            },
            {
                "id": 1776264,
                "content": [
                    {
                        "username": "YehudisK",
                        "content": "Attention leetcode -\\nSome guy is using fake accounts to down-vote all the good posts, not letting them reach people and discouraging to post more!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "num1=1+1i    ,    num2=2+-1i\na1=1 ,  a2=2 ,  b1=1,  b2=-1\n\nBasic Math:-)\n\nFor real =  a1a2-b1b2\nFor complex = a1b2+a2b1\nComplex number = real+complex*(i)"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This problem looks easy on a surface level, but it is not so easy!"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I think it is easy. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem have so many dislikes? Totally don't understand. 🤕 Think it is a good problem. Because it is easy but tagged as medium?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/537_Complex_Number_Multiplication.cpp\\nPLS LEAVE A STAR\\n"
                    },
                    {
                        "username": "kislaykaushik",
                        "content": "firstly find real and imaginary number\\nnow after that  use basic `math concept` of \\nreal = real * real  and real = -(img * img)\\nimg = real * img\\n\\nthen finally return the result.\\nIn java:\\n\\n        int r1=0,r2=0,i1=0,i2=0;\\n        int idx1=num1.indexOf(\"+\");\\n        int idx2=num2.indexOf(\"+\");\\n        r1=Integer.valueOf(num1.substring(0,idx1));\\n        r2=Integer.valueOf(num2.substring(0,idx2));\\n        i1=Integer.valueOf(num1.substring(idx1+1,num1.length()-1));\\n        i2=Integer.valueOf(num2.substring(idx2+1,num2.length()-1));\\n        int real=-(i1*i2)+r1*r2;\\n        int img=i2*r1+i1*r2;\\n        String ans=real+\"+\"+img+\"i\";\\n        return ans;\\n\\n"
                    }
                ]
            },
            {
                "id": 1715095,
                "content": [
                    {
                        "username": "YehudisK",
                        "content": "Attention leetcode -\\nSome guy is using fake accounts to down-vote all the good posts, not letting them reach people and discouraging to post more!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "num1=1+1i    ,    num2=2+-1i\na1=1 ,  a2=2 ,  b1=1,  b2=-1\n\nBasic Math:-)\n\nFor real =  a1a2-b1b2\nFor complex = a1b2+a2b1\nComplex number = real+complex*(i)"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This problem looks easy on a surface level, but it is not so easy!"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I think it is easy. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem have so many dislikes? Totally don't understand. 🤕 Think it is a good problem. Because it is easy but tagged as medium?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/537_Complex_Number_Multiplication.cpp\\nPLS LEAVE A STAR\\n"
                    },
                    {
                        "username": "kislaykaushik",
                        "content": "firstly find real and imaginary number\\nnow after that  use basic `math concept` of \\nreal = real * real  and real = -(img * img)\\nimg = real * img\\n\\nthen finally return the result.\\nIn java:\\n\\n        int r1=0,r2=0,i1=0,i2=0;\\n        int idx1=num1.indexOf(\"+\");\\n        int idx2=num2.indexOf(\"+\");\\n        r1=Integer.valueOf(num1.substring(0,idx1));\\n        r2=Integer.valueOf(num2.substring(0,idx2));\\n        i1=Integer.valueOf(num1.substring(idx1+1,num1.length()-1));\\n        i2=Integer.valueOf(num2.substring(idx2+1,num2.length()-1));\\n        int real=-(i1*i2)+r1*r2;\\n        int img=i2*r1+i1*r2;\\n        String ans=real+\"+\"+img+\"i\";\\n        return ans;\\n\\n"
                    }
                ]
            }
        ]
    }
]