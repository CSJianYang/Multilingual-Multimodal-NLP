[
    {
        "title": "Minimize Maximum of Array",
        "question_content": "You are given a 0-indexed array nums comprising of n non-negative integers.\nIn one operation, you must:\n\n\tChoose an integer i such that 1 <= i < n and nums[i] > 0.\n\tDecrease nums[i] by 1.\n\tIncrease nums[i - 1] by 1.\n\nReturn the minimum possible value of the maximum integer of nums after performing any number of operations.\n&nbsp;\nExample 1:\n\nInput: nums = [3,7,1,6]\nOutput: 5\nExplanation:\nOne set of optimal operations is as follows:\n1. Choose i = 1, and nums becomes [4,6,1,6].\n2. Choose i = 3, and nums becomes [4,6,2,5].\n3. Choose i = 1, and nums becomes [5,5,2,5].\nThe maximum integer of nums is 5. It can be shown that the maximum number cannot be less than 5.\nTherefore, we return 5.\n\nExample 2:\n\nInput: nums = [10,1]\nOutput: 10\nExplanation:\nIt is optimal to leave nums as is, and since 10 is the maximum value, we return 10.\n\n&nbsp;\nConstraints:\n\n\tn == nums.length\n\t2 <= n <= 105\n\t0 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 2706521,
                "title": "java-c-python-prefix-sum-average-o-n",
                "content": "# **Intuition**\\nIn one operation:\\ndecrease A[i] by 1.\\nincrease A[i - 1] by 1.\\n\\nWe actully move the value of A[i] to A[i - 1] by 1,\\nthe sum won\\'t change.\\n\\nIf `A[i] < A[i + 1]`,\\nthen we can repeatly do the operations,\\nuntil `A[i] >= A[i+1]`.\\nSo finally the array `A` will become decrescent order.\\n<br>\\n\\n# **Explanation**\\nWe calculate the prefix sum arrray and their average.\\nThe average is the lower bound of the result,\\nand it\\'s reachable lower bound by the process in intuition,\\nso this average is the result.\\n<br>\\n\\n# Calculate average\\nWe need to calculate the ceil integer of the average,\\nFor example `7 = 3 + 2 + 2`,\\nthe ceil average is `3`.\\n\\nThe ceil average with `sum` of `i + 1` number:\\n`ceil(double(sum) / (i + 1))`\\n\\nWe can also do integer division:\\n`(sum + i) / (i + 1)`\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minimizeArrayValue(int[] A) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < A.length; ++i) {\\n            sum += A[i];\\n            res = Math.max(res, (sum + i) / (i + 1));\\n        }\\n        return (int)res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimizeArrayValue(vector<int>& A) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            sum += A[i];\\n            res = max(res, (sum + i) / (i + 1));\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n\\tdef minimizeArrayValue(self, A: List[int]) -> int:\\n        return max((a + i) // (i + 1) for i,a in enumerate(accumulate(A)))\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimizeArrayValue(int[] A) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < A.length; ++i) {\\n            sum += A[i];\\n            res = Math.max(res, (sum + i) / (i + 1));\\n        }\\n        return (int)res;\\n    }\\n```\n```cpp\\n    int minimizeArrayValue(vector<int>& A) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            sum += A[i];\\n            res = max(res, (sum + i) / (i + 1));\\n        }\\n        return res;\\n    }\\n```\n```py\\n\\tdef minimizeArrayValue(self, A: List[int]) -> int:\\n        return max((a + i) // (i + 1) for i,a in enumerate(accumulate(A)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3381323,
                "title": "image-explanation-brute-better-o-nlogm-optimal-o-n-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Reducing Dishes` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/c847042a-0467-4a70-ae8e-2334f4f324f8_1680662519.7955203.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/12bc569d-cd92-4670-b3d4-f7f5a73270b2_1680658588.9087818.png)\\n![image.png](https://assets.leetcode.com/users/images/2f83f614-d759-4c53-b6bc-51cca7114aec_1680658600.7222004.png)\\n![image.png](https://assets.leetcode.com/users/images/eabf3c40-589a-4357-a7be-0bfd6ffcf703_1680658609.1913445.png)\\n![image.png](https://assets.leetcode.com/users/images/4201959a-e73a-4389-bdfc-24838a390884_1680658619.5628827.png)\\n![image.png](https://assets.leetcode.com/users/images/fa415ba1-c047-4b0d-85c8-5ad98cc26527_1680658628.0101314.png)\\n![image.png](https://assets.leetcode.com/users/images/0ac472e3-2f2c-4440-843f-1ee04dd70326_1680658641.5219798.png)\\n![image.png](https://assets.leetcode.com/users/images/717eb807-6769-48ef-892a-823a12a7a948_1680658651.8700726.png)\\n![image.png](https://assets.leetcode.com/users/images/a6dfd0bd-e5e9-40c4-92c2-638335d3fe41_1680658671.9470701.png)\\n![image.png](https://assets.leetcode.com/users/images/14e3b874-e18a-4098-ab6b-9198d69fb45f_1680661950.9766278.png)\\n![image.png](https://assets.leetcode.com/users/images/1a2db97b-75cd-4c33-b0e7-5c1ced0651ae_1680658687.2741568.png)\\n![image.png](https://assets.leetcode.com/users/images/b965db02-24b5-4216-8e67-dee38b984b52_1680658696.0315495.png)\\n![image.png](https://assets.leetcode.com/users/images/27d2af2a-4851-4069-8987-45d3cd044de7_1680658703.1101856.png)\\n\\n\\n# Optimal Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& A) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            sum += A[i];\\n            res = max(res, (sum + i) / (i + 1));\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minimizeArrayValue(int[] A) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < A.length; ++i) {\\n            sum += A[i];\\n            res = Math.max(res, (sum + i) / (i + 1));\\n        }\\n        return (int)res;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def minimizeArrayValue(self, A: List[int]) -> int:\\n        return max((a + i) // (i + 1) for i,a in enumerate(accumulate(A)))\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& A) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            sum += A[i];\\n            res = max(res, (sum + i) / (i + 1));\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minimizeArrayValue(int[] A) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < A.length; ++i) {\\n            sum += A[i];\\n            res = Math.max(res, (sum + i) / (i + 1));\\n        }\\n        return (int)res;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def minimizeArrayValue(self, A: List[int]) -> int:\\n        return max((a + i) // (i + 1) for i,a in enumerate(accumulate(A)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381227,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers this week. I planned to give for next 10,000 Subscribers as well. So **DON\\'T FORGET** to Subscribe\\n\\n**Search \\uD83D\\uDC49`Tech Wired leetcode` on YouTube to Subscribe**\\n# OR \\n**Click the Link in my Leetcode Profile to Subscribe**\\n\\n\\n\\n# Recursion Explained (How to think recursively)\\n**Search \\uD83D\\uDC49`Recursion by Tech Wired` on YouTube**\\n\\n![Yellow & Black Earn Money YouTube Thumbnail (10).png](https://assets.leetcode.com/users/images/8e01ef12-7af2-43e7-890b-64be9f68204f_1680655527.4444485.png)\\n\\n\\n\\nHappy Learning, Cheers Guys \\uD83D\\uDE0A\\n# Approach:\\n\\n- Initialize total_sum and result to 0.\\n- Loop through the nums array from index 0 to len(nums)-1.\\n- For each index, add the value at that index to the total_sum.\\n- Calculate the maximum of the current result and the division of total_sum and index+1 using integer division //.\\n- Update the result with the maximum value.\\n- Repeat steps 3-5 for all indices.\\n- Return the result as the minimum maximum of the array.\\n\\n# Intuition:\\n\\n- The goal is to minimize the maximum of the array by dividing the array into subarrays and taking the sum of each subarray.\\n- By dividing the array into subarrays and taking their sum, we can obtain the average value of each subarray.\\n- The task is to find the maximum average value among all possible subarrays.\\n- We can achieve this by iteratively calculating the sum of the array up to each index and dividing it by the number of elements up to that index.\\n- We keep track of the maximum average value found so far and update it as we iterate through the array.\\n- Finally, we return the maximum average value as the result, which represents the minimum maximum of the array. This is because a smaller average value indicates a smaller maximum value. By choosing the maximum average value, we are minimizing the maximum of the array.\\n\\n```Python []\\nclass Solution:\\n    def minimizeArrayValue(self, nums):\\n        total_sum = 0\\n        result = 0\\n        for index in range(len(nums)):\\n            total_sum += nums[index]\\n            result = max(result, (total_sum + index) // (index + 1))\\n        return int(result)\\n\\n```\\n```Java []\\npublic class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0;\\n        long result = 0;\\n        for (int index = 0; index < nums.length; ++index) {\\n            sum += nums[index];\\n            result = Math.max(result, (sum + index) / (index + 1));\\n        }\\n        return (int) result;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long sum = 0;\\n        long long result = 0;\\n        for (int index = 0; index < nums.size(); ++index) {\\n            sum += nums[index];\\n            result = max(result, (sum + index) / (index + 1));\\n        }\\n        return (int) result;\\n    }\\n};\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```Python []\\nclass Solution:\\n    def minimizeArrayValue(self, nums):\\n        total_sum = 0\\n        result = 0\\n        for index in range(len(nums)):\\n            total_sum += nums[index]\\n            result = max(result, (total_sum + index) // (index + 1))\\n        return int(result)\\n\\n```\n```Java []\\npublic class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0;\\n        long result = 0;\\n        for (int index = 0; index < nums.length; ++index) {\\n            sum += nums[index];\\n            result = Math.max(result, (sum + index) / (index + 1));\\n        }\\n        return (int) result;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long sum = 0;\\n        long long result = 0;\\n        for (int index = 0; index < nums.size(); ++index) {\\n            sum += nums[index];\\n            result = max(result, (sum + index) / (index + 1));\\n        }\\n        return (int) result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706375,
                "title": "binary-search-with-explanation",
                "content": "**Binary search on answer** : \\nLet say, we are making all values of array <= `max`.\\nwe can\\'t change a[0], so if a[0] > max, then it is not possible to make.\\n\\nNow there are two cases : \\nif a[i] > max   or if a[i] < max:\\n\\nIf a[i] < max : \\nthen we can add some value to that element, so extra += max-a[i];\\n\\nIf a[i] > max : \\nthen we will be taking some value from that element, and will be adding that value to prev elements.\\nNow as `ex` is containing maximum value which we can add to all the previous elements of that ith element.\\nSo if value to remove is greater than `ex`, then also it is not possible.\\nOtherwise `ex -= c`\\n\\nTime Complexity : **O(nlogm)**\\n\\n```\\nclass Solution {\\n\\n    public int minimizeArrayValue(int[] nums) {\\n        int s = 0, e = (int) 1e9, ans = 0;\\n        while (s <= e) {\\n            int mid = s + (e - s) / 2;\\n            if (ok(mid, nums)) {\\n                e = mid - 1;\\n                ans = mid;\\n            } else {\\n                s = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private boolean ok(int max, int a[]) {\\n        long ex = 0;\\n        for (int i : a) {\\n            if (i > max) {\\n                long c = (i - max);\\n                if (c > ex) return false;\\n                ex -= c;\\n            } else {\\n                ex += (max - i);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int minimizeArrayValue(int[] nums) {\\n        int s = 0, e = (int) 1e9, ans = 0;\\n        while (s <= e) {\\n            int mid = s + (e - s) / 2;\\n            if (ok(mid, nums)) {\\n                e = mid - 1;\\n                ans = mid;\\n            } else {\\n                s = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private boolean ok(int max, int a[]) {\\n        long ex = 0;\\n        for (int i : a) {\\n            if (i > max) {\\n                long c = (i - max);\\n                if (c > ex) return false;\\n                ex -= c;\\n            } else {\\n                ex += (max - i);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381375,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo minimize the maximum element of the array, we need to decrease the maximum element as much as possible without affecting the other elements. To achieve this, we can start by trying to decrease the maximum element to the minimum possible value and check if we can do this. If we can\\'t do this, we increment the maximum element by one and repeat the process.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use binary search to minimize the maximum element of the array. We initialize the left pointer as 0 and the right pointer as the maximum element in the array. We compute the mid point between the left and right pointers and check if we can minimize the maximum element to mid by performing some operations on the array. If we can minimize the maximum element to mid, we move the right pointer to mid. Otherwise, we move the left pointer to mid+1.\\n\\nTo check if we can minimize the maximum element to mid, we iterate over the array and check if we can decrease the elements greater than mid to mid and increase the elements less than mid to mid without exceeding the number of operations available.\\n\\n# Complexity\\n- Time complexity: The time complexity of the solution is $$O(n*log(m))$$, where n is the length of the given array and m is the maximum element in the array. This is because the binary search algorithm used in the solution has a time complexity of O(log(m)), and for each value of mid, the check function is called, which has a time complexity of O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the solution is $$O(1)$$, as we are only using a few constant extra variables to keep track of the maximum value and the number of moves required. The input array is not being modified, and no additional space is being used.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n```java []\\nclass Solution {\\n    public boolean check(int[] nums, int k) {\\n        // variable to keep track of how many moves we have\\n        long have = 0;\\n        // iterate over the array\\n        for (int n : nums) {\\n            // if the number is less than or equal to k, we don\\'t need to do anything\\n            if (n <= k) {\\n                // add the number of moves needed to make it k to the total number of moves we have\\n                have += k - n;\\n            } else {\\n                // if the number is greater than k, we need to move some of its value to the previous element\\n                // check if we have enough moves left to make this move\\n                if (have < n - k)\\n                    return false;\\n                else\\n                    // if we have enough moves, subtract the number of moves needed to make this move from the total number of moves we have\\n                    have -= (n - k);\\n            }\\n        }\\n        // if we reach here, it means we were able to achieve a maximum value of k or less using the given number of moves\\n        return true;\\n    }\\n\\n    public int minimizeArrayValue(int[] nums) {\\n        // initialize left and right pointers for binary search\\n        int left = 0, right = Arrays.stream(nums).max().getAsInt();\\n        // perform binary search to find the minimum possible value of the maximum integer of nums after performing any number of operations\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (check(nums, mid))\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        // return the minimum possible value of the maximum integer of nums after performing any number of operations\\n        return left;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    static bool check(vector<int> &nums, int k) {\\n        long long have=0;\\n        for (int n: nums)\\n        {\\n            if (n<=k)\\n            {\\n                have += k-n;\\n            }\\n            else\\n            {\\n                if (have < n-k)\\n                    return 0; \\n                else\\n                    have -= (n-k);\\n            }\\n        }\\n        return 1;\\n    }\\n\\n    int minimizeArrayValue(vector<int> &nums) {\\n        int left=0, right = *max_element(nums.begin(), nums.end());\\n        while (left<right)\\n        { \\n            int mid = left+(right-left)/2;\\n            if (check(nums, mid))\\n                right=mid;\\n            else\\n                left= mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```\\n\\n```Python []\\nclass Solution(object):\\n    def check(self, nums, k):\\n        have = 0\\n        for n in nums:\\n            if n <= k:\\n                have += k - n\\n            else:\\n                if have < n - k:\\n                    return False\\n                else:\\n                    have -= n - k\\n        return True\\n\\n    def minimizeArrayValue(self, nums):\\n        left, right = 0, max(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if self.check(nums, mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\n```\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```java []\\nclass Solution {\\n    public boolean check(int[] nums, int k) {\\n        // variable to keep track of how many moves we have\\n        long have = 0;\\n        // iterate over the array\\n        for (int n : nums) {\\n            // if the number is less than or equal to k, we don\\'t need to do anything\\n            if (n <= k) {\\n                // add the number of moves needed to make it k to the total number of moves we have\\n                have += k - n;\\n            } else {\\n                // if the number is greater than k, we need to move some of its value to the previous element\\n                // check if we have enough moves left to make this move\\n                if (have < n - k)\\n                    return false;\\n                else\\n                    // if we have enough moves, subtract the number of moves needed to make this move from the total number of moves we have\\n                    have -= (n - k);\\n            }\\n        }\\n        // if we reach here, it means we were able to achieve a maximum value of k or less using the given number of moves\\n        return true;\\n    }\\n\\n    public int minimizeArrayValue(int[] nums) {\\n        // initialize left and right pointers for binary search\\n        int left = 0, right = Arrays.stream(nums).max().getAsInt();\\n        // perform binary search to find the minimum possible value of the maximum integer of nums after performing any number of operations\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (check(nums, mid))\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        // return the minimum possible value of the maximum integer of nums after performing any number of operations\\n        return left;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    static bool check(vector<int> &nums, int k) {\\n        long long have=0;\\n        for (int n: nums)\\n        {\\n            if (n<=k)\\n            {\\n                have += k-n;\\n            }\\n            else\\n            {\\n                if (have < n-k)\\n                    return 0; \\n                else\\n                    have -= (n-k);\\n            }\\n        }\\n        return 1;\\n    }\\n\\n    int minimizeArrayValue(vector<int> &nums) {\\n        int left=0, right = *max_element(nums.begin(), nums.end());\\n        while (left<right)\\n        { \\n            int mid = left+(right-left)/2;\\n            if (check(nums, mid))\\n                right=mid;\\n            else\\n                left= mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```\n```Python []\\nclass Solution(object):\\n    def check(self, nums, k):\\n        have = 0\\n        for n in nums:\\n            if n <= k:\\n                have += k - n\\n            else:\\n                if have < n - k:\\n                    return False\\n                else:\\n                    have -= n - k\\n        return True\\n\\n    def minimizeArrayValue(self, nums):\\n        left, right = 0, max(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if self.check(nums, mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706472,
                "title": "average",
                "content": "The best we can do is to reduce `nums[i]` to the average of array `nums[0, i]`.\\n\\n**Python**\\n```python\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        return max(ceil(n / (i + 1)) for i, n in enumerate(accumulate(nums)))\\n```\\n**C++**\\n```cpp\\nint minimizeArrayValue(vector<int>& nums) {\\n    long long minmax = 0, sum = 0;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        sum += nums[i];\\n        minmax = max((sum + i) / (i + 1), minmax);\\n    }\\n    return minmax;\\n}\\n```\\n**Java**\\n```java\\npublic int minimizeArrayValue(int[] nums) {\\n    long minmax = 0, sum = 0;\\n    for (int i = 0; i < nums.length; ++i) {\\n        sum += nums[i];\\n        minmax = Math.max((sum + i) / (i + 1), minmax);\\n    }\\n    return (int)minmax;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        return max(ceil(n / (i + 1)) for i, n in enumerate(accumulate(nums)))\\n```\n```cpp\\nint minimizeArrayValue(vector<int>& nums) {\\n    long long minmax = 0, sum = 0;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        sum += nums[i];\\n        minmax = max((sum + i) / (i + 1), minmax);\\n    }\\n    return minmax;\\n}\\n```\n```java\\npublic int minimizeArrayValue(int[] nums) {\\n    long minmax = 0, sum = 0;\\n    for (int i = 0; i < nums.length; ++i) {\\n        sum += nums[i];\\n        minmax = Math.max((sum + i) / (i + 1), minmax);\\n    }\\n    return (int)minmax;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381500,
                "title": "very-easy-solution-100-explained-o-n-javascript-python",
                "content": "# Intuition\\n- Intuition behind this is to be greedy and calculate the sum of each subarray and divide it by the length of the subarray and store the max result each time. \\n- You ask me why? \\n- Well lets say we have an array [3,7]. How many times we can perform the operation? Well lets count : In first operation we will have [4,6]. In second operation we will have [5,5]. well thats as far as we can go given the condition that we need to minimize the max sum.\\n- Now see this other way, if I took sum of [3,7] and divide it be length of subarray what we will get? Its 5 obviously, right? So keeping that in mind we will continue our implementation.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Lets initialize res and total with nums[0]. Why? because as per the operations given in the question set if we are on ith index and subtracting 1 from it then we must add that 1 to the preceding element i.e. i-1 element. So that\\'s why.\\n- Also we will initialize the total with nums[0]. Why? Well its the same reason as above.\\n- Loop through the array starting from index 1 and calculate the total\\n- Finally calculate the result by taking max of result, total/length of subarray.  \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# JAVASCRIPT\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimizeArrayValue = function(nums) {\\n    let res = nums[0], total = nums[0]\\n    for(let i=1;i<nums.length;i++){\\n        total += nums[i]\\n        res = Math.max(res, Math.ceil(total/(i+1)))\\n    }\\n    return res\\n};\\n```\\n# PYTHON\\n```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        res, total = nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            total += nums[i]\\n            res = max(res, math.ceil(total/(i+1)))\\n        return res\\n```\\n![upvote.png](https://assets.leetcode.com/users/images/94bbcd6e-379b-4226-896b-9f89c29d0905_1680665044.6460235.png)\\n",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimizeArrayValue = function(nums) {\\n    let res = nums[0], total = nums[0]\\n    for(let i=1;i<nums.length;i++){\\n        total += nums[i]\\n        res = Math.max(res, Math.ceil(total/(i+1)))\\n    }\\n    return res\\n};\\n```\n```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        res, total = nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            total += nums[i]\\n            res = max(res, math.ceil(total/(i+1)))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381551,
                "title": "python3-c-java-prefix-sum-average-o-n-look-at-once",
                "content": "The code starts by initializing two integer variables ans and s to zero. The variable ans will store the final result, while s will store the sum of elements seen so far in the iteration.\\n\\nThe code then loops through each element nums[i] in the input array using a for loop. In each iteration, it updates the s variable by adding the current element to it. Then, it calculates the average value of the array up to the current index i by dividing s by i+1 and rounding up to the nearest integer using integer division.\\n\\nFinally, it updates the ans variable to the maximum value seen so far between ans and the current average value.\\n\\nAfter the loop is completed, the code returns the final value of ans.\\n# Please Upvote \\uD83D\\uDE07\\n<iframe src=\"https://leetcode.com/playground/GHQhkLi5/shared\" frameBorder=\"0\" width=\"1000\" height=\"300\"></iframe>\\n\\n![image.png](https://assets.leetcode.com/users/images/03354f6c-17b0-4db7-82a2-f82adb22e037_1680666832.3429396.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "The code starts by initializing two integer variables ans and s to zero. The variable ans will store the final result, while s will store the sum of elements seen so far in the iteration.\\n\\nThe code then loops through each element nums[i] in the input array using a for loop. In each iteration, it updates the s variable by adding the current element to it. Then, it calculates the average value of the array up to the current index i by dividing s by i+1 and rounding up to the nearest integer using integer division.\\n\\nFinally, it updates the ans variable to the maximum value seen so far between ans and the current average value.\\n\\nAfter the loop is completed, the code returns the final value of ans.\\n# Please Upvote \\uD83D\\uDE07\\n<iframe src=\"https://leetcode.com/playground/GHQhkLi5/shared\" frameBorder=\"0\" width=\"1000\" height=\"300\"></iframe>\\n\\n![image.png](https://assets.leetcode.com/users/images/03354f6c-17b0-4db7-82a2-f82adb22e037_1680666832.3429396.png)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3381834,
                "title": "c-binary-search-average-method-easy-to-understand-dry-run",
                "content": "# Intuition\\nIt\\'s a tricky problem to understand!\\n\\nWe need to find the minimum value in the array that can be made the largest through a series of operations. \\nFor example, consider the array [3, 7, 1, 6]. The maximum value in this array is 7, but we can potentially obtain a smaller value by performing the given operations. So, we start by performing the operations as follows:\\n\\n```\\n[3, 7, 1, 6] -> [4, 6, 1, 6] (now the maximum value is 6)\\n```\\n\\nNext, we continue to perform the operations:\\n\\n```\\n[4, 6, 1, 6] -> [5, 5, 1, 6] \\n[5, 5, 1, 6] -> [5, 5, 2, 5] (now the maximum value is 5)\\n```\\n\\nSo, the minimum value that can be made the largest in the array is 5. Any further operation on this array will result in increasing the maximum value, which is not our goal as we want to minimize it. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\nThough binary search isn\\'t the first idea that would occur, but after a few dry runs with different examples you would understand how it works. The idea is to find the minimum value such that after using the operations, no number in the array becomes greater than this minimum value. \\n1. This is done by using binary search, where the initial range of possible values for the minimum value is from 0 to the maximum number in the array. \\n2. Then, at each iteration of the binary search, a mid value is chosen from the range and checked if adding it to all the numbers in the array maintains the condition of no number being greater than the mid value. \\n3. If the condition is satisfied, the range is narrowed down to the left half, otherwise it is narrowed down to the right half. \\nThis process continues until the minimum value is found.\\n\\n### Dry run\\n```\\nnums=[4,3,6,2]\\n```\\n```\\n1. left=0, right=6 => mid=3\\nas nums[0] i.e 4 is greater than 3. \\nThat means it\\'s not possible to make all elements <=3 using the operations.\\nHence,  return false.\\n```\\nNote, that we can perform operations any no. of times. Hence, for two consecutive numbers, we can reduce and increase the curr and curr-1 any number of times. \\n```\\n2. left=mid+1=4, right=6 => mid=5\\n\\n    4   3   6   2 => [4,3,6,2]-> [5,2,6,2]\\n  +1|  -1|  \\n    5   2    \\n\\n    5   2   6   2 => [5,2,6,2]-> [5,5,3,2]  \\n       +3| -3| \\n    5   5   3   2\\n\\n    5   5   3   2 => [5,5,3,2]-> [5,5,5,0]\\n           +2| -2|\\n            5   0\\n\\nas all final elements are less than equal to 5 hence 5 is the answer.\\n\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity:  -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n## 1. Using Binary Search\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n\\n    // Function to check if a given target value is valid\\n    // by checking if it\\'s possible to make all elements of nums <= target\\n    bool isValid(ll target, vector<int>& nums){\\n        if(nums[0]>target) return false; \\n        ll prev=nums[0];\\n        for(int i=1;i<nums.size();++i){\\n            ll diff=target-prev; // Calculate the difference between target and previous element\\n            prev=nums[i]-diff; // Update prev by subtracting the difference from current element\\n            if(prev>target) return false; \\n        }\\n        return true; // If all elements can be made <= target, return true\\n    }\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        ll left=0, right=*max_element(nums.begin(),nums.end()); // Set left to 0 and right to the maximum element in nums\\n        while(left<right){ \\n            int mid=left+(right-left)/2; \\n            if(isValid(mid,nums)) right=mid; // If mid is a valid target, update right pointer\\n            else left=mid+1; // If mid is not a valid target, update left pointer\\n        }\\n        return right; // Return the smallest valid target value\\n    }\\n};\\n\\n```\\n## 2. Using Average\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int n=nums.size();\\n        ll sum=0,maxAvg=0;\\n        for(int i=0;i<n;++i){\\n            sum+=nums[i];\\n            ll currAvg=ceil((double)sum/(i+1));\\n            maxAvg=max(currAvg,maxAvg);\\n        }\\n        return maxAvg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\n[3, 7, 1, 6] -> [4, 6, 1, 6] (now the maximum value is 6)\\n```\n```\\n[4, 6, 1, 6] -> [5, 5, 1, 6] \\n[5, 5, 1, 6] -> [5, 5, 2, 5] (now the maximum value is 5)\\n```\n```\\nnums=[4,3,6,2]\\n```\n```\\n1. left=0, right=6 => mid=3\\nas nums[0] i.e 4 is greater than 3. \\nThat means it\\'s not possible to make all elements <=3 using the operations.\\nHence,  return false.\\n```\n```\\n2. left=mid+1=4, right=6 => mid=5\\n\\n    4   3   6   2 => [4,3,6,2]-> [5,2,6,2]\\n  +1|  -1|  \\n    5   2    \\n\\n    5   2   6   2 => [5,2,6,2]-> [5,5,3,2]  \\n       +3| -3| \\n    5   5   3   2\\n\\n    5   5   3   2 => [5,5,3,2]-> [5,5,5,0]\\n           +2| -2|\\n            5   0\\n\\nas all final elements are less than equal to 5 hence 5 is the answer.\\n\\n```\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n\\n    // Function to check if a given target value is valid\\n    // by checking if it\\'s possible to make all elements of nums <= target\\n    bool isValid(ll target, vector<int>& nums){\\n        if(nums[0]>target) return false; \\n        ll prev=nums[0];\\n        for(int i=1;i<nums.size();++i){\\n            ll diff=target-prev; // Calculate the difference between target and previous element\\n            prev=nums[i]-diff; // Update prev by subtracting the difference from current element\\n            if(prev>target) return false; \\n        }\\n        return true; // If all elements can be made <= target, return true\\n    }\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        ll left=0, right=*max_element(nums.begin(),nums.end()); // Set left to 0 and right to the maximum element in nums\\n        while(left<right){ \\n            int mid=left+(right-left)/2; \\n            if(isValid(mid,nums)) right=mid; // If mid is a valid target, update right pointer\\n            else left=mid+1; // If mid is not a valid target, update left pointer\\n        }\\n        return right; // Return the smallest valid target value\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int n=nums.size();\\n        ll sum=0,maxAvg=0;\\n        for(int i=0;i<n;++i){\\n            sum+=nums[i];\\n            ll currAvg=ceil((double)sum/(i+1));\\n            maxAvg=max(currAvg,maxAvg);\\n        }\\n        return maxAvg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836579,
                "title": "easy-to-understand-o-n-time-and-o-1-space-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince we can\\'t touch the first element, we want to move the minimimum possible largest there. That means if we find a larger element we want to move it to the first element, while doing that if we find a lower element than itself, we want to give it as much as possible, without making it larger than the first element. \\n\\nMy first approach was to do this for every index, if it\\'s larger than the first, then going back and giving to every element before it, trying to average it out. essentially making my solution O(n * n).\\n\\nto optimize I thought that since I am trying to average it out, I don\\'t need to do it again and again. I can use prefix_sum to keep track of the total amount of elements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nto minimize the largest one, we want to average it out, but we can\\'t average it out over the elements that come after it. so that means we can only average it out over elements that come before it. \\n\\nHow to do that? Well if the current element is larger than the first element then we need to take the sum of the elements up to the element, then divide them by their number so as to average it out over the elements up to and including the element.\\n\\nThis average is either larger than the first element, which means we have to update our first element, or if it\\'s lower then we have already found the largest element we can get at the first position.\\n\\nto understand this more, think of the following example:\\n[10, 2, 12]\\n\\n- we start from 2, it\\'s less than 10 so we continue.\\n- we have 12 > 10, which means we should average it out. the average is 24 / 3 = 8, but since the first element was larger than the average it should be the answer.\\n\\nlet\\'s see another example.\\n[3, 7, 1, 6, 8, 9]\\n- first = 3, sum = 3, list = [3]\\n- 7 > 3, average = ceil(10 / 2) = 5, first = max(5,3)\\n- first = 5, sum = 10, list = [5, 5]\\n- 1 < 5 continue, sum = 11, list = [5, 5, 1]\\n- 6 > 5 averate = ceil(17 / 4) = 5, first = max(5, 5)\\n- first = 5, sum = 17, list = [5, 5, 5, 2]\\n- 8 > 5, average = ceil(25 / 5) = 5 first = max(5, 5)\\n- first = 5, sum = 25, list = [5, 5, 5, 5, 5]\\n- 9 > 5, average = ceil(34 / 5) = 7, first = max(7, 5)\\n- first = 7, sum = 34, list = [7, 7, 7, 7, 7, 0]\\n- we return 7\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        maxim = nums[0]\\n        prefix_sum = nums[0]\\n\\n        for idx in range(1, len(nums)):\\n            curr = nums[idx]\\n            prefix_sum += curr\\n            if curr > maxim:\\n                maxim = max(maxim, math.ceil(prefix_sum / (idx + 1)))\\n\\n\\n        return maxim\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        maxim = nums[0]\\n        prefix_sum = nums[0]\\n\\n        for idx in range(1, len(nums)):\\n            curr = nums[idx]\\n            prefix_sum += curr\\n            if curr > maxim:\\n                maxim = max(maxim, math.ceil(prefix_sum / (idx + 1)))\\n\\n\\n        return maxim\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706364,
                "title": "python-o-n-1-pass-prefix-sum-no-extra-space",
                "content": "Hey guys, a simple solution to this problem. \\n\\nIf we encounter a number higher than the previous maximum, we know that we can increase the previous elements to decrease this higher number and the new maximum will be the sum of all elements divided by the number of elements (rounded up).\\n\\t\\n\\t\\tres=0\\n        maxi=s=nums[0]\\n        for i in range (1,len(nums)):\\n            s+=nums[i]\\n            if nums[i]>maxi:\\n                maxi=(s+i)/(i+1)\\n            res=max(maxi,res)\\n        return res\\n\\nPlease upvote if you liked!\\n\\nCheers,\\nBerthouille",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "Hey guys, a simple solution to this problem. \\n\\nIf we encounter a number higher than the previous maximum, we know that we can increase the previous elements to decrease this higher number and the new maximum will be the sum of all elements divided by the number of elements (rounded up).\\n\\t\\n\\t\\tres=0\\n        maxi=s=nums[0]\\n        for i in range (1,len(nums)):\\n            s+=nums[i]\\n            if nums[i]>maxi:\\n                maxi=(s+i)/(i+1)\\n            res=max(maxi,res)\\n        return res\\n\\nPlease upvote if you liked!\\n\\nCheers,\\nBerthouille",
                "codeTag": "Unknown"
            },
            {
                "id": 2706384,
                "title": "python-elegant-short-commented-o-n-prefix-average",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        cum_sum = maximum = 0\\n\\n        for i, num in enumerate(nums, start=1):\\n            cum_sum += num\\n\\t\\t\\t# At each step, we can try to minimize the element by evenly placing\\n\\t\\t\\t# the excess between the previous elements.\\n            maximum = max(ceil(cum_sum / i), maximum)\\n\\n        return maximum\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        cum_sum = maximum = 0\\n\\n        for i, num in enumerate(nums, start=1):\\n            cum_sum += num\\n\\t\\t\\t# At each step, we can try to minimize the element by evenly placing\\n\\t\\t\\t# the excess between the previous elements.\\n            maximum = max(ceil(cum_sum / i), maximum)\\n\\n        return maximum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706976,
                "title": "python-simple-solution-explained-o-n",
                "content": "Let\\'s assume `nums` includes two numbers only: `[num1, num2]`. According to the problem description, there is no way to decrease `num1`. So manipulations are possible only with `num2`. 3 possible cases can be considered:\\n1. `num1 > num2`: nothing can be done to decrease `max(nums)`, `num1` shall be returned;\\n2. `num1 = num2`: same as above;\\n3. `num1 < num2`: we can decrease `num2` increasing `num1` so both are equal (or almost equal). If `(num1 + num2) % 2 == 0` the resulting maximum value is `(num1 + num2) // 2`, otherwise `1` should be added to the average.\\n\\nNow let\\'s assume `nums = [num1, num2, num3]` and we already equalized `num1`, `num2`. We can only decrease `num3` thus increasing `num1` and `num2`, but this action does not make any sense if `num3` is less or equal to `max(nums1, nums2)`. If `num3` is the maximum we can equalize these 3 numbers making them as close to `sum(num1, num2, num3)/3` as possible.\\n\\nSo the algoritghm is to iterate over `nums` elements calculating the average and updating the maximum value if current average > current max.\\n\\n<int>Time complexity:</ins> `O(n)`\\n<int>Space complexity:</ins> `O(1)`\\n\\n```python\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        max_ = sum_ = 0\\n\\t\\t\\n        for i, num in enumerate(nums, start = 1):\\n            sum_ += num\\n            ave, modulo = divmod(sum_, i)\\n            if modulo: ave += 1\\n            max_ = max(ave, max_)\\n\\n        return max_\\n    # end minimizeArrayValue()\\n```\\n\\nWe may also include `if num > max_:` after `sum_` calculation. This somewhat improves runtime",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        max_ = sum_ = 0\\n\\t\\t\\n        for i, num in enumerate(nums, start = 1):\\n            sum_ += num\\n            ave, modulo = divmod(sum_, i)\\n            if modulo: ave += 1\\n            max_ = max(ave, max_)\\n\\n        return max_\\n    # end minimizeArrayValue()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706361,
                "title": "c-binary-search",
                "content": "Use `Binary Search` to find the smallest value satisfying. \\n\\nWhen checking if a value k is satisfied, we will try to reduce the current number to the minimum by reducing it by `k - prev`, if not, the number k is not satisfied.\\n``` C++\\nclass Solution {\\npublic:\\n    typedef long long LONG;\\n\\n    bool isValid(vector<int> &nums, int k) {\\n        if (nums[0] > k) return false;\\n        LONG prev = nums[0];\\n        for (int i = 1; i < nums.size(); ++i) {\\n            LONG d = k - prev;\\n            prev = nums[i] - d;\\n            if (prev > k) return false;\\n        }\\n        return true;\\n    }\\n\\n    int minimizeArrayValue(vector<int> &nums) {\\n        int res, left = 0, right = *max_element(nums.begin(), nums.end());\\n        while (left <= right) {\\n            int mid = (right - left) / 2 + left;\\n            if (isValid(nums, mid)) res = mid, right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "``` C++\\nclass Solution {\\npublic:\\n    typedef long long LONG;\\n\\n    bool isValid(vector<int> &nums, int k) {\\n        if (nums[0] > k) return false;\\n        LONG prev = nums[0];\\n        for (int i = 1; i < nums.size(); ++i) {\\n            LONG d = k - prev;\\n            prev = nums[i] - d;\\n            if (prev > k) return false;\\n        }\\n        return true;\\n    }\\n\\n    int minimizeArrayValue(vector<int> &nums) {\\n        int res, left = 0, right = *max_element(nums.begin(), nums.end());\\n        while (left <= right) {\\n            int mid = (right - left) / 2 + left;\\n            if (isValid(nums, mid)) res = mid, right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382849,
                "title": "java-simple-explained-clear-and-detailed-solution",
                "content": "# Intuition\\nThis problem and its formulation are **extremely difficult to understand** if you have never solved a problem like this before.\\nThe best way to overcome such a challenge is to look at a **few examples** and see what is going on.\\nWe can deduce from the problem statement that nums[0] array value cannot decrease and that values can only be distributed from nums[n] to nums[n-1], so they **flow from right to left**.\\n```\\n// minMax = not-computed\\n{3, 7, 4, 1}\\n// Flow 7 exceeding value to 3\\n{5, 5, 4, 1}\\n// minMax = 5\\n```\\n\\nIntuitively, we also notice that when we \"add\" a new relatively large number to the array, it generally has a large impact on the values on its left and may update the minMax.\\n```\\n// minMax = 5\\n{5, 5, 4, 1}\\n// Add 16\\n{5, 5, 4, 1, 16}\\n{5, 5, 4, 9, 8}\\n{5, 5, 7, 7, 7}\\n// [...] running flow-algorithm ...\\n{7, 6, 6, 6, 6}\\n// minMax = 7\\n```\\n\\nSymetrically, if the new number is small relatively to the previous values, it will impact little to no values at its left, and wouldn\\'t update the minMax.\\n\\n```\\n// minMax = 10\\n{10, 10, 9, 1}\\n// Add 4\\n{10, 10, 9, 1, 4}\\n{10, 10, 9, 3, 2}\\n// minMax = 10\\n```\\n\\nTo be more precise, we can see that whenever we \"add\" a new number, **the sum of previous values**, specifically the sum of (minMax-num) differentials, will determine if the minMax is increased.\\nDespite the fact that 16>10 in the following example, the +6 value (16-10 = 6) can be distributed on previous values less than 10.\\n\\n```\\n// minMax = 10\\n{10, 10, 9, 1}\\n// Add 16\\n{10, 10, 9, 1, 16}\\n{10, 10, 9, 9, 8}\\n// minMax = 10\\n```\\n**Sum-up:**\\n> The first array value cannot decrease, and exceeding values can only flow from right to left.\\n\\nWe can deduce from this that once we compute our first minMax on the first two array values, **the minMax can only increase or remain constant** as new values are added.\\n\\n> New large numbers exceeding value are distributed to the left based on the sum of previous num values. \\n\\nAs a result, whenever we add a new number, we can use the **sum of all previous numbers** to determine whether we are increasing the minMax. \\nWhen we look carefully at the examples, we can be more specific and notice that the **minMax equals the average value** (sum / array.length) at initialization, as well as everytime its value increases. \\n```\\n// initialization with 3-7 - minMax = 5 <=> ceil((3+7)/2) = ceil(10/2)\\n{3, 7}\\n// include 4 - minMax = 5\\n{5, 5, 4}\\n// include 11 - minMax = 7 <=> ceil((5+5+4+11)/4) = ceil(25/4)\\n{5, 5, 4, 11}\\n// [...] running flow-algorithm ...\\n{7, 6, 6, 6}\\n```\\n\\nWith these 2 ideas in mind, you should have a much better understanding of the code below.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ with n = nums.length\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        double minMax = 0d;\\n        double numsSum = 0d;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            numsSum += nums[i];\\n            double numsAverage = Math.ceil(numsSum / (i + 1));\\n            minMax = Math.max(minMax, numsAverage);\\n        }\\n\\n        return (int) minMax;\\n    }\\n}\\n\\n```\\n\\n### Thanks for visiting my solution \\u2764\\n### UPVOTE if you like it \\uD83D\\uDC4D\\n\\n![55tne0.jpg](https://assets.leetcode.com/users/images/3416cd04-47d4-4511-8276-e99441048f77_1680695679.1274028.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\n// minMax = not-computed\\n{3, 7, 4, 1}\\n// Flow 7 exceeding value to 3\\n{5, 5, 4, 1}\\n// minMax = 5\\n```\n```\\n// minMax = 5\\n{5, 5, 4, 1}\\n// Add 16\\n{5, 5, 4, 1, 16}\\n{5, 5, 4, 9, 8}\\n{5, 5, 7, 7, 7}\\n// [...] running flow-algorithm ...\\n{7, 6, 6, 6, 6}\\n// minMax = 7\\n```\n```\\n// minMax = 10\\n{10, 10, 9, 1}\\n// Add 4\\n{10, 10, 9, 1, 4}\\n{10, 10, 9, 3, 2}\\n// minMax = 10\\n```\n```\\n// minMax = 10\\n{10, 10, 9, 1}\\n// Add 16\\n{10, 10, 9, 1, 16}\\n{10, 10, 9, 9, 8}\\n// minMax = 10\\n```\n```\\n// initialization with 3-7 - minMax = 5 <=> ceil((3+7)/2) = ceil(10/2)\\n{3, 7}\\n// include 4 - minMax = 5\\n{5, 5, 4}\\n// include 11 - minMax = 7 <=> ceil((5+5+4+11)/4) = ceil(25/4)\\n{5, 5, 4, 11}\\n// [...] running flow-algorithm ...\\n{7, 6, 6, 6}\\n```\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        double minMax = 0d;\\n        double numsSum = 0d;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            numsSum += nums[i];\\n            double numsAverage = Math.ceil(numsSum / (i + 1));\\n            minMax = Math.max(minMax, numsAverage);\\n        }\\n\\n        return (int) minMax;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381487,
                "title": "c-easy-solution-prefix-sum-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution \\uD83D\\uDD25 || \\uD83D\\uDCAF\\uD83D\\uDCAFPrefix Sum Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\nApproach :\\none key observation is that we can\\'t change the first element so if we have max element at first then we cant change it \\nlikewise when we are standing on second element we can distribute the number in between first and second so we have our ans as `max(ans,ceil(prefix[i]/(i+1)))`\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n\\t//initializing cur and ans for storing prefix sum and res respectively\\n        long long ans=0,cur=0;\\n        for(int i=0;i<nums.size();i++){\\n            cur+=nums[i];\\n            long long val=ceil((cur)/(i+1.0));\\n\\t\\t\\t//storing max in the ans\\n            ans=max(ans,val);\\n            \\n        }\\n\\t\\t//returning the ans\\n        return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n\\t//initializing cur and ans for storing prefix sum and res respectively\\n        long long ans=0,cur=0;\\n        for(int i=0;i<nums.size();i++){\\n            cur+=nums[i];\\n            long long val=ceil((cur)/(i+1.0));\\n\\t\\t\\t//storing max in the ans\\n            ans=max(ans,val);\\n            \\n        }\\n\\t\\t//returning the ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381606,
                "title": "day-370-java-c-python-explained-intuition-approach-proof",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/025d868a-77e4-4618-80f8-194a954ed596_1680671235.2830439.png)\\n\\n# Please Upvote as it really motivates me\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##### \\u2022\\tTo find the minimum maximum value of an array, we can use an iterative approach. \\n##### \\u2022\\tFirst, we calculate the sum of the array up to each index and divide it by the number of elements up to that index. \\n##### \\u2022\\tWe then keep track of the maximum average value found so far and update it as we iterate through the array. \\n##### \\u2022\\tFinally, we return the maximum average value as the result, which represents the minimum maximum of the array. \\n##### \\u2022\\tBy choosing the maximum average value, we are effectively minimizing the maximum value of the array.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tDefine a public method named \"minimizeArrayValue\" that takes an integer array \"nums\" as input and returns an integer value.\\n##### \\u2022\\tInitialize two long variables \"ans\" and \"sum\" to 0.\\n##### \\u2022\\tUse a for loop to iterate through the \"nums\" array from index 0 to the length of the array.\\n##### \\u2022\\tInside the for loop, add the current element of the array to the \"sum\" variable and check if it is greater than the \"ans\" variable.\\n##### \\u2022\\tIf the current element is greater than \"ans\", update \"ans\" to the maximum value between \"ans\" and the ceiling value of the sum of the current element and \"sum\" divided by the current index plus 1.\\n##### \\u2022\\tReturn the integer value of \"ans\".\\n\\n\\n# Code\\n```c++ []\\nint minimizeArrayValue(vector<int>& nums,long  ans=0,long  sum=0) {\\n        for(int i=0;i<nums.size();sum+=nums[i],i++)\\n            if(nums[i]>ans)ans=max(ans,(long )ceil((double)(sum+nums[i])/(i+1)));\\n        return (int)ans;\\n    }\\n``` \\n```java []\\npublic int minimizeArrayValue(int[] nums) {\\n        long ans=0,sum=0;\\n        for(int i=0;i<nums.length;sum+=nums[i],i++)\\n            if(nums[i]>ans)ans=Math.max(ans,(long)Math.ceil((double)(sum+nums[i])/(i+1)));\\n        return (int)ans;\\n    }\\n```\\n```python []\\ndef minimizeArrayValue(nums):\\n    ans = 0\\n    sum = 0\\n    for i in range(len(nums)):\\n        sum += nums[i]\\n        if nums[i] > ans:\\n            ans = max(ans, math.ceil((sum + nums[i]) / (i + 1)))\\n    return int(ans)\\n```\\n\\n\\n\\n# Complexity\\nTime Complexity: O(n), where n is the length of the input array \"nums\". This is because we are iterating through the array once.\\n\\nSpace Complexity: O(1), as we are only using a constant amount of extra space to store the variables \"ans\" and \"sum\".\\n\\n# 2nd way \\n\\n```python []\\nclass Solution:\\n    def minimizeArrayValue(self, A: List[int]) -> int:\\n        return max((a + i) // (i + 1) for i,a in enumerate(accumulate(A)))\\n```\\n```c++ []\\nint minimizeArrayValue(vector<int>& A) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            sum += A[i];\\n            res = max(res, (sum + i) / (i + 1));\\n        }\\n        return res;\\n    }\\n```\\n```java []\\npublic int minimizeArrayValue(int[] A) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < A.length; ++i) {\\n            sum += A[i];\\n            res = Math.max(res, (sum + i) / (i + 1));\\n        }\\n        return (int)res;\\n    }\\n```\\n# DRY RUN \\n##### \\u2022\\tWe have the input array nums = [3,7,1,6] and we need to find the minimum number of elements to be added to the array such that the maximum element in the array is less than or equal to the target value. \\n##### \\u2022\\tWe start with an empty subarray and keep adding elements to it until the maximum element in the subarray is greater than the target value. Once this happens, we remove elements from the beginning of the subarray until the maximum element is less than or equal to the target value. We repeat this process until we reach the end of the array. \\n##### \\u2022\\tAt each step, we keep track of the number of elements added to the array and return the minimum of all such values. \\n##### \\u2022\\tLet\\'s see how this works for the given input: Initially, we have an empty subarray and ans = 0 . \\n##### \\u2022\\tWe add the first element 3 to the subarray and update sum = 3 . We add the second element 7 to the subarray and update sum = 10 . \\n##### \\u2022\\tThe maximum element in the subarray is 7 , which is greater than the target value. So, we remove elements from the beginning of the subarray until the maximum element is less than or equal to the target value. \\n##### \\u2022\\tWe remove the first element 3 and update sum = 7 . We add the third element 1 to the subarray and update sum = 8 . \\n##### \\u2022\\tWe add the fourth element 6 to the subarray and update sum = 14 . \\n##### \\u2022\\tThe maximum element in the subarray is 7 , which is less than or equal to the target value. So, we don\\'t need to remove any elements. \\n##### \\u2022\\tWe update ans to max(ans, ceil((sum + nums[i]) / (i + 1))) = max(0, ceil(14/4)) = 4 . We remove the first element 7 from the subarray and update sum = 7 . \\n##### \\u2022\\tThe maximum element in the subarray is 6 , which is less than or equal to the target value. So, we don\\'t need to remove any elements. \\n##### \\u2022\\tWe update ans to max(ans, ceil((sum + nums[i]) / (i + 1))) = max(4, ceil(13/3)) = 5 . We remove the first element 1 from the subarray and update sum = 6 . \\n##### \\u2022\\tThe maximum element in the subarray is 6 , which is less than or equal to the target value. So, we don\\'t need to remove any elements. \\n##### \\u2022\\tWe update ans to max(ans, ceil((sum + nums[i]) / (i + 1))) = max(5, ceil(12/2)) = 6 . We remove the first element 6 from the subarray and update sum = 6 . \\n##### \\u2022\\tThe maximum element in the subarray is 6 , which is less than or equal to the target value. So, we don\\'t need to remove any elements. \\n##### \\u2022\\tWe update ans to max(ans, ceil((sum + nums[i]) / (i + 1))) = max(6, ceil(6/1)) = 6 . \\n##### \\u2022\\tWe have reached the end of the array. \\n##### \\u2022\\tThe minimum number of elements to be added to the array is ans = 6 . \\n##### \\u2022\\tTherefore, the output is 6 .\\n\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n\\n![meme2.png](https://assets.leetcode.com/users/images/d588f492-3f95-45f6-8e4a-10d6069002a5_1680054021.7117147.png)\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n\\nhttps://leetcode.com/problems/minimize-maximum-of-array/solutions/3381606/day-370-java-c-python-explained-intuition-approach-proof/\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```c++ []\\nint minimizeArrayValue(vector<int>& nums,long  ans=0,long  sum=0) {\\n        for(int i=0;i<nums.size();sum+=nums[i],i++)\\n            if(nums[i]>ans)ans=max(ans,(long )ceil((double)(sum+nums[i])/(i+1)));\\n        return (int)ans;\\n    }\\n```\n```java []\\npublic int minimizeArrayValue(int[] nums) {\\n        long ans=0,sum=0;\\n        for(int i=0;i<nums.length;sum+=nums[i],i++)\\n            if(nums[i]>ans)ans=Math.max(ans,(long)Math.ceil((double)(sum+nums[i])/(i+1)));\\n        return (int)ans;\\n    }\\n```\n```python []\\ndef minimizeArrayValue(nums):\\n    ans = 0\\n    sum = 0\\n    for i in range(len(nums)):\\n        sum += nums[i]\\n        if nums[i] > ans:\\n            ans = max(ans, math.ceil((sum + nums[i]) / (i + 1)))\\n    return int(ans)\\n```\n```python []\\nclass Solution:\\n    def minimizeArrayValue(self, A: List[int]) -> int:\\n        return max((a + i) // (i + 1) for i,a in enumerate(accumulate(A)))\\n```\n```c++ []\\nint minimizeArrayValue(vector<int>& A) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            sum += A[i];\\n            res = max(res, (sum + i) / (i + 1));\\n        }\\n        return res;\\n    }\\n```\n```java []\\npublic int minimizeArrayValue(int[] A) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < A.length; ++i) {\\n            sum += A[i];\\n            res = Math.max(res, (sum + i) / (i + 1));\\n        }\\n        return (int)res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706352,
                "title": "greedy-java-binary-search",
                "content": "A greedy approach with binary search for the best value can solve the problem.\\nNote that we can always increase nums[j] as a result of decreasing nums[i] for all values of i such that i > j.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    static int minimizeArrayValue(int[] nums) {\\n        int left = 0, right = Arrays.stream(nums).max().getAsInt(), best = 0;\\n        while(left <= right){\\n            int mid = (left + (right-left)/2);\\n            if(valid(mid, nums)){\\n                best = mid;\\n                right = mid - 1;\\n            }\\n            else left = mid + 1;\\n        }\\n        return best;\\n    }\\n\\n    private static boolean valid(int mid, int[] nums) {\\n        long sum = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > (long)mid * (i+1)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int minimizeArrayValue(int[] nums) {\\n        int left = 0, right = Arrays.stream(nums).max().getAsInt(), best = 0;\\n        while(left <= right){\\n            int mid = (left + (right-left)/2);\\n            if(valid(mid, nums)){\\n                best = mid;\\n                right = mid - 1;\\n            }\\n            else left = mid + 1;\\n        }\\n        return best;\\n    }\\n\\n    private static boolean valid(int mid, int[] nums) {\\n        long sum = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > (long)mid * (i+1)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381704,
                "title": "java-average-without-using-ceil-function",
                "content": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum=0;\\n        int max=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            max=Math.max(max,(int)intCeil(sum,i+1));\\n        }\\n        return max;\\n    }\\n    public long intCeil(long a,int b) {\\n      if(a%b!=0) {\\n          return (a/b)+1;\\n      }\\n      else \\n          return a/b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum=0;\\n        int max=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            max=Math.max(max,(int)intCeil(sum,i+1));\\n        }\\n        return max;\\n    }\\n    public long intCeil(long a,int b) {\\n      if(a%b!=0) {\\n          return (a/b)+1;\\n      }\\n      else \\n          return a/b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384802,
                "title": "math-explained-ceil-and-prefix-sum-explained-in-detail-beginner-friendly",
                "content": "People who are interested only in why ceil(prefix/n) gets converted to (prefix+i)/i+1 read point 6 better.\\n\\nceil(a/b) forumula = (a+b-1)/b\\n\\n# Intuition\\n1) Consider Array [1,3,5,7]\\nour ans for minMax will lie between the lower and upper bound of array\\nlowerbound 1, upper bound 7 i.e will be in between 1,2,3,4,5,6,7.\\n2) Now we want to find the optimal solution for the problem i.e we need to find a number in the range 1 to 7. This is the intution for binary search approach for us.\\n3) Next question how binary search, so we will pick a middle element and if that is valid we move left to find more optimised ans, if it is not valid we move towards right side and decrease the search.\\n4) Now what operation we need to do with mid?\\nwe do -1 for ith index and +1 for i-1th index, so here the total sum of the array is not changing\\n\\nsay we have 4 nos in array\\nn1,n2,n3,n4\\nx is the optimal solution (mid) i.e minMax of the array\\n\\nthen **n1+n2+n3+n4 <= x + x + x + x** this holds true sum of all the elements will be less then 4 times x as it is the minimumMax of the array\\n\\n5) Explained via  cases\\n- Case 1\\nArray: [1,3,5,7]\\nSum  = 1+3+5+7 = 16 and assume x=4 is the minMax that is 4+4+4+4 = 16\\nSo this way x=4 is the optimal solution, but 3 will never be answer as 3*4(3+3+3+3) = 12 and 16<=12 is false as 16 is > 12.\\ni.e any integer >=4 can be ans till obviously max of array i.e 7\\n\\n- Case 2\\na)\\nArray: [5,3,1,7]\\nhere sum is 16 but x=4 minMax is not possible, because number at index  0 is 5(and we know that we can only increment the index 0 not decrease via operations +1,-1)\\nin such cases 4 will never be an ans even is 4+4+4+4 = 16 and 16<=16 and the minMax cannot be less than 5\\n\\nWhat we learn from point 5 is that due to change in position our logic of \\nn1+n2+n3+n4 <= x + x + x + x can get hampered so to solve this we need to check this at every no of the array\\n\\nb)\\nn1 <= x\\nn1 + n2<= x+ x\\nn1 + n2 + n3<= x+ x+ x\\nn1 + n2 + n3 + n4 <= x+ x+ x+ x\\n\\nand this is the approach we follow for Binary search \\n\\n6) Now can we do better thatn nlog(high-low) of binary search? yes we can\\nfrom point 4 we know n1+n2+n3+n4 <= x + x + x + x (where x was the optimal number we were trying to find)\\n\\ni.e n1+n2+n3+n4 <= 4*x, so if we do\\nn1/1 = x1\\n\\n(n1 + n2)/2 = x2\\n\\n\\n(n1 + n2+ n3)/3 = x3\\n\\n(n1 + n2 + n3+ n4)/4 = x4\\n\\nand our ans will be nothing but max of max(x1,x2,x3,x4) say x\\' same thing we did in 5b so for binary search we were doing the same thing with different x values to get one optimal x\\'\\n\\n\\n\\nSo we are doing nothing but prefixSum <= n* x \\nn is the nothing but the i+1, we need to do a **ceil(prefix/i+1) <= x**\\nminimumMax will be ceil(prefix/i+1)\\n\\nTo find ceil(a/b) mathFormula is (a+b-1)/b , ceil(4/3) = 2\\nexample of this 4+3-1/3 => 7-1/3 = 2\\n\\nSo applying our formula *ceil(a/b) => ceil(prefix/n)*\\n=> prefix+n-1/n => subsituting n valur (prefix + (i+1) - 1)/i+1\\n= **(prefix+i)/i+1**\\n\\nand hence in code we write like below\\n\\n```\\nfor (int i = 0; i < nums.length; ++i) {\\n            prefixSum += nums[i];\\n            answer = Math.max(answer, (prefixSum + i) / (i + 1));\\n        }\\n``` \\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging\\n\\n\\n---\\n\\n\\n# Prefix sum approach Code\\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        // Initialize answer and the prefix sum.\\n        long answer = 0, prefixSum = 0;   \\n\\n        // Iterate over nums, update prefix sum and answer.\\n        for (int i = 0; i < nums.length; ++i) {\\n            prefixSum += nums[i];\\n            answer = Math.max(answer, (prefixSum + i) / (i + 1));\\n        }\\n\\n        return (int)answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nfor (int i = 0; i < nums.length; ++i) {\\n            prefixSum += nums[i];\\n            answer = Math.max(answer, (prefixSum + i) / (i + 1));\\n        }\\n```\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        // Initialize answer and the prefix sum.\\n        long answer = 0, prefixSum = 0;   \\n\\n        // Iterate over nums, update prefix sum and answer.\\n        for (int i = 0; i < nums.length; ++i) {\\n            prefixSum += nums[i];\\n            answer = Math.max(answer, (prefixSum + i) / (i + 1));\\n        }\\n\\n        return (int)answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381454,
                "title": "javascript-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. For an integer i such that 1 <= i < n and nums[i] > 0, decrease nums[i] by 1, increase nums[i - 1] by 1\\n=> Sum of this array doesn\\'t change\\n2. The smallest maximum is always greater or equal than the average of this array\\n3. The smallest maximum of the subarray from 0 to i is the greater of the average of this subarray and the smallest maximum of the subarray from 0 to i - 1.\\n\\nExample: We have an array [3, 7, 1, 6]\\n- i = 0: SubArray [3] \\n  - Smallest maximum is 3\\n- i = 1: SubArray [3, 7]\\n  - Average: 5\\n  - Smallest maximum: Math.max(5, 3) = 5\\n- i = 2: Subarray [3, 7, 1]\\n  - Average: 4\\n  - Smallest maximum: Math.max(5, 4) = 5\\n- i = 3: Subarray [3, 7, 1, 6]\\n  - Average: 5\\n  - Smallest maximum: Math.max(5, 5) = 5\\n=> Result = 5\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimizeArrayValue = function(nums) {\\n  let sum = 0;\\n  let res = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    sum += nums[i];\\n    res = Math.max(res, Math.ceil(sum / (i+1)));\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimizeArrayValue = function(nums) {\\n  let sum = 0;\\n  let res = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    sum += nums[i];\\n    res = Math.max(res, Math.ceil(sum / (i+1)));\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2715053,
                "title": "binary-search",
                "content": "# Intuition\\nAs we need to find the Minimum we can use binary search.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo know weather a particular number can be the maximum we can run throught array from `n - 1` to `1` and if the `nums[i]` is greater than the max we simply add the difference to `nums[i - 1]`.\\nAt the end we check if `nums[0]` is less than equal to `m`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(nlog(max))`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    bool possibleMax(vector<int>& ar, int m) {\\n        vector<long> nums(ar.begin(), ar.end());\\n        \\n        for(int i = n - 1; i > 0; i--) {\\n            if(nums[i] > m)\\n                nums[i - 1] += nums[i] - m;\\n        }\\n        \\n        return nums[0] <= m;\\n    }\\n    \\n    int minimizeArrayValue(vector<int>& nums) {\\n        n = nums.size();\\n        int l = 0, r = *max_element(nums.begin(), nums.end()), mid;\\n        \\n        while(l <= r) {\\n            mid = l + (r - l) / 2;\\n            if(possibleMax(nums, mid))\\n                r = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    bool possibleMax(vector<int>& ar, int m) {\\n        vector<long> nums(ar.begin(), ar.end());\\n        \\n        for(int i = n - 1; i > 0; i--) {\\n            if(nums[i] > m)\\n                nums[i - 1] += nums[i] - m;\\n        }\\n        \\n        return nums[0] <= m;\\n    }\\n    \\n    int minimizeArrayValue(vector<int>& nums) {\\n        n = nums.size();\\n        int l = 0, r = *max_element(nums.begin(), nums.end()), mid;\\n        \\n        while(l <= r) {\\n            mid = l + (r - l) / 2;\\n            if(possibleMax(nums, mid))\\n                r = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706560,
                "title": "prefix-sum-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {  \\n        int n = nums.size();\\n        \\n        vector<long long> pref(n, nums[0]);\\n        int ans = nums[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            pref[i] = pref[i - 1] + nums[i];\\n            int maxi = ceil(pref[i] / double(i + 1));\\n            ans = max(ans, maxi);    \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nor\\n\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {  \\n        int n = nums.size();\\n        \\n        vector<long long> pref(n, nums[0]);\\n        int ans = nums[0];\\n        long sum = nums[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            sum += nums[i];\\n            int maxi = ceil(sum / double(i + 1));\\n            ans = max(ans, maxi);  \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nUpvote if you found it helpful :)",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {  \\n        int n = nums.size();\\n        \\n        vector<long long> pref(n, nums[0]);\\n        int ans = nums[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            pref[i] = pref[i - 1] + nums[i];\\n            int maxi = ceil(pref[i] / double(i + 1));\\n            ans = max(ans, maxi);    \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {  \\n        int n = nums.size();\\n        \\n        vector<long long> pref(n, nums[0]);\\n        int ans = nums[0];\\n        long sum = nums[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            sum += nums[i];\\n            int maxi = ceil(sum / double(i + 1));\\n            ans = max(ans, maxi);  \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381817,
                "title": "c-easy-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int minimizeArrayValue(vector<int>& v) {\\n        int n=v.size();\\n        ll i=0,j=10000000000;\\n        ll ans=j;\\n        while(i<=j){\\n            ll m=(i+j)/2;\\n            ll ex=0;\\n            for(int i=n-1;i>=0;i--){\\n              if(v[i]>m){\\n                  ex += v[i]-m;\\n              }\\n              else {\\n                  ll need=m-v[i];\\n                  ex -= min(ex,need);\\n              }\\n            }\\n            if(ex){\\n                i=m+1;\\n            }\\n            else {\\n                ans=m;\\n                j=m-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/fa0dc593-7f28-4ad1-8019-76add4d12ba5_1680673503.1127512.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int minimizeArrayValue(vector<int>& v) {\\n        int n=v.size();\\n        ll i=0,j=10000000000;\\n        ll ans=j;\\n        while(i<=j){\\n            ll m=(i+j)/2;\\n            ll ex=0;\\n            for(int i=n-1;i>=0;i--){\\n              if(v[i]>m){\\n                  ex += v[i]-m;\\n              }\\n              else {\\n                  ll need=m-v[i];\\n                  ex -= min(ex,need);\\n              }\\n            }\\n            if(ex){\\n                i=m+1;\\n            }\\n            else {\\n                ans=m;\\n                j=m-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381472,
                "title": "day-95-o-n-time-and-o-1-space-easiest-beginner-friendly-solution",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\n**WHY THIS CODE IS WORKING EFFICIENTLY ?**\\n*The reason for this is that if we want to minimize the value of the array, we need to make sure that the smallest value in the array is as large as possible. If we assume that the smallest value in the array is x, then the value of the array can be expressed as the sum of the differences between each element and x. Therefore, to minimize the value of the array, we want to make sure that these differences are as small as possible.*\\n\\n*One way to ensure that these differences are small is to make sure that the elements of the array are as close to each other as possible. If we assume that the elements of the array are sorted in ascending order, then one way to achieve this is to ensure that the differences between adjacent elements are at most 1. If we can achieve this, then we can obtain the minimum possible value of the array by setting the smallest value to be the first element of the sorted array.*\\n\\n*Now, let\\'s consider the subarray from the beginning of the array to the current position i. If we can ensure that the elements of this subarray are as close to each other as possible, then we can ensure that the smallest value in the subarray is as large as possible. Therefore, we want to find the largest possible average value of the elements in this subarray, so that we can ensure that the elements are as close to each other as possible.\\n*\\n*To find the largest possible average value of the elements in the subarray, we need to find the largest possible sum of the elements in the subarray. We can do this by adding up the elements of the subarray as we iterate through the array, and dividing the sum by the length of the subarray. Therefore, the expression (sum + i) / (i + 1) gives us the maximum possible average value of the elements in the subarray from the beginning of the array to the current position.*\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Initialize a long long integer variable sum to 0 and an integer variable ans to 0.\\n2. Iterate through the array nums from index 0 to n-1.\\n3. Add the current element of the array nums to sum.\\n4. Calculate the maximum possible average value of the elements in the subarray from the beginning of the array to the current position using the formula (sum + i) / (i + 1), where i is the current index.\\n5. Update the value of ans to the maximum of its current value and the value obtained in step 4.\\n6. Return the value of ans.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long int sum = 0;\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            ans = max(ans, (int)((sum + i) / (i + 1)));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0;\\n        int ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            ans = Math.max(ans, (int)((sum + i) / (i + 1)));\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        sum = 0\\n        ans = 0\\n        for i in range(len(nums)):\\n            sum += nums[i]\\n            ans = max(ans, (sum + i) // (i + 1))\\n        return ans\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** **O(n)**, where n is the size of array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long int sum = 0;\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            ans = max(ans, (int)((sum + i) / (i + 1)));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0;\\n        int ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            ans = Math.max(ans, (int)((sum + i) / (i + 1)));\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        sum = 0\\n        ans = 0\\n        for i in range(len(nums)):\\n            sum += nums[i]\\n            ans = max(ans, (sum + i) // (i + 1))\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826447,
                "title": "python-binary-search-on-answer-easy-to-understand",
                "content": "How can we identify whether we can use Binary Search on this problem?\\n\\nSee, whenever you see any problem that asks us to \"Minimize\" or \"Maximize\" something, you have to try to see if there is monotonicity. \\n\\nFor example, we are asked to \"Minimize\" the maximum value. It means, we have to make sure that we perform operations such that at the end, we have minimized the maximum value in the array to an extent that we cannot further minimize it.\\n\\n\\tSuppose we take an example -> nums = [3,7,1,6]\\n\\t\\n\\tHere, as the example reveals, the output is 5. \\n\\t\\n\\t5 means that if we take any index >= 1 and < n, and it is > 5, we can try to decrement it until it is == 5\\n\\t\\n\\tAnd the amount by which we decrement it is the same amount we have to use to increment the previous value\\n\\t\\n\\tWe start with \"7\". Since 7 > 5. We decrement it by 2 so that 7 now becomes 7 - 2 = 5\\n\\t\\n\\tSince we decremented \"7\", that means, we have to increment \"3\" by the same amount. \\n\\t\\n\\tSo after first operation, the array becomes -> [5,5,1,6]\\n\\t\\n\\tNow, when we reach \"6\", again \"6\" > \"5\". So we decrement it by 1 to make it 5.\\n\\t\\n\\tAnd we also increment \"1\" to make it 2.\\n\\t\\n\\tFinally, array becomes [5,5,2,5]\\n\\nNow, just think why cannot be any value less than \"5\" valid? What i we take \"4\" as the minimum value? Is it possible to convert all the values to be <= 4? Let\\'s see.\\n\\n\\tnums = [3,7,1,6]\\n\\t\\n\\tFirst, we have \"7\". We decrement it by 3 and increment previous \"3\" by \"3\". \\n\\n\\tnums = [6,4,1,6]\\n\\t\\n\\tDid you see what the issue is? Now, even though \"3\" was already a good value previously, since we added \"3\" more\\n\\tit now became > 4 which made it a bad value. So ofcourse \"4\" cannot be a valid value here.\\n\\t\\n\\tAnd since \"4\" is not valid, no value less than \"4\" is valid too. And that\\'s the monotonicity.\\n\\t\\n\\tSimilarly, if \"5\" was valid, then \"6\" or \"7\" or \"8\" or any value more than \"5\" is also a valid output. \\n\\t\\n\\tBut we want to minimize the valid value.\\n\\t\\nAnd since there is this monotonicity, it suggests we can apply Binary Search on this range of possible valid values. That\\'s what we call -\"**BINARY SEARCH ON ANSWER**\".\\n\\nNow think about what can be the range of valid possible minimum values? For test cases such as [10, 0] where the first element has the maximum value, there is no way we can minimize since decrement operation needs to be performed on indices >= 1 and < n. So this means, for any input, the upper limit is the maximum value in that input array.\\n\\nAnd similarly, what can be the lower limit? That\\'s what we are asked to find. We are asked to return the minimum possible valid value. And so, we can take the lower limit as \"0\". Since the nums[i] can be at least \"0\".\\n\\nSo now, we have this range [0, max(nums)] on which we have to apply Binary search. Each \"mid\" that we get is a possible valid minimum value. But we have to check if that\\'s the case. IF yes, then as we saw above, all values greater than \"mid\" will be valid too. But if not, then all values less than \"mid\" will be invalid.\\n\\nNow, continuing the example above - \\n\\n\\t\\tnums = [3,7,1,6]\\n\\t\\t\\n\\t\\tWhen we considered min value as \"4\", we saw that it made a good value \"3\", bad \\n\\t\\tby incrementing it such that it became more than 4.\\n\\t\\t\\n\\t\\tThis means, we cannot just blindly increment and decrement values.\\n\\t\\t\\n\\t\\tThere must be some limit by which we can decrement one value and increment the other.\\n\\t\\t\\n\\t\\tFor example in nums = [3,7,1,6], we can see that if we have min value as \"5\", then that means\\n\\t\\t\\n\\t\\t\"3\" cannot be incremented by any value > 2 because that would convert it to a bad value. \\n\\t\\t\\n\\t\\tHence, the increment limit is \"2\" here. And that means, we can decrement \"7\" by \"2\" only. \\n\\t\\t\\n\\t\\tNot by any number > 2\\n\\t\\n\\t\\tHence, instead of trying to decrement a value and then increment the previous value, we can do the opposite.\\n\\t\\t\\n\\t\\tThat is, try to see how much we can increment a value and then based on that \\n\\n\\t\\twe can decrement the next value if it is more than the minimum we are trying to validate.\\n\\t\\t\\n\\nAnd that\\'s why, in the \"isValid()\" method, I have a variable \"buffer\". It will check if current value is less than \"x\" then by what amount we can increment it such that it is still <= x. That will be our buffer.\\n\\nSimilarly, if some value is greater than \"x\", then the amount by which we can decrement it such that it is <= x should not be more than the buffer. We saw this when we considered \"x\" as \"4\" in nums = [3,7,1,6]. When it was \"4\", we saw that while buffer is only \"1\" for \"3\", we have to decrement \"7\" by \"3\" to make it <= 4. \\n\\nSo if this is the case for any number, we can straight away return False as there is no way to make sure all values are <= x in that case.\\n\\n\\n```\\nclass Solution:\\n    \\n    # Helper method to check if \"x\" can be the minimum possible value of the maximum integer of nums\\n    # \"x\" can be the minimum possible value if after performing any number of operations if\\n    # The maximum value at the end of resultinng array is <= x\\n    # So in short, we are trying to take each value and make sure it is <= x\\n    # If it is more than \"x\", then when we reduce it, we also want to increment the previous value by the same amount\\n    def isValid(self, x, nums): \\n        buffer = 0\\n        \\n        for num in nums:\\n            # If num is less than x, that means, we have a buffer of (x - num)\\n            # So we can increment this value by atmost (x - num)\\n            if num < x: \\n                buffer += x - num\\n            else:\\n                # If num is greater than x, we have to decrement it\\n                # But we only can use the available buffer\\n                # That is, the amount by which we have to decrement, should be <= buffer\\n                \\n                # If the amount by which we have to decrement is > buffer, then we can return False\\n                # As there is no way we can make all elements of array <= x in this case\\n                if buffer < num - x: return False\\n                \\n                # Otherwise, if the amount by which we have to decrement is <= buffer\\n                # we can use the amount from the available buffer\\n                buffer -= num - x\\n\\n        return True\\n                \\n    \\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        # We want to find minimum possible value of the maximum number in the list\\n        # What can be the range?\\n        \\n        # Ofcourse, we are trying to reduce the maximum value which means upper limit is the maximum value itself\\n        \\n        # What can be the smallest possible valid value after reducing the maximum number?\\n        # So we can take \"0\" as the lower limit since nums[i] can be at least 0\\n        \\n        start = 0\\n        end = max(nums)\\n\\n        minValue = end\\n        \\n        # For cases like [10, 0] where 0th index has the maximum value\\n        if nums[0] == end: return minValue\\n\\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            \\n            # If \"mid\" can be the minimum value of the maximum integer of nums\\n            # Then that means any value more than \"mid\" is also valid\\n            # but we want to minimize this value so we keep searching on left side of mid\\n            if self.isValid(mid, nums):\\n                minValue = mid\\n                end = mid - 1\\n            \\n            # If \"mid\" cannot be the minimum value, no value less than \"mid\" is valid\\n            # Hence, we will search for a valid minimum possible value on the right side of mid\\n            else: start = mid + 1\\n        \\n        return minValue\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # Helper method to check if \"x\" can be the minimum possible value of the maximum integer of nums\\n    # \"x\" can be the minimum possible value if after performing any number of operations if\\n    # The maximum value at the end of resultinng array is <= x\\n    # So in short, we are trying to take each value and make sure it is <= x\\n    # If it is more than \"x\", then when we reduce it, we also want to increment the previous value by the same amount\\n    def isValid(self, x, nums): \\n        buffer = 0\\n        \\n        for num in nums:\\n            # If num is less than x, that means, we have a buffer of (x - num)\\n            # So we can increment this value by atmost (x - num)\\n            if num < x: \\n                buffer += x - num\\n            else:\\n                # If num is greater than x, we have to decrement it\\n                # But we only can use the available buffer\\n                # That is, the amount by which we have to decrement, should be <= buffer\\n                \\n                # If the amount by which we have to decrement is > buffer, then we can return False\\n                # As there is no way we can make all elements of array <= x in this case\\n                if buffer < num - x: return False\\n                \\n                # Otherwise, if the amount by which we have to decrement is <= buffer\\n                # we can use the amount from the available buffer\\n                buffer -= num - x\\n\\n        return True\\n                \\n    \\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        # We want to find minimum possible value of the maximum number in the list\\n        # What can be the range?\\n        \\n        # Ofcourse, we are trying to reduce the maximum value which means upper limit is the maximum value itself\\n        \\n        # What can be the smallest possible valid value after reducing the maximum number?\\n        # So we can take \"0\" as the lower limit since nums[i] can be at least 0\\n        \\n        start = 0\\n        end = max(nums)\\n\\n        minValue = end\\n        \\n        # For cases like [10, 0] where 0th index has the maximum value\\n        if nums[0] == end: return minValue\\n\\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            \\n            # If \"mid\" can be the minimum value of the maximum integer of nums\\n            # Then that means any value more than \"mid\" is also valid\\n            # but we want to minimize this value so we keep searching on left side of mid\\n            if self.isValid(mid, nums):\\n                minValue = mid\\n                end = mid - 1\\n            \\n            # If \"mid\" cannot be the minimum value, no value less than \"mid\" is valid\\n            # Hence, we will search for a valid minimum possible value on the right side of mid\\n            else: start = mid + 1\\n        \\n        return minValue\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708976,
                "title": "c-binary-search-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool valid(int mid,vector<int> nums){\\n        long sum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            sum += nums[i];\\n            if(sum > (long)mid*(i+1)) return false;\\n        }\\n        return true;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int left = 0;\\n        int right = *max_element(nums.begin(),nums.end());\\n        int ans = 0;\\n        while(left <= right)\\n        {\\n            int mid = (left + right)/2;\\n            if(valid(mid,nums))\\n            {\\n                ans = mid;\\n                right = mid - 1;\\n            }\\n            else\\n            {\\n                left = mid + 1;\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int mid,vector<int> nums){\\n        long sum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            sum += nums[i];\\n            if(sum > (long)mid*(i+1)) return false;\\n        }\\n        return true;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int left = 0;\\n        int right = *max_element(nums.begin(),nums.end());\\n        int ans = 0;\\n        while(left <= right)\\n        {\\n            int mid = (left + right)/2;\\n            if(valid(mid,nums))\\n            {\\n                ans = mid;\\n                right = mid - 1;\\n            }\\n            else\\n            {\\n                left = mid + 1;\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707159,
                "title": "rust-11-ms-fastest-100-one-liner-proof-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/823174253/) employs averaging of prefix cumulative sum. It demonstrated **11 ms runtime (100.00%)** and used **3.3 MB memory (100.00%)**. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\nPlease check the analogous solution in [**Python**](https://leetcode.com/problems/minimize-maximum-of-array/discuss/2707345/Python-average-cumsum-%2B-PROOF-(with-detailed-comments)).\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn minimize_array_value(mut nums: Vec<i32>) -> i32 \\n    {\\n\\t    // here is the proof why it works...\\n\\t\\t// [a] the flow of value is only to the left; \\n        // [b] this eventually leads to a non-increasing list \\'final\\';\\n        // [c] in the end, the element \\'final[0]\\' will contain the answer;\\n        // [d] however, to detect this element without simulating the actual flow,\\n        //     we notice that, for each prefix, its average cumulative sum can\\n        //     not surpass the 0th element of the \\'final\\' list (pigeonhole principle)\\n        // [e] the question is, will the ceiled value of the average prefix sum \\n        //     ever be equal to the initial element of the resulting list (for some prefix)?\\n        // [f] yes, because if for ALL prefixes their average cumsum < \\'final[0]\\'\\n        //     then it is simply not possible to transfer value from right to left\\n        //     such that it becomes \\'final[0]\\' (can be proved by induction on prefixes)\\n        let mut sum: usize = 0;\\n        nums.into_iter()\\n            .enumerate()\\n            .map(|(i,n)| { sum += n as usize; (sum + i) / (i + 1) })\\n            .max().unwrap() as i32\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Prefix Sum"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn minimize_array_value(mut nums: Vec<i32>) -> i32 \\n    {\\n\\t    // here is the proof why it works...\\n\\t\\t// [a] the flow of value is only to the left; \\n        // [b] this eventually leads to a non-increasing list \\'final\\';\\n        // [c] in the end, the element \\'final[0]\\' will contain the answer;\\n        // [d] however, to detect this element without simulating the actual flow,\\n        //     we notice that, for each prefix, its average cumulative sum can\\n        //     not surpass the 0th element of the \\'final\\' list (pigeonhole principle)\\n        // [e] the question is, will the ceiled value of the average prefix sum \\n        //     ever be equal to the initial element of the resulting list (for some prefix)?\\n        // [f] yes, because if for ALL prefixes their average cumsum < \\'final[0]\\'\\n        //     then it is simply not possible to transfer value from right to left\\n        //     such that it becomes \\'final[0]\\' (can be proved by induction on prefixes)\\n        let mut sum: usize = 0;\\n        nums.into_iter()\\n            .enumerate()\\n            .map(|(i,n)| { sum += n as usize; (sum + i) / (i + 1) })\\n            .max().unwrap() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3383020,
                "title": "easy-way-by-using-prefix-sum",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long ans = 0, sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n\\n            long long res=(sum+i)/(i+1);\\n            ans = max(ans, res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long ans = 0, sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n\\n            long long res=(sum+i)/(i+1);\\n            ans = max(ans, res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707266,
                "title": "easy-intuitive-solution-fully-explained",
                "content": "# Intuition\\nsee first thing i saw in this question was \"minimum maximum\" this is something that gives you an idea to look towards a binary search approach ...... also the time complexity you need is something that will make this binary search intuition stronger.... \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nit is a simple binary search approach , which is going on mid value , writting a check function and then according to check function moving in first half or second half ....... one thing that you need to think about is check function for that you can refer to my code .... and yeah that\\'s all\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nm=end value(e.g 10^9)\\nn=vec length\\nT.C=O(n*log(m))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& nums,int val){\\n        int n=nums.size();\\n        long long count=0;\\n        bool ans=true;\\n        for(int i=0;i<n;i++){\\n            count+=(nums[i]-val);\\n            if(count>0){\\n                ans=false;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n        vector<int> temp=nums;\\n        sort(temp.begin(),temp.end());\\n        int start=temp[0];\\n        int end=temp[temp.size()-1];\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(check(nums,mid)){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& nums,int val){\\n        int n=nums.size();\\n        long long count=0;\\n        bool ans=true;\\n        for(int i=0;i<n;i++){\\n            count+=(nums[i]-val);\\n            if(count>0){\\n                ans=false;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n        vector<int> temp=nums;\\n        sort(temp.begin(),temp.end());\\n        int start=temp[0];\\n        int end=temp[temp.size()-1];\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(check(nums,mid)){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381370,
                "title": "simple-solution-with-detailed-explanation-javascript-go-rust",
                "content": "## Approach\\nWe can use the prefix sum approach in this problem because we need to calculate the maximum possible value of the array after performing any number of operations. The operation we can perform at any step is to choose an integer i such that 1 <= i < n and subtract 1 from nums[i] and add 1 to nums[i-1].\\n\\nThis operation implies that we can only decrease the value of an element if there is another element before it that we can increase. Therefore, we need to consider the values of the elements in a cumulative fashion. That is, the value of an element at index i depends not only on its own value, but also on the values of all elements before it.\\n\\nUsing a prefix sum approach allows us to keep track of the sum of the values of the elements up to index i. This sum gives us an estimate of the maximum possible value of the array if we were to distribute the sum equally among all elements up to index i. By taking the ceiling of this estimate, we get an upper bound on the maximum value of the array if we were to distribute the sum equally among all elements up to index i. We can then compare this upper bound with the current maximum value seen so far and update the maximum value if necessary.\\n\\nUsing a prefix sum approach allows us to compute the upper bound for each index i in O(n) time, resulting in a time complexity of O(n) for the entire algorithm. This is more efficient than an approach that would involve computing the maximum possible value of the array after each operation, which would take O(n^2) time.\\n\\n## Solution\\n\\n<iframe src=\"https://leetcode.com/playground/nFPqkSrK/shared\" frameBorder=\"0\"></iframe>\\n\\nThe `minimizeArrayValue` function takes an input array `nums` and returns the minimum possible value of the maximum integer after performing any number of operations.\\n\\nThe function first initializes two variables `max` and `prefixSum` to zero. The `max` variable will keep track of the maximum value seen so far, while the `prefixSum` variable will keep track of the prefix sum of the input array.\\n\\nThe function then iterates through the input array using a for loop. In each iteration, the function adds the current element to the prefix sum using `prefixSum += nums[i]`. It then computes the maximum value seen so far using `Math.max(max, Math.ceil(prefixSum / (i + 1)))`. The Math.ceil function rounds the prefix sum divided by the number of elements seen so far up to the nearest integer, which represents the maximum possible value of the array if we were to distribute the prefix sum equally among all elements seen so far. The `Math.max` function compares this maximum possible value with the current maximum value seen so far, and updates `max` if necessary.\\n\\nAfter iterating through the input array, the function returns the minimum possible value of the maximum integer, which is the value of `max`.",
                "solutionTags": [
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Prefix Sum"
                ],
                "code": "## Approach\\nWe can use the prefix sum approach in this problem because we need to calculate the maximum possible value of the array after performing any number of operations. The operation we can perform at any step is to choose an integer i such that 1 <= i < n and subtract 1 from nums[i] and add 1 to nums[i-1].\\n\\nThis operation implies that we can only decrease the value of an element if there is another element before it that we can increase. Therefore, we need to consider the values of the elements in a cumulative fashion. That is, the value of an element at index i depends not only on its own value, but also on the values of all elements before it.\\n\\nUsing a prefix sum approach allows us to keep track of the sum of the values of the elements up to index i. This sum gives us an estimate of the maximum possible value of the array if we were to distribute the sum equally among all elements up to index i. By taking the ceiling of this estimate, we get an upper bound on the maximum value of the array if we were to distribute the sum equally among all elements up to index i. We can then compare this upper bound with the current maximum value seen so far and update the maximum value if necessary.\\n\\nUsing a prefix sum approach allows us to compute the upper bound for each index i in O(n) time, resulting in a time complexity of O(n) for the entire algorithm. This is more efficient than an approach that would involve computing the maximum possible value of the array after each operation, which would take O(n^2) time.\\n\\n## Solution\\n\\n<iframe src=\"https://leetcode.com/playground/nFPqkSrK/shared\" frameBorder=\"0\"></iframe>\\n\\nThe `minimizeArrayValue` function takes an input array `nums` and returns the minimum possible value of the maximum integer after performing any number of operations.\\n\\nThe function first initializes two variables `max` and `prefixSum` to zero. The `max` variable will keep track of the maximum value seen so far, while the `prefixSum` variable will keep track of the prefix sum of the input array.\\n\\nThe function then iterates through the input array using a for loop. In each iteration, the function adds the current element to the prefix sum using `prefixSum += nums[i]`. It then computes the maximum value seen so far using `Math.max(max, Math.ceil(prefixSum / (i + 1)))`. The Math.ceil function rounds the prefix sum divided by the number of elements seen so far up to the nearest integer, which represents the maximum possible value of the array if we were to distribute the prefix sum equally among all elements seen so far. The `Math.max` function compares this maximum possible value with the current maximum value seen so far, and updates `max` if necessary.\\n\\nAfter iterating through the input array, the function returns the minimum possible value of the maximum integer, which is the value of `max`.",
                "codeTag": "Unknown"
            },
            {
                "id": 2707345,
                "title": "python-average-cumsum-proof-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/823207210/) employs averaging of prefix cumulative sum. It demonstrated **819 ms runtime (100.00%)** and used **26 MB memory (100.00%)**. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\nPlease check the analogous solution in [**Rust**](https://leetcode.com/problems/minimize-maximum-of-array/discuss/2707159/Rust-11-ms-fastest-(100)-solution-using-cumsumaverage-(with-detailed-comments)).\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nfrom math import ceil\\n\\nclass Solution:\\n    def minimizeArrayValue(self, nums: list[int]) -> int:\\n\\n        cumsum = 0\\n        result = 0\\n        \\n        # here is the proof why it works...\\n\\t\\t# [a] the flow of value is only to the left; \\n        # [b] this eventually leads to a non-increasing list \\'final\\';\\n        # [c] in the end, the element \\'final[0]\\' will contain the answer;\\n        # [d] however, to detect this element without simulating the actual flow,\\n        #     we notice that, for each prefix, its average cumulative sum can\\n        #     not surpass the 0th element of the \\'final\\' list (pigeonhole principle)\\n        # [e] the question is, will the ceiled value of the average prefix sum \\n        #     ever be equal to the initial element of the resulting list (for some prefix)?\\n        # [f] yes, because if for ALL prefixes their average cumsum < \\'final[0]\\'\\n        #     then it is simply not possible to transfer value from right to left\\n        #     such that it becomes \\'final[0]\\' (can be proved by induction on prefixes)\\n\\n        for i, n in enumerate(nums, start=1):\\n            cumsum += n\\n            result = max(ceil(cumsum / i), result)\\n\\n        return result\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Prefix Sum"
                ],
                "code": "```\\nfrom math import ceil\\n\\nclass Solution:\\n    def minimizeArrayValue(self, nums: list[int]) -> int:\\n\\n        cumsum = 0\\n        result = 0\\n        \\n        # here is the proof why it works...\\n\\t\\t# [a] the flow of value is only to the left; \\n        # [b] this eventually leads to a non-increasing list \\'final\\';\\n        # [c] in the end, the element \\'final[0]\\' will contain the answer;\\n        # [d] however, to detect this element without simulating the actual flow,\\n        #     we notice that, for each prefix, its average cumulative sum can\\n        #     not surpass the 0th element of the \\'final\\' list (pigeonhole principle)\\n        # [e] the question is, will the ceiled value of the average prefix sum \\n        #     ever be equal to the initial element of the resulting list (for some prefix)?\\n        # [f] yes, because if for ALL prefixes their average cumsum < \\'final[0]\\'\\n        #     then it is simply not possible to transfer value from right to left\\n        #     such that it becomes \\'final[0]\\' (can be proved by induction on prefixes)\\n\\n        for i, n in enumerate(nums, start=1):\\n            cumsum += n\\n            result = max(ceil(cumsum / i), result)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382839,
                "title": "full-explanation-in-simple-way-in-js",
                "content": "# Intuition\\n\\nWe\\'ll use :\\n- Math floor\\n- Math.max\\n- For loop\\n\\n*Math.max(a, b) - Returns the maximum value between a and b. This is used to update the result variable with the higher value between the previous value of result and the current calculated value.*\\n\\n*Math.floor(x) - Returns the largest integer less than or equal to a given number x. This is used to round down the calculated value of (curr + i) / (i + 1) to the nearest integer value.\\n*\\n# Approach\\n\\nUse a for loop to iterate through each element in the nums array. For each iteration:\\na. Add the current element to the curr variable, which represents the running total of the elements seen so far.\\nb. Calculate the current result by taking the maximum value between the previous result value and the floor division of the sum of curr and i (the current index) by i + 1. The purpose of this calculation is to determine the minimum value that can be obtained by performing the operation described earlier.\\nReturn the final value of result, which represents the minimum possible value that can be obtained by performing the operation on the input array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst minimizeArrayValue = function(nums) {\\n    let result= 0, curr= 0 ;\\n    for(let i= 0; i< nums.length; i++){\\n       curr += nums[i];\\n       result= Math.max(result, Math.floor((curr+ i)/ (i+ 1)));\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst minimizeArrayValue = function(nums) {\\n    let result= 0, curr= 0 ;\\n    for(let i= 0; i< nums.length; i++){\\n       curr += nums[i];\\n       result= Math.max(result, Math.floor((curr+ i)/ (i+ 1)));\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3382626,
                "title": "binary-search-c-bi",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thing that comes in your mind is to use ```BINARY SEARCH```.\\nBut this que is a little bit tricky, let\\'s see how to do that.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Apply binary search between 0 to maxElement.\\n2. Check for mid value that it is bigger or smaller than array elements, if it is smaller than the elements then update ```s to mid+1``` otherwise update it ```e to mid```.\\n3. Continue the process until find the min value.\\n\\nOptimisation: You can use s=nums[0] instead s=0 (I would suggest you to dry run).\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& nums, long long mid){\\n        int n=nums.size();\\n        long long previous = nums[0];\\n        if(previous > mid) return false;\\n\\n        for(int i=1;i<n;i++){\\n            long long dif = mid - previous;\\n            previous = nums[i] - dif;\\n            if(previous > mid){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long s=nums[0], e = *max_element(nums.begin(),nums.end());\\n\\n        while(s<e){\\n            int mid=(s+e)/2;\\n            if(check(nums,mid)){\\n                e=mid;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n};\\n```\\n\\n![please upvote.png](https://assets.leetcode.com/users/images/d0a2012c-257d-4c39-b102-5937b9f0280a_1680691030.312623.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```BINARY SEARCH```\n```s to mid+1```\n```e to mid```\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& nums, long long mid){\\n        int n=nums.size();\\n        long long previous = nums[0];\\n        if(previous > mid) return false;\\n\\n        for(int i=1;i<n;i++){\\n            long long dif = mid - previous;\\n            previous = nums[i] - dif;\\n            if(previous > mid){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long s=nums[0], e = *max_element(nums.begin(),nums.end());\\n\\n        while(s<e){\\n            int mid=(s+e)/2;\\n            if(check(nums,mid)){\\n                e=mid;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382267,
                "title": "java-prefsum-minimize-array-value",
                "content": "\\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        int max = 0;\\n        double cur = 0;\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            cur += nums[i];\\n            max = Math.max(max, (int)Math.ceil(cur / (i + 1)));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        int max = 0;\\n        double cur = 0;\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            cur += nums[i];\\n            max = Math.max(max, (int)Math.ceil(cur / (i + 1)));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381682,
                "title": "go-solution-binary-search",
                "content": "# Approach\\nWe determine the minimum and maximum that the result can be and then iterate through the options using a binary search. Further, while the $left$ is less than the $right$, we take the $middle$, and see what happens if we try to bring our array to the $middle$. We go from the last element to the first, if $nums[i]$ is greater than the $middle$, then we add the difference to the $total$, there is how much we need to subtract later. If the element is less than the $middle$, we add negative difference to the $total$, if the $total$ becomes less than zero we bring it back to zero. In the last step of the loop, we check whether it is possible to subtract $total$ from the $nums[0]$ and, depending on this, we decide in which direction to shift the boundary of our search.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n log (m))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nfunc minimizeArrayValue(nums []int) int {\\n\\tleft, right, sum := 0, 0, 0\\n\\n\\tfor _, num := range nums {\\n\\t\\tright = max(right, num)\\n        sum += num\\n\\t}\\n    left = sum / len(nums)\\n\\n\\tfor left < right {\\n\\t\\tmid := (left + right) / 2\\n\\t\\ttotal := 0\\n    \\n\\t\\tfor i := len(nums) - 1; i > 0; i-- {\\n            total += nums[i] - mid\\n\\t\\t\\tif total < 0 {\\n                total = 0\\n            }\\n\\t\\t}\\n\\n\\t\\tif nums[0]+total > mid {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t} else {\\n\\t\\t\\tright = mid\\n\\t\\t}\\n\\t}\\n\\n\\treturn left\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimizeArrayValue(nums []int) int {\\n\\tleft, right, sum := 0, 0, 0\\n\\n\\tfor _, num := range nums {\\n\\t\\tright = max(right, num)\\n        sum += num\\n\\t}\\n    left = sum / len(nums)\\n\\n\\tfor left < right {\\n\\t\\tmid := (left + right) / 2\\n\\t\\ttotal := 0\\n    \\n\\t\\tfor i := len(nums) - 1; i > 0; i-- {\\n            total += nums[i] - mid\\n\\t\\t\\tif total < 0 {\\n                total = 0\\n            }\\n\\t\\t}\\n\\n\\t\\tif nums[0]+total > mid {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t} else {\\n\\t\\t\\tright = mid\\n\\t\\t}\\n\\t}\\n\\n\\treturn left\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3381234,
                "title": "easiest-c-solution-with-explaination-3-lines-of-code",
                "content": "# Overview\\nAs shown in the picture below, we can make two operations to decrease nums[1] by 2 and increase nums[0] by 2, so the maximum value of nums is 5. It can be shown that this is the minimum maximum value we can make.\\n\\n![1.png](https://assets.leetcode.com/users/images/733ecc75-aa13-4f8a-a8fd-7a12f4354b40_1680654477.8796961.png)\\n\\n# Algorithm:\\n- Initialize `sum = 0` and `res = 0`.\\n- Iterate over nums, for each index i:\\n    - Update the sum as `sum += nums[i]`.\\n    - Check the maximum value we can obtain by averaging `sum` into `i + 1` evenly using ceiling division.\\n    - Take the larger one from `res` and the result from the previous integer division.\\n- Return `res`\\n\\n# Complexity Analysis\\nLet n be the length of the input array nums.\\n\\n- Time complexity: `O(n)`\\n\\nWe need to traverse nums once.\\nAt each step of the iteration, we update `sum` and `res` and it takes `O(1)` time.\\nTo sum up, the overall time complexity is `O(n)`.\\n- Space complexity: `O(1)`\\n\\nDuring the iteration, we only need to update the `sum` and update `res`, it takes `O(1)` space.\\n\\n# Code \\n## C++\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            sum += nums[i];\\n            res = max(res, (sum + i) / (i + 1));\\n        }\\n        return res;\\n    }\\n};\\n```\\n## Java\\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        // Initialize answer and the prefix sum.\\n        long answer = 0, prefixSum = 0;   \\n\\n        // Iterate over nums, update prefix sum and answer.\\n        for (int i = 0; i < nums.length; ++i) {\\n            prefixSum += nums[i];\\n            answer = Math.max(answer, (prefixSum + i) / (i + 1));\\n        }\\n\\n        return (int)answer;\\n    }\\n}\\n```\\n\\n## Python\\n```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        # Initialize answer and the prefix sum.\\n        answer = 0\\n        prefix_sum = 0\\n        \\n        # Iterate over nums, update prefix sum and answer.\\n        for i in range(len(nums)):\\n            prefix_sum += nums[i]\\n            answer = max(answer, math.ceil(prefix_sum / (i + 1)))\\n\\n        return answer\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            sum += nums[i];\\n            res = max(res, (sum + i) / (i + 1));\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        // Initialize answer and the prefix sum.\\n        long answer = 0, prefixSum = 0;   \\n\\n        // Iterate over nums, update prefix sum and answer.\\n        for (int i = 0; i < nums.length; ++i) {\\n            prefixSum += nums[i];\\n            answer = Math.max(answer, (prefixSum + i) / (i + 1));\\n        }\\n\\n        return (int)answer;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        # Initialize answer and the prefix sum.\\n        answer = 0\\n        prefix_sum = 0\\n        \\n        # Iterate over nums, update prefix sum and answer.\\n        for i in range(len(nums)):\\n            prefix_sum += nums[i]\\n            answer = max(answer, math.ceil(prefix_sum / (i + 1)))\\n\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381220,
                "title": "daily-leetcoding-challenge-april-day-5",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimize-maximum-of-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimize-maximum-of-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2726098,
                "title": "c-easy-average-concept-explained-100-faster",
                "content": "If (nums[i-1] < nums[i])\\nwhile (nums[i-1] < nums[i]) \\nnums[i-1]++, nums[i]++\\n\\nFor optimal maximum in subarray we decrement nums[i-1] and increment nums[i] until they are not equal \\nIf we were allowed to decrement any value and increment any value our approach would have been:\\nEg. [2, 3, 5]\\n**Average =** (2 + 3 + 5)/3 = 10/3 = 3, Optimal distribution is [3, 3, 4] so optimal max is **ceil((double)sum / length)**\\n**Approach for this question:**\\nEg. [13, 13, 20, 0, 8]\\nfor subarray [13, 13] optimal max is ceil(13+13)/2 = 13 so we update our maxi = 13\\nfor subarray [13, 13, 20] optimal max is ceil(26 + 20)/3 = 16 ([13, 13, 20] = [13+1, 13-1, 20] = [14, 12+4, 20-4] = [14, 16, 16] so we update our maxi = 16\\nfor subarray [13, 13, 20, 0] optimal max is ceil(46 + 0)/4 = 12 distributing [12, 12, 11, 11] but we know we can change only i-1 and i pairs so this distribution is not possible so we will keep previous subarray maximum as current array maximum = 16\\n\\n**If it helps, please UPVOTE : )**\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        long sum = 0;\\n        int maxi = 0;  //maxi = optimal max no. in array\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            sum += nums[i];\\n            maxi = max(maxi, (int)ceil((double)sum / (i + 1)));  //maximum of optimal maximum for each subarray\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        long sum = 0;\\n        int maxi = 0;  //maxi = optimal max no. in array\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            sum += nums[i];\\n            maxi = max(maxi, (int)ceil((double)sum / (i + 1)));  //maximum of optimal maximum for each subarray\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711336,
                "title": "python-3-2-lines-t-m-100-100",
                "content": "```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        nums = list(accumulate(nums))\\n        return max((i+nums[i])//(1+i) for i in range(len(nums))) \\n```\\n[https://leetcode.com/submissions/detail/823914275/](http://)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        nums = list(accumulate(nums))\\n        return max((i+nums[i])//(1+i) for i in range(len(nums))) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387930,
                "title": "easy-solutions-in-c-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to minimize the maximum value in the given array by making each element less than or equal to this maximum value. This is equivalent to finding the maximum value that we can assign to each element in the array such that the condition is satisfied.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can perform binary search on the range of possible maximum values. We initialize the range to be from 0 to the maximum value in the array. For each mid value, we check if we can assign this value to each element in the array such that each element is less than or equal to this maximum value. If this is the case, we can update our result to be this mid value. We continue this process until we have found the minimum possible maximum value that satisfies the condition\\nTo check if we can assign a mid value to each element in the array, we start with the first element and calculate the difference between the mid value and this element is less than or equal to the mid value (We can decrease the current number by the amount that we are allowed to increase the previous number).We continue this process until we have assigned a value to each element in the array. If at any point an element becomes greater than the mid value, we know that we cannot assign this mid value to the array.\\n# Complexity\\n- Time complexity:\\n$$O(nlogm)$$ where n is the size of the input array and m is the range of possible maximum values (maximum value in the input array). The binary search takes `log m` iterations and for each iteration, we check each element in the array, wehich takes `O(n)` time.\\n\\n- Space complexity:\\n- $$O(1)$$ as, we only use a constant amount of extra space for variables used in the binary search.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& nums, int mid){\\n        if (nums[0] > mid) return false;\\n        long long int prev = nums[0];\\n        for(int i=1; i<nums.size(); i++){\\n            long long int difference = mid - prev;\\n            prev = nums[i] - difference;\\n            if (prev > mid) return false;\\n        }\\n        return true;\\n    }\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int low = 0, high = *max_element(nums.begin(), nums.end());\\n        int res = 0;\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(isValid(nums, mid)){\\n                high = mid-1;\\n                res = mid;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& nums, int mid){\\n        if (nums[0] > mid) return false;\\n        long long int prev = nums[0];\\n        for(int i=1; i<nums.size(); i++){\\n            long long int difference = mid - prev;\\n            prev = nums[i] - difference;\\n            if (prev > mid) return false;\\n        }\\n        return true;\\n    }\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int low = 0, high = *max_element(nums.begin(), nums.end());\\n        int res = 0;\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(isValid(nums, mid)){\\n                high = mid-1;\\n                res = mid;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384112,
                "title": "python-3-easy-to-understand-solution",
                "content": "# Meaning of question\\nThe title will give an array called \"nums\". Our task is to minimize the maximum value in the array as much as possible, but the way to do this is a bit special. Taking nums[i] as an example:\\n1. Decrease the value of nums[i] by one.\\n2. Increase the value of nums[i-1] by one.\\n# Intuition\\nTraverse the values in nums, if the current number encountered (index=i) is larger than the previous number (index=i-1), then nums[i] value can be reduced by one and nums[i-1] value can be increased by one. However, this subtract-one-add-one operation will stop when the average of the two numbers is reached.\\n# Code and Approach\\n```\\nimport math # The function ceil() is used to round up a number to the nearest integer value.\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        ans = 0 # Record the current maximum value during traversal, which will be outputted in the end.\\n        total_sum = 0 # The sum used to calculate the average value.\\n        for i in range(len(nums)):\\n            total_sum += nums[i]\\n            ans = max( ans, math.ceil(total_sum /(i + 1)))\\n# If after swapping is no longer possible and the current value is greater than ans, then ans needs to be updated.\\n\\n# To round up: When the sum of nums[i] and nums[i-1] is divisible, both nums[i] and nums[i-1] will be the same. When the sum is not divisible, nums[i] will be 1 greater than nums[i-1].\\n        return ans\\n```\\n# Additional information about ceil() \\nTo use the `ceil()` and `floor()` functions, you need to import the `math module`. However, you can use **(total_sum + i)//(i + 1)** to achieve the same effect as ceil().\\n\\nThe reason why this works is as follows:\\n\\nAssume that `total_sum` is equal to `a` and `i+1` is equal to `b`.\\n\\nWhen we want to round up a/b, there are two possible scenarios:\\n\\n(1) a/b is divisible without rounding up.\\n\\n(2) a/b is not divisible and needs to be rounded up.\\n\\n1. If we want to avoid rounding up, we need to add something to the fraction a/b. Let\\'s call this value `z` . In order to avoid rounding up, **z must be less than 1**. So, in this case, `a/b + z` should still be divisible without rounding up.\\n2. If we need to round up, then `z` must be **greater than 1 or a/b + z must be divisible. Since z > 1 is not feasible, we need to find a value for `z` that makes `a/b + z` divisible.** In this case, we can add missing decimal value `z` . The missing value is 1 - (a/b - a//b) = 1 - 1/b, where a//b represents the integer part of a/b. Therefore, `z = 1 - 1/b`.\\n\\nWe can now substitute the values of a and b back into the equation a/b + z = (a+b-1)/b and get (total_sum + i)//(i + 1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math # The function ceil() is used to round up a number to the nearest integer value.\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        ans = 0 # Record the current maximum value during traversal, which will be outputted in the end.\\n        total_sum = 0 # The sum used to calculate the average value.\\n        for i in range(len(nums)):\\n            total_sum += nums[i]\\n            ans = max( ans, math.ceil(total_sum /(i + 1)))\\n# If after swapping is no longer possible and the current value is greater than ans, then ans needs to be updated.\\n\\n# To round up: When the sum of nums[i] and nums[i-1] is divisible, both nums[i] and nums[i-1] will be the same. When the sum is not divisible, nums[i] will be 1 greater than nums[i-1].\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384049,
                "title": "java-o-n-time-6-lines-beats-74",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minimizeArrayValue(int[] nums) {\\n    var avg = 0;\\n    var sum = 0L;\\n\\n    for (var i=0; i < nums.length; i++) {\\n      sum += nums[i];\\n      avg = Math.max(avg, (int) Math.ceil((double) sum / (i+1)));\\n    }\\n    return avg;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n  public int minimizeArrayValue(int[] nums) {\\n    var avg = 0;\\n    var sum = 0L;\\n\\n    for (var i=0; i < nums.length; i++) {\\n      sum += nums[i];\\n      avg = Math.max(avg, (int) Math.ceil((double) sum / (i+1)));\\n    }\\n    return avg;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382236,
                "title": "binary-serach-approach-simple-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int> &nums){\\n         long sum=0;\\n     for(int i=0;i<nums.size();i++){\\n         sum+=nums[i];\\n         if(sum>(long)mid*(i+1)) return false;\\n     }\\n\\n     return 1;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n       \\n        int i=0;\\n        int j=1e9;\\n        int ans=0;\\n        while(j>=i){\\n            int mid=i+(j-i)/2;\\n            if(check(mid,nums)){\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else{\\n                i=mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int> &nums){\\n         long sum=0;\\n     for(int i=0;i<nums.size();i++){\\n         sum+=nums[i];\\n         if(sum>(long)mid*(i+1)) return false;\\n     }\\n\\n     return 1;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n       \\n        int i=0;\\n        int j=1e9;\\n        int ans=0;\\n        while(j>=i){\\n            int mid=i+(j-i)/2;\\n            if(check(mid,nums)){\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else{\\n                i=mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382188,
                "title": "python3-o-n-easiest-detailed-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Using average method**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- we observer from question that if we increse one we also at same time decrese one value, so total sum will be same.\\n- so what will change, answer is elements value.\\n- now by performing inc and dec operation we\\'re reaching towards expected mean/average of sum of nums.\\n- we know index-0 element cannot be decremented, so our answer must be greater or equal to index-0.\\n---\\n- in array if we have two numbers and maximum is not in index-0 then we know answer will be average of two numbers, because both will reach to their avegare value till no further change.\\n- so start from element 0, take it as answer and loop through element 1.\\n- keep track of var sum that indicates sum till current element.\\n- now com[are average of current sum and current sum+current element.\\n- and take maximum of it.\\n- compare answer, max_average and take maximum of it.\\n- do this till n-1 times and return ans.\\n---\\n# Note\\n- why take average?\\n    - because if we observe incrementing and decrementing values makes them to go nearer to average of sum of nums.\\n    - now not all element can have value as average because it\\'ll violate sum has to be same during all process rule.\\n    - so some sub-arrays can have different value than average but they\\'re trying to go as neare to average as possible.\\n    - we want maximum answer of nums minimizing elements till we can\\'t.\\n    - so that\\'s why we\\'re taking maximum answer.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import ceil as UpperValue\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        tot = nums[0]\\n        n = len(nums)\\n        i = 1\\n        ans = 0\\n        while n - i:\\n            tillNow = UpperValue(tot/i)\\n            tot += nums[i]\\n            i += 1\\n            current = UpperValue(tot/i)\\n            ans = max(tillNow, current, ans)\\n        return ans\\n\\n```\\n# Please like and comment below ( \\u0361\\uD83D\\uDC41\\uFE0F\\u202F\\u035C\\u0296 \\u0361\\uD83D\\uDC41\\uFE0F)\\u270C",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nfrom math import ceil as UpperValue\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        tot = nums[0]\\n        n = len(nums)\\n        i = 1\\n        ans = 0\\n        while n - i:\\n            tillNow = UpperValue(tot/i)\\n            tot += nums[i]\\n            i += 1\\n            current = UpperValue(tot/i)\\n            ans = max(tillNow, current, ans)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381346,
                "title": "c-o-n-easier-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int n=(int)nums.size();\\n        long long sum=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            long long res=(sum+i)/(i+1);\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int n=(int)nums.size();\\n        long long sum=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            long long res=(sum+i)/(i+1);\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381313,
                "title": "c-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGet the total sum of all elements then iterate from end to the beginning. At each index, try to get the maximum between current min and the max possible value that would be if the sum could be evenly distributed to all cells up to that point (i+1). This is calculated by getting the ceiling of sum / total cells.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizeArrayValue(int[] nums) {\\n        long ans = 0;\\n        long sum = 0;\\n        for (var i = 0; i < nums.Length; i++) {\\n            sum += nums[i];\\n        }\\n\\n        for (var i = nums.Length-1; i >= 0; i--) {\\n            ans = Math.Max(ans, (long)Math.Ceiling(sum * 1.0 / (i+1)));\\n            sum -= nums[i];    \\n        }\\n\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizeArrayValue(int[] nums) {\\n        long ans = 0;\\n        long sum = 0;\\n        for (var i = 0; i < nums.Length; i++) {\\n            sum += nums[i];\\n        }\\n\\n        for (var i = nums.Length-1; i >= 0; i--) {\\n            ans = Math.Max(ans, (long)Math.Ceiling(sum * 1.0 / (i+1)));\\n            sum -= nums[i];    \\n        }\\n\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381279,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long int ans = nums[0];\\n        long long int i;\\n        long long int sum = nums[0];\\n        for(i=1;i<nums.size();i++)\\n        {\\n            sum += nums[i];\\n            //Taking average of numbers from index 0 to i\\n            ans = max(ans,(sum+i)/(i+1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long int ans = nums[0];\\n        long long int i;\\n        long long int sum = nums[0];\\n        for(i=1;i<nums.size();i++)\\n        {\\n            sum += nums[i];\\n            //Taking average of numbers from index 0 to i\\n            ans = max(ans,(sum+i)/(i+1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732221,
                "title": "c-binary-search-noob-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool satisfy(int x, vector<int>& nums) {\\n        vector<long long> copy;\\n        for(int x : nums) copy.push_back(x);\\n        for(int i=copy.size()-1; i>0; i--) {\\n            if(copy[i] > x) {\\n                copy[i-1] += copy[i]-x;\\n            }\\n        }\\n        return copy[0] <= x;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL); cout.tie(NULL);\\n        int left = 0, right = 1e9, ans = -1;\\n        while(left <= right) {\\n            int mid = (left+right)/2;\\n            if(satisfy(mid, nums)) {\\n                ans = mid;\\n                right = mid-1;\\n            } else {\\n                left = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool satisfy(int x, vector<int>& nums) {\\n        vector<long long> copy;\\n        for(int x : nums) copy.push_back(x);\\n        for(int i=copy.size()-1; i>0; i--) {\\n            if(copy[i] > x) {\\n                copy[i-1] += copy[i]-x;\\n            }\\n        }\\n        return copy[0] <= x;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL); cout.tie(NULL);\\n        int left = 0, right = 1e9, ans = -1;\\n        while(left <= right) {\\n            int mid = (left+right)/2;\\n            if(satisfy(mid, nums)) {\\n                ans = mid;\\n                right = mid-1;\\n            } else {\\n                left = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2706970,
                "title": "rust-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is basically a math problem. The rule says that a position value could be \"shifted\" into previous position. Thefore, the answer is to find the max average of sub-arrays [0..i] 0 <= i < n  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimize_array_value(nums: Vec<i32>) -> i32 {\\n        let (mut ret, mut sum) = (0i64, 0i64);\\n\\n        for i in 0..nums.len() {\\n            sum += nums[i] as i64;\\n            let temp = (sum + i as i64) / (i as i64 + 1);\\n            ret = ret.max(temp);\\n        }\\n    \\n         ret as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimize_array_value(nums: Vec<i32>) -> i32 {\\n        let (mut ret, mut sum) = (0i64, 0i64);\\n\\n        for i in 0..nums.len() {\\n            sum += nums[i] as i64;\\n            let temp = (sum + i as i64) / (i as i64 + 1);\\n            ret = ret.max(temp);\\n        }\\n    \\n         ret as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2706345,
                "title": "python3-prefix-sum-o-n-simple-explanation",
                "content": "\\nIdea: Notice that if we look at the first k elements of nums, their sum can only get bigger or stay the same when we perform more operations. Hence, to minimize the maximum value among these first k elements, we can make them as close as possible.\\n\\n```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        prefix_sum = [nums[0]]\\n        for i in range(1, len(nums)):\\n            prefix_sum.append(prefix_sum[-1] + nums[i])\\n            \\n        \\n        ans = nums[0]\\n        for ind, s in enumerate(prefix_sum):\\n            ans = max(ans, int(math.ceil(s / (ind + 1))))\\n            \\n        return ans\\n            \\n            \\n",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "\\nIdea: Notice that if we look at the first k elements of nums, their sum can only get bigger or stay the same when we perform more operations. Hence, to minimize the maximum value among these first k elements, we can make them as close as possible.\\n\\n```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        prefix_sum = [nums[0]]\\n        for i in range(1, len(nums)):\\n            prefix_sum.append(prefix_sum[-1] + nums[i])\\n            \\n        \\n        ans = nums[0]\\n        for ind, s in enumerate(prefix_sum):\\n            ans = max(ans, int(math.ceil(s / (ind + 1))))\\n            \\n        return ans\\n            \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 3827387,
                "title": "c-binary-search-easy-understanding-beginner-friendly",
                "content": "```\\nclass Solution {\\n    bool helpme(vector<int>&nums,long long mid)\\n    {\\n        vector<long long>nums1;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            nums1.push_back(nums[i]);\\n        }\\n        \\n        for (int i=nums1.size()-1; i>0 ;i--)\\n        {\\n            if (nums1[i] > mid)\\n            {\\n                long long calc = nums1[i] - mid;\\n                nums1[i] = mid;\\n                nums1[i-1] = nums1[i-1] + calc;\\n            }\\n        }\\n        long long maxElement = *max_element(nums1.begin(),nums1.end());\\n        nums1.clear();\\n        return (mid >= maxElement);\\n    }\\n    \\npublic:\\n    int minimizeArrayValue(vector<int>& nums)\\n    {\\n        int mini = nums[0] , maxi = nums[0];\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            mini = min(mini,nums[i]);\\n            maxi = max(maxi,nums[i]);\\n        }\\n        long long low = mini , high = maxi;\\n        long long ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            long long mid = low + (high-low) / 2;\\n            if(helpme(nums,mid))\\n            {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    bool helpme(vector<int>&nums,long long mid)\\n    {\\n        vector<long long>nums1;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            nums1.push_back(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3391078,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(q)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long sum = 0, ans = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            ans = max(ans, (sum + i) / (i + 1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long sum = 0, ans = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            ans = max(ans, (sum + i) / (i + 1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387151,
                "title": "priorityqueue-java-time-limit-exceed",
                "content": "## This Solution doesn\\'t work in optimal time complexity, i posted this just for educational purpose and as a way to get grasp on the topic of PriorityQueue and for someone who had the curiosity.\\n\\n# Intuition\\nSince we need to decrease maximum element at a particular time, i got stuck with this approach.\\n\\n# Complexity\\n- Time complexity: TLE(Time Limit Exceed)\\n\\n- Space complexity:O(2n)\\n\\n# Code\\n```\\n// custom object to store value and index of an element, we need it for PriorityQueue\\nclass MySet{\\n    int index, val;\\n    public MySet( int index, int val ){\\n        this.index = index;\\n        this.val = val;\\n    }\\n}\\n\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        PriorityQueue<MySet> pq = new PriorityQueue<>(nums.length,new Comparator<MySet>(){\\n            /*\\n                This comparator is constructed in such a way that if two elements have same value\\n                we will give higher priority to the one with lower index.\\n                This is because in case there are multiple max elements in the array,\\n                it is ideal to reduce the elements in the left first.\\n            */\\n            @Override\\n            public int compare(MySet obj1, MySet obj2){\\n                if( obj1.val == obj2.val ){\\n                    if( obj1.index == obj2.index ) return 0;\\n                    else if( obj1.index < obj2.index ) return -1;\\n                    else return 1;\\n                }\\n                else if( obj1.val > obj2.val ) return -1;\\n                else return 1;\\n            }\\n        });\\n\\n        HashMap<Integer,MySet> added = new HashMap<>();// hashmap to keep account of added values\\n        // Adding all the elements in PriorityQueue and HashMap\\n        for( int i=0; i<nums.length; i++ ) {\\n            MySet obj = new MySet(i,nums[i]);\\n            added.put(i,obj);\\n            pq.add(obj);\\n        }\\n\\n        while(true){\\n            MySet maxObj = pq.poll();\\n            // if element at 0th index is max then the array can\\'t be further reduced\\n            if( maxObj.index == 0 ) return maxObj.val;\\n\\n            // get the object that\\'s right before our maxObj from the HashMap\\n            MySet prev = added.get(maxObj.index-1);\\n            // if by incrementing prev we exceed the value of maxObj in prev than maxObj.val is our solution\\n            if( prev.val+1 > maxObj.val ) return maxObj.val;\\n\\n            /*\\n                In Else block we will perform following operations\\n                1) decrementing maxObj value\\n                2) removing previous obj from PriorityQueue\\n                3) incrementing previou obj value\\n                4) now add both updated maxObj and previous objects to PriorityQueue\\n                5) replace value of previous and max object from hashmap with updated value\\n            */\\n            else {\\n                maxObj.val--;  // reduced head\\'s value\\n                pq.remove(prev); // removing prevVal\\n                prev.val++;     // increment prevVal\\n                pq.add(prev);   // adding updated prev to PQ\\n                added.replace(prev.index,prev);     //updating value in Hashmap\\n                added.replace(maxObj.index,maxObj); //updating value in Hashmap\\n                pq.add(maxObj); // adding updated max to PQ\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// custom object to store value and index of an element, we need it for PriorityQueue\\nclass MySet{\\n    int index, val;\\n    public MySet( int index, int val ){\\n        this.index = index;\\n        this.val = val;\\n    }\\n}\\n\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        PriorityQueue<MySet> pq = new PriorityQueue<>(nums.length,new Comparator<MySet>(){\\n            /*\\n                This comparator is constructed in such a way that if two elements have same value\\n                we will give higher priority to the one with lower index.\\n                This is because in case there are multiple max elements in the array,\\n                it is ideal to reduce the elements in the left first.\\n            */\\n            @Override\\n            public int compare(MySet obj1, MySet obj2){\\n                if( obj1.val == obj2.val ){\\n                    if( obj1.index == obj2.index ) return 0;\\n                    else if( obj1.index < obj2.index ) return -1;\\n                    else return 1;\\n                }\\n                else if( obj1.val > obj2.val ) return -1;\\n                else return 1;\\n            }\\n        });\\n\\n        HashMap<Integer,MySet> added = new HashMap<>();// hashmap to keep account of added values\\n        // Adding all the elements in PriorityQueue and HashMap\\n        for( int i=0; i<nums.length; i++ ) {\\n            MySet obj = new MySet(i,nums[i]);\\n            added.put(i,obj);\\n            pq.add(obj);\\n        }\\n\\n        while(true){\\n            MySet maxObj = pq.poll();\\n            // if element at 0th index is max then the array can\\'t be further reduced\\n            if( maxObj.index == 0 ) return maxObj.val;\\n\\n            // get the object that\\'s right before our maxObj from the HashMap\\n            MySet prev = added.get(maxObj.index-1);\\n            // if by incrementing prev we exceed the value of maxObj in prev than maxObj.val is our solution\\n            if( prev.val+1 > maxObj.val ) return maxObj.val;\\n\\n            /*\\n                In Else block we will perform following operations\\n                1) decrementing maxObj value\\n                2) removing previous obj from PriorityQueue\\n                3) incrementing previou obj value\\n                4) now add both updated maxObj and previous objects to PriorityQueue\\n                5) replace value of previous and max object from hashmap with updated value\\n            */\\n            else {\\n                maxObj.val--;  // reduced head\\'s value\\n                pq.remove(prev); // removing prevVal\\n                prev.val++;     // increment prevVal\\n                pq.add(prev);   // adding updated prev to PQ\\n                added.replace(prev.index,prev);     //updating value in Hashmap\\n                added.replace(maxObj.index,maxObj); //updating value in Hashmap\\n                pq.add(maxObj); // adding updated max to PQ\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384345,
                "title": "python-shortest-1-liner-beats-100-functional-programming",
                "content": "# Approach\\nTL;DR, Same as [Editorial Solution](https://leetcode.com/problems/minimize-maximum-of-array/editorial/) written in functional approach.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is length of nums`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minimizeArrayValue(self, nums: list[int]) -> int:\\n        return max(ceil(x / i) for i, x in enumerate(accumulate(nums), 1))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```python\\nclass Solution:\\n    def minimizeArrayValue(self, nums: list[int]) -> int:\\n        return max(ceil(x / i) for i, x in enumerate(accumulate(nums), 1))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384322,
                "title": "c-brute-binary-search-optimal-prefixsum-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) optimal\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) optimal\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool isValid(int val, vector<int> nums){\\n        //check whether we can make all the elements of the array less than or equal to val.\\n        long long sum = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            sum += nums[i];\\n            if(sum > 1LL * val * (i+1)) return false;\\n        }\\n        return true;\\n    }\\n    int binarySearch(vector<int> &nums){\\n        //min possible value can be 0 and maximum possible can be max_element\\n        int low = 0, high = *max_element(nums.begin(), nums.end());\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(isValid(mid, nums)){\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n    int bruteForce(vector<int> &nums){\\n        int high = *max_element(nums.begin(), nums.end());\\n        int ans = -1;\\n        for(int val = 0; val <= high; val++){\\n            long long sum = 0;\\n            bool flag = true;\\n            for(int j = 0; j < nums.size(); j++){\\n                sum += nums[j];\\n                if(sum > 1LL * val * (j+1)) flag = false;\\n            }\\n            if(flag){\\n                ans = val;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        // return binarySearch(nums);\\n        // return bruteForce(nums);\\n        //greedy\\n        long long ans = 0, prefixSum = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            prefixSum += nums[i];\\n            //trying to distribute prefix sum across the array and choosing maximum because a new element added will only increase prefix sum and therefore ans.\\n            ans = max(ans, (prefixSum + i) / (i + 1));\\n        }\\n        return ans;\\n        //ceil(a/n) = a+n-1/n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    bool isValid(int val, vector<int> nums){\\n        //check whether we can make all the elements of the array less than or equal to val.\\n        long long sum = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            sum += nums[i];\\n            if(sum > 1LL * val * (i+1)) return false;\\n        }\\n        return true;\\n    }\\n    int binarySearch(vector<int> &nums){\\n        //min possible value can be 0 and maximum possible can be max_element\\n        int low = 0, high = *max_element(nums.begin(), nums.end());\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(isValid(mid, nums)){\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n    int bruteForce(vector<int> &nums){\\n        int high = *max_element(nums.begin(), nums.end());\\n        int ans = -1;\\n        for(int val = 0; val <= high; val++){\\n            long long sum = 0;\\n            bool flag = true;\\n            for(int j = 0; j < nums.size(); j++){\\n                sum += nums[j];\\n                if(sum > 1LL * val * (j+1)) flag = false;\\n            }\\n            if(flag){\\n                ans = val;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        // return binarySearch(nums);\\n        // return bruteForce(nums);\\n        //greedy\\n        long long ans = 0, prefixSum = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            prefixSum += nums[i];\\n            //trying to distribute prefix sum across the array and choosing maximum because a new element added will only increase prefix sum and therefore ans.\\n            ans = max(ans, (prefixSum + i) / (i + 1));\\n        }\\n        return ans;\\n        //ceil(a/n) = a+n-1/n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384232,
                "title": "java-solution-using-binary-search-approach-not-the-most-efficient",
                "content": "\\n# Code\\n```\\nclass Solution {\\n      // Function to check if a given target value is valid\\n    // by checking if it\\'s possible to make all elements of nums <= target\\n    boolean isValid(long x, int[] nums) {\\n        if(nums[0] > x) return false; \\n        long sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (sum > x * (i + 1)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int minimizeArrayValue(int[] nums) {\\n        long left = 0, right = Arrays.stream(nums).max().getAsInt(); // Set left to 0 and right to the maximum element in nums\\n        while (left < right) {\\n            long mid = left + (right - left) / 2;\\n            if (isValid(mid, nums)) {\\n                right = mid; // If mid is a valid target, update right pointer\\n            } else {\\n                left = mid + 1; // If mid is not a valid target, update left pointer\\n            }\\n        }\\n        return (int) right; // Return the smallest valid target value\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n      // Function to check if a given target value is valid\\n    // by checking if it\\'s possible to make all elements of nums <= target\\n    boolean isValid(long x, int[] nums) {\\n        if(nums[0] > x) return false; \\n        long sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (sum > x * (i + 1)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int minimizeArrayValue(int[] nums) {\\n        long left = 0, right = Arrays.stream(nums).max().getAsInt(); // Set left to 0 and right to the maximum element in nums\\n        while (left < right) {\\n            long mid = left + (right - left) / 2;\\n            if (isValid(mid, nums)) {\\n                right = mid; // If mid is a valid target, update right pointer\\n            } else {\\n                left = mid + 1; // If mid is not a valid target, update left pointer\\n            }\\n        }\\n        return (int) right; // Return the smallest valid target value\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384034,
                "title": "swift-solution-prefix-sum-beats-100",
                "content": "```\\nclass Solution {\\n    func minimizeArrayValue(_ nums: [Int]) -> Int {\\n        var prefixSum = nums[0] + nums[1]\\n        var minimumMaxValue = (nums[1] > nums[0]) ? ((prefixSum % 2 == 0) ? prefixSum/2 : prefixSum/2 + 1) : nums[0]\\n        if nums.count == 2 { return minimumMaxValue }\\n        \\n        for index in 2..<nums.count {\\n            let curr = nums[index]\\n            prefixSum += curr\\n            minimumMaxValue = max(minimumMaxValue, prefixSum % (index + 1) == 0 ? prefixSum/(index + 1) : (prefixSum/(index + 1)) + 1)\\n        }\\n        return minimumMaxValue\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    func minimizeArrayValue(_ nums: [Int]) -> Int {\\n        var prefixSum = nums[0] + nums[1]\\n        var minimumMaxValue = (nums[1] > nums[0]) ? ((prefixSum % 2 == 0) ? prefixSum/2 : prefixSum/2 + 1) : nums[0]\\n        if nums.count == 2 { return minimumMaxValue }\\n        \\n        for index in 2..<nums.count {\\n            let curr = nums[index]\\n            prefixSum += curr\\n            minimumMaxValue = max(minimumMaxValue, prefixSum % (index + 1) == 0 ? prefixSum/(index + 1) : (prefixSum/(index + 1)) + 1)\\n        }\\n        return minimumMaxValue\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383412,
                "title": "c-solution",
                "content": "# Code\\n```\\nint minimizeArrayValue(int* nums, int numsSize){\\n    double a= 0;double b= 0;\\n    for(int i= 0; i<numsSize; i++){\\n        b+=nums[i];\\n        if(a<=ceil(b/(i+1)))a=ceil(b/(i+1));\\n    }\\n    return (int)a;\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minimizeArrayValue(int* nums, int numsSize){\\n    double a= 0;double b= 0;\\n    for(int i= 0; i<numsSize; i++){\\n        b+=nums[i];\\n        if(a<=ceil(b/(i+1)))a=ceil(b/(i+1));\\n    }\\n    return (int)a;\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3383040,
                "title": "binary-search-approach-explained-step-by-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    bool check(int mid,vector<int>&nums){\\n\\n\\n        //this function checks whether the mid can be the min possible maximum value of the array\\n        //it  will be so if there is no scope of reducing it\\n\\n        //nums[0]+nums[1]+nums[i]>mid*i+1 which means any number amongst them is greater than mid\\n        //and it can be reduces to using any number of operations\\n        //that why in that case we are returning false;\\n        long long csum=0;\\n        for(int i=0;i<nums.size();i++){\\n            csum+=nums[i];\\n            long long c=(long long)mid*((long long)i+1);\\n            if(csum>c){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n\\n        //this language min max refers that the question is of binary search \\n        //now think on which variable you will be using binary search \\n        //we will be  using binary search on the max value possible in the array after using an\\n        //anu number of given operations\\n        //and we need to minimise this value so we will try finding till we get the\\n        //most optimal answer\\n        //now we will decide the range of binary search \\n        int low=0;\\n        int high=*max_element(nums.begin(),nums.end());\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(check(mid,nums)){\\n                ans=mid;\\n                high=mid-1;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;//finally we returned the most optimal last updated answer\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    bool check(int mid,vector<int>&nums){\\n\\n\\n        //this function checks whether the mid can be the min possible maximum value of the array\\n        //it  will be so if there is no scope of reducing it\\n\\n        //nums[0]+nums[1]+nums[i]>mid*i+1 which means any number amongst them is greater than mid\\n        //and it can be reduces to using any number of operations\\n        //that why in that case we are returning false;\\n        long long csum=0;\\n        for(int i=0;i<nums.size();i++){\\n            csum+=nums[i];\\n            long long c=(long long)mid*((long long)i+1);\\n            if(csum>c){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n\\n        //this language min max refers that the question is of binary search \\n        //now think on which variable you will be using binary search \\n        //we will be  using binary search on the max value possible in the array after using an\\n        //anu number of given operations\\n        //and we need to minimise this value so we will try finding till we get the\\n        //most optimal answer\\n        //now we will decide the range of binary search \\n        int low=0;\\n        int high=*max_element(nums.begin(),nums.end());\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(check(mid,nums)){\\n                ans=mid;\\n                high=mid-1;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;//finally we returned the most optimal last updated answer\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382685,
                "title": "short-5-line-code",
                "content": "\\n\\n![image.png](https://assets.leetcode.com/users/images/3eabb13a-2917-4450-ab70-828b5481c14a_1680692018.3742182.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n       int n= nums.size();\\n       long long first= nums[0];\\n       long long res=nums[0];\\n        for(int i=1; i<n; i++){\\n            first+=nums[i];\\n            res= max(res, (first+i)/(i+1));\\n        }\\n        return (int)res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n       int n= nums.size();\\n       long long first= nums[0];\\n       long long res=nums[0];\\n        for(int i=1; i<n; i++){\\n            first+=nums[i];\\n            res= max(res, (first+i)/(i+1));\\n        }\\n        return (int)res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382560,
                "title": "kotlin-binary-search-ez-algo",
                "content": "# Intuition\\nI can solve it in brute, and try to think some other solves...\\n\\n# Approach\\nfirst of all we need to add \\'isValid\\' function, where we checking our condition. next we adding in main \\'minimizeArrayValue\\' binary search algo, where we moving right border on isValid condition.\\n\\ni did 3 tries before i get that we cant just use \\'int\\', because in values where them exceed int range(int_max + 1), we need to use \\'long\\'.\\nthats all i think. not actually hard\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(max))$$\\n\\n- Space complexity:\\n$$O(max)$$(max in long range)\\n\\n# Code\\n```\\nclass Solution {\\n    fun minimizeArrayValue(nums: IntArray): Int {\\n        var left = 0L\\n        var right: Long? = nums.max()!!.toLong()\\n        while (left < right!!) {\\n            val mid: Long = left + (right - left).div(2)\\n            if (isValid(mid, nums)) {\\n                right = mid\\n            }\\n            else {\\n                left = mid + 1\\n            }\\n        }\\n        return right.toInt()\\n    }\\n\\n    private fun isValid(target: Long, nums: IntArray): Boolean {\\n        if (nums[0] > target) { // \\u043D\\u0435\\u043B\\u044C\\u0437\\u044F \\u043F\\u0440\\u0435\\u0434\\u044B\\u0434\\u0443\\u0449\\u0438\\u0439 \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435 \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0443\\u043C\\u0430\\n            return false\\n        }\\n        var prev: Long = nums[0].toLong() // \\u043F\\u0440\\u0435\\u0434\\u044B\\u0434\\u0443\\u0448\\u0438\\u0439 \\u0431\\u0443\\u0434\\u0435\\u0442 0(\\u043D\\u0430\\u0447\\u0438\\u043D\\u0430\\u0435\\u043C \\u0441 \\u0435\\u0434\\u0438\\u043D\\u0438\\u0446\\u044B)\\n        for (i in (1 until nums.size)) {\\n            val diff: Long = target - prev\\n            prev = nums[i].toLong() - diff\\n            if (prev > target) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    fun minimizeArrayValue(nums: IntArray): Int {\\n        var left = 0L\\n        var right: Long? = nums.max()!!.toLong()\\n        while (left < right!!) {\\n            val mid: Long = left + (right - left).div(2)\\n            if (isValid(mid, nums)) {\\n                right = mid\\n            }\\n            else {\\n                left = mid + 1\\n            }\\n        }\\n        return right.toInt()\\n    }\\n\\n    private fun isValid(target: Long, nums: IntArray): Boolean {\\n        if (nums[0] > target) { // \\u043D\\u0435\\u043B\\u044C\\u0437\\u044F \\u043F\\u0440\\u0435\\u0434\\u044B\\u0434\\u0443\\u0449\\u0438\\u0439 \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435 \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0443\\u043C\\u0430\\n            return false\\n        }\\n        var prev: Long = nums[0].toLong() // \\u043F\\u0440\\u0435\\u0434\\u044B\\u0434\\u0443\\u0448\\u0438\\u0439 \\u0431\\u0443\\u0434\\u0435\\u0442 0(\\u043D\\u0430\\u0447\\u0438\\u043D\\u0430\\u0435\\u043C \\u0441 \\u0435\\u0434\\u0438\\u043D\\u0438\\u0446\\u044B)\\n        for (i in (1 until nums.size)) {\\n            val diff: Long = target - prev\\n            prev = nums[i].toLong() - diff\\n            if (prev > target) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382417,
                "title": "minimize-maximize-of-array-easy-optimized-no-dp-no-hashset",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n       long long int res=INT_MIN;\\n       long long int sum1=0;\\n       for(int i=0;i<nums.size();i++){\\n           sum1+=nums[i];\\n           res=max(res,(sum1+i)/(i+1));\\n       }\\n       return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n       long long int res=INT_MIN;\\n       long long int sum1=0;\\n       for(int i=0;i<nums.size();i++){\\n           sum1+=nums[i];\\n           res=max(res,(sum1+i)/(i+1));\\n       }\\n       return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382409,
                "title": "minimize-maximum-of-array-fast-simple-easy-no-dp-no-hash",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) \\n    {\\n        long long int ans = 0;\\n        long long int res = 0;\\n        long long int sum = 0;\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            sum += nums[i];\\n            res = (sum)/(i+1);\\n            if((sum)%(i+1) != 0)\\n            {\\n                res++;\\n            }\\n            ans = max(res,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) \\n    {\\n        long long int ans = 0;\\n        long long int res = 0;\\n        long long int sum = 0;\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            sum += nums[i];\\n            res = (sum)/(i+1);\\n            if((sum)%(i+1) != 0)\\n            {\\n                res++;\\n            }\\n            ans = max(res,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381859,
                "title": "c-solution-with-efficient-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        // Initialize answer and the prefix sum.\\n        long long answer = 0, prefixSum = 0;\\n        \\n        // Iterate over nums, update prefix sum and answer.\\n        for (int i = 0; i < nums.size(); ++i) {\\n            prefixSum += nums[i];\\n            answer = max(answer, (prefixSum + i) / (i + 1));\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        // Initialize answer and the prefix sum.\\n        long long answer = 0, prefixSum = 0;\\n        \\n        // Iterate over nums, update prefix sum and answer.\\n        for (int i = 0; i < nums.size(); ++i) {\\n            prefixSum += nums[i];\\n            answer = max(answer, (prefixSum + i) / (i + 1));\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381742,
                "title": "python-two-approaches-binary-search-prefix-sum-average-with-explainations",
                "content": "##### 1. Binary Search\\nWe want to find \"minimum maximum value\", let\\'s call it max, max = [0, max(nums)].\\nTo achieve this, you need to make all nums[i] <= max.\\n           \\nSo here comes two conditions:\\n           \\n- **nums[i] > max**:\\nWe need to spread \"max-nums[i]\" to nums[:i] if there is capacity, \\nwhich means no num in nums[:i] > max\\uFF1B\\notherwise, this max value is not available for nums, pick a larger one\\n                \\n- **nums[i] <= max**:\\nIn this case we meet the condition, so we don\\'t need to spread any values.\\nWe only calculate the capacity \"nums[i]-max\" and store it.\\nOnce the capacity is enough, we can afford values from those nums[j] > max,\\nwhere j > i, and if the capacity still enough until we traverse the whole nums,\\nwe can try a smaller max value\\n            \\nBased on above findings, we can use binary search to find the \"max\" value,\\nand check the rules with all of it.\\n\\n```\\nclass Solution:\\n    \\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        self.nums = nums\\n        left = 0\\n        right = max(nums)\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            if self.check(mid):\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return left\\n    \\n    def check(self, maxValue) -> bool:\\n        capacity = 0\\n        for num in self.nums:\\n            if num > maxValue:\\n                over = num-maxValue\\n                if over > capacity: return False\\n                capacity -= over\\n            else:\\n                capacity += (maxValue - num)\\n        return True\\n```\\nTime Complexity: \\nSince binary search takes ***O(logn)*** and traverse the list takes ***O(n)*** , we do traverse at each binary search so the answer is ***O(nlogn)*** .\\n\\n##### 2. Prefix Sum Average\\nIf we can move value both left and right, the answer will be `ceil(sum(nums)/len(nums))`.\\n    \\nAssume we have nums = [3,1,2,4], we can get the total = 10 and average = 2.5\\nThis can be interpreted as we have len(nums) = 4 boxes and we put a ball into each box.\\nThen finally we will get [3,3,2,2] as result, the maximum is equal to ceil(2.5) = 3\\n\\nBut since we can only move value to left, we need to do some little tricks.\\n\\nWe assume nums = [3,7,1,3], but this time we consider each element step by step.\\nWhen i = 0, total of nums[:i] = 3 and the answer should be ceil(3/1) = 3.\\nWhen i = 1, total of nums[:i] = 10, the answer is ceil(10/2) = 5.\\nWhen i = 2, total of nums[:i] = 11, but the answer is not ceil(11/3) = 3 because we can only move left, so the answer is still 5.\\nWhen i = 3, total of nums[:i] = 14, but the answer is not ceil(14/4) = 4 because we can only move left, so the answer is still 5.\\n    \\nYou\\'ll see we can update the answer of each step once it is larger than previous. \\nWe can use prefix sum to achieve this.\\n\\n```\\nclass Solution:\\n\\tdef minimizeArrayValue(self, nums: List[int]) -> int:\\n\\t\\t\\tanswer = 0\\n\\t\\t\\tprefixSum = 0\\n\\t\\t\\tfor i, num in enumerate(nums):\\n\\t\\t\\t\\tprefixSum += num\\n\\t\\t\\t\\tanswer = max(answer, math.ceil(prefixSum/(i+1)))\\n\\t\\t\\treturn answer\\n```\\nTime Complexity: \\nSince we only traverse the whole nums one time, so the answer is ***O(n)*** .\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        self.nums = nums\\n        left = 0\\n        right = max(nums)\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            if self.check(mid):\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return left\\n    \\n    def check(self, maxValue) -> bool:\\n        capacity = 0\\n        for num in self.nums:\\n            if num > maxValue:\\n                over = num-maxValue\\n                if over > capacity: return False\\n                capacity -= over\\n            else:\\n                capacity += (maxValue - num)\\n        return True\\n```\n```\\nclass Solution:\\n\\tdef minimizeArrayValue(self, nums: List[int]) -> int:\\n\\t\\t\\tanswer = 0\\n\\t\\t\\tprefixSum = 0\\n\\t\\t\\tfor i, num in enumerate(nums):\\n\\t\\t\\t\\tprefixSum += num\\n\\t\\t\\t\\tanswer = max(answer, math.ceil(prefixSum/(i+1)))\\n\\t\\t\\treturn answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381539,
                "title": "o-n-time-complexity-fastest-code-ever",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0, ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            ans = Math.max(ans, (sum + i) / (i + 1));\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0, ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            ans = Math.max(ans, (sum + i) / (i + 1));\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381488,
                "title": "easy-c-solution-using-binary-search-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck for all possible values, using binary search.\\nHow to check if certain value satisfies the given condition?\\n->traverse from back and add the difference of (arr[i]-desired) to arr[i-1] and at last check condition on arr[0]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n\\n# Complexity\\n- Time complexity:O(n log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& a) {\\n        \\n        \\n        long long res=0;\\n        long long low=0;\\n        long long high=1000000000;\\n        while(low<=high){\\n            vector<long long> nums;\\n            for(auto x:a){\\n                nums.push_back((long long)x);\\n            }\\n            long long m=low+(high-low)/2;\\n            long long k=0;\\n            for(int i=nums.size()-1;i>0;i--){\\n                if(nums[i]>m){\\n                   \\n                    nums[i-1]+=(nums[i]-m);\\n                }\\n                \\n            }\\n            if(nums[0]<=m){\\n                high=m-1;\\n                res=m;\\n            }\\n            else{\\n                \\n                low=m+1;\\n                \\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& a) {\\n        \\n        \\n        long long res=0;\\n        long long low=0;\\n        long long high=1000000000;\\n        while(low<=high){\\n            vector<long long> nums;\\n            for(auto x:a){\\n                nums.push_back((long long)x);\\n            }\\n            long long m=low+(high-low)/2;\\n            long long k=0;\\n            for(int i=nums.size()-1;i>0;i--){\\n                if(nums[i]>m){\\n                   \\n                    nums[i-1]+=(nums[i]-m);\\n                }\\n                \\n            }\\n            if(nums[0]<=m){\\n                high=m-1;\\n                res=m;\\n            }\\n            else{\\n                \\n                low=m+1;\\n                \\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381307,
                "title": "easy-c-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialized answer and total sum with 0.\\n2. Then keeping max element in answer among max and average of starting i element, where i is 1 to n.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long int ans=0,sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            ans=max(ans,(sum+i)/(i+1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long int ans=0,sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            ans=max(ans,(sum+i)/(i+1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381303,
                "title": "prefix-sum-greedy-o-n-ruby",
                "content": "# Approach\\nPrefix sum + greedy\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef minimize_array_value(nums)\\n  prefix = 0\\n  result = 0\\n  nums.each_with_index do |num, i|\\n    prefix += nums[i]\\n    result = [result, (prefix.to_f/(i+1)).ceil].max\\n  end\\n  result\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef minimize_array_value(nums)\\n  prefix = 0\\n  result = 0\\n  nums.each_with_index do |num, i|\\n    prefix += nums[i]\\n    result = [result, (prefix.to_f/(i+1)).ceil].max\\n  end\\n  result\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2758232,
                "title": "java-easy-solution-3-4-liner",
                "content": "# Intuition : \\nThe best we can do is to reduce nums[i] to average of the array nums(0, i)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n      long max = 0, sum = 0;\\n      for(int i = 0; i < nums.length; i ++) {\\n          sum += nums[i];\\n          max = Math.max(max, (sum + i) / (i + 1));\\n      }  \\n      return (int)max;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n      long max = 0, sum = 0;\\n      for(int i = 0; i < nums.length; i ++) {\\n          sum += nums[i];\\n          max = Math.max(max, (sum + i) / (i + 1));\\n      }  \\n      return (int)max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719158,
                "title": "o-n-c-easy-to-understand-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first point to be observe is that we can distribute `arr[i]` to the array from `index = 0 to i`. So, let\\'s say we have `arr = [3,1,3,5]` then we can distribute `5` from `index = 0 to 3`, and our optimal result will be `arr = [3,3,3,3]` with `max(arr[i])` minimum.\\n\\n<hr>\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Let\\'s say we are given an array `arr = {3}` with one element, so at for this array we can say that the **maximum value** will be `arr[0]`, as we cannot distribute or reduce it. So, `maxValue = arr[0] = 3`.\\n \\n* Now add a new element to the array `arr = {3,7}`. Now as we have added a new element and it is more than `maxValue`. So, we can distribute it over `arr[0]` and the array would be `arr = {5,5}`. And correspondingly `maxValue = 5`.\\n\\n* Now add another element to the array, `arr = {3,7,1}`. The new element here is less than `maxValue`. Now observe that, we cannot reduce the `maxValue` by adding smaller element later. `maxValue = 5`\\n\\n* Now add the last element in the array, `arr = {3,7,1,6}`. Now the new element is more than `maxValue`. But here we can distribute the new element in the array from 0 to the element index such that it will not affect the `maxValue`. Here is a way, `arr = {5,5,2,5}` after distribution. Here one thing to note is that, once we found the `maxValue` until `index i` it is not necessary that every element will be equal after distribution, there will be elements with values less than `maxValue` but no elements with value more than `maxValue`, thus we could find a lot of blank spaces. So, for this case we need to carry a value `sum` of the arr until the previous element. Then we can find out the blank spaces where we can distribute `arr[i]`.\\n\\n**Let\\'s understand the code:**\\n* We first choose two variable `sum` and `maxValue` the sum will carry sum of elements from `index -> 0 to (i-1)` and `maxValue` will carry minimum of `max(arr)`\\n```c++\\nll sum=0ll, maxValue=0ll;\\n```\\n\\n* Now we have to traverse the array to find the optimal answer, so we run a loop from `0` to `n-1`. And the main calculation happenes inside.\\n\\n* Now we check whether the current value is greater than `maxValue` till previous index or not. If so, then we have to check whether we can fit the value inside blank spaces or not.( We have to distribute the `nums[i] - maxValue`, we don\\'t have to distribute the total `nums[i]`.) If it can\\'t be fit inside the empty spaces, then we have to increase ourmaxValue to fit `nums[i]`.\\n```c++\\nll numsi = nums[i];\\nif(numsi > maxValue){\\n  ll emptySpaces = i*maxValue - sum;\\n  numsi -= (emptySpaces + maxValue);\\n  if(numsi > 0)\\n    maxValue += ceil(numsi/(ld)(i+1));\\n}\\n```\\n\\n* Now we have to update our `sum` variable for the furthur calculation. and until this point, it will be inside the loop.\\n```c++\\nnumsi = (ll)(nums[i]); // <- careful, it changes inside `if` condition\\nsum += numsi;\\n```\\n\\n* Then we can return the maxValue what we have. \\n```c++\\nreturn (int)maxValue;\\n```\\n\\n\\n<hr>\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n<hr>\\n\\n# Code\\n```c++\\n#define ll long long \\n#define ld long double\\nclass Solution {\\npublic:\\n  int minimizeArrayValue(vector<int>& nums){\\n    int n = nums.size();\\n    ll sum=0ll, maxValue=0ll;\\n    for(int i=0; i<n; i++){\\n      ll numsi = nums[i];\\n      if(numsi > maxValue){\\n        ll emptySpaces = i*maxValue - sum;\\n        numsi -= (emptySpaces + maxValue);\\n        if(numsi > 0)\\n          maxValue += ceil(numsi/(ld)(i+1));\\n      }\\n      numsi = (ll)(nums[i]); \\n      sum += numsi;\\n    }\\n    return (int)maxValue;\\n  }\\n};\\n```\\n\\n<hr>\\n\\n# Thanks and Regards\\nIt took a lot of time to write solutions. So, if you find it helpful, please don\\'t forget to **Upvote**.\\n\\n**Thank You**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nll sum=0ll, maxValue=0ll;\\n```\n```c++\\nll numsi = nums[i];\\nif(numsi > maxValue){\\n  ll emptySpaces = i*maxValue - sum;\\n  numsi -= (emptySpaces + maxValue);\\n  if(numsi > 0)\\n    maxValue += ceil(numsi/(ld)(i+1));\\n}\\n```\n```c++\\nnumsi = (ll)(nums[i]); // <- careful, it changes inside `if` condition\\nsum += numsi;\\n```\n```c++\\nreturn (int)maxValue;\\n```\n```c++\\n#define ll long long \\n#define ld long double\\nclass Solution {\\npublic:\\n  int minimizeArrayValue(vector<int>& nums){\\n    int n = nums.size();\\n    ll sum=0ll, maxValue=0ll;\\n    for(int i=0; i<n; i++){\\n      ll numsi = nums[i];\\n      if(numsi > maxValue){\\n        ll emptySpaces = i*maxValue - sum;\\n        numsi -= (emptySpaces + maxValue);\\n        if(numsi > 0)\\n          maxValue += ceil(numsi/(ld)(i+1));\\n      }\\n      numsi = (ll)(nums[i]); \\n      sum += numsi;\\n    }\\n    return (int)maxValue;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711162,
                "title": "easy-and-simple-with-proper-comments-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& v) {\\n        int n=v.size();\\n        int ans=v[0];//Initially we assume ans would be the first element of the array as it can\\'t be reduced.\\n        long k=0;\\n        for(int i=0;i<n;i++){\\n            // Adding the elements and taking average of it and distribute the sum into elements behind this particular element.\\n            k+=v[i];\\n            int z=k/(i+1)+(k%(i+1)!=0);\\n            //Compare and pick the maximum as the division might be a must as this element could be a max and to reduce the maximum it should be shared among the previous elements.\\n            ans=max(ans,z);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& v) {\\n        int n=v.size();\\n        int ans=v[0];//Initially we assume ans would be the first element of the array as it can\\'t be reduced.\\n        long k=0;\\n        for(int i=0;i<n;i++){\\n            // Adding the elements and taking average of it and distribute the sum into elements behind this particular element.\\n            k+=v[i];\\n            int z=k/(i+1)+(k%(i+1)!=0);\\n            //Compare and pick the maximum as the division might be a must as this element could be a max and to reduce the maximum it should be shared among the previous elements.\\n            ans=max(ans,z);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706668,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int> &arr,int t){\\n        vector<long long> nums(arr.size());\\n        for(int i = 0; i<nums.size();++i) nums[i] = arr[i];\\n        for(int i = nums.size()-1; i>0; i--){\\n            if(nums[i]>t){\\n                nums[i-1]+=abs(t-nums[i]);\\n            }\\n        }\\n        return nums[0]<=t;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int l = 1, h = *max_element(nums.begin(),nums.end()), re = 0;\\n        while(l<=h){\\n            int m = (l+h)/2;\\n            if(find(nums,m)){re = m; h = m-1;}\\n            else l = m+1;\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int> &arr,int t){\\n        vector<long long> nums(arr.size());\\n        for(int i = 0; i<nums.size();++i) nums[i] = arr[i];\\n        for(int i = nums.size()-1; i>0; i--){\\n            if(nums[i]>t){\\n                nums[i-1]+=abs(t-nums[i]);\\n            }\\n        }\\n        return nums[0]<=t;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int l = 1, h = *max_element(nums.begin(),nums.end()), re = 0;\\n        while(l<=h){\\n            int m = (l+h)/2;\\n            if(find(nums,m)){re = m; h = m-1;}\\n            else l = m+1;\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706625,
                "title": "binary-search-based-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool ispossible(vector<long long>nums,long long d)\\n    {\\n        int n=nums.size();\\n        if(nums[0]>d)\\n            return false;\\n        for(int i=1;i<n;i++)\\n        {  \\n            long long x=d-nums[i-1];\\n            if(nums[i]>d)\\n            {\\n                if(nums[i]-d>x)\\n                    return false;\\n            }\\n            nums[i-1]+=x;\\n            nums[i]-=x;\\n            \\n        }\\n        return true;\\n    }\\n    \\n    int minimizeArrayValue(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<long long>nums;\\n        for(auto it:arr)\\n        {\\n            nums.push_back(it);\\n        }\\n        int s=0;\\n        int e=*max_element(nums.begin(),nums.end());\\n        int ans=-1;\\n        while(s<=e)\\n        {\\n            long long d=(s+e)/2;\\n            if(ispossible(nums,d))\\n            {\\n                ans=d;\\n                e=d-1;\\n            }\\n            else{\\n                s=d+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool ispossible(vector<long long>nums,long long d)\\n    {\\n        int n=nums.size();\\n        if(nums[0]>d)\\n            return false;\\n        for(int i=1;i<n;i++)\\n        {  \\n            long long x=d-nums[i-1];\\n            if(nums[i]>d)\\n            {\\n                if(nums[i]-d>x)\\n                    return false;\\n            }\\n            nums[i-1]+=x;\\n            nums[i]-=x;\\n            \\n        }\\n        return true;\\n    }\\n    \\n    int minimizeArrayValue(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<long long>nums;\\n        for(auto it:arr)\\n        {\\n            nums.push_back(it);\\n        }\\n        int s=0;\\n        int e=*max_element(nums.begin(),nums.end());\\n        int ans=-1;\\n        while(s<=e)\\n        {\\n            long long d=(s+e)/2;\\n            if(ispossible(nums,d))\\n            {\\n                ans=d;\\n                e=d-1;\\n            }\\n            else{\\n                s=d+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706578,
                "title": "javascript-easy-o-n",
                "content": "```\\nvar minimizeArrayValue = function(nums) {\\n        let sum = 0, res = 0;\\n        for (let i = 0; i < nums.length; ++i) {\\n            sum += nums[i];\\n            res = Math.max(res, Math.floor((sum + i) / (i + 1)));\\n        }\\n        return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimizeArrayValue = function(nums) {\\n        let sum = 0, res = 0;\\n        for (let i = 0; i < nums.length; ++i) {\\n            sum += nums[i];\\n            res = Math.max(res, Math.floor((sum + i) / (i + 1)));\\n        }\\n        return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2706483,
                "title": "short-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        mn = nums[0]\\n        nums = list(accumulate(nums))\\n        for i, n in enumerate(nums):\\n            mn = max(mn, ceil(n/(i+1)))\\n        return mn\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        mn = nums[0]\\n        nums = list(accumulate(nums))\\n        for i, n in enumerate(nums):\\n            mn = max(mn, ceil(n/(i+1)))\\n        return mn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706389,
                "title": "python-3-o-n-dynamic-programming-allocating-running-sum",
                "content": "Think of the numbers representing bar heights.\\n**The operation essentially allows us to re-allocate the height from the bar to whatever bars to its left. And the sum of bar heights will always remain unchanged.**\\nThen we want to find the minimum height such that we can fit every new bar under such height.\\nSo starting from left to right, let dp[i] represents the answer of nums[0:(i+1)], when nums[i+1] come in, we compare it to dp[i]:\\n\\n* If nums[i+1] <= dp[i], we don\\'t want to re-allocate its height, because if the left bars are all of the height dp[i], then we might risk increasing the minimum height limit.\\n* But if nums[i+1] > dp[i], we want to allocate the extra height to the left as evenly as possible.\\n```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [nums[0]]\\n        s = nums[0]\\n        for i in range(1, n):\\n            if nums[i] > dp[i - 1]:\\n                if (s + nums[i]) % (i + 1) == 0:\\n                    dp.append((s + nums[i]) // (i + 1))\\n                else:\\n                    dp.append((s + nums[i]) // (i + 1) + 1)\\n            else:\\n                dp.append(dp[i - 1])\\n            s += nums[i]\\n        \\n        return max(dp)\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [nums[0]]\\n        s = nums[0]\\n        for i in range(1, n):\\n            if nums[i] > dp[i - 1]:\\n                if (s + nums[i]) % (i + 1) == 0:\\n                    dp.append((s + nums[i]) // (i + 1))\\n                else:\\n                    dp.append((s + nums[i]) // (i + 1) + 1)\\n            else:\\n                dp.append(dp[i - 1])\\n            s += nums[i]\\n        \\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706383,
                "title": "easy-java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long max = nums[0];\\n        long sum = nums[0];\\n        for(int i=1; i<nums.length; i++) {\\n            sum += nums[i];\\n            long ans = sum%(i+1) == 0 ? sum / (i+1) : sum / (i+1) + 1;\\n            max = Math.max(max, ans);\\n        }\\n        \\n        return (int) max;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long max = nums[0];\\n        long sum = nums[0];\\n        for(int i=1; i<nums.length; i++) {\\n            sum += nums[i];\\n            long ans = sum%(i+1) == 0 ? sum / (i+1) : sum / (i+1) + 1;\\n            max = Math.max(max, ans);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2706358,
                "title": "python-prefix-sum-math-with-explanations",
                "content": "In this solution the idea of performing an operation is to shift the values to the left of the array. In our case we just need to calculate for each value of the array what is the minimum of the maximums by taking the Euclidean division of the sum of the numbers of our current array divide by its length. We store this maximum in a result variable that we change when this maximum is exceeded.\\n\\nTime complexity = O(n)\\nSpace complexity = O(n) -> Can be done in 0(1)\\n\\n```python\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        psum = [num for num in nums]\\n        \\n        for k in range(1, len(psum)):\\n            psum[k] = nums[k] + psum[k-1]\\n\\n        sol = 0\\n        for k in range(len(psum)):\\n            if psum[k] % (k+1) != 0:\\n                sol = max((psum[k] // (k+1)) + 1, sol)\\n            else:\\n                sol = max(psum[k] // (k+1), sol)\\n\\n        return sol\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```python\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        psum = [num for num in nums]\\n        \\n        for k in range(1, len(psum)):\\n            psum[k] = nums[k] + psum[k-1]\\n\\n        sol = 0\\n        for k in range(len(psum)):\\n            if psum[k] % (k+1) != 0:\\n                sol = max((psum[k] // (k+1)) + 1, sol)\\n            else:\\n                sol = max(psum[k] // (k+1), sol)\\n\\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028578,
                "title": "easiest-explanation-you-have-ever-find",
                "content": "**Problem Understanding:**\\nYou\\'re allowed to decrease a number at index i and increase the number at index i-1. The goal is to minimize the maximum value in the array.\\n\\n**Key Insight:**\\nThe operations allow us to shift values from the right to the left. However, we can\\'t directly control the leftmost value (index 0). This means the maximum value in the array will always be at least nums[0].\\n\\n**Approach:**\\nBinary Search on the Result:\\n\\nWe can use binary search to find the minimum possible maximum value. The lower bound is nums[0] and the upper bound is the current maximum value in the array.\\nFor each mid-value in the binary search, we need to check if we can make all the values in the array less than or equal to this mid-value.\\n\\n**Checking Feasibility:**\\n\\nStart iterating from the second element of the array.\\nFor each element, if it\\'s greater than the mid-value, calculate the difference. This difference is the amount we can shift to the left.\\nIf it\\'s less than the mid-value, we need to compensate for the difference from the amounts we\\'ve shifted from the right.\\nIf at any point we need more than we have shifted from the right, then it\\'s not feasible to achieve the mid-value as the maximum.\\nBinary Search Update:\\n\\nIf the mid-value is feasible, update the upper bound of the binary search.\\nIf not, update the lower bound.\\n\\n### Explanation:\\n\\n- The `canAchieve` function checks if it\\'s possible to make all numbers in the array (except the first one) less than or equal to the target. \\n- The `minimizeMaximum` function uses binary search to find the minimum possible maximum value.\\n\\n### Building Logic:\\n\\n1. **Binary Search**: This is a classic application of binary search on the result. Instead of searching in an array, we\\'re searching in a range of possible answers.\\n\\n2. **Feasibility Check**: The key logic lies in the feasibility check. We need to ensure that by shifting values from the right, we can make all values less than or equal to the target. The `extra` variable keeps track of how much we can shift to the left.\\n\\n3. **Iterative Approach**: The solution iteratively refines the possible range for the maximum value until it finds the minimum possible maximum.\\n\\nBy following this approach, you can ensure that the maximum value in the array is minimized after performing the operations.\\nCertainly! Let\\'s analyze the time and space complexity of the approach:\\n\\n**Time Complexity:**\\n\\n1. **Binary Search**: The binary search operates on a range of values, specifically from the minimum to the maximum value of the array. In the worst case, this range can be as large as the maximum value in the array. However, the number of iterations required for binary search is proportional to the logarithm of this range. If \\\\( M \\\\) is the maximum value in the array, the binary search will take \\\\( O(\\\\log M) \\\\) iterations.\\n\\n2. **Feasibility Check**: For each mid-value in the binary search, we perform a feasibility check which involves iterating over the entire array. This takes \\\\( O(n) \\\\) time, where \\\\( n \\\\) is the length of the array.\\n\\nCombining the two, the overall time complexity is \\\\( O(n \\\\log M) \\\\).\\n\\n### Space Complexity:\\n\\n1. **Binary Search Variables**: The binary search requires a constant amount of space for its variables (`left`, `right`, `mid`).\\n\\n2. **Feasibility Check Variables**: The feasibility check also uses a constant amount of space for its variables (`extra`).\\n\\nSince we\\'re not using any additional data structures that scale with the input size, the overall space complexity is \\\\( O(1) \\\\), which is constant space.\\n\\nIn summary:\\n- Time Complexity: \\\\( O(n \\\\log M) \\\\)\\n- Space Complexity: \\\\( O(1) \\\\)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkFeasibilty(int possibleMax,vector<int>& nums)\\n    {\\n        long long extra = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] < possibleMax)\\n            {\\n                extra += (possibleMax - nums[i]);\\n            }\\n            else\\n            {\\n                extra -= (nums[i] - possibleMax);\\n            }\\n\\n            if(extra<0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n            int n = nums.size();\\n            int left = nums[0];\\n            int right = *max_element(nums.begin()+1,nums.end());\\n            int res = nums[0];\\n            while(left <= right)\\n            {   \\n                int mid = (left+right)/2;\\n                \\n                if(checkFeasibilty(mid, nums))\\n                {\\n                    res= mid;\\n                    right = mid-1;\\n                    \\n                }\\n                else\\n                {\\n                    left = mid+1;\\n                }\\n\\n            }            \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkFeasibilty(int possibleMax,vector<int>& nums)\\n    {\\n        long long extra = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] < possibleMax)\\n            {\\n                extra += (possibleMax - nums[i]);\\n            }\\n            else\\n            {\\n                extra -= (nums[i] - possibleMax);\\n            }\\n\\n            if(extra<0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n            int n = nums.size();\\n            int left = nums[0];\\n            int right = *max_element(nums.begin()+1,nums.end());\\n            int res = nums[0];\\n            while(left <= right)\\n            {   \\n                int mid = (left+right)/2;\\n                \\n                if(checkFeasibilty(mid, nums))\\n                {\\n                    res= mid;\\n                    right = mid-1;\\n                    \\n                }\\n                else\\n                {\\n                    left = mid+1;\\n                }\\n\\n            }            \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727393,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long sum =0;\\n        long long ans =0;\\n        for(int i=0; i<nums.size();i++){\\n            sum+=nums[i];\\n            long long a = (sum+i)/(i+1);\\n            ans = max(ans, a);\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long sum =0;\\n        long long ans =0;\\n        for(int i=0; i<nums.size();i++){\\n            sum+=nums[i];\\n            long long a = (sum+i)/(i+1);\\n            ans = max(ans, a);\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413586,
                "title": "making-ice-cream-cones-fair-find-the-smallest-possible-maximum-cone",
                "content": "# Description\\nSolution for finding the smallest possible maximum ice cream cone by fairly distributing scoops using a running sum and averaging approach. \\uD83C\\uDF68\\uD83C\\uDFC3\\u200D\\u2642\\uFE0F\\uD83D\\uDCC8 Broken down to super simplistic terms so baby coders can get clue how this even makes sense. \\n\\n## Story Time\\nI found this problem to be exceptionally difficult to wrap my baby coder brain around. I had to get help from chatgpt and even then the ai bot friend had a hard time breaking it down and solving it correctly. \\n\\nI wound up asking it to explain the problem to me like I\\'m a 3rd grader and a few iterations later I asked it to tell me the problem like a story and then to relate the story to the code and the solution. \\n\\nThis approach made it make SO MUCH MORE SENSE to me than the giberish that was the initial problem prompt. Here\\'s the story and I hope you enjoy and find it helpful. \\n\\n---\\n\\n\\'Once upon a time, there was a kind dad named Jack who loved ice cream. He had a row of ice cream cones in front of him, each with a different number of scoops. Jack had many kids, and he wanted to share the ice cream with them in a fair way, but he also wanted to make sure he had a little more for himself since he was the dad after all.\\n\\nBut Jack had a special rule he had to follow. He could only take 2 scoops from one cone and add 2 scoops to another cone, but he could only move from left to right (no going back!). He wanted to come up with a strategy to make sure each of his kids got a similar amount of ice cream, but he could still have a bit more for himself.\\n\\nSo Jack put on his thinking cap and started working on his plan, just like a programmer with code. He knew he needed to keep track of the total number of scoops he had taken so far, just like a \"running sum\" in code. He could start from the leftmost cone and move towards the right, just like iterating through an array in code.\\n\\nAs Jack moved along the row of cones, he did some math, just like performing calculations in code. He calculated the average number of scoops per cone by dividing the running sum by the number of cones he had seen so far. But since Jack could only use whole numbers (no decimals!), he rounded up to the next whole number, just like using integer division in code.\\n\\nThen, Jack compared this \"evenly distributed\" number with the number of scoops on the biggest cone he had seen so far, just like comparing values in code. He kept the bigger one as the \"minimum maximum\" value, just like storing a variable with the maximum value seen so far in code.\\n\\nJack kept doing this for all the cones, always comparing the \"evenly distributed\" number with the biggest cone he had seen so far, and keeping the bigger one. At the end, the biggest cone he kept was the smallest possible maximum cone he could make by following the rule, just like the final result or output of the code.\\n\\nWith his clever strategy, Jack was able to divide the ice cream scoops in a fair and balanced way among his kids, making sure they all got a similar amount of ice cream, but he still had a little more for himself as the dad, just like solving the problem with code. His kids were happy with their ice cream treats, and Jack enjoyed sharing the joy of ice cream with his family! The end.\\'\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJack wants to distribute ice cream scoops in a fair way among his kids while keeping a little more for himself. He can only take 2 scoops from one cone and add 2 scoops to another cone, moving from left to right because of course the ice cream is melting and he needs to move quickly and efficiently before it all melts and the kids all cry and hate him the rest of their lives. \\n\\nIf you need more context, think of this scenario: If Jack and all his kids (who knows how many there actually are) go into a busy ice cream shop and just order a random batch where theres one cone per person but let the ice cream scooper choose how many scoops to put on the cones, then jack needs to fix it so his kids get a more fair amount of ice cream. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable to keep track of the total number of scoops taken so far.\\n2. Iterate through the row of cones from left to right.\\n3. For each cone, calculate the average number of scoops per cone by dividing the running sum by the number of cones seen so far (rounded up to the next whole number).\\n4. Compare the calculated \"evenly distributed\" number with the number of scoops on the biggest cone seen so far, and keep the bigger one as the \"minimum maximum\" value.\\n5. Repeat this process for all the cones, always keeping the bigger value as the \"minimum maximum\" value.\\n6. At the end, the biggest cone kept is the smallest possible maximum cone Jack can make by following the rule. Remember, he\\'s the dad and he\\'s doing all this work so he gets the biggest cone.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n), where n is the number of cones. This is because we need to iterate through each cone in the row of cones once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), as we are only using a constant amount of extra space to store the running sum and the \"minimum maximum\" value.\\n\\n# Code\\n```\\n\\nclass Solution(object):\\n    def minimizeArrayValue(self, cones):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_cone = 0 #the biggest cone seen so far\\n        running_total = 0 #the total number of scoops taken so far\\n        \\n        for i in range(len(cones)):\\n            running_total += nums[i] #add the scoops from the current cone to the running total\\n            avg_scoops = (running_total + i) // (i + 1)  # Calculate the average scoops per cone\\n            max_cone = max(max_cone, avg_scoops)  # Keep track of the biggest cone seen so far\\n        \\n        return max_cone  # Return the smallest possible maximum cone\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def minimizeArrayValue(self, cones):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_cone = 0 #the biggest cone seen so far\\n        running_total = 0 #the total number of scoops taken so far\\n        \\n        for i in range(len(cones)):\\n            running_total += nums[i] #add the scoops from the current cone to the running total\\n            avg_scoops = (running_total + i) // (i + 1)  # Calculate the average scoops per cone\\n            max_cone = max(max_cone, avg_scoops)  # Keep track of the biggest cone seen so far\\n        \\n        return max_cone  # Return the smallest possible maximum cone\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395159,
                "title": "not-the-best-one-but-glad-to-come-up-with-my-own",
                "content": "# Intuition\\nThis is more or less same as the averaging answer posted everywhere\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n\\n- Space complexity:\\n- O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& num) {\\n        long long ans=num[0];\\n        vector<long long> nums={num.begin(), num.end()};\\n        vector<long long> temp(nums.size(), nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            temp[i]=temp[i-1]+nums[i];\\n        }\\n        for(int i=nums.size()-1;i>0;i--){\\n            long long avg=temp[i]/(i+1);\\n            if(temp[i]%(i+1)) avg++;\\n            if(nums[i]<nums[i-1]){\\n                if(nums[i]>avg){\\n                    nums[i-1]+=(nums[i]-avg);\\n                    temp[i-1]+=(nums[i]-avg);\\n                    nums[i]-=(nums[i]-avg);\\n                }\\n                ans=max(ans, nums[i]);\\n                continue;\\n            }\\n            if(nums[i]<avg) continue;\\n            nums[i]-=abs(nums[i]-avg);\\n            nums[i-1]+=abs(nums[i]-avg);\\n            temp[i-1]+=abs(nums[i]-avg);\\n            \\n            ans=max(ans, nums[i]);\\n        }\\n        ans=max(ans, nums[0]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& num) {\\n        long long ans=num[0];\\n        vector<long long> nums={num.begin(), num.end()};\\n        vector<long long> temp(nums.size(), nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            temp[i]=temp[i-1]+nums[i];\\n        }\\n        for(int i=nums.size()-1;i>0;i--){\\n            long long avg=temp[i]/(i+1);\\n            if(temp[i]%(i+1)) avg++;\\n            if(nums[i]<nums[i-1]){\\n                if(nums[i]>avg){\\n                    nums[i-1]+=(nums[i]-avg);\\n                    temp[i-1]+=(nums[i]-avg);\\n                    nums[i]-=(nums[i]-avg);\\n                }\\n                ans=max(ans, nums[i]);\\n                continue;\\n            }\\n            if(nums[i]<avg) continue;\\n            nums[i]-=abs(nums[i]-avg);\\n            nums[i-1]+=abs(nums[i]-avg);\\n            temp[i-1]+=abs(nums[i]-avg);\\n            \\n            ans=max(ans, nums[i]);\\n        }\\n        ans=max(ans, nums[0]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389031,
                "title": "a-different-o-n-way-that-uses-an-ascending-stack-and-reversed-traversal",
                "content": "# Intuition\\nSince only latter number can give itself to the former ones, we can reverse the traversal so when we are looking at a number at index k, the best situation of k+1 \\\\~ n can already be determined and we can deduce the best of k\\\\~n from k+1 \\\\~ n\\nIf nums[k] is larger than nums[k+1] \\\\~ nums[n], then the result of k~n is nums[k] itself. Otherwise, we can borrow from k+1 to n so that we can get a better result now at k\\\\~n  than the result of k+1 \\\\~ n\\n\\n# Approach\\n1. Backward iteration\\n2. Use a stack to store the (height, amount) tuple, and maintains it ascending by height\\n3. If current number is smaller or equal than the height of the top element of the stack, pop the top element and merge it with current number\\n4. Merge means calculating the average of the height and sum of the amount of two \\'Blocks\\'\\n5. Merge until current height is larger than the top element to the stack, then push it into the stack\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        stack = deque()\\n        for num in nums[::-1]:\\n            cur = (num, 1)\\n            while len(stack) > 0 and cur[0] <= stack[-1][0]:\\n                old = stack.pop()\\n                amount = cur[1] + old[1]\\n                height = (cur[0] * cur[1] + old[0] * old[1]) / amount\\n                cur = (height, amount)\\n            stack.append(cur)\\n        return math.ceil(stack[-1][0])\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        stack = deque()\\n        for num in nums[::-1]:\\n            cur = (num, 1)\\n            while len(stack) > 0 and cur[0] <= stack[-1][0]:\\n                old = stack.pop()\\n                amount = cur[1] + old[1]\\n                height = (cur[0] * cur[1] + old[0] * old[1]) / amount\\n                cur = (height, amount)\\n            stack.append(cur)\\n        return math.ceil(stack[-1][0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384368,
                "title": "just-get-the-average",
                "content": "```\\nclass Solution:\\n    def minimizeArrayValue(self, a: List[int]) -> int:\\n        res = a[0]\\n        summ = a[0]\\n        for i in range(1,len(a)):\\n            summ+=a[i];\\n            res = max(math.ceil(summ/(i+1)),res)\\n        return res;\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeArrayValue(self, a: List[int]) -> int:\\n        res = a[0]\\n        summ = a[0]\\n        for i in range(1,len(a)):\\n            summ+=a[i];\\n            res = max(math.ceil(summ/(i+1)),res)\\n        return res;\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384215,
                "title": "beats-97-using-java-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long ans=0;\\n        long sum=0;\\n      for(int i=0;i<nums.length;i++) \\n      {\\n          sum+=nums[i];\\n           long k=(sum+i)/(long)(i+1);\\n           if(ans<k)ans=k; \\n       }\\n       return (int)ans;\\n    } \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long ans=0;\\n        long sum=0;\\n      for(int i=0;i<nums.length;i++) \\n      {\\n          sum+=nums[i];\\n           long k=(sum+i)/(long)(i+1);\\n           if(ans<k)ans=k; \\n       }\\n       return (int)ans;\\n    } \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384044,
                "title": "2439-minimize-maximum-of-array-java",
                "content": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        int ans=0;\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans=(int)Math.max(ans,(sum+i)/(i+1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        int ans=0;\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans=(int)Math.max(ans,(sum+i)/(i+1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383961,
                "title": "easy-clean-c-code-binarysearch-on-answer",
                "content": "## **Please NOTE:-**\\n#### I have not used passed by reference vector here because it will alter the given vector.....writing this specially as i have also not noticed this initially\\uD83D\\uDE43 & was doing the same wrong thing that took me a lot of time to debug\\uD83D\\uDE16\\uD83E\\uDD72 but finally i discovered it\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\n\\n### Have a good day/night\\uD83D\\uDE42\\n### Please Upvote\\uD83E\\uDD17\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool checker(int maxi,vector<long> nums,int n){   \\n        if(nums[0] > maxi)\\n            return false;\\n        for(int i = n - 1; i > 0 ; i--){\\n            if(nums[i] <= maxi)\\n                continue;\\n            long diff = nums[i] - maxi;\\n            nums[i - 1] += diff;\\n        }\\n        if(nums[0] > maxi)  //All the buffers will get collected in nums[0] so thats why checking it lastly again\\n            return false;\\n        return true;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int n = nums.size(),ll = 0,ul = 1e9,mid = 0,ans = 0;\\n        vector<long> vec(nums.begin(),nums.end());\\n        while(ll <= ul){\\n            mid = (ll + ul) >> 1;\\n            if(checker(mid,vec,n)){\\n                ul = mid - 1;\\n                ans = mid;\\n            }\\n            else\\n                ll = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checker(int maxi,vector<long> nums,int n){   \\n        if(nums[0] > maxi)\\n            return false;\\n        for(int i = n - 1; i > 0 ; i--){\\n            if(nums[i] <= maxi)\\n                continue;\\n            long diff = nums[i] - maxi;\\n            nums[i - 1] += diff;\\n        }\\n        if(nums[0] > maxi)  //All the buffers will get collected in nums[0] so thats why checking it lastly again\\n            return false;\\n        return true;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int n = nums.size(),ll = 0,ul = 1e9,mid = 0,ans = 0;\\n        vector<long> vec(nums.begin(),nums.end());\\n        while(ll <= ul){\\n            mid = (ll + ul) >> 1;\\n            if(checker(mid,vec,n)){\\n                ul = mid - 1;\\n                ans = mid;\\n            }\\n            else\\n                ll = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383872,
                "title": "binary-search-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool possible(int mid, int size, vector<int> nums) {\\n        if(mid<nums[0]) {\\n            return false;\\n        }\\n        long long sum = nums[size-1];\\n        for(int i = size-1; i>0; i--) {\\n            if(sum > mid) {\\n                long long dif = sum - mid;\\n                sum = (long long)(nums[i-1])+dif; \\n            }\\n            else {\\n                sum = nums[i-1];\\n            }\\n        }\\n        if(sum > mid) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int s = INT_MAX, e = INT_MIN;\\n        int size = nums.size();\\n        for(int i = 0; i<size; i++) {\\n            s = min(nums[i],s);\\n            e = max(nums[i],e);\\n        }\\n        int mid = s+(e-s)/2;\\n        while(s<e) {\\n            if(possible(mid,size,nums)) {\\n                e = mid;\\n            }\\n            else {\\n                s = mid+1;\\n            }\\n            mid = s+(e-s)/2;\\n        }\\n        return mid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool possible(int mid, int size, vector<int> nums) {\\n        if(mid<nums[0]) {\\n            return false;\\n        }\\n        long long sum = nums[size-1];\\n        for(int i = size-1; i>0; i--) {\\n            if(sum > mid) {\\n                long long dif = sum - mid;\\n                sum = (long long)(nums[i-1])+dif; \\n            }\\n            else {\\n                sum = nums[i-1];\\n            }\\n        }\\n        if(sum > mid) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int s = INT_MAX, e = INT_MIN;\\n        int size = nums.size();\\n        for(int i = 0; i<size; i++) {\\n            s = min(nums[i],s);\\n            e = max(nums[i],e);\\n        }\\n        int mid = s+(e-s)/2;\\n        while(s<e) {\\n            if(possible(mid,size,nums)) {\\n                e = mid;\\n            }\\n            else {\\n                s = mid+1;\\n            }\\n            mid = s+(e-s)/2;\\n        }\\n        return mid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383775,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe previous element takes the fall for the bigger element.\\nThe elements are getting equally distributed in a order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculated average sum for every element in the given order.\\nThe maximum average would be our answer.\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        s = 0\\n        ans = 0\\n        for i in range(len(nums)):\\n            s = s+nums[i]\\n            avg = s/(i+1)\\n            if avg > ans:\\n                ans = avg\\n        return ceil(ans)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        s = 0\\n        ans = 0\\n        for i in range(len(nums)):\\n            s = s+nums[i]\\n            avg = s/(i+1)\\n            if avg > ans:\\n                ans = avg\\n        return ceil(ans)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383747,
                "title": "c-o-n-beats-93-75",
                "content": "\\n\\n\\n\\n```\\npublic class Solution\\n{\\n  public int MinimizeArrayValue(int[] nums)\\n  {\\n    // Use long type because total can exceed int.MaxValue\\n    long total = nums[0];\\n    long ans = nums[0];\\n    for (var i = 1; i < nums.Length;)\\n    {\\n      total += nums[i];\\n      ans = Math.Max(ans, (long)Math.Ceiling(total * 1.0 / ++i));\\n    }\\n    return (int)ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n  public int MinimizeArrayValue(int[] nums)\\n  {\\n    // Use long type because total can exceed int.MaxValue\\n    long total = nums[0];\\n    long ans = nums[0];\\n    for (var i = 1; i < nums.Length;)\\n    {\\n      total += nums[i];\\n      ans = Math.Max(ans, (long)Math.Ceiling(total * 1.0 / ++i));\\n    }\\n    return (int)ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383733,
                "title": "typescript-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Approach is similar to water level in jar. For example for i index min height will be water level / index, next index i will increase one and height value will be accumulative sum / index.\\n- max height will be ans for each increament value\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N) = N length of nums\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1) constast space\\n\\n# Code\\n```\\nfunction minimizeArrayValue(nums: number[]): number {\\n    let ans = 0;\\n    let preSum = 0;\\n\\n    for (let i=0; i<nums.length; i++) {\\n        preSum += nums[i];\\n        ans = Math.max(ans, Math.ceil(preSum/(i+1)))\\n    }\\n\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minimizeArrayValue(nums: number[]): number {\\n    let ans = 0;\\n    let preSum = 0;\\n\\n    for (let i=0; i<nums.length; i++) {\\n        preSum += nums[i];\\n        ans = Math.max(ans, Math.ceil(preSum/(i+1)))\\n    }\\n\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3383722,
                "title": "c-easy-solution-using-prefix-sum",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        \\n        long long int res=0;\\n        \\n        int n=nums.size();\\n                  //prefixSum\\n        long long int prefSum=0;\\n\\n         for(int i=0;i<n;i++){\\n\\n             prefSum+=nums[i];\\n\\n             res= max(res , (prefSum+i)/(i+1));\\n         } \\n\\n         return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        \\n        long long int res=0;\\n        \\n        int n=nums.size();\\n                  //prefixSum\\n        long long int prefSum=0;\\n\\n         for(int i=0;i<n;i++){\\n\\n             prefSum+=nums[i];\\n\\n             res= max(res , (prefSum+i)/(i+1));\\n         } \\n\\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383686,
                "title": "o-n-java-dp",
                "content": "\\nclass Solution {\\n\\n    public int minimizeArrayValue(int[] nums) {\\n\\t\\n        int max = nums[0];\\n\\t\\t\\n\\t\\t//Keep Redundant value so that when you encounter any number greater than max, redundant can fill in\\n        long redundant = 0;\\n\\t\\t\\n        for(int i = 1;i<nums.length;i++){\\n            if(max == nums[i]){\\n                continue;\\n            }\\n            else if(max < nums[i]){\\n                int extra = nums[i]-max;\\n                if(extra > redundant){\\n                    extra -= redundant;\\n                    int level = extra/(i+1);\\n                    int rem = extra%(i+1);\\n                    max = max+level;\\n                    if(rem == 0){\\n                        redundant = 0;\\n                    }\\n                    else{\\n                        max++;\\n                        redundant = i+1-rem;\\n                    }\\n                }\\n                else{\\n                    redundant -=extra;\\n                }\\n            }\\n            else{\\n                redundant += max - nums[i];\\n            }\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n    public int minimizeArrayValue(int[] nums) {\\n\\t\\n        int max = nums[0];\\n\\t\\t\\n\\t\\t//Keep Redundant value so that when you encounter any number greater than max, redundant can fill in\\n        long redundant = 0;\\n\\t\\t\\n        for(int i = 1;i<nums.length;i++){\\n            if(max == nums[i]){\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3383596,
                "title": "simple-o-n-c-solution-using-prefix-sums",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        vector<long long>presum(n,0);\\n        presum[0] = nums[0];\\n\\n        for(int i=1;i<n;i++){\\n            presum[i] = presum[i-1] + nums[i];\\n        }\\n\\n        int runAvg = presum[0];\\n        int res = runAvg;\\n\\n        for(int i=1;i<n;i++){\\n            double den = i+1;\\n            runAvg = ceil(presum[i]/den);\\n            res = max(res, runAvg);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        vector<long long>presum(n,0);\\n        presum[0] = nums[0];\\n\\n        for(int i=1;i<n;i++){\\n            presum[i] = presum[i-1] + nums[i];\\n        }\\n\\n        int runAvg = presum[0];\\n        int res = runAvg;\\n\\n        for(int i=1;i<n;i++){\\n            double den = i+1;\\n            runAvg = ceil(presum[i]/den);\\n            res = max(res, runAvg);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383460,
                "title": "javascript-php-minimize-maximum-of-array-by-calculating-sum-and-finding-max-of-sum-i-1",
                "content": "# Approach\\nThis approach to solving the problem of minimizing the maximum value in an array is to calculate the sum of all the values in the array, and then find the maximum of the ceiling of the sum divided by the index plus one. This approach takes advantage of the fact that the sum of all the values in the array will always be larger than the maximum value, so by dividing the sum by the index plus one, we can find the maximum of the ceiling of the division, which will give us the minimum maximum value.\\n\\n# Complexity\\n*Time Complexity:* O(n) as the algorithm iterates through the array only once. \\n*Space Complexity:* O(1) as the algorithm uses only one variable to store the sum, and no additional data structures are used.\\n\\n\\n```php []\\nclass Solution\\n{\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function minimizeArrayValue(array $nums): int {\\n        $numLength = count($nums);\\n        $sum = 0;\\n        $mixMaxResult = 0;\\n        for ($i = 0; $i < $numLength; $i++) {\\n            $sum += $nums[$i];\\n            $mixMaxResult = max($mixMaxResult, ceil($sum / ($i + 1)));\\n        }\\n        return $mixMaxResult;\\n    }\\n}\\n```\\n```javascript []\\nvar minimizeArrayValue = function (nums) {\\n    let sum = 0;\\n    let res = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        res = Math.max(res, Math.ceil(sum / (i + 1)));\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "PHP",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```php []\\nclass Solution\\n{\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function minimizeArrayValue(array $nums): int {\\n        $numLength = count($nums);\\n        $sum = 0;\\n        $mixMaxResult = 0;\\n        for ($i = 0; $i < $numLength; $i++) {\\n            $sum += $nums[$i];\\n            $mixMaxResult = max($mixMaxResult, ceil($sum / ($i + 1)));\\n        }\\n        return $mixMaxResult;\\n    }\\n}\\n```\n```javascript []\\nvar minimizeArrayValue = function (nums) {\\n    let sum = 0;\\n    let res = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        res = Math.max(res, Math.ceil(sum / (i + 1)));\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383384,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) \\n    {\\n        long long int ans=0,s=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s+=nums[i];\\n            ans=max(ans,(s+i)/(i+1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) \\n    {\\n        long long int ans=0,s=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s+=nums[i];\\n            ans=max(ans,(s+i)/(i+1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383363,
                "title": "python3-o-n-greedy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        max_val = cur_sum = 0\\n\\n        for ind, num in enumerate(nums):            \\n            cur_sum += num\\n\\n            if num > max_val:\\n                mid_float = cur_sum / (ind + 1)\\n                mid_int = int(-1 * mid_float // 1 * -1)\\n                max_val = max([max_val, mid_int])\\n\\n        return max_val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        max_val = cur_sum = 0\\n\\n        for ind, num in enumerate(nums):            \\n            cur_sum += num\\n\\n            if num > max_val:\\n                mid_float = cur_sum / (ind + 1)\\n                mid_int = int(-1 * mid_float // 1 * -1)\\n                max_val = max([max_val, mid_int])\\n\\n        return max_val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383310,
                "title": "c-minimize-maximum-of-array-ac-faster-than-52-34-method-1",
                "content": "we want a single number bare minimum to be mid(the testing number) so that we can saythat we have achieved this number as our maximum number bbut if the prefix sum exceeds the mid element means that there is a number which ican surely say of going more than mid in the +/- operation \\n        what i mean to say is suppose array is of 4 spaces then\\n            5,5,5,5 is ok if it happening in real operations \\n            while below ones are also ok arrays after operations\\n            1 5 3 2\\n            5 5 3 4 \\n            5 4 2 4\\n            5 4 4 5\\n            etc....\\n            but this is not valid after operations\\n            7 5 3 2\\n            7 7 6 5\\n            6 5 4 3\\n            6 3 2 1\\n            \\n            as the maximum exceeds the 5 which is our sample to test here\\n            this particular characteristic can be caught by the if condition inside loop in the ABOVE code\\n            \\n            suppose in example 1 we take only first wo elements of array 3,7 w== if we try to make maximum of these both as 4 by the operations then let us see\\n                maximmum\\n            3,7  7\\n            4,6  6\\n            5,5  5\\n            6,4  6 and the repetitive process starts we cannot see here at any stage 4 as 4 cannot be adjusted with it being maximum among both of them\\n            \\n            NOW IMAGINE THIS IN CASE OF LARGE SIZE ARRAY\\n            \\n\\t\\t\\tbinary search is simply finding the maximum number we can settle as maximum \\n\\t\\t\\thigh points to element which can act as maximum\\n\\t\\t\\twhile low points to first element after mid which can act as maximum staying within the amount available to adjust the +/- operations\\n        \\n\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<int> &nums,long long int mid)\\n    {\\n         long long sum=0,maxnum=INT_MIN;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            if(sum>(i+1)*mid)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int minimizeArrayValue(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        \\n       int low=0,mid,high=*max_element(nums.begin(),nums.end());\\n        \\n        while(low<high)\\n        {\\n            mid=(low+high)>>1;\\n            \\n            if(isvalid(nums,mid))\\n            {\\n                high=mid;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n\\n        \\n        return high;\\n    }\\n};```\\n\\n![image](https://assets.leetcode.com/users/images/bccfb4ae-cd95-42f4-9ecd-5644148e7834_1680704215.9266646.png)",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<int> &nums,long long int mid)\\n    {\\n         long long sum=0,maxnum=INT_MIN;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            if(sum>(i+1)*mid)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int minimizeArrayValue(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        \\n       int low=0,mid,high=*max_element(nums.begin(),nums.end());\\n        \\n        while(low<high)\\n        {\\n            mid=(low+high)>>1;\\n            \\n            if(isvalid(nums,mid))\\n            {\\n                high=mid;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n\\n        \\n        return high;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3383270,
                "title": "swift-easy-solution-100",
                "content": "```\\nclass Solution {\\n    func minimizeArrayValue(_ nums: [Int]) -> Int {\\n        var nums = nums\\n        var prefixSum = 0\\n        var maxValue = 0\\n        for num in (0...nums.count - 1) {\\n            prefixSum += nums[num]\\n            maxValue = max(maxValue, Int((Double(prefixSum) / Double(num + 1)).rounded(.up)))\\n        }\\n        return maxValue\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimizeArrayValue(_ nums: [Int]) -> Int {\\n        var nums = nums\\n        var prefixSum = 0\\n        var maxValue = 0\\n        for num in (0...nums.count - 1) {\\n            prefixSum += nums[num]\\n            maxValue = max(maxValue, Int((Double(prefixSum) / Double(num + 1)).rounded(.up)))\\n        }\\n        return maxValue\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383254,
                "title": "binary-search-solution",
                "content": "# Intuition\\nAnswer cannot be less than nums[0] and cannot be greater than maximum element in the nums array.\\n\\n# Approach\\nBinary Search the answer between lo=nums[0] and hi=maximum element in the nums array. Creating a check function to check whether the given value can be obtained as maximum. If yes, answer can be that value or must be less than that value.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &nums, int x) {\\n        long long curr=nums[nums.size()-1], next;\\n        for(int i=nums.size()-1; i>=1; --i) {\\n            next = nums[i-1];\\n            if(curr > x) {\\n                next += (curr-x);\\n            }\\n            curr = next;\\n        }\\n        return (curr <= x);\\n    }\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int lo = nums[0];\\n        int hi = *max_element(nums.begin(), nums.end());\\n        while(hi-lo > 1) {\\n            int mid = lo + (hi-lo)/2;\\n            if(check(nums, mid)) {\\n                hi = mid;\\n            } else {\\n                lo = mid+1;\\n            }\\n        }\\n        if(check(nums, lo)) {\\n            return lo;\\n        } else {\\n            return hi;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &nums, int x) {\\n        long long curr=nums[nums.size()-1], next;\\n        for(int i=nums.size()-1; i>=1; --i) {\\n            next = nums[i-1];\\n            if(curr > x) {\\n                next += (curr-x);\\n            }\\n            curr = next;\\n        }\\n        return (curr <= x);\\n    }\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int lo = nums[0];\\n        int hi = *max_element(nums.begin(), nums.end());\\n        while(hi-lo > 1) {\\n            int mid = lo + (hi-lo)/2;\\n            if(check(nums, mid)) {\\n                hi = mid;\\n            } else {\\n                lo = mid+1;\\n            }\\n        }\\n        if(check(nums, lo)) {\\n            return lo;\\n        } else {\\n            return hi;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383232,
                "title": "binary-search-solution",
                "content": "# Intuition\\nWe used Binary search for this problem as this answer is of the type where we find minimum of maximums , so there can be many possible maximums and we have to find the minimum of it.\\n\\n# Approach\\nAssume each element as a histogram in a graph.\\n\\n# Complexity\\n- Time complexity:\\nO(log(n)) + O(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n ;\\nbool check(vector<int>& nums , int mid)\\n{\\n//We can see that the direction in which load is shifted is always R->L(right to left), so the leftmost element cannot be lesser than what it presently is , i.e(nums[0]). \\n// if our assumed answer , i.e (mid) is less than nums[0] , it can never be the maximum in our array , so we have to return false\\n\\nif(nums[0] > mid)\\nreturn false ;\\n\\n// this variable stores the sum of difference of element from the peak i.e, mid\\n// or we can say that this variable tells us the extra space that is available to further reduce our peak\\nlong long diff_from_peak = 0 ;\\nfor(int i = 0 ; i< n ; i++)\\n{\\n  // if the current element is less than the peak , it is added to the available space\\n   if(nums[i]< mid)\\n   {\\n      diff_from_peak += (mid - nums[i]);\\n   }\\n   else\\n   {\\n     // if their is  extra from the peak , we put it in the available space , hence reducing the space by that amount\\n      if(nums[i] - mid <= diff_from_peak)\\n      {\\n            diff_from_peak -= (nums[i]-mid);\\n      }\\n      else\\n      {\\n\\n        // if the available space is less than the overload , we have to return false \\n       return false ;\\n      }\\n      \\n   }\\n}\\n// if everything goes right , this is one possible answer , so we return true \\nreturn true ;\\n\\n\\n}\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int l = 0 ;\\n        // int h = INT_MIN ;\\n        int h = INT_MAX ;\\n        n = nums.size();\\n        // for(int i = 0 ; i< nums.size() ; i++)\\n        // {\\n        //   h = max(h,nums[i]);\\n        // }\\n\\n        while(l<h)\\n        {\\n          int mid = l+ (h-l)/2;\\n          if(check(nums,mid))\\n          {\\n              h = mid ;\\n          }\\n          else\\n          {\\n             l = mid+1;\\n          }\\n        }\\n        return l ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n ;\\nbool check(vector<int>& nums , int mid)\\n{\\n//We can see that the direction in which load is shifted is always R->L(right to left), so the leftmost element cannot be lesser than what it presently is , i.e(nums[0]). \\n// if our assumed answer , i.e (mid) is less than nums[0] , it can never be the maximum in our array , so we have to return false\\n\\nif(nums[0] > mid)\\nreturn false ;\\n\\n// this variable stores the sum of difference of element from the peak i.e, mid\\n// or we can say that this variable tells us the extra space that is available to further reduce our peak\\nlong long diff_from_peak = 0 ;\\nfor(int i = 0 ; i< n ; i++)\\n{\\n  // if the current element is less than the peak , it is added to the available space\\n   if(nums[i]< mid)\\n   {\\n      diff_from_peak += (mid - nums[i]);\\n   }\\n   else\\n   {\\n     // if their is  extra from the peak , we put it in the available space , hence reducing the space by that amount\\n      if(nums[i] - mid <= diff_from_peak)\\n      {\\n            diff_from_peak -= (nums[i]-mid);\\n      }\\n      else\\n      {\\n\\n        // if the available space is less than the overload , we have to return false \\n       return false ;\\n      }\\n      \\n   }\\n}\\n// if everything goes right , this is one possible answer , so we return true \\nreturn true ;\\n\\n\\n}\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int l = 0 ;\\n        // int h = INT_MIN ;\\n        int h = INT_MAX ;\\n        n = nums.size();\\n        // for(int i = 0 ; i< nums.size() ; i++)\\n        // {\\n        //   h = max(h,nums[i]);\\n        // }\\n\\n        while(l<h)\\n        {\\n          int mid = l+ (h-l)/2;\\n          if(check(nums,mid))\\n          {\\n              h = mid ;\\n          }\\n          else\\n          {\\n             l = mid+1;\\n          }\\n        }\\n        return l ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383132,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            res = Math.max(res, (sum + i) / (i + 1));\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            res = Math.max(res, (sum + i) / (i + 1));\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382988,
                "title": "java-solution-3-ms",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        int max = nums[0];\\n        long buf = max;\\n        for (int i = 1; i < nums.length; i++) {\\n            buf = nums[i] - (max - buf);\\n            if (buf > max) {\\n                int d = Math.toIntExact(buf - max);\\n                max += (d + i) / (i + 1);\\n                buf = max - (d % (i + 1) != 0 ? (i + 1 - d % (i + 1)) : 0);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        int max = nums[0];\\n        long buf = max;\\n        for (int i = 1; i < nums.length; i++) {\\n            buf = nums[i] - (max - buf);\\n            if (buf > max) {\\n                int d = Math.toIntExact(buf - max);\\n                max += (d + i) / (i + 1);\\n                buf = max - (d % (i + 1) != 0 ? (i + 1 - d % (i + 1)) : 0);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382819,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func minimizeArrayValue(_ nums: [Int]) -> Int {\\n        var res = nums[0]\\n        var total = nums[0]\\n\\n        for i in 1..<nums.count {\\n            total += nums[i]\\n            res = max(res, Int(ceil(Double(total) / Double(i + 1))))\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimizeArrayValue(_ nums: [Int]) -> Int {\\n        var res = nums[0]\\n        var total = nums[0]\\n\\n        for i in 1..<nums.count {\\n            total += nums[i]\\n            res = max(res, Int(ceil(Double(total) / Double(i + 1))))\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382799,
                "title": "accumulate-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport itertools\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        return max((x+ind)//(ind+1) for ind, x in enumerate(itertools.accumulate(nums)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport itertools\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        return max((x+ind)//(ind+1) for ind, x in enumerate(itertools.accumulate(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382792,
                "title": "simple-and-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] arr) {\\n        long sum=0;\\n        long res=0;\\n        for(int i=0; i<arr.length; i++){\\n            sum+=arr[i];\\n            res=Math.max(res, (sum+i)/(i+1));\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] arr) {\\n        long sum=0;\\n        long res=0;\\n        for(int i=0; i<arr.length; i++){\\n            sum+=arr[i];\\n            res=Math.max(res, (sum+i)/(i+1));\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382725,
                "title": "typescript-greedy-prefix-sum",
                "content": "# Brute Force (TLE)\\n\\n## Intuition\\nstarting from the back on each iteration, Keep adding from a index to the one before as far as the number in current index is greater. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n## Complexity\\n- Time complexity:\\nO(mn) -> where m is number of iterations as far the number on an index is greater than the one before\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nfunction minimizeArrayValue(nums: number[]): number {\\n    let stillMoreGreater:boolean = true;\\n\\n    while(stillMoreGreater) {  \\n        let stillMoreGreaterTemp: boolean = false;\\n\\n        for (let j = nums.length - 1; j >= 1; j--) {\\n            if((nums[j] > nums[j - 1]) && nums[j] > 0) {\\n                stillMoreGreaterTemp = true;\\n\\n                let numToSubAndAdd: number = Math.ceil((nums[j] - nums[j - 1]) / 2);\\n\\n                nums[j - 1] += numToSubAndAdd;\\n                nums[j] -= numToSubAndAdd;\\n            }\\n        }\\n\\n        stillMoreGreater = stillMoreGreaterTemp;\\n    }\\n\\n    return Math.max(...nums);\\n};\\n```\\n\\n# Greedy + PrefixSum\\n\\n## Intuition\\nCalculate the prefix sum at each index and try to evenly spread that between all indexes in that range including the current index. The maximum at that point should be the maximum between the current maximum and the maximum after the prefix sum has been evenly shared. Initialize current maximum to 0.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n## Complexity\\n- Time complexity:\\nO(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction minimizeArrayValue(nums: number[]): number {\\n    let ps: number = 0;\\n    let minSum: number = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        ps += nums[i];\\n\\n        minSum = Math.max(minSum, Math.ceil(ps/(i+1)));\\n    }\\n\\n    return minSum\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nfunction minimizeArrayValue(nums: number[]): number {\\n    let stillMoreGreater:boolean = true;\\n\\n    while(stillMoreGreater) {  \\n        let stillMoreGreaterTemp: boolean = false;\\n\\n        for (let j = nums.length - 1; j >= 1; j--) {\\n            if((nums[j] > nums[j - 1]) && nums[j] > 0) {\\n                stillMoreGreaterTemp = true;\\n\\n                let numToSubAndAdd: number = Math.ceil((nums[j] - nums[j - 1]) / 2);\\n\\n                nums[j - 1] += numToSubAndAdd;\\n                nums[j] -= numToSubAndAdd;\\n            }\\n        }\\n\\n        stillMoreGreater = stillMoreGreaterTemp;\\n    }\\n\\n    return Math.max(...nums);\\n};\\n```\n```\\nfunction minimizeArrayValue(nums: number[]): number {\\n    let ps: number = 0;\\n    let minSum: number = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        ps += nums[i];\\n\\n        minSum = Math.max(minSum, Math.ceil(ps/(i+1)));\\n    }\\n\\n    return minSum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3382672,
                "title": "day-95-binary-search-c-easy-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isPossible(vector< int> &nums, int t){\\n        if(nums[0]>t) return false;\\n        long long int p = nums[0];\\n        for(int i = 1; i<nums.size(); i++){\\n            long long int dif = t - p;\\n            p = nums[i] - dif;\\n            if(p>t) return false;\\n        }\\n        return true;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int s = 0;\\n        int e = INT_MIN;\\n\\n        for(int i = 0; i<nums.size(); i++) e = max(e,nums[i]);\\n\\n        while(s<e){\\n            int mid = (s+e)/2;\\n\\n            if(isPossible(nums,mid)) e = mid;\\n            else s = mid+1;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isPossible(vector< int> &nums, int t){\\n        if(nums[0]>t) return false;\\n        long long int p = nums[0];\\n        for(int i = 1; i<nums.size(); i++){\\n            long long int dif = t - p;\\n            p = nums[i] - dif;\\n            if(p>t) return false;\\n        }\\n        return true;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int s = 0;\\n        int e = INT_MIN;\\n\\n        for(int i = 0; i<nums.size(); i++) e = max(e,nums[i]);\\n\\n        while(s<e){\\n            int mid = (s+e)/2;\\n\\n            if(isPossible(nums,mid)) e = mid;\\n            else s = mid+1;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382603,
                "title": "c-very-easy-solution-o-n",
                "content": "<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long int ans = 0 , temp = 0;\\n        int n = nums.size();\\n        for( int i=0 ; i<n ; i++)\\n        {\\n            temp += nums[i];\\n            long long int cou = ceil((double)temp / (i+1)) ;\\n            ans = max( cou , ans );\\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        long long int ans = 0 , temp = 0;\\n        int n = nums.size();\\n        for( int i=0 ; i<n ; i++)\\n        {\\n            temp += nums[i];\\n            long long int cou = ceil((double)temp / (i+1)) ;\\n            ans = max( cou , ans );\\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382541,
                "title": "c-binary-search-on-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& nums, int pred) {\\n        if(nums[0] > pred)return false;\\n        \\n        long long n = size(nums), left = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] < pred) {\\n                left += (0LL + pred - nums[i]);\\n            }\\n            else {\\n                if(nums[i] - pred  <= left) {\\n                    left -= (nums[i] - pred);\\n                }\\n                else return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int minimizeArrayValue(vector<int>& nums) {\\n        \\n        int low = 0, high = *max_element(begin(nums), end(nums));\\n        \\n        while(low < high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(check(nums,mid))high = mid;\\n            else low = mid+1;\\n        }\\n        \\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& nums, int pred) {\\n        if(nums[0] > pred)return false;\\n        \\n        long long n = size(nums), left = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] < pred) {\\n                left += (0LL + pred - nums[i]);\\n            }\\n            else {\\n                if(nums[i] - pred  <= left) {\\n                    left -= (nums[i] - pred);\\n                }\\n                else return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int minimizeArrayValue(vector<int>& nums) {\\n        \\n        int low = 0, high = *max_element(begin(nums), end(nums));\\n        \\n        while(low < high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(check(nums,mid))high = mid;\\n            else low = mid+1;\\n        }\\n        \\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382403,
                "title": "binary-search-easy-c-code-step-by-step-explanation",
                "content": "\\n# Approach\\nSimple Approach of Binary Search on 0 to MaxElement(ARRAY)\\n\\n\"We are just minimizing the maxima\" (THIS PHRASE IN PROBLEM ALWAYS GIVES A HINT OF BINARY SEARCH)\\n\\nUsing an observation over several test case I just ended upon solution.\\n\\nBEFORE UNDERSTANDING THE LOGIC , try to dry run for test case \\n\\n\\n# Complexity\\n- Time complexity: O(N*log2(MaxElement)) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isPossible(vector <int>&nums , int k){\\n\\n        int n = nums.size();\\n        // First making a difference vector (currMax(k) - ith element)\\n        vector <long long> temp(n,0);\\n\\n        for(int i=0 ; i<n ; i++){\\n\\n            temp[i] = k-nums[i];\\n\\n        }\\n\\n        long long currSum = 0;\\n\\n        // If at any point of time my currSum becomes negative , then it is impossible to have K as the min of the maxima.\\n\\n        // For K = 8\\n        // [ 2 , 10 ]\\n        //  +6  , -2 , currSum will always be positive means it is possible to decrease 10 by factor of 2 and increase  2 by factor of 6 , making maximum as K = 8\\n\\n\\n\\n        // For K = 8\\n        // [ 10 , 2 ]\\n        //  -2 , +6  means currSum will be negative at first pt and it cannot be possible beacuse A[0] cannot be reduced only increased.\\n\\n\\n        // For k =5\\n        // [ 3 ,7 , 1 , 6 , 10 ]\\n        // [+2, -2, +4, -1 , -5]\\n\\n// curr Sum [2 , 0 , 4 , 3 , -2] here at last index currSum is negative hence it is not possible.\\n\\n\\n        // NOTE : Reducing a number does not affects its maximum value but increasing does , so we are mainly noticing whether is it possible to increase it by checking currSum.\\n\\n        for(auto &val : temp){\\n\\n            currSum += val;\\n\\n            if(currSum < 0) return false;\\n\\n        }\\n\\n        return true;\\n\\n\\n\\n    }\\n\\n\\n\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        \\n        int lo = 0;\\n        int hi = *max_element(nums.begin(),nums.end());\\n\\n        int mid;\\n        int ans;\\n        while(lo <= hi){\\n\\n            mid = lo + (hi-lo)/2;\\n\\n            if(isPossible(nums,mid)){\\n                // minimizing the maximum value\\n                ans = mid;\\n                hi = mid-1;\\n\\n            }\\n\\n            else{\\n\\n                lo = mid+1;\\n\\n            }\\n\\n        }\\n \\n\\n        return ans;\\n\\n    }\\n};\\n\\n\\nPLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isPossible(vector <int>&nums , int k){\\n\\n        int n = nums.size();\\n        // First making a difference vector (currMax(k) - ith element)\\n        vector <long long> temp(n,0);\\n\\n        for(int i=0 ; i<n ; i++){\\n\\n            temp[i] = k-nums[i];\\n\\n        }\\n\\n        long long currSum = 0;\\n\\n        // If at any point of time my currSum becomes negative , then it is impossible to have K as the min of the maxima.\\n\\n        // For K = 8\\n        // [ 2 , 10 ]\\n        //  +6  , -2 , currSum will always be positive means it is possible to decrease 10 by factor of 2 and increase  2 by factor of 6 , making maximum as K = 8\\n\\n\\n\\n        // For K = 8\\n        // [ 10 , 2 ]\\n        //  -2 , +6  means currSum will be negative at first pt and it cannot be possible beacuse A[0] cannot be reduced only increased.\\n\\n\\n        // For k =5\\n        // [ 3 ,7 , 1 , 6 , 10 ]\\n        // [+2, -2, +4, -1 , -5]\\n\\n// curr Sum [2 , 0 , 4 , 3 , -2] here at last index currSum is negative hence it is not possible.\\n\\n\\n        // NOTE : Reducing a number does not affects its maximum value but increasing does , so we are mainly noticing whether is it possible to increase it by checking currSum.\\n\\n        for(auto &val : temp){\\n\\n            currSum += val;\\n\\n            if(currSum < 0) return false;\\n\\n        }\\n\\n        return true;\\n\\n\\n\\n    }\\n\\n\\n\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        \\n        int lo = 0;\\n        int hi = *max_element(nums.begin(),nums.end());\\n\\n        int mid;\\n        int ans;\\n        while(lo <= hi){\\n\\n            mid = lo + (hi-lo)/2;\\n\\n            if(isPossible(nums,mid)){\\n                // minimizing the maximum value\\n                ans = mid;\\n                hi = mid-1;\\n\\n            }\\n\\n            else{\\n\\n                lo = mid+1;\\n\\n            }\\n\\n        }\\n \\n\\n        return ans;\\n\\n    }\\n};\\n\\n\\nPLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382327,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool Ispossible(long long target,vector<int>& nums)\\n    {\\n        vector<long long>arr(nums.begin(),nums.end());\\n        int n =arr.size();\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(arr[i] > target)\\n            {\\n                return false;\\n            }\\n            else if(arr[i]<= target)\\n            {\\n                arr[i+1] -= (target-arr[i]);\\n            }\\n        }\\n\\n        return (arr[n-1]<=target);\\n    }\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int start =0;\\n        int end = *max_element(nums.begin(),nums.end());\\n        int ans;\\n        while(start<end)\\n        {\\n            int mid =(start+end)/2;\\n            if(Ispossible(mid,nums))\\n            {\\n                end =mid;\\n               \\n            }\\n            else{\\n                start =mid+1;\\n            }\\n\\n        }\\n\\n        return start;\\n         }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool Ispossible(long long target,vector<int>& nums)\\n    {\\n        vector<long long>arr(nums.begin(),nums.end());\\n        int n =arr.size();\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(arr[i] > target)\\n            {\\n                return false;\\n            }\\n            else if(arr[i]<= target)\\n            {\\n                arr[i+1] -= (target-arr[i]);\\n            }\\n        }\\n\\n        return (arr[n-1]<=target);\\n    }\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int start =0;\\n        int end = *max_element(nums.begin(),nums.end());\\n        int ans;\\n        while(start<end)\\n        {\\n            int mid =(start+end)/2;\\n            if(Ispossible(mid,nums))\\n            {\\n                end =mid;\\n               \\n            }\\n            else{\\n                start =mid+1;\\n            }\\n\\n        }\\n\\n        return start;\\n         }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382262,
                "title": "binary-search-c-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf maxi is the maximum value in an array num, containing n elements, then\\n**(sum of n elements in num)<=(n*maxi)**\\n\\n# Complexity\\n- Time complexity: O(nlogm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: Constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        //apply binary search on all possible maxi\\'s for this array\\n        int maxim=nums[0];\\n        for(auto num:nums) {\\n            maxim=max(maxim,num);\\n        }\\n\\n        int i=0, j=maxim;       //possible maxi\\'s lies between [i,j]\\n        while(i<j) {\\n            int assumedMax=i+(j-i)/2;\\n\\n            long long prefixSum=0;\\n            int k;\\n            for(k=0;k<n;k++) {\\n                prefixSum+=nums[k];\\n                if(prefixSum<=(long long)(k+1)*assumedMax) {\\n                    continue;\\n                }\\n                else {\\n                    i=assumedMax+1;\\n                    break;\\n                }\\n            }\\n            if(k==n) {\\n                j=assumedMax;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        //apply binary search on all possible maxi\\'s for this array\\n        int maxim=nums[0];\\n        for(auto num:nums) {\\n            maxim=max(maxim,num);\\n        }\\n\\n        int i=0, j=maxim;       //possible maxi\\'s lies between [i,j]\\n        while(i<j) {\\n            int assumedMax=i+(j-i)/2;\\n\\n            long long prefixSum=0;\\n            int k;\\n            for(k=0;k<n;k++) {\\n                prefixSum+=nums[k];\\n                if(prefixSum<=(long long)(k+1)*assumedMax) {\\n                    continue;\\n                }\\n                else {\\n                    i=assumedMax+1;\\n                    break;\\n                }\\n            }\\n            if(k==n) {\\n                j=assumedMax;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382233,
                "title": "binary-search-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        //\\u5F9E\\u6700\\u5F8C\\u4E00\\u4F4D\\u958B\\u59CB\\u8655\\u7406 \\u905E\\u88DC\\n        int left = 0;\\n        int right = (int) 1e9+7;\\n\\n        while(left <= right){\\n            int mid = left + (right- left)/ 2;\\n            long extra = 0;//\\u907F\\u514D\\u6613\\u4F4D\\n            for(int i = nums.length - 1; i>= 0; i--){\\n                long total = nums[i] + extra;//\\u907F\\u514D\\u6613\\u4F4D\\n                if(total <= mid){\\n                    extra = 0;\\n                }else if(total > mid){\\n                    extra = total - mid;\\n                }\\n            }\\n            if(extra > 0){\\n                left = mid + 1;\\n            }else if(extra == 0){\\n                right = mid - 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        //\\u5F9E\\u6700\\u5F8C\\u4E00\\u4F4D\\u958B\\u59CB\\u8655\\u7406 \\u905E\\u88DC\\n        int left = 0;\\n        int right = (int) 1e9+7;\\n\\n        while(left <= right){\\n            int mid = left + (right- left)/ 2;\\n            long extra = 0;//\\u907F\\u514D\\u6613\\u4F4D\\n            for(int i = nums.length - 1; i>= 0; i--){\\n                long total = nums[i] + extra;//\\u907F\\u514D\\u6613\\u4F4D\\n                if(total <= mid){\\n                    extra = 0;\\n                }else if(total > mid){\\n                    extra = total - mid;\\n                }\\n            }\\n            if(extra > 0){\\n                left = mid + 1;\\n            }else if(extra == 0){\\n                right = mid - 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382192,
                "title": "from-zero-to-hero-c-8-line-solution-t-100",
                "content": "For those who do not want to read, see bottom for the fastest solution.\\n\\nBack in October, I did a competition and this problem was one of the ones I failed. At the time, I was unable to solve this problem without TLE. I was able to generate a working solution but I could not make it fast enough. Here\\'s my code:\\n\\n# TLE Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int currMax = INT_MAX, n = nums.size();\\n        while (currMax != 0) {\\n            currMax = 0;\\n            for (int i = 1; i < n; i++)\\n                if (nums[currMax] < nums[i]) {\\n                    currMax = i;\\n                    int diff = nums[currMax] + nums[currMax-1];\\n                    int div2 = diff >> 1;\\n                    nums[currMax] = div2;\\n                    nums[currMax-1] = div2 + (diff & 1);\\n                }\\n        }\\n        return nums[0];\\n    }\\n};\\n```\\nThis original code found the current maximum element of the array while it was not the first element and iteratively reduced the size of that element. I look back now and realize I\\'ve gotten substantially better at Leetcode.\\n\\n---\\nWhen I solved this problem today, my very first thought was, \"What optimal subproblem can I solve?\"\\n\\nThe answer I arrived at within 10 minutes was: The problem is solved optimally and trivially when ```nums.size == 1```. That realization led me to the solution I wrote today. If you expand that thought to ```nums.size == 2```, then if the second element is larger than the first, you can have a larger answer than the trivial case, else the trivial case wins.\\n\\nMore generally, at each step, if you spread out the numbers equally, this spreading can only increase the current maximum if and only if the average of those numbers is greater than the current maximum. Thus if you keep the average, you know how to spread the numbers and can compare it to the maximum. This led me to this 8-line, 100ms solution:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        double currAvg = nums[0];\\n        int currMax = nums[0], n = nums.size();\\n        for (int i = 1; i < n; i++) {\\n            currAvg += (nums[i] - currAvg) / (i+1);\\n            if (nums[i] > currMax && ceil(currAvg) > currMax)\\n                currMax = ceil(currAvg);\\n        }\\n        return currMax;\\n    }\\n};\\n```\\n\\nPlease like if this helped you!",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int currMax = INT_MAX, n = nums.size();\\n        while (currMax != 0) {\\n            currMax = 0;\\n            for (int i = 1; i < n; i++)\\n                if (nums[currMax] < nums[i]) {\\n                    currMax = i;\\n                    int diff = nums[currMax] + nums[currMax-1];\\n                    int div2 = diff >> 1;\\n                    nums[currMax] = div2;\\n                    nums[currMax-1] = div2 + (diff & 1);\\n                }\\n        }\\n        return nums[0];\\n    }\\n};\\n```\n```nums.size == 1```\n```nums.size == 2```\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        double currAvg = nums[0];\\n        int currMax = nums[0], n = nums.size();\\n        for (int i = 1; i < n; i++) {\\n            currAvg += (nums[i] - currAvg) / (i+1);\\n            if (nums[i] > currMax && ceil(currAvg) > currMax)\\n                currMax = ceil(currAvg);\\n        }\\n        return currMax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382181,
                "title": "easy-4-line-c-code-prefix-sum",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int ans = -INT_MAX;\\n        long long pref =0;\\n\\n        for(int i=0; i<nums.size(); ++i){\\n            pref += nums[i];\\n            ans = ((pref+i)/(i+1)>ans)\\n               = (pref+i)/(i+1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int ans = -INT_MAX;\\n        long long pref =0;\\n\\n        for(int i=0; i<nums.size(); ++i){\\n            pref += nums[i];\\n            ans = ((pref+i)/(i+1)>ans)\\n               = (pref+i)/(i+1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382166,
                "title": "binary-search-most-intuitive-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool helper(vector<int>& nums,int limit,int &n){\\n        long long balance=0;\\n        for(int i=n-1;i>=0;i--){\\n            balance=nums[i]+balance-limit;\\n            if(balance<=0){\\n                balance=0;\\n            }\\n        }\\n        if(balance<=0) return true;\\n        else return false;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=*min_element(nums.begin(),nums.end());\\n        int e=*max_element(nums.begin(),nums.end());\\n        int ans=-1;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(helper(nums,mid,n)){\\n                e=mid-1;\\n                ans=mid;\\n            }\\n            else s=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool helper(vector<int>& nums,int limit,int &n){\\n        long long balance=0;\\n        for(int i=n-1;i>=0;i--){\\n            balance=nums[i]+balance-limit;\\n            if(balance<=0){\\n                balance=0;\\n            }\\n        }\\n        if(balance<=0) return true;\\n        else return false;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=*min_element(nums.begin(),nums.end());\\n        int e=*max_element(nums.begin(),nums.end());\\n        int ans=-1;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(helper(nums,mid,n)){\\n                e=mid-1;\\n                ans=mid;\\n            }\\n            else s=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382159,
                "title": "prefix-sum-average-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0;\\n        long res = 0;\\n        for (int i = 0; i <nums.length; i++) {\\n            sum += nums[i];\\n            res= Math.max(res,(sum + i) /(i + 1));\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0;\\n        long res = 0;\\n        for (int i = 0; i <nums.length; i++) {\\n            sum += nums[i];\\n            res= Math.max(res,(sum + i) /(i + 1));\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382143,
                "title": "c-easiest-solution-prefix-sum-max-of-average-o-n-time-complexity",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        ll s = nums[0],res = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            s += nums[i];\\n            res = max(res,(s+i)/(i+1));\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        ll s = nums[0],res = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            s += nums[i];\\n            res = max(res,(s+i)/(i+1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3382125,
                "title": "easy-cpp-solution-beats-99-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first intuition for this problem would be to think about how to divide the elements into groups in a way that would minimize the maximum value. One approach could be to use binary search to find the minimum possible value of the maximum value, and then check if it is possible to divide the elements into groups such that the maximum value is less than or equal to this minimum value.\\n\\nHowever, the given code uses a simpler approach by calculating the prefix sums of the input vector and then calculating the average value of each group using the prefix sums. The ceiling of the average value is then used as the value of each element in the resulting vector, and the maximum value of this vector is returned as the solution.\\n\\nTherefore, the first intuition for this problem could be to think about how to divide the elements into groups and calculate the average value of each group in a way that would minimize the maximum value. The given code provides a simple and efficient solution to this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is a C++ code that takes a vector of integers nums as input and returns an integer value max. The purpose of this code is to minimize the maximum value in the input vector by dividing the elements of the vector into groups and taking the ceiling of the average value of each group.\\n\\nThe code begins by disabling synchronization between the C++ standard streams and the C standard streams for faster input and output.\\n\\nThen, a new vector pref of type vector<long long> is created with the same size as nums to store the prefix sums of nums. The first element of pref is assigned the value of the first element of nums, and then a loop is executed to calculate the prefix sums of nums and store them in pref.\\n\\nAfter that, the maximum value in the input vector is initialized to zero.\\n\\nThe next loop iterates through the elements of nums, and for each element nums[i], it calculates the average value of the first i+1 elements in nums using the prefix sum array pref, and then takes the ceiling of this value. The resulting value is then assigned to nums[i]. If nums[i] is greater than the current value of max, then max is updated to the value of nums[i].\\n\\nFinally, the function returns the value of max.\\n\\nIn summary, this code calculates the prefix sums of an input vector, divides the elements into groups, calculates the average value of each group using the prefix sums, and takes the ceiling of each average value. The code then returns the maximum value of the resulting vector.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given code is O(n), where n is the size of the input vector nums.\\n\\nThe loop that calculates the prefix sums of nums takes O(n) time.\\n\\nThe loop that iterates through the elements of nums and calculates the average value of each group also takes O(n) time.\\n\\nThus, the overall time complexity of the code is O(n) + O(n) = O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the given code is O(n), where n is the size of the input vector nums.\\n\\nThe additional space used in the code is for the pref vector, which has the same size as nums, and thus requires O(n) space.\\n\\nTherefore, the space complexity of the code is O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n       vector<long long>pref(nums.size());\\n       pref[0]=nums[0];\\n       for(int i=1;i<nums.size();i++){\\n           pref[i]=nums[i]+pref[i-1];\\n       } \\n       int max=0;\\n       for(int i=0;i<nums.size();i++){\\n          nums[i]=ceil(pref[i]/((i+1)*1.0));\\n          if(nums[i]>max){\\n              max=nums[i];\\n          }\\n       } \\n       return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n       vector<long long>pref(nums.size());\\n       pref[0]=nums[0];\\n       for(int i=1;i<nums.size();i++){\\n           pref[i]=nums[i]+pref[i-1];\\n       } \\n       int max=0;\\n       for(int i=0;i<nums.size();i++){\\n          nums[i]=ceil(pref[i]/((i+1)*1.0));\\n          if(nums[i]>max){\\n              max=nums[i];\\n          }\\n       } \\n       return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382109,
                "title": "c-o-n-average-value",
                "content": "in any sub array the maximum value reached frim operations will be the average, because the value can\\'t increase on right, if we are on index i , then value can only increase index i+1, \\nif we go to i+2, and it is a very high value, then decrease nums[i+2] will increase previous value, and affecting the previous average\\n\\n```\\nclass Solution {\\npublic:    \\n    int minimizeArrayValue(vector<int>& nums) {     \\n        long sum=0;\\n        long avg=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            avg=max(avg, (sum+i)/(i+1) );         \\n        }\\n        return avg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int minimizeArrayValue(vector<int>& nums) {     \\n        long sum=0;\\n        long avg=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            avg=max(avg, (sum+i)/(i+1) );         \\n        }\\n        return avg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381947,
                "title": "binary-search-on-ans-c",
                "content": "```\\nclass Solution {\\n    bool good(long long x, vector<int> &nums) {\\n        long long n = nums.size(), carry = 0, mx = -1e9;\\n        for(int i=n-1; i>0; i--) {\\n            if(nums[i] + carry >= x) {\\n                carry = nums[i] + carry - x;\\n                mx = max(mx, x);\\n            }\\n            else {\\n                mx = max(mx, nums[i] + carry);\\n                carry = 0;\\n            }\\n        }\\n        mx = max(mx, nums[0] + carry);\\n        return mx <= x;\\n    }\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int s = 0, e = 1e9, ans;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, nums)) e = m - 1, ans = m;\\n            else s = m + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool good(long long x, vector<int> &nums) {\\n        long long n = nums.size(), carry = 0, mx = -1e9;\\n        for(int i=n-1; i>0; i--) {\\n            if(nums[i] + carry >= x) {\\n                carry = nums[i] + carry - x;\\n                mx = max(mx, x);\\n            }\\n            else {\\n                mx = max(mx, nums[i] + carry);\\n                carry = 0;\\n            }\\n        }\\n        mx = max(mx, nums[0] + carry);\\n        return mx <= x;\\n    }\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int s = 0, e = 1e9, ans;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, nums)) e = m - 1, ans = m;\\n            else s = m + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381864,
                "title": "prefix-sum",
                "content": "# Intuition :\\nThe prefix sum is a technique used in array manipulation problems to optimize queries related to the sum of subarrays. It involves precomputing the sum of all elements up to each index of the array and storing the values in a separate array. This allows for constant time lookup of the sum of any subarray by subtracting the prefix sum of the starting index of the subarray from the prefix sum of the ending index.\\n\\nIn the given code, the prefix sum technique is used to calculate the sum of all elements up to the current index in the loop. This sum is then used to calculate the average of all subarrays up to the current index. By keeping track of the maximum average found so far, the minimum value of the array can be minimized.\\n\\nThe approach used in this code is a common one for minimizing the value of an array. The intuition behind this approach is that the minimum value of an array will always be one of the elements of the array. Therefore, we can try to minimize the value by checking all the possible averages of subarrays of the array and selecting the minimum of these averages.\\n\\nTo do this efficiently, we can use the prefix sum technique to calculate the sum of all subarrays up to each index of the array. We can then loop through all possible subarrays, calculate their averages using the prefix sums, and select the minimum of these averages.\\n\\nHowever, this approach would have a time complexity of O(n^2), which is not efficient for large arrays. To optimize this approach, we can observe that the minimum average will always be the average of a subarray that contains at least two consecutive elements of the array. Therefore, we only need to consider subarrays that contain consecutive elements.\\n\\nBy using the prefix sum technique to calculate the sum of all elements up to each index, we can calculate the sum of any consecutive subarray in constant time. This allows us to loop through all possible subarrays that contain consecutive elements and select the minimum of their averages in linear time, resulting in a time complexity of O(n).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach :\\nThe algorithm works as follows:\\n\\n1. Initialize two variables: sum and res to 0. The sum variable will be used to calculate the sum of all elements up to the current element in the loop, and res will hold the minimum average found so far.\\n\\n1. Loop through each element in the array using a for loop.\\n\\n1. In each iteration, add the current element to the sum variable.\\n\\n1. Calculate the average of the sum of all elements up to the current element using the formula (sum + i) / (i + 1). The variable i represents the index of the current element in the loop.\\n\\n1. If the average is greater than the current value of res, update res to the average value.\\n\\n1. After the loop, return the minimized array value, which is the final value of res.\\n\\nNote that the formula used to calculate the ceil of a division, ceil(a/b) = (a+b-1)/b, is used to ensure that the division result is rounded up to the nearest integer, which is necessary for finding the minimum average.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Function to minimize the value of an array.\\n    int minimizeArrayValue(vector<int>& nums) {\\n         // Initialize sum and result variables to 0.\\n         long sum = 0, res = 0;\\n         \\n        // Loop through each element in the array.\\n        for (int i = 0; i < nums.size(); ++i) {\\n            // Add current element to sum.\\n            sum += nums[i];\\n            \\n            // Calculate the average of the sum of all elements up to current element.\\n            // If average is greater than current result, update result to average.\\n            //actually our res would\\'ve been \\n            //res = max(res, (prefixsum(i)) / (i + 1)); \\n            //but we need to find the ceil of the second argument so we used the formula ceil(a/b) = (a+b-1)/b\\n            res = max(res, (sum + i) / (i + 1));\\n        }\\n        // Return the minimized array value.\\n        return res;\\n    }\\n};\\n\\n```\\n\\n---\\n\\n**PLEASE UPVOTE IF YOU LIKED THE SOLUTION :)**\\n\\n![ezgif.com-optimize.gif](https://assets.leetcode.com/users/images/39f0670c-2234-4a3f-bf96-188cfbaf2d9c_1680674597.1030438.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to minimize the value of an array.\\n    int minimizeArrayValue(vector<int>& nums) {\\n         // Initialize sum and result variables to 0.\\n         long sum = 0, res = 0;\\n         \\n        // Loop through each element in the array.\\n        for (int i = 0; i < nums.size(); ++i) {\\n            // Add current element to sum.\\n            sum += nums[i];\\n            \\n            // Calculate the average of the sum of all elements up to current element.\\n            // If average is greater than current result, update result to average.\\n            //actually our res would\\'ve been \\n            //res = max(res, (prefixsum(i)) / (i + 1)); \\n            //but we need to find the ceil of the second argument so we used the formula ceil(a/b) = (a+b-1)/b\\n            res = max(res, (sum + i) / (i + 1));\\n        }\\n        // Return the minimized array value.\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381784,
                "title": "kotlin-using-prefix-sum-and-average",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n   \\n    fun minimizeArrayValue(nums: IntArray): Int {\\n        var sum = 0L\\n        var average = 0\\n        var max = 0\\n        for (i in 0 until nums.size) {\\n            sum = sum + nums[i]\\n            average = Math.ceil(sum.toDouble() / (i + 1)).toInt()\\n            max = Math.max(max, average)\\n        }\\n        return max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n   \\n    fun minimizeArrayValue(nums: IntArray): Int {\\n        var sum = 0L\\n        var average = 0\\n        var max = 0\\n        for (i in 0 until nums.size) {\\n            sum = sum + nums[i]\\n            average = Math.ceil(sum.toDouble() / (i + 1)).toInt()\\n            max = Math.max(max, average)\\n        }\\n        return max\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381732,
                "title": "simple-greedy-solution-o-n-average-o-1",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int n = nums.size();\\n        long ans = 0,sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            // ans = max((int)ceil((double)sum/(i+1)),ans);\\n            ans = max((sum+i)/(i+1),ans);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n# upvote if it\\'s help you HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int n = nums.size();\\n        long ans = 0,sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            // ans = max((int)ceil((double)sum/(i+1)),ans);\\n            ans = max((sum+i)/(i+1),ans);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381719,
                "title": "python3-easiest-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        ans, t = nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            t += nums[i]\\n            ans = max(ans, math.ceil(t/(i+1)))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        ans, t = nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            t += nums[i]\\n            ans = max(ans, math.ceil(t/(i+1)))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381714,
                "title": "sum-and-average-easiest-c-approach-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCan Perform operations upto the average.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGetting Average of Subarray starting with first Index and storing its value to the answer.\\n\\nfor example:\\n\\nif we have 2 numbers in our vector. i.e. {4,12} Its average is 8.\\n\\nAccording to question. \\n\\n{4,12} -> {5,11} -> {6,10} -> {7,9} -> {8,8}. We can\\'t proceed futher.\\nSo, 8 would be the answer.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n\\n        long long minVal = nums[0];\\n        long long total = nums[0];\\n        \\n        for(int i=1;i<nums.size();i++){\\n            total += nums[i];\\n            if(nums[i] > minVal){\\n                int temp = total/(i+1);\\n                if(temp >= minVal){\\n                    if(total%(i+1)){\\n                        minVal = temp+1;\\n                    }else{\\n                        minVal = temp;\\n                    }\\n                }\\n            }\\n        }\\n        return minVal;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n\\n        long long minVal = nums[0];\\n        long long total = nums[0];\\n        \\n        for(int i=1;i<nums.size();i++){\\n            total += nums[i];\\n            if(nums[i] > minVal){\\n                int temp = total/(i+1);\\n                if(temp >= minVal){\\n                    if(total%(i+1)){\\n                        minVal = temp+1;\\n                    }else{\\n                        minVal = temp;\\n                    }\\n                }\\n            }\\n        }\\n        return minVal;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381603,
                "title": "c-binary-search-solution",
                "content": "# Approach\\nWith binary search, we find the minimum value $$mid$$ such that the sum of current elements is less than equal to number of elements * mid\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check(long long mid, vector<int>& nums){\\n        long long sum = 0;\\n        for(int i = 0, n = nums.size(); i < n; i++){\\n            sum += nums[i];\\n            if(sum > mid*(i + 1)) return false;\\n        }\\n        return true;\\n    }\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int left = 0, right = 1e9, ans = 0;\\n        while(left <= right){\\n            long long mid = (left + right)/2;\\n            if(check(mid, nums)) right = mid - 1, ans = mid;\\n            else left = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool check(long long mid, vector<int>& nums){\\n        long long sum = 0;\\n        for(int i = 0, n = nums.size(); i < n; i++){\\n            sum += nums[i];\\n            if(sum > mid*(i + 1)) return false;\\n        }\\n        return true;\\n    }\\n\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int left = 0, right = 1e9, ans = 0;\\n        while(left <= right){\\n            long long mid = (left + right)/2;\\n            if(check(mid, nums)) right = mid - 1, ans = mid;\\n            else left = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381592,
                "title": "c-simplest-o-n-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        unsigned long long int maxN = nums[0], sum = nums[0];\\n        for(int i = 1; i < nums.size(); i++)\\n            sum += nums[i], maxN = max(maxN,sum / (i + 1) + (sum % (i + 1) > 0));\\n        return maxN;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {\\n        unsigned long long int maxN = nums[0], sum = nums[0];\\n        for(int i = 1; i < nums.size(); i++)\\n            sum += nums[i], maxN = max(maxN,sum / (i + 1) + (sum % (i + 1) > 0));\\n        return maxN;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381568,
                "title": "simple-and-easy-to-understand-c-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {  \\n        int n = nums.size();\\n        int ans = nums[0];\\n        long sum = nums[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            sum += nums[i];\\n            int maxi = ceil(sum / double(i + 1));\\n            ans = max(ans, maxi);  \\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeArrayValue(vector<int>& nums) {  \\n        int n = nums.size();\\n        int ans = nums[0];\\n        long sum = nums[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            sum += nums[i];\\n            int maxi = ceil(sum / double(i + 1));\\n            ans = max(ans, maxi);  \\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381391,
                "title": "rust-binary-search-solution",
                "content": "\\n```\\nimpl Solution {\\n    pub fn minimize_array_value(nums: Vec<i32>) -> i32 {\\n        let (mut l, mut r) = (0, *nums.iter().max().unwrap());\\n\\n        while l < r {\\n            let mid = l + (r - l) / 2;\\n\\n            if Self::is_valid(&nums, mid) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n\\n        l\\n    }\\n\\n    fn is_valid(nums: &Vec<i32>, value: i32) -> bool {\\n        let mut sum: i64 = 0;\\n\\n        for &num in nums {\\n            if num <= value {\\n                sum += (value - num) as i64;\\n            } else {\\n                let diff = (num - value) as i64;\\n\\n                if sum < diff {\\n                    return false;\\n                }\\n\\n                sum -= diff;\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimize_array_value(nums: Vec<i32>) -> i32 {\\n        let (mut l, mut r) = (0, *nums.iter().max().unwrap());\\n\\n        while l < r {\\n            let mid = l + (r - l) / 2;\\n\\n            if Self::is_valid(&nums, mid) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n\\n        l\\n    }\\n\\n    fn is_valid(nums: &Vec<i32>, value: i32) -> bool {\\n        let mut sum: i64 = 0;\\n\\n        for &num in nums {\\n            if num <= value {\\n                sum += (value - num) as i64;\\n            } else {\\n                let diff = (num - value) as i64;\\n\\n                if sum < diff {\\n                    return false;\\n                }\\n\\n                sum -= diff;\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3381278,
                "title": "java-easy-solution-100-faster-code-one-liner-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0, max = 0;\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tmax = Math.max(max, ((sum += nums[i]) + i) / (i + 1));\\n\\t\\t}\\n\\t\\treturn (int) max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0, max = 0;\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tmax = Math.max(max, ((sum += nums[i]) + i) / (i + 1));\\n\\t\\t}\\n\\t\\treturn (int) max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381271,
                "title": "java-runtime-9-ms-beats-74-55-memory-61-4-mb-beats-84-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0;\\n        long result = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            sum += nums[i];\\n            result = Math.max(result, (sum + i) / (i + 1));\\n        }\\n        return (int) result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0;\\n        long result = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            sum += nums[i];\\n            result = Math.max(result, (sum + i) / (i + 1));\\n        }\\n        return (int) result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381239,
                "title": "",
                "content": "\\n\\n\\n# Approach\\n**Given you an array, the following operations can be performed for i with 1 <= i < len(nums)\\nPut nums[i]--, nums[i-1]++ nums[i] > 0\\nFor this condition, we should get the following understanding:\\nThe smaller number in the front can accept the excess number of the larger number in the back Maybe this sentence is a bit obscure.\\nWe can generalize from the local to the whole. We only need to check whether the array can be all not greater than k on the basis of the small number carrying the large number.\\nSo where does the number to check come from? Instant answer: \"Binary search\"\\nSince 0 <= a[i] <= 1e9 in the array, we cannot check all the numbers one by one. Binary search can help us quickly locate the answer**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool check(vector<int> &nums, int k) {\\n        long long have=0;\\n        for (int n: nums)\\n        {\\n            if (n<=k)\\n            {\\n                have += k-n;\\n            }\\n            else\\n            {\\n                if (have < n-k)\\n                    return 0; \\n                else\\n                    have -= (n-k);\\n            }\\n        }\\n        return 1;\\n    }\\n\\n    int minimizeArrayValue(vector<int> &nums) {\\n        int left=0, right = *max_element(nums.begin(), nums.end());\\n        while (left<right)\\n        { \\n            int mid = left+(right-left)/2;\\n            if (check(nums, mid))\\n                right=mid;\\n            else\\n                left= mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool check(vector<int> &nums, int k) {\\n        long long have=0;\\n        for (int n: nums)\\n        {\\n            if (n<=k)\\n            {\\n                have += k-n;\\n            }\\n            else\\n            {\\n                if (have < n-k)\\n                    return 0; \\n                else\\n                    have -= (n-k);\\n            }\\n        }\\n        return 1;\\n    }\\n\\n    int minimizeArrayValue(vector<int> &nums) {\\n        int left=0, right = *max_element(nums.begin(), nums.end());\\n        while (left<right)\\n        { \\n            int mid = left+(right-left)/2;\\n            if (check(nums, mid))\\n                right=mid;\\n            else\\n                left= mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326165,
                "title": "binary-search-easy-c-solution",
                "content": "\\n# Intution\\n<!--  It is optimal to perform all the operations from right to left.\\n-->\\n# Approach\\n<!-- Lets do binary search on the maximum element of the array \\'nums\\' we can get. We will try to make all the elements of the array <= \\'mid\\'. Start from the last index and if it is greater than \\'mid\\', make it equal to \\'mid\\' and add the extra difference to the previous element. At last, just check that the first element is <= \\'mid\\' or not. > -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isValid(vector<int> &nums, long long int k) {\\n        vector<long long int>numss;\\n        for(auto it: nums) {\\n            numss.push_back(it);\\n        }\\n        for (int i = numss.size()-1; i>0; i--) {\\n            if(numss[i] > k) {\\n                numss[i-1] += numss[i] - k;\\n            }\\n        }\\n        if(numss[0] > k) return false;\\n        return true;\\n    }\\n\\n    int minimizeArrayValue(vector<int> &nums) {\\n        long long int left = -1;\\n        long long int right = *max_element(nums.begin(), nums.end()) + 1;\\n        while (left + 1 < right) {\\n            long long int mid = (right + left) / 2;\\n           \\n            if(isValid(nums, mid)){\\n               right = mid; \\n            }\\n            else left = mid;\\n        }\\n        return right;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isValid(vector<int> &nums, long long int k) {\\n        vector<long long int>numss;\\n        for(auto it: nums) {\\n            numss.push_back(it);\\n        }\\n        for (int i = numss.size()-1; i>0; i--) {\\n            if(numss[i] > k) {\\n                numss[i-1] += numss[i] - k;\\n            }\\n        }\\n        if(numss[0] > k) return false;\\n        return true;\\n    }\\n\\n    int minimizeArrayValue(vector<int> &nums) {\\n        long long int left = -1;\\n        long long int right = *max_element(nums.begin(), nums.end()) + 1;\\n        while (left + 1 < right) {\\n            long long int mid = (right + left) / 2;\\n           \\n            if(isValid(nums, mid)){\\n               right = mid; \\n            }\\n            else left = mid;\\n        }\\n        return right;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317342,
                "title": "python-1-line-beats-97",
                "content": "\\n```\\ndef minimizeArrayValue(self, A: List[int]) -> int:\\n    return max((prefixsum+i)//(i+1) for i, prefixsum in enumerate(accumulate(A)))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minimizeArrayValue(self, A: List[int]) -> int:\\n    return max((prefixsum+i)//(i+1) for i, prefixsum in enumerate(accumulate(A)))\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3173545,
                "title": "simple-explained-solution",
                "content": "\\n```\\nclass Solution {\\n        public int minimizeArrayValue(int[] A) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < A.length; ++i) {\\n            sum += A[i];\\n            res = Math.max(res, (sum + i) / (i + 1));\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ruby",
                    "Swift",
                    "Go",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n        public int minimizeArrayValue(int[] A) {\\n        long sum = 0, res = 0;\\n        for (int i = 0; i < A.length; ++i) {\\n            sum += A[i];\\n            res = Math.max(res, (sum + i) / (i + 1));\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987572,
                "title": "simple-solution-easy-to-understand",
                "content": "# Intution\\nwe can only transfer the load from right to left and if previous sharing load is 5 and now current  avg is 3 \\nso that means the current number is less and they transfering it to right which cant happen .\\n\\nso the  max(max,avg) is the min maximum load that they have to suffer.\\n\\n\\n\\neg 3,7,1,6\\n\\n\\ni=0 , sum = 3  maxLoad we need to bear is 3.\\ni=1 , sum = 10 now 2 person need to bear total of 10 unit load \\n\\nso they distribute avg = totalLoad/no of person\\n\\navg = 3+7/2 = 5  \\nno they the minimum load each have to bear is 5; 5 5 \\n\\ni=2 sum=11 totalPerson = 3\\navg = 11/3 = 3.666 if we take floor(3.666) = 3 then \\n\\n3 person*3 = 9 load which is wrong \\n\\nso we take ceil of it  avg = 3.666 ceil(3.66) = 4;\\n\\nnow lets try to distribute 4 4 3\\n\\nprevious max load  = 5 now avg is 4 \\nthat means current number is less that maxLoad=5 and that why it \\nresulted in to drop the avg that means\\n\\ninitally the load was like that 5 5 \\nnow  its like that 4 4 3 that means we transfered the load to right side which can not happen according to conditions of give question\\n\\nthat meaning load sharing will be like 5 5 1  min max Load = 5\\n\\ni=3 sum = 17 avg = ceil(17/4) = 5\\n\\nand yes it is equal to previous min max Load so \\ndistribution will be like 5 5 1 6 becomes = 5 5 2 5 shared 1 unit load to left.\\n\\n\\n\\nanother eg . 7 3 1 6\\n\\ni=0 sum = 7 avg = 7  minMaxLoad = 7;\\ni=1 sum 3 avg = ceil(7+3)/2 = 5 \\n\\navg is less than minmaxLoad that means we transfered it to left to right like 7 3 => 5 5 which can not happen  so minMaxLoad = 7\\n\\ni=2 sum = 11 avg = 4\\navg < minMaxLoad\\n\\nintially 7 3 1\\nnow  4 4 3 that mean we transfered it to left can not happend \\nminMaxLoad remain same = 7;\\n\\ni=3 sum = 17 avg = ceil(17/4) = 5 \\n\\nnow avg < minMaxLoad that mean load transfered from left to right like that 5 5 5 2 cant not happen \\nminMaxLoad = 7 remains the same.\\n\\n\\nwhy we cant transfer load to left to right\\n\\nat some i if we apply given conditions \\n\\nnums[i] will be decreased and nums[i-1] will increase so it only transfer load to right to left. \\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = nums[0];\\n        long res = nums[0];\\n\\n        for(int i=1;i<nums.length;i++){\\n            sum+=nums[i];\\n            long avg = (sum+i)/(i+1);\\n            if(avg>res)\\n                res = avg;\\n        }\\n\\n        return (int)res;\\n\\n    }\\n       \\n\\n    \\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = nums[0];\\n        long res = nums[0];\\n\\n        for(int i=1;i<nums.length;i++){\\n            sum+=nums[i];\\n            long avg = (sum+i)/(i+1);\\n            if(avg>res)\\n                res = avg;\\n        }\\n\\n        return (int)res;\\n\\n    }\\n       \\n\\n    \\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825387,
                "title": "intuitive-approach-stack-prefix-sum-python",
                "content": "Before we get started, Check this Testcase \\n`nums = [5, 5, 4, 3, 2, 2, 1]`\\n\\nIf you notice, `while nums[i]\\u2265nums[i+1]`, we **cannot** pass the values because the condition says - \\n```\\n------------------------------------------------------------------------------\\n```\\n\\n*In one operation, you must:*\\n\\n* *Choose an integer i such that 1 <= i < n and nums[i] > 0.*\\n* *Decrease nums[i] by 1.*\\n* *Increase nums[i - 1] by 1.*\\n```\\n------------------------------------------------------------------------------\\n```\\n\\n\\n#### So, let\\'s see the intuition. \\nIf the **current average (or ceil value) is greater than previous averages**, then we can pass on values from current to next. Stack can do this. Here\\'s the code. \\n\\n```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        stack = []\\n        \\n        for i in range(n):\\n            curr = nums[i]          #This is current sum\\n            l = 1                   #This is current length of values\\n            val = curr/l            #This shows current Average value\\n            \\n            #If the current Average value is greater than previous one, \\n            #then we\\'re sure than it can be transferred\\n            while stack and (stack[-1][2])<val:     \\n                x, y, z = stack.pop()\\n                curr += x           #Adding the previous prefix sum to current sum\\n                l += y              #Adding possible values\\n                val = curr/l        #New Average value\\n            \\n            stack.append([curr, l, val])    #Simply append it in stack\\n        \\n        #By the end, we\\'ll have the stack with possible values of Averages\\n        return max(ceil(z) for x,y,z in stack)\\n```\\n\\nTime - O(n)\\nSpace - O(m) [where 1\\u2264m\\u2264n, m = stack length]\\n**With this intuitive approach you can also find that there exist `real solution(array)` using stack (Check last line)**\\n**I hope you\\'ve got the idea, if not check the Dry Run Below**\\n```\\n------------------------------------------------------------------------------\\n```\\n**Initially**\\n```\\nnums = [4,7,2,2,9,19,16,0,3,15]\\nstack = []\\n```\\n**For index 0:**\\n```\\ncurr = 4, l = 1, val = 4.0 (curr/l)\\nstack = [[4,1,4.0]]\\n```\\n\\n**For index 1:**\\n```\\ncurr = 7, l = 1, val = 7.0 \\nbecause 7.0 > 4.0 (stack[-1][2]), popped\\ncurr = 11, l = 2, val = 5.5 \\nstack = [[11, 2, 5.5]]\\n```\\n\\n**For index 2:**\\n```\\ncurr = 2, l = 1, val = 2.0 \\nbecause 2.0 < 5.5 (stack[-1][2]), pushed\\nstack = [[11, 2, 5.5], [2, 1, 2.0]]\\n```\\n**For index 3:**\\n```\\ncurr = 2, l = 1, val = 2.0 \\nbecause 2.0 == 2.0 (stack[-1][2]), push\\nstack = [[11, 2, 5.5], [2, 1, 2.0],[2, 1, 2.0]]\\n```\\n**For index 4:**\\n```\\ncurr = 9, l = 1, val = 9.0 \\n\\nbecause 9.0 > 2.0 (stack[-1][2]), popped\\ncurr = 11, l = 2, val = 5.5\\nstack = [[11, 2, 5.5], [2, 1, 2.0]]\\n\\nbecause 5.5 > 2.0 (stack[-1][2]), popped\\ncurr = 13, l = 3, val = 4.33\\nstack = [[11, 2, 5.5]]\\n\\nbecause 4.33 < 5.5 (stack[-1][2]), push\\nstack = [[11, 2, 5.5], [13, 3, 4.33]]\\n```\\n\\n**For index 5:**\\n```\\ncurr = 19, l = 1, val = 19.0 \\n\\nbecause 19.0 > 4.33 (stack[-1][2]), popped\\ncurr = 32, l = 4, val = 8.0\\nstack = [[11, 2, 5.5]]\\n\\nbecause 8.0 > 5.5 (stack[-1][2]), popped\\ncurr = 43, l = 6, val = 7.16\\nstack = []\\n\\nbecause empty, push\\nstack = [[43, 6, 7.16]\\n```\\n\\n**For index 6:**\\n```\\ncurr = 16, l = 1, val = 16.0 \\n\\nbecause 16.0 > 7.16 (stack[-1][2]), popped\\ncurr = 59, l = 7, val = 8.42\\nstack = []\\n\\nbecause empty, push\\nstack = [[59, 7, 8.42]]\\n```\\n\\n**For index 7:**\\n```\\ncurr = 0, l = 1, val = 0.0 \\n\\nbecause 0.0 < 8.42 (stack[-1][2]), push\\nstack = [[59, 7, 8.42], [0,1,0.0]]\\n```\\n\\n**For index 8:**\\n```\\ncurr = 3, l = 1, val = 3.0 \\n\\nbecause 3.0 > 0.0 (stack[-1][2]), popped\\ncurr = 3, l = 2, val = 1.5\\nstack = [[59, 7, 8.42]]\\n\\nbecause 1.5 < 8.42 (stack[-1][2]), push\\nstack = [[59, 7, 8.42], [3,3,1.5]]\\n```\\n\\n**For index 9:**\\n```\\ncurr = 15, l = 1, val = 15.0 \\n\\nbecause 15.0 > 1.5 (stack[-1][2]), popped\\ncurr = 18, l = 3, val = 6.0\\nstack = [[59, 7, 8.42]]\\n\\nbecause 6.0 < 8.42 (stack[-1][2]), push\\nstack = [[59, 7, 8.42], [18, 3, 6.0]]\\n```\\n\\n`-----------------------------------------------------------------`\\n\\n```\\nFinal stack = [[59, 7, 8.42], [18, 3, 6.0]]\\nans = max(ceil(8.42), ceil(6.0)) = max(9, 6) = 9\\nCorrect answer = 9\\n```\\n\\n**Notice :** stack represents the final solution (if you can modify it little)\\n`stack solution array = [[8,8,8,8,9,9,9], [6,6,6]] = [8,8,8,8,9,9,9,6,6,6]`\\n\\n\\nPlease **Upvote** you are understood or like it \\uD83D\\uDE04 \\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\n------------------------------------------------------------------------------\\n```\n```\\n------------------------------------------------------------------------------\\n```\n```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        stack = []\\n        \\n        for i in range(n):\\n            curr = nums[i]          #This is current sum\\n            l = 1                   #This is current length of values\\n            val = curr/l            #This shows current Average value\\n            \\n            #If the current Average value is greater than previous one, \\n            #then we\\'re sure than it can be transferred\\n            while stack and (stack[-1][2])<val:     \\n                x, y, z = stack.pop()\\n                curr += x           #Adding the previous prefix sum to current sum\\n                l += y              #Adding possible values\\n                val = curr/l        #New Average value\\n            \\n            stack.append([curr, l, val])    #Simply append it in stack\\n        \\n        #By the end, we\\'ll have the stack with possible values of Averages\\n        return max(ceil(z) for x,y,z in stack)\\n```\n```\\n------------------------------------------------------------------------------\\n```\n```\\nnums = [4,7,2,2,9,19,16,0,3,15]\\nstack = []\\n```\n```\\ncurr = 4, l = 1, val = 4.0 (curr/l)\\nstack = [[4,1,4.0]]\\n```\n```\\ncurr = 7, l = 1, val = 7.0 \\nbecause 7.0 > 4.0 (stack[-1][2]), popped\\ncurr = 11, l = 2, val = 5.5 \\nstack = [[11, 2, 5.5]]\\n```\n```\\ncurr = 2, l = 1, val = 2.0 \\nbecause 2.0 < 5.5 (stack[-1][2]), pushed\\nstack = [[11, 2, 5.5], [2, 1, 2.0]]\\n```\n```\\ncurr = 2, l = 1, val = 2.0 \\nbecause 2.0 == 2.0 (stack[-1][2]), push\\nstack = [[11, 2, 5.5], [2, 1, 2.0],[2, 1, 2.0]]\\n```\n```\\ncurr = 9, l = 1, val = 9.0 \\n\\nbecause 9.0 > 2.0 (stack[-1][2]), popped\\ncurr = 11, l = 2, val = 5.5\\nstack = [[11, 2, 5.5], [2, 1, 2.0]]\\n\\nbecause 5.5 > 2.0 (stack[-1][2]), popped\\ncurr = 13, l = 3, val = 4.33\\nstack = [[11, 2, 5.5]]\\n\\nbecause 4.33 < 5.5 (stack[-1][2]), push\\nstack = [[11, 2, 5.5], [13, 3, 4.33]]\\n```\n```\\ncurr = 19, l = 1, val = 19.0 \\n\\nbecause 19.0 > 4.33 (stack[-1][2]), popped\\ncurr = 32, l = 4, val = 8.0\\nstack = [[11, 2, 5.5]]\\n\\nbecause 8.0 > 5.5 (stack[-1][2]), popped\\ncurr = 43, l = 6, val = 7.16\\nstack = []\\n\\nbecause empty, push\\nstack = [[43, 6, 7.16]\\n```\n```\\ncurr = 16, l = 1, val = 16.0 \\n\\nbecause 16.0 > 7.16 (stack[-1][2]), popped\\ncurr = 59, l = 7, val = 8.42\\nstack = []\\n\\nbecause empty, push\\nstack = [[59, 7, 8.42]]\\n```\n```\\ncurr = 0, l = 1, val = 0.0 \\n\\nbecause 0.0 < 8.42 (stack[-1][2]), push\\nstack = [[59, 7, 8.42], [0,1,0.0]]\\n```\n```\\ncurr = 3, l = 1, val = 3.0 \\n\\nbecause 3.0 > 0.0 (stack[-1][2]), popped\\ncurr = 3, l = 2, val = 1.5\\nstack = [[59, 7, 8.42]]\\n\\nbecause 1.5 < 8.42 (stack[-1][2]), push\\nstack = [[59, 7, 8.42], [3,3,1.5]]\\n```\n```\\ncurr = 15, l = 1, val = 15.0 \\n\\nbecause 15.0 > 1.5 (stack[-1][2]), popped\\ncurr = 18, l = 3, val = 6.0\\nstack = [[59, 7, 8.42]]\\n\\nbecause 6.0 < 8.42 (stack[-1][2]), push\\nstack = [[59, 7, 8.42], [18, 3, 6.0]]\\n```\n```\\nFinal stack = [[59, 7, 8.42], [18, 3, 6.0]]\\nans = max(ceil(8.42), ceil(6.0)) = max(9, 6) = 9\\nCorrect answer = 9\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755575,
                "title": "binary-search-java-solution",
                "content": "```java\\nclass Solution {\\n    boolean isPos(int nums[],long target){\\n        long arr[] = new long[nums.length];\\n        for(int i = 0;i < nums.length;i++) arr[i] = (long)nums[i];\\n        for(int i = 0;i < arr.length - 1;i++){\\n            if(arr[i] > target) return false;\\n            arr[i + 1] -= (target - arr[i]);\\n        }\\n        return arr[arr.length - 1] <= target;\\n    }\\n    public int minimizeArrayValue(int[] nums) {\\n        long l = 0,h = (long)1e9;\\n        long ans = l;\\n        for(;l <= h;){\\n            long mid = (l + h) >> 1;\\n            if(isPos(nums,mid)){\\n                h = mid - 1;\\n                ans = mid;\\n            }\\n            else l = mid + 1;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n    boolean isPos(int nums[],long target){\\n        long arr[] = new long[nums.length];\\n        for(int i = 0;i < nums.length;i++) arr[i] = (long)nums[i];\\n        for(int i = 0;i < arr.length - 1;i++){\\n            if(arr[i] > target) return false;\\n            arr[i + 1] -= (target - arr[i]);\\n        }\\n        return arr[arr.length - 1] <= target;\\n    }\\n    public int minimizeArrayValue(int[] nums) {\\n        long l = 0,h = (long)1e9;\\n        long ans = l;\\n        for(;l <= h;){\\n            long mid = (l + h) >> 1;\\n            if(isPos(nums,mid)){\\n                h = mid - 1;\\n                ans = mid;\\n            }\\n            else l = mid + 1;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722667,
                "title": "javascript-binary-seach",
                "content": "Athough there are shorter solution, I found it this one the easiest to explain and possibly modify for variations of that question,\\nalso it was the way LarryNY used during contest.\\n\\nLarry\\'s explaination:\\nhttps://www.youtube.com/watch?v=agIUXJoG9tY\\n\\nIn short:  \\nWe do binary search on constrains,\\nif we write binary search in the way we have below, \\nleft will be equal to smallest num which doesnt have carry over \\n```\\nvar minimizeArrayValue = function(nums) {\\n  nums.reverse()\\n  let left = 0\\n  let right = 10**9\\n  \\n  while(left < right) {\\n      const mid = Math.floor(left + (right-left)/2)\\n      \\n      if(condition(mid)) {\\n          right = mid\\n      } else {\\n          left = mid + 1\\n      }\\n  }\\n    \\n    function condition(target) {\\n        let carry = 0\\n        \\n        for(const num of nums) {\\n            const currNum = num+carry\\n            \\n            carry =0\\n            \\n            if(currNum >= target) {\\n                carry = currNum - target\\n            }\\n        }\\n        \\n        return carry === 0\\n    }\\n    \\n    return left\\n};\\n```\\n\\n\\nyou also don\\'t need to reverse like Larry did, but the you need to loop from the end\\n\\n```\\nvar minimizeArrayValue = function(nums) {\\n  let left = 0  \\n  let right = 10**9\\n  \\n  while(left < right) {\\n      const mid = Math.floor(left + (right-left)/2)\\n      \\n     if(condition(mid)) {\\n         right = mid\\n     } else {\\n         left = mid + 1\\n     }\\n  }\\n    \\n    \\n  function condition(mid) {\\n     let carry = 0\\n     \\n     for(let i = nums.length - 1; i >= 0; i--) {\\n         const curr = nums[i] + carry\\n         carry = 0   \\n         \\n         if(curr > mid) {\\n             carry = curr - mid\\n         } \\n     }\\n      \\n     return carry === 0\\n  }\\n    \\n  return left\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar minimizeArrayValue = function(nums) {\\n  nums.reverse()\\n  let left = 0\\n  let right = 10**9\\n  \\n  while(left < right) {\\n      const mid = Math.floor(left + (right-left)/2)\\n      \\n      if(condition(mid)) {\\n          right = mid\\n      } else {\\n          left = mid + 1\\n      }\\n  }\\n    \\n    function condition(target) {\\n        let carry = 0\\n        \\n        for(const num of nums) {\\n            const currNum = num+carry\\n            \\n            carry =0\\n            \\n            if(currNum >= target) {\\n                carry = currNum - target\\n            }\\n        }\\n        \\n        return carry === 0\\n    }\\n    \\n    return left\\n};\\n```\n```\\nvar minimizeArrayValue = function(nums) {\\n  let left = 0  \\n  let right = 10**9\\n  \\n  while(left < right) {\\n      const mid = Math.floor(left + (right-left)/2)\\n      \\n     if(condition(mid)) {\\n         right = mid\\n     } else {\\n         left = mid + 1\\n     }\\n  }\\n    \\n    \\n  function condition(mid) {\\n     let carry = 0\\n     \\n     for(let i = nums.length - 1; i >= 0; i--) {\\n         const curr = nums[i] + carry\\n         carry = 0   \\n         \\n         if(curr > mid) {\\n             carry = curr - mid\\n         } \\n     }\\n      \\n     return carry === 0\\n  }\\n    \\n  return left\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2719779,
                "title": "ruby-one-liner-beats-100-100",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef minimize_array_value(nums)\\n  Range.new(*nums.minmax).bsearch { |l| nums.reverse.reduce(0) { [_1 + _2 - l, 0].max } == 0 }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef minimize_array_value(nums)\\n  Range.new(*nums.minmax).bsearch { |l| nums.reverse.reduce(0) { [_1 + _2 - l, 0].max } == 0 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2711841,
                "title": "python-binary-search",
                "content": "```class Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        def isValid(candidate):\\n            extra = 0\\n            for num in nums:\\n                diff = abs(candidate - num)\\n                if num <= candidate:\\n                    extra += diff\\n                else:\\n                    extra -= diff\\n                    if extra < 0:\\n                        return False\\n            return True\\n            \\n        \\n        l = min(nums)\\n        r = max(nums)\\n        \\n        while l < r:\\n            mid = (l + r) // 2\\n            if isValid(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```class Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        def isValid(candidate):\\n            extra = 0\\n            for num in nums:\\n                diff = abs(candidate - num)\\n                if num <= candidate:\\n                    extra += diff\\n                else:\\n                    extra -= diff\\n                    if extra < 0:\\n                        return False\\n            return True\\n            \\n        \\n        l = min(nums)\\n        r = max(nums)\\n        \\n        while l < r:\\n            mid = (l + r) // 2\\n            if isValid(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l",
                "codeTag": "Java"
            },
            {
                "id": 2708695,
                "title": "python3-minecraft",
                "content": "Imagine the array as blocks of dirt that needs to be distributed as evenly as possible but you can only move blocks to the left. The idea is that you have a hole that needs to be filled before you can raise the max height. If the current bar\\'s height is greater than the current max, then you have current_height - current_max number of blocks to distribute. \\n\\nIf the current column has more blocks than maxx and the extra blocks = (current_column - current_max) is greater than what\\'s needed to fill the current hole, then what\\'s left over after filling this hole must be distributed evenly between the columns from column 0 to the current column (and it needs to be packed as far left as possible). The new hole after this is (num_columns - extra_blocks % num_columns). \\n\\nIf the current column\\'s blocks are greater than current maximum and there are less boxes than the current hole, you can throw all the extra blocks (current_height - current_maximum) into the hole and the hole will be reduced by new_hole = old_hole - (current_column - current_max.\\n\\nIf the current column\\'s number of dirt blocks is less than current_max then you have more space in the hole (to be used to throw blocks into) by an amount (current_max - current_height).\\n\\nTime: O(n)\\nSpace: O(1)\\n```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        \\n        maxx = nums[0]\\n        hole = 0\\n        for i, x in enumerate(nums[1:], 1):\\n            if x - maxx > hole:\\n                extra_blocks = x - maxx - hole  # extra blocks after filling hole\\n                cols = i + 1\\n                if extra_blocks % cols == 0:\\n                    maxx = maxx + extra_blocks // cols\\n                    hole = 0\\n                else:\\n                    maxx = maxx + extra_blocks // cols + 1\\n                    hole = cols - extra_blocks % cols\\n            else:\\n                hole = hole + (maxx - x)\\n                \\n        return maxx\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeArrayValue(self, nums: List[int]) -> int:\\n        \\n        maxx = nums[0]\\n        hole = 0\\n        for i, x in enumerate(nums[1:], 1):\\n            if x - maxx > hole:\\n                extra_blocks = x - maxx - hole  # extra blocks after filling hole\\n                cols = i + 1\\n                if extra_blocks % cols == 0:\\n                    maxx = maxx + extra_blocks // cols\\n                    hole = 0\\n                else:\\n                    maxx = maxx + extra_blocks // cols + 1\\n                    hole = cols - extra_blocks % cols\\n            else:\\n                hole = hole + (maxx - x)\\n                \\n        return maxx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707853,
                "title": "java-80-faster-solution",
                "content": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0, max = 0;\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tmax = Math.max(max, ((sum += nums[i]) + i) / (i + 1));\\n\\t\\t}\\n\\t\\treturn (int) max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0, max = 0;\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tmax = Math.max(max, ((sum += nums[i]) + i) / (i + 1));\\n\\t\\t}\\n\\t\\treturn (int) max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707635,
                "title": "c-direct-computation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMin maximum of k first items is an average of these k items\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe compute min max for first 1, 2, ..., k, k + 1, ... n items and \\nreturn the max of these numbers  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizeArrayValue(int[] nums) {\\n        int result = nums[0];\\n        long total = nums[0];  \\n\\n        for (int i = 1; i < nums.Length; ++i) {\\n            total += nums[i];\\n\\n            int v = (int) ((total / (i + 1)) + Math.Clamp(total % (i + 1), 0, 1));\\n\\n            result = Math.Max(result, v);\\n        }    \\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizeArrayValue(int[] nums) {\\n        int result = nums[0];\\n        long total = nums[0];  \\n\\n        for (int i = 1; i < nums.Length; ++i) {\\n            total += nums[i];\\n\\n            int v = (int) ((total / (i + 1)) + Math.Clamp(total % (i + 1), 0, 1));\\n\\n            result = Math.Max(result, v);\\n        }    \\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707116,
                "title": "easy-to-understand-binary-search-check-c-efficient-clean-code",
                "content": "***Just do a binary search and check if it satisfies the limits by traversing the array and see if it is possible to keep the max in the limit, if true decrease the limit else increase the limit***\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&nums,int maxi){\\n        int n=nums.size();\\n        \\n        if(nums[0]>maxi){\\n            return false;\\n        }\\n        \\n        long long int extra=maxi-nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            if(nums[i]>maxi){\\n                int k=nums[i]-maxi;\\n                \\n                if(k>extra){\\n                    return false;\\n                }\\n                \\n                extra-=(nums[i]-maxi);\\n                \\n            }else{\\n                extra+=(maxi-nums[i]);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    int minimizeArrayValue(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int l=0;\\n        int r=1e9;\\n        \\n        int ans=INT_MIN;\\n        \\n        while(r>=l){\\n            int mid=(l+r)/2;\\n            \\n            if(check(nums,mid)){\\n                r=mid-1;\\n                ans=mid;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool check(vector<int>&nums,int maxi){\\n        int n=nums.size();\\n        \\n        if(nums[0]>maxi){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2706873,
                "title": "easy-java-solution",
                "content": "\\n8ms runtime\\n*post queries if got any*\\n**In one operation:**\\ndecrease A[i] by 1.\\nincrease A[i - 1] by 1.\\n\\nWe actully move the value of A[i] to A[i - 1] by 1,\\nthe sum won\\'t change.\\n\\nIf A[i] < A[i + 1],\\nthen we can repeatly do the operations,\\nuntil A[i] >= A[i+1].\\nSo finally the array A will become decrescent order.\\n\\n\\n**Explanation**\\nWe calculate the prefix sum arrray and their average.\\nThe average is the lower bound of the result,\\nand it\\'s reachable lower bound by the process in intuition,\\nso this average is the result.\\n\\n\\n**Complexity**\\nTime O(n)\\nSpace O(1)\\n\\n\\n\\n```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0;\\n        int result  = 0;\\n        int min;\\n        long sum2;\\n        \\n        for (int i = 0; i < nums.length; ++i){\\n            sum += nums[i];\\n            \\n            if (result >= nums[i]) continue;\\n            \\n            min = (int)( (sum + i) / (i + 1));\\n            result = Math.max(min, result);\\n        }\\n        \\n        return result;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        long sum = 0;\\n        int result  = 0;\\n        int min;\\n        long sum2;\\n        \\n        for (int i = 0; i < nums.length; ++i){\\n            sum += nums[i];\\n            \\n            if (result >= nums[i]) continue;\\n            \\n            min = (int)( (sum + i) / (i + 1));\\n            result = Math.max(min, result);\\n        }\\n        \\n        return result;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1854113,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1854127,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1854179,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1711721,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1854491,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1854388,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1854199,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1854497,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1855039,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1854107,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1854113,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1854127,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1854179,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1711721,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1854491,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1854388,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1854199,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1854497,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1855039,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1854107,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Those who didn\\'t understand this question\\nWe need the minimum value in the array that will be the largest. It means \\nFor ex.  We have this array [3,7,1,6] , here max. value is 7 but can we obtain a value less than 7 by performing the operations mentioned in the question. So we perform the op.\\n[3, 7, 1, 6] -> [4, 6, 1, 6] now max. value is 6. Can we obtain less than 6. Lets check\\n[4, 6, 1, 6] -> [5, 5, 1, 6] -> [5, 5, 2, 5] now max. value is 5.\\nSo, we obtained min. value that will be largest in array is 5. Now if we do any op. in this array it will result in increasing the max value but our goal is to minimize.\\nHope you understand the explanation.\\n\\n"
                    },
                    {
                        "username": "zma08",
                        "content": "[@siyu14](/siyu14) you can but the max 5 didn\\'t change, so no need to"
                    },
                    {
                        "username": "siyu14",
                        "content": "why 5516 cannot become 5525 then 5534?"
                    },
                    {
                        "username": "olchik",
                        "content": "[@harsh_na710](/harsh_na710) for example: [13,13,17,18,8] -> [13,14,16,18,8] -> [13,15,15,18,8] -> [13,16,14,18,8] -> [13,16,15,17,8] -> [13,16,16,16,8] -> [14,15,16,16,8] -> [15,14,16,16,8] -> [15,15,15,16,8]"
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "VISHAL_SUJAY_KUMAR",
                        "content": "\\nThanks dude after reading the question i was thinking from priority queue point got it cleared after reading u r explaination\\n"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@harsh_na710](/harsh_na710) \\n[13, 13, 17, 18, 8] MAX - 18. Can we get less than 18. Lets try\\n[13, 13, 17, 18, 8] -> [13, 13, 18, 17, 8] -> [13, 14, 17, 17, 8] MAX 17. lets minimize it further\\n[13, 14, 17, 17, 8] -> [13, 14, 18, 16, 8] -> [13, 15, 17, 16, 8] -> [13, 16, 16 ,16, 8]. MAX 16\\nNow if we do any operation it will only inc. the MAX"
                    },
                    {
                        "username": "harsh_na710",
                        "content": "Please explain how u r getting and of this input\\n[13,13,17,18,8]"
                    },
                    {
                        "username": "Aviral_Srivastava",
                        "content": "They should\\'ve explained the question like you. Thanks mate."
                    },
                    {
                        "username": "ranbir7",
                        "content": "thanksss\\n"
                    },
                    {
                        "username": "cesar1000",
                        "content": "Here's one way to interpret the goal: the only operation that we can run on the array transfers a unit toward elements on the left without affecting the overall sum. If you think about each array entry as a pile of rocks, the only allowed operation is to take a rock from one pile and move it to the pile on its left. The goal of the problem is to rearrange the rocks by applying this operation as many times as you want to make it so that the tallest pile is as low as possible."
                    },
                    {
                        "username": "Ishaan_P",
                        "content": "Clear intuitive explanation. Awesome!"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Wonderful explanation, thank you!"
                    },
                    {
                        "username": "rahul1995",
                        "content": "This should exactly be the problem statement. I understood the problem, but this is very easy to relate and understand."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is quite a tricky question, also the hints don't help much, so here are some helpful tips:-\n\n1. Ignore Binary Search Approach, look for a mathematical O(n) time complexity approach.\n\n2. Imagine having two number `5 10` . We need to decrease one and increase other, how would we minimize the maximum number among them? By Evenly distributing them! We can then take the ceiling of their average `(10+5)/2 = 7.5 = 8` .\n\n3. If there are three numbers, we need to take average of all of them and update our ans if it's bigger than the previously achieved answer, same for the whole array.\n\n4. Take a prefix sum variable, an ans variable, iterate through the array from 1st index, keep finding the ceiling of average until current iteration and update the answer as` ans  = max(ans, (total+i)/(i+1))`.\n\n5. To summarize, we are evenly distributing all the elements so as to make the maximum[ceil of average] among them minimum, and keeping track of the maximum value as answer to return it.\n\nNote: - Do a dry run to understand why `total+i` is done there to calculate ceil of average "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "thanks bruh stuck all day any idea about bs implementation"
                    },
                    {
                        "username": "arison646",
                        "content": "Damn that\\'s smart, good job dude"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) chad !"
                    },
                    {
                        "username": "serkora",
                        "content": "[@namandt](/namandt) The remainder of (total/i+1) is between 1 and i. Since we need to ceil this, adding i to the minimum possible remainder makes it (i+1), i.e. adds 1 to the division result (when it is truncated/floored because ints). [And since i is obviously less than i+1, we can never add more than 1 to the result.]"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "this is magic of math \\uD83D\\uDE2F"
                    },
                    {
                        "username": "namandt",
                        "content": "[@arshikamishra](/arshikamishra) \\nHe so cocky.\\nhe will say do dry run and find out.\\n\\ndude, we wanted to know the intuition behind th elogic.\\nwe know in a fucking dry run it will give the ceiling.. question is how?.\\nso cocky dude..good luck."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Here's my complete solution in case you are confused\n\n\nint minimizeArrayValue(vector<int>& nums) {\n        long long total = nums[0], ans = nums[0];\n        for(int i=1;i<nums.size();i++){\n            total += nums[i];\n            ans = max(ans, (total+i)/(i+1));\n        }\n        return (int)ans;\n    }\n\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@arshikamishra](/arshikamishra) Just do one dry run, you will realise that this formula gives the ceil of average very easily"
                    },
                    {
                        "username": "uavishal777",
                        "content": "[@arshikamishra](/arshikamishra)  i too could not understand it why it is (total+i)...i think its a technique to get ceil value.."
                    },
                    {
                        "username": "artem-tarasov",
                        "content": "[@arshikamishra](/arshikamishra) that's a fancy way to get the ceiling instead of floor when dividing"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "why (total+i) ??"
                    },
                    {
                        "username": "itraaghav",
                        "content": "Couldnt understand the question. Can someone explain"
                    },
                    {
                        "username": "sipi09",
                        "content": "It took me a while to get it also. The point is you can perform any number of operations that is described. It is important that you can choose i element of the list - which cannot be the first item (index cannot be 0). Once you have this item, you can perform the operation: decrease i item and increase i-1 item. With this \"operation\" set you have to figure out the lowest (minimum) possible value of the list (or its permutations!)  maximum values... \\nFor example: if you have a list: num=[3,7,1,6] then the maximum value is 7. But you can make an operation on i=1. So decrease num[1] which is 7 to be 6. And increase num[0] which is 3 to be 4. So the new list will be: [4,6,1,6]. In this the maximum value is 6, which is lower than the 7, so this is what we carry over. \\nCan we find lower maximum value if we do operations on any of the items in the new list?\\nI let you figure this out. :)\\nI hope this helps."
                    },
                    {
                        "username": "user9946L",
                        "content": "When your interviewer smoked crack right before your onsite..."
                    },
                    {
                        "username": "lostintime",
                        "content": "i have no idea what this question is asking. One of the most poorly worded questions i\\'ve encounted on Leetcode"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I hate questions like this that +1 and -1."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "same bro +1, -1 and \"\\'any number of operations\\' like what. I see them a lot on leetcode contests"
                    },
                    {
                        "username": "SIT_2_0_2_4",
                        "content": "[@ry-reek](/ry-reek) same here and i am struggling with the q like sub.. le it be subarray or substring etc plz help "
                    },
                    {
                        "username": "ry-reek",
                        "content": "same, I almost always don\\'t understand what to actually do in questions like these."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "When u wait whole night to solve Problem of the Day..\\nLe Leetcode : kar le ab solve."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose, $nums = [a, b, c, d]$\n1. Choose $i = 1$, $nums = [a + 1, b - 1, c, d]$\n2. Choose $i = 2$, $nums = [a + 1, b, c - 1, d]$\n3. Choose $i = 3$, $nums = [a + 1, b, c, d - 1]$\n\nMeans for an index $i$, we can transfer its value to any index $j \\le i$, and not just to $i - 1$.\nSo, we are transferring some part of value from index $i$ to previous indices.\n\n# Hint 2\nIf we have a number, say $m$, how can we check if this number is possible to be the maximum value of array?\nWhile transferring that some part of value from $i$th index to previous indices, the previous elements will be increased. So, we have to check that while increasing them, they will not go above the number $m$, for $m$ to be a possible value.\n\n# Hint 3\nTo check the above condition, if we are currently at index $i$, how much we can transfer the value of $nums[i]$ to previous indices?\nThere are total $i$ elements before $nums[i]$, and each one of them can be increased upto $m$.\nSo, total possible transfer at index $i$ to previous indices is $i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$.\nAnd, if $nums[i]>m$, then we have to decrease it and transfer its value to previous indices by atleast $nums[i]-m$.\n\nTherefore, for $m$ to be possible maximum, the amount by which we need to decrease $nums[i]$ can't be more than the total possible transfer to previous indices.\n$nums[i] - m \\le i.m - \\displaystyle\\sum_{j=0}^{i-1} nums[j]$\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\n\n# Hint 4\nNow, apply binary search over the variable $m$. Binary search is applicable because, if $m$ is a possible value, then anything greater than $m$ is not **minimum** possible value of maximum, and we can go search in range $[0,m]$. And if $m$ is not possible to be maximum of array, then anything smaller than $m$ is also not possible to be the maximum of array, and we can go search in range $[m+1, \\infty)$.\nIn each iteration of binary search, traverse whole array, maintain prefix sum and check condition given in Hint 3, for $O(n)$.\nTotal complexity will be $O(nlog(max(nums)))$\n\n# Hint 5\nNow, for the condition of Hint 3\n$\\displaystyle\\sum_{j=0}^{i} nums[j] \\le (i+1)m$\nWe were assuming the value of $m$ and checking if it is possible. But we can directly calculate this value using above condition:\n$(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1) \\le m$\nLet, $f(i)=(\\displaystyle\\sum_{j=0}^{i} nums[j]) / (i + 1)$, and $m \\ge f(i)$\nThis should be true for all indices $0 \\le i < n$. For example, for $i=0$, $m \\ge 2$, and for $i=1$, $m \\ge 3$. Then $m \\ge 2$ AND $m \\ge 3$ means $m \\ge 3$.\nSo,\n$m = \\displaystyle\\max_{0 \\le i < n} f(i)$\n\nNow, we can maintain prefix sum and update $m$ to $max(m, f(i))$ in each iteration.\nTotal complexity will be $O(n)$."
                    },
                    {
                        "username": "King_Pin",
                        "content": "I see 10^5 in constraints ... I start thinking Binary Search immediately lol."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "the funny thing is that it can be solved in linear time, if you don\\'t look at the constraints"
                    }
                ]
            },
            {
                "id": 1854503,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "I see so many people complaining about the clarity of the problem and I don't understand the reason. I've had a few times where I encountered ambiguous questions in Leetcode but this is clearly not the case today. In fact, this problem statement is as clear as it can get, short and concise. If the idea of minimizing the maximum number in an array confuses you then it's not the question's issue."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this ques is nuts. I know the answer and the solution but still overwhelmed by how they used average and prefix concept here. I don\\'t think I can think of this solution in interview within 40 min "
                    },
                    {
                        "username": "Msey",
                        "content": "for God sake don\\'t let us solve the \"Minimize the Maximum of Two Arrays\" tomorrow pls !"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "harder than yesterday\\'s hard !"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Maybe a mathematical description for this problem is helpful. What kind of the properties  are there?\nLet s_n be the summation of nums[i] for i=0,...,n.\nThe minimal max is related to ceil(s_n/(n+1)).\nIf you figure out the formula, the implementation problem becomes much easier."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "That's a pretty big hint there, you almost solved the problem for the reader"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Calculate prefix sum of the array.\\n- Iterate over the array from left to right.\\n- For each element, calculate the average value of the prefix sum up to that element and the index of that element.\\n- Update the answer variable to be the maximum of the previous answer and the current average value.\\n- Return the answer variable as the minimum possible value of the maximum integer in the array after performing any number of operations.\\n\\n**This approach uses O(1) space and O(n) time complexity, making it efficient for large inputs.**"
                    },
                    {
                        "username": "charonme",
                        "content": "The third step is wrong, you should instead calculate the average of the array values up to the index, or in other words divide the prefix sum by (the index + 1) and round it up"
                    },
                    {
                        "username": "namandt",
                        "content": "who the hell will tell that \\'ans\\' variable must have the first element as initial value!.\\nelse this approach will not work"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Is this supposed to be a medium question?"
                    },
                    {
                        "username": "felipealco",
                        "content": "The question says \"You MUST:..\" meanwhile the example 2 says \"It is optimal to leave nums as is\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes, there the optimal number of operations is 0, so you don\\'t have to do anything"
                    },
                    {
                        "username": "alecapiani",
                        "content": "The explanation of the second example is meh.\\nif nums = [2,2,..,2] would be ok.\\nSaying that you can\\'t change nothing is better than saying is optimal.\\n\\'\\'\\'\\nInput: nums = [10,1]\\nOutput: 10\\nExplanation:\\nIt is optimal to leave nums as is, and since 10 is the maximum value, we return 10.\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "dude was stoned writing this "
                    }
                ]
            },
            {
                "id": 1854924,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "I see so many people complaining about the clarity of the problem and I don't understand the reason. I've had a few times where I encountered ambiguous questions in Leetcode but this is clearly not the case today. In fact, this problem statement is as clear as it can get, short and concise. If the idea of minimizing the maximum number in an array confuses you then it's not the question's issue."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this ques is nuts. I know the answer and the solution but still overwhelmed by how they used average and prefix concept here. I don\\'t think I can think of this solution in interview within 40 min "
                    },
                    {
                        "username": "Msey",
                        "content": "for God sake don\\'t let us solve the \"Minimize the Maximum of Two Arrays\" tomorrow pls !"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "harder than yesterday\\'s hard !"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Maybe a mathematical description for this problem is helpful. What kind of the properties  are there?\nLet s_n be the summation of nums[i] for i=0,...,n.\nThe minimal max is related to ceil(s_n/(n+1)).\nIf you figure out the formula, the implementation problem becomes much easier."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "That's a pretty big hint there, you almost solved the problem for the reader"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Calculate prefix sum of the array.\\n- Iterate over the array from left to right.\\n- For each element, calculate the average value of the prefix sum up to that element and the index of that element.\\n- Update the answer variable to be the maximum of the previous answer and the current average value.\\n- Return the answer variable as the minimum possible value of the maximum integer in the array after performing any number of operations.\\n\\n**This approach uses O(1) space and O(n) time complexity, making it efficient for large inputs.**"
                    },
                    {
                        "username": "charonme",
                        "content": "The third step is wrong, you should instead calculate the average of the array values up to the index, or in other words divide the prefix sum by (the index + 1) and round it up"
                    },
                    {
                        "username": "namandt",
                        "content": "who the hell will tell that \\'ans\\' variable must have the first element as initial value!.\\nelse this approach will not work"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Is this supposed to be a medium question?"
                    },
                    {
                        "username": "felipealco",
                        "content": "The question says \"You MUST:..\" meanwhile the example 2 says \"It is optimal to leave nums as is\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes, there the optimal number of operations is 0, so you don\\'t have to do anything"
                    },
                    {
                        "username": "alecapiani",
                        "content": "The explanation of the second example is meh.\\nif nums = [2,2,..,2] would be ok.\\nSaying that you can\\'t change nothing is better than saying is optimal.\\n\\'\\'\\'\\nInput: nums = [10,1]\\nOutput: 10\\nExplanation:\\nIt is optimal to leave nums as is, and since 10 is the maximum value, we return 10.\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "dude was stoned writing this "
                    }
                ]
            },
            {
                "id": 1854922,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "I see so many people complaining about the clarity of the problem and I don't understand the reason. I've had a few times where I encountered ambiguous questions in Leetcode but this is clearly not the case today. In fact, this problem statement is as clear as it can get, short and concise. If the idea of minimizing the maximum number in an array confuses you then it's not the question's issue."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this ques is nuts. I know the answer and the solution but still overwhelmed by how they used average and prefix concept here. I don\\'t think I can think of this solution in interview within 40 min "
                    },
                    {
                        "username": "Msey",
                        "content": "for God sake don\\'t let us solve the \"Minimize the Maximum of Two Arrays\" tomorrow pls !"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "harder than yesterday\\'s hard !"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Maybe a mathematical description for this problem is helpful. What kind of the properties  are there?\nLet s_n be the summation of nums[i] for i=0,...,n.\nThe minimal max is related to ceil(s_n/(n+1)).\nIf you figure out the formula, the implementation problem becomes much easier."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "That's a pretty big hint there, you almost solved the problem for the reader"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Calculate prefix sum of the array.\\n- Iterate over the array from left to right.\\n- For each element, calculate the average value of the prefix sum up to that element and the index of that element.\\n- Update the answer variable to be the maximum of the previous answer and the current average value.\\n- Return the answer variable as the minimum possible value of the maximum integer in the array after performing any number of operations.\\n\\n**This approach uses O(1) space and O(n) time complexity, making it efficient for large inputs.**"
                    },
                    {
                        "username": "charonme",
                        "content": "The third step is wrong, you should instead calculate the average of the array values up to the index, or in other words divide the prefix sum by (the index + 1) and round it up"
                    },
                    {
                        "username": "namandt",
                        "content": "who the hell will tell that \\'ans\\' variable must have the first element as initial value!.\\nelse this approach will not work"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Is this supposed to be a medium question?"
                    },
                    {
                        "username": "felipealco",
                        "content": "The question says \"You MUST:..\" meanwhile the example 2 says \"It is optimal to leave nums as is\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes, there the optimal number of operations is 0, so you don\\'t have to do anything"
                    },
                    {
                        "username": "alecapiani",
                        "content": "The explanation of the second example is meh.\\nif nums = [2,2,..,2] would be ok.\\nSaying that you can\\'t change nothing is better than saying is optimal.\\n\\'\\'\\'\\nInput: nums = [10,1]\\nOutput: 10\\nExplanation:\\nIt is optimal to leave nums as is, and since 10 is the maximum value, we return 10.\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "dude was stoned writing this "
                    }
                ]
            },
            {
                "id": 1854263,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "I see so many people complaining about the clarity of the problem and I don't understand the reason. I've had a few times where I encountered ambiguous questions in Leetcode but this is clearly not the case today. In fact, this problem statement is as clear as it can get, short and concise. If the idea of minimizing the maximum number in an array confuses you then it's not the question's issue."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this ques is nuts. I know the answer and the solution but still overwhelmed by how they used average and prefix concept here. I don\\'t think I can think of this solution in interview within 40 min "
                    },
                    {
                        "username": "Msey",
                        "content": "for God sake don\\'t let us solve the \"Minimize the Maximum of Two Arrays\" tomorrow pls !"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "harder than yesterday\\'s hard !"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Maybe a mathematical description for this problem is helpful. What kind of the properties  are there?\nLet s_n be the summation of nums[i] for i=0,...,n.\nThe minimal max is related to ceil(s_n/(n+1)).\nIf you figure out the formula, the implementation problem becomes much easier."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "That's a pretty big hint there, you almost solved the problem for the reader"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Calculate prefix sum of the array.\\n- Iterate over the array from left to right.\\n- For each element, calculate the average value of the prefix sum up to that element and the index of that element.\\n- Update the answer variable to be the maximum of the previous answer and the current average value.\\n- Return the answer variable as the minimum possible value of the maximum integer in the array after performing any number of operations.\\n\\n**This approach uses O(1) space and O(n) time complexity, making it efficient for large inputs.**"
                    },
                    {
                        "username": "charonme",
                        "content": "The third step is wrong, you should instead calculate the average of the array values up to the index, or in other words divide the prefix sum by (the index + 1) and round it up"
                    },
                    {
                        "username": "namandt",
                        "content": "who the hell will tell that \\'ans\\' variable must have the first element as initial value!.\\nelse this approach will not work"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Is this supposed to be a medium question?"
                    },
                    {
                        "username": "felipealco",
                        "content": "The question says \"You MUST:..\" meanwhile the example 2 says \"It is optimal to leave nums as is\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes, there the optimal number of operations is 0, so you don\\'t have to do anything"
                    },
                    {
                        "username": "alecapiani",
                        "content": "The explanation of the second example is meh.\\nif nums = [2,2,..,2] would be ok.\\nSaying that you can\\'t change nothing is better than saying is optimal.\\n\\'\\'\\'\\nInput: nums = [10,1]\\nOutput: 10\\nExplanation:\\nIt is optimal to leave nums as is, and since 10 is the maximum value, we return 10.\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "dude was stoned writing this "
                    }
                ]
            },
            {
                "id": 1854115,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "I see so many people complaining about the clarity of the problem and I don't understand the reason. I've had a few times where I encountered ambiguous questions in Leetcode but this is clearly not the case today. In fact, this problem statement is as clear as it can get, short and concise. If the idea of minimizing the maximum number in an array confuses you then it's not the question's issue."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this ques is nuts. I know the answer and the solution but still overwhelmed by how they used average and prefix concept here. I don\\'t think I can think of this solution in interview within 40 min "
                    },
                    {
                        "username": "Msey",
                        "content": "for God sake don\\'t let us solve the \"Minimize the Maximum of Two Arrays\" tomorrow pls !"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "harder than yesterday\\'s hard !"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Maybe a mathematical description for this problem is helpful. What kind of the properties  are there?\nLet s_n be the summation of nums[i] for i=0,...,n.\nThe minimal max is related to ceil(s_n/(n+1)).\nIf you figure out the formula, the implementation problem becomes much easier."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "That's a pretty big hint there, you almost solved the problem for the reader"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Calculate prefix sum of the array.\\n- Iterate over the array from left to right.\\n- For each element, calculate the average value of the prefix sum up to that element and the index of that element.\\n- Update the answer variable to be the maximum of the previous answer and the current average value.\\n- Return the answer variable as the minimum possible value of the maximum integer in the array after performing any number of operations.\\n\\n**This approach uses O(1) space and O(n) time complexity, making it efficient for large inputs.**"
                    },
                    {
                        "username": "charonme",
                        "content": "The third step is wrong, you should instead calculate the average of the array values up to the index, or in other words divide the prefix sum by (the index + 1) and round it up"
                    },
                    {
                        "username": "namandt",
                        "content": "who the hell will tell that \\'ans\\' variable must have the first element as initial value!.\\nelse this approach will not work"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Is this supposed to be a medium question?"
                    },
                    {
                        "username": "felipealco",
                        "content": "The question says \"You MUST:..\" meanwhile the example 2 says \"It is optimal to leave nums as is\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes, there the optimal number of operations is 0, so you don\\'t have to do anything"
                    },
                    {
                        "username": "alecapiani",
                        "content": "The explanation of the second example is meh.\\nif nums = [2,2,..,2] would be ok.\\nSaying that you can\\'t change nothing is better than saying is optimal.\\n\\'\\'\\'\\nInput: nums = [10,1]\\nOutput: 10\\nExplanation:\\nIt is optimal to leave nums as is, and since 10 is the maximum value, we return 10.\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "dude was stoned writing this "
                    }
                ]
            },
            {
                "id": 1854166,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "I see so many people complaining about the clarity of the problem and I don't understand the reason. I've had a few times where I encountered ambiguous questions in Leetcode but this is clearly not the case today. In fact, this problem statement is as clear as it can get, short and concise. If the idea of minimizing the maximum number in an array confuses you then it's not the question's issue."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this ques is nuts. I know the answer and the solution but still overwhelmed by how they used average and prefix concept here. I don\\'t think I can think of this solution in interview within 40 min "
                    },
                    {
                        "username": "Msey",
                        "content": "for God sake don\\'t let us solve the \"Minimize the Maximum of Two Arrays\" tomorrow pls !"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "harder than yesterday\\'s hard !"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Maybe a mathematical description for this problem is helpful. What kind of the properties  are there?\nLet s_n be the summation of nums[i] for i=0,...,n.\nThe minimal max is related to ceil(s_n/(n+1)).\nIf you figure out the formula, the implementation problem becomes much easier."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "That's a pretty big hint there, you almost solved the problem for the reader"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Calculate prefix sum of the array.\\n- Iterate over the array from left to right.\\n- For each element, calculate the average value of the prefix sum up to that element and the index of that element.\\n- Update the answer variable to be the maximum of the previous answer and the current average value.\\n- Return the answer variable as the minimum possible value of the maximum integer in the array after performing any number of operations.\\n\\n**This approach uses O(1) space and O(n) time complexity, making it efficient for large inputs.**"
                    },
                    {
                        "username": "charonme",
                        "content": "The third step is wrong, you should instead calculate the average of the array values up to the index, or in other words divide the prefix sum by (the index + 1) and round it up"
                    },
                    {
                        "username": "namandt",
                        "content": "who the hell will tell that \\'ans\\' variable must have the first element as initial value!.\\nelse this approach will not work"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Is this supposed to be a medium question?"
                    },
                    {
                        "username": "felipealco",
                        "content": "The question says \"You MUST:..\" meanwhile the example 2 says \"It is optimal to leave nums as is\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes, there the optimal number of operations is 0, so you don\\'t have to do anything"
                    },
                    {
                        "username": "alecapiani",
                        "content": "The explanation of the second example is meh.\\nif nums = [2,2,..,2] would be ok.\\nSaying that you can\\'t change nothing is better than saying is optimal.\\n\\'\\'\\'\\nInput: nums = [10,1]\\nOutput: 10\\nExplanation:\\nIt is optimal to leave nums as is, and since 10 is the maximum value, we return 10.\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "dude was stoned writing this "
                    }
                ]
            },
            {
                "id": 1854996,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "I see so many people complaining about the clarity of the problem and I don't understand the reason. I've had a few times where I encountered ambiguous questions in Leetcode but this is clearly not the case today. In fact, this problem statement is as clear as it can get, short and concise. If the idea of minimizing the maximum number in an array confuses you then it's not the question's issue."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this ques is nuts. I know the answer and the solution but still overwhelmed by how they used average and prefix concept here. I don\\'t think I can think of this solution in interview within 40 min "
                    },
                    {
                        "username": "Msey",
                        "content": "for God sake don\\'t let us solve the \"Minimize the Maximum of Two Arrays\" tomorrow pls !"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "harder than yesterday\\'s hard !"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Maybe a mathematical description for this problem is helpful. What kind of the properties  are there?\nLet s_n be the summation of nums[i] for i=0,...,n.\nThe minimal max is related to ceil(s_n/(n+1)).\nIf you figure out the formula, the implementation problem becomes much easier."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "That's a pretty big hint there, you almost solved the problem for the reader"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Calculate prefix sum of the array.\\n- Iterate over the array from left to right.\\n- For each element, calculate the average value of the prefix sum up to that element and the index of that element.\\n- Update the answer variable to be the maximum of the previous answer and the current average value.\\n- Return the answer variable as the minimum possible value of the maximum integer in the array after performing any number of operations.\\n\\n**This approach uses O(1) space and O(n) time complexity, making it efficient for large inputs.**"
                    },
                    {
                        "username": "charonme",
                        "content": "The third step is wrong, you should instead calculate the average of the array values up to the index, or in other words divide the prefix sum by (the index + 1) and round it up"
                    },
                    {
                        "username": "namandt",
                        "content": "who the hell will tell that \\'ans\\' variable must have the first element as initial value!.\\nelse this approach will not work"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Is this supposed to be a medium question?"
                    },
                    {
                        "username": "felipealco",
                        "content": "The question says \"You MUST:..\" meanwhile the example 2 says \"It is optimal to leave nums as is\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes, there the optimal number of operations is 0, so you don\\'t have to do anything"
                    },
                    {
                        "username": "alecapiani",
                        "content": "The explanation of the second example is meh.\\nif nums = [2,2,..,2] would be ok.\\nSaying that you can\\'t change nothing is better than saying is optimal.\\n\\'\\'\\'\\nInput: nums = [10,1]\\nOutput: 10\\nExplanation:\\nIt is optimal to leave nums as is, and since 10 is the maximum value, we return 10.\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "dude was stoned writing this "
                    }
                ]
            },
            {
                "id": 1854598,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "I see so many people complaining about the clarity of the problem and I don't understand the reason. I've had a few times where I encountered ambiguous questions in Leetcode but this is clearly not the case today. In fact, this problem statement is as clear as it can get, short and concise. If the idea of minimizing the maximum number in an array confuses you then it's not the question's issue."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this ques is nuts. I know the answer and the solution but still overwhelmed by how they used average and prefix concept here. I don\\'t think I can think of this solution in interview within 40 min "
                    },
                    {
                        "username": "Msey",
                        "content": "for God sake don\\'t let us solve the \"Minimize the Maximum of Two Arrays\" tomorrow pls !"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "harder than yesterday\\'s hard !"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Maybe a mathematical description for this problem is helpful. What kind of the properties  are there?\nLet s_n be the summation of nums[i] for i=0,...,n.\nThe minimal max is related to ceil(s_n/(n+1)).\nIf you figure out the formula, the implementation problem becomes much easier."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "That's a pretty big hint there, you almost solved the problem for the reader"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Calculate prefix sum of the array.\\n- Iterate over the array from left to right.\\n- For each element, calculate the average value of the prefix sum up to that element and the index of that element.\\n- Update the answer variable to be the maximum of the previous answer and the current average value.\\n- Return the answer variable as the minimum possible value of the maximum integer in the array after performing any number of operations.\\n\\n**This approach uses O(1) space and O(n) time complexity, making it efficient for large inputs.**"
                    },
                    {
                        "username": "charonme",
                        "content": "The third step is wrong, you should instead calculate the average of the array values up to the index, or in other words divide the prefix sum by (the index + 1) and round it up"
                    },
                    {
                        "username": "namandt",
                        "content": "who the hell will tell that \\'ans\\' variable must have the first element as initial value!.\\nelse this approach will not work"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Is this supposed to be a medium question?"
                    },
                    {
                        "username": "felipealco",
                        "content": "The question says \"You MUST:..\" meanwhile the example 2 says \"It is optimal to leave nums as is\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes, there the optimal number of operations is 0, so you don\\'t have to do anything"
                    },
                    {
                        "username": "alecapiani",
                        "content": "The explanation of the second example is meh.\\nif nums = [2,2,..,2] would be ok.\\nSaying that you can\\'t change nothing is better than saying is optimal.\\n\\'\\'\\'\\nInput: nums = [10,1]\\nOutput: 10\\nExplanation:\\nIt is optimal to leave nums as is, and since 10 is the maximum value, we return 10.\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "dude was stoned writing this "
                    }
                ]
            },
            {
                "id": 1989660,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "I see so many people complaining about the clarity of the problem and I don't understand the reason. I've had a few times where I encountered ambiguous questions in Leetcode but this is clearly not the case today. In fact, this problem statement is as clear as it can get, short and concise. If the idea of minimizing the maximum number in an array confuses you then it's not the question's issue."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this ques is nuts. I know the answer and the solution but still overwhelmed by how they used average and prefix concept here. I don\\'t think I can think of this solution in interview within 40 min "
                    },
                    {
                        "username": "Msey",
                        "content": "for God sake don\\'t let us solve the \"Minimize the Maximum of Two Arrays\" tomorrow pls !"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "harder than yesterday\\'s hard !"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Maybe a mathematical description for this problem is helpful. What kind of the properties  are there?\nLet s_n be the summation of nums[i] for i=0,...,n.\nThe minimal max is related to ceil(s_n/(n+1)).\nIf you figure out the formula, the implementation problem becomes much easier."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "That's a pretty big hint there, you almost solved the problem for the reader"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Calculate prefix sum of the array.\\n- Iterate over the array from left to right.\\n- For each element, calculate the average value of the prefix sum up to that element and the index of that element.\\n- Update the answer variable to be the maximum of the previous answer and the current average value.\\n- Return the answer variable as the minimum possible value of the maximum integer in the array after performing any number of operations.\\n\\n**This approach uses O(1) space and O(n) time complexity, making it efficient for large inputs.**"
                    },
                    {
                        "username": "charonme",
                        "content": "The third step is wrong, you should instead calculate the average of the array values up to the index, or in other words divide the prefix sum by (the index + 1) and round it up"
                    },
                    {
                        "username": "namandt",
                        "content": "who the hell will tell that \\'ans\\' variable must have the first element as initial value!.\\nelse this approach will not work"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Is this supposed to be a medium question?"
                    },
                    {
                        "username": "felipealco",
                        "content": "The question says \"You MUST:..\" meanwhile the example 2 says \"It is optimal to leave nums as is\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes, there the optimal number of operations is 0, so you don\\'t have to do anything"
                    },
                    {
                        "username": "alecapiani",
                        "content": "The explanation of the second example is meh.\\nif nums = [2,2,..,2] would be ok.\\nSaying that you can\\'t change nothing is better than saying is optimal.\\n\\'\\'\\'\\nInput: nums = [10,1]\\nOutput: 10\\nExplanation:\\nIt is optimal to leave nums as is, and since 10 is the maximum value, we return 10.\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "dude was stoned writing this "
                    }
                ]
            },
            {
                "id": 1976808,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "I see so many people complaining about the clarity of the problem and I don't understand the reason. I've had a few times where I encountered ambiguous questions in Leetcode but this is clearly not the case today. In fact, this problem statement is as clear as it can get, short and concise. If the idea of minimizing the maximum number in an array confuses you then it's not the question's issue."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "this ques is nuts. I know the answer and the solution but still overwhelmed by how they used average and prefix concept here. I don\\'t think I can think of this solution in interview within 40 min "
                    },
                    {
                        "username": "Msey",
                        "content": "for God sake don\\'t let us solve the \"Minimize the Maximum of Two Arrays\" tomorrow pls !"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "harder than yesterday\\'s hard !"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Maybe a mathematical description for this problem is helpful. What kind of the properties  are there?\nLet s_n be the summation of nums[i] for i=0,...,n.\nThe minimal max is related to ceil(s_n/(n+1)).\nIf you figure out the formula, the implementation problem becomes much easier."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "That's a pretty big hint there, you almost solved the problem for the reader"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Calculate prefix sum of the array.\\n- Iterate over the array from left to right.\\n- For each element, calculate the average value of the prefix sum up to that element and the index of that element.\\n- Update the answer variable to be the maximum of the previous answer and the current average value.\\n- Return the answer variable as the minimum possible value of the maximum integer in the array after performing any number of operations.\\n\\n**This approach uses O(1) space and O(n) time complexity, making it efficient for large inputs.**"
                    },
                    {
                        "username": "charonme",
                        "content": "The third step is wrong, you should instead calculate the average of the array values up to the index, or in other words divide the prefix sum by (the index + 1) and round it up"
                    },
                    {
                        "username": "namandt",
                        "content": "who the hell will tell that \\'ans\\' variable must have the first element as initial value!.\\nelse this approach will not work"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Is this supposed to be a medium question?"
                    },
                    {
                        "username": "felipealco",
                        "content": "The question says \"You MUST:..\" meanwhile the example 2 says \"It is optimal to leave nums as is\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes, there the optimal number of operations is 0, so you don\\'t have to do anything"
                    },
                    {
                        "username": "alecapiani",
                        "content": "The explanation of the second example is meh.\\nif nums = [2,2,..,2] would be ok.\\nSaying that you can\\'t change nothing is better than saying is optimal.\\n\\'\\'\\'\\nInput: nums = [10,1]\\nOutput: 10\\nExplanation:\\nIt is optimal to leave nums as is, and since 10 is the maximum value, we return 10.\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "dude was stoned writing this "
                    }
                ]
            },
            {
                "id": 1950651,
                "content": [
                    {
                        "username": "anandnit",
                        "content": "just dry run with the intutuion of binary search "
                    },
                    {
                        "username": "tonybuidn",
                        "content": "In my opinion, I think this is a tricky question because as we can see that, we need to execute operations to return the minimum possible value of the maximum integer of nums. So we just need to execute one operation at 4th index\\nWe have : [4,6,1,6] . So we just need to execute one operation at 3th index => [4,6,2,5] => so the maximum value of nums is 6 with only 1 operation. So why do we need to execute to 3 operations to get only 5???? Thanks for pointing which one that makes my logic wrong."
                    },
                    {
                        "username": "tejasX",
                        "content": "Is it suitably medium ? I found it Hard in one go."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "leetcode needs to go to duolingo(what in the world is this english??)."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Thinking on my life choices now..."
                    },
                    {
                        "username": "user3475tK",
                        "content": "[4,7,2,2,9,19,16,0,3,15]. \nHow is ans 9 possible here? I believe we can't decrease 19 to below 10 as previous no will increase and become more than 9 even if we are able to have it as 0 by previous processing"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Here's one of the ways to get maximum of 9:\n\n1. Transfer 6 from 15 to 3 (now both are 9)\n2. Transfer 7 from 16 to 19 (now 16 is 9 and 19 is 26)\n3. Transfer 17 from 26 to 9 (now 26 is 9 and 9 is 26)\n4. Transfer 17 from 26 to 2 (now 26 is 9 and 2 is 19)\n5. Transfer 10 from 19 to left 2 (now 19 is 9 and left 2 is 12)\n6. Transfer 3 from 12 to 7 (now 12 is 9 and 7 is 10)\n7. Transfer 1 from 10 to 4. (now 10 is 9 and 4 is 5)\n\nSo in the end it's [5, 9, 9, 9, 9, 9, 9, 0, 9, 9]\nAnd while it's possible to reduce some of 9s to 8, you can't reduce *all* of 9s which are to the left of 0. So, the answer is 9."
                    },
                    {
                        "username": "psat",
                        "content": "The way this question is structured, I can easily push the numbers such that the array is [14,1,1,1] it satisfies all the initial constrains for nums[i] > 0 and 1<=i<n. Why stop at [5,5,2,5]"
                    },
                    {
                        "username": "codelearner12345",
                        "content": "You can do that, but then the max value is 14, not 5. You want to minimize this maximum value, and you can\\'t get lower than 5 in that example."
                    },
                    {
                        "username": "codelearner12345",
                        "content": "I don\\'t think the problem itself is inherently bad, but the hint is definitely misleading. It\\'s much easier to look for an O(n) solution than a binary search. The examples could also be more detailed."
                    },
                    {
                        "username": "josh10187",
                        "content": "Not sure what I am doing wrong, my ans is always 1 off on testcase 31? \\n `ans = 0\\n  sums = 0\\n\\n  for i in range(len(len(nums)):\\n          sums += nums[i]\\n          ans = max(ans, (sums / (i + 1))\\n\\nreturn ans\\n`"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "try (sums+i)/(i+1)"
                    },
                    {
                        "username": "Entrropic",
                        "content": "I'll share my thoughts and my approach (O(N) time and O(1) space):\n\n1. If there wasn't a limitation that you can only use elements to the left of selected nums[i], the solution could be calculated as `ceil(sum(nums)/len(nums))` - as you would be able to \"spread\" numbers as evenly as possible across the whole array;\n2. Due to the limitations, you need to double check if `ceil(sum(nums[:i])/len(nums[:i]))` is achievable for subarray to the left of \"i\". For example, for [10,1]  `ceil(sum(nums[:2])/len(nums[:2]))` would be 6, but `ceil(sum(nums[:1])/len(nums[:1]))` is 10, and that is the actual answer.\n3. The above idea provides an approach that can be used: calculate sum and length of array and store them. Then use for loop from nums.length-1 to 0 inclusive, and calculate the result of `ceil(stored_sum/stored_length)`, each time decreasing sum by nums[i] and length by 1. Store max result of dividing \"stored_sum\" by \"stored_length\" and return it in the end."
                    }
                ]
            },
            {
                "id": 1855495,
                "content": [
                    {
                        "username": "anandnit",
                        "content": "just dry run with the intutuion of binary search "
                    },
                    {
                        "username": "tonybuidn",
                        "content": "In my opinion, I think this is a tricky question because as we can see that, we need to execute operations to return the minimum possible value of the maximum integer of nums. So we just need to execute one operation at 4th index\\nWe have : [4,6,1,6] . So we just need to execute one operation at 3th index => [4,6,2,5] => so the maximum value of nums is 6 with only 1 operation. So why do we need to execute to 3 operations to get only 5???? Thanks for pointing which one that makes my logic wrong."
                    },
                    {
                        "username": "tejasX",
                        "content": "Is it suitably medium ? I found it Hard in one go."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "leetcode needs to go to duolingo(what in the world is this english??)."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Thinking on my life choices now..."
                    },
                    {
                        "username": "user3475tK",
                        "content": "[4,7,2,2,9,19,16,0,3,15]. \nHow is ans 9 possible here? I believe we can't decrease 19 to below 10 as previous no will increase and become more than 9 even if we are able to have it as 0 by previous processing"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Here's one of the ways to get maximum of 9:\n\n1. Transfer 6 from 15 to 3 (now both are 9)\n2. Transfer 7 from 16 to 19 (now 16 is 9 and 19 is 26)\n3. Transfer 17 from 26 to 9 (now 26 is 9 and 9 is 26)\n4. Transfer 17 from 26 to 2 (now 26 is 9 and 2 is 19)\n5. Transfer 10 from 19 to left 2 (now 19 is 9 and left 2 is 12)\n6. Transfer 3 from 12 to 7 (now 12 is 9 and 7 is 10)\n7. Transfer 1 from 10 to 4. (now 10 is 9 and 4 is 5)\n\nSo in the end it's [5, 9, 9, 9, 9, 9, 9, 0, 9, 9]\nAnd while it's possible to reduce some of 9s to 8, you can't reduce *all* of 9s which are to the left of 0. So, the answer is 9."
                    },
                    {
                        "username": "psat",
                        "content": "The way this question is structured, I can easily push the numbers such that the array is [14,1,1,1] it satisfies all the initial constrains for nums[i] > 0 and 1<=i<n. Why stop at [5,5,2,5]"
                    },
                    {
                        "username": "codelearner12345",
                        "content": "You can do that, but then the max value is 14, not 5. You want to minimize this maximum value, and you can\\'t get lower than 5 in that example."
                    },
                    {
                        "username": "codelearner12345",
                        "content": "I don\\'t think the problem itself is inherently bad, but the hint is definitely misleading. It\\'s much easier to look for an O(n) solution than a binary search. The examples could also be more detailed."
                    },
                    {
                        "username": "josh10187",
                        "content": "Not sure what I am doing wrong, my ans is always 1 off on testcase 31? \\n `ans = 0\\n  sums = 0\\n\\n  for i in range(len(len(nums)):\\n          sums += nums[i]\\n          ans = max(ans, (sums / (i + 1))\\n\\nreturn ans\\n`"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "try (sums+i)/(i+1)"
                    },
                    {
                        "username": "Entrropic",
                        "content": "I'll share my thoughts and my approach (O(N) time and O(1) space):\n\n1. If there wasn't a limitation that you can only use elements to the left of selected nums[i], the solution could be calculated as `ceil(sum(nums)/len(nums))` - as you would be able to \"spread\" numbers as evenly as possible across the whole array;\n2. Due to the limitations, you need to double check if `ceil(sum(nums[:i])/len(nums[:i]))` is achievable for subarray to the left of \"i\". For example, for [10,1]  `ceil(sum(nums[:2])/len(nums[:2]))` would be 6, but `ceil(sum(nums[:1])/len(nums[:1]))` is 10, and that is the actual answer.\n3. The above idea provides an approach that can be used: calculate sum and length of array and store them. Then use for loop from nums.length-1 to 0 inclusive, and calculate the result of `ceil(stored_sum/stored_length)`, each time decreasing sum by nums[i] and length by 1. Store max result of dividing \"stored_sum\" by \"stored_length\" and return it in the end."
                    }
                ]
            },
            {
                "id": 1855341,
                "content": [
                    {
                        "username": "anandnit",
                        "content": "just dry run with the intutuion of binary search "
                    },
                    {
                        "username": "tonybuidn",
                        "content": "In my opinion, I think this is a tricky question because as we can see that, we need to execute operations to return the minimum possible value of the maximum integer of nums. So we just need to execute one operation at 4th index\\nWe have : [4,6,1,6] . So we just need to execute one operation at 3th index => [4,6,2,5] => so the maximum value of nums is 6 with only 1 operation. So why do we need to execute to 3 operations to get only 5???? Thanks for pointing which one that makes my logic wrong."
                    },
                    {
                        "username": "tejasX",
                        "content": "Is it suitably medium ? I found it Hard in one go."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "leetcode needs to go to duolingo(what in the world is this english??)."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Thinking on my life choices now..."
                    },
                    {
                        "username": "user3475tK",
                        "content": "[4,7,2,2,9,19,16,0,3,15]. \nHow is ans 9 possible here? I believe we can't decrease 19 to below 10 as previous no will increase and become more than 9 even if we are able to have it as 0 by previous processing"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Here's one of the ways to get maximum of 9:\n\n1. Transfer 6 from 15 to 3 (now both are 9)\n2. Transfer 7 from 16 to 19 (now 16 is 9 and 19 is 26)\n3. Transfer 17 from 26 to 9 (now 26 is 9 and 9 is 26)\n4. Transfer 17 from 26 to 2 (now 26 is 9 and 2 is 19)\n5. Transfer 10 from 19 to left 2 (now 19 is 9 and left 2 is 12)\n6. Transfer 3 from 12 to 7 (now 12 is 9 and 7 is 10)\n7. Transfer 1 from 10 to 4. (now 10 is 9 and 4 is 5)\n\nSo in the end it's [5, 9, 9, 9, 9, 9, 9, 0, 9, 9]\nAnd while it's possible to reduce some of 9s to 8, you can't reduce *all* of 9s which are to the left of 0. So, the answer is 9."
                    },
                    {
                        "username": "psat",
                        "content": "The way this question is structured, I can easily push the numbers such that the array is [14,1,1,1] it satisfies all the initial constrains for nums[i] > 0 and 1<=i<n. Why stop at [5,5,2,5]"
                    },
                    {
                        "username": "codelearner12345",
                        "content": "You can do that, but then the max value is 14, not 5. You want to minimize this maximum value, and you can\\'t get lower than 5 in that example."
                    },
                    {
                        "username": "codelearner12345",
                        "content": "I don\\'t think the problem itself is inherently bad, but the hint is definitely misleading. It\\'s much easier to look for an O(n) solution than a binary search. The examples could also be more detailed."
                    },
                    {
                        "username": "josh10187",
                        "content": "Not sure what I am doing wrong, my ans is always 1 off on testcase 31? \\n `ans = 0\\n  sums = 0\\n\\n  for i in range(len(len(nums)):\\n          sums += nums[i]\\n          ans = max(ans, (sums / (i + 1))\\n\\nreturn ans\\n`"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "try (sums+i)/(i+1)"
                    },
                    {
                        "username": "Entrropic",
                        "content": "I'll share my thoughts and my approach (O(N) time and O(1) space):\n\n1. If there wasn't a limitation that you can only use elements to the left of selected nums[i], the solution could be calculated as `ceil(sum(nums)/len(nums))` - as you would be able to \"spread\" numbers as evenly as possible across the whole array;\n2. Due to the limitations, you need to double check if `ceil(sum(nums[:i])/len(nums[:i]))` is achievable for subarray to the left of \"i\". For example, for [10,1]  `ceil(sum(nums[:2])/len(nums[:2]))` would be 6, but `ceil(sum(nums[:1])/len(nums[:1]))` is 10, and that is the actual answer.\n3. The above idea provides an approach that can be used: calculate sum and length of array and store them. Then use for loop from nums.length-1 to 0 inclusive, and calculate the result of `ceil(stored_sum/stored_length)`, each time decreasing sum by nums[i] and length by 1. Store max result of dividing \"stored_sum\" by \"stored_length\" and return it in the end."
                    }
                ]
            },
            {
                "id": 1855125,
                "content": [
                    {
                        "username": "anandnit",
                        "content": "just dry run with the intutuion of binary search "
                    },
                    {
                        "username": "tonybuidn",
                        "content": "In my opinion, I think this is a tricky question because as we can see that, we need to execute operations to return the minimum possible value of the maximum integer of nums. So we just need to execute one operation at 4th index\\nWe have : [4,6,1,6] . So we just need to execute one operation at 3th index => [4,6,2,5] => so the maximum value of nums is 6 with only 1 operation. So why do we need to execute to 3 operations to get only 5???? Thanks for pointing which one that makes my logic wrong."
                    },
                    {
                        "username": "tejasX",
                        "content": "Is it suitably medium ? I found it Hard in one go."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "leetcode needs to go to duolingo(what in the world is this english??)."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Thinking on my life choices now..."
                    },
                    {
                        "username": "user3475tK",
                        "content": "[4,7,2,2,9,19,16,0,3,15]. \nHow is ans 9 possible here? I believe we can't decrease 19 to below 10 as previous no will increase and become more than 9 even if we are able to have it as 0 by previous processing"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Here's one of the ways to get maximum of 9:\n\n1. Transfer 6 from 15 to 3 (now both are 9)\n2. Transfer 7 from 16 to 19 (now 16 is 9 and 19 is 26)\n3. Transfer 17 from 26 to 9 (now 26 is 9 and 9 is 26)\n4. Transfer 17 from 26 to 2 (now 26 is 9 and 2 is 19)\n5. Transfer 10 from 19 to left 2 (now 19 is 9 and left 2 is 12)\n6. Transfer 3 from 12 to 7 (now 12 is 9 and 7 is 10)\n7. Transfer 1 from 10 to 4. (now 10 is 9 and 4 is 5)\n\nSo in the end it's [5, 9, 9, 9, 9, 9, 9, 0, 9, 9]\nAnd while it's possible to reduce some of 9s to 8, you can't reduce *all* of 9s which are to the left of 0. So, the answer is 9."
                    },
                    {
                        "username": "psat",
                        "content": "The way this question is structured, I can easily push the numbers such that the array is [14,1,1,1] it satisfies all the initial constrains for nums[i] > 0 and 1<=i<n. Why stop at [5,5,2,5]"
                    },
                    {
                        "username": "codelearner12345",
                        "content": "You can do that, but then the max value is 14, not 5. You want to minimize this maximum value, and you can\\'t get lower than 5 in that example."
                    },
                    {
                        "username": "codelearner12345",
                        "content": "I don\\'t think the problem itself is inherently bad, but the hint is definitely misleading. It\\'s much easier to look for an O(n) solution than a binary search. The examples could also be more detailed."
                    },
                    {
                        "username": "josh10187",
                        "content": "Not sure what I am doing wrong, my ans is always 1 off on testcase 31? \\n `ans = 0\\n  sums = 0\\n\\n  for i in range(len(len(nums)):\\n          sums += nums[i]\\n          ans = max(ans, (sums / (i + 1))\\n\\nreturn ans\\n`"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "try (sums+i)/(i+1)"
                    },
                    {
                        "username": "Entrropic",
                        "content": "I'll share my thoughts and my approach (O(N) time and O(1) space):\n\n1. If there wasn't a limitation that you can only use elements to the left of selected nums[i], the solution could be calculated as `ceil(sum(nums)/len(nums))` - as you would be able to \"spread\" numbers as evenly as possible across the whole array;\n2. Due to the limitations, you need to double check if `ceil(sum(nums[:i])/len(nums[:i]))` is achievable for subarray to the left of \"i\". For example, for [10,1]  `ceil(sum(nums[:2])/len(nums[:2]))` would be 6, but `ceil(sum(nums[:1])/len(nums[:1]))` is 10, and that is the actual answer.\n3. The above idea provides an approach that can be used: calculate sum and length of array and store them. Then use for loop from nums.length-1 to 0 inclusive, and calculate the result of `ceil(stored_sum/stored_length)`, each time decreasing sum by nums[i] and length by 1. Store max result of dividing \"stored_sum\" by \"stored_length\" and return it in the end."
                    }
                ]
            },
            {
                "id": 1855069,
                "content": [
                    {
                        "username": "anandnit",
                        "content": "just dry run with the intutuion of binary search "
                    },
                    {
                        "username": "tonybuidn",
                        "content": "In my opinion, I think this is a tricky question because as we can see that, we need to execute operations to return the minimum possible value of the maximum integer of nums. So we just need to execute one operation at 4th index\\nWe have : [4,6,1,6] . So we just need to execute one operation at 3th index => [4,6,2,5] => so the maximum value of nums is 6 with only 1 operation. So why do we need to execute to 3 operations to get only 5???? Thanks for pointing which one that makes my logic wrong."
                    },
                    {
                        "username": "tejasX",
                        "content": "Is it suitably medium ? I found it Hard in one go."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "leetcode needs to go to duolingo(what in the world is this english??)."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Thinking on my life choices now..."
                    },
                    {
                        "username": "user3475tK",
                        "content": "[4,7,2,2,9,19,16,0,3,15]. \nHow is ans 9 possible here? I believe we can't decrease 19 to below 10 as previous no will increase and become more than 9 even if we are able to have it as 0 by previous processing"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Here's one of the ways to get maximum of 9:\n\n1. Transfer 6 from 15 to 3 (now both are 9)\n2. Transfer 7 from 16 to 19 (now 16 is 9 and 19 is 26)\n3. Transfer 17 from 26 to 9 (now 26 is 9 and 9 is 26)\n4. Transfer 17 from 26 to 2 (now 26 is 9 and 2 is 19)\n5. Transfer 10 from 19 to left 2 (now 19 is 9 and left 2 is 12)\n6. Transfer 3 from 12 to 7 (now 12 is 9 and 7 is 10)\n7. Transfer 1 from 10 to 4. (now 10 is 9 and 4 is 5)\n\nSo in the end it's [5, 9, 9, 9, 9, 9, 9, 0, 9, 9]\nAnd while it's possible to reduce some of 9s to 8, you can't reduce *all* of 9s which are to the left of 0. So, the answer is 9."
                    },
                    {
                        "username": "psat",
                        "content": "The way this question is structured, I can easily push the numbers such that the array is [14,1,1,1] it satisfies all the initial constrains for nums[i] > 0 and 1<=i<n. Why stop at [5,5,2,5]"
                    },
                    {
                        "username": "codelearner12345",
                        "content": "You can do that, but then the max value is 14, not 5. You want to minimize this maximum value, and you can\\'t get lower than 5 in that example."
                    },
                    {
                        "username": "codelearner12345",
                        "content": "I don\\'t think the problem itself is inherently bad, but the hint is definitely misleading. It\\'s much easier to look for an O(n) solution than a binary search. The examples could also be more detailed."
                    },
                    {
                        "username": "josh10187",
                        "content": "Not sure what I am doing wrong, my ans is always 1 off on testcase 31? \\n `ans = 0\\n  sums = 0\\n\\n  for i in range(len(len(nums)):\\n          sums += nums[i]\\n          ans = max(ans, (sums / (i + 1))\\n\\nreturn ans\\n`"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "try (sums+i)/(i+1)"
                    },
                    {
                        "username": "Entrropic",
                        "content": "I'll share my thoughts and my approach (O(N) time and O(1) space):\n\n1. If there wasn't a limitation that you can only use elements to the left of selected nums[i], the solution could be calculated as `ceil(sum(nums)/len(nums))` - as you would be able to \"spread\" numbers as evenly as possible across the whole array;\n2. Due to the limitations, you need to double check if `ceil(sum(nums[:i])/len(nums[:i]))` is achievable for subarray to the left of \"i\". For example, for [10,1]  `ceil(sum(nums[:2])/len(nums[:2]))` would be 6, but `ceil(sum(nums[:1])/len(nums[:1]))` is 10, and that is the actual answer.\n3. The above idea provides an approach that can be used: calculate sum and length of array and store them. Then use for loop from nums.length-1 to 0 inclusive, and calculate the result of `ceil(stored_sum/stored_length)`, each time decreasing sum by nums[i] and length by 1. Store max result of dividing \"stored_sum\" by \"stored_length\" and return it in the end."
                    }
                ]
            },
            {
                "id": 1855048,
                "content": [
                    {
                        "username": "anandnit",
                        "content": "just dry run with the intutuion of binary search "
                    },
                    {
                        "username": "tonybuidn",
                        "content": "In my opinion, I think this is a tricky question because as we can see that, we need to execute operations to return the minimum possible value of the maximum integer of nums. So we just need to execute one operation at 4th index\\nWe have : [4,6,1,6] . So we just need to execute one operation at 3th index => [4,6,2,5] => so the maximum value of nums is 6 with only 1 operation. So why do we need to execute to 3 operations to get only 5???? Thanks for pointing which one that makes my logic wrong."
                    },
                    {
                        "username": "tejasX",
                        "content": "Is it suitably medium ? I found it Hard in one go."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "leetcode needs to go to duolingo(what in the world is this english??)."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Thinking on my life choices now..."
                    },
                    {
                        "username": "user3475tK",
                        "content": "[4,7,2,2,9,19,16,0,3,15]. \nHow is ans 9 possible here? I believe we can't decrease 19 to below 10 as previous no will increase and become more than 9 even if we are able to have it as 0 by previous processing"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Here's one of the ways to get maximum of 9:\n\n1. Transfer 6 from 15 to 3 (now both are 9)\n2. Transfer 7 from 16 to 19 (now 16 is 9 and 19 is 26)\n3. Transfer 17 from 26 to 9 (now 26 is 9 and 9 is 26)\n4. Transfer 17 from 26 to 2 (now 26 is 9 and 2 is 19)\n5. Transfer 10 from 19 to left 2 (now 19 is 9 and left 2 is 12)\n6. Transfer 3 from 12 to 7 (now 12 is 9 and 7 is 10)\n7. Transfer 1 from 10 to 4. (now 10 is 9 and 4 is 5)\n\nSo in the end it's [5, 9, 9, 9, 9, 9, 9, 0, 9, 9]\nAnd while it's possible to reduce some of 9s to 8, you can't reduce *all* of 9s which are to the left of 0. So, the answer is 9."
                    },
                    {
                        "username": "psat",
                        "content": "The way this question is structured, I can easily push the numbers such that the array is [14,1,1,1] it satisfies all the initial constrains for nums[i] > 0 and 1<=i<n. Why stop at [5,5,2,5]"
                    },
                    {
                        "username": "codelearner12345",
                        "content": "You can do that, but then the max value is 14, not 5. You want to minimize this maximum value, and you can\\'t get lower than 5 in that example."
                    },
                    {
                        "username": "codelearner12345",
                        "content": "I don\\'t think the problem itself is inherently bad, but the hint is definitely misleading. It\\'s much easier to look for an O(n) solution than a binary search. The examples could also be more detailed."
                    },
                    {
                        "username": "josh10187",
                        "content": "Not sure what I am doing wrong, my ans is always 1 off on testcase 31? \\n `ans = 0\\n  sums = 0\\n\\n  for i in range(len(len(nums)):\\n          sums += nums[i]\\n          ans = max(ans, (sums / (i + 1))\\n\\nreturn ans\\n`"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "try (sums+i)/(i+1)"
                    },
                    {
                        "username": "Entrropic",
                        "content": "I'll share my thoughts and my approach (O(N) time and O(1) space):\n\n1. If there wasn't a limitation that you can only use elements to the left of selected nums[i], the solution could be calculated as `ceil(sum(nums)/len(nums))` - as you would be able to \"spread\" numbers as evenly as possible across the whole array;\n2. Due to the limitations, you need to double check if `ceil(sum(nums[:i])/len(nums[:i]))` is achievable for subarray to the left of \"i\". For example, for [10,1]  `ceil(sum(nums[:2])/len(nums[:2]))` would be 6, but `ceil(sum(nums[:1])/len(nums[:1]))` is 10, and that is the actual answer.\n3. The above idea provides an approach that can be used: calculate sum and length of array and store them. Then use for loop from nums.length-1 to 0 inclusive, and calculate the result of `ceil(stored_sum/stored_length)`, each time decreasing sum by nums[i] and length by 1. Store max result of dividing \"stored_sum\" by \"stored_length\" and return it in the end."
                    }
                ]
            },
            {
                "id": 1855023,
                "content": [
                    {
                        "username": "anandnit",
                        "content": "just dry run with the intutuion of binary search "
                    },
                    {
                        "username": "tonybuidn",
                        "content": "In my opinion, I think this is a tricky question because as we can see that, we need to execute operations to return the minimum possible value of the maximum integer of nums. So we just need to execute one operation at 4th index\\nWe have : [4,6,1,6] . So we just need to execute one operation at 3th index => [4,6,2,5] => so the maximum value of nums is 6 with only 1 operation. So why do we need to execute to 3 operations to get only 5???? Thanks for pointing which one that makes my logic wrong."
                    },
                    {
                        "username": "tejasX",
                        "content": "Is it suitably medium ? I found it Hard in one go."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "leetcode needs to go to duolingo(what in the world is this english??)."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Thinking on my life choices now..."
                    },
                    {
                        "username": "user3475tK",
                        "content": "[4,7,2,2,9,19,16,0,3,15]. \nHow is ans 9 possible here? I believe we can't decrease 19 to below 10 as previous no will increase and become more than 9 even if we are able to have it as 0 by previous processing"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Here's one of the ways to get maximum of 9:\n\n1. Transfer 6 from 15 to 3 (now both are 9)\n2. Transfer 7 from 16 to 19 (now 16 is 9 and 19 is 26)\n3. Transfer 17 from 26 to 9 (now 26 is 9 and 9 is 26)\n4. Transfer 17 from 26 to 2 (now 26 is 9 and 2 is 19)\n5. Transfer 10 from 19 to left 2 (now 19 is 9 and left 2 is 12)\n6. Transfer 3 from 12 to 7 (now 12 is 9 and 7 is 10)\n7. Transfer 1 from 10 to 4. (now 10 is 9 and 4 is 5)\n\nSo in the end it's [5, 9, 9, 9, 9, 9, 9, 0, 9, 9]\nAnd while it's possible to reduce some of 9s to 8, you can't reduce *all* of 9s which are to the left of 0. So, the answer is 9."
                    },
                    {
                        "username": "psat",
                        "content": "The way this question is structured, I can easily push the numbers such that the array is [14,1,1,1] it satisfies all the initial constrains for nums[i] > 0 and 1<=i<n. Why stop at [5,5,2,5]"
                    },
                    {
                        "username": "codelearner12345",
                        "content": "You can do that, but then the max value is 14, not 5. You want to minimize this maximum value, and you can\\'t get lower than 5 in that example."
                    },
                    {
                        "username": "codelearner12345",
                        "content": "I don\\'t think the problem itself is inherently bad, but the hint is definitely misleading. It\\'s much easier to look for an O(n) solution than a binary search. The examples could also be more detailed."
                    },
                    {
                        "username": "josh10187",
                        "content": "Not sure what I am doing wrong, my ans is always 1 off on testcase 31? \\n `ans = 0\\n  sums = 0\\n\\n  for i in range(len(len(nums)):\\n          sums += nums[i]\\n          ans = max(ans, (sums / (i + 1))\\n\\nreturn ans\\n`"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "try (sums+i)/(i+1)"
                    },
                    {
                        "username": "Entrropic",
                        "content": "I'll share my thoughts and my approach (O(N) time and O(1) space):\n\n1. If there wasn't a limitation that you can only use elements to the left of selected nums[i], the solution could be calculated as `ceil(sum(nums)/len(nums))` - as you would be able to \"spread\" numbers as evenly as possible across the whole array;\n2. Due to the limitations, you need to double check if `ceil(sum(nums[:i])/len(nums[:i]))` is achievable for subarray to the left of \"i\". For example, for [10,1]  `ceil(sum(nums[:2])/len(nums[:2]))` would be 6, but `ceil(sum(nums[:1])/len(nums[:1]))` is 10, and that is the actual answer.\n3. The above idea provides an approach that can be used: calculate sum and length of array and store them. Then use for loop from nums.length-1 to 0 inclusive, and calculate the result of `ceil(stored_sum/stored_length)`, each time decreasing sum by nums[i] and length by 1. Store max result of dividing \"stored_sum\" by \"stored_length\" and return it in the end."
                    }
                ]
            },
            {
                "id": 1855016,
                "content": [
                    {
                        "username": "anandnit",
                        "content": "just dry run with the intutuion of binary search "
                    },
                    {
                        "username": "tonybuidn",
                        "content": "In my opinion, I think this is a tricky question because as we can see that, we need to execute operations to return the minimum possible value of the maximum integer of nums. So we just need to execute one operation at 4th index\\nWe have : [4,6,1,6] . So we just need to execute one operation at 3th index => [4,6,2,5] => so the maximum value of nums is 6 with only 1 operation. So why do we need to execute to 3 operations to get only 5???? Thanks for pointing which one that makes my logic wrong."
                    },
                    {
                        "username": "tejasX",
                        "content": "Is it suitably medium ? I found it Hard in one go."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "leetcode needs to go to duolingo(what in the world is this english??)."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Thinking on my life choices now..."
                    },
                    {
                        "username": "user3475tK",
                        "content": "[4,7,2,2,9,19,16,0,3,15]. \nHow is ans 9 possible here? I believe we can't decrease 19 to below 10 as previous no will increase and become more than 9 even if we are able to have it as 0 by previous processing"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Here's one of the ways to get maximum of 9:\n\n1. Transfer 6 from 15 to 3 (now both are 9)\n2. Transfer 7 from 16 to 19 (now 16 is 9 and 19 is 26)\n3. Transfer 17 from 26 to 9 (now 26 is 9 and 9 is 26)\n4. Transfer 17 from 26 to 2 (now 26 is 9 and 2 is 19)\n5. Transfer 10 from 19 to left 2 (now 19 is 9 and left 2 is 12)\n6. Transfer 3 from 12 to 7 (now 12 is 9 and 7 is 10)\n7. Transfer 1 from 10 to 4. (now 10 is 9 and 4 is 5)\n\nSo in the end it's [5, 9, 9, 9, 9, 9, 9, 0, 9, 9]\nAnd while it's possible to reduce some of 9s to 8, you can't reduce *all* of 9s which are to the left of 0. So, the answer is 9."
                    },
                    {
                        "username": "psat",
                        "content": "The way this question is structured, I can easily push the numbers such that the array is [14,1,1,1] it satisfies all the initial constrains for nums[i] > 0 and 1<=i<n. Why stop at [5,5,2,5]"
                    },
                    {
                        "username": "codelearner12345",
                        "content": "You can do that, but then the max value is 14, not 5. You want to minimize this maximum value, and you can\\'t get lower than 5 in that example."
                    },
                    {
                        "username": "codelearner12345",
                        "content": "I don\\'t think the problem itself is inherently bad, but the hint is definitely misleading. It\\'s much easier to look for an O(n) solution than a binary search. The examples could also be more detailed."
                    },
                    {
                        "username": "josh10187",
                        "content": "Not sure what I am doing wrong, my ans is always 1 off on testcase 31? \\n `ans = 0\\n  sums = 0\\n\\n  for i in range(len(len(nums)):\\n          sums += nums[i]\\n          ans = max(ans, (sums / (i + 1))\\n\\nreturn ans\\n`"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "try (sums+i)/(i+1)"
                    },
                    {
                        "username": "Entrropic",
                        "content": "I'll share my thoughts and my approach (O(N) time and O(1) space):\n\n1. If there wasn't a limitation that you can only use elements to the left of selected nums[i], the solution could be calculated as `ceil(sum(nums)/len(nums))` - as you would be able to \"spread\" numbers as evenly as possible across the whole array;\n2. Due to the limitations, you need to double check if `ceil(sum(nums[:i])/len(nums[:i]))` is achievable for subarray to the left of \"i\". For example, for [10,1]  `ceil(sum(nums[:2])/len(nums[:2]))` would be 6, but `ceil(sum(nums[:1])/len(nums[:1]))` is 10, and that is the actual answer.\n3. The above idea provides an approach that can be used: calculate sum and length of array and store them. Then use for loop from nums.length-1 to 0 inclusive, and calculate the result of `ceil(stored_sum/stored_length)`, each time decreasing sum by nums[i] and length by 1. Store max result of dividing \"stored_sum\" by \"stored_length\" and return it in the end."
                    }
                ]
            },
            {
                "id": 1854954,
                "content": [
                    {
                        "username": "anandnit",
                        "content": "just dry run with the intutuion of binary search "
                    },
                    {
                        "username": "tonybuidn",
                        "content": "In my opinion, I think this is a tricky question because as we can see that, we need to execute operations to return the minimum possible value of the maximum integer of nums. So we just need to execute one operation at 4th index\\nWe have : [4,6,1,6] . So we just need to execute one operation at 3th index => [4,6,2,5] => so the maximum value of nums is 6 with only 1 operation. So why do we need to execute to 3 operations to get only 5???? Thanks for pointing which one that makes my logic wrong."
                    },
                    {
                        "username": "tejasX",
                        "content": "Is it suitably medium ? I found it Hard in one go."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "leetcode needs to go to duolingo(what in the world is this english??)."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Thinking on my life choices now..."
                    },
                    {
                        "username": "user3475tK",
                        "content": "[4,7,2,2,9,19,16,0,3,15]. \nHow is ans 9 possible here? I believe we can't decrease 19 to below 10 as previous no will increase and become more than 9 even if we are able to have it as 0 by previous processing"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Here's one of the ways to get maximum of 9:\n\n1. Transfer 6 from 15 to 3 (now both are 9)\n2. Transfer 7 from 16 to 19 (now 16 is 9 and 19 is 26)\n3. Transfer 17 from 26 to 9 (now 26 is 9 and 9 is 26)\n4. Transfer 17 from 26 to 2 (now 26 is 9 and 2 is 19)\n5. Transfer 10 from 19 to left 2 (now 19 is 9 and left 2 is 12)\n6. Transfer 3 from 12 to 7 (now 12 is 9 and 7 is 10)\n7. Transfer 1 from 10 to 4. (now 10 is 9 and 4 is 5)\n\nSo in the end it's [5, 9, 9, 9, 9, 9, 9, 0, 9, 9]\nAnd while it's possible to reduce some of 9s to 8, you can't reduce *all* of 9s which are to the left of 0. So, the answer is 9."
                    },
                    {
                        "username": "psat",
                        "content": "The way this question is structured, I can easily push the numbers such that the array is [14,1,1,1] it satisfies all the initial constrains for nums[i] > 0 and 1<=i<n. Why stop at [5,5,2,5]"
                    },
                    {
                        "username": "codelearner12345",
                        "content": "You can do that, but then the max value is 14, not 5. You want to minimize this maximum value, and you can\\'t get lower than 5 in that example."
                    },
                    {
                        "username": "codelearner12345",
                        "content": "I don\\'t think the problem itself is inherently bad, but the hint is definitely misleading. It\\'s much easier to look for an O(n) solution than a binary search. The examples could also be more detailed."
                    },
                    {
                        "username": "josh10187",
                        "content": "Not sure what I am doing wrong, my ans is always 1 off on testcase 31? \\n `ans = 0\\n  sums = 0\\n\\n  for i in range(len(len(nums)):\\n          sums += nums[i]\\n          ans = max(ans, (sums / (i + 1))\\n\\nreturn ans\\n`"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "try (sums+i)/(i+1)"
                    },
                    {
                        "username": "Entrropic",
                        "content": "I'll share my thoughts and my approach (O(N) time and O(1) space):\n\n1. If there wasn't a limitation that you can only use elements to the left of selected nums[i], the solution could be calculated as `ceil(sum(nums)/len(nums))` - as you would be able to \"spread\" numbers as evenly as possible across the whole array;\n2. Due to the limitations, you need to double check if `ceil(sum(nums[:i])/len(nums[:i]))` is achievable for subarray to the left of \"i\". For example, for [10,1]  `ceil(sum(nums[:2])/len(nums[:2]))` would be 6, but `ceil(sum(nums[:1])/len(nums[:1]))` is 10, and that is the actual answer.\n3. The above idea provides an approach that can be used: calculate sum and length of array and store them. Then use for loop from nums.length-1 to 0 inclusive, and calculate the result of `ceil(stored_sum/stored_length)`, each time decreasing sum by nums[i] and length by 1. Store max result of dividing \"stored_sum\" by \"stored_length\" and return it in the end."
                    }
                ]
            },
            {
                "id": 1854935,
                "content": [
                    {
                        "username": "anandnit",
                        "content": "just dry run with the intutuion of binary search "
                    },
                    {
                        "username": "tonybuidn",
                        "content": "In my opinion, I think this is a tricky question because as we can see that, we need to execute operations to return the minimum possible value of the maximum integer of nums. So we just need to execute one operation at 4th index\\nWe have : [4,6,1,6] . So we just need to execute one operation at 3th index => [4,6,2,5] => so the maximum value of nums is 6 with only 1 operation. So why do we need to execute to 3 operations to get only 5???? Thanks for pointing which one that makes my logic wrong."
                    },
                    {
                        "username": "tejasX",
                        "content": "Is it suitably medium ? I found it Hard in one go."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "leetcode needs to go to duolingo(what in the world is this english??)."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Thinking on my life choices now..."
                    },
                    {
                        "username": "user3475tK",
                        "content": "[4,7,2,2,9,19,16,0,3,15]. \nHow is ans 9 possible here? I believe we can't decrease 19 to below 10 as previous no will increase and become more than 9 even if we are able to have it as 0 by previous processing"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Here's one of the ways to get maximum of 9:\n\n1. Transfer 6 from 15 to 3 (now both are 9)\n2. Transfer 7 from 16 to 19 (now 16 is 9 and 19 is 26)\n3. Transfer 17 from 26 to 9 (now 26 is 9 and 9 is 26)\n4. Transfer 17 from 26 to 2 (now 26 is 9 and 2 is 19)\n5. Transfer 10 from 19 to left 2 (now 19 is 9 and left 2 is 12)\n6. Transfer 3 from 12 to 7 (now 12 is 9 and 7 is 10)\n7. Transfer 1 from 10 to 4. (now 10 is 9 and 4 is 5)\n\nSo in the end it's [5, 9, 9, 9, 9, 9, 9, 0, 9, 9]\nAnd while it's possible to reduce some of 9s to 8, you can't reduce *all* of 9s which are to the left of 0. So, the answer is 9."
                    },
                    {
                        "username": "psat",
                        "content": "The way this question is structured, I can easily push the numbers such that the array is [14,1,1,1] it satisfies all the initial constrains for nums[i] > 0 and 1<=i<n. Why stop at [5,5,2,5]"
                    },
                    {
                        "username": "codelearner12345",
                        "content": "You can do that, but then the max value is 14, not 5. You want to minimize this maximum value, and you can\\'t get lower than 5 in that example."
                    },
                    {
                        "username": "codelearner12345",
                        "content": "I don\\'t think the problem itself is inherently bad, but the hint is definitely misleading. It\\'s much easier to look for an O(n) solution than a binary search. The examples could also be more detailed."
                    },
                    {
                        "username": "josh10187",
                        "content": "Not sure what I am doing wrong, my ans is always 1 off on testcase 31? \\n `ans = 0\\n  sums = 0\\n\\n  for i in range(len(len(nums)):\\n          sums += nums[i]\\n          ans = max(ans, (sums / (i + 1))\\n\\nreturn ans\\n`"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "try (sums+i)/(i+1)"
                    },
                    {
                        "username": "Entrropic",
                        "content": "I'll share my thoughts and my approach (O(N) time and O(1) space):\n\n1. If there wasn't a limitation that you can only use elements to the left of selected nums[i], the solution could be calculated as `ceil(sum(nums)/len(nums))` - as you would be able to \"spread\" numbers as evenly as possible across the whole array;\n2. Due to the limitations, you need to double check if `ceil(sum(nums[:i])/len(nums[:i]))` is achievable for subarray to the left of \"i\". For example, for [10,1]  `ceil(sum(nums[:2])/len(nums[:2]))` would be 6, but `ceil(sum(nums[:1])/len(nums[:1]))` is 10, and that is the actual answer.\n3. The above idea provides an approach that can be used: calculate sum and length of array and store them. Then use for loop from nums.length-1 to 0 inclusive, and calculate the result of `ceil(stored_sum/stored_length)`, each time decreasing sum by nums[i] and length by 1. Store max result of dividing \"stored_sum\" by \"stored_length\" and return it in the end."
                    }
                ]
            },
            {
                "id": 1854884,
                "content": [
                    {
                        "username": "SeaShanty",
                        "content": "I have seen these types of \\' *any number of operation* \\' questions appear a lot on leetcode coding challenges. Can anyone suggest a common approach to these problem or a question set of similar problems or something? Help this beginner out :)"
                    },
                    {
                        "username": "palak-agg",
                        "content": "class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        int sum=nums[0];\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            sum+=nums[i];\\n            res=Math.max(res,(int)Math.ceil(sum/(i+1)));\\n        }\\n        return res;\\n    }\\n}\\n\\nCan someone please tell what\\'s wrong with this code?"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Can anyone provide the code for brute force approach? i have understood the approach but i m not able to code it."
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "explain approach"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "For those who are stuck, consider the test cases:\n\n[2, 3, 4]\n[4, 3, 2]\n[2, 4, 3]\n[20, 1, 30]\n\n...and see if you can find any patterns that you can take advantage of."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "1) Why is the case i = 2 not suitable, because 1<=i<n\n2) Why does the condition say \"nums[i] > 0.\" but we already have a non-negative array?\n\nUPD: The first question is solved. i = 2 we can use, in this case:\n[3, 7, 1, 6] -> [3, 6, 0, 6] -> [4, 5, 1, 5] -> [5, 4, 2, 4] -> End\n\nThis case suggested the idea: find the index of the maximum through bs and apply the algorithm until the index != 0"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is the most elegant DP problem I\\'ve ever seen, so far."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Anybody else facing the issue with submissions to this question?I am getting wrong answer, but when i use cout statement it is giving correct answer then and displaying the true result of my program."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was HARD\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "This feels like a purely logic+ math  based sum"
                    },
                    {
                        "username": "Chibix",
                        "content": "Hello guys, may someone help me please, I don\\'t understand why in this input : [13,13,20,0,8,9,9] the output must be 16 whereas we could reach 14 (isn\\'t it ?) Thank you in advance ! :) "
                    },
                    {
                        "username": "Chibix",
                        "content": "[@rishi_058](/rishi_058) Ok thx bro ! "
                    },
                    {
                        "username": "rishi_058",
                        "content": "[@Chibix](/Chibix) You can\\'t sort the given array "
                    },
                    {
                        "username": "Chibix",
                        "content": "here is the steps for input = [13,13,20,0,8,9,9] :\\n\\nnums [0, 8, 9, 9, 13, 13, 20]\\nnums [4, 4, 9, 9, 13, 13, 20]\\nnums [4, 7, 6, 9, 13, 13, 20]\\nnums [4, 7, 8, 7, 13, 13, 20]\\nnums [4, 7, 8, 10, 10, 13, 20]\\nnums [4, 7, 8, 10, 12, 11, 20]\\nnums [4, 7, 8, 10, 12, 15, 16]\\nnums [6, 5, 8, 10, 12, 15, 16]\\nnums [6, 7, 6, 10, 12, 15, 16]\\nnums [6, 7, 8, 8, 12, 15, 16]\\nnums [6, 7, 8, 10, 10, 15, 16]\\nnums [6, 7, 8, 10, 13, 12, 16]\\nfinal nums : [6, 7, 8, 10, 13, 14, 14]"
                    }
                ]
            },
            {
                "id": 1854861,
                "content": [
                    {
                        "username": "SeaShanty",
                        "content": "I have seen these types of \\' *any number of operation* \\' questions appear a lot on leetcode coding challenges. Can anyone suggest a common approach to these problem or a question set of similar problems or something? Help this beginner out :)"
                    },
                    {
                        "username": "palak-agg",
                        "content": "class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        int sum=nums[0];\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            sum+=nums[i];\\n            res=Math.max(res,(int)Math.ceil(sum/(i+1)));\\n        }\\n        return res;\\n    }\\n}\\n\\nCan someone please tell what\\'s wrong with this code?"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Can anyone provide the code for brute force approach? i have understood the approach but i m not able to code it."
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "explain approach"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "For those who are stuck, consider the test cases:\n\n[2, 3, 4]\n[4, 3, 2]\n[2, 4, 3]\n[20, 1, 30]\n\n...and see if you can find any patterns that you can take advantage of."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "1) Why is the case i = 2 not suitable, because 1<=i<n\n2) Why does the condition say \"nums[i] > 0.\" but we already have a non-negative array?\n\nUPD: The first question is solved. i = 2 we can use, in this case:\n[3, 7, 1, 6] -> [3, 6, 0, 6] -> [4, 5, 1, 5] -> [5, 4, 2, 4] -> End\n\nThis case suggested the idea: find the index of the maximum through bs and apply the algorithm until the index != 0"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is the most elegant DP problem I\\'ve ever seen, so far."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Anybody else facing the issue with submissions to this question?I am getting wrong answer, but when i use cout statement it is giving correct answer then and displaying the true result of my program."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was HARD\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "This feels like a purely logic+ math  based sum"
                    },
                    {
                        "username": "Chibix",
                        "content": "Hello guys, may someone help me please, I don\\'t understand why in this input : [13,13,20,0,8,9,9] the output must be 16 whereas we could reach 14 (isn\\'t it ?) Thank you in advance ! :) "
                    },
                    {
                        "username": "Chibix",
                        "content": "[@rishi_058](/rishi_058) Ok thx bro ! "
                    },
                    {
                        "username": "rishi_058",
                        "content": "[@Chibix](/Chibix) You can\\'t sort the given array "
                    },
                    {
                        "username": "Chibix",
                        "content": "here is the steps for input = [13,13,20,0,8,9,9] :\\n\\nnums [0, 8, 9, 9, 13, 13, 20]\\nnums [4, 4, 9, 9, 13, 13, 20]\\nnums [4, 7, 6, 9, 13, 13, 20]\\nnums [4, 7, 8, 7, 13, 13, 20]\\nnums [4, 7, 8, 10, 10, 13, 20]\\nnums [4, 7, 8, 10, 12, 11, 20]\\nnums [4, 7, 8, 10, 12, 15, 16]\\nnums [6, 5, 8, 10, 12, 15, 16]\\nnums [6, 7, 6, 10, 12, 15, 16]\\nnums [6, 7, 8, 8, 12, 15, 16]\\nnums [6, 7, 8, 10, 10, 15, 16]\\nnums [6, 7, 8, 10, 13, 12, 16]\\nfinal nums : [6, 7, 8, 10, 13, 14, 14]"
                    }
                ]
            },
            {
                "id": 1854798,
                "content": [
                    {
                        "username": "SeaShanty",
                        "content": "I have seen these types of \\' *any number of operation* \\' questions appear a lot on leetcode coding challenges. Can anyone suggest a common approach to these problem or a question set of similar problems or something? Help this beginner out :)"
                    },
                    {
                        "username": "palak-agg",
                        "content": "class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        int sum=nums[0];\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            sum+=nums[i];\\n            res=Math.max(res,(int)Math.ceil(sum/(i+1)));\\n        }\\n        return res;\\n    }\\n}\\n\\nCan someone please tell what\\'s wrong with this code?"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Can anyone provide the code for brute force approach? i have understood the approach but i m not able to code it."
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "explain approach"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "For those who are stuck, consider the test cases:\n\n[2, 3, 4]\n[4, 3, 2]\n[2, 4, 3]\n[20, 1, 30]\n\n...and see if you can find any patterns that you can take advantage of."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "1) Why is the case i = 2 not suitable, because 1<=i<n\n2) Why does the condition say \"nums[i] > 0.\" but we already have a non-negative array?\n\nUPD: The first question is solved. i = 2 we can use, in this case:\n[3, 7, 1, 6] -> [3, 6, 0, 6] -> [4, 5, 1, 5] -> [5, 4, 2, 4] -> End\n\nThis case suggested the idea: find the index of the maximum through bs and apply the algorithm until the index != 0"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is the most elegant DP problem I\\'ve ever seen, so far."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Anybody else facing the issue with submissions to this question?I am getting wrong answer, but when i use cout statement it is giving correct answer then and displaying the true result of my program."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was HARD\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "This feels like a purely logic+ math  based sum"
                    },
                    {
                        "username": "Chibix",
                        "content": "Hello guys, may someone help me please, I don\\'t understand why in this input : [13,13,20,0,8,9,9] the output must be 16 whereas we could reach 14 (isn\\'t it ?) Thank you in advance ! :) "
                    },
                    {
                        "username": "Chibix",
                        "content": "[@rishi_058](/rishi_058) Ok thx bro ! "
                    },
                    {
                        "username": "rishi_058",
                        "content": "[@Chibix](/Chibix) You can\\'t sort the given array "
                    },
                    {
                        "username": "Chibix",
                        "content": "here is the steps for input = [13,13,20,0,8,9,9] :\\n\\nnums [0, 8, 9, 9, 13, 13, 20]\\nnums [4, 4, 9, 9, 13, 13, 20]\\nnums [4, 7, 6, 9, 13, 13, 20]\\nnums [4, 7, 8, 7, 13, 13, 20]\\nnums [4, 7, 8, 10, 10, 13, 20]\\nnums [4, 7, 8, 10, 12, 11, 20]\\nnums [4, 7, 8, 10, 12, 15, 16]\\nnums [6, 5, 8, 10, 12, 15, 16]\\nnums [6, 7, 6, 10, 12, 15, 16]\\nnums [6, 7, 8, 8, 12, 15, 16]\\nnums [6, 7, 8, 10, 10, 15, 16]\\nnums [6, 7, 8, 10, 13, 12, 16]\\nfinal nums : [6, 7, 8, 10, 13, 14, 14]"
                    }
                ]
            },
            {
                "id": 1854770,
                "content": [
                    {
                        "username": "SeaShanty",
                        "content": "I have seen these types of \\' *any number of operation* \\' questions appear a lot on leetcode coding challenges. Can anyone suggest a common approach to these problem or a question set of similar problems or something? Help this beginner out :)"
                    },
                    {
                        "username": "palak-agg",
                        "content": "class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        int sum=nums[0];\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            sum+=nums[i];\\n            res=Math.max(res,(int)Math.ceil(sum/(i+1)));\\n        }\\n        return res;\\n    }\\n}\\n\\nCan someone please tell what\\'s wrong with this code?"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Can anyone provide the code for brute force approach? i have understood the approach but i m not able to code it."
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "explain approach"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "For those who are stuck, consider the test cases:\n\n[2, 3, 4]\n[4, 3, 2]\n[2, 4, 3]\n[20, 1, 30]\n\n...and see if you can find any patterns that you can take advantage of."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "1) Why is the case i = 2 not suitable, because 1<=i<n\n2) Why does the condition say \"nums[i] > 0.\" but we already have a non-negative array?\n\nUPD: The first question is solved. i = 2 we can use, in this case:\n[3, 7, 1, 6] -> [3, 6, 0, 6] -> [4, 5, 1, 5] -> [5, 4, 2, 4] -> End\n\nThis case suggested the idea: find the index of the maximum through bs and apply the algorithm until the index != 0"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is the most elegant DP problem I\\'ve ever seen, so far."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Anybody else facing the issue with submissions to this question?I am getting wrong answer, but when i use cout statement it is giving correct answer then and displaying the true result of my program."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was HARD\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "This feels like a purely logic+ math  based sum"
                    },
                    {
                        "username": "Chibix",
                        "content": "Hello guys, may someone help me please, I don\\'t understand why in this input : [13,13,20,0,8,9,9] the output must be 16 whereas we could reach 14 (isn\\'t it ?) Thank you in advance ! :) "
                    },
                    {
                        "username": "Chibix",
                        "content": "[@rishi_058](/rishi_058) Ok thx bro ! "
                    },
                    {
                        "username": "rishi_058",
                        "content": "[@Chibix](/Chibix) You can\\'t sort the given array "
                    },
                    {
                        "username": "Chibix",
                        "content": "here is the steps for input = [13,13,20,0,8,9,9] :\\n\\nnums [0, 8, 9, 9, 13, 13, 20]\\nnums [4, 4, 9, 9, 13, 13, 20]\\nnums [4, 7, 6, 9, 13, 13, 20]\\nnums [4, 7, 8, 7, 13, 13, 20]\\nnums [4, 7, 8, 10, 10, 13, 20]\\nnums [4, 7, 8, 10, 12, 11, 20]\\nnums [4, 7, 8, 10, 12, 15, 16]\\nnums [6, 5, 8, 10, 12, 15, 16]\\nnums [6, 7, 6, 10, 12, 15, 16]\\nnums [6, 7, 8, 8, 12, 15, 16]\\nnums [6, 7, 8, 10, 10, 15, 16]\\nnums [6, 7, 8, 10, 13, 12, 16]\\nfinal nums : [6, 7, 8, 10, 13, 14, 14]"
                    }
                ]
            },
            {
                "id": 1854759,
                "content": [
                    {
                        "username": "SeaShanty",
                        "content": "I have seen these types of \\' *any number of operation* \\' questions appear a lot on leetcode coding challenges. Can anyone suggest a common approach to these problem or a question set of similar problems or something? Help this beginner out :)"
                    },
                    {
                        "username": "palak-agg",
                        "content": "class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        int sum=nums[0];\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            sum+=nums[i];\\n            res=Math.max(res,(int)Math.ceil(sum/(i+1)));\\n        }\\n        return res;\\n    }\\n}\\n\\nCan someone please tell what\\'s wrong with this code?"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Can anyone provide the code for brute force approach? i have understood the approach but i m not able to code it."
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "explain approach"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "For those who are stuck, consider the test cases:\n\n[2, 3, 4]\n[4, 3, 2]\n[2, 4, 3]\n[20, 1, 30]\n\n...and see if you can find any patterns that you can take advantage of."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "1) Why is the case i = 2 not suitable, because 1<=i<n\n2) Why does the condition say \"nums[i] > 0.\" but we already have a non-negative array?\n\nUPD: The first question is solved. i = 2 we can use, in this case:\n[3, 7, 1, 6] -> [3, 6, 0, 6] -> [4, 5, 1, 5] -> [5, 4, 2, 4] -> End\n\nThis case suggested the idea: find the index of the maximum through bs and apply the algorithm until the index != 0"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is the most elegant DP problem I\\'ve ever seen, so far."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Anybody else facing the issue with submissions to this question?I am getting wrong answer, but when i use cout statement it is giving correct answer then and displaying the true result of my program."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was HARD\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "This feels like a purely logic+ math  based sum"
                    },
                    {
                        "username": "Chibix",
                        "content": "Hello guys, may someone help me please, I don\\'t understand why in this input : [13,13,20,0,8,9,9] the output must be 16 whereas we could reach 14 (isn\\'t it ?) Thank you in advance ! :) "
                    },
                    {
                        "username": "Chibix",
                        "content": "[@rishi_058](/rishi_058) Ok thx bro ! "
                    },
                    {
                        "username": "rishi_058",
                        "content": "[@Chibix](/Chibix) You can\\'t sort the given array "
                    },
                    {
                        "username": "Chibix",
                        "content": "here is the steps for input = [13,13,20,0,8,9,9] :\\n\\nnums [0, 8, 9, 9, 13, 13, 20]\\nnums [4, 4, 9, 9, 13, 13, 20]\\nnums [4, 7, 6, 9, 13, 13, 20]\\nnums [4, 7, 8, 7, 13, 13, 20]\\nnums [4, 7, 8, 10, 10, 13, 20]\\nnums [4, 7, 8, 10, 12, 11, 20]\\nnums [4, 7, 8, 10, 12, 15, 16]\\nnums [6, 5, 8, 10, 12, 15, 16]\\nnums [6, 7, 6, 10, 12, 15, 16]\\nnums [6, 7, 8, 8, 12, 15, 16]\\nnums [6, 7, 8, 10, 10, 15, 16]\\nnums [6, 7, 8, 10, 13, 12, 16]\\nfinal nums : [6, 7, 8, 10, 13, 14, 14]"
                    }
                ]
            },
            {
                "id": 1854756,
                "content": [
                    {
                        "username": "SeaShanty",
                        "content": "I have seen these types of \\' *any number of operation* \\' questions appear a lot on leetcode coding challenges. Can anyone suggest a common approach to these problem or a question set of similar problems or something? Help this beginner out :)"
                    },
                    {
                        "username": "palak-agg",
                        "content": "class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        int sum=nums[0];\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            sum+=nums[i];\\n            res=Math.max(res,(int)Math.ceil(sum/(i+1)));\\n        }\\n        return res;\\n    }\\n}\\n\\nCan someone please tell what\\'s wrong with this code?"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Can anyone provide the code for brute force approach? i have understood the approach but i m not able to code it."
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "explain approach"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "For those who are stuck, consider the test cases:\n\n[2, 3, 4]\n[4, 3, 2]\n[2, 4, 3]\n[20, 1, 30]\n\n...and see if you can find any patterns that you can take advantage of."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "1) Why is the case i = 2 not suitable, because 1<=i<n\n2) Why does the condition say \"nums[i] > 0.\" but we already have a non-negative array?\n\nUPD: The first question is solved. i = 2 we can use, in this case:\n[3, 7, 1, 6] -> [3, 6, 0, 6] -> [4, 5, 1, 5] -> [5, 4, 2, 4] -> End\n\nThis case suggested the idea: find the index of the maximum through bs and apply the algorithm until the index != 0"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is the most elegant DP problem I\\'ve ever seen, so far."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Anybody else facing the issue with submissions to this question?I am getting wrong answer, but when i use cout statement it is giving correct answer then and displaying the true result of my program."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was HARD\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "This feels like a purely logic+ math  based sum"
                    },
                    {
                        "username": "Chibix",
                        "content": "Hello guys, may someone help me please, I don\\'t understand why in this input : [13,13,20,0,8,9,9] the output must be 16 whereas we could reach 14 (isn\\'t it ?) Thank you in advance ! :) "
                    },
                    {
                        "username": "Chibix",
                        "content": "[@rishi_058](/rishi_058) Ok thx bro ! "
                    },
                    {
                        "username": "rishi_058",
                        "content": "[@Chibix](/Chibix) You can\\'t sort the given array "
                    },
                    {
                        "username": "Chibix",
                        "content": "here is the steps for input = [13,13,20,0,8,9,9] :\\n\\nnums [0, 8, 9, 9, 13, 13, 20]\\nnums [4, 4, 9, 9, 13, 13, 20]\\nnums [4, 7, 6, 9, 13, 13, 20]\\nnums [4, 7, 8, 7, 13, 13, 20]\\nnums [4, 7, 8, 10, 10, 13, 20]\\nnums [4, 7, 8, 10, 12, 11, 20]\\nnums [4, 7, 8, 10, 12, 15, 16]\\nnums [6, 5, 8, 10, 12, 15, 16]\\nnums [6, 7, 6, 10, 12, 15, 16]\\nnums [6, 7, 8, 8, 12, 15, 16]\\nnums [6, 7, 8, 10, 10, 15, 16]\\nnums [6, 7, 8, 10, 13, 12, 16]\\nfinal nums : [6, 7, 8, 10, 13, 14, 14]"
                    }
                ]
            },
            {
                "id": 1854694,
                "content": [
                    {
                        "username": "SeaShanty",
                        "content": "I have seen these types of \\' *any number of operation* \\' questions appear a lot on leetcode coding challenges. Can anyone suggest a common approach to these problem or a question set of similar problems or something? Help this beginner out :)"
                    },
                    {
                        "username": "palak-agg",
                        "content": "class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        int sum=nums[0];\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            sum+=nums[i];\\n            res=Math.max(res,(int)Math.ceil(sum/(i+1)));\\n        }\\n        return res;\\n    }\\n}\\n\\nCan someone please tell what\\'s wrong with this code?"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Can anyone provide the code for brute force approach? i have understood the approach but i m not able to code it."
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "explain approach"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "For those who are stuck, consider the test cases:\n\n[2, 3, 4]\n[4, 3, 2]\n[2, 4, 3]\n[20, 1, 30]\n\n...and see if you can find any patterns that you can take advantage of."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "1) Why is the case i = 2 not suitable, because 1<=i<n\n2) Why does the condition say \"nums[i] > 0.\" but we already have a non-negative array?\n\nUPD: The first question is solved. i = 2 we can use, in this case:\n[3, 7, 1, 6] -> [3, 6, 0, 6] -> [4, 5, 1, 5] -> [5, 4, 2, 4] -> End\n\nThis case suggested the idea: find the index of the maximum through bs and apply the algorithm until the index != 0"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is the most elegant DP problem I\\'ve ever seen, so far."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Anybody else facing the issue with submissions to this question?I am getting wrong answer, but when i use cout statement it is giving correct answer then and displaying the true result of my program."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was HARD\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "This feels like a purely logic+ math  based sum"
                    },
                    {
                        "username": "Chibix",
                        "content": "Hello guys, may someone help me please, I don\\'t understand why in this input : [13,13,20,0,8,9,9] the output must be 16 whereas we could reach 14 (isn\\'t it ?) Thank you in advance ! :) "
                    },
                    {
                        "username": "Chibix",
                        "content": "[@rishi_058](/rishi_058) Ok thx bro ! "
                    },
                    {
                        "username": "rishi_058",
                        "content": "[@Chibix](/Chibix) You can\\'t sort the given array "
                    },
                    {
                        "username": "Chibix",
                        "content": "here is the steps for input = [13,13,20,0,8,9,9] :\\n\\nnums [0, 8, 9, 9, 13, 13, 20]\\nnums [4, 4, 9, 9, 13, 13, 20]\\nnums [4, 7, 6, 9, 13, 13, 20]\\nnums [4, 7, 8, 7, 13, 13, 20]\\nnums [4, 7, 8, 10, 10, 13, 20]\\nnums [4, 7, 8, 10, 12, 11, 20]\\nnums [4, 7, 8, 10, 12, 15, 16]\\nnums [6, 5, 8, 10, 12, 15, 16]\\nnums [6, 7, 6, 10, 12, 15, 16]\\nnums [6, 7, 8, 8, 12, 15, 16]\\nnums [6, 7, 8, 10, 10, 15, 16]\\nnums [6, 7, 8, 10, 13, 12, 16]\\nfinal nums : [6, 7, 8, 10, 13, 14, 14]"
                    }
                ]
            },
            {
                "id": 1854600,
                "content": [
                    {
                        "username": "SeaShanty",
                        "content": "I have seen these types of \\' *any number of operation* \\' questions appear a lot on leetcode coding challenges. Can anyone suggest a common approach to these problem or a question set of similar problems or something? Help this beginner out :)"
                    },
                    {
                        "username": "palak-agg",
                        "content": "class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        int sum=nums[0];\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            sum+=nums[i];\\n            res=Math.max(res,(int)Math.ceil(sum/(i+1)));\\n        }\\n        return res;\\n    }\\n}\\n\\nCan someone please tell what\\'s wrong with this code?"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Can anyone provide the code for brute force approach? i have understood the approach but i m not able to code it."
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "explain approach"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "For those who are stuck, consider the test cases:\n\n[2, 3, 4]\n[4, 3, 2]\n[2, 4, 3]\n[20, 1, 30]\n\n...and see if you can find any patterns that you can take advantage of."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "1) Why is the case i = 2 not suitable, because 1<=i<n\n2) Why does the condition say \"nums[i] > 0.\" but we already have a non-negative array?\n\nUPD: The first question is solved. i = 2 we can use, in this case:\n[3, 7, 1, 6] -> [3, 6, 0, 6] -> [4, 5, 1, 5] -> [5, 4, 2, 4] -> End\n\nThis case suggested the idea: find the index of the maximum through bs and apply the algorithm until the index != 0"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is the most elegant DP problem I\\'ve ever seen, so far."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Anybody else facing the issue with submissions to this question?I am getting wrong answer, but when i use cout statement it is giving correct answer then and displaying the true result of my program."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was HARD\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "This feels like a purely logic+ math  based sum"
                    },
                    {
                        "username": "Chibix",
                        "content": "Hello guys, may someone help me please, I don\\'t understand why in this input : [13,13,20,0,8,9,9] the output must be 16 whereas we could reach 14 (isn\\'t it ?) Thank you in advance ! :) "
                    },
                    {
                        "username": "Chibix",
                        "content": "[@rishi_058](/rishi_058) Ok thx bro ! "
                    },
                    {
                        "username": "rishi_058",
                        "content": "[@Chibix](/Chibix) You can\\'t sort the given array "
                    },
                    {
                        "username": "Chibix",
                        "content": "here is the steps for input = [13,13,20,0,8,9,9] :\\n\\nnums [0, 8, 9, 9, 13, 13, 20]\\nnums [4, 4, 9, 9, 13, 13, 20]\\nnums [4, 7, 6, 9, 13, 13, 20]\\nnums [4, 7, 8, 7, 13, 13, 20]\\nnums [4, 7, 8, 10, 10, 13, 20]\\nnums [4, 7, 8, 10, 12, 11, 20]\\nnums [4, 7, 8, 10, 12, 15, 16]\\nnums [6, 5, 8, 10, 12, 15, 16]\\nnums [6, 7, 6, 10, 12, 15, 16]\\nnums [6, 7, 8, 8, 12, 15, 16]\\nnums [6, 7, 8, 10, 10, 15, 16]\\nnums [6, 7, 8, 10, 13, 12, 16]\\nfinal nums : [6, 7, 8, 10, 13, 14, 14]"
                    }
                ]
            },
            {
                "id": 1854536,
                "content": [
                    {
                        "username": "SeaShanty",
                        "content": "I have seen these types of \\' *any number of operation* \\' questions appear a lot on leetcode coding challenges. Can anyone suggest a common approach to these problem or a question set of similar problems or something? Help this beginner out :)"
                    },
                    {
                        "username": "palak-agg",
                        "content": "class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        int sum=nums[0];\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            sum+=nums[i];\\n            res=Math.max(res,(int)Math.ceil(sum/(i+1)));\\n        }\\n        return res;\\n    }\\n}\\n\\nCan someone please tell what\\'s wrong with this code?"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Can anyone provide the code for brute force approach? i have understood the approach but i m not able to code it."
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "explain approach"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "For those who are stuck, consider the test cases:\n\n[2, 3, 4]\n[4, 3, 2]\n[2, 4, 3]\n[20, 1, 30]\n\n...and see if you can find any patterns that you can take advantage of."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "1) Why is the case i = 2 not suitable, because 1<=i<n\n2) Why does the condition say \"nums[i] > 0.\" but we already have a non-negative array?\n\nUPD: The first question is solved. i = 2 we can use, in this case:\n[3, 7, 1, 6] -> [3, 6, 0, 6] -> [4, 5, 1, 5] -> [5, 4, 2, 4] -> End\n\nThis case suggested the idea: find the index of the maximum through bs and apply the algorithm until the index != 0"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is the most elegant DP problem I\\'ve ever seen, so far."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Anybody else facing the issue with submissions to this question?I am getting wrong answer, but when i use cout statement it is giving correct answer then and displaying the true result of my program."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was HARD\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "This feels like a purely logic+ math  based sum"
                    },
                    {
                        "username": "Chibix",
                        "content": "Hello guys, may someone help me please, I don\\'t understand why in this input : [13,13,20,0,8,9,9] the output must be 16 whereas we could reach 14 (isn\\'t it ?) Thank you in advance ! :) "
                    },
                    {
                        "username": "Chibix",
                        "content": "[@rishi_058](/rishi_058) Ok thx bro ! "
                    },
                    {
                        "username": "rishi_058",
                        "content": "[@Chibix](/Chibix) You can\\'t sort the given array "
                    },
                    {
                        "username": "Chibix",
                        "content": "here is the steps for input = [13,13,20,0,8,9,9] :\\n\\nnums [0, 8, 9, 9, 13, 13, 20]\\nnums [4, 4, 9, 9, 13, 13, 20]\\nnums [4, 7, 6, 9, 13, 13, 20]\\nnums [4, 7, 8, 7, 13, 13, 20]\\nnums [4, 7, 8, 10, 10, 13, 20]\\nnums [4, 7, 8, 10, 12, 11, 20]\\nnums [4, 7, 8, 10, 12, 15, 16]\\nnums [6, 5, 8, 10, 12, 15, 16]\\nnums [6, 7, 6, 10, 12, 15, 16]\\nnums [6, 7, 8, 8, 12, 15, 16]\\nnums [6, 7, 8, 10, 10, 15, 16]\\nnums [6, 7, 8, 10, 13, 12, 16]\\nfinal nums : [6, 7, 8, 10, 13, 14, 14]"
                    }
                ]
            },
            {
                "id": 1854498,
                "content": [
                    {
                        "username": "SeaShanty",
                        "content": "I have seen these types of \\' *any number of operation* \\' questions appear a lot on leetcode coding challenges. Can anyone suggest a common approach to these problem or a question set of similar problems or something? Help this beginner out :)"
                    },
                    {
                        "username": "palak-agg",
                        "content": "class Solution {\\n    public int minimizeArrayValue(int[] nums) {\\n        int sum=nums[0];\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            sum+=nums[i];\\n            res=Math.max(res,(int)Math.ceil(sum/(i+1)));\\n        }\\n        return res;\\n    }\\n}\\n\\nCan someone please tell what\\'s wrong with this code?"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Can anyone provide the code for brute force approach? i have understood the approach but i m not able to code it."
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "explain approach"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "For those who are stuck, consider the test cases:\n\n[2, 3, 4]\n[4, 3, 2]\n[2, 4, 3]\n[20, 1, 30]\n\n...and see if you can find any patterns that you can take advantage of."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "1) Why is the case i = 2 not suitable, because 1<=i<n\n2) Why does the condition say \"nums[i] > 0.\" but we already have a non-negative array?\n\nUPD: The first question is solved. i = 2 we can use, in this case:\n[3, 7, 1, 6] -> [3, 6, 0, 6] -> [4, 5, 1, 5] -> [5, 4, 2, 4] -> End\n\nThis case suggested the idea: find the index of the maximum through bs and apply the algorithm until the index != 0"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is the most elegant DP problem I\\'ve ever seen, so far."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Anybody else facing the issue with submissions to this question?I am getting wrong answer, but when i use cout statement it is giving correct answer then and displaying the true result of my program."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this was HARD\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "This feels like a purely logic+ math  based sum"
                    },
                    {
                        "username": "Chibix",
                        "content": "Hello guys, may someone help me please, I don\\'t understand why in this input : [13,13,20,0,8,9,9] the output must be 16 whereas we could reach 14 (isn\\'t it ?) Thank you in advance ! :) "
                    },
                    {
                        "username": "Chibix",
                        "content": "[@rishi_058](/rishi_058) Ok thx bro ! "
                    },
                    {
                        "username": "rishi_058",
                        "content": "[@Chibix](/Chibix) You can\\'t sort the given array "
                    },
                    {
                        "username": "Chibix",
                        "content": "here is the steps for input = [13,13,20,0,8,9,9] :\\n\\nnums [0, 8, 9, 9, 13, 13, 20]\\nnums [4, 4, 9, 9, 13, 13, 20]\\nnums [4, 7, 6, 9, 13, 13, 20]\\nnums [4, 7, 8, 7, 13, 13, 20]\\nnums [4, 7, 8, 10, 10, 13, 20]\\nnums [4, 7, 8, 10, 12, 11, 20]\\nnums [4, 7, 8, 10, 12, 15, 16]\\nnums [6, 5, 8, 10, 12, 15, 16]\\nnums [6, 7, 6, 10, 12, 15, 16]\\nnums [6, 7, 8, 8, 12, 15, 16]\\nnums [6, 7, 8, 10, 10, 15, 16]\\nnums [6, 7, 8, 10, 13, 12, 16]\\nfinal nums : [6, 7, 8, 10, 13, 14, 14]"
                    }
                ]
            }
        ]
    }
]