[
    {
        "title": "Recover a Tree From Preorder Traversal",
        "question_content": "We run a&nbsp;preorder&nbsp;depth-first search (DFS) on the root of a binary tree.\nAt each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.&nbsp; If the depth of a node is D, the depth of its immediate child is D + 1.&nbsp; The depth of the root node is 0.\nIf a node has only one child, that child is guaranteed to be the left child.\nGiven the output traversal of this traversal, recover the tree and return its root.\n&nbsp;\nExample 1:\nInput: traversal = \"1-2--3--4-5--6--7\"\nOutput: [1,2,5,3,4,6,7]\nExample 2:\nInput: traversal = \"1-2--3---4-5--6---7\"\nOutput: [1,2,5,3,null,6,null,4,null,7]\nExample 3:\nInput: traversal = \"1-401--349---90--88\"\nOutput: [1,401,null,349,88,90]\n&nbsp;\nConstraints:\n\tThe number of nodes in the original tree is in the range [1, 1000].\n\t1 <= Node.val <= 109",
        "solutions": [
            {
                "id": 274621,
                "title": "java-c-python-iterative-stack-solution",
                "content": "## **Explanation**\\nWe save the construction path in a `stack`.\\nIn each loop,\\nwe get the number `level` of `\\'-\\'`\\nwe get the value `val` of `node` to add.\\n\\nIf the size of stack is bigger than the level of node,\\nwe pop the stack until it\\'s not.\\n\\nFinally we return the first element in the stack, as it\\'s root of our tree.\\n\\n## **Complexity**\\n\\nTime `O(S)`, Space `O(N)`\\n\\n\\n**Java**\\n```\\n    public TreeNode recoverFromPreorder(String S) {\\n        int level, val;\\n        Stack<TreeNode> stack = new Stack<>();\\n        for (int i = 0; i < S.length();) {\\n            for (level = 0; S.charAt(i) == \\'-\\'; i++) {\\n                level++;\\n            }\\n            for (val = 0; i < S.length() && S.charAt(i) != \\'-\\'; i++) {\\n                val = val * 10 + (S.charAt(i) - \\'0\\');\\n            }\\n            while (stack.size() > level) {\\n                stack.pop();\\n            }\\n            TreeNode node = new TreeNode(val);\\n            if (!stack.isEmpty()) {\\n                if (stack.peek().left == null) {\\n                    stack.peek().left = node;\\n                } else {\\n                    stack.peek().right = node;\\n                }\\n            }\\n            stack.add(node);\\n        }\\n        while (stack.size() > 1) {\\n            stack.pop();\\n        }\\n        return stack.pop();\\n    }\\n```\\n\\n**C++**\\n```\\n    TreeNode* recoverFromPreorder(string S) {\\n        vector<TreeNode*> stack;\\n        for (int i = 0, level, val; i < S.length();) {\\n            for (level = 0; S[i] == \\'-\\'; i++)\\n                level++;\\n            for (val = 0; i < S.length() && S[i] != \\'-\\'; i++)\\n                val = val * 10 + S[i] - \\'0\\';\\n            TreeNode* node = new TreeNode(val);\\n            while (stack.size() > level) stack.pop_back();\\n            if (!stack.empty())\\n                if (!stack.back()->left) stack.back()->left = node;\\n                else stack.back()->right = node;\\n            stack.push_back(node);\\n        }\\n        return stack[0];\\n    }\\n```\\n\\n**Python:**\\n```\\n    def recoverFromPreorder(self, S):\\n        stack, i = [], 0\\n        while i < len(S):\\n            level, val = 0, \"\"\\n            while i < len(S) and S[i] == \\'-\\':\\n                level, i = level + 1, i + 1\\n            while i < len(S) and S[i] != \\'-\\':\\n                val, i = val + S[i], i + 1\\n            while len(stack) > level:\\n                stack.pop()\\n            node = TreeNode(val)\\n            if stack and stack[-1].left is None:\\n                stack[-1].left = node\\n            elif stack:\\n                stack[-1].right = node\\n            stack.append(node)\\n        return stack[0]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    public TreeNode recoverFromPreorder(String S) {\\n        int level, val;\\n        Stack<TreeNode> stack = new Stack<>();\\n        for (int i = 0; i < S.length();) {\\n            for (level = 0; S.charAt(i) == \\'-\\'; i++) {\\n                level++;\\n            }\\n            for (val = 0; i < S.length() && S.charAt(i) != \\'-\\'; i++) {\\n                val = val * 10 + (S.charAt(i) - \\'0\\');\\n            }\\n            while (stack.size() > level) {\\n                stack.pop();\\n            }\\n            TreeNode node = new TreeNode(val);\\n            if (!stack.isEmpty()) {\\n                if (stack.peek().left == null) {\\n                    stack.peek().left = node;\\n                } else {\\n                    stack.peek().right = node;\\n                }\\n            }\\n            stack.add(node);\\n        }\\n        while (stack.size() > 1) {\\n            stack.pop();\\n        }\\n        return stack.pop();\\n    }\\n```\n```\\n    TreeNode* recoverFromPreorder(string S) {\\n        vector<TreeNode*> stack;\\n        for (int i = 0, level, val; i < S.length();) {\\n            for (level = 0; S[i] == \\'-\\'; i++)\\n                level++;\\n            for (val = 0; i < S.length() && S[i] != \\'-\\'; i++)\\n                val = val * 10 + S[i] - \\'0\\';\\n            TreeNode* node = new TreeNode(val);\\n            while (stack.size() > level) stack.pop_back();\\n            if (!stack.empty())\\n                if (!stack.back()->left) stack.back()->left = node;\\n                else stack.back()->right = node;\\n            stack.push_back(node);\\n        }\\n        return stack[0];\\n    }\\n```\n```\\n    def recoverFromPreorder(self, S):\\n        stack, i = [], 0\\n        while i < len(S):\\n            level, val = 0, \"\"\\n            while i < len(S) and S[i] == \\'-\\':\\n                level, i = level + 1, i + 1\\n            while i < len(S) and S[i] != \\'-\\':\\n                val, i = val + S[i], i + 1\\n            while len(stack) > level:\\n                stack.pop()\\n            node = TreeNode(val)\\n            if stack and stack[-1].left is None:\\n                stack[-1].left = node\\n            elif stack:\\n                stack[-1].right = node\\n            stack.append(node)\\n        return stack[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 276002,
                "title": "java-simple-inline-iterative-solution-with-hashmap",
                "content": "Count the dashes and the numbers as you iterate the string.\\n\\n```java\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        Map<Integer, TreeNode> levels = new HashMap<>();\\n        int i = 0;\\n        while(i < S.length()) {\\n            int curLevel = 0, curNum = 0;\\n            while(i < S.length() && S.charAt(i) == \\'-\\') {\\n                ++curLevel;\\n                ++i;\\n            }\\n            while(i < S.length() && S.charAt(i) >= \\'0\\' && S.charAt(i) <= \\'9\\') {\\n                curNum = curNum*10 + (S.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            TreeNode curNode = new TreeNode(curNum);\\n            levels.put(curLevel, curNode);\\n            if(curLevel > 0) {\\n                TreeNode parent = levels.get(curLevel - 1);\\n                if(parent.left == null) parent.left = curNode;\\n                else parent.right = curNode;\\n            }\\n        }\\n        return levels.get(0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        Map<Integer, TreeNode> levels = new HashMap<>();\\n        int i = 0;\\n        while(i < S.length()) {\\n            int curLevel = 0, curNum = 0;\\n            while(i < S.length() && S.charAt(i) == \\'-\\') {\\n                ++curLevel;\\n                ++i;\\n            }\\n            while(i < S.length() && S.charAt(i) >= \\'0\\' && S.charAt(i) <= \\'9\\') {\\n                curNum = curNum*10 + (S.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            TreeNode curNode = new TreeNode(curNum);\\n            levels.put(curLevel, curNode);\\n            if(curLevel > 0) {\\n                TreeNode parent = levels.get(curLevel - 1);\\n                if(parent.left == null) parent.left = curNode;\\n                else parent.right = curNode;\\n            }\\n        }\\n        return levels.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274656,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    int index = 0;\\n    public TreeNode recoverFromPreorder(String S) {\\n        return helper(S, 0);\\n    }\\n    \\n    public TreeNode helper(String s, int depth) {\\n        int numDash = 0;\\n        while (index + numDash < s.length() && s.charAt(index + numDash) == \\'-\\') {\\n            numDash++;\\n        }\\n        if (numDash != depth) return null;\\n        int next = index + numDash;\\n        while (next < s.length() && s.charAt(next) != \\'-\\') next++;\\n        int val = Integer.parseInt(s.substring(index + numDash, next));\\n        index = next;\\n        TreeNode root = new TreeNode(val);\\n        root.left = helper(s, depth + 1);\\n        root.right = helper(s, depth + 1);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int index = 0;\\n    public TreeNode recoverFromPreorder(String S) {\\n        return helper(S, 0);\\n    }\\n    \\n    public TreeNode helper(String s, int depth) {\\n        int numDash = 0;\\n        while (index + numDash < s.length() && s.charAt(index + numDash) == \\'-\\') {\\n            numDash++;\\n        }\\n        if (numDash != depth) return null;\\n        int next = index + numDash;\\n        while (next < s.length() && s.charAt(next) != \\'-\\') next++;\\n        int val = Integer.parseInt(s.substring(index + numDash, next));\\n        index = next;\\n        TreeNode root = new TreeNode(val);\\n        root.left = helper(s, depth + 1);\\n        root.right = helper(s, depth + 1);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274633,
                "title": "c-simple-recursive-preorder",
                "content": "Similar to solving `#331 Verify Preorder Serialization of a Binary Tree` and `#297 Serialize and Deserialize Binary Tree` and a few other similar questions.\\n\\nThe idea is pretty simple, at each depth make sure that the number of `\\'-\\'` is same as the depth, if it\\'s not return `NULL` else continue the recursive preorder traversal.\\n\\nIn general the preorder traversal through recursion is:\\n```c++\\nvoid preorder(Treenode* root)\\n{\\n\\tif(!root)\\n\\t{\\n\\t\\tcout<<\"NULL\";\\n\\t\\treturn;\\n\\t}\\n\\tcout<<root->val;\\n\\tpreorder(root->left);\\n\\tpreorder(root->right);\\n}\\n```\\n\\nWhat we are doing here is the same, just imagine the string is in form of a tree and make sure that the boundaries for print(case above)/set root->val(this case) or returning/printing NULL are set right (according to the question).\\n\\n```c++\\nclass Solution {\\npublic:\\n    int i=0;\\n    TreeNode* recoverFromPreorder(string &S,int d)\\n    {\\n        int nextDigitPos=S.find_first_of(\"1234567890\",i);                          // Get index of the first number after i.\\n        if(nextDigitPos-i!=d)                                                      // If number of \\'-\\' in between != depth return NULL\\n            return NULL;\\n        int nextDashPos=S.find(\"-\",nextDigitPos);                                  // Get the index of the next \\'-\\'\\n        int rootValue=stoi(S.substr(nextDigitPos,nextDashPos-nextDigitPos));\\n        TreeNode* root=new TreeNode(rootValue);                                    // Create the root with the node\\'s value\\n        i=nextDashPos;                                                             // Move index forward for future recursions.\\n        root->left=recoverFromPreorder(S,d+1);                                     // Create left subtree\\n        root->right=recoverFromPreorder(S,d+1);                                    // Create right subtree\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string S)\\n    {\\n        return recoverFromPreorder(S,0);\\n    }\\n};\\n```\\n**Complexity**\\nSpace: `O(h)` where `h` is the height of tree. This is due to recursion stack. Worst case this can be equal to number of nodes in the tree.\\nTime: `O(n)`. where `n` is the length of the string.\\n\\n**Note:**\\nThere is some extra time spent when the number of `-` in between is not equal to current `depth`. This is due to the next recursion again finding the position of the next digit in the first line for `nextDigitPos`. This can be avoided by moving it out as a global variable and only calculating it once. This would make it a true `O(n)` recursive solution. However the difference is negligible and hence I am not adding that solution.",
                "solutionTags": [],
                "code": "```c++\\nvoid preorder(Treenode* root)\\n{\\n\\tif(!root)\\n\\t{\\n\\t\\tcout<<\"NULL\";\\n\\t\\treturn;\\n\\t}\\n\\tcout<<root->val;\\n\\tpreorder(root->left);\\n\\tpreorder(root->right);\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int i=0;\\n    TreeNode* recoverFromPreorder(string &S,int d)\\n    {\\n        int nextDigitPos=S.find_first_of(\"1234567890\",i);                          // Get index of the first number after i.\\n        if(nextDigitPos-i!=d)                                                      // If number of \\'-\\' in between != depth return NULL\\n            return NULL;\\n        int nextDashPos=S.find(\"-\",nextDigitPos);                                  // Get the index of the next \\'-\\'\\n        int rootValue=stoi(S.substr(nextDigitPos,nextDashPos-nextDigitPos));\\n        TreeNode* root=new TreeNode(rootValue);                                    // Create the root with the node\\'s value\\n        i=nextDashPos;                                                             // Move index forward for future recursions.\\n        root->left=recoverFromPreorder(S,d+1);                                     // Create left subtree\\n        root->right=recoverFromPreorder(S,d+1);                                    // Create right subtree\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string S)\\n    {\\n        return recoverFromPreorder(S,0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 274605,
                "title": "c-iterative-stack",
                "content": "1. Track the current level (count \\'-\\'s). Then get the value.\\n2. Create the current node using the value.\\n3. Remove elements from the stack until its size equals to the current level.\\n4. If the stack is not empty, make the current element the left (or right, if left is occupied) child of the node at the top.\\n5. Push the current node into the stack.\\n```\\nTreeNode* recoverFromPreorder(string S) {\\n  stack<TreeNode*> st;\\n  for (auto p = 0, len = 0, level = 0; p < S.size(); p += len) {\\n    level = 0, len = 0;\\n    while (S[p] == \\'-\\') ++level, ++p;\\n    while (p + len < S.size() && S[p + len] != \\'-\\') ++len;\\n    TreeNode* n = new TreeNode(stoi(S.substr(p, len)));\\n    while (st.size() > level) st.pop();\\n    if (!st.empty()) {\\n      if (st.top()->left == nullptr) st.top()->left = n;\\n      else st.top()->right = n;\\n    }\\n    st.push(n);\\n  }\\n  while (st.size() > 1) st.pop();\\n  return st.top();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* recoverFromPreorder(string S) {\\n  stack<TreeNode*> st;\\n  for (auto p = 0, len = 0, level = 0; p < S.size(); p += len) {\\n    level = 0, len = 0;\\n    while (S[p] == \\'-\\') ++level, ++p;\\n    while (p + len < S.size() && S[p + len] != \\'-\\') ++len;\\n    TreeNode* n = new TreeNode(stoi(S.substr(p, len)));\\n    while (st.size() > level) st.pop();\\n    if (!st.empty()) {\\n      if (st.top()->left == nullptr) st.top()->left = n;\\n      else st.top()->right = n;\\n    }\\n    st.push(n);\\n  }\\n  while (st.size() > 1) st.pop();\\n  return st.top();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 537706,
                "title": "c-short-easy-o-n-solution",
                "content": "The idea is simple: \\ngo through the string only once and each time when we reach a none root number (a node), it is the left or right child of the last appeared number (node) whose number of dashes is 1 less than the current one\\'s.\\n\\nuse a map with the key being the number of dashes of each node.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        unordered_map<int, TreeNode *> mp;\\n        int cur = 0;\\n        for (int i = 0; i < S.size(); i++) {\\n            if (S[i] == \\'-\\') {\\n                cur += 1;\\n            }\\n            else {\\n                string num = \"\";\\n                while (i < S.size() && S[i] >= \\'0\\' && S[i] <= \\'9\\')\\n                    num += S[i++];\\n                i--;\\n                int cn = stoi(num);\\n                mp[cur] = new TreeNode(cn);\\n                if (cur)\\n                    if (mp[cur - 1]->left)\\n                        mp[cur - 1]->right = mp[cur];\\n                    else\\n                        mp[cur - 1]->left = mp[cur];\\n                cur = 0;\\n            }\\n        }\\n        return mp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        unordered_map<int, TreeNode *> mp;\\n        int cur = 0;\\n        for (int i = 0; i < S.size(); i++) {\\n            if (S[i] == \\'-\\') {\\n                cur += 1;\\n            }\\n            else {\\n                string num = \"\";\\n                while (i < S.size() && S[i] >= \\'0\\' && S[i] <= \\'9\\')\\n                    num += S[i++];\\n                i--;\\n                int cn = stoi(num);\\n                mp[cur] = new TreeNode(cn);\\n                if (cur)\\n                    if (mp[cur - 1]->left)\\n                        mp[cur - 1]->right = mp[cur];\\n                    else\\n                        mp[cur - 1]->left = mp[cur];\\n                cur = 0;\\n            }\\n        }\\n        return mp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274596,
                "title": "screencast-of-leetcode-weekly-contest-132",
                "content": "https://www.youtube.com/watch?v=ZYu2-7ovvw8\\n\\nWasted 4 mins debugging the last problem, and turns out I misread the test case...\\notherwise, I would have won this contest. sad...",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=ZYu2-7ovvw8\\n\\nWasted 4 mins debugging the last problem, and turns out I misread the test case...\\notherwise, I would have won this contest. sad...",
                "codeTag": "Unknown"
            },
            {
                "id": 274874,
                "title": "java-regex-solution",
                "content": "```\\n    public TreeNode recoverFromPreorder(String S) {\\n        return helper(S, 1);\\n    }\\n    \\n    TreeNode helper(String S, int depth) {\\n        if (S.length() == 0) {\\n            return null;\\n        }\\n        String regex = \"(?<=\\\\\\\\d)[-]{\" + depth + \"}(?=\\\\\\\\d)\"; \\n        String[] s = S.split(regex);\\n        \\n        TreeNode root = new TreeNode(Integer.parseInt(s[0]));\\n        \\n        if (s.length > 1) {\\n            root.left = helper(s[1], depth+1);\\n        }\\n        if (s.length > 2) {\\n            root.right = helper(s[2], depth+1);\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode recoverFromPreorder(String S) {\\n        return helper(S, 1);\\n    }\\n    \\n    TreeNode helper(String S, int depth) {\\n        if (S.length() == 0) {\\n            return null;\\n        }\\n        String regex = \"(?<=\\\\\\\\d)[-]{\" + depth + \"}(?=\\\\\\\\d)\"; \\n        String[] s = S.split(regex);\\n        \\n        TreeNode root = new TreeNode(Integer.parseInt(s[0]));\\n        \\n        if (s.length > 1) {\\n            root.left = helper(s[1], depth+1);\\n        }\\n        if (s.length > 2) {\\n            root.right = helper(s[2], depth+1);\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282366,
                "title": "java-clean-code-list-solution",
                "content": "Less code, and easy to read.\\n\\n```\\n public TreeNode recoverFromPreorder(String S) {\\n        String[] tokens = S.split(\"-\");\\n        List<TreeNode> list = new ArrayList<>();\\n        \\n        list.add(new TreeNode(Integer.valueOf(tokens[0])));\\n        int level = 1;\\n        for(int i=1; i<tokens.length; i++){\\n        \\n            if(!tokens[i].isEmpty()){\\n                TreeNode node = new TreeNode(Integer.valueOf(tokens[i]));\\n                list.add(level, node);\\n                \\n                TreeNode parent = list.get(level-1);\\n                if(parent.left == null){\\n                    parent.left  = node;\\n                }else{\\n                    parent.right = node;\\n                }\\n                \\n                level = 1;\\n            }else{\\n                level++;\\n            }\\n        }\\n        \\n        return list.get(0);\\n    }",
                "solutionTags": [],
                "code": "Less code, and easy to read.\\n\\n```\\n public TreeNode recoverFromPreorder(String S) {\\n        String[] tokens = S.split(\"-\");\\n        List<TreeNode> list = new ArrayList<>();\\n        \\n        list.add(new TreeNode(Integer.valueOf(tokens[0])));\\n        int level = 1;\\n        for(int i=1; i<tokens.length; i++){\\n        \\n            if(!tokens[i].isEmpty()){\\n                TreeNode node = new TreeNode(Integer.valueOf(tokens[i]));\\n                list.add(level, node);\\n                \\n                TreeNode parent = list.get(level-1);\\n                if(parent.left == null){\\n                    parent.left  = node;\\n                }else{\\n                    parent.right = node;\\n                }\\n                \\n                level = 1;\\n            }else{\\n                level++;\\n            }\\n        }\\n        \\n        return list.get(0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1355318,
                "title": "o-n-dfs-easy-to-understand-8ms-faster-than-99",
                "content": "## Approach:\\n\\n##### We first count the level of the current node and check if it is equal to the current level our node is in using recursion. If it is, we add a new node and do the same for left and right otherwise, we return NULL.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int index;\\n    \\n    TreeNode* makeTree(string& pre, int level)\\n    {\\n        if(pre[index] == \\'\\\\0\\') return NULL;\\n        \\n        int currLevel = 0;\\n        \\n        while(pre[index + currLevel] == \\'-\\')\\n            currLevel++;\\n        \\n        if(currLevel == level)\\n        {\\n            index += currLevel;\\n            \\n            int currVal = 0;\\n            \\n            while(pre[index] >= \\'0\\' && pre[index] <= \\'9\\')\\n            {\\n                currVal = (10 * currVal) + (pre[index] - \\'0\\');\\n                index++;\\n            }\\n            \\n            TreeNode *root = new TreeNode(currVal);\\n            \\n            root->left = makeTree(pre, level + 1);\\n            root->right = makeTree(pre, level + 1);\\n            \\n            return root;\\n        }\\n        \\n        return NULL;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) \\n    {\\n        index = 0;\\n        \\n        return makeTree(traversal, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int index;\\n    \\n    TreeNode* makeTree(string& pre, int level)\\n    {\\n        if(pre[index] == \\'\\\\0\\') return NULL;\\n        \\n        int currLevel = 0;\\n        \\n        while(pre[index + currLevel] == \\'-\\')\\n            currLevel++;\\n        \\n        if(currLevel == level)\\n        {\\n            index += currLevel;\\n            \\n            int currVal = 0;\\n            \\n            while(pre[index] >= \\'0\\' && pre[index] <= \\'9\\')\\n            {\\n                currVal = (10 * currVal) + (pre[index] - \\'0\\');\\n                index++;\\n            }\\n            \\n            TreeNode *root = new TreeNode(currVal);\\n            \\n            root->left = makeTree(pre, level + 1);\\n            root->right = makeTree(pre, level + 1);\\n            \\n            return root;\\n        }\\n        \\n        return NULL;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) \\n    {\\n        index = 0;\\n        \\n        return makeTree(traversal, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293669,
                "title": "python-solution-with-dictionary-68ms-13-5mb",
                "content": "Track each last node seen at a given depth in a dictionary indexed by depth. \\n\\nCollisions are ok, because we will have processed the node and stored a pointer to it from our `head` by the time we get to the other subtree.\\n\\n# Time:\\n\\nO(n)\\n# Space:\\nO(h) space where h is the tree height. Best case: O (log n) Worst case: O(n)\\n\\n```\\ndef recoverFromPreorder(self, S: str) -> TreeNode:\\n        depth = 0\\n        dd = collections.defaultdict(TreeNode)\\n        head = TreeNode(-1)\\n        dd[-1] = head\\n        cur_num = \\'\\'        \\n        for i, c in enumerate(S):\\n            if c != \\'-\\':\\n                if (i < len(S)-1 and S[i+1] != \\'-\\'): \\n                    cur_num += c\\n                else:\\n                    prev = dd[depth-1]\\n                    cur = TreeNode(cur_num + c)\\n                    dd[depth] = cur\\n                    \\n                    if prev.left:\\n                        prev.right = cur\\n                    else:\\n                        prev.left = cur\\n\\n                    depth = 0\\n                    cur_num = \\'\\'\\n            else:\\n                depth += 1\\n            \\n        return head.left\\n```",
                "solutionTags": [],
                "code": "```\\ndef recoverFromPreorder(self, S: str) -> TreeNode:\\n        depth = 0\\n        dd = collections.defaultdict(TreeNode)\\n        head = TreeNode(-1)\\n        dd[-1] = head\\n        cur_num = \\'\\'        \\n        for i, c in enumerate(S):\\n            if c != \\'-\\':\\n                if (i < len(S)-1 and S[i+1] != \\'-\\'): \\n                    cur_num += c\\n                else:\\n                    prev = dd[depth-1]\\n                    cur = TreeNode(cur_num + c)\\n                    dd[depth] = cur\\n                    \\n                    if prev.left:\\n                        prev.right = cur\\n                    else:\\n                        prev.left = cur\\n\\n                    depth = 0\\n                    cur_num = \\'\\'\\n            else:\\n                depth += 1\\n            \\n        return head.left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3117894,
                "title": "c-o-n-non-recursive-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo points to notice here:\\n\\n1) In preorder traversal, parent is traversed before any node. Also lets say depth of the parent is d(p) and depth of the node is d(n).\\n2) During preorder traversal, if we are traversing any node at depth d(n), the last traversed node at depth d(p) will be the current node\\'s parent.\\n\\nSo solutions goes like this:\\n\\nTraverse the input string and keep track of last traversed nodes corresponding to depths.\\nWe can calculate the depth of the current node by counting the \\'-\\' in the input string before the value. (lets call it d).\\nThe current node\\'s parent will be at depth d-1.\\nAssign the parent.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nA map(m) is used to store last traversed Node pointer at depth d;\\n\\nTraverse the input string;\\nCalculate depth d of the current node;\\nCalculate value val of the current node;\\nCreate node;\\nGet the parent of the node, which is the last processed node at depth d-1.\\nAssign to the left/right of the parent.\\nMark the current node as last processed node at depth d. (ie. insert it into map at depth d).\\n\\nreturn the node at depth d=0;\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    bool isDigit(char c){\\n        return c>=\\'0\\'&&c<=\\'9\\';\\n    }\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int,TreeNode*> m;\\n        \\n        int i = 0;\\n        while(i<traversal.size()){\\n            int d = 0;\\n            while(i<traversal.size() && traversal[i]==\\'-\\'){\\n                d++;\\n                i++;\\n            }\\n            string s = \"\";\\n            while(i<traversal.size() && isDigit(traversal[i])){\\n                s+= traversal[i];\\n                i++;\\n            }\\n            int val = stoi(s);\\n            TreeNode* node = new TreeNode(val);\\n            if(d>0){\\n                TreeNode* p = m[d-1];\\n                if(p->left==NULL){\\n                    p->left = node;\\n                }\\n                else{\\n                    p->right = node;\\n                }\\n            }\\n            m[d] = node;\\n        }\\n        \\n        return m[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    bool isDigit(char c){\\n        return c>=\\'0\\'&&c<=\\'9\\';\\n    }\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int,TreeNode*> m;\\n        \\n        int i = 0;\\n        while(i<traversal.size()){\\n            int d = 0;\\n            while(i<traversal.size() && traversal[i]==\\'-\\'){\\n                d++;\\n                i++;\\n            }\\n            string s = \"\";\\n            while(i<traversal.size() && isDigit(traversal[i])){\\n                s+= traversal[i];\\n                i++;\\n            }\\n            int val = stoi(s);\\n            TreeNode* node = new TreeNode(val);\\n            if(d>0){\\n                TreeNode* p = m[d-1];\\n                if(p->left==NULL){\\n                    p->left = node;\\n                }\\n                else{\\n                    p->right = node;\\n                }\\n            }\\n            m[d] = node;\\n        }\\n        \\n        return m[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328780,
                "title": "8-line-python-recursion-40ms-beats-100",
                "content": "https://leetcode.com/submissions/detail/241310130/\\n\\n```\\nimport re\\n\\nclass Solution(object):\\n    def recoverFromPreorder(self, S):\\n        vals = [(len(s[1]), int(s[2])) for s in re.findall(\"((-*)(\\\\d+))\", S)][::-1]\\n\\n        def fn(level):\\n            if not vals or level != vals[-1][0]: return None\\n            node = TreeNode(vals.pop()[1])\\n            node.left = fn(level+1)\\n            node.right = fn(level+1)\\n            return node\\n        return fn(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nimport re\\n\\nclass Solution(object):\\n    def recoverFromPreorder(self, S):\\n        vals = [(len(s[1]), int(s[2])) for s in re.findall(\"((-*)(\\\\d+))\", S)][::-1]\\n\\n        def fn(level):\\n            if not vals or level != vals[-1][0]: return None\\n            node = TreeNode(vals.pop()[1])\\n            node.left = fn(level+1)\\n            node.right = fn(level+1)\\n            return node\\n        return fn(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 276751,
                "title": "easy-recursive-python-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def recoverFromPreorder(self, s: str) -> TreeNode:\\n        self.index = 0\\n        def dfs(depth):\\n            if self.index == len(s):\\n                return\\n            for i in range(depth):\\n                if s[self.index+i] != \\'-\\':\\n                    return\\n            self.index += depth\\n            curr = 0\\n            while self.index < len(s) and s[self.index].isdigit():\\n                curr = curr * 10 + int(s[self.index])\\n                self.index += 1\\n            node = TreeNode(curr)\\n            node.left = dfs(depth+1)\\n            node.right = dfs(depth+1)\\n            return node\\n        return dfs(0)\\n    \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def recoverFromPreorder(self, s: str) -> TreeNode:\\n        self.index = 0\\n        def dfs(depth):\\n            if self.index == len(s):\\n                return\\n            for i in range(depth):\\n                if s[self.index+i] != \\'-\\':\\n                    return\\n            self.index += depth\\n            curr = 0\\n            while self.index < len(s) and s[self.index].isdigit():\\n                curr = curr * 10 + int(s[self.index])\\n                self.index += 1\\n            node = TreeNode(curr)\\n            node.left = dfs(depth+1)\\n            node.right = dfs(depth+1)\\n            return node\\n        return dfs(0)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116747,
                "title": "javascript-dfs-solution-with-only-one-function",
                "content": "#### core concept \\nSplitting by the ```depth+1``` number of \"-\" in ```dfs``` and every layer in ```dfs``` only handles the depth+1 of \\'-\\' .\\nIt would split ```traversal``` into three part: ```[val , leftStr , rightStr]```\\nAnd using regex as separator.\\n\\n```  ex: \\'1-2--3--4-5--6--7\\' split by \\'-\\'  ==>  [\\'1\\',\\'2--3--4\\',\\'5--6--7\\'] ```\\n\\n(By using regex , we could ignore \\'--\\' when splitting by \\'-\\' )\\n\\n---\\n\\nHere comes the code.\\n\\n\\n```\\nvar recoverFromPreorder = function(traversal) {\\n    \\n    let n = traversal.length;\\n    \\n    // Every layer in dfs handles the depth+1 of \\'-\\' only.\\n    // ex: \\n    //   depth=0 -> find \\'-\\'  as splitter\\n    //   depth=1 -> find \\'--\\' as splitter\\n    //   depth=2 -> find \\'---\\' as splitter\\n    let dfs = (str,depth)=>{\\n        if(str.indexOf(\"-\") === -1) return new TreeNode(str);\\n\\t\\t\\n\\t\\t// 1. We split by the depth+1 number of \\'-\\'\\n        // Using regex to split is much easier. -> str.split(/(?<=\\\\d)-(?=\\\\d)/g)\\n\\t\\t// where (?<=\\\\d)  means positive lookbehind , ex: \"1- ...\", then we\\'ll split \\'-\\' excluding 1.\\n\\t\\t// Similarly , (?=\\\\d) means positive lookahead , ex: \"-5 ...\",  then we\\'ll split \\'-\\' excluding 5.\\n\\t\\t\\n        let re = new RegExp(`(?<=\\\\\\\\d)${\"-\".repeat(depth+1)}(?=\\\\\\\\d)`,\\'g\\');\\n        let [val,leftStr,rightStr] = str.split(re);\\n        // ex: 1-2--3--4-5--6--7 --> [\\'1\\',\\'2--3--4\\',\\'5--6--7\\']\\n        \\n\\t\\t// 2. After splitting,  we\\'ll get [val,leftStr,rightStr]\\n\\t\\t// Then we could handle left / right node in the next dfs layer intuitively.\\n        let node = new TreeNode(val);\\n        if(leftStr)  node.left  = dfs(leftStr,depth+1);\\n        if(rightStr) node.right = dfs(rightStr,depth+1);\\n        \\n        return node;\\n    };\\n    \\n    return dfs(traversal,0);\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```depth+1```\n```dfs```\n```dfs```\n```traversal```\n```[val , leftStr , rightStr]```\n```  ex: \\'1-2--3--4-5--6--7\\' split by \\'-\\'  ==>  [\\'1\\',\\'2--3--4\\',\\'5--6--7\\'] ```\n```\\nvar recoverFromPreorder = function(traversal) {\\n    \\n    let n = traversal.length;\\n    \\n    // Every layer in dfs handles the depth+1 of \\'-\\' only.\\n    // ex: \\n    //   depth=0 -> find \\'-\\'  as splitter\\n    //   depth=1 -> find \\'--\\' as splitter\\n    //   depth=2 -> find \\'---\\' as splitter\\n    let dfs = (str,depth)=>{\\n        if(str.indexOf(\"-\") === -1) return new TreeNode(str);\\n\\t\\t\\n\\t\\t// 1. We split by the depth+1 number of \\'-\\'\\n        // Using regex to split is much easier. -> str.split(/(?<=\\\\d)-(?=\\\\d)/g)\\n\\t\\t// where (?<=\\\\d)  means positive lookbehind , ex: \"1- ...\", then we\\'ll split \\'-\\' excluding 1.\\n\\t\\t// Similarly , (?=\\\\d) means positive lookahead , ex: \"-5 ...\",  then we\\'ll split \\'-\\' excluding 5.\\n\\t\\t\\n        let re = new RegExp(`(?<=\\\\\\\\d)${\"-\".repeat(depth+1)}(?=\\\\\\\\d)`,\\'g\\');\\n        let [val,leftStr,rightStr] = str.split(re);\\n        // ex: 1-2--3--4-5--6--7 --> [\\'1\\',\\'2--3--4\\',\\'5--6--7\\']\\n        \\n\\t\\t// 2. After splitting,  we\\'ll get [val,leftStr,rightStr]\\n\\t\\t// Then we could handle left / right node in the next dfs layer intuitively.\\n        let node = new TreeNode(val);\\n        if(leftStr)  node.left  = dfs(leftStr,depth+1);\\n        if(rightStr) node.right = dfs(rightStr,depth+1);\\n        \\n        return node;\\n    };\\n    \\n    return dfs(traversal,0);\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1191195,
                "title": "c-100-fast-8ms",
                "content": "**Idea :** As mentioned in the description of the ques **\\'-\\'** represents depth of the node succeeding the **\\'-\\'**. This means if string is **1-2--3** This means 1 is root and 2 is let child of 1 and 3 is left child of 2  as mentioned in the description if there is only one  node at a level it is **left child**. So here I have made a **recursive solution** in line of preorder dfs traversal with the string and starting index being global variables. The idea of the function is to only pass the depth of the required node and then the function checks the required no. of dashes equal to depth , if yes then it creates a node and updates starting index and if no it returns NULL.\\n**Why starting index global?**\\nYou might come up with a question that why starting index is global as in the question it is mentioned that if there is a only child of a node it is compulsory to be left child so if a function discovers a node at a depth it is marked as left child of the parent first and then the starting index is updated as then when right child function is called it checks at the updated index and if found then mark the right child otherwise NULL so Starting index has to be global for correct marking.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int ind=0;\\n    string s;\\n    TreeNode* solve(int depth)\\n    {\\n        if(s.length()<depth)\\n        {\\n            return NULL;\\n        }\\n        for(int i=ind;i<ind+depth;i++)\\n        {\\n                  if(s[i]!=\\'-\\')\\n                  {\\n                      return NULL;\\n                  }\\n        }\\n\\t\\t//This string is basically to store numeric value of the node ( as it can be any digit no.)\\n        string temp;\\n        int st=ind+depth;\\n        while(s[st]!=\\'-\\' && st<s.length())\\n        {\\n            temp+=s[st];\\n            st++;\\n        }\\n        int j= stoi(temp);\\n        TreeNode*root= new TreeNode(j);\\n        ind=st;\\n        root->left=solve(depth+1);\\n        root->right=solve(depth+1);\\n        return root;      \\n        \\n    }\\n    TreeNode* recoverFromPreorder(string S) {\\n        s=S;\\n        TreeNode*root=solve(0);\\n        return root;\\n    }\\n};\\n\\n```\\n**I hope you liked my solution , Please Upvote!**\\n![image](https://assets.leetcode.com/users/images/f2f04366-10c8-402c-861b-4b34e5e4e81f_1620140225.0532122.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ind=0;\\n    string s;\\n    TreeNode* solve(int depth)\\n    {\\n        if(s.length()<depth)\\n        {\\n            return NULL;\\n        }\\n        for(int i=ind;i<ind+depth;i++)\\n        {\\n                  if(s[i]!=\\'-\\')\\n                  {\\n                      return NULL;\\n                  }\\n        }\\n\\t\\t//This string is basically to store numeric value of the node ( as it can be any digit no.)\\n        string temp;\\n        int st=ind+depth;\\n        while(s[st]!=\\'-\\' && st<s.length())\\n        {\\n            temp+=s[st];\\n            st++;\\n        }\\n        int j= stoi(temp);\\n        TreeNode*root= new TreeNode(j);\\n        ind=st;\\n        root->left=solve(depth+1);\\n        root->right=solve(depth+1);\\n        return root;      \\n        \\n    }\\n    TreeNode* recoverFromPreorder(string S) {\\n        s=S;\\n        TreeNode*root=solve(0);\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376427,
                "title": "easy-to-understand-java-recursive-solution-with-explanation",
                "content": "/**\\nbased on this logic:\\n**1.**\\nat each level, we need split S based on the splitter on each level\\nat level 1, splitter is \"-\" (note: it is \"-\" only, not \"--\", not \"---\")\\nat level 2, splitter is \"--\"\\nat level 3, splitter is \"---\"\\nand so on\\nthe splitter is made of \"-\"s, and count of \"-\" equal to level\\n\\n**2.**\\nafter we find splitter, we need split our input S based on 3 cases:\\n   a. if no splitter found in S, the whole S used as value of node,  return node\\n   b. if only one splitter found, then we Split S as two parts, first part is node, second part is left child tree for node.\\n   c. if two splitter found, then we split S into 3 parts, first is for node, second part is for node.left, and third for node.right.\\n   \\n   \\n**3**\\nhow to find splitter for each level ( here is the key point for the logic )\\n    first we find the index of \"-\"(assume at index i), to make sure the \"-\" is the splitter, we need check value of S at index(i+level),\\n\\t\\ta. if it is not \"-\", we found the splitter.\\n\\t\\tb. if it is \"-\", that means it is for future level, we need skip all the next \"-\"s until a not \"-\" found, we need start   find splitter after it. \\n\\nfor example \\nS= \"1-2--3--4-5--6--7\"  \\nat level 1, splitter is \"-\", we found two, so separate it into 3 parts\\nnode: 1\\nnode.left:  S=\"2--3--4\" (recursive call with level = 2)\\nnode.right  S=\"5--6--7\" (recursive call with level = 2)\\nreturn node;\\nhow to find \"-\", first we find \"-\" at index of i (i=1), to make sure it is the splitter \"-\"\\nwe need check value at i + level (i=1, level=1), so we check S(2), it is not \"-\" but \"2\", so we find one splitter. to find second one, we continue search \"-\", found it at index j=3, but S(j+level) is \"-\", so we know it is not splitter, need increment j until S(j) is not \"-\", finally we\\'ll find another splitter at index 9,\\nso we S split into **1** ,      **2--3--4**   ,  **5--6--7**, please note we need remove the splitter itself when split S.\\n\\n\\n\\nfor recurse call level 2, splitter is \"--\"\\nin 2--3--4 we find two splitter \"--\"s, so split into 3 parts\\nnode: 2\\nnode.left: S=\"3\"  (recursive call with level = 3)\\nnode.right:S=\"4\" (recursive call with level = 3)\\nreturn node;\\n\\n...\\n\\n**/\\n```\\n\\n\\nclass Solution {\\n    \\n    public TreeNode recoverFromPreorder(String S) {\\n        return recoverTreeByLevel(S, 1);\\n\\n    }\\n\\n   private TreeNode recoverTreeByLevel(String S, int level) {\\n\\n        if (S.length() == 0) {\\n            return null;\\n        }\\n        int leftIndex = -1;\\n        int rightIndex = -1;\\n\\t\\t//try to find first splitter \\n        for (int i = 1; i < S.length() - level; i++) {\\n            //we found left child if below condition evaluated to true;\\n            if (S.charAt(i) == \\'-\\' && S.charAt(i + level) != \\'-\\') {\\n                leftIndex = i;\\n                break;\\n            }\\n        }\\n        //if there is no left, just create a TreeNode and return; \\n        if (leftIndex == -1) {\\n            return new TreeNode(Integer.parseInt(S));\\n        }\\n \\n        //if we find left node, we create create the node, from substring from [0, i) of S.\\n        TreeNode node = new TreeNode(Integer.parseInt(S.substring(0, leftIndex)));\\n\\n        //we need skip the splitter of \\'-\\', which the count of level\\n        leftIndex += level;\\n       \\n\\t   //try to find the second splitter\\n        //then we need to check if we has right child node in S start from leftIndex\\n        for (int j = leftIndex; j < S.length() - level; j++) {\\n            //in below case, it means we have right child\\n            if (S.charAt(j) == \\'-\\') {\\n                if (S.charAt(j + level) != \\'-\\') {\\n                    rightIndex = j;\\n                    break;\\n                } else {\\n                    //below is to skip all those \\'-\\' which for levels greater than current level;\\n                    while(S.charAt(++j)==\\'-\\');\\n                }\\n            }\\n        }\\n\\n        //if no right child node find, we only use recursive call to build left child and return node\\n        if (rightIndex == -1) {\\n            node.left = recoverTreeByLevel(S.substring(leftIndex), level + 1);\\n            return node;\\n        }\\n\\n        \\n        //if we find both left and right, we need build both children and then return\\n        node.left = recoverTreeByLevel(S.substring(leftIndex, rightIndex), level + 1);\\n        node.right = recoverTreeByLevel(S.substring(rightIndex+level), level + 1);\\n        return node;\\n\\n    }\\n   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\n    \\n    public TreeNode recoverFromPreorder(String S) {\\n        return recoverTreeByLevel(S, 1);\\n\\n    }\\n\\n   private TreeNode recoverTreeByLevel(String S, int level) {\\n\\n        if (S.length() == 0) {\\n            return null;\\n        }\\n        int leftIndex = -1;\\n        int rightIndex = -1;\\n\\t\\t//try to find first splitter \\n        for (int i = 1; i < S.length() - level; i++) {\\n            //we found left child if below condition evaluated to true;\\n            if (S.charAt(i) == \\'-\\' && S.charAt(i + level) != \\'-\\') {\\n                leftIndex = i;\\n                break;\\n            }\\n        }\\n        //if there is no left, just create a TreeNode and return; \\n        if (leftIndex == -1) {\\n            return new TreeNode(Integer.parseInt(S));\\n        }\\n \\n        //if we find left node, we create create the node, from substring from [0, i) of S.\\n        TreeNode node = new TreeNode(Integer.parseInt(S.substring(0, leftIndex)));\\n\\n        //we need skip the splitter of \\'-\\', which the count of level\\n        leftIndex += level;\\n       \\n\\t   //try to find the second splitter\\n        //then we need to check if we has right child node in S start from leftIndex\\n        for (int j = leftIndex; j < S.length() - level; j++) {\\n            //in below case, it means we have right child\\n            if (S.charAt(j) == \\'-\\') {\\n                if (S.charAt(j + level) != \\'-\\') {\\n                    rightIndex = j;\\n                    break;\\n                } else {\\n                    //below is to skip all those \\'-\\' which for levels greater than current level;\\n                    while(S.charAt(++j)==\\'-\\');\\n                }\\n            }\\n        }\\n\\n        //if no right child node find, we only use recursive call to build left child and return node\\n        if (rightIndex == -1) {\\n            node.left = recoverTreeByLevel(S.substring(leftIndex), level + 1);\\n            return node;\\n        }\\n\\n        \\n        //if we find both left and right, we need build both children and then return\\n        node.left = recoverTreeByLevel(S.substring(leftIndex, rightIndex), level + 1);\\n        node.right = recoverTreeByLevel(S.substring(rightIndex+level), level + 1);\\n        return node;\\n\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532929,
                "title": "java-recursive-simple-and-short",
                "content": "```\\nclass Solution {\\n\\tint index = 0;\\n\\tpublic TreeNode recoverFromPreorder(String s) {\\n\\t\\treturn helper(s, 0);\\n\\t}\\n\\n\\tpublic TreeNode helper(String s, int depth) {\\n\\t\\tint temp = 0;\\n\\t\\twhile (index + temp < s.length() && s.charAt(index + temp) == \\'-\\') {\\n\\t\\t\\ttemp++;\\n\\t\\t}\\n\\t\\tif (temp != depth) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tint nd = 0;\\n\\t\\twhile (index + temp + nd < s.length() && s.charAt(index + temp + nd) != \\'-\\') {\\n\\t\\t\\tnd++;\\n\\t\\t}\\n\\t\\tint val = Integer.parseInt(s.substring(index + temp, index + temp + nd));\\n\\t\\tindex = index + temp + nd;\\n\\n\\t\\tTreeNode node = new TreeNode(val);\\n\\t\\tnode.left = helper(s, depth + 1);\\n\\t\\tnode.right = helper(s, depth + 1);\\n\\n\\t\\treturn node;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\tint index = 0;\\n\\tpublic TreeNode recoverFromPreorder(String s) {\\n\\t\\treturn helper(s, 0);\\n\\t}\\n\\n\\tpublic TreeNode helper(String s, int depth) {\\n\\t\\tint temp = 0;\\n\\t\\twhile (index + temp < s.length() && s.charAt(index + temp) == \\'-\\') {\\n\\t\\t\\ttemp++;\\n\\t\\t}\\n\\t\\tif (temp != depth) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tint nd = 0;\\n\\t\\twhile (index + temp + nd < s.length() && s.charAt(index + temp + nd) != \\'-\\') {\\n\\t\\t\\tnd++;\\n\\t\\t}\\n\\t\\tint val = Integer.parseInt(s.substring(index + temp, index + temp + nd));\\n\\t\\tindex = index + temp + nd;\\n\\n\\t\\tTreeNode node = new TreeNode(val);\\n\\t\\tnode.left = helper(s, depth + 1);\\n\\t\\tnode.right = helper(s, depth + 1);\\n\\n\\t\\treturn node;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430236,
                "title": "cpp-solution-using-map",
                "content": "**Please Upvote**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int,TreeNode*>m;\\n        TreeNode* root,*ptr;\\n        int i=0;\\n        string num=\"\";\\n        while(i<traversal.size() && traversal[i]!=\\'-\\'){\\n            num+=traversal[i];\\n            i++;\\n        }\\n        \\n        ptr =new TreeNode(stoi(num));\\n        m[0]=ptr;\\n        root=ptr;\\n        \\n        while(i<traversal.size()){\\n            int dash=0;\\n            string s=\"\";\\n            while(traversal[i]==\\'-\\'){\\n                dash++;\\n                i++;\\n            }\\n            \\n            while(i<traversal.size() && traversal[i]!=\\'-\\'){\\n                s+=traversal[i];\\n                i++;\\n            }\\n            \\n            auto ele=new TreeNode(stoi(s));\\n            if(!m[dash-1]->left)m[dash-1]->left=ele;\\n            else m[dash-1]->right=ele;\\n            \\n            m[dash]=ele;\\n        }\\n        \\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int,TreeNode*>m;\\n        TreeNode* root,*ptr;\\n        int i=0;\\n        string num=\"\";\\n        while(i<traversal.size() && traversal[i]!=\\'-\\'){\\n            num+=traversal[i];\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1019379,
                "title": "easy-stack-based-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    TreeNode* recoverFromPreorder(string S) \\n    {\\n        stack<TreeNode *>stk;\\n        int i=0;\\n        while(i<S.length())\\n        {\\n            int level=0;\\n            while(i<S.length() && S[i]==\\'-\\')\\n            {\\n                level++;\\n                i++;\\n            }\\n            if(i==S.length())\\n            {\\n                break;\\n            }\\n            int start=i;\\n            while(i<S.length() && S[i]!=\\'-\\')\\n            {\\n                i++;\\n            }\\n            int x=stoi(S.substr(start,i-start));\\n            TreeNode *tmp=new TreeNode(x);\\n            if(stk.empty())\\n            {\\n                stk.push(tmp);\\n                continue;\\n            }\\n            while(stk.size()>level)\\n            {\\n                stk.pop();\\n            }\\n            if(stk.top()->left)\\n            {\\n                stk.top()->right=tmp;\\n            }\\n            else\\n            {\\n                stk.top()->left=tmp;\\n            }\\n            stk.push(tmp);\\n        }\\n        while(stk.size()!=1)\\n        {\\n            stk.pop();\\n        }\\n        return stk.top();\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    TreeNode* recoverFromPreorder(string S) \\n    {\\n        stack<TreeNode *>stk;\\n        int i=0;\\n        while(i<S.length())\\n        {\\n            int level=0;\\n            while(i<S.length() && S[i]==\\'-\\')\\n            {\\n                level++;\\n                i++;\\n            }\\n            if(i==S.length())\\n            {\\n                break;\\n            }\\n            int start=i;\\n            while(i<S.length() && S[i]!=\\'-\\')\\n            {\\n                i++;\\n            }\\n            int x=stoi(S.substr(start,i-start));\\n            TreeNode *tmp=new TreeNode(x);\\n            if(stk.empty())\\n            {\\n                stk.push(tmp);\\n                continue;\\n            }\\n            while(stk.size()>level)\\n            {\\n                stk.pop();\\n            }\\n            if(stk.top()->left)\\n            {\\n                stk.top()->right=tmp;\\n            }\\n            else\\n            {\\n                stk.top()->left=tmp;\\n            }\\n            stk.push(tmp);\\n        }\\n        while(stk.size()!=1)\\n        {\\n            stk.pop();\\n        }\\n        return stk.top();\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786958,
                "title": "well-commented-and-explained-step-by-step-process-time-beats-94",
                "content": "### Our approach is:\\n1. find the depth of up comming node with the help of \\'-\\'\\n2. find the node val because node value can be of more than one digit\\n3. do iterative version of dfs:\\n\\t* \\tif our stack top node has depht 1 less then upcoming node then append the curr node to left of  top of node of stack because string has in-order based..\\n\\t* \\tnow the problem is *what if when we have depth of curr node greater than top of node of stack*,    In this condition we start poping all the node *(as we do dfs)* till the point where node at the top of stack has one difference with current upcoming node.. And we decide to append the currnode with the top of stack\\'s node on right side.... Because input is inorder and we have back track i.e. we have filled the left subtree for node which is at the top of stack and now turn comes for right subtree\\n\\nRest of process my commend will do:)\\n```\\nTreeNode* recoverFromPreorder(string str) {\\n\\tTreeNode *root=new TreeNode();\\n\\tif(str.size()==0) return root=nullptr;//an empty tree\\n\\tstack<pair<TreeNode * , int>> pending;\\n\\t//first element of pair is for the storing the node and secod pair is for the storing the depth of that node\\n\\tint index=0,nodeVal=0;\\n\\t//find the node val for tree\\n\\twhile(index<str.size() && str[index]!=\\'-\\') nodeVal=nodeVal*10+str[index++]-\\'0\\';\\n\\troot=new TreeNode(nodeVal);\\n\\tpending.push(make_pair(root , 0));\\n\\twhile(pending.size() && index<str.size()){\\n\\t\\tint depth=0;\\n\\t\\twhile(index<str.size() && str[index]==\\'-\\') index++ , depth++;\\t//find the depth of next node\\n\\t\\tnodeVal=0;\\n\\t\\t//let\\'s find the node value\\n\\t\\twhile(index<str.size() && str[index]!=\\'-\\') nodeVal=nodeVal*10+str[index++]-\\'0\\';\\n\\tTreeNode * currNode=new TreeNode(nodeVal);\\n\\t//LET\\'S get the parent what i have inserted earlier\\n\\t\\tpair<TreeNode* , int> parent=pending.top();\\n\\t\\t//if the difference between parent and current node is 1 then make curr node as left child of parent\\n\\t\\t//because question has given that If a node has only one child, that child is guaranteed to be the left child.\\n\\t\\tif((depth-parent.second)==1){\\n\\t\\t\\t//make curr node as a left child of the parent\\n\\t\\t\\t(parent.first)->left=currNode;\\n\\t\\t\\tpending.push(make_pair(currNode , depth));\\n\\t\\t}else{\\n\\t\\t\\t//find the parent of current node and append curr node as a right child of that parent\\n\\t\\t\\twhile(pending.size() && (depth - pending.top().second)!=1){\\n\\t\\t\\t\\tpending.pop();\\n\\t\\t\\t}\\n\\t\\t\\t//now our top has suitable parent for the curr node now append the curr node with parent as a right child .....\\n\\t\\t\\t//right child cause of we have been backtracking that\\'s why we assumed that our left subtree completed\\n\\t\\t\\tparent=pending.top();\\n\\t\\t\\t(parent.first)->right=currNode;\\n\\t\\t\\tpending.push(make_pair(currNode  , depth));//append curr node\\n\\t\\t}\\n\\t}\\n\\treturn root;\\n}\\n```\\nPlease vote if it help you:)\\nHappy coding!!!",
                "solutionTags": [],
                "code": "```\\nTreeNode* recoverFromPreorder(string str) {\\n\\tTreeNode *root=new TreeNode();\\n\\tif(str.size()==0) return root=nullptr;//an empty tree\\n\\tstack<pair<TreeNode * , int>> pending;\\n\\t//first element of pair is for the storing the node and secod pair is for the storing the depth of that node\\n\\tint index=0,nodeVal=0;\\n\\t//find the node val for tree\\n\\twhile(index<str.size() && str[index]!=\\'-\\') nodeVal=nodeVal*10+str[index++]-\\'0\\';\\n\\troot=new TreeNode(nodeVal);\\n\\tpending.push(make_pair(root , 0));\\n\\twhile(pending.size() && index<str.size()){\\n\\t\\tint depth=0;\\n\\t\\twhile(index<str.size() && str[index]==\\'-\\') index++ , depth++;\\t//find the depth of next node\\n\\t\\tnodeVal=0;\\n\\t\\t//let\\'s find the node value\\n\\t\\twhile(index<str.size() && str[index]!=\\'-\\') nodeVal=nodeVal*10+str[index++]-\\'0\\';\\n\\tTreeNode * currNode=new TreeNode(nodeVal);\\n\\t//LET\\'S get the parent what i have inserted earlier\\n\\t\\tpair<TreeNode* , int> parent=pending.top();\\n\\t\\t//if the difference between parent and current node is 1 then make curr node as left child of parent\\n\\t\\t//because question has given that If a node has only one child, that child is guaranteed to be the left child.\\n\\t\\tif((depth-parent.second)==1){\\n\\t\\t\\t//make curr node as a left child of the parent\\n\\t\\t\\t(parent.first)->left=currNode;\\n\\t\\t\\tpending.push(make_pair(currNode , depth));\\n\\t\\t}else{\\n\\t\\t\\t//find the parent of current node and append curr node as a right child of that parent\\n\\t\\t\\twhile(pending.size() && (depth - pending.top().second)!=1){\\n\\t\\t\\t\\tpending.pop();\\n\\t\\t\\t}\\n\\t\\t\\t//now our top has suitable parent for the curr node now append the curr node with parent as a right child .....\\n\\t\\t\\t//right child cause of we have been backtracking that\\'s why we assumed that our left subtree completed\\n\\t\\t\\tparent=pending.top();\\n\\t\\t\\t(parent.first)->right=currNode;\\n\\t\\t\\tpending.push(make_pair(currNode  , depth));//append curr node\\n\\t\\t}\\n\\t}\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476158,
                "title": "simple-java-recursive-solution-with-detailed-explanation-100-time",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    private int index;      // index for chars\\n    private char[] chars;   // chars for string S\\n    \\n    public TreeNode recoverFromPreorder(String S) {\\n        if (S == null || S.length() == 0)\\n            return null;\\n        \\n        // initialize global values for a fresh run\\n        index = 0;\\n        chars = S.toCharArray();\\n        \\n        TreeNode root = new TreeNode(getNodeVal());\\n        helper(0, root);\\n        return root;\\n    }\\n    \\n    private void helper(int level, TreeNode parent) {\\n        // keep tracking next number of dashes\\n        int numOfDashes = getNumOfDashes();\\n        \\n        // as long as the number of dashes is directly 1 more than level, we append it as a direct child\\n        while (numOfDashes == level + 1) {\\n            index += numOfDashes;       // move index to next non-dash character\\n            TreeNode newNode = new TreeNode(getNodeVal());\\n            \\n            // \"If a node has only one child, that child is guaranteed to be the left child.\"\\n            // always first try to append new node to the left of parent node\\n            if (parent.left == null)\\n                parent.left = newNode;\\n            else\\n                parent.right = newNode;\\n            \\n            // recursively append children in the next level\\n            helper(level + 1, newNode);\\n            \\n            // see if there exist right child node\\n            numOfDashes = getNumOfDashes();\\n        }\\n    }\\n    \\n    private int getNodeVal() {\\n        if (index >= chars.length)\\n            return -1;\\n        \\n        int count = 0, i;\\n        for (i = index; i < chars.length && chars[i] != \\'-\\'; i++)\\n            count = count * 10 + (chars[i] - \\'0\\');\\n        \\n        // update index\\n        index = i;\\n        return count;\\n    }\\n    \\n    private int getNumOfDashes() {\\n        if (index >= chars.length)\\n            return -1;\\n        \\n        int count = 0;\\n        for (int i = index; i < chars.length && chars[i] == \\'-\\'; i++)\\n            count ++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    private int index;      // index for chars\\n    private char[] chars;   // chars for string S\\n    \\n    public TreeNode recoverFromPreorder(String S) {\\n        if (S == null || S.length() == 0)\\n            return null;\\n        \\n        // initialize global values for a fresh run\\n        index = 0;\\n        chars = S.toCharArray();\\n        \\n        TreeNode root = new TreeNode(getNodeVal());\\n        helper(0, root);\\n        return root;\\n    }\\n    \\n    private void helper(int level, TreeNode parent) {\\n        // keep tracking next number of dashes\\n        int numOfDashes = getNumOfDashes();\\n        \\n        // as long as the number of dashes is directly 1 more than level, we append it as a direct child\\n        while (numOfDashes == level + 1) {\\n            index += numOfDashes;       // move index to next non-dash character\\n            TreeNode newNode = new TreeNode(getNodeVal());\\n            \\n            // \"If a node has only one child, that child is guaranteed to be the left child.\"\\n            // always first try to append new node to the left of parent node\\n            if (parent.left == null)\\n                parent.left = newNode;\\n            else\\n                parent.right = newNode;\\n            \\n            // recursively append children in the next level\\n            helper(level + 1, newNode);\\n            \\n            // see if there exist right child node\\n            numOfDashes = getNumOfDashes();\\n        }\\n    }\\n    \\n    private int getNodeVal() {\\n        if (index >= chars.length)\\n            return -1;\\n        \\n        int count = 0, i;\\n        for (i = index; i < chars.length && chars[i] != \\'-\\'; i++)\\n            count = count * 10 + (chars[i] - \\'0\\');\\n        \\n        // update index\\n        index = i;\\n        return count;\\n    }\\n    \\n    private int getNumOfDashes() {\\n        if (index >= chars.length)\\n            return -1;\\n        \\n        int count = 0;\\n        for (int i = index; i < chars.length && chars[i] == \\'-\\'; i++)\\n            count ++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353177,
                "title": "c-simple-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* util(int &in, string s, int level) {\\n        if(in >= s.length())return NULL;\\n        int count=0;\\n        while(s[in+count] == \\'-\\'){count++;}\\n        \\n        if(count == level){\\n            in += count;\\n            \\n            long int val=0;\\n            while(isdigit(s[in])){\\n                val = 10*val + (s[in]-\\'0\\');\\n                in++;\\n            }\\n            \\n            TreeNode *node = new TreeNode(val);\\n            node->left = util(in,s,level+1);\\n            node->right = util(in,s,level+1);\\n            return node;\\n        }\\n        return NULL;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string S) {\\n        int in=0,level=0;\\n        return util(in,S,level);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* util(int &in, string s, int level) {\\n        if(in >= s.length())return NULL;\\n        int count=0;\\n        while(s[in+count] == \\'-\\'){count++;}\\n        \\n        if(count == level){\\n            in += count;\\n            \\n            long int val=0;\\n            while(isdigit(s[in])){\\n                val = 10*val + (s[in]-\\'0\\');\\n                in++;\\n            }\\n            \\n            TreeNode *node = new TreeNode(val);\\n            node->left = util(in,s,level+1);\\n            node->right = util(in,s,level+1);\\n            return node;\\n        }\\n        return NULL;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string S) {\\n        int in=0,level=0;\\n        return util(in,S,level);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352551,
                "title": "simple-and-easy-javascript-solution",
                "content": "I guess this problem is not so hard as seems. Just parse `S`, where a number of dashes is level (or depth). You know values and its levels (or depths) respectively. Then construct a tree iterating values and its levels (or depths). To find out the parent of some node use `nodeOnLevel` table (`par = nodeOnLevel[lev - 1]`)\\n```\\nconst levs = S.split(/\\\\d/).filter(s => s !== \\'\\').map(s => s.length)\\nconst nums = S.split(/-+/) \\n\\nconst root = new TreeNode(nums.shift())\\nconst nodeOnLevel = [root]\\n\\nlet i = 0\\n\\nwhile (i < nums.length) {\\n\\tconst val = nums[i]\\n\\tconst node = new TreeNode(val)\\n\\tconst lev = levs[i]\\n\\tconst par = nodeOnLevel[lev - 1]\\n\\n\\tif (!par.left) par.left = node\\n\\telse if (!par.right) par.right = node\\n\\n\\tnodeOnLevel[lev] = node\\n\\ti++\\n}\\n\\nreturn root\\n```",
                "solutionTags": [],
                "code": "```\\nconst levs = S.split(/\\\\d/).filter(s => s !== \\'\\').map(s => s.length)\\nconst nums = S.split(/-+/) \\n\\nconst root = new TreeNode(nums.shift())\\nconst nodeOnLevel = [root]\\n\\nlet i = 0\\n\\nwhile (i < nums.length) {\\n\\tconst val = nums[i]\\n\\tconst node = new TreeNode(val)\\n\\tconst lev = levs[i]\\n\\tconst par = nodeOnLevel[lev - 1]\\n\\n\\tif (!par.left) par.left = node\\n\\telse if (!par.right) par.right = node\\n\\n\\tnodeOnLevel[lev] = node\\n\\ti++\\n}\\n\\nreturn root\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2893500,
                "title": "c-solution-hasp-map-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince first node at a particular level will always be the left child of its parent element, we cannot have a tree that will have a ```NULL``` left subtree and a ```!NULL``` right subtree. So at a level, if we have a left child, we assign the current node to the right pointer of the parent, else to the left pointer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a hash map to store the last node added at any level. Then while iterating we, keep track of the current level ```d```. Then we use the map to find the parent element of this node from the map i.e ```mp[d-1]```, and assign the node to the parent\\'s right or left pointer accordingly.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string t) {\\n        if(t.size()==0) return NULL;\\n        unordered_map<int,TreeNode*> mp;\\n        int num = 0, i = 0;\\n        int n = t.size();\\n        while(i<n && isdigit(t[i])){\\n            num = num*10 + (t[i]-\\'0\\');\\n            i++;\\n        }\\n        TreeNode* root = new TreeNode(num);\\n        mp[0] = root;\\n        int d = 0;\\n        while(i<n){\\n            if(t[i]==\\'-\\'){\\n                d++;i++;\\n            }\\n            else{\\n                num = 0;\\n                while(i<n && isdigit(t[i])){\\n                    num = num*10 + (t[i]-\\'0\\');\\n                    i++;\\n                }\\n                TreeNode* node = mp[d-1];\\n                if(!node->left){\\n                    node->left = new TreeNode(num);\\n                    mp[d]=node->left;\\n                }\\n                else{\\n                    node->right = new TreeNode(num);\\n                    mp[d]=node->right;\\n                }\\n                d=0;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```NULL```\n```!NULL```\n```d```\n```mp[d-1]```\n```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string t) {\\n        if(t.size()==0) return NULL;\\n        unordered_map<int,TreeNode*> mp;\\n        int num = 0, i = 0;\\n        int n = t.size();\\n        while(i<n && isdigit(t[i])){\\n            num = num*10 + (t[i]-\\'0\\');\\n            i++;\\n        }\\n        TreeNode* root = new TreeNode(num);\\n        mp[0] = root;\\n        int d = 0;\\n        while(i<n){\\n            if(t[i]==\\'-\\'){\\n                d++;i++;\\n            }\\n            else{\\n                num = 0;\\n                while(i<n && isdigit(t[i])){\\n                    num = num*10 + (t[i]-\\'0\\');\\n                    i++;\\n                }\\n                TreeNode* node = mp[d-1];\\n                if(!node->left){\\n                    node->left = new TreeNode(num);\\n                    mp[d]=node->left;\\n                }\\n                else{\\n                    node->right = new TreeNode(num);\\n                    mp[d]=node->right;\\n                }\\n                d=0;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448129,
                "title": "short-easy-iterative-solution-using-hashmap-c-solution",
                "content": "```\\nTreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int,TreeNode*> node;\\n        node[-1] = new TreeNode(0);\\n        int dep = 0;\\n        int n = traversal.length();\\n        for(int i=0;i<n;){\\n            if(traversal[i]==\\'-\\'){\\n                dep = 0;\\n                while(traversal[i]==\\'-\\'){\\n                    dep++;i++;\\n                }\\n            }\\n            else{\\n                int val;\\n                string temp = \"\";\\n                while(i<n && traversal[i]!=\\'-\\'){\\n                    temp+=traversal[i];\\n                    i++;\\n                }\\n                val = stoi(temp);\\n                TreeNode* curr = new TreeNode(val);\\n                if(node[dep-1]->left)\\n                    node[dep-1]->right = curr;\\n                else \\n                    node[dep-1]->left = curr;\\n                node[dep] = curr;\\n            }\\n        }\\n        \\n        return node[-1]->left;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nTreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int,TreeNode*> node;\\n        node[-1] = new TreeNode(0);\\n        int dep = 0;\\n        int n = traversal.length();\\n        for(int i=0;i<n;){\\n            if(traversal[i]==\\'-\\'){\\n                dep = 0;\\n                while(traversal[i]==\\'-\\'){\\n                    dep++;i++;\\n                }\\n            }\\n            else{\\n                int val;\\n                string temp = \"\";\\n                while(i<n && traversal[i]!=\\'-\\'){\\n                    temp+=traversal[i];\\n                    i++;\\n                }\\n                val = stoi(temp);\\n                TreeNode* curr = new TreeNode(val);\\n                if(node[dep-1]->left)\\n                    node[dep-1]->right = curr;\\n                else \\n                    node[dep-1]->left = curr;\\n                node[dep] = curr;\\n            }\\n        }\\n        \\n        return node[-1]->left;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1778322,
                "title": "c-with-intuition-and-commented-code",
                "content": "\\n**The Intuition**\\nIf we find the depth of a node, it must be 1 greater than its parent. So using this we can find out if a node is a child of the previous value or not. If a node has depth 1 greater than the previous value in the string, then it should be joined to the previous node else we must return NULL. Now, we can build the tree using the power of recursion.\\n\\n\\n\\n\\n\\n\\tclass Solution {\\n\\n\\t\\tint n;\\t\\t\\t//Length of string\\n\\n\\n\\t\\t//Returns the numerical digit of character digit\\n\\t\\tint char_int(char a){\\n\\t\\t\\treturn (a-\\'0\\');\\n\\t\\t}\\n\\n\\n\\t\\t//Finds the depth of the value with respect to the \\'-\\' present before it in the string\\n\\t\\tint count_depth(string &traversal,int str){\\n\\t\\t\\tint cnt=0;\\n\\n\\t\\t//Running the loop until we get any numeric digit\\n\\t\\t\\twhile(traversal[str]==\\'-\\'){str++;cnt++;}\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\n\\t\\t//Returns the value of the node\\n\\t\\tint value(string& traversal,int &str){\\n\\t\\t\\tint val=0;\\n\\n\\t\\t//Running the loop until we get \\'-\\' or the end of string\\n\\t\\t\\twhile(str<n&&traversal[str]>=\\'0\\'&&traversal[str]<=\\'9\\')val=(val*10+char_int(traversal[str++]));\\n\\t\\t\\treturn val;\\n\\t\\t}\\n\\n\\n\\n\\t\\t/*We pass the string, the index pointer and the depth of the previous value in the string\\n\\t\\tWe are passing the index pointer by reference, as it would be helpful \\n\\t\\tin eliminating unnecessary syntax of increasing the index pointer, \\n\\t\\twhich may lead to some errors, which can be difficult to debug. */\\n\\t\\tTreeNode* gen_tree(string &traversal,int &str,int dep){\\n\\n\\t\\t\\tif(str>=n)return NULL;\\t// Returns NULL whenever the string is complete\\n\\n\\t\\t\\tint depth=count_depth(traversal,str);\\t\\t// Finding the depth of the node\\n\\n\\t\\t/*If the depth is not 1 greater than the depth of the previous value,\\n\\t\\tthen it cannot be a child of it, so we return NULL*/\\n\\t\\t\\tif(depth!=dep+1)return NULL;\\n\\n\\t\\t/* If it is a child of the previous value, then we are\\n\\t\\tjust increasing the pointer to the value portion of the string*/\\n\\t\\t\\tstr+=depth;\\n\\n\\n\\t\\t\\tTreeNode* root=new TreeNode(value(traversal,str));\\t//Creating the node using the value\\n\\n\\n\\n\\t\\t\\troot->left=gen_tree(traversal,str,depth);\\t//Calling the recursion for the left child\\n\\n\\n\\t\\t\\troot->right=gen_tree(traversal,str,depth);\\t//Calling the recursion for the right child\\n\\n\\t\\t\\treturn root;\\t//Returning the root\\n\\t\\t}\\n\\n\\t\\tpublic:\\n\\t\\tTreeNode* recoverFromPreorder(string traversal) {\\n\\t\\t\\tn=traversal.size();\\n\\t\\t\\tint str=0;\\n\\n\\t\\t/* We are passing the depth as -1, as the depth of the root is 0, \\n\\t\\tso it will upheld the parent-child depth relationship*/\\n\\t\\t\\treturn gen_tree(traversal,str,-1);\\t\\n\\t\\t}\\n\\t};\\n\\n\\nThanks for reading the blog. Any suggesstions will be highly appreciated\\uD83D\\uDE4F",
                "solutionTags": [
                    "Tree",
                    "Recursion",
                    "Interactive"
                ],
                "code": "class Solution {\\n\\n\\t\\tint n;\\t\\t\\t//Length of string\\n\\n\\n\\t\\t//Returns the numerical digit of character digit\\n\\t\\tint char_int(char a){\\n\\t\\t\\treturn (a-\\'0\\');\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1722014,
                "title": "c-easy-preorder-traversal-solution",
                "content": "```\\n#define l left\\n#define r right\\n#define null nullptr\\nclass Solution {\\npublic:\\n    vector<char> v;\\n    int i = 0;\\n    void solve(TreeNode* root,int pd, int& cd,int& x){\\n        if (i<v.size() && v[i]==\\'-\\'){\\n            if(x==-1){\\n                cd++;\\n                i++;\\n                solve(root,pd,cd,x);\\n            }else{\\n                i--;\\n            }\\n        }else if(i<v.size() && x==-1){\\n            x=v[i]-\\'0\\';\\n            i++;\\n            solve(root,pd,cd,x);\\n        }else if (i<v.size() && v[i-1]!=\\'-\\' && v[i]!=\\'-\\'){\\n            x=x*10+(v[i]-\\'0\\');\\n            i++;\\n            solve(root,pd,cd,x);\\n        }\\n        if(cd>pd){\\n            root->l= new TreeNode(x);\\n            x=-1;\\n            i++;\\n            pd=cd;\\n            cd=0;\\n            solve(root->l,pd,cd,x);\\n        }else{\\n            return ;\\n        }\\n        if(cd==pd){\\n            root->r= new TreeNode(x);\\n            x=-1;\\n            i++;\\n            pd=cd;\\n            cd=0;\\n            solve(root->r,pd,cd,x);\\n        }\\n        return ;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) {\\n        for (auto j : traversal )\\n            v.push_back(j);\\n        TreeNode* root = new TreeNode();\\n        int x =0;\\n        while(i<v.size() && v[i]!=\\'-\\'){\\n            x=x*10 + (v[i]-\\'0\\');\\n            i++;\\n        }\\n        root->val=x;\\n        if(traversal.size()==1) return root;\\n        int d = 0;x=-1;\\n        solve(root,0,d,x);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n#define l left\\n#define r right\\n#define null nullptr\\nclass Solution {\\npublic:\\n    vector<char> v;\\n    int i = 0;\\n    void solve(TreeNode* root,int pd, int& cd,int& x){\\n        if (i<v.size() && v[i]==\\'-\\'){\\n            if(x==-1){\\n                cd++;\\n                i++;\\n                solve(root,pd,cd,x);\\n            }else{\\n                i--;\\n            }\\n        }else if(i<v.size() && x==-1){\\n            x=v[i]-\\'0\\';\\n            i++;\\n            solve(root,pd,cd,x);\\n        }else if (i<v.size() && v[i-1]!=\\'-\\' && v[i]!=\\'-\\'){\\n            x=x*10+(v[i]-\\'0\\');\\n            i++;\\n            solve(root,pd,cd,x);\\n        }\\n        if(cd>pd){\\n            root->l= new TreeNode(x);\\n            x=-1;\\n            i++;\\n            pd=cd;\\n            cd=0;\\n            solve(root->l,pd,cd,x);\\n        }else{\\n            return ;\\n        }\\n        if(cd==pd){\\n            root->r= new TreeNode(x);\\n            x=-1;\\n            i++;\\n            pd=cd;\\n            cd=0;\\n            solve(root->r,pd,cd,x);\\n        }\\n        return ;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) {\\n        for (auto j : traversal )\\n            v.push_back(j);\\n        TreeNode* root = new TreeNode();\\n        int x =0;\\n        while(i<v.size() && v[i]!=\\'-\\'){\\n            x=x*10 + (v[i]-\\'0\\');\\n            i++;\\n        }\\n        root->val=x;\\n        if(traversal.size()==1) return root;\\n        int d = 0;x=-1;\\n        solve(root,0,d,x);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664886,
                "title": "c-intuitive-solution",
                "content": "Follow the following steps:\\n1. Retrieve the depth of the node\\n2. Retrieve the value of the node\\n3. Save the node at depth using a hashmap\\n4. Check for the parent node and link the parent and child node together\\nHere\\'s the code, Happy Coding! \\uD83D\\uDE01\\n```\\nclass Solution {\\npublic:   \\n    TreeNode* recoverFromPreorder(string t) \\n    {\\n        unordered_map<int, TreeNode*>hash;        \\n        for(int i = 0; i < t.length(); i++)\\n        {\\n            string temp = \"\";\\n            while(i < t.length() and !isdigit(t[i]))\\n            {\\n                temp += t[i];\\n                i++;\\n            }//Getting the dashes for depth    \\n            \\n            string curr_s = \"\";\\n            while(i < t.length() and isdigit(t[i]))\\n            {\\n                curr_s += t[i];\\n                i++;\\n            }//Getting the value of node          \\n            \\n            TreeNode *curr = new TreeNode(stoi(curr_s));\\n            hash[temp.length()] = curr;//Saving the node with depth\\n            \\n            if(hash.find(temp.length() - 1) != hash.end())\\n            {                \\n                TreeNode *parent = hash[temp.length() - 1];\\n                if(parent -> left == NULL)\\n                    parent -> left = curr;\\n                else\\n                    parent -> right = curr;\\n            }//Finding parent and linking the child\\n            i--;\\n        }\\n        return hash[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:   \\n    TreeNode* recoverFromPreorder(string t) \\n    {\\n        unordered_map<int, TreeNode*>hash;        \\n        for(int i = 0; i < t.length(); i++)\\n        {\\n            string temp = \"\";\\n            while(i < t.length() and !isdigit(t[i]))\\n            {\\n                temp += t[i];\\n                i++;\\n            }//Getting the dashes for depth    \\n            \\n            string curr_s = \"\";\\n            while(i < t.length() and isdigit(t[i]))\\n            {\\n                curr_s += t[i];\\n                i++;\\n            }//Getting the value of node          \\n            \\n            TreeNode *curr = new TreeNode(stoi(curr_s));\\n            hash[temp.length()] = curr;//Saving the node with depth\\n            \\n            if(hash.find(temp.length() - 1) != hash.end())\\n            {                \\n                TreeNode *parent = hash[temp.length() - 1];\\n                if(parent -> left == NULL)\\n                    parent -> left = curr;\\n                else\\n                    parent -> right = curr;\\n            }//Finding parent and linking the child\\n            i--;\\n        }\\n        return hash[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441088,
                "title": "java-recursion-simple-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return helper(1, traversal);\\n    }\\n    \\n    private TreeNode helper(int level, String str){\\n        int i = 0;\\n        while(i < str.length() && str.charAt(i) != \\'-\\')\\n            i++;\\n        TreeNode root = new TreeNode(Integer.parseInt(str.substring(0, i)));\\n        if(i < str.length()){\\n            String rem = str.substring(i + level);\\n            int j = getidx(rem, level);\\n            if(j != -1){\\n                root.left = helper(level + 1, rem.substring(0, j));\\n                root.right = helper(level + 1, rem.substring(j + level));\\n            } else\\n                root.left = helper(level + 1, rem);\\n        }\\n        return root;\\n    }\\n    \\n    private int getidx(String str, int dash){\\n        int count = 0;\\n        for(int i = 0; i < str.length(); i++){\\n            if(str.charAt(i) == \\'-\\')\\n                count++;\\n            else{\\n                if(count == dash)\\n                    return i - dash;\\n                count = 0;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return helper(1, traversal);\\n    }\\n    \\n    private TreeNode helper(int level, String str){\\n        int i = 0;\\n        while(i < str.length() && str.charAt(i) != \\'-\\')\\n            i++;\\n        TreeNode root = new TreeNode(Integer.parseInt(str.substring(0, i)));\\n        if(i < str.length()){\\n            String rem = str.substring(i + level);\\n            int j = getidx(rem, level);\\n            if(j != -1){\\n                root.left = helper(level + 1, rem.substring(0, j));\\n                root.right = helper(level + 1, rem.substring(j + level));\\n            } else\\n                root.left = helper(level + 1, rem);\\n        }\\n        return root;\\n    }\\n    \\n    private int getidx(String str, int dash){\\n        int count = 0;\\n        for(int i = 0; i < str.length(); i++){\\n            if(str.charAt(i) == \\'-\\')\\n                count++;\\n            else{\\n                if(count == dash)\\n                    return i - dash;\\n                count = 0;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351559,
                "title": "c-simple-approach-easy-to-understand",
                "content": "We are storing the number of levels to help us understand the relation between nodes better and the value starting point and end point to insert the whole value in the stack.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        stack <TreeNode*> s;\\n        for (int i = 0; i < traversal.length();){\\n            int level = 0;\\n            while(traversal[i] == \\'-\\')\\n                level++, i++;\\n            int strt = i;\\n            while(isdigit(traversal[i]))\\n                i++;\\n            int val = stoi(traversal.substr(strt, i - strt + 1));\\n            TreeNode* result = new TreeNode(val);\\n            if (s.empty())    \\n                {s.emplace(result); continue;}\\n            while(s.size() > level) \\n                s.pop();\\n            if (s.top()->left)  \\n                s.top()->right = result;\\n            else \\n                s.top()->left = result;\\n            s.emplace(result);\\n        }\\n        while(s.size() > 1)\\n            s.pop();\\n        return s.top();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        stack <TreeNode*> s;\\n        for (int i = 0; i < traversal.length();){\\n            int level = 0;\\n            while(traversal[i] == \\'-\\')\\n                level++, i++;\\n            int strt = i;\\n            while(isdigit(traversal[i]))\\n                i++;\\n            int val = stoi(traversal.substr(strt, i - strt + 1));\\n            TreeNode* result = new TreeNode(val);\\n            if (s.empty())    \\n                {s.emplace(result); continue;}\\n            while(s.size() > level) \\n                s.pop();\\n            if (s.top()->left)  \\n                s.top()->right = result;\\n            else \\n                s.top()->left = result;\\n            s.emplace(result);\\n        }\\n        while(s.size() > 1)\\n            s.pop();\\n        return s.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179506,
                "title": "python3-stack",
                "content": "\\n```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        stack = []\\n        depth, val = 0, \"\"\\n        for i, x in enumerate(S): \\n            if x == \"-\": \\n                depth += 1\\n                val = \"\"\\n            else: \\n                val += S[i]\\n                if i+1 == len(S) or S[i+1] == \"-\": \\n                    node = TreeNode(int(val))\\n                    while len(stack) > depth: stack.pop()\\n                    if stack:\\n                        if not stack[-1].left: stack[-1].left = node\\n                        else: stack[-1].right = node\\n                    stack.append(node)\\n                    depth = 0\\n        return stack[0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        stack = []\\n        depth, val = 0, \"\"\\n        for i, x in enumerate(S): \\n            if x == \"-\": \\n                depth += 1\\n                val = \"\"\\n            else: \\n                val += S[i]\\n                if i+1 == len(S) or S[i+1] == \"-\": \\n                    node = TreeNode(int(val))\\n                    while len(stack) > depth: stack.pop()\\n                    if stack:\\n                        if not stack[-1].left: stack[-1].left = node\\n                        else: stack[-1].right = node\\n                    stack.append(node)\\n                    depth = 0\\n        return stack[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415217,
                "title": "python-recursion-solution-beat-99-31",
                "content": "This solution beats 99.31% of python3 submission.\\nI find result of S.split(\\'-\\') is a horrible thing. So I change something to make it work.\\n```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        for i in range(30, -1, -1):\\n            if S.find(\\'-\\' * i) != 0:\\n                S = S.replace(\\'-\\' * i, chr(i + 65))\\n        \\n        def helper(s, depth):\\n            tmp = s.split(chr(depth + 65))\\n            root = TreeNode(tmp[0])\\n            root.left = helper(tmp[1], depth+1) if len(tmp) > 1 else None\\n            root.right = helper(tmp[2], depth+1) if len(tmp) > 2 else None\\n            return root\\n        \\n        return helper(S, 1)\\n```\\nor iteration is better ~ But use more space.\\n```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        if not S: return\\n        l = S.split(\\'-\\')\\n        s, depth = [[TreeNode(l[0]), 0]], 1\\n        for item in l[1:]:\\n            if not item:\\n                depth += 1\\n                continue\\n            node = TreeNode(item)\\n            while s[-1][1] != depth - 1:\\n                s.pop()\\n            if not s[-1][0].left: \\n                s[-1][0].left = node\\n            else:\\n                s[-1][0].right = node\\n            s.append([node, depth])\\n            depth = 1\\n        return s[0][0]\\n```\\nIf you don\\'t like my solution, maybe his is more suitable for you.\\n[[Python] Beat 98.86%, 64ms, O(N) time](https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/discuss/275367/Python-Beat-98.86-64ms-O(N)-time)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        for i in range(30, -1, -1):\\n            if S.find(\\'-\\' * i) != 0:\\n                S = S.replace(\\'-\\' * i, chr(i + 65))\\n        \\n        def helper(s, depth):\\n            tmp = s.split(chr(depth + 65))\\n            root = TreeNode(tmp[0])\\n            root.left = helper(tmp[1], depth+1) if len(tmp) > 1 else None\\n            root.right = helper(tmp[2], depth+1) if len(tmp) > 2 else None\\n            return root\\n        \\n        return helper(S, 1)\\n```\n```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        if not S: return\\n        l = S.split(\\'-\\')\\n        s, depth = [[TreeNode(l[0]), 0]], 1\\n        for item in l[1:]:\\n            if not item:\\n                depth += 1\\n                continue\\n            node = TreeNode(item)\\n            while s[-1][1] != depth - 1:\\n                s.pop()\\n            if not s[-1][0].left: \\n                s[-1][0].left = node\\n            else:\\n                s[-1][0].right = node\\n            s.append([node, depth])\\n            depth = 1\\n        return s[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323636,
                "title": "simple-java-solution-beating-92-in-speed-and-memory",
                "content": "```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        \\n        if(S == null || S.isEmpty())\\n            return null;\\n        \\n        int[] index = new int[1];\\n        index[0] = 0;\\n        \\n        return recoverMyTree(S, index, 0);\\n        \\n    }\\n    \\n    public TreeNode recoverMyTree(String S, int[] index, int depth)   {\\n        \\n        if(index[0] >= S.length())\\n            return null;\\n        \\n        //check if number of dashes are equal to depth\\n        \\n        int count = 0;\\n        for(int i = index[0]; i < S.length() && S.charAt(i) == \\'-\\'; i++)\\n            count++;\\n        \\n        TreeNode node = null;\\n        \\n        if(count == depth)  {\\n            index[0] += count;\\n            node = new TreeNode(getNumber(S, index));\\n            \\n            \\n            node.left = recoverMyTree(S, index, depth + 1);\\n            node.right = recoverMyTree(S, index, depth + 1);\\n        }\\n        \\n        return node;\\n        \\n    }\\n    \\n    public int getNumber(String S, int[] index) {\\n        \\n        int i = index[0];\\n        \\n        int number = 0;\\n        int mult = 10;\\n        \\n        while(index[0] < S.length() && S.charAt(index[0]) != \\'-\\') {\\n            \\n            number = (number*mult) + Character.getNumericValue(S.charAt(index[0]));\\n            index[0]++;\\n        }\\n        \\n        return number;\\n    }\\n    \\n}```",
                "solutionTags": [],
                "code": "```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        \\n        if(S == null || S.isEmpty())\\n            return null;\\n        \\n        int[] index = new int[1];\\n        index[0] = 0;\\n        \\n        return recoverMyTree(S, index, 0);\\n        \\n    }\\n    \\n    public TreeNode recoverMyTree(String S, int[] index, int depth)   {\\n        \\n        if(index[0] >= S.length())\\n            return null;\\n        \\n        //check if number of dashes are equal to depth\\n        \\n        int count = 0;\\n        for(int i = index[0]; i < S.length() && S.charAt(i) == \\'-\\'; i++)\\n            count++;\\n        \\n        TreeNode node = null;\\n        \\n        if(count == depth)  {\\n            index[0] += count;\\n            node = new TreeNode(getNumber(S, index));\\n            \\n            \\n            node.left = recoverMyTree(S, index, depth + 1);\\n            node.right = recoverMyTree(S, index, depth + 1);\\n        }\\n        \\n        return node;\\n        \\n    }\\n    \\n    public int getNumber(String S, int[] index) {\\n        \\n        int i = index[0];\\n        \\n        int number = 0;\\n        int mult = 10;\\n        \\n        while(index[0] < S.length() && S.charAt(index[0]) != \\'-\\') {\\n            \\n            number = (number*mult) + Character.getNumericValue(S.charAt(index[0]));\\n            index[0]++;\\n        }\\n        \\n        return number;\\n    }\\n    \\n}```",
                "codeTag": "Java"
            },
            {
                "id": 302415,
                "title": "java-map-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        if(S == null || S.length() == 0) return null;\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        int end = 0;\\n        while(end < S.length() && S.charAt(end) != \\'-\\') end++;\\n        TreeNode root = new TreeNode(Integer.valueOf(S.substring(0,end)));\\n        map.put(1, root);\\n        while(end< S.length()) {\\n            int prev = end;\\n            while(S.charAt(end) == \\'-\\') end++;\\n            int level = end - prev;\\n            TreeNode parent = map.get(level);\\n            prev = end;\\n            while(end < S.length() && S.charAt(end) != \\'-\\') end++;\\n            TreeNode child = new TreeNode(Integer.valueOf(S.substring(prev,end)));\\n            if(parent.left == null) parent.left = child;\\n            else parent.right = child;\\n            map.put(level+1,child);\\n        }\\n        return root;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        if(S == null || S.length() == 0) return null;\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        int end = 0;\\n        while(end < S.length() && S.charAt(end) != \\'-\\') end++;\\n        TreeNode root = new TreeNode(Integer.valueOf(S.substring(0,end)));\\n        map.put(1, root);\\n        while(end< S.length()) {\\n            int prev = end;\\n            while(S.charAt(end) == \\'-\\') end++;\\n            int level = end - prev;\\n            TreeNode parent = map.get(level);\\n            prev = end;\\n            while(end < S.length() && S.charAt(end) != \\'-\\') end++;\\n            TreeNode child = new TreeNode(Integer.valueOf(S.substring(prev,end)));\\n            if(parent.left == null) parent.left = child;\\n            else parent.right = child;\\n            map.put(level+1,child);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3282474,
                "title": "java-code",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int i=0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return traverse(traversal,0);\\n    }\\n    public TreeNode traverse(String traversal,int level)\\n    {\\n        if(i==traversal.length())return null;\\n        int j=i,c=0;\\n        while(traversal.charAt(j)==\\'-\\')\\n        {\\n            c+=1;\\n            j+=1;\\n        }\\n        if(c==level)\\n        {\\n            int k=j;\\n            while(j<traversal.length() && traversal.charAt(j)!=\\'-\\')j+=1;\\n            String sub=traversal.substring(k,j);\\n            i=j;\\n            TreeNode root=new TreeNode(Integer.parseInt(sub));\\n            root.left=traverse(traversal,level+1);\\n            root.right=traverse(traversal,level+1);\\n            return root;\\n        }\\n        else return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int i=0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return traverse(traversal,0);\\n    }\\n    public TreeNode traverse(String traversal,int level)\\n    {\\n        if(i==traversal.length())return null;\\n        int j=i,c=0;\\n        while(traversal.charAt(j)==\\'-\\')\\n        {\\n            c+=1;\\n            j+=1;\\n        }\\n        if(c==level)\\n        {\\n            int k=j;\\n            while(j<traversal.length() && traversal.charAt(j)!=\\'-\\')j+=1;\\n            String sub=traversal.substring(k,j);\\n            i=j;\\n            TreeNode root=new TreeNode(Integer.parseInt(sub));\\n            root.left=traverse(traversal,level+1);\\n            root.right=traverse(traversal,level+1);\\n            return root;\\n        }\\n        else return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355265,
                "title": "c-simple-iterative-solution-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n\\t// Returns the index of \\'-\\' if present otherwise returns the string length\\n    int findIndex(int ind, string &traversal){\\n        int req = traversal.size();\\n        for(int i=ind; i<traversal.size(); i++){\\n            if(traversal[i] == \\'-\\'){\\n                req = i;\\n                break;\\n            }\\n        }\\n        return req;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) {\\n        // Pushing the node along with its depth into the stack\\n        int depth = 0;\\n        stack<pair<TreeNode*,int>> st;\\n        \\n\\t\\t// Finding the root node\\n        int ind = findIndex(0, traversal);\\n        string str = traversal.substr(0, ind);\\n        TreeNode *root = new TreeNode(stoi(str));\\n        \\n\\t\\t// Pushing the root node along with its depth\\n        st.push({root, 0});\\n\\t\\t\\n\\t\\t// Starting from \\'ind\\' as it has the next \\'-\\' character\\n        int i = ind;\\n        \\n        while(i<traversal.size()){\\n\\t\\t\\t// Increment the depth\\n            if(traversal[i] == \\'-\\'){\\n                depth++;\\n                i++;\\n                continue;\\n            }\\n            \\n            // Find the complete number as no.of digits can be > 1\\n            int ind = findIndex(i, traversal);\\n            string str = traversal.substr(i, ind-i);\\n            TreeNode *node = new TreeNode(stoi(str));\\n            \\n            // Finding its appropriate parent, whose depth is one less than current depth\\n            while(!st.empty() && st.top().second != depth-1){\\n                st.pop();\\n            }\\n            \\n            // There is already left child for the parent\\n            if(st.top().first->left){\\n                st.top().first->right = node;\\n            }\\n            else{\\n                st.top().first->left = node;\\n            }\\n            \\n            // Pushing that node and its depth into stack\\n            st.push({node, depth});\\n            depth = 0;\\n            i = ind;\\n        }\\n    \\n        return root;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// Returns the index of \\'-\\' if present otherwise returns the string length\\n    int findIndex(int ind, string &traversal){\\n        int req = traversal.size();\\n        for(int i=ind; i<traversal.size(); i++){\\n            if(traversal[i] == \\'-\\'){\\n                req = i;\\n                break;\\n            }\\n        }\\n        return req;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) {\\n        // Pushing the node along with its depth into the stack\\n        int depth = 0;\\n        stack<pair<TreeNode*,int>> st;\\n        \\n\\t\\t// Finding the root node\\n        int ind = findIndex(0, traversal);\\n        string str = traversal.substr(0, ind);\\n        TreeNode *root = new TreeNode(stoi(str));\\n        \\n\\t\\t// Pushing the root node along with its depth\\n        st.push({root, 0});\\n\\t\\t\\n\\t\\t// Starting from \\'ind\\' as it has the next \\'-\\' character\\n        int i = ind;\\n        \\n        while(i<traversal.size()){\\n\\t\\t\\t// Increment the depth\\n            if(traversal[i] == \\'-\\'){\\n                depth++;\\n                i++;\\n                continue;\\n            }\\n            \\n            // Find the complete number as no.of digits can be > 1\\n            int ind = findIndex(i, traversal);\\n            string str = traversal.substr(i, ind-i);\\n            TreeNode *node = new TreeNode(stoi(str));\\n            \\n            // Finding its appropriate parent, whose depth is one less than current depth\\n            while(!st.empty() && st.top().second != depth-1){\\n                st.pop();\\n            }\\n            \\n            // There is already left child for the parent\\n            if(st.top().first->left){\\n                st.top().first->right = node;\\n            }\\n            else{\\n                st.top().first->left = node;\\n            }\\n            \\n            // Pushing that node and its depth into stack\\n            st.push({node, depth});\\n            depth = 0;\\n            i = ind;\\n        }\\n    \\n        return root;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2336413,
                "title": "java-recursion",
                "content": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        if(!traversal.contains(\"-\"))\\n            return new TreeNode(Integer.parseInt(traversal));\\n        String number = \"\";\\n        int i = 0;\\n        while(traversal.charAt(i)!=\\'-\\'){\\n            number+=traversal.charAt(i);\\n            i++;\\n        }\\n        //System.out.print(\"root = \" + number + \" \" + i + \"     \");\\n        TreeNode root = new TreeNode(Integer.parseInt(number));\\n        StringBuilder str = new StringBuilder();\\n        int bk = 0;\\n        for(int j = i; i < traversal.length(); i++){\\n            if(traversal.charAt(i-1) != \\'-\\' && traversal.charAt(i) == \\'-\\' && traversal.charAt(i+1) != \\'-\\')\\n                bk = str.toString().length();\\n            else if(!(traversal.charAt(i-1) != \\'-\\' && traversal.charAt(i) == \\'-\\'))\\n                str.append(traversal.charAt(i));\\n        }\\n        String divide = str.toString();\\n        \\n        TreeNode left = (bk==0)?recoverFromPreorder(divide):recoverFromPreorder(divide.substring(0,bk));\\n        TreeNode right = (bk==0)?null:recoverFromPreorder(divide.substring(bk,divide.length()));\\n        root.left = left;\\n        root.right = right;\\n            \\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        if(!traversal.contains(\"-\"))\\n            return new TreeNode(Integer.parseInt(traversal));\\n        String number = \"\";\\n        int i = 0;\\n        while(traversal.charAt(i)!=\\'-\\'){\\n            number+=traversal.charAt(i);\\n            i++;\\n        }\\n        //System.out.print(\"root = \" + number + \" \" + i + \"     \");\\n        TreeNode root = new TreeNode(Integer.parseInt(number));\\n        StringBuilder str = new StringBuilder();\\n        int bk = 0;\\n        for(int j = i; i < traversal.length(); i++){\\n            if(traversal.charAt(i-1) != \\'-\\' && traversal.charAt(i) == \\'-\\' && traversal.charAt(i+1) != \\'-\\')\\n                bk = str.toString().length();\\n            else if(!(traversal.charAt(i-1) != \\'-\\' && traversal.charAt(i) == \\'-\\'))\\n                str.append(traversal.charAt(i));\\n        }\\n        String divide = str.toString();\\n        \\n        TreeNode left = (bk==0)?recoverFromPreorder(divide):recoverFromPreorder(divide.substring(0,bk));\\n        TreeNode right = (bk==0)?null:recoverFromPreorder(divide.substring(bk,divide.length()));\\n        root.left = left;\\n        root.right = right;\\n            \\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900554,
                "title": "cpp-easy-to-understand",
                "content": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint ix = 0;\\n\\t\\tTreeNode* help(string t, int pnthgt){\\n\\t\\t\\tint val = 0;\\n\\t\\t\\twhile(ix < t.size() && isdigit(t[ix])){\\n\\t\\t\\t\\tval = val*10 + t[ix]-\\'0\\';\\n\\t\\t\\t\\tix = ix+1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(val == 0)return nullptr;\\n\\t\\t\\tTreeNode* root = new TreeNode(val);\\n\\t\\t\\tstring str;\\n\\t\\t\\tstr.append(pnthgt+1, \\'-\\');\\n\\t\\t\\tif(str == t.substr(ix, pnthgt+1)){\\n\\t\\t\\t\\tix = ix + pnthgt + 1;\\n\\t\\t\\t\\troot->left = help(t, pnthgt+1);\\n\\t\\t\\t}\\n\\t\\t\\telse return root;\\n\\n\\t\\t\\tif(str == t.substr(ix, pnthgt+1)){\\n\\t\\t\\t\\tix = ix + pnthgt + 1;\\n\\t\\t\\t\\troot->right = help(t, pnthgt+1);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn root;\\n\\n\\t\\t}\\n\\t\\tTreeNode* recoverFromPreorder(string t) {\\n\\t\\t\\tint ix = 0;\\n\\t\\t\\treturn help(t, 0);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint ix = 0;\\n\\t\\tTreeNode* help(string t, int pnthgt){\\n\\t\\t\\tint val = 0;\\n\\t\\t\\twhile(ix < t.size() && isdigit(t[ix])){\\n\\t\\t\\t\\tval = val*10 + t[ix]-\\'0\\';\\n\\t\\t\\t\\tix = ix+1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1800427,
                "title": "java-easy-clean-and-detailed-recursive-solution",
                "content": "```\\nclass Solution {\\n    int ptr = 0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return find(traversal, 0);\\n    }\\n    \\n    public TreeNode find(String traversal, int level){\\n        if(ptr == traversal.length())\\n            return null;\\n        int i = ptr;\\n        int count = 0;\\n        while(traversal.charAt(i) == \\'-\\'){\\n            count++;\\n            i++;\\n        }\\n        if(count == level){\\n            int start = i;\\n            while(i < traversal.length() && traversal.charAt(i) != \\'-\\')\\n                i++;\\n            int val = Integer.parseInt(traversal.substring(start, i));\\n            ptr = i;\\n            TreeNode root = new TreeNode(val);\\n            root.left = find(traversal, level + 1);\\n            root.right = find(traversal, level + 1);\\n            return root;\\n        }else\\n            return null;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ptr = 0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return find(traversal, 0);\\n    }\\n    \\n    public TreeNode find(String traversal, int level){\\n        if(ptr == traversal.length())\\n            return null;\\n        int i = ptr;\\n        int count = 0;\\n        while(traversal.charAt(i) == \\'-\\'){\\n            count++;\\n            i++;\\n        }\\n        if(count == level){\\n            int start = i;\\n            while(i < traversal.length() && traversal.charAt(i) != \\'-\\')\\n                i++;\\n            int val = Integer.parseInt(traversal.substring(start, i));\\n            ptr = i;\\n            TreeNode root = new TreeNode(val);\\n            root.left = find(traversal, level + 1);\\n            root.right = find(traversal, level + 1);\\n            return root;\\n        }else\\n            return null;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922334,
                "title": "java-build-tree-recursively-with-photo-and-comments",
                "content": "![image](https://assets.leetcode.com/users/images/4a27bdc3-8224-4aeb-ab48-97f699c2aad2_1604429624.6136794.png)\\n```java\\n    public TreeNode recoverFromPreorder(String s) {\\n        final char[] chars = s.toCharArray();\\n        return build(chars, 0, chars.length - 1, 1);\\n    }\\n\\n    private TreeNode build(char[] chars, int start, int end, int level) {\\n        if (start > end) {\\n            return null;\\n        }\\n        // convert chars to integer, take example of \"405 - - 1 - - 22\", the first int is 405, NOT 4\\n        final StringBuilder stringBuilder = new StringBuilder();\\n        while (start <= end && chars[start] != \\'-\\') {\\n            stringBuilder.append(chars[start]);\\n            start++;\\n        }\\n        // root of node\\n        final TreeNode root = new TreeNode(Integer.parseInt(stringBuilder.toString()));\\n        if (start == end) {\\n            return root;\\n        }\\n        // calculate left start\\n        final int leftStart = start + level;\\n        int interval = 0;\\n        int rightStart = leftStart + 1;\\n        // calculate right start, if exists one, it must have count of \"-\" equals to level\\n        while (rightStart < chars.length) {\\n            if (chars[rightStart] == \\'-\\') {\\n                interval++;\\n            } else {\\n                if (interval == level) {\\n                    break;\\n                }\\n                interval = 0;\\n            }\\n            ++rightStart;\\n        }\\n        // recalculate left end, it may have rightStart > end, so we take end\\n        final int leftEnd = rightStart > end ? end : rightStart - level - 1;\\n        // build tree recursively\\n        root.left = build(chars, leftStart, leftEnd, level + 1);\\n        root.right = build(chars, rightStart, end, level + 1);\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    public TreeNode recoverFromPreorder(String s) {\\n        final char[] chars = s.toCharArray();\\n        return build(chars, 0, chars.length - 1, 1);\\n    }\\n\\n    private TreeNode build(char[] chars, int start, int end, int level) {\\n        if (start > end) {\\n            return null;\\n        }\\n        // convert chars to integer, take example of \"405 - - 1 - - 22\", the first int is 405, NOT 4\\n        final StringBuilder stringBuilder = new StringBuilder();\\n        while (start <= end && chars[start] != \\'-\\') {\\n            stringBuilder.append(chars[start]);\\n            start++;\\n        }\\n        // root of node\\n        final TreeNode root = new TreeNode(Integer.parseInt(stringBuilder.toString()));\\n        if (start == end) {\\n            return root;\\n        }\\n        // calculate left start\\n        final int leftStart = start + level;\\n        int interval = 0;\\n        int rightStart = leftStart + 1;\\n        // calculate right start, if exists one, it must have count of \"-\" equals to level\\n        while (rightStart < chars.length) {\\n            if (chars[rightStart] == \\'-\\') {\\n                interval++;\\n            } else {\\n                if (interval == level) {\\n                    break;\\n                }\\n                interval = 0;\\n            }\\n            ++rightStart;\\n        }\\n        // recalculate left end, it may have rightStart > end, so we take end\\n        final int leftEnd = rightStart > end ? end : rightStart - level - 1;\\n        // build tree recursively\\n        root.left = build(chars, leftStart, leftEnd, level + 1);\\n        root.right = build(chars, rightStart, end, level + 1);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 676572,
                "title": "simple-recursive-preorder-traversal",
                "content": "Keep a ptr to the current position in the string. At each level check if the next value is for the current level. if it is create a node and return it to the parent else return empty node.\\n```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        ptr = 0\\n        def traverse(level: int) -> TreeNode:\\n            nonlocal ptr\\n            nextLevel = 0\\n            while ptr < len(S) and S[ptr] == \\'-\\':\\n                nextLevel += 1\\n                ptr += 1\\n                \\n            if level == nextLevel: \\n                val = \\'\\'\\n                while ptr < len(S) and S[ptr] != \\'-\\':\\n                    val += S[ptr]\\n                    ptr += 1\\n                node = TreeNode(int(val))\\n                node.left = traverse(level+1)\\n                node.right = traverse(level+1)\\n                return node\\n            else:\\n                ptr -= nextLevel\\n                return None\\n\\n        return traverse(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        ptr = 0\\n        def traverse(level: int) -> TreeNode:\\n            nonlocal ptr\\n            nextLevel = 0\\n            while ptr < len(S) and S[ptr] == \\'-\\':\\n                nextLevel += 1\\n                ptr += 1\\n                \\n            if level == nextLevel: \\n                val = \\'\\'\\n                while ptr < len(S) and S[ptr] != \\'-\\':\\n                    val += S[ptr]\\n                    ptr += 1\\n                node = TreeNode(int(val))\\n                node.left = traverse(level+1)\\n                node.right = traverse(level+1)\\n                return node\\n            else:\\n                ptr -= nextLevel\\n                return None\\n\\n        return traverse(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426849,
                "title": "c-simple-map-solution-this-should-be-a-medium",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    int parse_dash(string& S, int& i) {\\n        int ans = 0;\\n        while(i < S.length()) {\\n            if(S[i] != \\'-\\') break;\\n            ans++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n    \\n    int parse_num(string& S, int& i) {\\n        int ans = 0;\\n        while(i < S.length()) {\\n            if(S[i] == \\'-\\') break;\\n            ans = ans*10 + (S[i]-\\'0\\');\\n            i++;\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        unordered_map<int, TreeNode*> m;\\n        int n = S.length();\\n        int i = 0;\\n        while(i < n) {\\n            int dash = parse_dash(S, i);\\n            int num = parse_num(S, i);\\n            TreeNode* curr = new TreeNode(num);\\n            if(dash != 0) {\\n                TreeNode* parent = m[dash-1];\\n                if(!parent->left) parent->left = curr;\\n                else parent->right = curr;\\n            }\\n            m[dash] = curr;\\n        }\\n        return m[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    int parse_dash(string& S, int& i) {\\n        int ans = 0;\\n        while(i < S.length()) {\\n            if(S[i] != \\'-\\') break;\\n            ans++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n    \\n    int parse_num(string& S, int& i) {\\n        int ans = 0;\\n        while(i < S.length()) {\\n            if(S[i] == \\'-\\') break;\\n            ans = ans*10 + (S[i]-\\'0\\');\\n            i++;\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        unordered_map<int, TreeNode*> m;\\n        int n = S.length();\\n        int i = 0;\\n        while(i < n) {\\n            int dash = parse_dash(S, i);\\n            int num = parse_num(S, i);\\n            TreeNode* curr = new TreeNode(num);\\n            if(dash != 0) {\\n                TreeNode* parent = m[dash-1];\\n                if(!parent->left) parent->left = curr;\\n                else parent->right = curr;\\n            }\\n            m[dash] = curr;\\n        }\\n        return m[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341110,
                "title": "easiest-c-solution-no-recursion-and-also-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef TreeNode* btptr;\\n    TreeNode* recoverFromPreorder(string s) \\n    {\\n      btptr root=NULL;\\n        int cnt=0;\\n        if(s.length()==0)\\n             return root;\\n         vector<pair<btptr,int> >ump;\\n        // pair stores the newly formed node with their depths as the second                //parameter\\n        int i=0,n=s.length();\\n        while(i<n)\\n        {\\n            int d=0;\\n            while(i<n&&s[i]!=\\'-\\')\\n            {\\n                d=d*10+(s[i]-\\'0\\');\\n                i++;\\n            }\\n            btptr y=new TreeNode(d);// formed new node \\n            ump.push_back(make_pair(y,cnt));\\n            cnt=0;\\n            while(i<n&&s[i]==\\'-\\')\\n            {\\n                i++;\\n                cnt++;// calculating depths for every node \\n            }\\n        }\\n        // forming the tree with the help of vector<pair<btptr,int>>ump;\\n        // which stored the newly formed nodes with their depths \\n        // and for every node searched the nearest node that is at depth lesser \\n        // than the current node if we got such node\\n        // then break at that point and if for that node if left is null then \\n        // assign first left as said in question \\n        // if left is not null then assign right\\n        for(int i=1;i<ump.size();i++)\\n        {\\n            for(int u=i-1;u>=0;u--)\\n            {\\n                if(ump[u].second<ump[i].second)\\n                {\\n                    if(ump[u].first->left==NULL)\\n                        ump[u].first->left=ump[i].first;\\n                    else\\n                        ump[u].first->right=ump[i].first;\\n                    break;\\n                }\\n            }\\n        }\\n        return ump[0].first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef TreeNode* btptr;\\n    TreeNode* recoverFromPreorder(string s) \\n    {\\n      btptr root=NULL;\\n        int cnt=0;\\n        if(s.length()==0)\\n             return root;\\n         vector<pair<btptr,int> >ump;\\n        // pair stores the newly formed node with their depths as the second                //parameter\\n        int i=0,n=s.length();\\n        while(i<n)\\n        {\\n            int d=0;\\n            while(i<n&&s[i]!=\\'-\\')\\n            {\\n                d=d*10+(s[i]-\\'0\\');\\n                i++;\\n            }\\n            btptr y=new TreeNode(d);// formed new node \\n            ump.push_back(make_pair(y,cnt));\\n            cnt=0;\\n            while(i<n&&s[i]==\\'-\\')\\n            {\\n                i++;\\n                cnt++;// calculating depths for every node \\n            }\\n        }\\n        // forming the tree with the help of vector<pair<btptr,int>>ump;\\n        // which stored the newly formed nodes with their depths \\n        // and for every node searched the nearest node that is at depth lesser \\n        // than the current node if we got such node\\n        // then break at that point and if for that node if left is null then \\n        // assign first left as said in question \\n        // if left is not null then assign right\\n        for(int i=1;i<ump.size();i++)\\n        {\\n            for(int u=i-1;u>=0;u--)\\n            {\\n                if(ump[u].second<ump[i].second)\\n                {\\n                    if(ump[u].first->left==NULL)\\n                        ump[u].first->left=ump[i].first;\\n                    else\\n                        ump[u].first->right=ump[i].first;\\n                    break;\\n                }\\n            }\\n        }\\n        return ump[0].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290160,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution(object):\\n    def recoverFromPreorder(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        self.i = 0\\n        self.L = len(S)\\n        \\n        def build_tree(level):\\n            node = TreeNode(get_value())\\n            next_level = get_level()\\n            if next_level <= level:\\n                self.i -= next_level\\n                return node\\n            node.left = build_tree(next_level)\\n            next_level = get_level()\\n            if next_level <= level:\\n                self.i -= next_level\\n                return node\\n            node.right = build_tree(next_level)\\n            return node\\n            \\n        def get_level():\\n            level = 0\\n            while self.i < self.L and S[self.i] == \\'-\\':\\n                level += 1\\n                self.i+=1\\n            return level\\n\\n        def get_value():\\n            val = \"\"\\n            while self.i < self.L and S[self.i] != \\'-\\':\\n                val += S[self.i]\\n                self.i+=1\\n            return val\\n        \\n        return build_tree(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def recoverFromPreorder(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        self.i = 0\\n        self.L = len(S)\\n        \\n        def build_tree(level):\\n            node = TreeNode(get_value())\\n            next_level = get_level()\\n            if next_level <= level:\\n                self.i -= next_level\\n                return node\\n            node.left = build_tree(next_level)\\n            next_level = get_level()\\n            if next_level <= level:\\n                self.i -= next_level\\n                return node\\n            node.right = build_tree(next_level)\\n            return node\\n            \\n        def get_level():\\n            level = 0\\n            while self.i < self.L and S[self.i] == \\'-\\':\\n                level += 1\\n                self.i+=1\\n            return level\\n\\n        def get_value():\\n            val = \"\"\\n            while self.i < self.L and S[self.i] != \\'-\\':\\n                val += S[self.i]\\n                self.i+=1\\n            return val\\n        \\n        return build_tree(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278544,
                "title": "this-should-not-be-hard",
                "content": "This should not be hard, relative to other hard. I don\\'t use any tricks or algorithm, just brute force and it is the best solution:\\n```\\n    public TreeNode RecoverFromPreorder(string S) {\\n        TreeNode root = null;\\n        var parents = new Stack<TreeNode>();\\n        \\n        for (int i = 0; i < S.Length; ) {\\n            \\n            // parse depth and value\\n            int depth = 0, val = 0;\\n            for (; i < S.Length && S[i] == \\'-\\'; i++) depth++;\\n            for (; i < S.Length && S[i] != \\'-\\'; i++) val = val*10 + (S[i]-\\'0\\');\\n            var node = new TreeNode(val);\\n            \\n            while (parents.Count > depth) parents.Pop();\\n            \\n            if (root == null) {\\n                root = node;\\n            } else {\\n                var p = parents.Peek();\\n                if (p.left == null) p.left = node;\\n                else p.right  = node;\\n            }\\n            \\n            parents.Push(node);\\n        }\\n        \\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode RecoverFromPreorder(string S) {\\n        TreeNode root = null;\\n        var parents = new Stack<TreeNode>();\\n        \\n        for (int i = 0; i < S.Length; ) {\\n            \\n            // parse depth and value\\n            int depth = 0, val = 0;\\n            for (; i < S.Length && S[i] == \\'-\\'; i++) depth++;\\n            for (; i < S.Length && S[i] != \\'-\\'; i++) val = val*10 + (S[i]-\\'0\\');\\n            var node = new TreeNode(val);\\n            \\n            while (parents.Count > depth) parents.Pop();\\n            \\n            if (root == null) {\\n                root = node;\\n            } else {\\n                var p = parents.Peek();\\n                if (p.left == null) p.left = node;\\n                else p.right  = node;\\n            }\\n            \\n            parents.Push(node);\\n        }\\n        \\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 276736,
                "title": "rust-recursive-solution",
                "content": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn recover_from_preorder(s: String) -> Option<Rc<RefCell<TreeNode>>> {\\n        let vals: Vec<i32> = s.split(\\'-\\').filter(|x| x.len() > 0).map(|x| x.parse().unwrap()).collect();\\n        let mut depths: Vec<i32> = s.split(char::is_numeric).filter(|x| x.len() > 0).map(|x| x.len() as i32).collect();\\n        depths.insert(0, 0); // \\u6839\\u8282\\u70B9\\n\\n        Solution::build_tree(&vals, &depths, 0, 0).0\\n    }\\n\\n    fn build_tree(vals: &Vec<i32>, depths: &Vec<i32>, idx: usize, depth: usize) -> (Option<Rc<RefCell<TreeNode>>>, usize) {\\n        if idx >= vals.len() || depth as i32 > depths[idx]  {\\n            return (None, idx);\\n        }\\n        let child = Some(Rc::new(RefCell::new(TreeNode::new(vals[idx]))));\\n        let (left, left_idx) = Solution::build_tree(vals, depths, idx + 1, depth + 1);\\n        let mut next_idx = left_idx;\\n        child.as_ref().unwrap().borrow_mut().left = left;\\n        if left_idx > idx { // \\u6709\\u53F3\\u5B50\\u6811\\n            let (right, right_idx) = Solution::build_tree(vals, depths, left_idx, depth + 1);\\n            next_idx = right_idx;\\n            child.as_ref().unwrap().borrow_mut().right = right;\\n        }\\n\\n        (child, next_idx)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn recover_from_preorder(s: String) -> Option<Rc<RefCell<TreeNode>>> {\\n        let vals: Vec<i32> = s.split(\\'-\\').filter(|x| x.len() > 0).map(|x| x.parse().unwrap()).collect();\\n        let mut depths: Vec<i32> = s.split(char::is_numeric).filter(|x| x.len() > 0).map(|x| x.len() as i32).collect();\\n        depths.insert(0, 0); // \\u6839\\u8282\\u70B9\\n\\n        Solution::build_tree(&vals, &depths, 0, 0).0\\n    }\\n\\n    fn build_tree(vals: &Vec<i32>, depths: &Vec<i32>, idx: usize, depth: usize) -> (Option<Rc<RefCell<TreeNode>>>, usize) {\\n        if idx >= vals.len() || depth as i32 > depths[idx]  {\\n            return (None, idx);\\n        }\\n        let child = Some(Rc::new(RefCell::new(TreeNode::new(vals[idx]))));\\n        let (left, left_idx) = Solution::build_tree(vals, depths, idx + 1, depth + 1);\\n        let mut next_idx = left_idx;\\n        child.as_ref().unwrap().borrow_mut().left = left;\\n        if left_idx > idx { // \\u6709\\u53F3\\u5B50\\u6811\\n            let (right, right_idx) = Solution::build_tree(vals, depths, left_idx, depth + 1);\\n            next_idx = right_idx;\\n            child.as_ref().unwrap().borrow_mut().right = right;\\n        }\\n\\n        (child, next_idx)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3243162,
                "title": "simple-c-solution-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string path;\\n    int getDepth() {\\n        int n = path.length(), idx = 0;\\n        for(; idx < n && path[idx] == \\'-\\'; idx++){}\\n        return idx;\\n    }\\n    int getValue() {\\n        int n = path.length(), idx = 0, num = 0;\\n        for(; idx < n; ++idx) {\\n            if(path[idx] != \\'-\\') break;\\n        }\\n        for(; idx < n; idx++) {\\n            if(path[idx] == \\'-\\') break;\\n            int digit = path[idx] - \\'0\\';\\n            num = num * 10 + digit;\\n        }\\n        path = path.substr(idx);\\n        return num;\\n    }\\n    TreeNode* dfs(int required_depth) {\\n        int available_depth = getDepth();\\n        if(required_depth > available_depth) {\\n            return NULL;\\n        }\\n        int value = getValue();\\n        TreeNode* root = new TreeNode(value);\\n        root->left = dfs(required_depth + 1);\\n        root->right = dfs(required_depth + 1);\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        path = traversal;\\n        return dfs(0);\\n    }\\n};\\n\\n// 1 [2 3 4 5 6 7\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string path;\\n    int getDepth() {\\n        int n = path.length(), idx = 0;\\n        for(; idx < n && path[idx] == \\'-\\'; idx++){}\\n        return idx;\\n    }\\n    int getValue() {\\n        int n = path.length(), idx = 0, num = 0;\\n        for(; idx < n; ++idx) {\\n            if(path[idx] != \\'-\\') break;\\n        }\\n        for(; idx < n; idx++) {\\n            if(path[idx] == \\'-\\') break;\\n            int digit = path[idx] - \\'0\\';\\n            num = num * 10 + digit;\\n        }\\n        path = path.substr(idx);\\n        return num;\\n    }\\n    TreeNode* dfs(int required_depth) {\\n        int available_depth = getDepth();\\n        if(required_depth > available_depth) {\\n            return NULL;\\n        }\\n        int value = getValue();\\n        TreeNode* root = new TreeNode(value);\\n        root->left = dfs(required_depth + 1);\\n        root->right = dfs(required_depth + 1);\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        path = traversal;\\n        return dfs(0);\\n    }\\n};\\n\\n// 1 [2 3 4 5 6 7\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094251,
                "title": "hashmap-solution-easy-cpp",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string s) {\\n        \\n            int i = 0;\\n            string l = \"\";\\n            // Find root of the tree\\n\\t\\t\\twhile(i < s.length() && s[i] != \\'-\\')\\n                    l += s[i],i++;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n            \\n            // Create root by converting string to integer\\n            TreeNode* root  = new TreeNode(stoi(l));\\n            TreeNode* ans = root;\\n            map<int,TreeNode*> mp;\\n            \\n            \\n            // Root is on 0 level, at one time only one node will open at any level\\n            mp[0]  = root;\\n\\t\\t\\t\\n            \\n            while(i < s.length())\\n            {\\n                    int count = 0;\\n\\t\\t\\t\\t\\t// Find the depth of next element\\n                    while(i < s.length() && s[i] == \\'-\\')\\n                            count++,i++;\\n                  //  cout<<count<<\"\\\\n\";\\n                    \\n\\t\\t\\t\\t\\t// Find the element\\n                    string local = \"\";\\n                    while(i < s.length() && s[i] != \\'-\\')\\n                            local += s[i],i++;\\n                    \\n\\t\\t\\t\\t\\t// Create Node\\n                    TreeNode* temp = new TreeNode(stoi(local));\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// If at depth count-1 left position is NULL then insert there\\n                    if(mp[count-1]->left == NULL)\\n                    {\\n                            mp[count-1]->left = temp;\\n                            mp[count] = temp;\\n                            \\n                    }else{\\n                            \\n                            mp[count-1]->right = temp;\\n                            mp[count] = temp; \\n                    }\\n                   \\n            }\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string s) {\\n        \\n            int i = 0;\\n            string l = \"\";\\n            // Find root of the tree\\n\\t\\t\\twhile(i < s.length() && s[i] != \\'-\\')\\n                    l += s[i],i++;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n            \\n            // Create root by converting string to integer\\n            TreeNode* root  = new TreeNode(stoi(l));\\n            TreeNode* ans = root;\\n            map<int,TreeNode*> mp;\\n            \\n            \\n            // Root is on 0 level, at one time only one node will open at any level\\n            mp[0]  = root;\\n\\t\\t\\t\\n            \\n            while(i < s.length())\\n            {\\n                    int count = 0;\\n\\t\\t\\t\\t\\t// Find the depth of next element\\n                    while(i < s.length() && s[i] == \\'-\\')\\n                            count++,i++;\\n                  //  cout<<count<<\"\\\\n\";\\n                    \\n\\t\\t\\t\\t\\t// Find the element\\n                    string local = \"\";\\n                    while(i < s.length() && s[i] != \\'-\\')\\n                            local += s[i],i++;\\n                    \\n\\t\\t\\t\\t\\t// Create Node\\n                    TreeNode* temp = new TreeNode(stoi(local));\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// If at depth count-1 left position is NULL then insert there\\n                    if(mp[count-1]->left == NULL)\\n                    {\\n                            mp[count-1]->left = temp;\\n                            mp[count] = temp;\\n                            \\n                    }else{\\n                            \\n                            mp[count-1]->right = temp;\\n                            mp[count] = temp; \\n                    }\\n                   \\n            }\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2990144,
                "title": "ruby-2-liner",
                "content": "```\\ndef recover_from_preorder(traversal)\\n\\n  r,*c = traversal.split /(?<=\\\\d)-(?=\\\\d)/\\n  TreeNode.new r, *c.map{ recover_from_preorder _1.gsub /-(-+)/, \\'\\\\1\\' }\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef recover_from_preorder(traversal)\\n\\n  r,*c = traversal.split /(?<=\\\\d)-(?=\\\\d)/\\n  TreeNode.new r, *c.map{ recover_from_preorder _1.gsub /-(-+)/, \\'\\\\1\\' }\\n\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2896048,
                "title": "recursive-java-solution-using-stack-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Convert the traversals string into two lists such that one represents the integer values and the other represents the depths where such nodes are found. Make sure to put in zero as the first element of the other array. It represents zero as the depth of our root node.\\n2. Prepare an empty stack for storing a tuple of TreeNode objects, and their depth.\\n3. Create a dummy node and push it into the stack with a depth of -1\\n4. Call a build function on the first index `i = 0` of the two lists in `1` above.\\n5. If the top element on the stack has a lower value depth than the depth of the current item, create a new TreeNode with value and depths at index i and label it as the left child of the top element on the stack and push the new TreeNode unto the stack.\\n6. If the previous condition was false, keep popping off items from the stack until you get a TreeNode whose depth is lower than the current depth at `i`.\\n7. After popping of items, create a new TreeNode with the current value label it as the right child of the Top element of the stack. Pop the top element of the stack and push the new TreeNode and current depth on top of the stack.\\n8. Recursively repeat the steps until `i` goes out of bounds.\\n\\n# Complexity\\n- Time complexity: **$$O(n)$$**\\n\\n- Space complexity: **$$O(n)$$**\\n\\n# Code\\n```\\nclass Tup<A, B> {\\n\\tA first;\\n\\tB second;\\n\\n\\tpublic Tup(A a, B b) {\\n\\t\\tthis.first = a;\\n\\t\\tthis.second = b;\\n\\t}\\n\\n}\\n\\nclass Solution {\\n\\tStack<Tup<TreeNode, Integer>> stack = new Stack<>();\\n\\tTreeNode root = new TreeNode();\\n\\tTup<ArrayList<Integer>, ArrayList<Integer>> content;\\n\\tint n;\\n\\n\\tpublic TreeNode recoverFromPreorder(String traversal) {\\n\\t\\tcontent = modify(traversal);\\n\\t\\tn = content.first.size();\\n\\t\\tstack.push(new Tup<>(root, -1));\\n\\t\\tbuild(0);\\n\\t\\treturn root.left;\\n\\t}\\n\\n\\tprivate void build(int i) {\\n\\t\\tif (i >= n)\\n\\t\\t\\treturn;\\n\\n\\t\\tTreeNode newNode = new TreeNode(content.first.get(i));\\n\\t\\tint depth = content.second.get(i);\\n\\n\\t\\tif (depth > stack.peek().second) {\\n\\t\\t\\tstack.peek().first.left = newNode;\\n\\t\\t\\tstack.push(new Tup<>(newNode, depth));\\n\\t\\t} else {\\n\\t\\t\\twhile (stack.peek().second >= depth) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t}\\n\\t\\t\\tstack.pop().first.right = newNode;\\n\\t\\t\\tstack.push(new Tup<>(newNode, depth));\\n\\t\\t}\\n\\n\\t\\tbuild(i + 1);\\n\\t}\\n\\n\\tprivate Tup<ArrayList<Integer>, ArrayList<Integer>> modify(String con) {\\n\\t\\tint n = con.length();\\n\\t\\tint i = 0;\\n\\n\\t\\tTup<ArrayList<Integer>, ArrayList<Integer>> ans = new Tup<>(new ArrayList<>(), new ArrayList<>());\\n\\t\\tans.second.add(0);\\n\\n\\t\\twhile (i < n) {\\n\\t\\t\\tif (con.charAt(i) == \\'-\\') {\\n\\t\\t\\t\\tint c = 0;\\n\\t\\t\\t\\twhile (i < n && con.charAt(i) == \\'-\\') {\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans.second.add(c);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint num = 0;\\n\\n\\t\\t\\t\\twhile (i < n && con.charAt(i) != \\'-\\') {\\n\\t\\t\\t\\t\\tnum *= 10;\\n\\t\\t\\t\\t\\tnum += con.charAt(i) - \\'0\\';\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans.first.add(num);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Tup<A, B> {\\n\\tA first;\\n\\tB second;\\n\\n\\tpublic Tup(A a, B b) {\\n\\t\\tthis.first = a;\\n\\t\\tthis.second = b;\\n\\t}\\n\\n}\\n\\nclass Solution {\\n\\tStack<Tup<TreeNode, Integer>> stack = new Stack<>();\\n\\tTreeNode root = new TreeNode();\\n\\tTup<ArrayList<Integer>, ArrayList<Integer>> content;\\n\\tint n;\\n\\n\\tpublic TreeNode recoverFromPreorder(String traversal) {\\n\\t\\tcontent = modify(traversal);\\n\\t\\tn = content.first.size();\\n\\t\\tstack.push(new Tup<>(root, -1));\\n\\t\\tbuild(0);\\n\\t\\treturn root.left;\\n\\t}\\n\\n\\tprivate void build(int i) {\\n\\t\\tif (i >= n)\\n\\t\\t\\treturn;\\n\\n\\t\\tTreeNode newNode = new TreeNode(content.first.get(i));\\n\\t\\tint depth = content.second.get(i);\\n\\n\\t\\tif (depth > stack.peek().second) {\\n\\t\\t\\tstack.peek().first.left = newNode;\\n\\t\\t\\tstack.push(new Tup<>(newNode, depth));\\n\\t\\t} else {\\n\\t\\t\\twhile (stack.peek().second >= depth) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t}\\n\\t\\t\\tstack.pop().first.right = newNode;\\n\\t\\t\\tstack.push(new Tup<>(newNode, depth));\\n\\t\\t}\\n\\n\\t\\tbuild(i + 1);\\n\\t}\\n\\n\\tprivate Tup<ArrayList<Integer>, ArrayList<Integer>> modify(String con) {\\n\\t\\tint n = con.length();\\n\\t\\tint i = 0;\\n\\n\\t\\tTup<ArrayList<Integer>, ArrayList<Integer>> ans = new Tup<>(new ArrayList<>(), new ArrayList<>());\\n\\t\\tans.second.add(0);\\n\\n\\t\\twhile (i < n) {\\n\\t\\t\\tif (con.charAt(i) == \\'-\\') {\\n\\t\\t\\t\\tint c = 0;\\n\\t\\t\\t\\twhile (i < n && con.charAt(i) == \\'-\\') {\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans.second.add(c);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint num = 0;\\n\\n\\t\\t\\t\\twhile (i < n && con.charAt(i) != \\'-\\') {\\n\\t\\t\\t\\t\\tnum *= 10;\\n\\t\\t\\t\\t\\tnum += con.charAt(i) - \\'0\\';\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans.first.add(num);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894918,
                "title": "python-minimal-code-without-stack-or-recursion-the-best",
                "content": "# Approach\\nNote that the empty tree is supported as well.\\n\\nThe Best!\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        root = None\\n        for val in traversal.split(\\'-\\'):\\n            if not root or val == \\'\\':\\n                parent = (parent.right if parent.right else parent.left) if root else (root := TreeNode(int(val)))\\n            else:\\n                parent, _ = root, setattr(parent, \\'right\\' if parent.left else \\'left\\', TreeNode(int(val)))\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        root = None\\n        for val in traversal.split(\\'-\\'):\\n            if not root or val == \\'\\':\\n                parent = (parent.right if parent.right else parent.left) if root else (root := TreeNode(int(val)))\\n            else:\\n                parent, _ = root, setattr(parent, \\'right\\' if parent.left else \\'left\\', TreeNode(int(val)))\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769002,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int,TreeNode*>m;\\n        TreeNode* root,*ptr;\\n        int i=0;\\n        string num=\"\";\\n        while(i<traversal.size() && traversal[i]!=\\'-\\'){\\n            num+=traversal[i];\\n            i++;\\n        }\\n        \\n        ptr =new TreeNode(stoi(num));\\n        m[0]=ptr;\\n        root=ptr;\\n        \\n        while(i<traversal.size()){\\n            int dash=0;\\n            string s=\"\";\\n            while(traversal[i]==\\'-\\'){\\n                dash++;\\n                i++;\\n            }\\n            \\n            while(i<traversal.size() && traversal[i]!=\\'-\\'){\\n                s+=traversal[i];\\n                i++;\\n            }\\n            \\n            auto ele=new TreeNode(stoi(s));\\n            if(!m[dash-1]->left)m[dash-1]->left=ele;\\n            else m[dash-1]->right=ele;\\n            \\n            m[dash]=ele;\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int,TreeNode*>m;\\n        TreeNode* root,*ptr;\\n        int i=0;\\n        string num=\"\";\\n        while(i<traversal.size() && traversal[i]!=\\'-\\'){\\n            num+=traversal[i];\\n            i++;\\n        }\\n        \\n        ptr =new TreeNode(stoi(num));\\n        m[0]=ptr;\\n        root=ptr;\\n        \\n        while(i<traversal.size()){\\n            int dash=0;\\n            string s=\"\";\\n            while(traversal[i]==\\'-\\'){\\n                dash++;\\n                i++;\\n            }\\n            \\n            while(i<traversal.size() && traversal[i]!=\\'-\\'){\\n                s+=traversal[i];\\n                i++;\\n            }\\n            \\n            auto ele=new TreeNode(stoi(s));\\n            if(!m[dash-1]->left)m[dash-1]->left=ele;\\n            else m[dash-1]->right=ele;\\n            \\n            m[dash]=ele;\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465019,
                "title": "c-short-and-simple-code",
                "content": "Runtime 22ms\\n```\\nclass Solution {\\npublic:\\n    \\n\\n    TreeNode* rec(vector<pair<int,int>> &v,int &i,int dashes){\\n        if(i>=v.size()||dashes!=v[i].second){\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(v[i].first);\\n        i++;\\n        root->left=rec(v,i,dashes+1);\\n        root->right=rec(v,i,dashes+1);\\n        return root;\\n        \\n    }\\n    \\n    TreeNode* recoverFromPreorder(string str) {\\n        vector<pair<int,int>> v;\\n        int count=0;\\n        for(int i=0;i<str.size();i++){\\n            if(str[i]!=\\'-\\'){\\n                string s=\"\";\\n                while(i<str.size()&&str[i]!=\\'-\\')\\n                    s+=str[i++];\\n                i--;\\n                v.push_back({stoi(s),count});\\n                count=0;\\n            }\\n            else count++;\\n              \\n        }\\n        int x=0;\\n        return rec(v,x,0);\\n    }\\n};\\n```\\nTime Complexity O(n) Space Complexity O(n)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n    TreeNode* rec(vector<pair<int,int>> &v,int &i,int dashes){\\n        if(i>=v.size()||dashes!=v[i].second){\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(v[i].first);\\n        i++;\\n        root->left=rec(v,i,dashes+1);\\n        root->right=rec(v,i,dashes+1);\\n        return root;\\n        \\n    }\\n    \\n    TreeNode* recoverFromPreorder(string str) {\\n        vector<pair<int,int>> v;\\n        int count=0;\\n        for(int i=0;i<str.size();i++){\\n            if(str[i]!=\\'-\\'){\\n                string s=\"\";\\n                while(i<str.size()&&str[i]!=\\'-\\')\\n                    s+=str[i++];\\n                i--;\\n                v.push_back({stoi(s),count});\\n                count=0;\\n            }\\n            else count++;\\n              \\n        }\\n        int x=0;\\n        return rec(v,x,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447190,
                "title": "python-recursive-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    # preorder = root -> left -> right\\n    # Then the task at hand is to look for \"digit\"+ -\"+ \"digit\" in string\\n    # Assign the first appearance to the left tree, the second to right\\n    # We need to shorten - streaks by one in the resultant string\\n    def dash_reducer(self, ori_string):\\n        count, result_string = 0, \"\"\\n        for c in ori_string:\\n            if c.isdigit():\\n                if count > 0:\\n                    result_string += \"-\"*(count-1)\\n                    count = 0\\n                result_string += c\\n            else:\\n                count += 1\\n        return result_string\\n        \\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        i, curr, finished_root, start = 0, 0, False, []\\n        for i, c in enumerate(traversal):\\n            if not finished_root:\\n                if c.isdigit():\\n                    curr *= 10\\n                    curr += int(c)\\n                else:\\n                    finished_root = True\\n                    root = TreeNode(curr)\\n            if c == \"-\" and traversal[i-1].isdigit() and traversal[i+1].isdigit():\\n                start.append(i+1)\\n        if len(start) == 0:\\n            finished_root = True\\n            root = TreeNode(curr)\\n        elif len(start) == 1:\\n            root.left = self.recoverFromPreorder(self.dash_reducer(traversal[start[0]:]))\\n        else:\\n            root.left = self.recoverFromPreorder(self.dash_reducer(traversal[start[0]:start[1]-1]))\\n            root.right = self.recoverFromPreorder(self.dash_reducer(traversal[start[1]:]))\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    # preorder = root -> left -> right\\n    # Then the task at hand is to look for \"digit\"+ -\"+ \"digit\" in string\\n    # Assign the first appearance to the left tree, the second to right\\n    # We need to shorten - streaks by one in the resultant string\\n    def dash_reducer(self, ori_string):\\n        count, result_string = 0, \"\"\\n        for c in ori_string:\\n            if c.isdigit():\\n                if count > 0:\\n                    result_string += \"-\"*(count-1)\\n                    count = 0\\n                result_string += c\\n            else:\\n                count += 1\\n        return result_string\\n        \\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        i, curr, finished_root, start = 0, 0, False, []\\n        for i, c in enumerate(traversal):\\n            if not finished_root:\\n                if c.isdigit():\\n                    curr *= 10\\n                    curr += int(c)\\n                else:\\n                    finished_root = True\\n                    root = TreeNode(curr)\\n            if c == \"-\" and traversal[i-1].isdigit() and traversal[i+1].isdigit():\\n                start.append(i+1)\\n        if len(start) == 0:\\n            finished_root = True\\n            root = TreeNode(curr)\\n        elif len(start) == 1:\\n            root.left = self.recoverFromPreorder(self.dash_reducer(traversal[start[0]:]))\\n        else:\\n            root.left = self.recoverFromPreorder(self.dash_reducer(traversal[start[0]:start[1]-1]))\\n            root.right = self.recoverFromPreorder(self.dash_reducer(traversal[start[1]:]))\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352614,
                "title": "c-solution-time-o-n-memory-o-n-beats-95-iterative-stack",
                "content": "```C#\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string traversal) {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        int start = 0, index = 0;\\n        while (index < traversal.Length) {\\n            int depth = 0;\\n            while (index < traversal.Length && traversal[index] == \\'-\\') { depth++; index++; }\\n            \\n            int number = 0;\\n            while (index < traversal.Length && char.IsDigit(traversal[index])) {\\n                number = number * 10 + traversal[index] - \\'0\\';\\n                index++;\\n            }\\n            \\n            bool wentBack = stack.Count > depth;\\n            while (stack.Count > depth) stack.Pop();\\n            \\n            TreeNode current = new TreeNode(number);\\n            if (stack.Count > 0) {\\n                TreeNode top = stack.Peek();\\n                if (wentBack) top.right = current;\\n                else top.left = current;\\n            }\\n            \\n            stack.Push(current);\\n        }\\n        \\n        while (stack.Count > 1) stack.Pop();\\n        return stack.Peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack",
                    "Iterator"
                ],
                "code": "```C#\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string traversal) {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        int start = 0, index = 0;\\n        while (index < traversal.Length) {\\n            int depth = 0;\\n            while (index < traversal.Length && traversal[index] == \\'-\\') { depth++; index++; }\\n            \\n            int number = 0;\\n            while (index < traversal.Length && char.IsDigit(traversal[index])) {\\n                number = number * 10 + traversal[index] - \\'0\\';\\n                index++;\\n            }\\n            \\n            bool wentBack = stack.Count > depth;\\n            while (stack.Count > depth) stack.Pop();\\n            \\n            TreeNode current = new TreeNode(number);\\n            if (stack.Count > 0) {\\n                TreeNode top = stack.Peek();\\n                if (wentBack) top.right = current;\\n                else top.left = current;\\n            }\\n            \\n            stack.Push(current);\\n        }\\n        \\n        while (stack.Count > 1) stack.Pop();\\n        return stack.Peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278817,
                "title": "c-easiest-solution",
                "content": "**Pls Upvote if you like the Solution!**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string s) {\\n        vector <TreeNode*> st;                       //Stack Declaration\\n        for(int i=0; i<s.size(); ){\\n            int level=0, val=0;                      //Variables for level and number\\n            while(s[i] == \\'-\\')\\n                level++, i++;                        //Calculating Level\\n            while(i < s.size() && s[i] != \\'-\\'){      //Storing number in val\\n                val*=10;\\n                val+=s[i]-\\'0\\';                       //Converting char to int\\n                i++;\\n            }\\n            TreeNode* node = new TreeNode(val);                   //Creating new node\\n            while(st.size()>level) st.pop_back();                 //Finding right level to Insert\\n            if(!st.empty()){\\n                if(!st.back()->left) st.back()->left=node;        //Checking left child first\\n                else st.back()->right=node;                       //Creating right child if left child already present\\n            }\\n            st.push_back(node);                                   //Pushing new node to stack\\n        }\\n        return st[0];                                             //Returning head\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string s) {\\n        vector <TreeNode*> st;                       //Stack Declaration\\n        for(int i=0; i<s.size(); ){\\n            int level=0, val=0;                      //Variables for level and number\\n            while(s[i] == \\'-\\')\\n                level++, i++;                        //Calculating Level\\n            while(i < s.size() && s[i] != \\'-\\'){      //Storing number in val\\n                val*=10;\\n                val+=s[i]-\\'0\\';                       //Converting char to int\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2278157,
                "title": "faster-than-95-99-of-c-iterative-stack",
                "content": "```\\nTreeNode recoverFromPreorder(string traversal){\\n        stack<TreeNode> stk;\\n        for(int i=0;i<traversal.length();){\\n            int level=0;\\n            while(traversal[i]==\\'-\\')++level,++i;\\n            int start = i;\\n            while(isdigit(traversal[i]))++i;\\n            int val=stoi(traversal.substr(start,i-start+1));\\n            TreeNodetmp = new TreeNode(val);\\n            if(stk.empty()) {stk.emplace(tmp);continue;}\\n            while(stk.size()>level)stk.pop();\\n            if(stk.top()->left)stk.top()->right=tmp;\\n            else stk.top()->left=tmp;\\n            stk.emplace(tmp);\\n        }\\n        while(stk.size()>1)stk.pop();\\n        return stk.top();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode recoverFromPreorder(string traversal){\\n        stack<TreeNode> stk;\\n        for(int i=0;i<traversal.length();){\\n            int level=0;\\n            while(traversal[i]==\\'-\\')++level,++i;\\n            int start = i;\\n            while(isdigit(traversal[i]))++i;\\n            int val=stoi(traversal.substr(start,i-start+1));\\n            TreeNodetmp = new TreeNode(val);\\n            if(stk.empty()) {stk.emplace(tmp);continue;}\\n            while(stk.size()>level)stk.pop();\\n            if(stk.top()->left)stk.top()->right=tmp;\\n            else stk.top()->left=tmp;\\n            stk.emplace(tmp);\\n        }\\n        while(stk.size()>1)stk.pop();\\n        return stk.top();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2153637,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string s) {\\n        int sz = s.size();\\n        int idx = 0;\\n        string rootval = \"\";\\n        while(idx<sz && s[idx] >= \\'0\\' && s[idx] <= \\'9\\')\\n        {\\n            rootval += s[idx];\\n            idx++;\\n        }\\n        TreeNode* root = new TreeNode(stoll(rootval));\\n        //TreeNode* rootNode = root;\\n        stack<pair<TreeNode*, int>> st;\\n        st.push({root,0});\\n        while(idx < sz)\\n        {\\n            int level = 0;\\n            while(s[idx] == \\'-\\')\\n            {\\n                level++;\\n                idx++;\\n            }\\n            string sm = \"\"; \\n            while(idx < sz && s[idx] >= \\'0\\' && s[idx] <= \\'9\\')\\n            {\\n                sm += s[idx];\\n                idx++;\\n            }\\n            while(st.top().second >= level)\\n            {\\n                st.pop();\\n            }\\n            TreeNode* tmp = new TreeNode(stoll(sm));\\n            if(!st.top().first->left)\\n            {\\n                st.top().first->left = tmp;\\n            }\\n            else\\n            {\\n                st.top().first->right = tmp;\\n            }\\n            st.push({tmp, level});\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string s) {\\n        int sz = s.size();\\n        int idx = 0;\\n        string rootval = \"\";\\n        while(idx<sz && s[idx] >= \\'0\\' && s[idx] <= \\'9\\')\\n        {\\n            rootval += s[idx];\\n            idx++;\\n        }\\n        TreeNode* root = new TreeNode(stoll(rootval));\\n        //TreeNode* rootNode = root;\\n        stack<pair<TreeNode*, int>> st;\\n        st.push({root,0});\\n        while(idx < sz)\\n        {\\n            int level = 0;\\n            while(s[idx] == \\'-\\')\\n            {\\n                level++;\\n                idx++;\\n            }\\n            string sm = \"\"; \\n            while(idx < sz && s[idx] >= \\'0\\' && s[idx] <= \\'9\\')\\n            {\\n                sm += s[idx];\\n                idx++;\\n            }\\n            while(st.top().second >= level)\\n            {\\n                st.pop();\\n            }\\n            TreeNode* tmp = new TreeNode(stoll(sm));\\n            if(!st.top().first->left)\\n            {\\n                st.top().first->left = tmp;\\n            }\\n            else\\n            {\\n                st.top().first->right = tmp;\\n            }\\n            st.push({tmp, level});\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134294,
                "title": "java-easy-preorder-traversal-solution-easy-to-understand",
                "content": "class Solution {\\n\\n    int i = 0;\\n    public TreeNode helper(String str, int depth){\\n        int d = 0;\\n        while(i+d<str.length() && str.charAt(i+d) == \\'-\\'){\\n            d++;\\n        }\\n        \\n        if(d != depth){\\n            return null;\\n        }\\n        \\n        int nd = 0;\\n        \\n        while(i + d + nd <str.length() && str.charAt(i+d+nd) != \\'-\\'){\\n            nd++;\\n        }\\n        \\n        int val = Integer.parseInt(str.substring(i+d,i+d+nd));\\n        i = i + d + nd;\\n        TreeNode root = new TreeNode(val);\\n        root.left = helper(str,depth+1);\\n        root.right = helper(str,depth+1);\\n        \\n        return root;\\n        \\n    }\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        if(traversal.length()==0){\\n            return null;\\n        }\\n        \\n        return helper(traversal,0);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\n    int i = 0;\\n    public TreeNode helper(String str, int depth){\\n        int d = 0;\\n        while(i+d<str.length() && str.charAt(i+d) == \\'-\\'){\\n            d++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2123129,
                "title": "java-simple-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int i = 0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return helper(traversal,0);\\n    }\\n    \\n    public TreeNode helper(String str, int depth){\\n        //d == number of dashes\\n        int d = 0;\\n        while(i+d < str.length() && str.charAt((i+d)) == \\'-\\'){\\n            d++;\\n        }\\n        \\n        //if dashes is not equal to depth add null \\n        if(d != depth){\\n            return null;\\n        }\\n        \\n        //nd --> Non dash \\n        int nd = 0;\\n        while((i+d+nd) < str.length() && str.charAt(i+d+nd) != \\'-\\'){\\n            nd++;\\n        }\\n        \\n\\t\\t//create val from dashes ending to non-dashes ending\\n        int val = Integer.parseInt(str.substring(i+d,i+d+nd));\\n        i = i+d+nd;\\n        TreeNode node = new TreeNode(val);\\n        node.left = helper(str,depth+1);\\n        node.right = helper(str,depth+1);\\n        \\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int i = 0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return helper(traversal,0);\\n    }\\n    \\n    public TreeNode helper(String str, int depth){\\n        //d == number of dashes\\n        int d = 0;\\n        while(i+d < str.length() && str.charAt((i+d)) == \\'-\\'){\\n            d++;\\n        }\\n        \\n        //if dashes is not equal to depth add null \\n        if(d != depth){\\n            return null;\\n        }\\n        \\n        //nd --> Non dash \\n        int nd = 0;\\n        while((i+d+nd) < str.length() && str.charAt(i+d+nd) != \\'-\\'){\\n            nd++;\\n        }\\n        \\n\\t\\t//create val from dashes ending to non-dashes ending\\n        int val = Integer.parseInt(str.substring(i+d,i+d+nd));\\n        i = i+d+nd;\\n        TreeNode node = new TreeNode(val);\\n        node.left = helper(str,depth+1);\\n        node.right = helper(str,depth+1);\\n        \\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074837,
                "title": "c-iterative-traversal-stack",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL :)**\\n\\n```\\n#define ff first\\n#define ss second\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string t) \\n    {\\n        t+=\"-\";\\n        int n=t.size();\\n        int c=0;\\n       \\n        vector<int>level;\\n        vector<int>nodes;\\n        \\n        for(int i=0;i<n;)\\n        {\\n            if(t[i]>=\\'0\\'&&t[i]<=\\'9\\')\\n            {\\n                int num=0;\\n                while(i<n&&t[i]>=\\'0\\'&&t[i]<=\\'9\\')\\n                {\\n                    num=num*10+(t[i]-48);\\n                    i++;\\n                }\\n                nodes.push_back(num);\\n                level.push_back(c);\\n                c=0;\\n            }\\n            else\\n            {\\n                c++;\\n                i++;\\n            }\\n        }\\n        \\n        TreeNode* root=new TreeNode(nodes[0]);\\n        stack<pair<TreeNode*,int>>st;\\n        st.push({root,0});\\n        \\n        for(int i=1;i<nodes.size();i++)\\n        {\\n            if(level[st.top().ss]<level[i])\\n                st.push({new TreeNode(nodes[i]),i});\\n            else\\n            {\\n                while(!st.empty()&&level[st.top().ss]>=level[i])\\n                {\\n                    TreeNode* l=st.top().ff;st.pop();\\n                    if(!st.empty())\\n                    {if(st.top().ff->left==NULL)st.top().ff->left=l;}\\n                }\\n                st.top().ff->right=new TreeNode(nodes[i]);\\n                st.push({st.top().ff->right,i});\\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            TreeNode* node=st.top().ff;st.pop();\\n            if(!st.empty())\\n            {\\n                if(st.top().ff->left==NULL)st.top().ff->left=node;\\n                else st.top().ff->right=node;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\n#define ff first\\n#define ss second\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string t) \\n    {\\n        t+=\"-\";\\n        int n=t.size();\\n        int c=0;\\n       \\n        vector<int>level;\\n        vector<int>nodes;\\n        \\n        for(int i=0;i<n;)\\n        {\\n            if(t[i]>=\\'0\\'&&t[i]<=\\'9\\')\\n            {\\n                int num=0;\\n                while(i<n&&t[i]>=\\'0\\'&&t[i]<=\\'9\\')\\n                {\\n                    num=num*10+(t[i]-48);\\n                    i++;\\n                }\\n                nodes.push_back(num);\\n                level.push_back(c);\\n                c=0;\\n            }\\n            else\\n            {\\n                c++;\\n                i++;\\n            }\\n        }\\n        \\n        TreeNode* root=new TreeNode(nodes[0]);\\n        stack<pair<TreeNode*,int>>st;\\n        st.push({root,0});\\n        \\n        for(int i=1;i<nodes.size();i++)\\n        {\\n            if(level[st.top().ss]<level[i])\\n                st.push({new TreeNode(nodes[i]),i});\\n            else\\n            {\\n                while(!st.empty()&&level[st.top().ss]>=level[i])\\n                {\\n                    TreeNode* l=st.top().ff;st.pop();\\n                    if(!st.empty())\\n                    {if(st.top().ff->left==NULL)st.top().ff->left=l;}\\n                }\\n                st.top().ff->right=new TreeNode(nodes[i]);\\n                st.push({st.top().ff->right,i});\\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            TreeNode* node=st.top().ff;st.pop();\\n            if(!st.empty())\\n            {\\n                if(st.top().ff->left==NULL)st.top().ff->left=node;\\n                else st.top().ff->right=node;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994477,
                "title": "c-iterative-stack-18-ms-faster-than-90-of-c-online-submissions",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        \\n        int p1 = 0;\\n        int p2 = 0;\\n        \\n        int n = traversal.size();\\n        \\n        stack<pair<TreeNode*, int>> st;\\n        \\n        while(p2 < n && traversal[p2] != \\'-\\')\\n            p2++;\\n        \\n        string str = traversal.substr(0, p2);\\n        \\n        TreeNode* root = new TreeNode(stoi(str));\\n        \\n        st.push({root, 0});\\n        \\n        while(p2 < n){\\n            while(p1 < n && traversal[p1] != \\'-\\'){\\n                p1++;\\n            }\\n            while(p2 < n && traversal[p2] == \\'-\\')\\n                p2++;\\n            \\n            int level = p2 - p1;\\n            \\n            p1 = p2;\\n            \\n            while(p2 < n && traversal[p2] != \\'-\\')\\n                p2++;\\n            \\n            int y = p2 - p1;\\n            \\n            string str = traversal.substr(p1, y);\\n            \\n            TreeNode* newNode = new TreeNode(stoi(str));\\n            \\n            while(st.top().second != level -1)\\n                st.pop();\\n            \\n            auto temp = st.top().first;\\n            \\n            if(!(temp -> left)){\\n                temp -> left = newNode;\\n            }else{\\n                temp -> right = newNode;\\n            }\\n            \\n            st.push({newNode, level});\\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        \\n        int p1 = 0;\\n        int p2 = 0;\\n        \\n        int n = traversal.size();\\n        \\n        stack<pair<TreeNode*, int>> st;\\n        \\n        while(p2 < n && traversal[p2] != \\'-\\')\\n            p2++;\\n        \\n        string str = traversal.substr(0, p2);\\n        \\n        TreeNode* root = new TreeNode(stoi(str));\\n        \\n        st.push({root, 0});\\n        \\n        while(p2 < n){\\n            while(p1 < n && traversal[p1] != \\'-\\'){\\n                p1++;\\n            }\\n            while(p2 < n && traversal[p2] == \\'-\\')\\n                p2++;\\n            \\n            int level = p2 - p1;\\n            \\n            p1 = p2;\\n            \\n            while(p2 < n && traversal[p2] != \\'-\\')\\n                p2++;\\n            \\n            int y = p2 - p1;\\n            \\n            string str = traversal.substr(p1, y);\\n            \\n            TreeNode* newNode = new TreeNode(stoi(str));\\n            \\n            while(st.top().second != level -1)\\n                st.pop();\\n            \\n            auto temp = st.top().first;\\n            \\n            if(!(temp -> left)){\\n                temp -> left = newNode;\\n            }else{\\n                temp -> right = newNode;\\n            }\\n            \\n            st.push({newNode, level});\\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960912,
                "title": "python-simple-iterative-solution-using-stack",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\n\\nclass Solution(object):\\n    def recoverFromPreorder(self, traversal):\\n        \"\"\"\\n        As, given input traversal is in the form of string. To process data we need to\\n        seperate out numbers and dashes.\\n\\n        maintain hashmap for each node and dashes.\\n        key - TreeNode object, value - number of dashes in front of respective number\\n\\n        Ex. traversal =  \"1--3---4\" \\n            treeMap = {TreeNode(1):0, TreeNode(3): 2, TreeNode(4): 3}\\n        \"\"\"\\n\\n        treeMap = {}\\n        traversal = traversal + \\'-\\'\\n        num = dash = \\'\\'\\n        stack = []\\n\\n        #loop through traversal to fill up treeMap\\n        for idx in range(len(traversal)):\\n            if traversal[idx] == \\'-\\':\\n                dash += \\'-\\'\\n            if traversal[idx].isnumeric():\\n                num += traversal[idx]\\n            if traversal[idx].isnumeric() and traversal[idx + 1] == \\'-\\':\\n                intNum = int(num)\\n                node = TreeNode(intNum)\\n                treeMap[node] = len(dash)\\n                num = dash = \\'\\'\\n\\n\\n                # use stack to create tree\\n                if not stack:\\n                    stack.append(node)\\n                else:\\n                    while(treeMap[stack[-1]] >= treeMap[node]):\\n                        stack.pop() \\n                    if not stack[-1].left:\\n                        stack[-1].left = node\\n                    else:\\n                        stack[-1].right = node\\n                    stack.append(node)\\n\\n        return stack[0]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\n\\nclass Solution(object):\\n    def recoverFromPreorder(self, traversal):\\n        \"\"\"\\n        As, given input traversal is in the form of string. To process data we need to\\n        seperate out numbers and dashes.\\n\\n        maintain hashmap for each node and dashes.\\n        key - TreeNode object, value - number of dashes in front of respective number\\n\\n        Ex. traversal =  \"1--3---4\" \\n            treeMap = {TreeNode(1):0, TreeNode(3): 2, TreeNode(4): 3}\\n        \"\"\"\\n\\n        treeMap = {}\\n        traversal = traversal + \\'-\\'\\n        num = dash = \\'\\'\\n        stack = []\\n\\n        #loop through traversal to fill up treeMap\\n        for idx in range(len(traversal)):\\n            if traversal[idx] == \\'-\\':\\n                dash += \\'-\\'\\n            if traversal[idx].isnumeric():\\n                num += traversal[idx]\\n            if traversal[idx].isnumeric() and traversal[idx + 1] == \\'-\\':\\n                intNum = int(num)\\n                node = TreeNode(intNum)\\n                treeMap[node] = len(dash)\\n                num = dash = \\'\\'\\n\\n\\n                # use stack to create tree\\n                if not stack:\\n                    stack.append(node)\\n                else:\\n                    while(treeMap[stack[-1]] >= treeMap[node]):\\n                        stack.pop() \\n                    if not stack[-1].left:\\n                        stack[-1].left = node\\n                    else:\\n                        stack[-1].right = node\\n                    stack.append(node)\\n\\n        return stack[0]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869558,
                "title": "c-dfs-single-string-traversal-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    void dfs(TreeNode* root, int& curr, int n, string& s, int lvl)\\n    {\\n        if(curr >= n)\\n            return;\\n        \\n        int d = 0;\\n        while((curr < n)&&(s[curr] == \\'-\\'))\\n        {\\n            ++d;\\n            ++curr;\\n        }\\n        \\n        if(d == lvl)\\n        {\\n            \\n            int num = (int)s[curr] - 48;\\n            ++curr;\\n            while((curr<n)&&(s[curr] != \\'-\\'))\\n            {\\n                num = num*10 + ((int)s[curr] - 48);\\n                ++curr;\\n            }\\n            root->left = new TreeNode(num);\\n            dfs(root->left, curr, n, s, lvl + 1);\\n        }\\n        else\\n        {\\n            curr -= d;\\n            return;\\n        }\\n        \\n        \\n        d = 0;\\n        while((curr < n)&&(s[curr] == \\'-\\'))\\n        {\\n            ++d;\\n            ++curr;\\n        }\\n        \\n        if(d == lvl)\\n        {\\n            int num = (int)s[curr] - 48;\\n            ++curr;\\n            while((curr<n)&&(s[curr] != \\'-\\'))\\n            {\\n                num = num*10 + ((int)s[curr] - 48);\\n                ++curr;\\n            }\\n            root->right = new TreeNode(num);\\n            dfs(root->right, curr, n, s, lvl + 1);\\n        }\\n        else\\n        {\\n            curr -= d;\\n            return;\\n        }\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string t) {\\n        \\n        int n = t.size();\\n        if(n == 0)\\n        {\\n            return NULL;\\n        }\\n        \\n        int curr = 0;\\n        int num = (int)t[curr] - 48;\\n        ++curr;\\n        while((curr<n)&&(t[curr] != \\'-\\'))\\n        {\\n            num = num*10 + ((int)t[curr] - 48);\\n            ++curr;\\n        }\\n        \\n        TreeNode* root = new TreeNode(num);\\n        \\n        dfs(root, curr, n, t, 1);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    void dfs(TreeNode* root, int& curr, int n, string& s, int lvl)\\n    {\\n        if(curr >= n)\\n            return;\\n        \\n        int d = 0;\\n        while((curr < n)&&(s[curr] == \\'-\\'))\\n        {\\n            ++d;\\n            ++curr;\\n        }\\n        \\n        if(d == lvl)\\n        {\\n            \\n            int num = (int)s[curr] - 48;\\n            ++curr;\\n            while((curr<n)&&(s[curr] != \\'-\\'))\\n            {\\n                num = num*10 + ((int)s[curr] - 48);\\n                ++curr;\\n            }\\n            root->left = new TreeNode(num);\\n            dfs(root->left, curr, n, s, lvl + 1);\\n        }\\n        else\\n        {\\n            curr -= d;\\n            return;\\n        }\\n        \\n        \\n        d = 0;\\n        while((curr < n)&&(s[curr] == \\'-\\'))\\n        {\\n            ++d;\\n            ++curr;\\n        }\\n        \\n        if(d == lvl)\\n        {\\n            int num = (int)s[curr] - 48;\\n            ++curr;\\n            while((curr<n)&&(s[curr] != \\'-\\'))\\n            {\\n                num = num*10 + ((int)s[curr] - 48);\\n                ++curr;\\n            }\\n            root->right = new TreeNode(num);\\n            dfs(root->right, curr, n, s, lvl + 1);\\n        }\\n        else\\n        {\\n            curr -= d;\\n            return;\\n        }\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string t) {\\n        \\n        int n = t.size();\\n        if(n == 0)\\n        {\\n            return NULL;\\n        }\\n        \\n        int curr = 0;\\n        int num = (int)t[curr] - 48;\\n        ++curr;\\n        while((curr<n)&&(t[curr] != \\'-\\'))\\n        {\\n            num = num*10 + ((int)t[curr] - 48);\\n            ++curr;\\n        }\\n        \\n        TreeNode* root = new TreeNode(num);\\n        \\n        dfs(root, curr, n, t, 1);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841215,
                "title": "easy-to-understand-dfs-pointer-to-pointer-solution",
                "content": "Algo:\\n- Current Heigh (ch) equals to Expected height(eh), add new node here with the val. And regenerate new ch, and eh.\\n- if eh > ch, the next node should be in left as **\"If a node has only one child, that child is guaranteed to be the left child.\"**\\n- if again eh> ch, the next node should be in right side.\\n- if eh < ch, next node should be upper in the tree from current location. \\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    string traversal;\\npublic:\\n    void buildTree(TreeNode **node, int &eh,int ch,int &ci){\\n        /*\\n        *node=new TreeNode(5);\\n        \\n        cout<<(*node)->val<<\" \"<<&((*node)->left)<<endl;\\n        TreeNode **x=(&((*node)->left));\\n        *x=new TreeNode(6);\\n        cout<<(*x)->val<<endl;\\n        return;\\n        */\\n        //cout<<ch<<\" \"<<eh<<\" \"<<ci<<endl;\\n        if(ch==eh){\\n            stringstream ss;\\n            while(ci < traversal.length() && traversal[ci]!=\\'-\\'){\\n                ss<<traversal[ci];\\n                ci++;\\n            }\\n            int v;\\n            ss>>v;\\n            *node = new TreeNode(v);\\n            \\n            if(ci==traversal.length()) {\\n                eh=-1;\\n                return;\\n            }\\n            eh=1;\\n            while(traversal[++ci]==\\'-\\'){\\n                eh++;\\n            }\\n            \\n        }\\n        if(eh> ch){\\n            buildTree(&((*node)->left),eh,ch+1,ci);\\n        }\\n        if(eh> ch){\\n            buildTree(&((*node)->right),eh,ch+1,ci);\\n        }\\n        \\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        this->traversal=traversal;\\n        TreeNode *root;\\n        int eh=0,ci=0;\\n        \\n        buildTree(&root,eh,0,ci);\\n        //cout<<\"Finish\"<<endl;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    string traversal;\\npublic:\\n    void buildTree(TreeNode **node, int &eh,int ch,int &ci){\\n        /*\\n        *node=new TreeNode(5);\\n        \\n        cout<<(*node)->val<<\" \"<<&((*node)->left)<<endl;\\n        TreeNode **x=(&((*node)->left));\\n        *x=new TreeNode(6);\\n        cout<<(*x)->val<<endl;\\n        return;\\n        */\\n        //cout<<ch<<\" \"<<eh<<\" \"<<ci<<endl;\\n        if(ch==eh){\\n            stringstream ss;\\n            while(ci < traversal.length() && traversal[ci]!=\\'-\\'){\\n                ss<<traversal[ci];\\n                ci++;\\n            }\\n            int v;\\n            ss>>v;\\n            *node = new TreeNode(v);\\n            \\n            if(ci==traversal.length()) {\\n                eh=-1;\\n                return;\\n            }\\n            eh=1;\\n            while(traversal[++ci]==\\'-\\'){\\n                eh++;\\n            }\\n            \\n        }\\n        if(eh> ch){\\n            buildTree(&((*node)->left),eh,ch+1,ci);\\n        }\\n        if(eh> ch){\\n            buildTree(&((*node)->right),eh,ch+1,ci);\\n        }\\n        \\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        this->traversal=traversal;\\n        TreeNode *root;\\n        int eh=0,ci=0;\\n        \\n        buildTree(&root,eh,0,ci);\\n        //cout<<\"Finish\"<<endl;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1840180,
                "title": "java-recursive-code-should-be-clear-clean",
                "content": "```\\nclass Solution {\\n    private int index;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        if(traversal == null || traversal.length() == 0) return null;\\n        \\n        index = 0;\\n        return buildIt(traversal, 0); \\n    }\\n    \\n    private TreeNode buildIt(String data, int level){\\n        if(index >= data.length()) return null; // end of string\\n        \\n        // get level\\n        int dashs = getDashs(data);\\n        if(dashs < level) return null; \\n        \\n        // correct level, adjust index\\n        index += dashs;\\n        \\n        // get number\\n        int val = getNumber(data);\\n        \\n        TreeNode root = new TreeNode(val);\\n        \\n        root.left = buildIt(data, level+1);\\n        root.right = buildIt(data, level+1); \\n        \\n        return root; \\n    }\\n    \\n    // do not move index, we need to know first if the \\n    // level is correct.\\n    private int getDashs(String s){\\n        int dashs = 0;\\n        while(s.charAt(index+dashs) == \\'-\\'){\\n            dashs++;\\n        }\\n        return dashs;\\n    }\\n    \\n    private int getNumber(String s){\\n        StringBuilder sb = new StringBuilder();\\n        while(index < s.length() && s.charAt(index) != \\'-\\'){\\n            sb.append(s.charAt(index++));\\n        }\\n        return Integer.parseInt(sb.toString()); \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private int index;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        if(traversal == null || traversal.length() == 0) return null;\\n        \\n        index = 0;\\n        return buildIt(traversal, 0); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1771754,
                "title": "easy-python-solution-stack",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def find_level(self , s):\\n        if s[0] != \"-\":\\n            return 0 , s\\n        level = 0\\n        while(s[0] == \"-\"):\\n            level +=1\\n            s = s[1:]\\n        \\n        return (level , s)\\n    \\n    def find_num(self , s):\\n        if s[0] == \"-\":\\n            return None\\n        ans = \"\"\\n        count = 0\\n        for i in range(len(s)):\\n            if s[i] == \"-\":\\n                break\\n            ans += s[i]\\n            count +=1\\n        \\n        return (int(ans) , s[count:])\\n    \\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        \\n        s = traversal\\n        levels = []\\n        values = []\\n        while(s):\\n            level , s = self.find_level(s) \\n            num , s = self.find_num(s)\\n            levels.append(level)\\n            values.append(num)\\n        \\n        root = TreeNode(values[0])\\n        \\n        stack = [(root , 0)]\\n        for i in range(1 , len(values)):\\n            current_level = levels[i]\\n            current_val = values[i]\\n            \\n            while(stack and current_level <= stack[-1][1]):\\n                stack.pop()\\n            node , level = stack[-1]\\n            current_node = TreeNode(current_val)\\n            \\n            if node.left:\\n                node.right = current_node\\n            else:\\n                node.left = current_node\\n            \\n            stack.append((current_node, current_level))\\n        \\n        return stack[0][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def find_level(self , s):\\n        if s[0] != \"-\":\\n            return 0 , s\\n        level = 0\\n        while(s[0] == \"-\"):\\n            level +=1\\n            s = s[1:]\\n        \\n        return (level , s)\\n    \\n    def find_num(self , s):\\n        if s[0] == \"-\":\\n            return None\\n        ans = \"\"\\n        count = 0\\n        for i in range(len(s)):\\n            if s[i] == \"-\":\\n                break\\n            ans += s[i]\\n            count +=1\\n        \\n        return (int(ans) , s[count:])\\n    \\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        \\n        s = traversal\\n        levels = []\\n        values = []\\n        while(s):\\n            level , s = self.find_level(s) \\n            num , s = self.find_num(s)\\n            levels.append(level)\\n            values.append(num)\\n        \\n        root = TreeNode(values[0])\\n        \\n        stack = [(root , 0)]\\n        for i in range(1 , len(values)):\\n            current_level = levels[i]\\n            current_val = values[i]\\n            \\n            while(stack and current_level <= stack[-1][1]):\\n                stack.pop()\\n            node , level = stack[-1]\\n            current_node = TreeNode(current_val)\\n            \\n            if node.left:\\n                node.right = current_node\\n            else:\\n                node.left = current_node\\n            \\n            stack.append((current_node, current_level))\\n        \\n        return stack[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684682,
                "title": "c-stack-solution-beats-91",
                "content": "Assume the dashes(\"-\") as the height of the node from the root , if the # of dashes are greater than that of the stack top element , that means it is it\\'s child , and if\\n\\nthe # of dashes are less than that of the stack top element then pop from the stack. It is a recursive approach but done via a stack :) .\\n\\n```\\n\\nclass Solution {\\npublic:\\n\\n    TreeNode* recoverFromPreorder(string s) {\\n    \\n        stack<pair<TreeNode *,int>> st;\\n        \\n        int i=0;\\n        int n=s.size();\\n        while(i<n)\\n        {\\n            string val=\"\";\\n            int dashes=0;\\n            while( i<n && s[i]==\\'-\\')\\n            {\\n                dashes++;\\n                i++;\\n            }\\n            while(i<n && s[i]!=\\'-\\')\\n                val+=s[i++];\\n            int num=stoi(val);\\n            TreeNode * newNode =new TreeNode(num); \\n            if(st.empty())\\n            {\\n                st.push({newNode,dashes});                \\n            }\\n            else\\n            {\\n                while(!st.empty() && st.top().second>=dashes)\\n                    st.pop();\\n                \\n                if(st.top().first->left==NULL)\\n                    st.top().first->left=newNode;\\n                else \\n                    st.top().first->right=newNode;\\n                \\n                st.push({newNode,dashes});\\n                    \\n            }\\n                \\n        }\\n        while(st.size()!=1)\\n            st.pop();\\n        return st.top().first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    TreeNode* recoverFromPreorder(string s) {\\n    \\n        stack<pair<TreeNode *,int>> st;\\n        \\n        int i=0;\\n        int n=s.size();\\n        while(i<n)\\n        {\\n            string val=\"\";\\n            int dashes=0;\\n            while( i<n && s[i]==\\'-\\')\\n            {\\n                dashes++;\\n                i++;\\n            }\\n            while(i<n && s[i]!=\\'-\\')\\n                val+=s[i++];\\n            int num=stoi(val);\\n            TreeNode * newNode =new TreeNode(num); \\n            if(st.empty())\\n            {\\n                st.push({newNode,dashes});                \\n            }\\n            else\\n            {\\n                while(!st.empty() && st.top().second>=dashes)\\n                    st.pop();\\n                \\n                if(st.top().first->left==NULL)\\n                    st.top().first->left=newNode;\\n                else \\n                    st.top().first->right=newNode;\\n                \\n                st.push({newNode,dashes});\\n                    \\n            }\\n                \\n        }\\n        while(st.size()!=1)\\n            st.pop();\\n        return st.top().first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569363,
                "title": "c-unordered-map-based-approach",
                "content": "```\\nclass Solution {\\npublic:    \\n    TreeNode* recoverFromPreorder(string st) {\\n        unordered_map<int,queue<TreeNode*>> mapi;\\n        \\n        int i=0;\\n        string num = \"\";\\n        while(i<st.size()&&st[i]!=\\'-\\'){\\n                num = num + st[i];\\n                i++;\\n        }\\n        int numbu = stoi(num);\\n        TreeNode* root = new TreeNode(numbu);\\n        mapi[0].push(root);\\n        \\n        while(i < st.size()){\\n            int depth = 0;\\n            while(st[i] == \\'-\\'){\\n                depth++;\\n                i++;\\n            }\\n            int k = depth;\\n            while(mapi.find(k)!=mapi.end()){\\n                mapi.erase(k);\\n                k++;\\n            } \\n            string num = \"\";\\n            while(i<st.size()&&st[i]!=\\'-\\'){\\n                num = num + st[i];\\n                i++;\\n            }\\n            int numb = stoi(num);\\n            \\n            TreeNode * temp = mapi[depth-1].front();\\n            \\n            TreeNode* temp1 = new TreeNode(numb);\\n            \\n            if(temp->left == NULL){\\n                temp->left = temp1;\\n            } else {\\n                temp->right = temp1;\\n            }\\n            \\n            if(temp->left&&temp->right){\\n                mapi[depth-1].pop();\\n            }\\n            mapi[depth].push(temp1);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n    TreeNode* recoverFromPreorder(string st) {\\n        unordered_map<int,queue<TreeNode*>> mapi;\\n        \\n        int i=0;\\n        string num = \"\";\\n        while(i<st.size()&&st[i]!=\\'-\\'){\\n                num = num + st[i];\\n                i++;\\n        }\\n        int numbu = stoi(num);\\n        TreeNode* root = new TreeNode(numbu);\\n        mapi[0].push(root);\\n        \\n        while(i < st.size()){\\n            int depth = 0;\\n            while(st[i] == \\'-\\'){\\n                depth++;\\n                i++;\\n            }\\n            int k = depth;\\n            while(mapi.find(k)!=mapi.end()){\\n                mapi.erase(k);\\n                k++;\\n            } \\n            string num = \"\";\\n            while(i<st.size()&&st[i]!=\\'-\\'){\\n                num = num + st[i];\\n                i++;\\n            }\\n            int numb = stoi(num);\\n            \\n            TreeNode * temp = mapi[depth-1].front();\\n            \\n            TreeNode* temp1 = new TreeNode(numb);\\n            \\n            if(temp->left == NULL){\\n                temp->left = temp1;\\n            } else {\\n                temp->right = temp1;\\n            }\\n            \\n            if(temp->left&&temp->right){\\n                mapi[depth-1].pop();\\n            }\\n            mapi[depth].push(temp1);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530376,
                "title": "java-stack-solution",
                "content": "```\\n// Stack Solution\\n// Keep the top element in stack is the parent of current node.\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        if (traversal == null || traversal.isEmpty()) return null;\\n        final int L = traversal.length();\\n        TreeNode root = null;\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        int idx = 0;\\n        while (idx < L) {\\n            int depth = 0;\\n            while (idx < L && traversal.charAt(idx) == \\'-\\') {\\n                idx++;\\n                depth++;\\n            }\\n            int val = 0;\\n            while (idx < L && traversal.charAt(idx) != \\'-\\') {\\n                val = traversal.charAt(idx) - \\'0\\' + val * 10;\\n                idx++;\\n            }\\n            while (stack.size() > depth) { // Pop the nodes at same level or below.\\n                stack.pop();\\n            }\\n            TreeNode node = new TreeNode(val);\\n            if (!stack.isEmpty()) {\\n                TreeNode parent = stack.peek();\\n                if (parent.left == null) {\\n                    parent.left = node;\\n                } else {\\n                    parent.right = node;\\n                }\\n            }\\n            stack.push(node);\\n            if (root == null) root = node;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Stack Solution\\n// Keep the top element in stack is the parent of current node.\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        if (traversal == null || traversal.isEmpty()) return null;\\n        final int L = traversal.length();\\n        TreeNode root = null;\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        int idx = 0;\\n        while (idx < L) {\\n            int depth = 0;\\n            while (idx < L && traversal.charAt(idx) == \\'-\\') {\\n                idx++;\\n                depth++;\\n            }\\n            int val = 0;\\n            while (idx < L && traversal.charAt(idx) != \\'-\\') {\\n                val = traversal.charAt(idx) - \\'0\\' + val * 10;\\n                idx++;\\n            }\\n            while (stack.size() > depth) { // Pop the nodes at same level or below.\\n                stack.pop();\\n            }\\n            TreeNode node = new TreeNode(val);\\n            if (!stack.isEmpty()) {\\n                TreeNode parent = stack.peek();\\n                if (parent.left == null) {\\n                    parent.left = node;\\n                } else {\\n                    parent.right = node;\\n                }\\n            }\\n            stack.push(node);\\n            if (root == null) root = node;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495610,
                "title": "cpp-simple-understandable-code",
                "content": "```\\nstring s;\\n    int p = 0;\\n    \\n    int Getnum(){\\n        int temp = 0;\\n        while(p < s.size() && s[p] != \\'-\\'){\\n            temp *= 10;\\n            temp += (int)(s[p] - \\'0\\');\\n            p++;\\n        }\\n        return temp;\\n    }\\n    \\n    int getdepth(){\\n        int cnt = 0;\\n        while(p < s.size() && s[p] == \\'-\\'){\\n            cnt++;\\n            p++;\\n        }\\n        return cnt;\\n    }\\n    \\n    TreeNode* find(TreeNode* root, int depth){\\n        \\n        int cnt = getdepth();\\n        if(cnt != depth){ \\n            p -= cnt;\\n            return NULL;\\n        }\\n        \\n        int num = Getnum();\\n        \\n        root = new TreeNode(num);\\n        root->left = find(root->left, depth+1);\\n        root->right = find(root->right, depth+1);\\n        \\n        return root;\\n        \\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) {\\n        \\n        TreeNode* root = NULL;\\n        this->s = traversal;\\n        \\n        root = find(root, 0);\\n        \\n        return root;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring s;\\n    int p = 0;\\n    \\n    int Getnum(){\\n        int temp = 0;\\n        while(p < s.size() && s[p] != \\'-\\'){\\n            temp *= 10;\\n            temp += (int)(s[p] - \\'0\\');\\n            p++;\\n        }\\n        return temp;\\n    }\\n    \\n    int getdepth(){\\n        int cnt = 0;\\n        while(p < s.size() && s[p] == \\'-\\'){\\n            cnt++;\\n            p++;\\n        }\\n        return cnt;\\n    }\\n    \\n    TreeNode* find(TreeNode* root, int depth){\\n        \\n        int cnt = getdepth();\\n        if(cnt != depth){ \\n            p -= cnt;\\n            return NULL;\\n        }\\n        \\n        int num = Getnum();\\n        \\n        root = new TreeNode(num);\\n        root->left = find(root->left, depth+1);\\n        root->right = find(root->right, depth+1);\\n        \\n        return root;\\n        \\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) {\\n        \\n        TreeNode* root = NULL;\\n        this->s = traversal;\\n        \\n        root = find(root, 0);\\n        \\n        return root;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1460447,
                "title": "python-3-python-recover-a-tree-from-preorder-traversal",
                "content": "```\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        stack=[]\\n        res=\\'\\'\\n        i=0\\n        while i<len(traversal) and \\'0\\'<= traversal[i]<=\\'9\\':\\n            res+=traversal[i]\\n            i+=1\\n        root=TreeNode()\\n        root.val=int(res)\\n        stack=[[0,root]]\\n        while i<len(traversal):\\n            count=0\\n            while i<len(traversal) and traversal[i]<=\\'-\\':\\n                count+=1\\n                i+=1\\n            res=\\'\\'\\n            while i<len(traversal) and \\'0\\'<= traversal[i]<=\\'9\\':\\n                res+=traversal[i]\\n                i+=1\\n            node=TreeNode()\\n            node.val=int(res)\\n            while stack and stack[-1][0]!=count-1:\\n                stack.pop()\\n            if stack[-1][1].left==None:\\n                stack[-1][1].left=node\\n            else:\\n                stack[-1][1].right=node\\n            stack.append([count,node])\\n        return root\\n                \\n            \\n            \\n            \\n            \\n       \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        stack=[]\\n        res=\\'\\'\\n        i=0\\n        while i<len(traversal) and \\'0\\'<= traversal[i]<=\\'9\\':\\n            res+=traversal[i]\\n            i+=1\\n        root=TreeNode()\\n        root.val=int(res)\\n        stack=[[0,root]]\\n        while i<len(traversal):\\n            count=0\\n            while i<len(traversal) and traversal[i]<=\\'-\\':\\n                count+=1\\n                i+=1\\n            res=\\'\\'\\n            while i<len(traversal) and \\'0\\'<= traversal[i]<=\\'9\\':\\n                res+=traversal[i]\\n                i+=1\\n            node=TreeNode()\\n            node.val=int(res)\\n            while stack and stack[-1][0]!=count-1:\\n                stack.pop()\\n            if stack[-1][1].left==None:\\n                stack[-1][1].left=node\\n            else:\\n                stack[-1][1].right=node\\n            stack.append([count,node])\\n        return root\\n                \\n            \\n            \\n            \\n            \\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345076,
                "title": "c-simple-recursive-preorder",
                "content": "Store the values in pre order along with their depth. Then create a tree with the matching depth and values. Return NULL when the depth doesn\\'t match or the preorder traversal ends.\\n\\n```\\nclass Solution {\\n    vector <pair<int,int>> v;\\n    int idx = 0;\\npublic:\\n    TreeNode* preOrder(int depth){\\n        if(idx>=v.size() || depth != v[idx].first)\\n            return NULL;\\n        TreeNode* root = new TreeNode(v[idx].second);\\n        idx += 1;\\n        root->left = preOrder(depth+1);\\n        root->right = preOrder(depth+1);\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        int dash = 0;\\n        int num=traversal[0] - \\'0\\';\\n        for(int i=1;i<traversal.size();i++){\\n            if(traversal[i] == \\'-\\'){\\n                if(traversal[i-1] != \\'-\\'){\\n                    v.push_back({dash,num});\\n                    dash = 0;\\n                    num = 0;\\n                }\\n                dash++;\\n            }else{\\n                num = num*10 + traversal[i] - \\'0\\';\\n            }\\n        }\\n        v.push_back({dash,num});\\n        return preOrder(0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector <pair<int,int>> v;\\n    int idx = 0;\\npublic:\\n    TreeNode* preOrder(int depth){\\n        if(idx>=v.size() || depth != v[idx].first)\\n            return NULL;\\n        TreeNode* root = new TreeNode(v[idx].second);\\n        idx += 1;\\n        root->left = preOrder(depth+1);\\n        root->right = preOrder(depth+1);\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        int dash = 0;\\n        int num=traversal[0] - \\'0\\';\\n        for(int i=1;i<traversal.size();i++){\\n            if(traversal[i] == \\'-\\'){\\n                if(traversal[i-1] != \\'-\\'){\\n                    v.push_back({dash,num});\\n                    dash = 0;\\n                    num = 0;\\n                }\\n                dash++;\\n            }else{\\n                num = num*10 + traversal[i] - \\'0\\';\\n            }\\n        }\\n        v.push_back({dash,num});\\n        return preOrder(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189399,
                "title": "recursive-simple-approach-c",
                "content": "- We recursively find required level and curr level,by calculating the no of \"-\" and if curr and req level match then it is going to be a child.\\n- Else we return NULL.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nint i=0;\\nclass Solution {\\npublic:\\n    //converting the given string to a number\\n    int convert(vector<int> vect){\\n        int j=vect.size()-1,k=0,m=0;\\n        while(j>=0){\\n            m+=vect[j]*pow(10,k);\\n            k++;j--;\\n        }\\n        return m;\\n    }\\n    //Recursively genrating the tree form string S\\n    TreeNode *construct(string S,int req_level){\\n           int j=i,curr_level=0;\\n           if(i==S.size()) return NULL;\\n           j--;\\n           while(j>=0 && S[j]==\\'-\\'){\\n               curr_level++;\\n               j--;\\n           }\\n           //if current level is not equal to required level return NULL\\n           if(curr_level!=req_level) return NULL;\\n           vector<int> vect;\\n           while(i!=S.size() && S[i]!=\\'-\\'){\\n               vect.push_back(S[i]-\\'0\\');\\n               i++;\\n           }\\n           while(i!=S.size() && S[i]==\\'-\\') i++;\\n           int num = convert(vect);\\n           TreeNode *node = new TreeNode(num);\\n           node->left = construct(S,curr_level+1);\\n           node->right = construct(S,curr_level+1);\\n           return node;\\n    }\\n    TreeNode* recoverFromPreorder(string S) {\\n        i=0;\\n        TreeNode *root = construct(S,0);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nint i=0;\\nclass Solution {\\npublic:\\n    //converting the given string to a number\\n    int convert(vector<int> vect){\\n        int j=vect.size()-1,k=0,m=0;\\n        while(j>=0){\\n            m+=vect[j]*pow(10,k);\\n            k++;j--;\\n        }\\n        return m;\\n    }\\n    //Recursively genrating the tree form string S\\n    TreeNode *construct(string S,int req_level){\\n           int j=i,curr_level=0;\\n           if(i==S.size()) return NULL;\\n           j--;\\n           while(j>=0 && S[j]==\\'-\\'){\\n               curr_level++;\\n               j--;\\n           }\\n           //if current level is not equal to required level return NULL\\n           if(curr_level!=req_level) return NULL;\\n           vector<int> vect;\\n           while(i!=S.size() && S[i]!=\\'-\\'){\\n               vect.push_back(S[i]-\\'0\\');\\n               i++;\\n           }\\n           while(i!=S.size() && S[i]==\\'-\\') i++;\\n           int num = convert(vect);\\n           TreeNode *node = new TreeNode(num);\\n           node->left = construct(S,curr_level+1);\\n           node->right = construct(S,curr_level+1);\\n           return node;\\n    }\\n    TreeNode* recoverFromPreorder(string S) {\\n        i=0;\\n        TreeNode *root = construct(S,0);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107935,
                "title": "c-faster-than-48-o-n-single-pass-with-hashmap",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string S) {\\n        Dictionary<int, TreeNode> _lastAtLevel = new Dictionary<int, TreeNode>();\\n        \\n        int currentLevel=0;\\n        int lastIndex=0;\\n        \\n        while(lastIndex<S.Length){\\n            currentLevel=0;\\n            \\n            while(lastIndex<S.Length && S[lastIndex]==\\'-\\'){\\n                lastIndex++;\\n                currentLevel++;\\n            }\\n\\n            int valStartIndex = lastIndex;\\n\\n            while(lastIndex<S.Length && S[lastIndex]!=\\'-\\'){\\n                lastIndex++;\\n            }\\n\\n            string val=S.Substring(valStartIndex, lastIndex-valStartIndex);\\n\\n            TreeNode tn = new TreeNode(int.Parse(val));\\n\\n            if(currentLevel>0){\\n                TreeNode parent = _lastAtLevel[currentLevel-1];\\n\\n                if(parent.left==null){\\n                    parent.left = tn;\\n                }\\n                else{\\n                    parent.right = tn;\\n                }\\n            }\\n\\n            _lastAtLevel[currentLevel]=tn;\\n        }\\n        \\n        return _lastAtLevel[0];\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string S) {\\n        Dictionary<int, TreeNode> _lastAtLevel = new Dictionary<int, TreeNode>();\\n        \\n        int currentLevel=0;\\n        int lastIndex=0;\\n        \\n        while(lastIndex<S.Length){\\n            currentLevel=0;\\n            \\n            while(lastIndex<S.Length && S[lastIndex]==\\'-\\'){\\n                lastIndex++;\\n                currentLevel++;\\n            }\\n\\n            int valStartIndex = lastIndex;\\n\\n            while(lastIndex<S.Length && S[lastIndex]!=\\'-\\'){\\n                lastIndex++;\\n            }\\n\\n            string val=S.Substring(valStartIndex, lastIndex-valStartIndex);\\n\\n            TreeNode tn = new TreeNode(int.Parse(val));\\n\\n            if(currentLevel>0){\\n                TreeNode parent = _lastAtLevel[currentLevel-1];\\n\\n                if(parent.left==null){\\n                    parent.left = tn;\\n                }\\n                else{\\n                    parent.right = tn;\\n                }\\n            }\\n\\n            _lastAtLevel[currentLevel]=tn;\\n        }\\n        \\n        return _lastAtLevel[0];\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047405,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution {\\n    TreeNode* helper(const string& str, int& idx, int curDepth) {\\n        if (idx == str.size()) return nullptr;\\n        \\n        int depth = 0;\\n        while (idx < str.size() && str[idx] == \\'-\\') {\\n            ++depth;\\n            ++idx;\\n        }\\n        \\n        if (depth < curDepth) {\\n            idx -= depth;\\n            return nullptr;\\n        }\\n        \\n        int val = 0;\\n        while (idx < str.size() && isdigit(str[idx])) {\\n            val = val * 10 + str[idx] - \\'0\\';\\n            ++idx;\\n        }\\n        \\n        TreeNode* node = new TreeNode(val);\\n        node->left = helper(str, idx, curDepth + 1);\\n        node->right = helper(str, idx, curDepth + 1);\\n        \\n        return node;\\n    }\\n    \\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        int idx = 0;\\n        return helper(S, idx, 0);\\n    }\\n};\\n```\\n\\n\\nSlightly refactored:\\n```\\nclass Solution {\\n    int idx = 0;\\n    string str;\\n    \\n    int getDepth() {\\n        int depth = 0;\\n        while (idx < str.size() && str[idx] == \\'-\\') {\\n            ++depth;\\n            ++idx;\\n        }\\n        return depth;\\n    }\\n    \\n    int getVal() {\\n        int val = 0;\\n        while (idx < str.size() && isdigit(str[idx])) {\\n            val = val * 10 + str[idx] - \\'0\\';\\n            ++idx;\\n        }\\n        return val;\\n    }\\n    \\n    TreeNode* helper(int curDepth) {\\n        if (idx == str.size()) return nullptr;\\n        \\n        auto depth = getDepth();\\n        if (depth < curDepth) {\\n            idx -= depth;\\n            return nullptr;\\n        }\\n                \\n        auto node = new TreeNode(getVal());\\n        node->left = helper(curDepth + 1);\\n        node->right = helper(curDepth + 1);\\n        \\n        return node;\\n    }\\n    \\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        str = S;\\n        return helper(0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode* helper(const string& str, int& idx, int curDepth) {\\n        if (idx == str.size()) return nullptr;\\n        \\n        int depth = 0;\\n        while (idx < str.size() && str[idx] == \\'-\\') {\\n            ++depth;\\n            ++idx;\\n        }\\n        \\n        if (depth < curDepth) {\\n            idx -= depth;\\n            return nullptr;\\n        }\\n        \\n        int val = 0;\\n        while (idx < str.size() && isdigit(str[idx])) {\\n            val = val * 10 + str[idx] - \\'0\\';\\n            ++idx;\\n        }\\n        \\n        TreeNode* node = new TreeNode(val);\\n        node->left = helper(str, idx, curDepth + 1);\\n        node->right = helper(str, idx, curDepth + 1);\\n        \\n        return node;\\n    }\\n    \\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        int idx = 0;\\n        return helper(S, idx, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int idx = 0;\\n    string str;\\n    \\n    int getDepth() {\\n        int depth = 0;\\n        while (idx < str.size() && str[idx] == \\'-\\') {\\n            ++depth;\\n            ++idx;\\n        }\\n        return depth;\\n    }\\n    \\n    int getVal() {\\n        int val = 0;\\n        while (idx < str.size() && isdigit(str[idx])) {\\n            val = val * 10 + str[idx] - \\'0\\';\\n            ++idx;\\n        }\\n        return val;\\n    }\\n    \\n    TreeNode* helper(int curDepth) {\\n        if (idx == str.size()) return nullptr;\\n        \\n        auto depth = getDepth();\\n        if (depth < curDepth) {\\n            idx -= depth;\\n            return nullptr;\\n        }\\n                \\n        auto node = new TreeNode(getVal());\\n        node->left = helper(curDepth + 1);\\n        node->right = helper(curDepth + 1);\\n        \\n        return node;\\n    }\\n    \\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        str = S;\\n        return helper(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958849,
                "title": "using-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        int n = S.length();\\n        Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque<>();\\n        int i = 0;\\n        TreeNode ans = new TreeNode(-1);\\n        stack.addLast(new Pair(ans, -1)); // temp node\\n        while (i < n) {\\n            int d = 0; //depth\\n            while (i < n && S.charAt(i) == \\'-\\') {\\n                d++; i++;\\n            }\\n            int num = 0;\\n            while (i < n && (S.charAt(i) >= \\'0\\' && S.charAt(i) <= \\'9\\')) {\\n                num = num * 10 + (S.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            \\n            TreeNode cur = new TreeNode(num);\\n            // if we see the new node depth as stack[-1].d + 1, then \\n            // add this node as left to top of stack node\\n            if (stack.getLast().getValue()+1 == d) {\\n                TreeNode top = stack.getLast().getKey();\\n                top.left = cur; \\n            } else {\\n                // pop stack till we get stack[-1].d+1 == d\\n                while (stack.getLast().getValue()+1 != d) {\\n                    stack.removeLast();\\n                }\\n                TreeNode top = stack.getLast().getKey();\\n                top.right = cur;\\n            }\\n            stack.addLast(new Pair(cur, d));\\n        }\\n        return ans.left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        int n = S.length();\\n        Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque<>();\\n        int i = 0;\\n        TreeNode ans = new TreeNode(-1);\\n        stack.addLast(new Pair(ans, -1)); // temp node\\n        while (i < n) {\\n            int d = 0; //depth\\n            while (i < n && S.charAt(i) == \\'-\\') {\\n                d++; i++;\\n            }\\n            int num = 0;\\n            while (i < n && (S.charAt(i) >= \\'0\\' && S.charAt(i) <= \\'9\\')) {\\n                num = num * 10 + (S.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            \\n            TreeNode cur = new TreeNode(num);\\n            // if we see the new node depth as stack[-1].d + 1, then \\n            // add this node as left to top of stack node\\n            if (stack.getLast().getValue()+1 == d) {\\n                TreeNode top = stack.getLast().getKey();\\n                top.left = cur; \\n            } else {\\n                // pop stack till we get stack[-1].d+1 == d\\n                while (stack.getLast().getValue()+1 != d) {\\n                    stack.removeLast();\\n                }\\n                TreeNode top = stack.getLast().getKey();\\n                top.right = cur;\\n            }\\n            stack.addLast(new Pair(cur, d));\\n        }\\n        return ans.left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925378,
                "title": "simple-java-solution-for-slow-learners-like-myself-using-2-queues",
                "content": "//Runtime: O(n) to parse string and build queue, O(n) to build tree from queue -> O(n) where n is the length of string\\n//Space: O(n + h) where h is depth of expected tree\\n```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String s) {\\n        s = s == null ? \"\" : s;\\n        \\n        Queue<Integer> numQueue = new LinkedList<>(), dashQueue = new LinkedList<>();\\n        int i = 0;\\n        \\n        while (i < s.length()) {\\n            int num = 0, dash = 0;\\n            \\n            while (i < s.length() && s.charAt(i) == \\'-\\') {\\n                dash++;\\n                i++;\\n            }\\n\\n            while (i < s.length() && s.charAt(i) >= \\'0\\' && s.charAt(i) <= \\'9\\') \\n                num = num * 10 + (s.charAt(i++) - \\'0\\');\\n            \\n            numQueue.offer(num);\\n            dashQueue.offer(dash);\\n        }\\n\\n        return build(numQueue, dashQueue, 0);\\n    }\\n    \\n\\n    private TreeNode build(Queue<Integer> numQueue, Queue<Integer> dashQueue, int level) {\\n        if (dashQueue.isEmpty() || dashQueue.peek() != level) \\n            return null;\\n        \\n        int num = numQueue.poll();\\n        dashQueue.poll();\\n        \\n        TreeNode root = new TreeNode(num);\\n        root.left = build(numQueue, dashQueue, level + 1);\\n        root.right = build(numQueue, dashQueue, level + 1);\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String s) {\\n        s = s == null ? \"\" : s;\\n        \\n        Queue<Integer> numQueue = new LinkedList<>(), dashQueue = new LinkedList<>();\\n        int i = 0;\\n        \\n        while (i < s.length()) {\\n            int num = 0, dash = 0;\\n            \\n            while (i < s.length() && s.charAt(i) == \\'-\\') {\\n                dash++;\\n                i++;\\n            }\\n\\n            while (i < s.length() && s.charAt(i) >= \\'0\\' && s.charAt(i) <= \\'9\\') \\n                num = num * 10 + (s.charAt(i++) - \\'0\\');\\n            \\n            numQueue.offer(num);\\n            dashQueue.offer(dash);\\n        }\\n\\n        return build(numQueue, dashQueue, 0);\\n    }\\n    \\n\\n    private TreeNode build(Queue<Integer> numQueue, Queue<Integer> dashQueue, int level) {\\n        if (dashQueue.isEmpty() || dashQueue.peek() != level) \\n            return null;\\n        \\n        int num = numQueue.poll();\\n        dashQueue.poll();\\n        \\n        TreeNode root = new TreeNode(num);\\n        root.left = build(numQueue, dashQueue, level + 1);\\n        root.right = build(numQueue, dashQueue, level + 1);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900032,
                "title": "java-dfs-solution",
                "content": "1. If number of \"-\" are 1 more than current level insert a node to the left or right..\\n2. If number of \"-\" are <= current level return back to upper level.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int i=0;\\n    TreeNode root = null;\\n    String S = null;\\n    public TreeNode recoverFromPreorder(String S) {\\n        if(S.isEmpty())\\n            return null;\\n        this.S=S;\\n        String number = \"\";\\n        while(i<S.length() && Character.isDigit(S.charAt(i))){\\n            number+=S.charAt(i);\\n            i++;\\n        }\\n        root=new TreeNode(Integer.valueOf(number));\\n        recover(root,0);\\n        return root;\\n    }\\n    \\n    \\n    public int recover(TreeNode root,int level){\\n        if(i==S.length())\\n            return 0;\\n        int count=0;\\n        while(S.charAt(i)==\\'-\\'){\\n            count++;\\n            i++;\\n        }\\n        if(count==level+1){\\n                if(root.left==null){\\n                    String number = \"\";\\n                    while(i<S.length() && Character.isDigit(S.charAt(i))){\\n                        number+=S.charAt(i);\\n                        i++;\\n                    }\\n                    root.left=new TreeNode(Integer.valueOf(number));\\n                    int x =  recover(root.left,level+1);\\n                    if(x<=level){\\n                        return x;\\n                    }\\n                } \\n                if(root.right==null){\\n                    String number = \"\";\\n                    while(i<S.length() && Character.isDigit(S.charAt(i))){\\n                    number+=S.charAt(i);\\n                    i++;\\n                    }\\n                    root.right=new TreeNode(Integer.valueOf(number));\\n                    int x =  recover(root.right,level+1);\\n                    if(x<=level)\\n                    return x;\\n                }\\n            }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int i=0;\\n    TreeNode root = null;\\n    String S = null;\\n    public TreeNode recoverFromPreorder(String S) {\\n        if(S.isEmpty())\\n            return null;\\n        this.S=S;\\n        String number = \"\";\\n        while(i<S.length() && Character.isDigit(S.charAt(i))){\\n            number+=S.charAt(i);\\n            i++;\\n        }\\n        root=new TreeNode(Integer.valueOf(number));\\n        recover(root,0);\\n        return root;\\n    }\\n    \\n    \\n    public int recover(TreeNode root,int level){\\n        if(i==S.length())\\n            return 0;\\n        int count=0;\\n        while(S.charAt(i)==\\'-\\'){\\n            count++;\\n            i++;\\n        }\\n        if(count==level+1){\\n                if(root.left==null){\\n                    String number = \"\";\\n                    while(i<S.length() && Character.isDigit(S.charAt(i))){\\n                        number+=S.charAt(i);\\n                        i++;\\n                    }\\n                    root.left=new TreeNode(Integer.valueOf(number));\\n                    int x =  recover(root.left,level+1);\\n                    if(x<=level){\\n                        return x;\\n                    }\\n                } \\n                if(root.right==null){\\n                    String number = \"\";\\n                    while(i<S.length() && Character.isDigit(S.charAt(i))){\\n                    number+=S.charAt(i);\\n                    i++;\\n                    }\\n                    root.right=new TreeNode(Integer.valueOf(number));\\n                    int x =  recover(root.right,level+1);\\n                    if(x<=level)\\n                    return x;\\n                }\\n            }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842076,
                "title": "java-without-recursion-queue-or-stack",
                "content": "Solution relies on straight forward observation that if I am currently considering node of deapth D, its parent will be most recently visited node with deapth [D-1]. And this will hold true for preorder traversal.\\n\\n```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String s) {\\n        int cur = 0;\\n        int n = s.length();\\n        char[] a = s.toCharArray();\\n        HashMap<Integer, TreeNode> lastNodeAtDeapth = new HashMap<>();\\n        \\n        // Root is always first, find its value.\\n        int val = 0;\\n        while (cur < n && a[cur] != \\'-\\') {\\n            val *= 10;\\n            val += (a[cur] - \\'0\\');\\n            cur++;\\n        }\\n        \\n        TreeNode root = new TreeNode(val);\\n        lastNodeAtDeapth.put(0, root);\\n        \\n        while (cur < n) {\\n            int deapth = 0;\\n            while (cur < n && a[cur] == \\'-\\') {\\n                deapth++;\\n                cur++;\\n            }\\n            int curVal = 0;\\n            while (cur < n && a[cur] != \\'-\\') {\\n                curVal *= 10;\\n                curVal += (a[cur] - \\'0\\');\\n                cur++;\\n            }\\n            TreeNode node = new TreeNode(curVal);\\n            lastNodeAtDeapth.put(deapth, node);\\n            TreeNode parent = lastNodeAtDeapth.get(deapth - 1);\\n            if (parent.left == null)\\n                parent.left = node;\\n            else \\n                parent.right = node;\\n        }\\n        return root;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String s) {\\n        int cur = 0;\\n        int n = s.length();\\n        char[] a = s.toCharArray();\\n        HashMap<Integer, TreeNode> lastNodeAtDeapth = new HashMap<>();\\n        \\n        // Root is always first, find its value.\\n        int val = 0;\\n        while (cur < n && a[cur] != \\'-\\') {\\n            val *= 10;\\n            val += (a[cur] - \\'0\\');\\n            cur++;\\n        }\\n        \\n        TreeNode root = new TreeNode(val);\\n        lastNodeAtDeapth.put(0, root);\\n        \\n        while (cur < n) {\\n            int deapth = 0;\\n            while (cur < n && a[cur] == \\'-\\') {\\n                deapth++;\\n                cur++;\\n            }\\n            int curVal = 0;\\n            while (cur < n && a[cur] != \\'-\\') {\\n                curVal *= 10;\\n                curVal += (a[cur] - \\'0\\');\\n                cur++;\\n            }\\n            TreeNode node = new TreeNode(curVal);\\n            lastNodeAtDeapth.put(deapth, node);\\n            TreeNode parent = lastNodeAtDeapth.get(deapth - 1);\\n            if (parent.left == null)\\n                parent.left = node;\\n            else \\n                parent.right = node;\\n        }\\n        return root;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776700,
                "title": "simple-python-solution-with-a-stack",
                "content": "A simple Python solution that uses `re` for parsing and a stack for appending tree nodes.\\n\\n```\\ndef recoverFromPreorder(self, S: str) -> TreeNode:\\n    import re\\n    if not S:\\n        return None\\n    groups = re.findall(r\\'(-*)([^-]+)\\', S)\\n    pending = [TreeNode(int(groups[0][1]))]\\n    for g in groups[1:]:\\n        depth = len(g[0])\\n        val = int(g[1])\\n        if depth >= len(pending):\\n            pending[-1].left = TreeNode(val)\\n            pending.append(pending[-1].left)\\n        else:\\n            del pending[depth:]\\n            pending[-1].right = TreeNode(val)\\n            pending.append(pending[-1].right)\\n    return pending[0]\\n```",
                "solutionTags": [],
                "code": "```\\ndef recoverFromPreorder(self, S: str) -> TreeNode:\\n    import re\\n    if not S:\\n        return None\\n    groups = re.findall(r\\'(-*)([^-]+)\\', S)\\n    pending = [TreeNode(int(groups[0][1]))]\\n    for g in groups[1:]:\\n        depth = len(g[0])\\n        val = int(g[1])\\n        if depth >= len(pending):\\n            pending[-1].left = TreeNode(val)\\n            pending.append(pending[-1].left)\\n        else:\\n            del pending[depth:]\\n            pending[-1].right = TreeNode(val)\\n            pending.append(pending[-1].right)\\n    return pending[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 730295,
                "title": "c-solution-using-hash-map-time-o-n-space-o-h-h-height-of-the-tree",
                "content": "For explanation and better understanding refer to the link below:\\nhttps://docs.google.com/document/d/1gFIH55uhUHdLtvBErh9tQLf4pBf-KGBeMHtz2z0d1Is/edit?usp=sharing\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    TreeNode* newnode(int data)\\n    {\\n        TreeNode* n=new TreeNode;\\n        n->val=data;\\n        n->left=NULL;\\n        n->right=NULL;\\n        return n;\\n    }\\n    TreeNode* recoverFromPreorder(string S) {\\n        \\n        unordered_map<int,TreeNode*> level;\\n        TreeNode* root;\\n        int i,c=0;\\n        for(i=0;i<S.size();)\\n        {\\n            if(S[i]==\\'-\\')\\n            {\\n                c++;\\n                i++;\\n            }\\n            else\\n            {\\n                string n=\"\";\\n                while(i<S.size()&&S[i]>=\\'0\\'&&S[i]<=\\'9\\')\\n                {\\n                    n+=S[i];   \\n                    i++;\\n                }\\n                level[c]=newnode(stoi(n));\\n                if(c>0)\\n                {\\n                    TreeNode* parent=level[c-1];\\n                    if(!parent->left)\\n                        parent->left=level[c];\\n                    else\\n                        parent->right=level[c];\\n                }\\n                else\\n                    root=level[c];\\n                c=0;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    TreeNode* newnode(int data)\\n    {\\n        TreeNode* n=new TreeNode;\\n        n->val=data;\\n        n->left=NULL;\\n        n->right=NULL;\\n        return n;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 683190,
                "title": "c-simple-solution-using-memoization",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        unordered_map<int, vector<TreeNode*>> vmap;\\n        int idx = 0, dash = 0, val = 0;\\n        while (idx < S.length()) {\\n            //cout << idx << \":\" << dash << \":\" << val << endl;\\n            if (isdigit(S[idx])) {\\n                val = val * 10 + (S[idx] - \\'0\\');\\n                if ((idx + 1 < S.length() && S[idx + 1] == \\'-\\') ||\\n                   (idx == S.length() - 1)) {\\n                    \\n                    TreeNode* nd = new TreeNode(val);\\n                    if (dash == 0) {\\n                        vmap[0].push_back(nd);\\n                    } else {\\n                        int n = vmap[dash - 1].size();\\n                        if (vmap[dash - 1][n - 1]->left == NULL)  vmap[dash - 1][n - 1]->left = nd;\\n                        else vmap[dash - 1][n - 1]->right = nd;\\n                        vmap[dash].push_back(nd);\\n                    }\\n                    dash = 0;\\n                } \\n            } else {\\n                val = 0;\\n                dash++;\\n            }\\n            idx++;\\n        }\\n        return vmap[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        unordered_map<int, vector<TreeNode*>> vmap;\\n        int idx = 0, dash = 0, val = 0;\\n        while (idx < S.length()) {\\n            //cout << idx << \":\" << dash << \":\" << val << endl;\\n            if (isdigit(S[idx])) {\\n                val = val * 10 + (S[idx] - \\'0\\');\\n                if ((idx + 1 < S.length() && S[idx + 1] == \\'-\\') ||\\n                   (idx == S.length() - 1)) {\\n                    \\n                    TreeNode* nd = new TreeNode(val);\\n                    if (dash == 0) {\\n                        vmap[0].push_back(nd);\\n                    } else {\\n                        int n = vmap[dash - 1].size();\\n                        if (vmap[dash - 1][n - 1]->left == NULL)  vmap[dash - 1][n - 1]->left = nd;\\n                        else vmap[dash - 1][n - 1]->right = nd;\\n                        vmap[dash].push_back(nd);\\n                    }\\n                    dash = 0;\\n                } \\n            } else {\\n                val = 0;\\n                dash++;\\n            }\\n            idx++;\\n        }\\n        return vmap[0][0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 669992,
                "title": "c-solution-preorder-traverse-using-stack-or-vector",
                "content": "```\\nclass Solution {\\n  private:\\n    int idx, N;\\n    int nextInt(string& s) {\\n      int p = idx;\\n      while (idx<N && s[idx]!=\\'-\\')\\n        ++idx;\\n      return stoi(s.substr(p, idx-p));\\n    }\\n    int nextDepth(string& s) {\\n      int p = idx;\\n      while (idx<N && s[idx]==\\'-\\')\\n        ++idx;\\n      return idx-p;\\n    }\\n  public:\\n    TreeNode* recoverFromPreorder(string S) {\\n      idx = 0;\\n      N = S.size();\\n      int val = nextInt(S), depth;\\n      TreeNode* root = new TreeNode(val);\\n      // vector<TreeNode*> memo(1000);\\n      // memo[0] = root;\\n      stack<TreeNode*> s;\\n      s.push(root);\\n      while (idx<N) {\\n        depth = nextDepth(S);\\n        val = nextInt(S);\\n        // memo[depth] = new TreeNode(val);\\n        // if (memo[depth-1]->left)\\n        //   memo[depth-1]->right = memo[depth];\\n        // else\\n        //   memo[depth-1]->left = memo[depth];\\n        TreeNode* node = new TreeNode(val);\\n        while (s.size()>depth)\\n          s.pop();\\n        if (s.top()->left)\\n          s.top()->right = node;\\n        else\\n          s.top()->left = node;\\n        s.push(node);\\n      }\\n      return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  private:\\n    int idx, N;\\n    int nextInt(string& s) {\\n      int p = idx;\\n      while (idx<N && s[idx]!=\\'-\\')\\n        ++idx;\\n      return stoi(s.substr(p, idx-p));\\n    }\\n    int nextDepth(string& s) {\\n      int p = idx;\\n      while (idx<N && s[idx]==\\'-\\')\\n        ++idx;\\n      return idx-p;\\n    }\\n  public:\\n    TreeNode* recoverFromPreorder(string S) {\\n      idx = 0;\\n      N = S.size();\\n      int val = nextInt(S), depth;\\n      TreeNode* root = new TreeNode(val);\\n      // vector<TreeNode*> memo(1000);\\n      // memo[0] = root;\\n      stack<TreeNode*> s;\\n      s.push(root);\\n      while (idx<N) {\\n        depth = nextDepth(S);\\n        val = nextInt(S);\\n        // memo[depth] = new TreeNode(val);\\n        // if (memo[depth-1]->left)\\n        //   memo[depth-1]->right = memo[depth];\\n        // else\\n        //   memo[depth-1]->left = memo[depth];\\n        TreeNode* node = new TreeNode(val);\\n        while (s.size()>depth)\\n          s.pop();\\n        if (s.top()->left)\\n          s.top()->right = node;\\n        else\\n          s.top()->left = node;\\n        s.push(node);\\n      }\\n      return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669647,
                "title": "c-iterative-solution-using-map-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* newNode(int val)\\n    {\\n        TreeNode* node = new TreeNode(val);\\n        return node;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string str) {\\n        map<int , vector<TreeNode*>> freq;\\n        \\n        int len = str.length();\\n        \\n        if( len == 0)\\n            return NULL;\\n        \\n        string t = \"\";\\n        int i =0;\\n        while(i<len && str[i] != \\'-\\')\\n        {\\n            t+=str[i];\\n            i++;\\n        }\\n        TreeNode* root = newNode(stoi(t));\\n        freq[0].push_back(root);\\n        int count = 0;\\n        for( ;i<len ;i++)\\n        {\\n            int c = 0;\\n            while( i < len && str[i] == \\'-\\')\\n            {\\n                c++;\\n                i++;\\n            }\\n            if( i == len)\\n                break;\\n            \\n            string t = \"\";\\n            while( i< len && str[i] != \\'-\\')\\n            {\\n                t+=str[i];\\n                i++;\\n            }  \\n            i--;\\n            TreeNode* temp = newNode(stoi(t));\\n            freq[c].push_back(temp);\\n            if( freq.count(c-1))\\n            {               \\n                TreeNode* temp2 = freq[c-1].back();\\n                freq[c-1].pop_back();\\n                if( temp2->left == NULL)\\n                    temp2->left = temp;\\n                else\\n                    temp2->right = temp;\\n                freq[c-1].push_back(temp2);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* newNode(int val)\\n    {\\n        TreeNode* node = new TreeNode(val);\\n        return node;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string str) {\\n        map<int , vector<TreeNode*>> freq;\\n        \\n        int len = str.length();\\n        \\n        if( len == 0)\\n            return NULL;\\n        \\n        string t = \"\";\\n        int i =0;\\n        while(i<len && str[i] != \\'-\\')\\n        {\\n            t+=str[i];\\n            i++;\\n        }\\n        TreeNode* root = newNode(stoi(t));\\n        freq[0].push_back(root);\\n        int count = 0;\\n        for( ;i<len ;i++)\\n        {\\n            int c = 0;\\n            while( i < len && str[i] == \\'-\\')\\n            {\\n                c++;\\n                i++;\\n            }\\n            if( i == len)\\n                break;\\n            \\n            string t = \"\";\\n            while( i< len && str[i] != \\'-\\')\\n            {\\n                t+=str[i];\\n                i++;\\n            }  \\n            i--;\\n            TreeNode* temp = newNode(stoi(t));\\n            freq[c].push_back(temp);\\n            if( freq.count(c-1))\\n            {               \\n                TreeNode* temp2 = freq[c-1].back();\\n                freq[c-1].pop_back();\\n                if( temp2->left == NULL)\\n                    temp2->left = temp;\\n                else\\n                    temp2->right = temp;\\n                freq[c-1].push_back(temp2);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668537,
                "title": "c-recursion",
                "content": "\\'\\'\\'\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nstruct TreeNode* help(char **str, int prev, int *count) {\\n    \\n    int curr=0;\\n    int val=0;\\n    int update=0;\\n    \\n    struct TreeNode *temp;\\n    \\n    if(**str == \\'\\\\0\\')\\n        return NULL;\\n\\n    \\n    temp = malloc(sizeof(struct TreeNode));\\n    while(**str != \\'-\\' && **str != \\'\\\\0\\') {\\n        val = val*10;\\n        val += **str-\\'0\\';\\n        printf(\"val=%d\\\\n\",val);\\n        (*str)++;\\n    }\\n    temp->val = val;\\n    temp->left = NULL;\\n    temp->right = NULL;\\n    \\n    if(**str == \\'\\\\0\\')\\n        return temp;\\n    \\n    while(**str == \\'-\\') {\\n        (*str)++;\\n        curr++;\\n    }\\n    \\n    if(curr <= prev) {\\n    *count = curr;\\n    return temp;\\n    }\\n    \\n    //left child\\n    if(curr == prev+1)\\n        temp->left = help(str,curr,count);\\n    \\n    if(*count == prev+1)\\n        temp->right = help(str,curr,count);\\n    \\n    return temp;\\n}\\n\\nstruct TreeNode* recoverFromPreorder(char * S){\\n\\n    int prev = 0;\\n    int count = 0;\\n    int len = strlen(S);\\n    if(len == 0)\\n        return NULL;\\n    \\n    return help(&S,prev,&count);\\n    \\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nstruct TreeNode* help(char **str, int prev, int *count) {\\n    \\n    int curr=0;\\n    int val=0;\\n    int update=0;\\n    \\n    struct TreeNode *temp;\\n    \\n    if(**str == \\'\\\\0\\')\\n        return NULL;\\n\\n    \\n    temp = malloc(sizeof(struct TreeNode));\\n    while(**str != \\'-\\' && **str != \\'\\\\0\\') {\\n        val = val*10;\\n        val += **str-\\'0\\';\\n        printf(\"val=%d\\\\n\",val);\\n        (*str)++;\\n    }\\n    temp->val = val;\\n    temp->left = NULL;\\n    temp->right = NULL;\\n    \\n    if(**str == \\'\\\\0\\')\\n        return temp;\\n    \\n    while(**str == \\'-\\') {\\n        (*str)++;\\n        curr++;\\n    }\\n    \\n    if(curr <= prev) {\\n    *count = curr;\\n    return temp;\\n    }\\n    \\n    //left child\\n    if(curr == prev+1)\\n        temp->left = help(str,curr,count);\\n    \\n    if(*count == prev+1)\\n        temp->right = help(str,curr,count);\\n    \\n    return temp;\\n}\\n\\nstruct TreeNode* recoverFromPreorder(char * S){\\n\\n    int prev = 0;\\n    int count = 0;\\n    int len = strlen(S);\\n    if(len == 0)\\n        return NULL;\\n    \\n    return help(&S,prev,&count);\\n    \\n}\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 665137,
                "title": "c-dfs-easy",
                "content": "```\\n\\nclass Solution {\\n    \\n    string s; // copy of string\\n    int N;\\n    int i; // to iterate string\\n    \\n    // Calculate Depth based on number of \\'-\\'\\n    inline int calcdepth () {\\n        int d=0;\\n        while (s[i]==\\'-\\') {\\n            i++;\\n            d++;\\n        }\\n        return d;\\n    }\\n    \\n    // Calculate Val till we hit next \\'-\\'\\n    inline int get_val () {\\n        int n=0;\\n        while ((i<N) && (s[i]!=\\'-\\')) {\\n            n = n*10 + (int)s[i] - (int) \\'0\\';\\n            i++;\\n        }\\n        return n;\\n    }\\n    \\n    // Create node for current call.\\n    // check for left and right children if any\\n    TreeNode* dfs_depth (int depth)\\n    {\\n        if (i>=N) return NULL;\\n        TreeNode * node = new TreeNode (get_val());\\n\\t\\t\\n        // x==0 -> Left node\\n        // x==1 -> Right node\\n        for (int x=0; x<2; x++) { \\n            if (i<N) {\\n                int ibuff = i; // Buffering i for later use if d is not greater than depth \\n\\t\\t\\t\\t               // is important to maintain integrity of tree.\\n                int d = calcdepth();\\n                if (d>depth) {\\n                    if (x==0) node->left = dfs_depth(d);  // x==0\\n                    else node->right = dfs_depth(d);      // x==1\\n                } else {\\n                    i = ibuff;\\n                }\\n            }            \\n        }\\n        return node;\\n    }\\n    \\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        s=S;\\n        N = s.size();\\n        i = 0;\\n        return dfs_depth(0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    \\n    string s; // copy of string\\n    int N;\\n    int i; // to iterate string\\n    \\n    // Calculate Depth based on number of \\'-\\'\\n    inline int calcdepth () {\\n        int d=0;\\n        while (s[i]==\\'-\\') {\\n            i++;\\n            d++;\\n        }\\n        return d;\\n    }\\n    \\n    // Calculate Val till we hit next \\'-\\'\\n    inline int get_val () {\\n        int n=0;\\n        while ((i<N) && (s[i]!=\\'-\\')) {\\n            n = n*10 + (int)s[i] - (int) \\'0\\';\\n            i++;\\n        }\\n        return n;\\n    }\\n    \\n    // Create node for current call.\\n    // check for left and right children if any\\n    TreeNode* dfs_depth (int depth)\\n    {\\n        if (i>=N) return NULL;\\n        TreeNode * node = new TreeNode (get_val());\\n\\t\\t\\n        // x==0 -> Left node\\n        // x==1 -> Right node\\n        for (int x=0; x<2; x++) { \\n            if (i<N) {\\n                int ibuff = i; // Buffering i for later use if d is not greater than depth \\n\\t\\t\\t\\t               // is important to maintain integrity of tree.\\n                int d = calcdepth();\\n                if (d>depth) {\\n                    if (x==0) node->left = dfs_depth(d);  // x==0\\n                    else node->right = dfs_depth(d);      // x==1\\n                } else {\\n                    i = ibuff;\\n                }\\n            }            \\n        }\\n        return node;\\n    }\\n    \\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        s=S;\\n        N = s.size();\\n        i = 0;\\n        return dfs_depth(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649402,
                "title": "java-2ms-faster-than-94-12",
                "content": "\\nclass Solution {\\n\\n    public TreeNode recoverFromPreorder(String S) {\\n        if (S.length() == 0) {\\n            return null;\\n        }\\n        int params[] = new int[2]; // params[0] to store current index of string and params[1] to store count of dashes.\\n        return formTree(S, params, 0);\\n    }\\n\\t\\n    static TreeNode formTree(String str, int params[], int level) {\\n        if (params[0] > str.length()) {\\n            return null;\\n        }\\n        TreeNode node = null;\\n        if (params[1] == level) {\\n            int num = getCurrentNodeValue(str, params);\\n            node = new TreeNode(num);\\n            params[1] = countDashes(str, params[0]);\\n            params[0] = params[0] + params[1];\\n            node.left = formTree(str, params, level+1);\\n            node.right = formTree(str, params, level+1);\\n        }\\n        return node;\\n    \\n    }\\n    \\n    static int getCurrentNodeValue(String str, int params[]) {\\n        int num = 0;\\n        while (params[0] < str.length()) {\\n            if (str.charAt(params[0]) < 58 && str.charAt(params[0]) > 47) {\\n                num = num * 10 + (str.charAt(params[0]) - 48);\\n                params[0]++;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return num;\\n    }\\n    \\n    static int countDashes(String str, int index) {\\n        int count = 0;\\n        if (index > str.length()) {\\n            return count;\\n        }\\n        count++;\\n        while (index < str.length() - 1) {\\n            if (str.charAt(index) == str.charAt(index+1) && str.charAt(index) == \\'-\\') {\\n                count++;\\n                index++;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public TreeNode recoverFromPreorder(String S) {\\n        if (S.length() == 0) {\\n            return null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 630854,
                "title": "java-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        \\n        Stack<TreeNode> s= new Stack<>();\\n\\n        for(int i =0; i<S.length(); ){\\n            int level=0;\\n            while(S.charAt(i)==\\'-\\'){\\n                level++;\\n                i++;\\n            }\\n            int num=0;\\n            while(i<S.length() && S.charAt(i)!=\\'-\\'){\\n                char c= S.charAt(i);\\n                num =(num*10)+ Character.getNumericValue(c);\\n                i++;\\n                \\n            }\\n\\n           while(s.size()>level){\\n               s.pop();\\n           }\\n            TreeNode n= new TreeNode(num);\\n            if(!s.empty()){\\n                TreeNode curNode= s.peek();\\n                if(s.peek().left== null){\\n                    s.peek().left= n;\\n                }else{\\n                    s.peek().right=n;\\n                }\\n            }\\n            \\n            s.push(n);\\n        }\\n        \\n        while(s.size()>1){\\n            s.pop();\\n        }\\n        \\n        return s.pop();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        \\n        Stack<TreeNode> s= new Stack<>();\\n\\n        for(int i =0; i<S.length(); ){\\n            int level=0;\\n            while(S.charAt(i)==\\'-\\'){\\n                level++;\\n                i++;\\n            }\\n            int num=0;\\n            while(i<S.length() && S.charAt(i)!=\\'-\\'){\\n                char c= S.charAt(i);\\n                num =(num*10)+ Character.getNumericValue(c);\\n                i++;\\n                \\n            }\\n\\n           while(s.size()>level){\\n               s.pop();\\n           }\\n            TreeNode n= new TreeNode(num);\\n            if(!s.empty()){\\n                TreeNode curNode= s.peek();\\n                if(s.peek().left== null){\\n                    s.peek().left= n;\\n                }else{\\n                    s.peek().right=n;\\n                }\\n            }\\n            \\n            s.push(n);\\n        }\\n        \\n        while(s.size()>1){\\n            s.pop();\\n        }\\n        \\n        return s.pop();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597610,
                "title": "java-easy-understand-recursive-using-regex",
                "content": "As we know the number of dash represents the level of the tree. For example \"1-2--3--4-5--6--7\"\\nStep1. Spilt by exactly \"-\", we can get \"1\", \"2--3--4\", \"5--6--7\". \"1\" is the root, \"2--3--4\" is the left child, \"5--6--7\" is the right child.\\nStep2. Spilt \"2--3--4\" by exactly \"--\"\\uFF0C we can get \"2\", \"3\", \"4\", \"2\" is the root, \"3\" is the left child, \"4\" is the right child. So this part is resolved.\\nStep3. Do the same sa Step2 for \"5--6--7\"\\n```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        return recover(S, 1);\\n    }\\n\\n    TreeNode recover(String s, int level) {\\n        //there is no \"-\", then it\\'s a leaf node\\n        if (!s.contains(\"-\")) {\\n            return new TreeNode(Integer.parseInt(s));\\n        }\\n        //spilt s by the level, lv1 is \"-\", lv2 is \"--\" and so on, we must ensure there is no \"-\" before or after\\n        String part[] = s.split(\"(?<!-)-{\" + level+ \"}(?!-)\");\\n        //parse the node\\n        TreeNode node = new TreeNode(Integer.parseInt(part[0]));\\n        //parse the left child\\n        node.left = recover(part[1], level + 1);\\n        //parse the right if there is a right\\n        if (part.length == 3) {\\n            node.right = recover(part[2], level + 1);\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        return recover(S, 1);\\n    }\\n\\n    TreeNode recover(String s, int level) {\\n        //there is no \"-\", then it\\'s a leaf node\\n        if (!s.contains(\"-\")) {\\n            return new TreeNode(Integer.parseInt(s));\\n        }\\n        //spilt s by the level, lv1 is \"-\", lv2 is \"--\" and so on, we must ensure there is no \"-\" before or after\\n        String part[] = s.split(\"(?<!-)-{\" + level+ \"}(?!-)\");\\n        //parse the node\\n        TreeNode node = new TreeNode(Integer.parseInt(part[0]));\\n        //parse the left child\\n        node.left = recover(part[1], level + 1);\\n        //parse the right if there is a right\\n        if (part.length == 3) {\\n            node.right = recover(part[2], level + 1);\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573530,
                "title": "simple-c-recursive",
                "content": "```\\nTreeNode* recoverFromPreorder_(string S, int level, int& idx, int& nextLevel) {\\n\\n\\tif (idx >= S.length()) return nullptr;\\n\\n\\tint val = 0;\\n\\tfor (; idx < S.length() && S[idx] <= \\'9\\' && S[idx] >= \\'0\\'; ++idx) val = val * 10 + (S[idx] - \\'0\\');\\n\\n\\tTreeNode* newNode = new TreeNode(val);\\n\\n\\tint nextDepth = 0;\\n\\tfor (; idx < S.length() && S[idx] == \\'-\\'; ++idx) ++nextDepth;\\n\\tnextLevel = nextDepth;\\n\\n\\tif (nextDepth > level) newNode->leftLeaf = recoverFromPreorder_(S, level + 1, idx, nextLevel);\\n\\telse return newNode;\\n\\n\\tif (nextLevel > level) newNode->rightLeaf = recoverFromPreorder_(S, level + 1, idx, nextLevel);\\n\\n\\treturn newNode;\\n}\\n\\nTreeNode* recoverFromPreorder(string S) {\\n\\tint idx = 0, nextLevel = 0;\\n\\treturn recoverFromPreorder_(S, 0, idx, nextLevel);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* recoverFromPreorder_(string S, int level, int& idx, int& nextLevel) {\\n\\n\\tif (idx >= S.length()) return nullptr;\\n\\n\\tint val = 0;\\n\\tfor (; idx < S.length() && S[idx] <= \\'9\\' && S[idx] >= \\'0\\'; ++idx) val = val * 10 + (S[idx] - \\'0\\');\\n\\n\\tTreeNode* newNode = new TreeNode(val);\\n\\n\\tint nextDepth = 0;\\n\\tfor (; idx < S.length() && S[idx] == \\'-\\'; ++idx) ++nextDepth;\\n\\tnextLevel = nextDepth;\\n\\n\\tif (nextDepth > level) newNode->leftLeaf = recoverFromPreorder_(S, level + 1, idx, nextLevel);\\n\\telse return newNode;\\n\\n\\tif (nextLevel > level) newNode->rightLeaf = recoverFromPreorder_(S, level + 1, idx, nextLevel);\\n\\n\\treturn newNode;\\n}\\n\\nTreeNode* recoverFromPreorder(string S) {\\n\\tint idx = 0, nextLevel = 0;\\n\\treturn recoverFromPreorder_(S, 0, idx, nextLevel);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 556087,
                "title": "c-unordered-map-76-speed-21-memory",
                "content": "Use an unordered_map to keep track of the incomplete node in the level immediately above the current level as we iterate through the string S. Since it is a preorder traversal, we will never have more than one node in the map at the same level that is incomplete (i.e. no conflicts).\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        unordered_map<int, TreeNode *> LevelNode;                 //level, node\\n        int lvl = 0;                                              //running level counter\\n        for (int i = 0; i < S.size(); i++) {\\n            if (S[i] != \\'-\\') {                                      //parse dashes to get level\\n                string num = \"\";\\n                while (i < S.size() && isdigit(S[i])) {\\n                    num += S[i];                              //get number as a string\\n                    i++;\\n                }\\n                int val = stoi(num);                                //get number as integer\\n                LevelNode[lvl] = new TreeNode(val);                 //add the node to the map indexed by level\\n                if (lvl > 0){                                       //if there is a higher node, set the current node as left or right\\n                    if (LevelNode[lvl - 1]->left) LevelNode[lvl - 1]->right = LevelNode[lvl];       \\n                    else LevelNode[lvl - 1]->left = LevelNode[lvl];\\n                }\\n                lvl = 0;                           //reset level counter\\n                i--;                               //set i position for next iteration--this counteracts the i++ at the end of the iteration\\n            }\\n            else {\\n               lvl++;\\n            }\\n        }\\n        return LevelNode[0];                                       //return the root\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        unordered_map<int, TreeNode *> LevelNode;                 //level, node\\n        int lvl = 0;                                              //running level counter\\n        for (int i = 0; i < S.size(); i++) {\\n            if (S[i] != \\'-\\') {                                      //parse dashes to get level\\n                string num = \"\";\\n                while (i < S.size() && isdigit(S[i])) {\\n                    num += S[i];                              //get number as a string\\n                    i++;\\n                }\\n                int val = stoi(num);                                //get number as integer\\n                LevelNode[lvl] = new TreeNode(val);                 //add the node to the map indexed by level\\n                if (lvl > 0){                                       //if there is a higher node, set the current node as left or right\\n                    if (LevelNode[lvl - 1]->left) LevelNode[lvl - 1]->right = LevelNode[lvl];       \\n                    else LevelNode[lvl - 1]->left = LevelNode[lvl];\\n                }\\n                lvl = 0;                           //reset level counter\\n                i--;                               //set i position for next iteration--this counteracts the i++ at the end of the iteration\\n            }\\n            else {\\n               lvl++;\\n            }\\n        }\\n        return LevelNode[0];                                       //return the root\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506748,
                "title": "modern-c-solution-with-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        if (S.empty()) return nullptr;\\n        auto pos = 0;\\n        return decode(S, pos, 0);\\n    }\\n    \\nprivate:\\n    TreeNode *decode(const std::string &s, int &pos, int dashCount) {\\n        if (pos >= s.size()) return nullptr;\\n        auto curPos = pos;\\n        while (curPos < s.size() && s[curPos] == \\'-\\') ++curPos;\\n        if (curPos - pos != dashCount) return nullptr;\\n        int val = 0;\\n        for(; curPos < s.size() && s[curPos] != \\'-\\'; ++curPos)\\n            val = val * 10 + s[curPos] - \\'0\\';\\n        auto node = new TreeNode(val);\\n        pos = curPos;\\n        node->left = decode(s, pos, dashCount + 1);\\n        node->right = decode(s, pos, dashCount + 1);\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        if (S.empty()) return nullptr;\\n        auto pos = 0;\\n        return decode(S, pos, 0);\\n    }\\n    \\nprivate:\\n    TreeNode *decode(const std::string &s, int &pos, int dashCount) {\\n        if (pos >= s.size()) return nullptr;\\n        auto curPos = pos;\\n        while (curPos < s.size() && s[curPos] == \\'-\\') ++curPos;\\n        if (curPos - pos != dashCount) return nullptr;\\n        int val = 0;\\n        for(; curPos < s.size() && s[curPos] != \\'-\\'; ++curPos)\\n            val = val * 10 + s[curPos] - \\'0\\';\\n        auto node = new TreeNode(val);\\n        pos = curPos;\\n        node->left = decode(s, pos, dashCount + 1);\\n        node->right = decode(s, pos, dashCount + 1);\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425178,
                "title": "java-recursive-dfs-with-queue",
                "content": "Use the similar idea with https://leetcode.com/problems/serialize-and-deserialize-binary-tree/ \\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        if (S == null || S.length() == 0) return null;\\n        \\n        Deque<int[]> q = preprocess(S);\\n        \\n        return buildTreeWithDfs(q, 0);\\n    }\\n    \\n    private TreeNode buildTreeWithDfs(Deque<int[]> q, int curDepth) {\\n        if (q.isEmpty() || q.peek()[1] != curDepth) return null;\\n        \\n        TreeNode curNode = new TreeNode(q.poll()[0]);\\n        curNode.left = buildTreeWithDfs(q, curDepth + 1);\\n        curNode.right = buildTreeWithDfs(q, curDepth + 1);\\n        \\n        return curNode;\\n    }\\n    \\n    private Deque<int[]> preprocess(String s) {\\n        Deque<int[]> q = new ArrayDeque<>();\\n        \\n        int preNum = 0, depth = 0, i = 0;\\n        boolean sawDigit = false;\\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            if (c >= \\'0\\' && c <= \\'9\\') {\\n                preNum = preNum * 10 + (c - \\'0\\');\\n                sawDigit = true;\\n            } else if (c == \\'-\\') {\\n                if (sawDigit) {\\n                    q.offer(new int[]{preNum, depth});\\n                    \\n                    // reset\\n                    preNum = 0;\\n                    depth = 0;\\n                    sawDigit = false;\\n                } \\n                depth++;\\n            }\\n            i++;\\n        }\\n        \\n        if (sawDigit) q.offer(new int[]{preNum, depth});\\n        \\n        return q;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        if (S == null || S.length() == 0) return null;\\n        \\n        Deque<int[]> q = preprocess(S);\\n        \\n        return buildTreeWithDfs(q, 0);\\n    }\\n    \\n    private TreeNode buildTreeWithDfs(Deque<int[]> q, int curDepth) {\\n        if (q.isEmpty() || q.peek()[1] != curDepth) return null;\\n        \\n        TreeNode curNode = new TreeNode(q.poll()[0]);\\n        curNode.left = buildTreeWithDfs(q, curDepth + 1);\\n        curNode.right = buildTreeWithDfs(q, curDepth + 1);\\n        \\n        return curNode;\\n    }\\n    \\n    private Deque<int[]> preprocess(String s) {\\n        Deque<int[]> q = new ArrayDeque<>();\\n        \\n        int preNum = 0, depth = 0, i = 0;\\n        boolean sawDigit = false;\\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            if (c >= \\'0\\' && c <= \\'9\\') {\\n                preNum = preNum * 10 + (c - \\'0\\');\\n                sawDigit = true;\\n            } else if (c == \\'-\\') {\\n                if (sawDigit) {\\n                    q.offer(new int[]{preNum, depth});\\n                    \\n                    // reset\\n                    preNum = 0;\\n                    depth = 0;\\n                    sawDigit = false;\\n                } \\n                depth++;\\n            }\\n            i++;\\n        }\\n        \\n        if (sawDigit) q.offer(new int[]{preNum, depth});\\n        \\n        return q;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420243,
                "title": "python3-with-regex-beats-99-50",
                "content": "Just code this by intuition:\\n```\\nimport re\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        dash_map = {}\\n        dash_cnt = 0\\n        first_num = \"\"\\n        for ch in S:\\n            if ch == \\'-\\': break\\n            first_num += ch\\n        dash_map[0] = TreeNode(int(first_num))\\n        s = re.findall(r\\'(-+)(\\\\d+)\\', S)\\n        for dash, num in s:\\n            dash_num = len(dash)\\n            num = int(num)\\n            n = TreeNode(num)\\n            fa = dash_map[dash_num - 1]\\n            if not fa.left:\\n                fa.left = n\\n            elif not fa.right:\\n                fa.right = n\\n            dash_map[dash_num] = n\\n        return dash_map[0]\\n```\\nRegex is useful in formatting the string.",
                "solutionTags": [],
                "code": "```\\nimport re\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        dash_map = {}\\n        dash_cnt = 0\\n        first_num = \"\"\\n        for ch in S:\\n            if ch == \\'-\\': break\\n            first_num += ch\\n        dash_map[0] = TreeNode(int(first_num))\\n        s = re.findall(r\\'(-+)(\\\\d+)\\', S)\\n        for dash, num in s:\\n            dash_num = len(dash)\\n            num = int(num)\\n            n = TreeNode(num)\\n            fa = dash_map[dash_num - 1]\\n            if not fa.left:\\n                fa.left = n\\n            elif not fa.right:\\n                fa.right = n\\n            dash_map[dash_num] = n\\n        return dash_map[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405663,
                "title": "single-traversal-using-a-stack-python-3",
                "content": "**Idea:**\\n\\n1. Keep traversing the string till you see a single integer, keep counting the number of dashes while you do this.\\n2. Once you have found an integer now start traversing the string till you see a dash. This is useful to read non single digit numbers.\\n3. Once you have encountered a dash after seeing 1 or more integers, it means you have an integer ready to be inserted into your tree. \\n4. Check if root is null and then assign this new int to your root.\\n5. If root is not null:\\n\\t1. Take a stack and initialise it with the root, level of the root and keep repeating the steps below till the stack is empty.\\n\\t\\t1. Pop an element out of the stack.\\n\\t\\t2. if the level of the element popped out of the stack is 1 less than the level of the element to be inserted. Check if the current element has free left and insert or check if the current element has free right and then insert.\\n\\t\\t3. if the level of the element popped is less than the level of the element to be inserted, insert the right child, cur_level+1 and left child, cur_level+1 into the stack if they are not null.\\n\\n**Code**\\n*Note: Uncomment the print statements to better understand what is happening while you run the code.*\\n```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str, levels=None) -> TreeNode:\\n        root = None\\n        n = len(S)\\n        foo = \\'\\'\\n        i = 0\\n        new_level = 0\\n        while i < n:\\n            if S[i] == \\'-\\':\\n                i += 1\\n                new_level += 1\\n                continue\\n            while i < n and S[i] != \\'-\\':\\n                foo += S[i]\\n                i += 1\\n\\n            temp = TreeNode(int(foo))\\n            temp.left = None\\n            temp.right = None\\n            foo = \\'\\'\\n\\n            # print(\"@@@@@@@@@@@@   {}   @@@@@@@@@@@@\".format(temp.val))\\n            if not root:\\n                root = temp\\n            else:\\n                stack = [(root, 0)]\\n                while stack:\\n                    cur = stack.pop()\\n                    cur_level = cur[1]\\n                    cur_node = cur[0]\\n                    # print(cur_level, new_level)\\n                    if cur_level == new_level - 1:\\n                        # print(\"In with {} for {}\".format(cur_node.val, temp.val))\\n                        if not cur_node.left:\\n                            cur_node.left = temp\\n                            break\\n                        elif not cur_node.right:\\n                            cur_node.right = temp\\n                            break\\n                    else:\\n                        # print(\"cur {} temp {}\".format(cur_node.val, temp.val))\\n                        if cur_node.right and cur_level < new_level:\\n                            # print(\"Adding \", cur_node.right.val)\\n                            stack.append((cur_node.right, cur_level+1))\\n                        if (not cur_node.right) and cur_node.left and cur_level < new_level:\\n                            # print(\"Adding \", cur_node.left.val)\\n                            stack.append((cur_node.left, cur_level+1))\\n            new_level = 0\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str, levels=None) -> TreeNode:\\n        root = None\\n        n = len(S)\\n        foo = \\'\\'\\n        i = 0\\n        new_level = 0\\n        while i < n:\\n            if S[i] == \\'-\\':\\n                i += 1\\n                new_level += 1\\n                continue\\n            while i < n and S[i] != \\'-\\':\\n                foo += S[i]\\n                i += 1\\n\\n            temp = TreeNode(int(foo))\\n            temp.left = None\\n            temp.right = None\\n            foo = \\'\\'\\n\\n            # print(\"@@@@@@@@@@@@   {}   @@@@@@@@@@@@\".format(temp.val))\\n            if not root:\\n                root = temp\\n            else:\\n                stack = [(root, 0)]\\n                while stack:\\n                    cur = stack.pop()\\n                    cur_level = cur[1]\\n                    cur_node = cur[0]\\n                    # print(cur_level, new_level)\\n                    if cur_level == new_level - 1:\\n                        # print(\"In with {} for {}\".format(cur_node.val, temp.val))\\n                        if not cur_node.left:\\n                            cur_node.left = temp\\n                            break\\n                        elif not cur_node.right:\\n                            cur_node.right = temp\\n                            break\\n                    else:\\n                        # print(\"cur {} temp {}\".format(cur_node.val, temp.val))\\n                        if cur_node.right and cur_level < new_level:\\n                            # print(\"Adding \", cur_node.right.val)\\n                            stack.append((cur_node.right, cur_level+1))\\n                        if (not cur_node.right) and cur_node.left and cur_level < new_level:\\n                            # print(\"Adding \", cur_node.left.val)\\n                            stack.append((cur_node.left, cur_level+1))\\n            new_level = 0\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 390991,
                "title": "python-dictionary-solution",
                "content": "```\\nclass Solution:\\n    def recoverFromPreorder(self, s: str) -> TreeNode:\\n        i = 0\\n        while i < len(s) and s[i] != \"-\":\\n            i += 1\\n        root = TreeNode(int(s[:i]))\\n        memo, state = {}, {}\\n        memo[0], state[0] = root, 0\\n        while i < len(s):\\n            anchor = i\\n            while i < len(s) and s[i] == \"-\":\\n                i += 1\\n            l = i - anchor\\n            anchor = i\\n            while i < len(s) and s[i] != \"-\":\\n                i += 1\\n            val = int(s[anchor:i])\\n            if state[l - 1] == 0:\\n                memo[l - 1].left = TreeNode(val)\\n                memo[l] = memo[l - 1].left\\n            else:\\n                memo[l - 1].right = TreeNode(val)\\n                memo[l] = memo[l - 1].right\\n            state[l - 1] ^= 1\\n            state[l] = 0\\n        return root",
                "solutionTags": [],
                "code": "class Solution:\\n    def recoverFromPreorder(self, s: str) -> TreeNode:\\n        i = 0\\n        while i < len(s) and s[i] != \"-\":\\n            i += 1\\n        root = TreeNode(int(s[:i]))\\n        memo, state = {}",
                "codeTag": "Java"
            },
            {
                "id": 325057,
                "title": "python-recursive-solution-easy-to-understand",
                "content": "We firstly transform the input array to a node list. There is no doubt that the first node in that list is the root. If the level of the second node is 1 (actually, it must be), it is the left child of the root (guaranteed by problem description). If the level of the third node is 2, it must be the left child of `root.left`, but not the right child of root, since `root.left.left` is the only correct \\'position\\' that the current tree could expand to and has a level of 2.\\n\\n```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        # recover by pre-order\\n        # parse nodes\\' info\\n        flag, i = 0, 0\\n        info = []\\n        while i < len(S):\\n            # collecting dashes\\n            dashes = 0\\n            while S[i] == \\'-\\':\\n                dashes, i = dashes + 1, i + 1\\n            # collecting digits\\n            digits = \\'\\'\\n            while S[i] != \\'-\\':\\n                digits, i = digits + S[i], i + 1\\n            info.append((dashes, digits))\\n\\n        self.has_built = 0      # has built x nodes\\n\\n        def preorder(depth):\\n            if self.has_built >= len(info) or info[self.has_built][0] != depth:\\n                return None\\n            node = TreeNode(info[self.has_built][1])\\n            self.has_built += 1\\n            node.left = preorder(depth+1)\\n            node.right = preorder(depth+1)\\n            return node\\n\\n        return preorder(0)\\n```\\nMaybe you want to ask: why could you guarantee that the node `info[self.has_built]` is the at the place we are visiting given that `info[self.has_built][0] == depth`? It is hard for me to explain it well, but you can image how we traverse a tree in pre-order. Let our node `info[self.has_built]` be `visit_node`, and its level be `L`. Suppose `visit_node` is a child of another node of level `L-1`,  not at the current visiting place (let\\'s denote it with a virtual node `curr_node`). `visit_node` and `curr_node` are on the same level. Then `visit_node` could not be left to `curr_node`, because `visit_node` should be visited before the parent of `curr_node`. Also, `visit_node` could not be right to `curr_node`, because the parent of `visit_node` hasn\\'t been visited. In summary, `visit_node` is equal to `curr_node`.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        # recover by pre-order\\n        # parse nodes\\' info\\n        flag, i = 0, 0\\n        info = []\\n        while i < len(S):\\n            # collecting dashes\\n            dashes = 0\\n            while S[i] == \\'-\\':\\n                dashes, i = dashes + 1, i + 1\\n            # collecting digits\\n            digits = \\'\\'\\n            while S[i] != \\'-\\':\\n                digits, i = digits + S[i], i + 1\\n            info.append((dashes, digits))\\n\\n        self.has_built = 0      # has built x nodes\\n\\n        def preorder(depth):\\n            if self.has_built >= len(info) or info[self.has_built][0] != depth:\\n                return None\\n            node = TreeNode(info[self.has_built][1])\\n            self.has_built += 1\\n            node.left = preorder(depth+1)\\n            node.right = preorder(depth+1)\\n            return node\\n\\n        return preorder(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313731,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        return helper(S,0);\\n    }\\nprivate:\\n    TreeNode* helper(string S, int level) {\\n        if(S.empty())   return NULL;\\n        else    {\\n            S=S.substr(level);  // remove the level count of prefix \\'-\\'\\n            int val=0,k=0;\\n            while(isdigit(S[k]))\\n                val=10*val+S[k++]-\\'0\\';\\n            TreeNode* root=new TreeNode(val);\\n            S=S.substr(k);      // remove k digits\\n            if(!S.empty())  {\\n                int j=S.length()-1-level-1;\\n                string s(level+1,\\'-\\');\\n                while(j>0)  {\\n                    if(isdigit(S[j+level+1]) && S.substr(j,level+1)==s && isdigit(S[j-1]))\\n                        break;  // j is the start location of the right subtree\\n                    else\\n                        --j;\\n                }\\n                if(0==j)\\n                    root->left=helper(S,level+1);\\n                else    {\\n                    root->left=helper(S.substr(0,j),level+1);\\n                    root->right=helper(S.substr(j),level+1);\\n                }\\n            }\\n            return root;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        return helper(S,0);\\n    }\\nprivate:\\n    TreeNode* helper(string S, int level) {\\n        if(S.empty())   return NULL;\\n        else    {\\n            S=S.substr(level);  // remove the level count of prefix \\'-\\'\\n            int val=0,k=0;\\n            while(isdigit(S[k]))\\n                val=10*val+S[k++]-\\'0\\';\\n            TreeNode* root=new TreeNode(val);\\n            S=S.substr(k);      // remove k digits\\n            if(!S.empty())  {\\n                int j=S.length()-1-level-1;\\n                string s(level+1,\\'-\\');\\n                while(j>0)  {\\n                    if(isdigit(S[j+level+1]) && S.substr(j,level+1)==s && isdigit(S[j-1]))\\n                        break;  // j is the start location of the right subtree\\n                    else\\n                        --j;\\n                }\\n                if(0==j)\\n                    root->left=helper(S,level+1);\\n                else    {\\n                    root->left=helper(S.substr(0,j),level+1);\\n                    root->right=helper(S.substr(j),level+1);\\n                }\\n            }\\n            return root;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293181,
                "title": "golang-hashmap-solution-very-simple",
                "content": "```golang\\nfunc recoverFromPreorder(S string) *TreeNode {\\n    sLen := len(S)\\n\\tif sLen <= 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tvar root *TreeNode\\n\\n\\tidxLevelMap := make(map[int]*TreeNode)\\n\\n\\ti := 0\\n\\tnumStart := 0\\n\\tnumEnd := 0\\n\\tdepth := 0\\n\\n\\tfor i <= sLen {\\n\\t\\tif i == sLen || S[i] == \\'-\\' {\\n\\t\\t\\tif numEnd > numStart {\\n\\t\\t\\t\\tnum, _ := strconv.Atoi(S[numStart:numEnd])\\n\\t\\t\\t\\tif depth <= 0 {\\n\\t\\t\\t\\t\\troot = &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal:   num,\\n\\t\\t\\t\\t\\t\\tLeft:  nil,\\n\\t\\t\\t\\t\\t\\tRight: nil,\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tidxLevelMap[depth] = root\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfatherTreeNode, _ := idxLevelMap[depth-1]\\n\\t\\t\\t\\t\\ttreeNode := &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal:   num,\\n\\t\\t\\t\\t\\t\\tLeft:  nil,\\n\\t\\t\\t\\t\\t\\tRight: nil,\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif fatherTreeNode.Left == nil {\\n\\t\\t\\t\\t\\t\\tfatherTreeNode.Left = treeNode\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tfatherTreeNode.Right = treeNode\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tidxLevelMap[depth] = treeNode\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdepth = 0\\n\\t\\t\\t}\\n\\t\\t\\tdepth++\\n\\t\\t\\tnumStart = i + 1\\n\\t\\t\\tnumEnd = i + 1\\n\\t\\t} else {\\n\\t\\t\\tnumEnd++\\n\\t\\t}\\n\\n\\t\\ti++\\n\\t}\\n\\n\\treturn root\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nfunc recoverFromPreorder(S string) *TreeNode {\\n    sLen := len(S)\\n\\tif sLen <= 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tvar root *TreeNode\\n\\n\\tidxLevelMap := make(map[int]*TreeNode)\\n\\n\\ti := 0\\n\\tnumStart := 0\\n\\tnumEnd := 0\\n\\tdepth := 0\\n\\n\\tfor i <= sLen {\\n\\t\\tif i == sLen || S[i] == \\'-\\' {\\n\\t\\t\\tif numEnd > numStart {\\n\\t\\t\\t\\tnum, _ := strconv.Atoi(S[numStart:numEnd])\\n\\t\\t\\t\\tif depth <= 0 {\\n\\t\\t\\t\\t\\troot = &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal:   num,\\n\\t\\t\\t\\t\\t\\tLeft:  nil,\\n\\t\\t\\t\\t\\t\\tRight: nil,\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tidxLevelMap[depth] = root\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfatherTreeNode, _ := idxLevelMap[depth-1]\\n\\t\\t\\t\\t\\ttreeNode := &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal:   num,\\n\\t\\t\\t\\t\\t\\tLeft:  nil,\\n\\t\\t\\t\\t\\t\\tRight: nil,\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif fatherTreeNode.Left == nil {\\n\\t\\t\\t\\t\\t\\tfatherTreeNode.Left = treeNode\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tfatherTreeNode.Right = treeNode\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tidxLevelMap[depth] = treeNode\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdepth = 0\\n\\t\\t\\t}\\n\\t\\t\\tdepth++\\n\\t\\t\\tnumStart = i + 1\\n\\t\\t\\tnumEnd = i + 1\\n\\t\\t} else {\\n\\t\\t\\tnumEnd++\\n\\t\\t}\\n\\n\\t\\ti++\\n\\t}\\n\\n\\treturn root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 285932,
                "title": "c-simple-solution-in-o-1-space-currently-outperforms-everything-else",
                "content": "This algorithm travels down from the root every time it inserts a new node.\\n\\nI thought it would be a fun solution to write, but I did not think it would be fast. To my surprise, it beats 100% of all other submissions in both time and space, at least on LeetCode\\'s current test-cases. Still, I expect solutions that use recursion or a stack would outperform this on much larger inputs.\\n\\n```\\nclass Solution {\\npublic:\\n  TreeNode* recoverFromPreorder(std::string S) {\\n    cppHackery();\\n    s  = std::move(S);\\n    it = s.begin();\\n    while (it != s.end()) {\\n      int depth = parseDepth();\\n      int value = parseValue();\\n      nextNodePtr(depth) = new TreeNode(value);\\n    }\\n    return root;\\n  }\\n  \\nprivate:\\n  std::string           s;\\n  std::string::iterator it;\\n  TreeNode*             root;\\n  \\n  // Just a trick to make this run just the tiniest bit faster.\\n  void cppHackery() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n  }\\n  \\n  // Get the value for the next node by consuming the input.\\n  int parseValue() {\\n    int result = 0;\\n    for (; it != s.end() && *it != \\'-\\'; ++it)\\n      result = result * 10 + (*it - \\'0\\');\\n    return result;\\n  }\\n  \\n  // Get the depth for the next node by consuming the input.\\n  int parseDepth() {\\n    int result = 0;\\n    for (; *it == \\'-\\'; ++it)\\n      ++result;\\n    return result;    \\n  }\\n  \\n  // Get a reference to the next empty TreeNode* variable at the given depth.\\n  TreeNode*& nextNodePtr(int depth) {\\n    if (depth == 0) return root;\\n    TreeNode* node = root;\\n    while (--depth)\\n      node = node->right ? node->right : node->left;\\n    return node->left ? node->right : node->left;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  TreeNode* recoverFromPreorder(std::string S) {\\n    cppHackery();\\n    s  = std::move(S);\\n    it = s.begin();\\n    while (it != s.end()) {\\n      int depth = parseDepth();\\n      int value = parseValue();\\n      nextNodePtr(depth) = new TreeNode(value);\\n    }\\n    return root;\\n  }\\n  \\nprivate:\\n  std::string           s;\\n  std::string::iterator it;\\n  TreeNode*             root;\\n  \\n  // Just a trick to make this run just the tiniest bit faster.\\n  void cppHackery() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n  }\\n  \\n  // Get the value for the next node by consuming the input.\\n  int parseValue() {\\n    int result = 0;\\n    for (; it != s.end() && *it != \\'-\\'; ++it)\\n      result = result * 10 + (*it - \\'0\\');\\n    return result;\\n  }\\n  \\n  // Get the depth for the next node by consuming the input.\\n  int parseDepth() {\\n    int result = 0;\\n    for (; *it == \\'-\\'; ++it)\\n      ++result;\\n    return result;    \\n  }\\n  \\n  // Get a reference to the next empty TreeNode* variable at the given depth.\\n  TreeNode*& nextNodePtr(int depth) {\\n    if (depth == 0) return root;\\n    TreeNode* node = root;\\n    while (--depth)\\n      node = node->right ? node->right : node->left;\\n    return node->left ? node->right : node->left;\\n  }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 284659,
                "title": "beats-100-runtime",
                "content": "```\\nclass Solution {\\n    \\n    public TreeNode recoverFromPreorder(String S) {\\n        return recover(S, new int[]{0}, 0); \\n    }\\n    public TreeNode recover(String s, int[] i, int d){\\n      \\n        if(i[0] >= s.length()) return null;\\n        int cur = i[0], d1 = 0;\\n        while(cur < s.length() && s.charAt(cur) == \\'-\\'){\\n            d1++; cur++;\\n        }\\n        if(d1 != d){\\n            return null;\\n        }\\n        int x = 0;\\n        while(cur < s.length() && Character.isDigit(s.charAt(cur))){\\n            x = x*10 + (s.charAt(cur++) - \\'0\\');\\n        } \\n        i[0] = cur; \\n        TreeNode node = new TreeNode(x);\\n        node.left = recover(s, i, d+1);\\n        node.right = recover(s, i, d+1);\\n        return node;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public TreeNode recoverFromPreorder(String S) {\\n        return recover(S, new int[]{0}",
                "codeTag": "Java"
            },
            {
                "id": 280321,
                "title": "another-recursive-solution",
                "content": "```\\n vector<int> nodes;\\n \\n // Saves the next node with the same number of dashes for a given node.\\n unordered_map<int, int> next, prev;\\n\\n TreeNode* createTree(int from, int to) {\\n\\n    if (from >= to) return NULL;\\n\\n    TreeNode* tree = new TreeNode(nodes[from]);\\n\\n    // Get the index of the next node with the same number\\n    // of dashes\\n    int mid;\\n    if (next.count(from + 1) && (mid = next[from + 1]) < to) {\\n          tree->left = createTree(from + 1, mid);\\n          tree->right = createTree(mid, to);\\n          return tree;\\n    }\\n    tree->left = createTree(from + 1, to);\\n    return tree;\\n }\\n\\n TreeNode* recoverFromPreorder(string S) {\\n    int n = S.size();\\n    for (int i = 0; i < n;) {\\n       int dashes = 0;\\n       while (i < n && S[i] == \\'-\\') {\\n          dashes++;\\n          i++;\\n       }\\n       int num = 0;\\n       while (i < n && S[i] != \\'-\\') {\\n          num = 10 * num + S[i] - \\'0\\';\\n          i++;\\n       }\\n\\n       int curIdx = nodes.size();\\n       nodes.push_back(num);\\n       // Save the next node with the same number of dashes\\n       if (prev.count(dashes)) {\\n          next[prev[dashes]] = curIdx;\\n       }\\n       prev[dashes] = curIdx;\\n    }\\n    return createTree(0, nodes.size());\\n }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n vector<int> nodes;\\n \\n // Saves the next node with the same number of dashes for a given node.\\n unordered_map<int, int> next, prev;\\n\\n TreeNode* createTree(int from, int to) {\\n\\n    if (from >= to) return NULL;\\n\\n    TreeNode* tree = new TreeNode(nodes[from]);\\n\\n    // Get the index of the next node with the same number\\n    // of dashes\\n    int mid;\\n    if (next.count(from + 1) && (mid = next[from + 1]) < to) {\\n          tree->left = createTree(from + 1, mid);\\n          tree->right = createTree(mid, to);\\n          return tree;\\n    }\\n    tree->left = createTree(from + 1, to);\\n    return tree;\\n }\\n\\n TreeNode* recoverFromPreorder(string S) {\\n    int n = S.size();\\n    for (int i = 0; i < n;) {\\n       int dashes = 0;\\n       while (i < n && S[i] == \\'-\\') {\\n          dashes++;\\n          i++;\\n       }\\n       int num = 0;\\n       while (i < n && S[i] != \\'-\\') {\\n          num = 10 * num + S[i] - \\'0\\';\\n          i++;\\n       }\\n\\n       int curIdx = nodes.size();\\n       nodes.push_back(num);\\n       // Save the next node with the same number of dashes\\n       if (prev.count(dashes)) {\\n          next[prev[dashes]] = curIdx;\\n       }\\n       prev[dashes] = curIdx;\\n    }\\n    return createTree(0, nodes.size());\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 276633,
                "title": "a-easy-understandable-recursive-solution-for-tree-problem",
                "content": "A simple recursive DFS pattern for tree problem is:\\n1. DFS to the left side of node.\\n2. DFS to the right side of node.\\n3. Based on given conditions, organize the way of calling 1 and 2.\\n\\nFor this problem, the key point is to understand in which condition to add left children or right children for each node.\\n\\nThink in a greedy way, for each node, always try to add left child and right child, except two conditions:\\n1. If current node depth (level) is larger than expected depth, it means current node is next new level of its parent, so, it will always be left children.\\n2. If current node depth is less than expected depth it means current node is not current node\\'s children, or even higher ancestor. so it will return `nullptr`. To force the DFS travesal back to previosly DFS call with lower expected depth.\\n\\nAbove two conditions will tell whether a node\\'s left or right children is exist. Thus, the current node depth and expected depth are key parameters to recover the tree.\\n\\nAnother importance note is, for each node, DFS try to find next level node as deeper as possible unless next level node is *nullptr*, thus expected depth will increase by one at each DFS call:\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        int index = 0;\\n        return dfs(S, index, 0);\\n    }\\n    \\n    TreeNode* dfs(string& S, int& index, int level) {\\n        if (index >= S.length()) return nullptr;\\n        // get the level for this node\\n        int curLevel = 0;\\n        while (S[index] == \\'-\\') {\\n            index++;\\n            curLevel++;\\n        }\\n        if (curLevel < level) {\\n            index -= curLevel;\\n            return nullptr;\\n        }\\n        \\n        // get the number for this node\\n        int num = S[index++] - \\'0\\';\\n        while (S[index]-\\'0\\' >= 0 && S[index]-\\'9\\' <= 0) {\\n            num = 10 * num + (S[index++] - \\'0\\');\\n        }\\n        \\n        TreeNode* node = new TreeNode(num);\\n        \\n        if (curLevel == level) {\\n            node->left = dfs(S, index, level+1);\\n            node->right = dfs(S, index, level+1);\\n        } else if (curLevel > level) {\\n            node->left = dfs(S, index, curLevel+1);\\n        }\\n        \\n        return node;\\n    }\\n};\\n```\\n\\nNote:\\n1. To support recursive solution, string index should pass as a reference.\\n2. If condtion 2 happens, string index will recover to its original value before current function call.\\n3. Above case introduce performance burden (current 24ms comparing to the best), it could be fine-tuned by add next level in each recursive call to avoid index travesal back.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        int index = 0;\\n        return dfs(S, index, 0);\\n    }\\n    \\n    TreeNode* dfs(string& S, int& index, int level) {\\n        if (index >= S.length()) return nullptr;\\n        // get the level for this node\\n        int curLevel = 0;\\n        while (S[index] == \\'-\\') {\\n            index++;\\n            curLevel++;\\n        }\\n        if (curLevel < level) {\\n            index -= curLevel;\\n            return nullptr;\\n        }\\n        \\n        // get the number for this node\\n        int num = S[index++] - \\'0\\';\\n        while (S[index]-\\'0\\' >= 0 && S[index]-\\'9\\' <= 0) {\\n            num = 10 * num + (S[index++] - \\'0\\');\\n        }\\n        \\n        TreeNode* node = new TreeNode(num);\\n        \\n        if (curLevel == level) {\\n            node->left = dfs(S, index, level+1);\\n            node->right = dfs(S, index, level+1);\\n        } else if (curLevel > level) {\\n            node->left = dfs(S, index, curLevel+1);\\n        }\\n        \\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274800,
                "title": "java-short-solution",
                "content": "```\\n    String gS;\\n    public TreeNode recoverFromPreorder(String S) {\\n        gS = S;\\n        return helper(0);\\n    }\\n    \\n    TreeNode helper(int d) {\\n        if(gS.length() == 0) return null;\\n        \\n        int level = 0, idx = 0;\\n        while(gS.charAt(idx) == \\'-\\') idx++;\\n        level = idx;\\n        \\n        if(level != d) return null;\\n        \\n        while(idx < gS.length() && Character.isDigit(gS.charAt(idx))) idx++;\\n        \\n        TreeNode root = new TreeNode(Integer.parseInt(gS.substring(level, idx)));\\n        gS = gS.substring(idx);\\n        root.left = helper(d+1);\\n        root.right = helper(d+1);\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    String gS;\\n    public TreeNode recoverFromPreorder(String S) {\\n        gS = S;\\n        return helper(0);\\n    }\\n    \\n    TreeNode helper(int d) {\\n        if(gS.length() == 0) return null;\\n        \\n        int level = 0, idx = 0;\\n        while(gS.charAt(idx) == \\'-\\') idx++;\\n        level = idx;\\n        \\n        if(level != d) return null;\\n        \\n        while(idx < gS.length() && Character.isDigit(gS.charAt(idx))) idx++;\\n        \\n        TreeNode root = new TreeNode(Integer.parseInt(gS.substring(level, idx)));\\n        gS = gS.substring(idx);\\n        root.left = helper(d+1);\\n        root.right = helper(d+1);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 274784,
                "title": "java-recursive-solution",
                "content": "1. The first number is always root.\\n2. The string after root is always equal to ```n``` dashes, where ```n``` is next level.\\n3. If the right node is null, we can only find one string of ```n``` dashes.\\n```\\nEx: \"1-2--3--4-5--6--7\"\\n\\n\" 1  -  (2--3--4)  -  (5--6--7) \"\\n root  left string  right string\\n \\n1 is always the value of root.\\n\"-\" is always the string after root.\\n```\\n4. Do it recursively.\\n\\n```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        return helper(1, S);\\n    }\\n    private TreeNode helper(int level, String S) {\\n        // find root number\\n        int i = 0;\\n        while(i < S.length() && S.charAt(i) != \\'-\\') i++;\\n        TreeNode node = new TreeNode(new Integer(S.substring(0, i)));\\n        if(i == S.length()) return node;\\n        // find left & right nodes\\n        S = S.substring(i+level);\\n        i = 0;\\n        while(i < S.length()){\\n            int cnt = 0;\\n            while(i < S.length() && S.charAt(i) == \\'-\\') { i++; cnt++; }\\n\\t\\t\\t// right node exists\\n            if(cnt == level) {\\n                node.left = helper(level+1, S.substring(0, i-level));\\n                node.right = helper(level+1, S.substring(i));\\n                return node;\\n            }\\n            while(i < S.length() && S.charAt(i) != \\'-\\') i++;\\n        }\\n        // only left node\\n        node.left = helper(level+1, S);\\n        return node;\\n    }\\n}\\n```\\nTime complexity: ```O(N)```, N is the length of string.",
                "solutionTags": [],
                "code": "```n```\n```n```\n```n```\n```\\nEx: \"1-2--3--4-5--6--7\"\\n\\n\" 1  -  (2--3--4)  -  (5--6--7) \"\\n root  left string  right string\\n \\n1 is always the value of root.\\n\"-\" is always the string after root.\\n```\n```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        return helper(1, S);\\n    }\\n    private TreeNode helper(int level, String S) {\\n        // find root number\\n        int i = 0;\\n        while(i < S.length() && S.charAt(i) != \\'-\\') i++;\\n        TreeNode node = new TreeNode(new Integer(S.substring(0, i)));\\n        if(i == S.length()) return node;\\n        // find left & right nodes\\n        S = S.substring(i+level);\\n        i = 0;\\n        while(i < S.length()){\\n            int cnt = 0;\\n            while(i < S.length() && S.charAt(i) == \\'-\\') { i++; cnt++; }\\n\\t\\t\\t// right node exists\\n            if(cnt == level) {\\n                node.left = helper(level+1, S.substring(0, i-level));\\n                node.right = helper(level+1, S.substring(i));\\n                return node;\\n            }\\n            while(i < S.length() && S.charAt(i) != \\'-\\') i++;\\n        }\\n        // only left node\\n        node.left = helper(level+1, S);\\n        return node;\\n    }\\n}\\n```\n```O(N)```",
                "codeTag": "Java"
            },
            {
                "id": 274659,
                "title": "python-recursive-solution",
                "content": "The idea here is to recursively recover the tree. First you have to find where the right subtree starts in the string. On that position is a number and its previous element is still a number.\\n\\n```python\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        if S:\\n            nodes = [\"-\" if v == \"\" else v for v in S.split(\"-\")] # split all `-`\\n            root = TreeNode(int(nodes[0]))\\n            if len(nodes) == 1:\\n                return root\\n            elif len(nodes) == 2:\\n                root.left = TreeNode(int(nodes[1]))\\n                return root\\n            else:\\n                for i, v in enumerate(nodes[2: ], 2):\\n                    if nodes[i - 1] != \"-\" and v != \"-\":\\n                        rightPosition = i # found right subtree start position\\n                        break\\n                else: # right subtree does not exist\\n                    rightPosition = len(nodes)\\n\\n                leftTraversal = nodes[1: rightPosition]\\n                rightTraversal = nodes[rightPosition: ]\\n\\n                root.left = self.recoverFromPreorder(\"\".join(leftTraversal)) # recursively construct left subtree\\n                root.right = self.recoverFromPreorder(\"\".join(rightTraversal)) # recursively construct right subtree\\n                return root\\n        else:\\n            return None\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        if S:\\n            nodes = [\"-\" if v == \"\" else v for v in S.split(\"-\")] # split all `-`\\n            root = TreeNode(int(nodes[0]))\\n            if len(nodes) == 1:\\n                return root\\n            elif len(nodes) == 2:\\n                root.left = TreeNode(int(nodes[1]))\\n                return root\\n            else:\\n                for i, v in enumerate(nodes[2: ], 2):\\n                    if nodes[i - 1] != \"-\" and v != \"-\":\\n                        rightPosition = i # found right subtree start position\\n                        break\\n                else: # right subtree does not exist\\n                    rightPosition = len(nodes)\\n\\n                leftTraversal = nodes[1: rightPosition]\\n                rightTraversal = nodes[rightPosition: ]\\n\\n                root.left = self.recoverFromPreorder(\"\".join(leftTraversal)) # recursively construct left subtree\\n                root.right = self.recoverFromPreorder(\"\".join(rightTraversal)) # recursively construct right subtree\\n                return root\\n        else:\\n            return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274600,
                "title": "python-solution-with-explanation-simple-logic",
                "content": "for S = \\'1-2--3--4-5--6--7\\'\\nwe define helper() to get the root node constructed by S.\\nso we just split S as three parts by \\'-\\'(current level)\\n`l = [\\'1\\', \\'2--3--4\\', \\'5--6--7\\']`\\nthen, root = TreeNode(l[0]), root.left = helper(l[1]), root.right = helper(l[2])\\n\\nsorry for my mess code\\n```python\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        def getsplit(S, num):\\n            i = 0\\n            res = []\\n            start = 0\\n            while i < len(S):\\n                if S[i] == \\'-\\':\\n                    j = i\\n                    while j < len(S) and S[j] == \\'-\\': j += 1\\n                    if j-i == num:\\n                        res.append(S[start:i])\\n                        start = j\\n                    i = j -1\\n                i += 1\\n            res.append(S[start:])\\n            return res\\n\\n        def helper(S, num):\\n            if not S: return None\\n            # get root\\n            index = 0\\n            while index < len(S) and S[index] != \\'-\\': index += 1\\n            root = TreeNode(int(S[:index]))\\n            # split S into three parts\\n            l = getsplit(S, num)\\n            # not kid or just have left kid\\n            if len(l) == 1: return root\\n            elif len(l) == 2:\\n                root.left = helper(l[1], num+1)\\n            elif len(l) == 3:\\n                root.left = helper(l[1], num+1)\\n                root.right = helper(l[2], num+1)\\n            return root\\n\\n        return helper(S, 1)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        def getsplit(S, num):\\n            i = 0\\n            res = []\\n            start = 0\\n            while i < len(S):\\n                if S[i] == \\'-\\':\\n                    j = i\\n                    while j < len(S) and S[j] == \\'-\\': j += 1\\n                    if j-i == num:\\n                        res.append(S[start:i])\\n                        start = j\\n                    i = j -1\\n                i += 1\\n            res.append(S[start:])\\n            return res\\n\\n        def helper(S, num):\\n            if not S: return None\\n            # get root\\n            index = 0\\n            while index < len(S) and S[index] != \\'-\\': index += 1\\n            root = TreeNode(int(S[:index]))\\n            # split S into three parts\\n            l = getsplit(S, num)\\n            # not kid or just have left kid\\n            if len(l) == 1: return root\\n            elif len(l) == 2:\\n                root.left = helper(l[1], num+1)\\n            elif len(l) == 3:\\n                root.left = helper(l[1], num+1)\\n                root.right = helper(l[2], num+1)\\n            return root\\n\\n        return helper(S, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274575,
                "title": "java-iterative-stack-solution-o-n",
                "content": "Keep track of track of depth of node by counting number of `-`. Then, pop nodes from stack until we reach current depth. Greedily try appending to either left or right child.\\n\\nTime: O(N)\\nSpace: O(N)\\n\\n```\\n    public TreeNode recoverFromPreorder(String S) {\\n        Deque<TreeNode> deque = new ArrayDeque<>();\\n        int currentDepth = 0;\\n        int i = 0;\\n        while(i < S.length()) {\\n            if (S.charAt(i) != \\'-\\') {\\n                int num = 0;\\n                while(i < S.length() && S.charAt(i) != \\'-\\') {\\n                    num = num * 10 + (S.charAt(i) - \\'0\\');\\n                    i++;\\n                }\\n                \\n                while(deque.size() > currentDepth) {\\n                    deque.pollLast();\\n                }\\n                TreeNode parent = deque.size() > 0 ? deque.peekLast() : null;\\n                    \\n                TreeNode node = new TreeNode(num);\\n                if (parent != null) {\\n                    if (parent.left == null) parent.left = node;\\n                    else parent.right = node;\\n                }\\n                deque.offerLast(node);\\n                currentDepth = 0;\\n            } else {\\n                i++;\\n                currentDepth++;\\n            }\\n        }\\n        \\n        return deque.size() > 0 ? deque.pollFirst() : null;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode recoverFromPreorder(String S) {\\n        Deque<TreeNode> deque = new ArrayDeque<>();\\n        int currentDepth = 0;\\n        int i = 0;\\n        while(i < S.length()) {\\n            if (S.charAt(i) != \\'-\\') {\\n                int num = 0;\\n                while(i < S.length() && S.charAt(i) != \\'-\\') {\\n                    num = num * 10 + (S.charAt(i) - \\'0\\');\\n                    i++;\\n                }\\n                \\n                while(deque.size() > currentDepth) {\\n                    deque.pollLast();\\n                }\\n                TreeNode parent = deque.size() > 0 ? deque.peekLast() : null;\\n                    \\n                TreeNode node = new TreeNode(num);\\n                if (parent != null) {\\n                    if (parent.left == null) parent.left = node;\\n                    else parent.right = node;\\n                }\\n                deque.offerLast(node);\\n                currentDepth = 0;\\n            } else {\\n                i++;\\n                currentDepth++;\\n            }\\n        }\\n        \\n        return deque.size() > 0 ? deque.pollFirst() : null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087547,
                "title": "iterative-vector-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number of dashes represent the level at which a node should be at. ALso, for every value like \"--x\", where x is the node value, would mean that not only is x at level 2 (since there are k=2 dashes and levels start at 0) but also the fact that this is a child node of the last node in level 1 (k-1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis approach utilises a vector to store the levels index wise. Suppose, for the given string \"1-2-3--4--5--6---7\",\\nthe resultant vector should look like:\\n0 {1} ====> 1->(2,3)\\n1 {2 , 3} ====> 2->(4,5) , 3->(6)\\n2 {4 , 5 , 6} ====> 4->(8)\\n4 {8}\\n\\n# Complexity\\n- Time complexity: O(n), n=no of nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), n=no of nodes\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        vector<vector<TreeNode*>> a;\\n        int x=0; //for storing node value\\n        int i=0;\\n        int k=0; //counts no of dashes\\n        int n=traversal.size();\\n        while(i<n && traversal[i]!=\\'-\\') //first node\\n        {\\n            x=x*10+(traversal[i]-\\'0\\');\\n            i++;\\n        }\\n        TreeNode *h=new TreeNode(x);\\n        a.push_back({h});\\n        while(i<n)\\n        {\\n            if(traversal[i]==\\'-\\'){\\n                x=0;\\n                k++;\\n            }\\n            else {\\n                x=x*10+(traversal[i]-\\'0\\');\\n                if(i==n-1 || traversal[i+1]==\\'-\\')\\n                {\\n                    int m=a[k-1].size();\\n                    TreeNode* p=new TreeNode(x);\\n                    if(a[k-1][m-1]->left==NULL)\\n                    a[k-1][m-1]->left=p;\\n                    else\\n                    a[k-1][m-1]->right=p;\\n                    if(k>=a.size())\\n                    a.push_back({p});\\n                    else\\n                    a[k].push_back(p);\\n                    k=0;\\n                }\\n            }\\n            i++;\\n        }\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        vector<vector<TreeNode*>> a;\\n        int x=0; //for storing node value\\n        int i=0;\\n        int k=0; //counts no of dashes\\n        int n=traversal.size();\\n        while(i<n && traversal[i]!=\\'-\\') //first node\\n        {\\n            x=x*10+(traversal[i]-\\'0\\');\\n            i++;\\n        }\\n        TreeNode *h=new TreeNode(x);\\n        a.push_back({h});\\n        while(i<n)\\n        {\\n            if(traversal[i]==\\'-\\'){\\n                x=0;\\n                k++;\\n            }\\n            else {\\n                x=x*10+(traversal[i]-\\'0\\');\\n                if(i==n-1 || traversal[i+1]==\\'-\\')\\n                {\\n                    int m=a[k-1].size();\\n                    TreeNode* p=new TreeNode(x);\\n                    if(a[k-1][m-1]->left==NULL)\\n                    a[k-1][m-1]->left=p;\\n                    else\\n                    a[k-1][m-1]->right=p;\\n                    if(k>=a.size())\\n                    a.push_back({p});\\n                    else\\n                    a[k].push_back(p);\\n                    k=0;\\n                }\\n            }\\n            i++;\\n        }\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044848,
                "title": "c-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n    Approach:Using Stack\\n    We will traverse the given input string string.In each iteraton, we will separate node value and its depth for further processing. \\n    We will create new TreeNode for each val.Every time we create a new node, we will store it in a stack in the hope that it may become\\n    a parent of other nodes we will come across in the future.\\n    Before storing the current node in the stack, we need to find the parent of the current node.\\n    Given string is preorder traversal.In preorder , we visit root first and then we process\\n    its children. Therefore, Parent will be one of the nodes already stored in the stack.But which among them will be the parent?\\n    If the depth of a parent is D, the depth of its immediate child is D + 1.Therefore, we will pop the elements from stack till\\n    depth of the element on the top of the  stack is not equal to current depth-1.\\n    Once we find out the parent,next question is whether to attach the current node to left or to the right of parent?\\n    For this we maintain the depth of previous node called as prevDepth.\\n    We need to consider following 3 cases:\\n    i>Current Depth>prev Depth\\n    In preorder traversal after visiting the root node,we go to the left and as we go to the left depth increases by 1.\\n    So, if currDepth>prevDepth then it means that current node is left child of parent.\\n    \\n    ii>Current Depth=Prev Depth\\n    If prevDepth and currDepth are equal ,then it means\\n    that previous node and current node are siblings.Previous node is already attached to its parent as left child.\\n    So, current node is right child of the parent.\\n    \\n    \\n    iii>Current Depth<Prev Depth\\n    current node must be the right child of node on the top of the stack.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string traversal) \\n    {\\n        Stack<(TreeNode,int)> st=new Stack<(TreeNode,int)>();\\n        int prevDepth=0,currDepth=0;\\n        TreeNode root=null;\\n        int val=0;\\n        \\n        if(traversal==\"\")\\n        {\\n            return null;\\n        }\\n        \\n        for(int i=0;i<traversal.Length;)\\n        {\\n            currDepth=0;\\n            val=0;\\n            while(traversal[i]==\\'-\\')\\n            {\\n                currDepth++;\\n                i++;\\n            }\\n            while(i<traversal.Length && char.IsDigit(traversal[i]))\\n            {\\n                val=(val*10)+(traversal[i]-48);\\n                i++;\\n            }\\n            Console.WriteLine(val+\":\"+currDepth);\\n            TreeNode node=new TreeNode(val);\\n\\n            if(root==null) \\n            {\\n                root=node;\\n            }\\n            while(st.Count>0 && st.Peek().Item2!=currDepth-1)\\n            {\\n                st.Pop();\\n            }\\n                \\n                if(st.Count>0 && currDepth>prevDepth)\\n                {\\n                    st.Peek().Item1.left=node;\\n                }\\n                else if(st.Count>0 && (currDepth==prevDepth || currDepth<prevDepth))\\n                {\\n                    st.Peek().Item1.right=node;\\n                    st.Pop();\\n                }\\n\\n                st.Push((node,currDepth));\\n                prevDepth=currDepth;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string traversal) \\n    {\\n        Stack<(TreeNode,int)> st=new Stack<(TreeNode,int)>();\\n        int prevDepth=0,currDepth=0;\\n        TreeNode root=null;\\n        int val=0;\\n        \\n        if(traversal==\"\")\\n        {\\n            return null;\\n        }\\n        \\n        for(int i=0;i<traversal.Length;)\\n        {\\n            currDepth=0;\\n            val=0;\\n            while(traversal[i]==\\'-\\')\\n            {\\n                currDepth++;\\n                i++;\\n            }\\n            while(i<traversal.Length && char.IsDigit(traversal[i]))\\n            {\\n                val=(val*10)+(traversal[i]-48);\\n                i++;\\n            }\\n            Console.WriteLine(val+\":\"+currDepth);\\n            TreeNode node=new TreeNode(val);\\n\\n            if(root==null) \\n            {\\n                root=node;\\n            }\\n            while(st.Count>0 && st.Peek().Item2!=currDepth-1)\\n            {\\n                st.Pop();\\n            }\\n                \\n                if(st.Count>0 && currDepth>prevDepth)\\n                {\\n                    st.Peek().Item1.left=node;\\n                }\\n                else if(st.Count>0 && (currDepth==prevDepth || currDepth<prevDepth))\\n                {\\n                    st.Peek().Item1.right=node;\\n                    st.Pop();\\n                }\\n\\n                st.Push((node,currDepth));\\n                prevDepth=currDepth;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040775,
                "title": "solution-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string trav) {\\n        stack<TreeNode*> s;\\n        int i = 0;\\n        while(i < trav.size()){\\n            int lev = 0, j = i;\\n            while(j < trav.size() && trav[j] == \\'-\\'){\\n                j++;\\n                lev++;\\n            }\\n            int val = 0;\\n            while(j < trav.size() && trav[j] != \\'-\\'){\\n                val = 10 * val + (trav[j] - \\'0\\');\\n                j++;\\n            }\\n            TreeNode* newnode = new TreeNode(val);\\n            while(s.size() > lev)s.pop();\\n            if(!s.empty()){\\n                if(s.top() -> left)s.top() -> right = newnode;\\n                else s.top() -> left = newnode;\\n            }\\n            s.push(newnode);\\n            i = j;\\n        }\\n        if(s.empty())return NULL;\\n        while(s.size() > 1)s.pop();\\n        return s.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string trav) {\\n        stack<TreeNode*> s;\\n        int i = 0;\\n        while(i < trav.size()){\\n            int lev = 0, j = i;\\n            while(j < trav.size() && trav[j] == \\'-\\'){\\n                j++;\\n                lev++;\\n            }\\n            int val = 0;\\n            while(j < trav.size() && trav[j] != \\'-\\'){\\n                val = 10 * val + (trav[j] - \\'0\\');\\n                j++;\\n            }\\n            TreeNode* newnode = new TreeNode(val);\\n            while(s.size() > lev)s.pop();\\n            if(!s.empty()){\\n                if(s.top() -> left)s.top() -> right = newnode;\\n                else s.top() -> left = newnode;\\n            }\\n            s.push(newnode);\\n            i = j;\\n        }\\n        if(s.empty())return NULL;\\n        while(s.size() > 1)s.pop();\\n        return s.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038041,
                "title": "c-iterative-stack-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int calDepth(string &s, int &i){\\n        int n = s.size();\\n        int cnt = 0;\\n        while(i<n && s[i]==\\'-\\'){\\n            cnt++;\\n            ++i;\\n        }\\n        return cnt;\\n    }\\n    \\n    int calValue(string &s, int &i){\\n        int n = s.size();\\n        int val = 0;\\n        while(i<n && s[i]!=\\'-\\'){\\n            val*=10;\\n            val+=(s[i]-\\'0\\');\\n            ++i;\\n        }\\n        return val;\\n    }\\n    \\n    TreeNode* solve(string &s, int i){\\n        int n = s.size();\\n        stack<pair<TreeNode*,int>> stk;\\n        TreeNode* root = nullptr;\\n        while(i<n){\\n            int curDepth = calDepth(s, i);\\n            int curVal = calValue(s, i);\\n            while(!stk.empty() && stk.top().second >= curDepth){\\n                stk.pop();\\n            }\\n            TreeNode* node = new TreeNode(curVal);\\n            if(!root) root=node;\\n            else{\\n                if(!stk.top().first->left) stk.top().first->left = node;\\n                else stk.top().first->right = node;\\n            }\\n            stk.push({node, curDepth});\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) {\\n        return solve(traversal, 0);\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int calDepth(string &s, int &i){\\n        int n = s.size();\\n        int cnt = 0;\\n        while(i<n && s[i]==\\'-\\'){\\n            cnt++;\\n            ++i;\\n        }\\n        return cnt;\\n    }\\n    \\n    int calValue(string &s, int &i){\\n        int n = s.size();\\n        int val = 0;\\n        while(i<n && s[i]!=\\'-\\'){\\n            val*=10;\\n            val+=(s[i]-\\'0\\');\\n            ++i;\\n        }\\n        return val;\\n    }\\n    \\n    TreeNode* solve(string &s, int i){\\n        int n = s.size();\\n        stack<pair<TreeNode*,int>> stk;\\n        TreeNode* root = nullptr;\\n        while(i<n){\\n            int curDepth = calDepth(s, i);\\n            int curVal = calValue(s, i);\\n            while(!stk.empty() && stk.top().second >= curDepth){\\n                stk.pop();\\n            }\\n            TreeNode* node = new TreeNode(curVal);\\n            if(!root) root=node;\\n            else{\\n                if(!stk.top().first->left) stk.top().first->left = node;\\n                else stk.top().first->right = node;\\n            }\\n            stk.push({node, curDepth});\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) {\\n        return solve(traversal, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976934,
                "title": "inefficient-but-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the nodes are in level one , number of \\'-\\' before the number is 1 & if its in level 2 its -- and so on\\n\\n# Approach\\nStore the levels in HashMap and the parent level is current level-1, in hashmap if there is a node and its left is null assign the node to parent.left else parent.right\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\n)(N)\\n# Code\\n```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String str) {\\n        HashMap<Integer,TreeNode> hm = new HashMap<>();\\n        TreeNode root = null;\\n        int pre = 0;\\n        for(int i=0;i<str.length();){\\n            if(Character.isDigit(str.charAt(i))){\\n                int num = 0;\\n                while(i<str.length() && Character.isDigit(str.charAt(i))){\\n                    num*=10;\\n                    num+=(str.charAt(i)-\\'0\\');\\n                    i++;\\n                }\\n                TreeNode node = new TreeNode(num);\\n                hm.put(pre,node);\\n                if(pre==0){\\n                    root = node;\\n                }else{\\n                    TreeNode par = hm.get(pre-1);\\n                    if(par.left == null)\\n                        par.left = node;\\n                    else\\n                        par.right = node;\\n                }\\n            }\\n            if(i<str.length()&&str.charAt(i) == \\'-\\'){\\n                pre = 0;\\n                while(i<str.length() && str.charAt(i) == \\'-\\'){\\n                    pre++;i++;}\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String str) {\\n        HashMap<Integer,TreeNode> hm = new HashMap<>();\\n        TreeNode root = null;\\n        int pre = 0;\\n        for(int i=0;i<str.length();){\\n            if(Character.isDigit(str.charAt(i))){\\n                int num = 0;\\n                while(i<str.length() && Character.isDigit(str.charAt(i))){\\n                    num*=10;\\n                    num+=(str.charAt(i)-\\'0\\');\\n                    i++;\\n                }\\n                TreeNode node = new TreeNode(num);\\n                hm.put(pre,node);\\n                if(pre==0){\\n                    root = node;\\n                }else{\\n                    TreeNode par = hm.get(pre-1);\\n                    if(par.left == null)\\n                        par.left = node;\\n                    else\\n                        par.right = node;\\n                }\\n            }\\n            if(i<str.length()&&str.charAt(i) == \\'-\\'){\\n                pre = 0;\\n                while(i<str.length() && str.charAt(i) == \\'-\\'){\\n                    pre++;i++;}\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967624,
                "title": "intutitive-solution-commented-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int i = 0; // Index for string traversal\\n    \\n    TreeNode* recoverFromPreorder(string &S, int d) {\\n        int nextDigitPos = S.find_first_of(\"1234567890\", i); // This line of code uses the find_first_of function to search for the first occurrence of any character in the string \"1234567890\" (which represents the digits 0 to 9) after the index i in the string S.\\n\\t\\t\\t\\t//Find the index of the first number after index i\\n        \\n        // Check if the number of hyphens between current index i and nextDigitPos is equal to depth d\\n        if (nextDigitPos - i != d)\\n            return NULL; // Return NULL if the condition is not met\\n        \\n        int nextDashPos = S.find(\"-\", nextDigitPos); // This line of code uses the find function to search for the first occurrence of the character \\'-\\' (hyphen) in the string S starting from the index nextDigitPos.\\n\\n        int rootValue = stoi(S.substr(nextDigitPos, nextDashPos - nextDigitPos)); // Extract the root value\\n        \\n        TreeNode* root = new TreeNode(rootValue); // Create the root with the extracted value\\n        i = nextDashPos; // Move the index forward for future recursions\\n        \\n        // Recursively create left and right subtrees with increased depth\\n        root->left = recoverFromPreorder(S, d + 1);\\n        root->right = recoverFromPreorder(S, d + 1);\\n        \\n        return root; // Return the constructed root\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string S) {\\n        return recoverFromPreorder(S, 0); // Call the main function with initial depth 0\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int i = 0; // Index for string traversal\\n    \\n    TreeNode* recoverFromPreorder(string &S, int d) {\\n        int nextDigitPos = S.find_first_of(\"1234567890\", i); // This line of code uses the find_first_of function to search for the first occurrence of any character in the string \"1234567890\" (which represents the digits 0 to 9) after the index i in the string S.\\n\\t\\t\\t\\t//Find the index of the first number after index i\\n        \\n        // Check if the number of hyphens between current index i and nextDigitPos is equal to depth d\\n        if (nextDigitPos - i != d)\\n            return NULL; // Return NULL if the condition is not met\\n        \\n        int nextDashPos = S.find(\"-\", nextDigitPos); // This line of code uses the find function to search for the first occurrence of the character \\'-\\' (hyphen) in the string S starting from the index nextDigitPos.\\n\\n        int rootValue = stoi(S.substr(nextDigitPos, nextDashPos - nextDigitPos)); // Extract the root value\\n        \\n        TreeNode* root = new TreeNode(rootValue); // Create the root with the extracted value\\n        i = nextDashPos; // Move the index forward for future recursions\\n        \\n        // Recursively create left and right subtrees with increased depth\\n        root->left = recoverFromPreorder(S, d + 1);\\n        root->right = recoverFromPreorder(S, d + 1);\\n        \\n        return root; // Return the constructed root\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string S) {\\n        return recoverFromPreorder(S, 0); // Call the main function with initial depth 0\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967623,
                "title": "intutitive-solution-commented-easy",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   TreeNode* recoverFromPreorder(string str) {\\n\\tTreeNode *root=new TreeNode();\\n\\tif(str.size()==0) return root=nullptr;//an empty tree\\n\\tstack<pair<TreeNode * , int>> pending;\\n\\t//first element of pair is for the storing the node and secod pair is for the storing the depth of that node\\n\\tint index=0,nodeVal=0;\\n\\t//find the node val for tree\\n\\twhile(index<str.size() && str[index]!=\\'-\\') nodeVal=nodeVal*10+str[index++]-\\'0\\';\\n\\troot=new TreeNode(nodeVal);\\n\\tpending.push(make_pair(root , 0));\\n\\twhile(pending.size() && index<str.size()){\\n\\t\\tint depth=0;\\n\\t\\twhile(index<str.size() && str[index]==\\'-\\') index++ , depth++;\\t//find the depth of next node\\n\\t\\tnodeVal=0;\\n\\t\\t//let\\'s find the node value\\n\\t\\twhile(index<str.size() && str[index]!=\\'-\\') nodeVal=nodeVal*10+str[index++]-\\'0\\';\\n\\tTreeNode * currNode=new TreeNode(nodeVal);\\n\\t//LET\\'S get the parent what i have inserted earlier\\n\\t\\tpair<TreeNode* , int> parent=pending.top();\\n\\t\\t//if the difference between parent and current node is 1 then make curr node as left child of parent\\n\\t\\t//because question has given that If a node has only one child, that child is guaranteed to be the left child.\\n\\t\\tif((depth-parent.second)==1){\\n\\t\\t\\t//make curr node as a left child of the parent\\n\\t\\t\\t(parent.first)->left=currNode;\\n\\t\\t\\tpending.push(make_pair(currNode , depth));\\n\\t\\t}else{\\n\\t\\t\\t//find the parent of current node and append curr node as a right child of that parent\\n\\t\\t\\twhile(pending.size() && (depth - pending.top().second)!=1){\\n\\t\\t\\t\\tpending.pop();\\n\\t\\t\\t}\\n\\t\\t\\t//now our top has suitable parent for the curr node now append the curr node with parent as a right child .....\\n\\t\\t\\t//right child cause of we have been backtracking that\\'s why we assumed that our left subtree completed\\n\\t\\t\\tparent=pending.top();\\n\\t\\t\\t(parent.first)->right=currNode;\\n\\t\\t\\tpending.push(make_pair(currNode  , depth));//append curr node\\n\\t\\t}\\n\\t}\\n\\treturn root;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   TreeNode* recoverFromPreorder(string str) {\\n\\tTreeNode *root=new TreeNode();\\n\\tif(str.size()==0) return root=nullptr;//an empty tree\\n\\tstack<pair<TreeNode * , int>> pending;\\n\\t//first element of pair is for the storing the node and secod pair is for the storing the depth of that node\\n\\tint index=0,nodeVal=0;\\n\\t//find the node val for tree\\n\\twhile(index<str.size() && str[index]!=\\'-\\') nodeVal=nodeVal*10+str[index++]-\\'0\\';\\n\\troot=new TreeNode(nodeVal);\\n\\tpending.push(make_pair(root , 0));\\n\\twhile(pending.size() && index<str.size()){\\n\\t\\tint depth=0;\\n\\t\\twhile(index<str.size() && str[index]==\\'-\\') index++ , depth++;\\t//find the depth of next node\\n\\t\\tnodeVal=0;\\n\\t\\t//let\\'s find the node value\\n\\t\\twhile(index<str.size() && str[index]!=\\'-\\') nodeVal=nodeVal*10+str[index++]-\\'0\\';\\n\\tTreeNode * currNode=new TreeNode(nodeVal);\\n\\t//LET\\'S get the parent what i have inserted earlier\\n\\t\\tpair<TreeNode* , int> parent=pending.top();\\n\\t\\t//if the difference between parent and current node is 1 then make curr node as left child of parent\\n\\t\\t//because question has given that If a node has only one child, that child is guaranteed to be the left child.\\n\\t\\tif((depth-parent.second)==1){\\n\\t\\t\\t//make curr node as a left child of the parent\\n\\t\\t\\t(parent.first)->left=currNode;\\n\\t\\t\\tpending.push(make_pair(currNode , depth));\\n\\t\\t}else{\\n\\t\\t\\t//find the parent of current node and append curr node as a right child of that parent\\n\\t\\t\\twhile(pending.size() && (depth - pending.top().second)!=1){\\n\\t\\t\\t\\tpending.pop();\\n\\t\\t\\t}\\n\\t\\t\\t//now our top has suitable parent for the curr node now append the curr node with parent as a right child .....\\n\\t\\t\\t//right child cause of we have been backtracking that\\'s why we assumed that our left subtree completed\\n\\t\\t\\tparent=pending.top();\\n\\t\\t\\t(parent.first)->right=currNode;\\n\\t\\t\\tpending.push(make_pair(currNode  , depth));//append curr node\\n\\t\\t}\\n\\t}\\n\\treturn root;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951964,
                "title": "java-sol-with-runtime-2ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int i=0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n      return  helper(traversal, 0);\\n    }\\n    public TreeNode helper(String str, int dept){\\n        int d=0;\\n        while(i+d<str.length() && str.charAt(i+d)==\\'-\\'){\\n            d++;\\n        }\\n        if(d!=dept){\\n            return null;\\n        }\\n        int nd=0;\\n        while(i+d+nd< str.length() && str.charAt(i+d+nd)!=\\'-\\'){\\n            nd++;\\n        }\\n        int val= Integer.parseInt(str.substring(i+d, i+d+nd));\\n        i=i+d+nd;\\n        TreeNode node = new TreeNode(val);\\n        node.left= helper(str, dept+1);\\n        node.right= helper(str, dept+1);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int i=0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n      return  helper(traversal, 0);\\n    }\\n    public TreeNode helper(String str, int dept){\\n        int d=0;\\n        while(i+d<str.length() && str.charAt(i+d)==\\'-\\'){\\n            d++;\\n        }\\n        if(d!=dept){\\n            return null;\\n        }\\n        int nd=0;\\n        while(i+d+nd< str.length() && str.charAt(i+d+nd)!=\\'-\\'){\\n            nd++;\\n        }\\n        int val= Integer.parseInt(str.substring(i+d, i+d+nd));\\n        i=i+d+nd;\\n        TreeNode node = new TreeNode(val);\\n        node.left= helper(str, dept+1);\\n        node.right= helper(str, dept+1);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903245,
                "title": "python-simple-recursion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def get_left_and_right(self, s, count):\\n        i = 0\\n        while i < len(s):\\n            if s[i] == \"-\" and s[i-1].isdigit():\\n                j = i+1\\n                while j < len(s) and s[j] == \"-\":\\n                    j += 1\\n                if j-i == count:\\n                    return s[:i], s[j:]\\n            i += 1\\n        return s[:i], s[i+count:]\\n    \\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        if not traversal: return None\\n        node_val = \"\"\\n        while traversal and traversal[0].isdigit():\\n            node_val += traversal[0]\\n            traversal = traversal[1:]\\n        node = TreeNode(int(node_val))\\n        dash_count = 0\\n        while traversal and traversal[0] == \"-\":\\n            dash_count += 1\\n            traversal = traversal[1:]\\n        left_t, right_t = self.get_left_and_right(traversal, dash_count)\\n        node.left = self.recoverFromPreorder(left_t)\\n        node.right = self.recoverFromPreorder(right_t)\\n        return node\\n        \\n",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def get_left_and_right(self, s, count):\\n        i = 0\\n        while i < len(s):\\n            if s[i] == \"-\" and s[i-1].isdigit():\\n                j = i+1\\n                while j < len(s) and s[j] == \"-\":\\n                    j += 1\\n                if j-i == count:\\n                    return s[:i], s[j:]\\n            i += 1\\n        return s[:i], s[i+count:]\\n    \\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        if not traversal: return None\\n        node_val = \"\"\\n        while traversal and traversal[0].isdigit():\\n            node_val += traversal[0]\\n            traversal = traversal[1:]\\n        node = TreeNode(int(node_val))\\n        dash_count = 0\\n        while traversal and traversal[0] == \"-\":\\n            dash_count += 1\\n            traversal = traversal[1:]\\n        left_t, right_t = self.get_left_and_right(traversal, dash_count)\\n        node.left = self.recoverFromPreorder(left_t)\\n        node.right = self.recoverFromPreorder(right_t)\\n        return node\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3879515,
                "title": "beats-89-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        \\n        // TreeNode array[] = new TreeNode[]      , size nhi pta phle se therefore list\\n        // use karni padhegi  ; \\n\\n        if( traversal.length() == 0)\\n        return null ; \\n\\n\\n        List<TreeNode> list = new ArrayList<>() ; \\n         \\n         String temp = \"\" ; \\n\\n          int i = 0 ; \\n\\n         for(  i = 0 ; i < traversal.length(); i++)\\n         {\\n              if( traversal.charAt(i) < \\'0\\' || traversal.charAt(i) > \\'9\\')\\n              {\\n                  break ; \\n              }\\n              else\\n              continue ; \\n         }\\n\\n        \\n         temp = traversal.substring(0 , i) ; \\n\\n\\n         int data = Integer.parseInt(temp) ; \\n\\n         TreeNode root = new TreeNode(data) ; \\n\\n         list.add(root) ; \\n\\n         helper(traversal , i ,  list) ; \\n\\n\\n         return root ; \\n    } \\n    public void helper(String traversal , int index , List<TreeNode> list)\\n    {\\n         if( index >= traversal.length())\\n         return ; \\n\\n        int count = 0 ; \\n\\n        while( index < traversal.length() && traversal.charAt(index) == \\'-\\')\\n        {\\n            count++ ; \\n            index++ ; \\n        }\\n        \\n        int tempIndex = index ; \\n\\n         while( index < traversal.length() && traversal.charAt(index) != \\'-\\')\\n        {\\n            \\n            index++ ; \\n        }\\n\\n\\n        int data = Integer.parseInt(traversal.substring(tempIndex , index)) ; \\n\\n        TreeNode parent = list.get(count-1) ; \\n\\n        TreeNode curr = new TreeNode(data) ; \\n\\n        if( parent.left == null)\\n        {\\n            parent.left = curr ; \\n        }\\n        else\\n        parent.right = curr  ; \\n\\n\\n        if( list.size() > count)\\n        {\\n            list.add(count , curr) ; \\n        }\\n        else\\n        list.add(curr) ; \\n\\n        helper( traversal , index , list) ; \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        \\n        // TreeNode array[] = new TreeNode[]      , size nhi pta phle se therefore list\\n        // use karni padhegi  ; \\n\\n        if( traversal.length() == 0)\\n        return null ; \\n\\n\\n        List<TreeNode> list = new ArrayList<>() ; \\n         \\n         String temp = \"\" ; \\n\\n          int i = 0 ; \\n\\n         for(  i = 0 ; i < traversal.length(); i++)\\n         {\\n              if( traversal.charAt(i) < \\'0\\' || traversal.charAt(i) > \\'9\\')\\n              {\\n                  break ; \\n              }\\n              else\\n              continue ; \\n         }\\n\\n        \\n         temp = traversal.substring(0 , i) ; \\n\\n\\n         int data = Integer.parseInt(temp) ; \\n\\n         TreeNode root = new TreeNode(data) ; \\n\\n         list.add(root) ; \\n\\n         helper(traversal , i ,  list) ; \\n\\n\\n         return root ; \\n    } \\n    public void helper(String traversal , int index , List<TreeNode> list)\\n    {\\n         if( index >= traversal.length())\\n         return ; \\n\\n        int count = 0 ; \\n\\n        while( index < traversal.length() && traversal.charAt(index) == \\'-\\')\\n        {\\n            count++ ; \\n            index++ ; \\n        }\\n        \\n        int tempIndex = index ; \\n\\n         while( index < traversal.length() && traversal.charAt(index) != \\'-\\')\\n        {\\n            \\n            index++ ; \\n        }\\n\\n\\n        int data = Integer.parseInt(traversal.substring(tempIndex , index)) ; \\n\\n        TreeNode parent = list.get(count-1) ; \\n\\n        TreeNode curr = new TreeNode(data) ; \\n\\n        if( parent.left == null)\\n        {\\n            parent.left = curr ; \\n        }\\n        else\\n        parent.right = curr  ; \\n\\n\\n        if( list.size() > count)\\n        {\\n            list.add(count , curr) ; \\n        }\\n        else\\n        list.add(curr) ; \\n\\n        helper( traversal , index , list) ; \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874429,
                "title": "stack-beats-99",
                "content": "# Intuition\\nThe problem involves reconstructing a binary tree from a preorder traversal with depth information. Preorder traversal means that you traverse the root node, then the left subtree, and finally the right subtree. The depth information is indicated by the number of dashes before each node value. The key is to use a stack to keep track of the nodes being constructed.\\n\\n# Approach\\nInitialize an empty stack to keep track of nodes being constructed.\\nInitialize an index i to traverse the input trav string.\\nStart a loop that runs while i is within the bounds of the trav string.\\nInside the loop:\\nCount the number of dashes at index i to determine the depth of the current node.\\nRead the node value by extracting consecutive digits from index i and converting them to an integer.\\nCreate a new TreeNode with the extracted value.\\nPop nodes from the stack until the stack size is equal to the calculated depth. This helps to find the parent node of the current node.\\nIf the stack is not empty:\\nCheck if the parent node already has a left child. If it does, set the new node as the right child; otherwise, set it as the left child.\\nPush the new node onto the stack.\\nUpdate index i to move past the processed node value.\\nAfter processing the entire trav string:\\nIf the stack is empty, return NULL since there\\'s no tree to construct.\\nWhile the stack size is greater than 1, pop nodes from the stack until only the root node remains.\\nReturn the root node (the only node left in the stack).\\n\\n# Complexity\\n\\nTime Complexity: The algorithm processes each character of the input string once, and for each character, the stack operations take constant time. Hence, the time complexity is O(n), where n is the length of the input string trav.\\n\\nSpace Complexity: The space used by the stack corresponds to the maximum depth of the tree, which can be at most n/2 in the worst case (for a skewed tree). Therefore, the space complexity is O(n). Additionally, the space used for other variables and objects is negligible compared to the stack space.\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string trav) {\\n        stack<TreeNode*> s;\\n        int i = 0;\\n        while(i < trav.size()){\\n            int lev = 0, j = i;\\n            while(j < trav.size() && trav[j] == \\'-\\'){\\n                j++;\\n                lev++;\\n            }\\n            int val = 0;\\n            while(j < trav.size() && trav[j] != \\'-\\'){\\n                val = 10 * val + (trav[j] - \\'0\\');\\n                j++;\\n            }\\n            TreeNode* newnode = new TreeNode(val);\\n            while(s.size() > lev)s.pop();\\n            if(!s.empty()){\\n                if(s.top() -> left)s.top() -> right = newnode;\\n                else s.top() -> left = newnode;\\n            }\\n            s.push(newnode);\\n            i = j;\\n        }\\n        if(s.empty())return NULL;\\n        while(s.size() > 1)s.pop();\\n        return s.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string trav) {\\n        stack<TreeNode*> s;\\n        int i = 0;\\n        while(i < trav.size()){\\n            int lev = 0, j = i;\\n            while(j < trav.size() && trav[j] == \\'-\\'){\\n                j++;\\n                lev++;\\n            }\\n            int val = 0;\\n            while(j < trav.size() && trav[j] != \\'-\\'){\\n                val = 10 * val + (trav[j] - \\'0\\');\\n                j++;\\n            }\\n            TreeNode* newnode = new TreeNode(val);\\n            while(s.size() > lev)s.pop();\\n            if(!s.empty()){\\n                if(s.top() -> left)s.top() -> right = newnode;\\n                else s.top() -> left = newnode;\\n            }\\n            s.push(newnode);\\n            i = j;\\n        }\\n        if(s.empty())return NULL;\\n        while(s.size() > 1)s.pop();\\n        return s.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872517,
                "title": "recover-the-binary-tree-from-the-given-traversal-solution-faster-than-92-48-memory-100",
                "content": "# Intuition\\nTo solve this problem, I would use a stack to keep track of the parent nodes while traversing the given traversal string\\n\\n# Approach\\nThe depth of each node is determined by the number of dashes before its value. We iterate through the traversal string and for each node, we create a new `TreeNode` object with the corresponding value. If the depth of the current node is equal to the length of the stack, it means the current node is the left child of the last node in the stack. Otherwise, we pop nodes from the stack until we reach the parent of the current node, and set the current node as the right child of the parent. Finally, we return the root of the tree (which is the first element in the stack).\\nSo:\\n\\n1. Initialize an empty stack.\\n2. Iterate through the traversal string character by character:\\n   - Count the number of dashes (\\'-\\') to determine the depth of the current node.\\n   - Extract the numerical value of the node.\\n   - Create a new TreeNode object with the extracted value.\\n   - Check the depth of the current node:\\n     - If the depth is equal to the length of the stack, it means the current node is the left child of the last node in the stack. Set the left child of the last node in the stack to the current node.\\n     - If the depth is less than the length of the stack, it means the current node is the right child of one of the nodes already in the stack. Pop nodes from the stack until we reach the parent of the current node. Set the right child of the parent to the current node.\\n   - Push the current node onto the stack.\\n3. Return the root of the tree (which is the first element in the stack).\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the given traversal string. We iterate through the string once to build the tree.\\n\\n- Space complexity:\\nO(d), where d is the maximum depth of the tree. This is because the stack will contain at most d nodes at any given time.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        stack = []\\n        i = 0\\n        \\n        while i < len(traversal):\\n            depth = 0\\n            val = \"\"\\n            \\n            while i < len(traversal) and traversal[i] == \"-\":\\n                depth += 1\\n                i += 1\\n            \\n            while i < len(traversal) and traversal[i] != \"-\":\\n                val += traversal[i]\\n                i += 1\\n            \\n            node = TreeNode(int(val))\\n            \\n            if depth == len(stack):\\n                if stack:\\n                    stack[-1].left = node\\n            else:\\n                while len(stack) > depth:\\n                    stack.pop()\\n                stack[-1].right = node\\n            \\n            stack.append(node)\\n        \\n        return stack[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        stack = []\\n        i = 0\\n        \\n        while i < len(traversal):\\n            depth = 0\\n            val = \"\"\\n            \\n            while i < len(traversal) and traversal[i] == \"-\":\\n                depth += 1\\n                i += 1\\n            \\n            while i < len(traversal) and traversal[i] != \"-\":\\n                val += traversal[i]\\n                i += 1\\n            \\n            node = TreeNode(int(val))\\n            \\n            if depth == len(stack):\\n                if stack:\\n                    stack[-1].left = node\\n            else:\\n                while len(stack) > depth:\\n                    stack.pop()\\n                stack[-1].right = node\\n            \\n            stack.append(node)\\n        \\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866849,
                "title": "simple-python-solution-beats-92-83-in-run-time",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(d) where d is the max depth of the tree.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        l=1\\n        traversal=traversal.split(\"-\")\\n        Map={0:TreeNode(int(traversal[0]))}\\n        while l<len(traversal):\\n            count=1\\n            while traversal[l]==\"\" and l<len(traversal):\\n                count+=1\\n                l+=1\\n            newNode=TreeNode(int(traversal[l]))\\n            if Map[count-1].left==None:\\n                Map[count-1].left=newNode\\n            else:\\n                Map[count-1].right=newNode\\n            Map[count]=newNode\\n            l+=1\\n        return Map[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        l=1\\n        traversal=traversal.split(\"-\")\\n        Map={0:TreeNode(int(traversal[0]))}\\n        while l<len(traversal):\\n            count=1\\n            while traversal[l]==\"\" and l<len(traversal):\\n                count+=1\\n                l+=1\\n            newNode=TreeNode(int(traversal[l]))\\n            if Map[count-1].left==None:\\n                Map[count-1].left=newNode\\n            else:\\n                Map[count-1].right=newNode\\n            Map[count]=newNode\\n            l+=1\\n        return Map[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847913,
                "title": "python-solutino-beats-100",
                "content": "# Intuition\\nBrute Force with some optimization\\n\\n# Approach\\nSimply counting the number of dashes and if current number of dashes= prev dash count + 1 then the element will be a left child of the previous element otherwise it will be the right child of the node with Dash count= currrent dash count -1.\\n\\n# Complexity\\n- Time complexity:O(N)\\n- As fetching the element at a key in an unordered map take O(1) time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        level=defaultdict(list)\\n        dash=0\\n        prev=-1\\n        split=traversal.split(\"-\")\\n        print(split)\\n        for item in split:\\n            if item==\"\":\\n                dash+=1\\n                continue\\n            #print(item)\\n            node=TreeNode(item)\\n            level[dash].append(node)\\n            if prev==-1:\\n                root=node\\n            elif prev!=-1 and dash==prev+1:\\n                #print(node.val)\\n                level[prev][-1].left=node\\n            elif prev!=-1 and dash<=prev and dash>0:\\n                \\n                #print(level,dash)\\n                level[dash-1][-1].right=node\\n            #print(prev,dash)\\n            prev=dash\\n            dash=1\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        level=defaultdict(list)\\n        dash=0\\n        prev=-1\\n        split=traversal.split(\"-\")\\n        print(split)\\n        for item in split:\\n            if item==\"\":\\n                dash+=1\\n                continue\\n            #print(item)\\n            node=TreeNode(item)\\n            level[dash].append(node)\\n            if prev==-1:\\n                root=node\\n            elif prev!=-1 and dash==prev+1:\\n                #print(node.val)\\n                level[prev][-1].left=node\\n            elif prev!=-1 and dash<=prev and dash>0:\\n                \\n                #print(level,dash)\\n                level[dash-1][-1].right=node\\n            #print(prev,dash)\\n            prev=dash\\n            dash=1\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843396,
                "title": "o-n-using-hashmap-integer-treenode",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(h)\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n\\n        Map<Integer, TreeNode> hm = new HashMap<>();\\n        \\n        int i = 0;\\n        while (i < traversal.length()) {\\n            int depth = 0;\\n            while (i < traversal.length() && traversal.charAt(i) == \\'-\\') {\\n                depth++;\\n                i++;\\n            }\\n            \\n            int val = 0;\\n            while (i < traversal.length() && Character.isDigit(traversal.charAt(i))) {\\n                val = val * 10 + (traversal.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            \\n            TreeNode node = new TreeNode(val);\\n            hm.put(depth, node);\\n            \\n            if (depth > 0) {\\n                if (hm.get(depth - 1).left == null) {\\n                    hm.get(depth - 1).left = node;\\n                } \\n                else {\\n                    hm.get(depth - 1).right = node;\\n                }\\n            }\\n        }\\n        \\n        return hm.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n\\n        Map<Integer, TreeNode> hm = new HashMap<>();\\n        \\n        int i = 0;\\n        while (i < traversal.length()) {\\n            int depth = 0;\\n            while (i < traversal.length() && traversal.charAt(i) == \\'-\\') {\\n                depth++;\\n                i++;\\n            }\\n            \\n            int val = 0;\\n            while (i < traversal.length() && Character.isDigit(traversal.charAt(i))) {\\n                val = val * 10 + (traversal.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            \\n            TreeNode node = new TreeNode(val);\\n            hm.put(depth, node);\\n            \\n            if (depth > 0) {\\n                if (hm.get(depth - 1).left == null) {\\n                    hm.get(depth - 1).left = node;\\n                } \\n                else {\\n                    hm.get(depth - 1).right = node;\\n                }\\n            }\\n        }\\n        \\n        return hm.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811617,
                "title": "dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* dfs(string& s, int& i, int d){\\n        if(i >= s.size()) return nullptr;\\n        int depth =0;\\n        int j = i;\\n        while(s[j]==\\'-\\'){\\n            depth++;\\n            j++;\\n        }\\n        if(depth < d) return nullptr;\\n        i = j;\\n        int val = 0;\\n        while(i<s.size() && s[i]-\\'0\\'>=0 && s[i] -\\'0\\' <= 9){\\n            val = 10*val + s[i]-\\'0\\';\\n            i++;\\n        }\\n        if(depth == d){\\n        TreeNode* root = new TreeNode(val);\\n        root->left = dfs(s, i, depth+1);\\n        root->right = dfs(s, i, depth+1);\\n        return root;\\n        }\\n        return nullptr;\\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        int i=0;\\n        return dfs(traversal, i, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* dfs(string& s, int& i, int d){\\n        if(i >= s.size()) return nullptr;\\n        int depth =0;\\n        int j = i;\\n        while(s[j]==\\'-\\'){\\n            depth++;\\n            j++;\\n        }\\n        if(depth < d) return nullptr;\\n        i = j;\\n        int val = 0;\\n        while(i<s.size() && s[i]-\\'0\\'>=0 && s[i] -\\'0\\' <= 9){\\n            val = 10*val + s[i]-\\'0\\';\\n            i++;\\n        }\\n        if(depth == d){\\n        TreeNode* root = new TreeNode(val);\\n        root->left = dfs(s, i, depth+1);\\n        root->right = dfs(s, i, depth+1);\\n        return root;\\n        }\\n        return nullptr;\\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        int i=0;\\n        return dfs(traversal, i, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798890,
                "title": "c-using-stack",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public TreeNode RecoverFromPreorder(string traversal)\\n    {\\n        var stack = new Stack<TreeNode>();\\n        \\n        for (var i = 0; i < traversal.Length;)\\n        {\\n            int level;\\n            for (level = 0; traversal[i] == \\'-\\'; i++)\\n            {\\n                level++;\\n            }\\n\\n            int value;\\n            for (value = 0; i < traversal.Length && traversal[i] != \\'-\\'; i++)\\n            {\\n                value = value * 10 + (traversal[i] - \\'0\\');\\n            }\\n\\n            while (stack.Count > level)\\n            {\\n                stack.Pop();\\n            }\\n\\n            var node = new TreeNode(value);\\n            if (stack.Any())\\n            {\\n                if (stack.Peek().left == null)\\n                {\\n                    stack.Peek().left = node;\\n                }\\n                else\\n                {\\n                    stack.Peek().right = node;\\n                }\\n            }\\n\\n            stack.Push(node);\\n        }\\n\\n        return stack.Last();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public TreeNode RecoverFromPreorder(string traversal)\\n    {\\n        var stack = new Stack<TreeNode>();\\n        \\n        for (var i = 0; i < traversal.Length;)\\n        {\\n            int level;\\n            for (level = 0; traversal[i] == \\'-\\'; i++)\\n            {\\n                level++;\\n            }\\n\\n            int value;\\n            for (value = 0; i < traversal.Length && traversal[i] != \\'-\\'; i++)\\n            {\\n                value = value * 10 + (traversal[i] - \\'0\\');\\n            }\\n\\n            while (stack.Count > level)\\n            {\\n                stack.Pop();\\n            }\\n\\n            var node = new TreeNode(value);\\n            if (stack.Any())\\n            {\\n                if (stack.Peek().left == null)\\n                {\\n                    stack.Peek().left = node;\\n                }\\n                else\\n                {\\n                    stack.Peek().right = node;\\n                }\\n            }\\n\\n            stack.Push(node);\\n        }\\n\\n        return stack.Last();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797960,
                "title": "java-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n\\n        Stack<Node> stack = new Stack<>();\\n        int count = 0;\\n\\n         for (int i = 0; i < traversal.length(); i++) {\\n             if (traversal.charAt(i) != \\'-\\') {\\n                int j = i + 1;\\n                while (j < traversal.length() && traversal.charAt(j) != \\'-\\') {\\n                     j++;\\n                }\\n                \\n                String s = traversal.substring(i, j);\\n                i = j - 1;\\n\\n\\n                while (!stack.isEmpty() && stack.peek().level >= count) {\\n                    stack.pop();\\n                }\\n\\n                if (stack.isEmpty()) {\\n                    TreeNode treeNode = new TreeNode(Integer.valueOf(s));\\n                    Node node = new Node(treeNode, count);\\n                    stack.push(node);\\n                    count = 0;\\n                }\\n                else {\\n                    TreeNode top = stack.peek().treeNode;\\n\\n                    if (top.left != null) {\\n                        TreeNode treeNode = new TreeNode(Integer.valueOf(s));\\n                        Node node = new Node(treeNode, count);\\n                        stack.push(node);\\n                        count = 0;\\n                        top.right = treeNode;\\n                    }\\n                    else {\\n                        TreeNode treeNode = new TreeNode(Integer.valueOf(s));\\n                        Node node = new Node(treeNode, count);\\n                        stack.push(node);\\n                        count = 0;\\n                        top.left = treeNode;\\n                    }\\n\\n                }\\n                \\n             }\\n             else {\\n                 count++;\\n             }\\n         }\\n\\n         while (stack.size() > 1) stack.pop();\\n\\n         return stack.peek().treeNode;\\n        \\n    }\\n\\n    class Node {\\n        TreeNode treeNode;\\n        int level;\\n\\n        public Node(TreeNode treeNode, int level) {\\n            this.treeNode = treeNode;\\n            this.level = level;\\n        }\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n\\n        Stack<Node> stack = new Stack<>();\\n        int count = 0;\\n\\n         for (int i = 0; i < traversal.length(); i++) {\\n             if (traversal.charAt(i) != \\'-\\') {\\n                int j = i + 1;\\n                while (j < traversal.length() && traversal.charAt(j) != \\'-\\') {\\n                     j++;\\n                }\\n                \\n                String s = traversal.substring(i, j);\\n                i = j - 1;\\n\\n\\n                while (!stack.isEmpty() && stack.peek().level >= count) {\\n                    stack.pop();\\n                }\\n\\n                if (stack.isEmpty()) {\\n                    TreeNode treeNode = new TreeNode(Integer.valueOf(s));\\n                    Node node = new Node(treeNode, count);\\n                    stack.push(node);\\n                    count = 0;\\n                }\\n                else {\\n                    TreeNode top = stack.peek().treeNode;\\n\\n                    if (top.left != null) {\\n                        TreeNode treeNode = new TreeNode(Integer.valueOf(s));\\n                        Node node = new Node(treeNode, count);\\n                        stack.push(node);\\n                        count = 0;\\n                        top.right = treeNode;\\n                    }\\n                    else {\\n                        TreeNode treeNode = new TreeNode(Integer.valueOf(s));\\n                        Node node = new Node(treeNode, count);\\n                        stack.push(node);\\n                        count = 0;\\n                        top.left = treeNode;\\n                    }\\n\\n                }\\n                \\n             }\\n             else {\\n                 count++;\\n             }\\n         }\\n\\n         while (stack.size() > 1) stack.pop();\\n\\n         return stack.peek().treeNode;\\n        \\n    }\\n\\n    class Node {\\n        TreeNode treeNode;\\n        int level;\\n\\n        public Node(TreeNode treeNode, int level) {\\n            this.treeNode = treeNode;\\n            this.level = level;\\n        }\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782895,
                "title": "easy-c-o-n-code-commented-code-no-extra-space-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode* func(string &ans, int l, int r) {\\n        if(l>r)     return NULL;    \\n        \\n        int i=l, node=0;   //imputing node val\\n        while (i<=r && ans[i] != \\'-\\') {\\n            node = node*10 + (ans[i]-\\'0\\');\\n            i++;\\n        }\\n        \\n        if(i >= r)    return (new TreeNode(node)); //if leaf node\\n        \\n        int dashcnt = 0;    \\n        while(ans[i]== \\'-\\') {  //counting level of left subtree\\n            dashcnt++; i++;\\n        }\\n\\n        int c=0; int nxtidx = i;  //nxtidx point to root node val of left subtree\\n        //checking whether same node has right subtree\\n        while(i<=r && dashcnt != c) { \\n            c=0; i++;\\n            while(ans[i] == \\'-\\') {\\n                c++; i++;\\n            }\\n        }\\n        \\n        // i will point to root node val of right subtree\\n        // i-c-1 will point to last node of left subtree\\n        TreeNode* res = new TreeNode(node);\\n        \\n        res->left = func(ans, nxtidx, i-c-1);  //left subtree\\n        res->right = func(ans, i, r);          //right subtree\\n        \\n        return res;\\n    }\\n\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        return func(traversal, 0, traversal.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode* func(string &ans, int l, int r) {\\n        if(l>r)     return NULL;    \\n        \\n        int i=l, node=0;   //imputing node val\\n        while (i<=r && ans[i] != \\'-\\') {\\n            node = node*10 + (ans[i]-\\'0\\');\\n            i++;\\n        }\\n        \\n        if(i >= r)    return (new TreeNode(node)); //if leaf node\\n        \\n        int dashcnt = 0;    \\n        while(ans[i]== \\'-\\') {  //counting level of left subtree\\n            dashcnt++; i++;\\n        }\\n\\n        int c=0; int nxtidx = i;  //nxtidx point to root node val of left subtree\\n        //checking whether same node has right subtree\\n        while(i<=r && dashcnt != c) { \\n            c=0; i++;\\n            while(ans[i] == \\'-\\') {\\n                c++; i++;\\n            }\\n        }\\n        \\n        // i will point to root node val of right subtree\\n        // i-c-1 will point to last node of left subtree\\n        TreeNode* res = new TreeNode(node);\\n        \\n        res->left = func(ans, nxtidx, i-c-1);  //left subtree\\n        res->right = func(ans, i, r);          //right subtree\\n        \\n        return res;\\n    }\\n\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        return func(traversal, 0, traversal.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764985,
                "title": "c-with-comments-100-time-o-n-2-o-n-2",
                "content": "# Approach\\nWe can treat an input string as a \\n{value, {singleDash}, leftNode, {singleDash}, rightNode}\\nSo if we \"split\" input string by a singleDash, we can execute this function for both left and right substrings:\\n![image.png](https://assets.leetcode.com/users/images/c091a12a-e49b-4265-af17-a828bd0bb0fd_1689348256.9800248.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)  \\\\quad|\\\\quad{} \\u03A9(nlog(n))$$\\n- Space complexity: $$O(n^2) \\\\quad|\\\\quad \\u03A9(nlog(n))$$\\n\\nBad for Single child chain tree\\n![image.png](https://assets.leetcode.com/users/images/96cfcdb7-d01a-444b-b1ea-8e459cdcca2e_1689349930.3272674.png)\\n\\nGood for Balanced tree\\n![image.png](https://assets.leetcode.com/users/images/f204ed5f-4292-45d0-9f15-269bf7fe4b50_1689350109.5713055.png)\\n\\n# Code\\n```\\npublic TreeNode RecoverFromPreorder(string traversal) \\n{\\n    var sb = new StringBuilder();\\n    var result = SplitAndFill(traversal);\\n    return result;\\n\\n    TreeNode SplitAndFill(string str)\\n    {\\n        if (str == null) return null;\\n            \\n        var nodeData = Split(str);\\n        return new TreeNode(\\n            nodeData.val,\\n            SplitAndFill(nodeData.left),\\n            SplitAndFill(nodeData.right));\\n    }\\n\\n    (int val, string left, string right) Split(string str)\\n    {\\n        var headValue = 0;\\n        var children = new string[2];\\n            \\n        var i = 0;\\n        byte nestingLevel = 0;\\n            \\n        while (i < str.Length && str[i] != \\'-\\') \\n            headValue = headValue * 10 + (str[i++] - \\'0\\');\\n\\n        for (; ++i < str.Length;)\\n        {\\n            var c = str[i];\\n            if (str[i] == \\'-\\')\\n            {\\n                // our left/right substrings shoud have\\n                // 1 less \"dash nesting level\"\\n                // e.g.   in input \"1-2--3--4\"\\n                // we want to have \"2-3-4\"\\n                //         and not \"-2--3--4\"\\n                if (nestingLevel != 0)\\n                    sb.Append(c);\\n                nestingLevel++;\\n            }\\n            else\\n            {\\n                if (nestingLevel == 1)\\n                {\\n                    // if we face a single dash again, \\n                    // we can set all we collected at this point\\n                    // to the left node, as there can\\'t be\\n                    // another singe dash: the remainer is\\n                    // a right node substring\\n                    children[0] = sb.ToString();\\n                    sb.Clear();\\n                    nestingLevel = 0;\\n                    i--;\\n                }\\n                else\\n                {\\n                    sb.Append(c);\\n                    nestingLevel = 0;\\n                }\\n            }\\n        }\\n            \\n        if (sb.Length > 0)\\n        {\\n            // if our left substring is null\\n            // then the input string had no\\n            // single dashes\\n            // which means this node has only 1 child\\n            // and it cannot be right node by design\\n            i = children[0] == null ? 0 : 1;\\n            children[i] = sb.ToString();\\n        }\\n        sb.Clear();\\n\\n        return (headValue, children[0], children[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic TreeNode RecoverFromPreorder(string traversal) \\n{\\n    var sb = new StringBuilder();\\n    var result = SplitAndFill(traversal);\\n    return result;\\n\\n    TreeNode SplitAndFill(string str)\\n    {\\n        if (str == null) return null;\\n            \\n        var nodeData = Split(str);\\n        return new TreeNode(\\n            nodeData.val,\\n            SplitAndFill(nodeData.left),\\n            SplitAndFill(nodeData.right));\\n    }\\n\\n    (int val, string left, string right) Split(string str)\\n    {\\n        var headValue = 0;\\n        var children = new string[2];\\n            \\n        var i = 0;\\n        byte nestingLevel = 0;\\n            \\n        while (i < str.Length && str[i] != \\'-\\') \\n            headValue = headValue * 10 + (str[i++] - \\'0\\');\\n\\n        for (; ++i < str.Length;)\\n        {\\n            var c = str[i];\\n            if (str[i] == \\'-\\')\\n            {\\n                // our left/right substrings shoud have\\n                // 1 less \"dash nesting level\"\\n                // e.g.   in input \"1-2--3--4\"\\n                // we want to have \"2-3-4\"\\n                //         and not \"-2--3--4\"\\n                if (nestingLevel != 0)\\n                    sb.Append(c);\\n                nestingLevel++;\\n            }\\n            else\\n            {\\n                if (nestingLevel == 1)\\n                {\\n                    // if we face a single dash again, \\n                    // we can set all we collected at this point\\n                    // to the left node, as there can\\'t be\\n                    // another singe dash: the remainer is\\n                    // a right node substring\\n                    children[0] = sb.ToString();\\n                    sb.Clear();\\n                    nestingLevel = 0;\\n                    i--;\\n                }\\n                else\\n                {\\n                    sb.Append(c);\\n                    nestingLevel = 0;\\n                }\\n            }\\n        }\\n            \\n        if (sb.Length > 0)\\n        {\\n            // if our left substring is null\\n            // then the input string had no\\n            // single dashes\\n            // which means this node has only 1 child\\n            // and it cannot be right node by design\\n            i = children[0] == null ? 0 : 1;\\n            children[i] = sb.ToString();\\n        }\\n        sb.Clear();\\n\\n        return (headValue, children[0], children[1]);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3696355,
                "title": "easy-beats-100-tree-recursive-approach-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<pair<int, int>>& preorder, int& idx, int currDepth) {\\n        if (idx >= preorder.size() || preorder[idx].second != currDepth)\\n            return nullptr;\\n\\n        TreeNode* root = new TreeNode(preorder[idx].first);\\n        idx++;\\n\\n        root->left = buildTree(preorder, idx, currDepth + 1);\\n        root->right = buildTree(preorder, idx, currDepth + 1);\\n\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string t) {\\n        vector<pair<int, int>> preorder;\\n        int i = 0;\\n        while (i < t.size()) {\\n            int value = 0;\\n            int depth = 0;\\n            while (i < t.size() && t[i] == \\'-\\') {\\n                depth++;\\n                i++;\\n            }\\n            while (i < t.size() && isdigit(t[i])) {\\n                value = value * 10 + (t[i] - \\'0\\');\\n                i++;\\n            }\\n            preorder.push_back({ value, depth });\\n        }\\n        int idx = 0;\\n        TreeNode* root = buildTree(preorder, idx, 0);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<pair<int, int>>& preorder, int& idx, int currDepth) {\\n        if (idx >= preorder.size() || preorder[idx].second != currDepth)\\n            return nullptr;\\n\\n        TreeNode* root = new TreeNode(preorder[idx].first);\\n        idx++;\\n\\n        root->left = buildTree(preorder, idx, currDepth + 1);\\n        root->right = buildTree(preorder, idx, currDepth + 1);\\n\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string t) {\\n        vector<pair<int, int>> preorder;\\n        int i = 0;\\n        while (i < t.size()) {\\n            int value = 0;\\n            int depth = 0;\\n            while (i < t.size() && t[i] == \\'-\\') {\\n                depth++;\\n                i++;\\n            }\\n            while (i < t.size() && isdigit(t[i])) {\\n                value = value * 10 + (t[i] - \\'0\\');\\n                i++;\\n            }\\n            preorder.push_back({ value, depth });\\n        }\\n        int idx = 0;\\n        TreeNode* root = buildTree(preorder, idx, 0);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692072,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string trav) {\\n        stack<TreeNode*> st;\\n        int value = 0;\\n        int count = 0;\\n        trav += \\'-\\';\\n        for(auto& ch : trav) {\\n            if (ch == \\'-\\') {\\n                if (value != 0) {\\n                    TreeNode* node = new TreeNode(value);\\n                    while(st.size() > count) {\\n                        st.pop();\\n                    }\\n                    if (!st.empty()) {\\n                        TreeNode*& father = st.top();\\n                        if (!father->left) {\\n                            father->left = node;\\n                        } else {\\n                            father->right = node;\\n                        }\\n                    }\\n                    st.push(node);\\n\\n                    count = 0;\\n                    value = 0;\\n                }\\n                count++;\\n            } else {\\n                value *= 10;\\n                value += ch - \\'0\\';\\n            }\\n        }\\n        while(st.size() > 1) {\\n            st.pop();\\n        }\\n        return st.top();\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string trav) {\\n        stack<TreeNode*> st;\\n        int value = 0;\\n        int count = 0;\\n        trav += \\'-\\';\\n        for(auto& ch : trav) {\\n            if (ch == \\'-\\') {\\n                if (value != 0) {\\n                    TreeNode* node = new TreeNode(value);\\n                    while(st.size() > count) {\\n                        st.pop();\\n                    }\\n                    if (!st.empty()) {\\n                        TreeNode*& father = st.top();\\n                        if (!father->left) {\\n                            father->left = node;\\n                        } else {\\n                            father->right = node;\\n                        }\\n                    }\\n                    st.push(node);\\n\\n                    count = 0;\\n                    value = 0;\\n                }\\n                count++;\\n            } else {\\n                value *= 10;\\n                value += ch - \\'0\\';\\n            }\\n        }\\n        while(st.size() > 1) {\\n            st.pop();\\n        }\\n        return st.top();\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678383,
                "title": "non-recursive-easy-to-understand-c",
                "content": "# Intuition\\nUse a \\'depth-indexed\\' stack to find the parent of the current node.\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  TreeNode* recoverFromPreorder(string traversal) {\\n    int i = 0;  // current position in the string\\n    int n = traversal.size();\\n    // returns the next integer in the traversal\\n    // (advances `i\\' to a dash or the end of the string)\\n    auto nextInt = [&]() {\\n      // bound from [i, min(end of string, dash)]\\n      const char* start = traversal.data() + i;\\n      while ((i < n) && (traversal[i] != \\'-\\')) {\\n        i += 1;\\n      }\\n      const char* stop = traversal.data() + i + 1;\\n      // read the int from the string\\n      int res;\\n      auto[_, ec] = std::from_chars(start, stop, res);\\n      assert(ec == std::errc{});  // MUST SUCCEED!\\n      // return the resulting int\\n      return res;\\n    };\\n    // create the root element\\n    TreeNode* root = new TreeNode(nextInt());\\n    // stack of (node, depth)\\n    stack<pair<TreeNode*, int>> stk;\\n    // starts with root at depth 0\\n    stk.emplace(root, 0);\\n    // while we haven\\'t reached the end of the string...\\n    while (i < n) {\\n      // count the depth of the current node\\n      int depth = 0;\\n      while ((i < n) && (traversal[i] == \\'-\\')) {\\n        depth += 1;\\n        i += 1;\\n      }\\n      // find its parent in the stack (immediate node with depth - 1)\\n      while (!(stk.empty()) && (stk.top().second != (depth - 1))) {\\n        stk.pop();\\n      }\\n      // create the child, and set its position within the parent\\n      TreeNode* parent = stk.top().first;\\n      TreeNode* child = new TreeNode(nextInt());\\n      if (parent->left) {\\n        // the parent\\'s left child has already been created,\\n        // so set this node as its right child\\n        parent->right = child;\\n      } else {\\n        parent->left = child;\\n      }\\n      // add this new node to the stack!\\n      stk.emplace(child, depth);\\n    }\\n    // return the root...\\n    return root;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  TreeNode* recoverFromPreorder(string traversal) {\\n    int i = 0;  // current position in the string\\n    int n = traversal.size();\\n    // returns the next integer in the traversal\\n    // (advances `i\\' to a dash or the end of the string)\\n    auto nextInt = [&]() {\\n      // bound from [i, min(end of string, dash)]\\n      const char* start = traversal.data() + i;\\n      while ((i < n) && (traversal[i] != \\'-\\')) {\\n        i += 1;\\n      }\\n      const char* stop = traversal.data() + i + 1;\\n      // read the int from the string\\n      int res;\\n      auto[_, ec] = std::from_chars(start, stop, res);\\n      assert(ec == std::errc{});  // MUST SUCCEED!\\n      // return the resulting int\\n      return res;\\n    };\\n    // create the root element\\n    TreeNode* root = new TreeNode(nextInt());\\n    // stack of (node, depth)\\n    stack<pair<TreeNode*, int>> stk;\\n    // starts with root at depth 0\\n    stk.emplace(root, 0);\\n    // while we haven\\'t reached the end of the string...\\n    while (i < n) {\\n      // count the depth of the current node\\n      int depth = 0;\\n      while ((i < n) && (traversal[i] == \\'-\\')) {\\n        depth += 1;\\n        i += 1;\\n      }\\n      // find its parent in the stack (immediate node with depth - 1)\\n      while (!(stk.empty()) && (stk.top().second != (depth - 1))) {\\n        stk.pop();\\n      }\\n      // create the child, and set its position within the parent\\n      TreeNode* parent = stk.top().first;\\n      TreeNode* child = new TreeNode(nextInt());\\n      if (parent->left) {\\n        // the parent\\'s left child has already been created,\\n        // so set this node as its right child\\n        parent->right = child;\\n      } else {\\n        parent->left = child;\\n      }\\n      // add this new node to the stack!\\n      stk.emplace(child, depth);\\n    }\\n    // return the root...\\n    return root;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672628,
                "title": "c-recursive-approach-easy-to-understand",
                "content": "# Intuition\\nUse recursion to get left nodes and right nodes.\\n\\n# Approach\\nStore a global pointer `STR` to point to where we have reached in the string. Implement:\\n- `getint()`: returns next integer in `STR` and increase `STR` pass the number)\\n- `getlevel()`: returns the number of dashes nearby in `STR` and increase `STR` pass the dashes.\\n- **`getNode(int nextLevel)`**: this is a *recursive* function. \\n    - First it use `getint()` to find the nearest integer and put it in `val`. \\n    - To find each of the children nodes, first get the level by calling `getlevel()`. \\n    - If it matches `nextLevel`, then we spotted our child node and recursively call `getNode`. Else decrease `STR` to before the dashes.\\n\\n# Complexity\\n- Time complexity: at least $$O(N)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: at least $$O(N)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nchar* STR; // our global ptr\\ntypedef struct TreeNode Node; // shorten name\\n\\n// return a new node\\nNode* newNode(int val) {\\n    Node* res = malloc(sizeof(Node));\\n    res -> val = val; res -> left = NULL; res -> right = NULL;\\n    return res;\\n}\\n\\n// return next int in STR and increase STR\\nint getint() {\\n    int res = 0;\\n    for (; isdigit(*STR); ++STR) {\\n        res = res * 10 + *STR - \\'0\\';\\n    }\\n    return res;\\n}\\n\\n// return the number of dashes in STR and increase STR\\nint getlevel() {\\n    int res = 0;\\n    for (; *STR == \\'-\\'; ++STR, ++res);\\n    return res; \\n}\\n\\n// return the next node in STR, with its child nodes being at nextLevel\\nNode* getNode(int nextLevel) {\\n    Node* res = newNode(getint());\\n    int i = getlevel();\\n    if (i == nextLevel) res->left = getNode(nextLevel + 1);\\n    else STR -= i; // cancel the getlevel()\\n    i = getlevel();\\n    if (i == nextLevel) res->right = getNode(nextLevel + 1);\\n    else STR -= i; // cancel the getlevel()\\n    return res;\\n}\\n\\nstruct TreeNode* recoverFromPreorder(char * traversal){\\n    STR = traversal;\\n    return getNode(1); \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nchar* STR; // our global ptr\\ntypedef struct TreeNode Node; // shorten name\\n\\n// return a new node\\nNode* newNode(int val) {\\n    Node* res = malloc(sizeof(Node));\\n    res -> val = val; res -> left = NULL; res -> right = NULL;\\n    return res;\\n}\\n\\n// return next int in STR and increase STR\\nint getint() {\\n    int res = 0;\\n    for (; isdigit(*STR); ++STR) {\\n        res = res * 10 + *STR - \\'0\\';\\n    }\\n    return res;\\n}\\n\\n// return the number of dashes in STR and increase STR\\nint getlevel() {\\n    int res = 0;\\n    for (; *STR == \\'-\\'; ++STR, ++res);\\n    return res; \\n}\\n\\n// return the next node in STR, with its child nodes being at nextLevel\\nNode* getNode(int nextLevel) {\\n    Node* res = newNode(getint());\\n    int i = getlevel();\\n    if (i == nextLevel) res->left = getNode(nextLevel + 1);\\n    else STR -= i; // cancel the getlevel()\\n    i = getlevel();\\n    if (i == nextLevel) res->right = getNode(nextLevel + 1);\\n    else STR -= i; // cancel the getlevel()\\n    return res;\\n}\\n\\nstruct TreeNode* recoverFromPreorder(char * traversal){\\n    STR = traversal;\\n    return getNode(1); \\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3657874,
                "title": "dfs-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDFs+recursion is used to manage the dfs construction whenever countdash of child is 1 greater than countdash of parent it is attached to the left and then right respectively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApplying dfs in each recursion counting the countdash and previouscount dash...\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* find(int &start, int pcd, string s) {\\n        int i = start;\\n        int countdash = 0;\\n        if (i >= s.size()-1) return NULL;\\n        while (s[i] == \\'-\\' && i <= s.size() - 1) {\\n            countdash++;\\n            i++;\\n        }\\n        string t = \"\";\\n        while (s[i] != \\'-\\' && i <= s.size() - 1) {\\n            t += s[i];\\n            i++;\\n        }\\n        if (countdash > pcd) {\\n           start = i;\\n            TreeNode* temp = new TreeNode(stoi(t));\\n            temp->left = find(start, countdash, s);\\n            temp->right = find(start, countdash, s);\\n            return temp;\\n        }\\n         else if (countdash <= pcd) {\\n            return NULL;\\n        }\\n        return NULL;\\n    }\\n\\n    TreeNode* recoverFromPreorder(string s) {\\n        int n = s.size();\\n        if (n == 0) return NULL;\\n        if(n==1)\\n        {\\n            TreeNode* head = new TreeNode((s[0])-\\'0\\');\\n            head->left=NULL;\\n            head->right=NULL;\\n            return head;\\n        }\\n        int i = 0;\\n        string temp = \"\";\\n        while (s[i] != \\'-\\') {\\n            temp += s[i];\\n            i++;\\n        }\\n        TreeNode* head = new TreeNode(stoi(temp));\\n        \\n        int start = i;\\n        head->left = find(start, 0, s);\\n        head->right = find(start, 0, s);\\n        return head;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* find(int &start, int pcd, string s) {\\n        int i = start;\\n        int countdash = 0;\\n        if (i >= s.size()-1) return NULL;\\n        while (s[i] == \\'-\\' && i <= s.size() - 1) {\\n            countdash++;\\n            i++;\\n        }\\n        string t = \"\";\\n        while (s[i] != \\'-\\' && i <= s.size() - 1) {\\n            t += s[i];\\n            i++;\\n        }\\n        if (countdash > pcd) {\\n           start = i;\\n            TreeNode* temp = new TreeNode(stoi(t));\\n            temp->left = find(start, countdash, s);\\n            temp->right = find(start, countdash, s);\\n            return temp;\\n        }\\n         else if (countdash <= pcd) {\\n            return NULL;\\n        }\\n        return NULL;\\n    }\\n\\n    TreeNode* recoverFromPreorder(string s) {\\n        int n = s.size();\\n        if (n == 0) return NULL;\\n        if(n==1)\\n        {\\n            TreeNode* head = new TreeNode((s[0])-\\'0\\');\\n            head->left=NULL;\\n            head->right=NULL;\\n            return head;\\n        }\\n        int i = 0;\\n        string temp = \"\";\\n        while (s[i] != \\'-\\') {\\n            temp += s[i];\\n            i++;\\n        }\\n        TreeNode* head = new TreeNode(stoi(temp));\\n        \\n        int start = i;\\n        head->left = find(start, 0, s);\\n        head->right = find(start, 0, s);\\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649900,
                "title": "c-simple-recursive-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode *check(string str , int &index , int depth)\\n    {\\n        string temp  = \"\";\\n        int i = index;\\n        while(i < str.size() && str[i]!=\\'-\\')\\n        {\\n            temp+=str[i++];\\n        }\\n        TreeNode *root = new TreeNode(stoi(temp));\\n\\n        //checking depth of next node\\n        index = i;\\n        int dep = 0;\\n        while(i<str.size() && str[i]==\\'-\\'){\\n            dep++;\\n            i++;\\n        }\\n\\n        //If depth is not greater than the root depth itself than its the root node we will simply return root\\n        if(dep > depth)\\n        {   \\n            index = i;\\n            root->left = check(str , index , dep);\\n        }\\n        else\\n        {\\n            return root;\\n        }\\n\\n\\n        //If Left Child exist checking possibility of right child\\n        i = index;\\n        dep = 0;\\n        while(i<str.size() && str[i]==\\'-\\'){\\n            dep++;\\n            i++;\\n        }\\n        if(dep > depth)\\n        {\\n            index = i;\\n            root->right = check(str , index , dep);\\n        }\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        int index = 0;\\n        TreeNode *root = check(traversal , index , 0);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *check(string str , int &index , int depth)\\n    {\\n        string temp  = \"\";\\n        int i = index;\\n        while(i < str.size() && str[i]!=\\'-\\')\\n        {\\n            temp+=str[i++];\\n        }\\n        TreeNode *root = new TreeNode(stoi(temp));\\n\\n        //checking depth of next node\\n        index = i;\\n        int dep = 0;\\n        while(i<str.size() && str[i]==\\'-\\'){\\n            dep++;\\n            i++;\\n        }\\n\\n        //If depth is not greater than the root depth itself than its the root node we will simply return root\\n        if(dep > depth)\\n        {   \\n            index = i;\\n            root->left = check(str , index , dep);\\n        }\\n        else\\n        {\\n            return root;\\n        }\\n\\n\\n        //If Left Child exist checking possibility of right child\\n        i = index;\\n        dep = 0;\\n        while(i<str.size() && str[i]==\\'-\\'){\\n            dep++;\\n            i++;\\n        }\\n        if(dep > depth)\\n        {\\n            index = i;\\n            root->right = check(str , index , dep);\\n        }\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        int index = 0;\\n        TreeNode *root = check(traversal , index , 0);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640614,
                "title": "simple-o-n-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string t) {\\n        int idx =0;\\n        TreeNode* root = createTree(t,idx,-1);\\n        return root;\\n    }\\n\\n    TreeNode* createTree(string t,int &idx,int prev){\\n        if(idx==t.size()) return NULL;\\n        TreeNode * n = new TreeNode();\\n        string num;\\n        int cnt=0;\\n        while(idx<t.size() && t[idx]==\\'-\\'){\\n            cnt++;\\n            idx++;\\n        } \\n        if(cnt<=prev){\\n            idx-=(cnt);\\n            return NULL;\\n        }\\n        while(idx<t.size() && t[idx]>=\\'0\\' && t[idx]<=\\'9\\'){\\n            num.push_back(t[idx++]);\\n        }\\n        n->val = stoi(num);\\n        n->left = createTree(t,idx,cnt);\\n        n->right = createTree(t,idx,cnt);\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string t) {\\n        int idx =0;\\n        TreeNode* root = createTree(t,idx,-1);\\n        return root;\\n    }\\n\\n    TreeNode* createTree(string t,int &idx,int prev){\\n        if(idx==t.size()) return NULL;\\n        TreeNode * n = new TreeNode();\\n        string num;\\n        int cnt=0;\\n        while(idx<t.size() && t[idx]==\\'-\\'){\\n            cnt++;\\n            idx++;\\n        } \\n        if(cnt<=prev){\\n            idx-=(cnt);\\n            return NULL;\\n        }\\n        while(idx<t.size() && t[idx]>=\\'0\\' && t[idx]<=\\'9\\'){\\n            num.push_back(t[idx++]);\\n        }\\n        n->val = stoi(num);\\n        n->left = createTree(t,idx,cnt);\\n        n->right = createTree(t,idx,cnt);\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636552,
                "title": "simple-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* findans(string t,int h,int &ind){\\n        string s = \"\";\\n        while(ind<t.size() and t[ind]!=\\'-\\'){s = s + t[ind];ind++;}\\n        TreeNode* node = new TreeNode(stoi(s));\\n        h++;\\n        int x = ind;\\n        while(x<t.size() and t[x]==\\'-\\')x++;\\n        if(x!=t.size() and x==ind+h){\\n            ind = x;\\n            node->left = findans(t,h,ind);\\n        }\\n        x = ind;\\n        while(x<t.size() and t[x]==\\'-\\')x++;\\n        if(x!=t.size() and x==ind+h){\\n            ind = x;\\n            node->right = findans(t,h,ind);\\n        }\\n        return node;\\n    }\\n    TreeNode* recoverFromPreorder(string t) {\\n        int ind = 0;\\n        return findans(t,0,ind);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* findans(string t,int h,int &ind){\\n        string s = \"\";\\n        while(ind<t.size() and t[ind]!=\\'-\\'){s = s + t[ind];ind++;}\\n        TreeNode* node = new TreeNode(stoi(s));\\n        h++;\\n        int x = ind;\\n        while(x<t.size() and t[x]==\\'-\\')x++;\\n        if(x!=t.size() and x==ind+h){\\n            ind = x;\\n            node->left = findans(t,h,ind);\\n        }\\n        x = ind;\\n        while(x<t.size() and t[x]==\\'-\\')x++;\\n        if(x!=t.size() and x==ind+h){\\n            ind = x;\\n            node->right = findans(t,h,ind);\\n        }\\n        return node;\\n    }\\n    TreeNode* recoverFromPreorder(string t) {\\n        int ind = 0;\\n        return findans(t,0,ind);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632976,
                "title": "simple-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n     int convertInt(string &temp){\\n        int ans=0;\\n        int sign=1;\\n        for(int i=0;i<temp.size();i++) {\\n            int t = temp[i] - 48;\\n            ans = ans *10 + t;\\n        }\\n        return ans;\\n    }\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        vector<int>no;\\n        vector<int>dep;\\n\\n        string temp = \"\";\\n        int cnt=0;\\n        for(int i=0;i<traversal.size();i++) {\\n            if(traversal[i] == \\'-\\' && traversal[i-1] != \\'-\\') {\\n                int a = convertInt(temp);\\n                no.push_back(a);\\n                temp=\"\";\\n                cnt++;\\n            }\\n            else if(!i || (i && traversal[i] != \\'-\\' && traversal[i-1]==\\'-\\')) {\\n                temp += traversal[i];\\n                dep.push_back(cnt);\\n                cnt=0;\\n            }\\n            else {\\n                if(traversal[i] == \\'-\\') cnt++;\\n                else temp += traversal[i];\\n            }\\n        }\\n        int a = convertInt(temp);\\n        no.push_back(a);\\n\\n        stack<pair<TreeNode *,int>>st;\\n        TreeNode *root = new TreeNode(no[0]);\\n        st.push({root,dep[0]});\\n\\n        for(int i=1;i<no.size();i++) {\\n            if(dep[i] > st.top().second) {\\n                TreeNode *curr = new TreeNode (no[i]);\\n                st.top().first->left = curr;\\n                st.push({curr,dep[i]});\\n            }\\n            else {\\n                while(dep[i] <= st.top().second) st.pop();\\n                auto it = st.top();\\n                st.pop();\\n                TreeNode *curr = new TreeNode (no[i]);\\n                it.first->right = curr;\\n                st.push({curr,dep[i]});\\n            }\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n     int convertInt(string &temp){\\n        int ans=0;\\n        int sign=1;\\n        for(int i=0;i<temp.size();i++) {\\n            int t = temp[i] - 48;\\n            ans = ans *10 + t;\\n        }\\n        return ans;\\n    }\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        vector<int>no;\\n        vector<int>dep;\\n\\n        string temp = \"\";\\n        int cnt=0;\\n        for(int i=0;i<traversal.size();i++) {\\n            if(traversal[i] == \\'-\\' && traversal[i-1] != \\'-\\') {\\n                int a = convertInt(temp);\\n                no.push_back(a);\\n                temp=\"\";\\n                cnt++;\\n            }\\n            else if(!i || (i && traversal[i] != \\'-\\' && traversal[i-1]==\\'-\\')) {\\n                temp += traversal[i];\\n                dep.push_back(cnt);\\n                cnt=0;\\n            }\\n            else {\\n                if(traversal[i] == \\'-\\') cnt++;\\n                else temp += traversal[i];\\n            }\\n        }\\n        int a = convertInt(temp);\\n        no.push_back(a);\\n\\n        stack<pair<TreeNode *,int>>st;\\n        TreeNode *root = new TreeNode(no[0]);\\n        st.push({root,dep[0]});\\n\\n        for(int i=1;i<no.size();i++) {\\n            if(dep[i] > st.top().second) {\\n                TreeNode *curr = new TreeNode (no[i]);\\n                st.top().first->left = curr;\\n                st.push({curr,dep[i]});\\n            }\\n            else {\\n                while(dep[i] <= st.top().second) st.pop();\\n                auto it = st.top();\\n                st.pop();\\n                TreeNode *curr = new TreeNode (no[i]);\\n                it.first->right = curr;\\n                st.push({curr,dep[i]});\\n            }\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619295,
                "title": "98-fastest-iterative-stack-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Have a stack that holds all the nodes\\n- Init stack to hold the root node and have the reference to the root for easy return (you can also pop the stack until size is 1 and return that node)\\n- Create 2 helper methods to parse next depth and val in the string for less confusion\\n- If the depth is one greater then the previous depth, then that node is the left child of the prev node\\n- Otherwise that node is a right child of a parent node. Pop the stack an appropriate amount to get the correct parent node.\\n\\n# Complexity\\n- Time complexity:\\nO(N), where N is number of nodes\\n\\n- Space complexity:\\nO(N), where N is number of nodes\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        stack<TreeNode*> node_stack;\\n        int i = 0, prevDepth = 0;\\n        TreeNode* root = new TreeNode(getVal(traversal, i));\\n        node_stack.push(root);\\n        while (i < traversal.size()) {\\n            int depth = getDepth(traversal, i);\\n            TreeNode* node = new TreeNode(getVal(traversal, i));\\n            if (depth == prevDepth+1) {\\n                node_stack.top()->left = node;\\n            } else if (depth <= prevDepth) {\\n                int diff = prevDepth-depth;\\n                for (int i = 0; i <= diff; i++) {\\n                    node_stack.pop();\\n                }\\n                node_stack.top()->right = node;\\n            }\\n            prevDepth = depth;\\n            node_stack.push(node);\\n        }\\n        return root;\\n    }\\nprivate:\\n    int getDepth(string& traversal, int& i) {\\n        int depth = 0;\\n        while (traversal[i] == \\'-\\') {\\n            depth++;\\n            i++;\\n        }\\n        return depth;\\n    }\\n    int getVal(string& traversal, int& i) {\\n        int len = 0;\\n        while (traversal[i+len] != \\'-\\' && i+len < traversal.size()) {\\n            len++;\\n        }\\n        int val = stoi(traversal.substr(i, len));\\n        i += len;\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        stack<TreeNode*> node_stack;\\n        int i = 0, prevDepth = 0;\\n        TreeNode* root = new TreeNode(getVal(traversal, i));\\n        node_stack.push(root);\\n        while (i < traversal.size()) {\\n            int depth = getDepth(traversal, i);\\n            TreeNode* node = new TreeNode(getVal(traversal, i));\\n            if (depth == prevDepth+1) {\\n                node_stack.top()->left = node;\\n            } else if (depth <= prevDepth) {\\n                int diff = prevDepth-depth;\\n                for (int i = 0; i <= diff; i++) {\\n                    node_stack.pop();\\n                }\\n                node_stack.top()->right = node;\\n            }\\n            prevDepth = depth;\\n            node_stack.push(node);\\n        }\\n        return root;\\n    }\\nprivate:\\n    int getDepth(string& traversal, int& i) {\\n        int depth = 0;\\n        while (traversal[i] == \\'-\\') {\\n            depth++;\\n            i++;\\n        }\\n        return depth;\\n    }\\n    int getVal(string& traversal, int& i) {\\n        int len = 0;\\n        while (traversal[i+len] != \\'-\\' && i+len < traversal.size()) {\\n            len++;\\n        }\\n        int val = stoi(traversal.substr(i, len));\\n        i += len;\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618870,
                "title": "c-beats-44",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string s)\\n    {\\n        int i = 0;\\n        int req = 0;\\n        \\n        return RecoverFromPreorder(ref req, ref i, s, 0);\\n    }\\n\\n    TreeNode RecoverFromPreorder(ref int req, ref int i, string s, int level)\\n    {\\n        string val = \"\";\\n        req = 0;\\n        while (i < s.Length && s[i] != \\'-\\')\\n        {\\n            val += s[i];\\n            i++;\\n        }\\n        TreeNode node = new TreeNode(int.Parse(val));\\n        while (i < s.Length && s[i] == \\'-\\')\\n        {\\n            req++;\\n            i++;\\n        }\\n        if (req > level)\\n        {\\n            node.left = RecoverFromPreorder(ref req, ref i, s, level + 1);\\n            if (i < s.Length && req > level)\\n                node.right = RecoverFromPreorder(ref req, ref i, s, level + 1);\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string s)\\n    {\\n        int i = 0;\\n        int req = 0;\\n        \\n        return RecoverFromPreorder(ref req, ref i, s, 0);\\n    }\\n\\n    TreeNode RecoverFromPreorder(ref int req, ref int i, string s, int level)\\n    {\\n        string val = \"\";\\n        req = 0;\\n        while (i < s.Length && s[i] != \\'-\\')\\n        {\\n            val += s[i];\\n            i++;\\n        }\\n        TreeNode node = new TreeNode(int.Parse(val));\\n        while (i < s.Length && s[i] == \\'-\\')\\n        {\\n            req++;\\n            i++;\\n        }\\n        if (req > level)\\n        {\\n            node.left = RecoverFromPreorder(ref req, ref i, s, level + 1);\\n            if (i < s.Length && req > level)\\n                node.right = RecoverFromPreorder(ref req, ref i, s, level + 1);\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618838,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string s)\\n    {\\n        int i = 0;\\n        int req = 0;\\n\\n        TreeNode Solve(int level)\\n        {\\n            string val = \"\";\\n            req = 0;\\n            while (i < s.Length && s[i] != \\'-\\')\\n            {\\n                val += s[i];\\n                i++;\\n            }\\n            TreeNode node = new TreeNode(int.Parse(val));\\n            while (i < s.Length && s[i] == \\'-\\')\\n            {\\n                req++;\\n                i++;\\n            }\\n            if (req > level)\\n            {\\n                node.left = Solve(level + 1);\\n                if (i < s.Length && req > level)\\n                    node.right = Solve(level + 1);\\n            }\\n            return node;\\n        }\\n\\n        return Solve(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string s)\\n    {\\n        int i = 0;\\n        int req = 0;\\n\\n        TreeNode Solve(int level)\\n        {\\n            string val = \"\";\\n            req = 0;\\n            while (i < s.Length && s[i] != \\'-\\')\\n            {\\n                val += s[i];\\n                i++;\\n            }\\n            TreeNode node = new TreeNode(int.Parse(val));\\n            while (i < s.Length && s[i] == \\'-\\')\\n            {\\n                req++;\\n                i++;\\n            }\\n            if (req > level)\\n            {\\n                node.left = Solve(level + 1);\\n                if (i < s.Length && req > level)\\n                    node.right = Solve(level + 1);\\n            }\\n            return node;\\n        }\\n\\n        return Solve(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592334,
                "title": "c-solution-with-easy-to-understand-solution",
                "content": "# Intuition\\nThis is one of the most interesting trees question I have ever solved!\\nIn this question, we are given a string such that it shows the preorder traversal and the depth of each node just before it. So, in order to make things easy, I have created a Traversal array with int data type which stores nodes in such a way that depth of node comes before actual node value. \\nEx: \\n![image.png](https://assets.leetcode.com/users/images/b4820a63-83ba-4d67-ae0f-02899fe1d576_1685781852.941001.png)\\n\\nThe vector is : 0 1 1 2 2 3 2 4 1 5 2 6 2 7\\nThe even indices are depths and odd indices are actual node values.\\nSo, 1 has depth 0, 2 has depth 1, 3 has depth 2 and so on..\\nThis will help us get node value and depth of node in numerical form directly.\\n\\n\\n# Approach\\nNow see this : 0 1 *1* 2 2 3 2 4 *1* 5 2 6 2 7\\nNow, since in preorder, the first node is root, so take out 0 1 (first 2 elements of traversal array).\\nNow see the left and right part of the tree in figure.\\nLeft part is : 1 2 2 3 2 4\\nRight part is : 1 5 2 6 2 7\\n\\nIn the vector, if a depth = currentNodeDepth+1 is repeated twice, it means, both left and right subtree exist.\\nIf currentNodeDepth+1 just comes once, it means just one subtree(left) exists. \\nSo here, you can see that depth = 1 is repeated twice (look at italicized 1s at index = 2 and index = 8).\\nNow, send subsequent part of trees for recursion and build trees.\\n\\nAlso note, that if there are no left and right subtrees, then in that case just make node with the appropriate value and return.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* buildTree(vector<int>& Traversal,int i,int j)\\n    {\\n        \\n        if(i >= Traversal.size())\\n        {\\n            return NULL;\\n        }\\n        TreeNode* root = new TreeNode(Traversal[i+1]);\\n        int depth = Traversal[i]+1;\\n        int count = 0;\\n        int idx;\\n        for(idx=i+2;idx<=j;idx+=2)\\n        {\\n            if(Traversal[idx] == depth)\\n            count++;\\n            if(count==2)\\n            break;\\n        }\\n        if(count==2)\\n        {\\n            root->left = buildTree(Traversal,i+2,idx-2);\\n            root->right = buildTree(Traversal,idx,j);\\n        }\\n        else if(count == 1)\\n        {\\n            root->left = buildTree(Traversal,i+2,j);\\n        }\\n        return root;\\n    }\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        vector<int>Traversal;\\n        int i = 0;\\n        while(i<traversal.length() && traversal[i]!=\\'-\\'){\\n            i++;\\n        }\\n        Traversal.push_back(0);\\n        Traversal.push_back(stoi(traversal.substr(0,i)));\\n        int st1 = -1;\\n        int st2 = -1;\\n        int depth = 0;\\n    \\n        for(int idx=i;idx<traversal.length();idx++)\\n        {\\n            if(traversal[idx]!=\\'-\\')\\n            {\\n                if(st2==-1)\\n                {\\n                    st2=idx;\\n                    if(st1!=-1)\\n                    {\\n                        Traversal.push_back(depth);\\n                        depth=0;\\n                        st1=-1;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                if(st1==-1)\\n                {\\n                    st1=idx;\\n                    if(st2!=-1)\\n                    {\\n                        Traversal.push_back(stoi(traversal.substr(st2,idx-st2)));\\n                        st2=-1;\\n                    }\\n                }\\n                depth++;\\n            }\\n        }\\n        if(st2!=-1)\\n        Traversal.push_back(stoi(traversal.substr(st2,traversal.length()-st2)));\\n        \\n        return buildTree(Traversal,0,Traversal.size()-2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* buildTree(vector<int>& Traversal,int i,int j)\\n    {\\n        \\n        if(i >= Traversal.size())\\n        {\\n            return NULL;\\n        }\\n        TreeNode* root = new TreeNode(Traversal[i+1]);\\n        int depth = Traversal[i]+1;\\n        int count = 0;\\n        int idx;\\n        for(idx=i+2;idx<=j;idx+=2)\\n        {\\n            if(Traversal[idx] == depth)\\n            count++;\\n            if(count==2)\\n            break;\\n        }\\n        if(count==2)\\n        {\\n            root->left = buildTree(Traversal,i+2,idx-2);\\n            root->right = buildTree(Traversal,idx,j);\\n        }\\n        else if(count == 1)\\n        {\\n            root->left = buildTree(Traversal,i+2,j);\\n        }\\n        return root;\\n    }\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        vector<int>Traversal;\\n        int i = 0;\\n        while(i<traversal.length() && traversal[i]!=\\'-\\'){\\n            i++;\\n        }\\n        Traversal.push_back(0);\\n        Traversal.push_back(stoi(traversal.substr(0,i)));\\n        int st1 = -1;\\n        int st2 = -1;\\n        int depth = 0;\\n    \\n        for(int idx=i;idx<traversal.length();idx++)\\n        {\\n            if(traversal[idx]!=\\'-\\')\\n            {\\n                if(st2==-1)\\n                {\\n                    st2=idx;\\n                    if(st1!=-1)\\n                    {\\n                        Traversal.push_back(depth);\\n                        depth=0;\\n                        st1=-1;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                if(st1==-1)\\n                {\\n                    st1=idx;\\n                    if(st2!=-1)\\n                    {\\n                        Traversal.push_back(stoi(traversal.substr(st2,idx-st2)));\\n                        st2=-1;\\n                    }\\n                }\\n                depth++;\\n            }\\n        }\\n        if(st2!=-1)\\n        Traversal.push_back(stoi(traversal.substr(st2,traversal.length()-st2)));\\n        \\n        return buildTree(Traversal,0,Traversal.size()-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585008,
                "title": "readable-python-recursive-preorder-construction",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    # recursive preorder construction using dashes to infer linkage\\n    # time: O(n), space: O(n)\\n    def recoverFromPreorder(self, traversal: str) -> TreeNode:\\n        def constructTree() -> TreeNode:\\n            nonlocal index\\n            val, depth = depthMap[index]\\n            root = TreeNode(val)\\n            index += 1\\n\\n            if index == len(depthMap) or depthMap[index][1] != depth+1:\\n                return root\\n            root.left = constructTree()\\n\\n            if index == len(depthMap) or depthMap[index][1] != depth+1:\\n                return root\\n            root.right = constructTree()\\n\\n            return root\\n\\n        def constructDepthMap() -> list:\\n            depthMap = []\\n            i = 0\\n            while i < len(traversal):\\n                depth = 0\\n                while i < len(traversal) and traversal[i] == \\'-\\':\\n                    depth += 1\\n                    i += 1\\n                val = 0\\n                while i < len(traversal) and traversal[i].isdigit():\\n                    val = (val * 10) + int(traversal[i])\\n                    i += 1\\n                depthMap.append((val, depth))\\n            return depthMap\\n\\n        depthMap = constructDepthMap()\\n        index = 0\\n        return constructTree()\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    # recursive preorder construction using dashes to infer linkage\\n    # time: O(n), space: O(n)\\n    def recoverFromPreorder(self, traversal: str) -> TreeNode:\\n        def constructTree() -> TreeNode:\\n            nonlocal index\\n            val, depth = depthMap[index]\\n            root = TreeNode(val)\\n            index += 1\\n\\n            if index == len(depthMap) or depthMap[index][1] != depth+1:\\n                return root\\n            root.left = constructTree()\\n\\n            if index == len(depthMap) or depthMap[index][1] != depth+1:\\n                return root\\n            root.right = constructTree()\\n\\n            return root\\n\\n        def constructDepthMap() -> list:\\n            depthMap = []\\n            i = 0\\n            while i < len(traversal):\\n                depth = 0\\n                while i < len(traversal) and traversal[i] == \\'-\\':\\n                    depth += 1\\n                    i += 1\\n                val = 0\\n                while i < len(traversal) and traversal[i].isdigit():\\n                    val = (val * 10) + int(traversal[i])\\n                    i += 1\\n                depthMap.append((val, depth))\\n            return depthMap\\n\\n        depthMap = constructDepthMap()\\n        index = 0\\n        return constructTree()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581882,
                "title": "dfs-java-tree-traversal-faster-than-94-3ms",
                "content": "# Intuition\\nTraverse the tree and set the children based on the index of the string you are currently traversing.\\n\\n# Approach\\nNot the easiest approach to begin with. 2 helper functions getValue() and getLevel() which calculate the value at the point you are at and level, and also return the index where the next phase of value/level begins. Thus you know that if the current level is where you want to be, then you just mutate the parent by adding a child and run dfs on it making him parent. That\\'s the whore idea.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public static TreeNode recoverFromPreorder(String preorder) {\\n        int[] meta = getValue(0, preorder);\\n        TreeNode root = new TreeNode(meta[1]);\\n        dfs(meta[0], preorder, 0, root);\\n        return root;\\n    }\\n\\n    private static int dfs(int i, String preorder, int curLevel, TreeNode parent) {\\n        if (i == preorder.length()) return i;\\n\\n        int[] levelLeft = getLevel(i, preorder);\\n        if (levelLeft[1] == curLevel + 1) {\\n            int[] valueLeft = getValue(levelLeft[0], preorder);\\n            parent.left = new TreeNode(valueLeft[1]);\\n            int k = dfs(valueLeft[0], preorder, curLevel+1, parent.left);\\n            int[] levelRight = getLevel(k, preorder);\\n            if (levelRight[1] == curLevel + 1) {\\n                int[] valueRight = getValue(levelRight[0], preorder);\\n                parent.right = new TreeNode(valueRight[1]);\\n                return dfs(valueRight[0], preorder, curLevel+1, parent.right);\\n            }\\n            return k;\\n        }\\n        return i;\\n    }\\n\\n    private static int[] getLevel(int i, String preorder) {\\n        int level = 0;\\n        while (i < preorder.length() && preorder.charAt(i) == \\'-\\') {\\n            level++;\\n            i++;\\n        }\\n        return new int[]{i, level};\\n    }\\n\\n    private static int[] getValue(int i, String preorder) {\\n        int j = i;\\n        while (j < preorder.length() && preorder.charAt(j) != \\'-\\') {\\n            j++;\\n        }\\n        return new int[]{j, Integer.parseInt(preorder.substring(i, j))};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public static TreeNode recoverFromPreorder(String preorder) {\\n        int[] meta = getValue(0, preorder);\\n        TreeNode root = new TreeNode(meta[1]);\\n        dfs(meta[0], preorder, 0, root);\\n        return root;\\n    }\\n\\n    private static int dfs(int i, String preorder, int curLevel, TreeNode parent) {\\n        if (i == preorder.length()) return i;\\n\\n        int[] levelLeft = getLevel(i, preorder);\\n        if (levelLeft[1] == curLevel + 1) {\\n            int[] valueLeft = getValue(levelLeft[0], preorder);\\n            parent.left = new TreeNode(valueLeft[1]);\\n            int k = dfs(valueLeft[0], preorder, curLevel+1, parent.left);\\n            int[] levelRight = getLevel(k, preorder);\\n            if (levelRight[1] == curLevel + 1) {\\n                int[] valueRight = getValue(levelRight[0], preorder);\\n                parent.right = new TreeNode(valueRight[1]);\\n                return dfs(valueRight[0], preorder, curLevel+1, parent.right);\\n            }\\n            return k;\\n        }\\n        return i;\\n    }\\n\\n    private static int[] getLevel(int i, String preorder) {\\n        int level = 0;\\n        while (i < preorder.length() && preorder.charAt(i) == \\'-\\') {\\n            level++;\\n            i++;\\n        }\\n        return new int[]{i, level};\\n    }\\n\\n    private static int[] getValue(int i, String preorder) {\\n        int j = i;\\n        while (j < preorder.length() && preorder.charAt(j) != \\'-\\') {\\n            j++;\\n        }\\n        return new int[]{j, Integer.parseInt(preorder.substring(i, j))};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573853,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int, TreeNode *> mp; // depth -> node;\\n        int i = 0, n = traversal.size();\\n\\n        while(i < n) {\\n            int depth = 0;\\n            while(i < n and traversal[i] == \\'-\\') i++, depth++;\\n\\n            string num;\\n            while(i < n and isdigit(traversal[i])) num += traversal[i++];\\n\\n            TreeNode *node = new TreeNode(stoi(num));\\n            if(depth > 0) {\\n                TreeNode *parent = mp[depth - 1];\\n                if(!parent->left) parent->left = node;\\n                else parent->right = node;\\n            }\\n\\n            mp[depth] = node;\\n        }\\n\\n        return mp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int, TreeNode *> mp; // depth -> node;\\n        int i = 0, n = traversal.size();\\n\\n        while(i < n) {\\n            int depth = 0;\\n            while(i < n and traversal[i] == \\'-\\') i++, depth++;\\n\\n            string num;\\n            while(i < n and isdigit(traversal[i])) num += traversal[i++];\\n\\n            TreeNode *node = new TreeNode(stoi(num));\\n            if(depth > 0) {\\n                TreeNode *parent = mp[depth - 1];\\n                if(!parent->left) parent->left = node;\\n                else parent->right = node;\\n            }\\n\\n            mp[depth] = node;\\n        }\\n\\n        return mp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565731,
                "title": "swift-solution-dfs",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    var arrNodesDepth: [(Int, Int)] = []\\n    var tree: TreeNode?\\n    var iteration = 1\\n\\n    func recoverFromPreorder(_ traversal: String) -> TreeNode? {\\n        var depth = 0 \\n        var number: String = \"\"\\n        var endNumber = false\\n\\n        for char in traversal {\\n            if char == \"-\" {\\n                if endNumber {\\n                    arrNodesDepth.append((Int(number)!, depth))\\n                    number = \"\"\\n                    endNumber = false\\n                    depth = 0\\n                }\\n\\n                depth += 1\\n            } else {\\n                number += String(char)\\n                endNumber = true\\n            }\\n        }\\n        arrNodesDepth.append((Int(number)!, depth))\\n\\n        tree = TreeNode(arrNodesDepth[0].0)\\n\\n        dfs(tree, 0)\\n\\n        return tree\\n    }\\n\\n    func dfs(_ node: TreeNode?, _ prevDepth: Int) {\\n        if iteration == arrNodesDepth.count { return }\\n        if arrNodesDepth[iteration].1 > prevDepth {\\n            node?.left = TreeNode(arrNodesDepth[iteration].0)\\n            iteration += 1\\n            dfs(node?.left, prevDepth + 1)\\n        }\\n\\n        if iteration == arrNodesDepth.count { return }\\n        if arrNodesDepth[iteration].1 - 1 == prevDepth {\\n            node?.right = TreeNode(arrNodesDepth[iteration].0)\\n            iteration += 1\\n            dfs(node?.right, prevDepth + 1)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    var arrNodesDepth: [(Int, Int)] = []\\n    var tree: TreeNode?\\n    var iteration = 1\\n\\n    func recoverFromPreorder(_ traversal: String) -> TreeNode? {\\n        var depth = 0 \\n        var number: String = \"\"\\n        var endNumber = false\\n\\n        for char in traversal {\\n            if char == \"-\" {\\n                if endNumber {\\n                    arrNodesDepth.append((Int(number)!, depth))\\n                    number = \"\"\\n                    endNumber = false\\n                    depth = 0\\n                }\\n\\n                depth += 1\\n            } else {\\n                number += String(char)\\n                endNumber = true\\n            }\\n        }\\n        arrNodesDepth.append((Int(number)!, depth))\\n\\n        tree = TreeNode(arrNodesDepth[0].0)\\n\\n        dfs(tree, 0)\\n\\n        return tree\\n    }\\n\\n    func dfs(_ node: TreeNode?, _ prevDepth: Int) {\\n        if iteration == arrNodesDepth.count { return }\\n        if arrNodesDepth[iteration].1 > prevDepth {\\n            node?.left = TreeNode(arrNodesDepth[iteration].0)\\n            iteration += 1\\n            dfs(node?.left, prevDepth + 1)\\n        }\\n\\n        if iteration == arrNodesDepth.count { return }\\n        if arrNodesDepth[iteration].1 - 1 == prevDepth {\\n            node?.right = TreeNode(arrNodesDepth[iteration].0)\\n            iteration += 1\\n            dfs(node?.right, prevDepth + 1)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557806,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\nprivate:\\n    TreeNode *readNode(string &S, int &i) {\\n        int n = 0;\\n        for (; i < S.size() && isdigit(S[i]); ++i) n = 10 * n + S[i] - \\'0\\';\\n        return new TreeNode(n);\\n    }\\n    int readDash(string &S, int &i) {\\n        int cnt = 0;\\n        for (; i < S.size() && S[i] == \\'-\\'; ++i, ++cnt);\\n        return cnt;\\n    }\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        int i = 0, N = S.size();\\n        auto root = readNode(S, i);\\n        stack<TreeNode*> s;\\n        s.push(root);\\n        while (i < S.size()) {\\n            int dep = readDash(S, i);\\n            auto node = readNode(S, i);\\n            while (dep < s.size()) s.pop();\\n            auto p = s.top();\\n            if (p->left) p->right = node;\\n            else p->left = node;\\n            s.push(node);\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution(object):\\n    def recoverFromPreorder(self, S):\\n        vals = [(len(s[1]), int(s[2])) for s in re.findall(\"((-*)(\\\\d+))\", S)][::-1]\\n\\n        def fn(level):\\n            if not vals or level != vals[-1][0]: return None\\n            node = TreeNode(vals.pop()[1])\\n            node.left = fn(level+1)\\n            node.right = fn(level+1)\\n            return node\\n        return fn(0)\\n```\\n\\n```Java []\\nclass Solution {\\n    private int index;\\n    private char[] chars;\\n    \\n    public TreeNode recoverFromPreorder(String S) {\\n        if (S == null || S.length() == 0)\\n            return null;\\n        \\n        index = 0;\\n        chars = S.toCharArray();\\n        \\n        TreeNode root = new TreeNode(getNodeVal());\\n        helper(0, root);\\n        return root;\\n    }\\n    private void helper(int level, TreeNode parent) {\\n        int numOfDashes = getNumOfDashes();\\n        \\n        while (numOfDashes == level + 1) {\\n            index += numOfDashes;\\n            TreeNode newNode = new TreeNode(getNodeVal());\\n            \\n            if (parent.left == null)\\n                parent.left = newNode;\\n            else\\n                parent.right = newNode;\\n            \\n            helper(level + 1, newNode);\\n            \\n            numOfDashes = getNumOfDashes();\\n        }\\n    }\\n    private int getNodeVal() {\\n        if (index >= chars.length)\\n            return -1;\\n        \\n        int count = 0, i;\\n        for (i = index; i < chars.length && chars[i] != \\'-\\'; i++)\\n            count = count * 10 + (chars[i] - \\'0\\');\\n        \\n        index = i;\\n        return count;\\n    }\\n    private int getNumOfDashes() {\\n        if (index >= chars.length)\\n            return -1;\\n        \\n        int count = 0;\\n        for (int i = index; i < chars.length && chars[i] == \\'-\\'; i++)\\n            count ++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    TreeNode *readNode(string &S, int &i) {\\n        int n = 0;\\n        for (; i < S.size() && isdigit(S[i]); ++i) n = 10 * n + S[i] - \\'0\\';\\n        return new TreeNode(n);\\n    }\\n    int readDash(string &S, int &i) {\\n        int cnt = 0;\\n        for (; i < S.size() && S[i] == \\'-\\'; ++i, ++cnt);\\n        return cnt;\\n    }\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        int i = 0, N = S.size();\\n        auto root = readNode(S, i);\\n        stack<TreeNode*> s;\\n        s.push(root);\\n        while (i < S.size()) {\\n            int dep = readDash(S, i);\\n            auto node = readNode(S, i);\\n            while (dep < s.size()) s.pop();\\n            auto p = s.top();\\n            if (p->left) p->right = node;\\n            else p->left = node;\\n            s.push(node);\\n        }\\n        return root;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution(object):\\n    def recoverFromPreorder(self, S):\\n        vals = [(len(s[1]), int(s[2])) for s in re.findall(\"((-*)(\\\\d+))\", S)][::-1]\\n\\n        def fn(level):\\n            if not vals or level != vals[-1][0]: return None\\n            node = TreeNode(vals.pop()[1])\\n            node.left = fn(level+1)\\n            node.right = fn(level+1)\\n            return node\\n        return fn(0)\\n```\n```Java []\\nclass Solution {\\n    private int index;\\n    private char[] chars;\\n    \\n    public TreeNode recoverFromPreorder(String S) {\\n        if (S == null || S.length() == 0)\\n            return null;\\n        \\n        index = 0;\\n        chars = S.toCharArray();\\n        \\n        TreeNode root = new TreeNode(getNodeVal());\\n        helper(0, root);\\n        return root;\\n    }\\n    private void helper(int level, TreeNode parent) {\\n        int numOfDashes = getNumOfDashes();\\n        \\n        while (numOfDashes == level + 1) {\\n            index += numOfDashes;\\n            TreeNode newNode = new TreeNode(getNodeVal());\\n            \\n            if (parent.left == null)\\n                parent.left = newNode;\\n            else\\n                parent.right = newNode;\\n            \\n            helper(level + 1, newNode);\\n            \\n            numOfDashes = getNumOfDashes();\\n        }\\n    }\\n    private int getNodeVal() {\\n        if (index >= chars.length)\\n            return -1;\\n        \\n        int count = 0, i;\\n        for (i = index; i < chars.length && chars[i] != \\'-\\'; i++)\\n            count = count * 10 + (chars[i] - \\'0\\');\\n        \\n        index = i;\\n        return count;\\n    }\\n    private int getNumOfDashes() {\\n        if (index >= chars.length)\\n            return -1;\\n        \\n        int count = 0;\\n        for (int i = index; i < chars.length && chars[i] == \\'-\\'; i++)\\n            count ++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554851,
                "title": "unordered-map-c-solution",
                "content": "# Intuition \\nalways parent will be read first then child\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\napproach is to use unordered map and store nodes based on depth. connect child nodes with parent node\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n       \\n        int str_length=traversal.length();\\n        if(str_length==0)\\n        {\\n            return nullptr;\\n        }\\n        unordered_map<int,vector<TreeNode*>> mpp;\\n        \\n         int start_no=0;\\n        int curr_depth=0;\\n        int index=0;\\n        while(traversal[index]!=\\'-\\' && index<str_length)\\n            {\\n                index++;\\n            }\\n            int end_no=index;\\n            string s=traversal.substr(start_no,end_no-start_no);\\n            int number= stoi(s);\\n              TreeNode* head=new TreeNode(number);\\n            mpp[curr_depth].push_back(head);\\n       \\n        int i=end_no;\\n        while(i<str_length)\\n        {\\n            curr_depth=0;\\n            while(traversal[i]==\\'-\\' && i<str_length)\\n            {\\n              curr_depth++;\\n              i++;\\n            }\\n            int start_index=i;\\n            while(traversal[i]!=\\'-\\' && i<str_length)\\n            {\\n                i++;\\n            }\\n            int end_index=i;\\n            string s=traversal.substr(start_index,end_index-start_index);\\n            number= stoi(s);\\n        \\n                TreeNode* temp= new TreeNode(number);\\n\\n                 TreeNode* parent=mpp[curr_depth-1].back();\\n                if(parent->left==nullptr)\\n                {\\n                    parent->left=temp;\\n                }\\n                else\\n                {\\n                    parent->right=temp;\\n                }\\n                mpp[curr_depth].push_back(temp);\\n            }\\n\\n        return head;\\n        }\\n\\n        \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n       \\n        int str_length=traversal.length();\\n        if(str_length==0)\\n        {\\n            return nullptr;\\n        }\\n        unordered_map<int,vector<TreeNode*>> mpp;\\n        \\n         int start_no=0;\\n        int curr_depth=0;\\n        int index=0;\\n        while(traversal[index]!=\\'-\\' && index<str_length)\\n            {\\n                index++;\\n            }\\n            int end_no=index;\\n            string s=traversal.substr(start_no,end_no-start_no);\\n            int number= stoi(s);\\n              TreeNode* head=new TreeNode(number);\\n            mpp[curr_depth].push_back(head);\\n       \\n        int i=end_no;\\n        while(i<str_length)\\n        {\\n            curr_depth=0;\\n            while(traversal[i]==\\'-\\' && i<str_length)\\n            {\\n              curr_depth++;\\n              i++;\\n            }\\n            int start_index=i;\\n            while(traversal[i]!=\\'-\\' && i<str_length)\\n            {\\n                i++;\\n            }\\n            int end_index=i;\\n            string s=traversal.substr(start_index,end_index-start_index);\\n            number= stoi(s);\\n        \\n                TreeNode* temp= new TreeNode(number);\\n\\n                 TreeNode* parent=mpp[curr_depth-1].back();\\n                if(parent->left==nullptr)\\n                {\\n                    parent->left=temp;\\n                }\\n                else\\n                {\\n                    parent->right=temp;\\n                }\\n                mpp[curr_depth].push_back(temp);\\n            }\\n\\n        return head;\\n        }\\n\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553271,
                "title": "c-stack-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\nint readnum(string& s, int& ind) {\\n    int res = 0;\\n    while (ind < s.size() &&  s[ind] != \\'-\\') {\\n        res = res * 10 + s[ind] - \\'0\\';\\n        ++ind;\\n    }\\n    return res;\\n}\\n\\nint readlevel(string& s, int& ind) {\\n    int res = 0;\\n    while (ind < s.size() &&  s[ind] == \\'-\\') {\\n        res++;\\n        ++ind;\\n    }\\n    return res;\\n}\\n\\npublic:\\n    TreeNode* recoverFromPreorder(string s) {\\n        \\n        int i = 0;\\n        int num = readnum(s, i);\\n        auto head = new TreeNode(num);\\n\\n        stack<TreeNode*> st;\\n        st.push(head);\\n\\n        while (!st.empty()) {\\n            int lev = st.size();\\n            auto cur = st.top(); \\n\\n            if (i == s.size()) break;\\n\\n            int tmp = i;\\n            int lev1 = readlevel(s, i);\\n            if ( lev1 < lev) {\\n                i = tmp;\\n                st.pop();\\n                continue;\\n            }\\n\\n            if (lev == lev1) {\\n                int num1 = readnum(s, i);\\n                if (cur->left == nullptr) {\\n                    cur->left = new TreeNode(num1);\\n                    st.push(cur->left);\\n                } else {\\n                    cur->right = new TreeNode(num1);\\n                    st.push(cur->right);\\n                }\\n\\n                if (i == s.size()) break;\\n            }\\n\\n        }\\n\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\nint readnum(string& s, int& ind) {\\n    int res = 0;\\n    while (ind < s.size() &&  s[ind] != \\'-\\') {\\n        res = res * 10 + s[ind] - \\'0\\';\\n        ++ind;\\n    }\\n    return res;\\n}\\n\\nint readlevel(string& s, int& ind) {\\n    int res = 0;\\n    while (ind < s.size() &&  s[ind] == \\'-\\') {\\n        res++;\\n        ++ind;\\n    }\\n    return res;\\n}\\n\\npublic:\\n    TreeNode* recoverFromPreorder(string s) {\\n        \\n        int i = 0;\\n        int num = readnum(s, i);\\n        auto head = new TreeNode(num);\\n\\n        stack<TreeNode*> st;\\n        st.push(head);\\n\\n        while (!st.empty()) {\\n            int lev = st.size();\\n            auto cur = st.top(); \\n\\n            if (i == s.size()) break;\\n\\n            int tmp = i;\\n            int lev1 = readlevel(s, i);\\n            if ( lev1 < lev) {\\n                i = tmp;\\n                st.pop();\\n                continue;\\n            }\\n\\n            if (lev == lev1) {\\n                int num1 = readnum(s, i);\\n                if (cur->left == nullptr) {\\n                    cur->left = new TreeNode(num1);\\n                    st.push(cur->left);\\n                } else {\\n                    cur->right = new TreeNode(num1);\\n                    st.push(cur->right);\\n                }\\n\\n                if (i == s.size()) break;\\n            }\\n\\n        }\\n\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1697214,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "2leetcode: Why this one is hard? Why??? Really don\\'t understand how you guys pick the difficulty level, often u mark medium as hard, and vise versa. Don\\'t you think you should base your decision on acceptance rate? like >75% -> easy, 45-74 -> medium, and < 45 - hard or something like that? Seems more reasonable to me than your \\'estimations\\' "
                    },
                    {
                        "username": "KautsIITD",
                        "content": "But there can be questions which are hard to solve but don\\'t have much Edge cases to Fail once implemented, Hence higher success rate while taking sufficient time to implement.."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed, this one seems very doable (haven\\'t tried it yet). I just did 1443, which seems way harder. Maybe have peoplpe vote after they completed it, there are a couple weird ones out there. Although acceptance rate says more about if there are test cases people haven\\'t thought of right?"
                    },
                    {
                        "username": "yzch1128",
                        "content": "I was asked a very similar question during a FAANG on-site interview. But that question was better wrapped and you had to realize it is in fact a preorder sequence of an n-ary tree and then rebuild it, and then do some traversal to implement some other functions required by the interviewer. The interview was only 45mins and you had at most 40mins for the coding, and this question is like the first half of the coding.\\nSo if you are able to understand and code this problem bug free within 20 mins, you should be more than qualify to pass FAANG coding interview.\\nThe question itself is definitely not hard."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Should be under medium to easy category."
                    }
                ]
            },
            {
                "id": 2061944,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "2leetcode: Why this one is hard? Why??? Really don\\'t understand how you guys pick the difficulty level, often u mark medium as hard, and vise versa. Don\\'t you think you should base your decision on acceptance rate? like >75% -> easy, 45-74 -> medium, and < 45 - hard or something like that? Seems more reasonable to me than your \\'estimations\\' "
                    },
                    {
                        "username": "KautsIITD",
                        "content": "But there can be questions which are hard to solve but don\\'t have much Edge cases to Fail once implemented, Hence higher success rate while taking sufficient time to implement.."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed, this one seems very doable (haven\\'t tried it yet). I just did 1443, which seems way harder. Maybe have peoplpe vote after they completed it, there are a couple weird ones out there. Although acceptance rate says more about if there are test cases people haven\\'t thought of right?"
                    },
                    {
                        "username": "yzch1128",
                        "content": "I was asked a very similar question during a FAANG on-site interview. But that question was better wrapped and you had to realize it is in fact a preorder sequence of an n-ary tree and then rebuild it, and then do some traversal to implement some other functions required by the interviewer. The interview was only 45mins and you had at most 40mins for the coding, and this question is like the first half of the coding.\\nSo if you are able to understand and code this problem bug free within 20 mins, you should be more than qualify to pass FAANG coding interview.\\nThe question itself is definitely not hard."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Should be under medium to easy category."
                    }
                ]
            },
            {
                "id": 1869174,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "2leetcode: Why this one is hard? Why??? Really don\\'t understand how you guys pick the difficulty level, often u mark medium as hard, and vise versa. Don\\'t you think you should base your decision on acceptance rate? like >75% -> easy, 45-74 -> medium, and < 45 - hard or something like that? Seems more reasonable to me than your \\'estimations\\' "
                    },
                    {
                        "username": "KautsIITD",
                        "content": "But there can be questions which are hard to solve but don\\'t have much Edge cases to Fail once implemented, Hence higher success rate while taking sufficient time to implement.."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed, this one seems very doable (haven\\'t tried it yet). I just did 1443, which seems way harder. Maybe have peoplpe vote after they completed it, there are a couple weird ones out there. Although acceptance rate says more about if there are test cases people haven\\'t thought of right?"
                    },
                    {
                        "username": "yzch1128",
                        "content": "I was asked a very similar question during a FAANG on-site interview. But that question was better wrapped and you had to realize it is in fact a preorder sequence of an n-ary tree and then rebuild it, and then do some traversal to implement some other functions required by the interviewer. The interview was only 45mins and you had at most 40mins for the coding, and this question is like the first half of the coding.\\nSo if you are able to understand and code this problem bug free within 20 mins, you should be more than qualify to pass FAANG coding interview.\\nThe question itself is definitely not hard."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Should be under medium to easy category."
                    }
                ]
            }
        ]
    }
]