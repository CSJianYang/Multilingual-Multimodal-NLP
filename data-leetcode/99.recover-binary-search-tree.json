[
    {
        "title": "Recover Binary Search Tree",
        "question_content": "You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.\n&nbsp;\nExample 1:\n\nInput: root = [1,3,null,null,2]\nOutput: [3,1,null,null,2]\nExplanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.\n\nExample 2:\n\nInput: root = [3,1,4,null,null,2]\nOutput: [2,1,4,null,null,3]\nExplanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [2, 1000].\n\t-231 <= Node.val <= 231 - 1\n\n&nbsp;\nFollow up: A solution using O(n) space is pretty straight-forward. Could you devise a constant O(1) space solution?",
        "solutions": [
            {
                "id": 32535,
                "title": "no-fancy-algorithm-just-simple-and-powerful-in-order-traversal",
                "content": "This question appeared difficult to me but it is really just a simple in-order traversal! I got really frustrated when other people are showing off Morris Traversal which is totally not necessary here. \\n\\nLet's start by writing the in order traversal:\\n\\n    private void traverse (TreeNode root) {\\n       if (root == null)\\n          return;\\n       traverse(root.left);\\n       // Do some business\\n       traverse(root.right);\\n    }\\n\\nSo when we need to print the node values in order, we insert System.out.println(root.val) in the place of \"Do some business\".\\n\\nWhat is the business we are doing here?\\nWe need to find the first and second elements that are not in order right?\\n\\nHow do we find these two elements? For example, we have the following tree that is printed as in order traversal:\\n\\n6, 3, 4, 5, 2\\n\\nWe compare each node with its next one and we can find out that 6 is the first element to swap because 6 > 3 and 2 is the second element to swap because 2 < 5.\\n\\nReally, what we are comparing is the current node and its previous node in the \"in order traversal\". \\n\\nLet us define three variables, firstElement, secondElement, and prevElement. Now we just need to build the \"do some business\" logic as finding the two elements. See the code below:\\n\\n    public class Solution {\\n        \\n        TreeNode firstElement = null;\\n        TreeNode secondElement = null;\\n        // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized\\n        TreeNode prevElement = new TreeNode(Integer.MIN_VALUE);\\n        \\n        public void recoverTree(TreeNode root) {\\n            \\n            // In order traversal to find the two elements\\n            traverse(root);\\n            \\n            // Swap the values of the two nodes\\n            int temp = firstElement.val;\\n            firstElement.val = secondElement.val;\\n            secondElement.val = temp;\\n        }\\n        \\n        private void traverse(TreeNode root) {\\n            \\n            if (root == null)\\n                return;\\n                \\n            traverse(root.left);\\n            \\n            // Start of \"do some business\", \\n            // If first element has not been found, assign it to prevElement (refer to 6 in the example above)\\n            if (firstElement == null && prevElement.val >= root.val) {\\n                firstElement = prevElement;\\n            }\\n        \\n            // If first element is found, assign the second element to the root (refer to 2 in the example above)\\n            if (firstElement != null && prevElement.val >= root.val) {\\n                secondElement = root;\\n            }        \\n            prevElement = root;\\n\\n            // End of \"do some business\"\\n\\n            traverse(root.right);\\n    }\\n\\nAnd we are done, it is just that easy!",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        TreeNode firstElement = null;\\n        TreeNode secondElement = null;\\n        // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized\\n        TreeNode prevElement = new TreeNode(Integer.MIN_VALUE);\\n        \\n        public void recoverTree(TreeNode root) {\\n            \\n            // In order traversal to find the two elements\\n            traverse(root);\\n            \\n            // Swap the values of the two nodes\\n            int temp = firstElement.val;\\n            firstElement.val = secondElement.val;\\n            secondElement.val = temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32559,
                "title": "detail-explain-about-how-morris-traversal-finds-two-incorrect-pointer",
                "content": "To understand this, you need to first understand Morris Traversal or Morris Threading Traversal.\\nIt take use of leaf nodes' right/left pointer to achieve O(1) space Traversal on a Binary Tree.\\nBelow is a standard Inorder Morris Traversal, referred from http://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html (a Chinese Blog, while the graphs are great for illustration)\\n\\n    public void morrisTraversal(TreeNode root){\\n    \\t\\tTreeNode temp = null;\\n    \\t\\twhile(root!=null){\\n    \\t\\t\\tif(root.left!=null){\\n    \\t\\t\\t\\t// connect threading for root\\n    \\t\\t\\t\\ttemp = root.left;\\n    \\t\\t\\t\\twhile(temp.right!=null && temp.right != root)\\n    \\t\\t\\t\\t\\ttemp = temp.right;\\n    \\t\\t\\t\\t// the threading already exists\\n    \\t\\t\\t\\tif(temp.right!=null){\\n    \\t\\t\\t\\t\\ttemp.right = null;\\n    \\t\\t\\t\\t\\tSystem.out.println(root.val);\\n    \\t\\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t\\t}else{\\n    \\t\\t\\t\\t\\t// construct the threading\\n    \\t\\t\\t\\t\\ttemp.right = root;\\n    \\t\\t\\t\\t\\troot = root.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tSystem.out.println(root.val);\\n    \\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n\\nIn the above code, `System.out.println(root.val);`appear twice, which functions as outputing the Node in ascending order (BST). Since these places are in order, replace them with\\n\\n        if(pre!=null && pre.val > root.val){\\n        \\tif(first==null){first = pre;second = root;}\\n        \\telse{second = root;}\\n      }\\n    pre = root;\\n\\neach time, the pre node and root are in order as `System.out.println(root.val);` outputs them in order.\\n\\nThen, come to how to specify the first wrong node and second wrong node.\\n\\nWhen they are not consecutive, the first time we meet `pre.val > root.val` ensure us the first node is the pre node, since root should be traversal ahead of pre, pre should be at least at small as root. The second time we meet `pre.val > root.val` ensure us the second node is the root node, since we are now looking for a node to replace with out first node, which is found before.\\n\\nWhen they are consecutive, which means the case `pre.val > cur.val` will appear only once. We need to take case this case without destroy the previous analysis. So the first node will still be pre, and the second will be just set to root. Once we meet this case again, the first node will not be affected.\\n\\nBelow is the updated version on Morris Traversal.\\n\\n\\n    public void recoverTree(TreeNode root) {\\n            TreeNode pre = null;\\n            TreeNode first = null, second = null;\\n            // Morris Traversal\\n            TreeNode temp = null;\\n    \\t\\twhile(root!=null){\\n    \\t\\t\\tif(root.left!=null){\\n    \\t\\t\\t\\t// connect threading for root\\n    \\t\\t\\t\\ttemp = root.left;\\n    \\t\\t\\t\\twhile(temp.right!=null && temp.right != root)\\n    \\t\\t\\t\\t\\ttemp = temp.right;\\n    \\t\\t\\t\\t// the threading already exists\\n    \\t\\t\\t\\tif(temp.right!=null){\\n    \\t\\t\\t\\t    if(pre!=null && pre.val > root.val){\\n    \\t\\t\\t\\t        if(first==null){first = pre;second = root;}\\n    \\t\\t\\t\\t        else{second = root;}\\n    \\t\\t\\t\\t    }\\n    \\t\\t\\t\\t    pre = root;\\n    \\t\\t\\t\\t    \\n    \\t\\t\\t\\t\\ttemp.right = null;\\n    \\t\\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t\\t}else{\\n    \\t\\t\\t\\t\\t// construct the threading\\n    \\t\\t\\t\\t\\ttemp.right = root;\\n    \\t\\t\\t\\t\\troot = root.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tif(pre!=null && pre.val > root.val){\\n    \\t\\t\\t\\t    if(first==null){first = pre;second = root;}\\n    \\t\\t\\t\\t    else{second = root;}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tpre = root;\\n    \\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t// swap two node values;\\n    \\t\\tif(first!= null && second != null){\\n    \\t\\t    int t = first.val;\\n    \\t\\t    first.val = second.val;\\n    \\t\\t    second.val = t;\\n    \\t\\t}\\n        }",
                "solutionTags": [],
                "code": "To understand this, you need to first understand Morris Traversal or Morris Threading Traversal.\\nIt take use of leaf nodes' right/left pointer to achieve O(1) space Traversal on a Binary Tree.\\nBelow is a standard Inorder Morris Traversal, referred from http://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html (a Chinese Blog, while the graphs are great for illustration)\\n\\n    public void morrisTraversal(TreeNode root){\\n    \\t\\tTreeNode temp = null;\\n    \\t\\twhile(root!=null){\\n    \\t\\t\\tif(root.left!=null){\\n    \\t\\t\\t\\t// connect threading for root\\n    \\t\\t\\t\\ttemp = root.left;\\n    \\t\\t\\t\\twhile(temp.right!=null && temp.right != root)\\n    \\t\\t\\t\\t\\ttemp = temp.right;\\n    \\t\\t\\t\\t// the threading already exists\\n    \\t\\t\\t\\tif(temp.right!=null){\\n    \\t\\t\\t\\t\\ttemp.right = null;\\n    \\t\\t\\t\\t\\tSystem.out.println(root.val);\\n    \\t\\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t\\t}else{\\n    \\t\\t\\t\\t\\t// construct the threading\\n    \\t\\t\\t\\t\\ttemp.right = root;\\n    \\t\\t\\t\\t\\troot = root.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tSystem.out.println(root.val);\\n    \\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n\\nIn the above code, `System.out.println(root.val);`appear twice, which functions as outputing the Node in ascending order (BST). Since these places are in order, replace them with\\n\\n        if(pre!=null && pre.val > root.val){\\n        \\tif(first==null){first = pre;second = root;}\\n        \\telse{second = root;}\\n      }\\n    pre = root;\\n\\neach time, the pre node and root are in order as `System.out.println(root.val);` outputs them in order.\\n\\nThen, come to how to specify the first wrong node and second wrong node.\\n\\nWhen they are not consecutive, the first time we meet `pre.val > root.val` ensure us the first node is the pre node, since root should be traversal ahead of pre, pre should be at least at small as root. The second time we meet `pre.val > root.val` ensure us the second node is the root node, since we are now looking for a node to replace with out first node, which is found before.\\n\\nWhen they are consecutive, which means the case `pre.val > cur.val` will appear only once. We need to take case this case without destroy the previous analysis. So the first node will still be pre, and the second will be just set to root. Once we meet this case again, the first node will not be affected.\\n\\nBelow is the updated version on Morris Traversal.\\n\\n\\n    public void recoverTree(TreeNode root) {\\n            TreeNode pre = null;\\n            TreeNode first = null, second = null;\\n            // Morris Traversal\\n            TreeNode temp = null;\\n    \\t\\twhile(root!=null){\\n    \\t\\t\\tif(root.left!=null){\\n    \\t\\t\\t\\t// connect threading for root\\n    \\t\\t\\t\\ttemp = root.left;\\n    \\t\\t\\t\\twhile(temp.right!=null && temp.right != root)\\n    \\t\\t\\t\\t\\ttemp = temp.right;\\n    \\t\\t\\t\\t// the threading already exists\\n    \\t\\t\\t\\tif(temp.right!=null){\\n    \\t\\t\\t\\t    if(pre!=null && pre.val > root.val){\\n    \\t\\t\\t\\t        if(first==null){first = pre;second = root;}\\n    \\t\\t\\t\\t        else{second = root;}\\n    \\t\\t\\t\\t    }\\n    \\t\\t\\t\\t    pre = root;\\n    \\t\\t\\t\\t    \\n    \\t\\t\\t\\t\\ttemp.right = null;\\n    \\t\\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t\\t}else{\\n    \\t\\t\\t\\t\\t// construct the threading\\n    \\t\\t\\t\\t\\ttemp.right = root;\\n    \\t\\t\\t\\t\\troot = root.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tif(pre!=null && pre.val > root.val){\\n    \\t\\t\\t\\t    if(first==null){first = pre;second = root;}\\n    \\t\\t\\t\\t    else{second = root;}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tpre = root;\\n    \\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t// swap two node values;\\n    \\t\\tif(first!= null && second != null){\\n    \\t\\t    int t = first.val;\\n    \\t\\t    first.val = second.val;\\n    \\t\\t    second.val = t;\\n    \\t\\t}\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 32539,
                "title": "tree-deserializer-and-visualizer-for-python",
                "content": "Wrote some tools for my own local testing. For example `deserialize('[1,2,3,null,null,4,null,null,5]')` will turn that into a tree and return the root [as explained in the FAQ](https://leetcode.com/faq/). I also wrote a visualizer. Two examples:\\n\\n`drawtree(deserialize('[1,2,3,null,null,4,null,null,5]'))`:\\n\\n![enter image description here][1]\\n\\n`drawtree(deserialize('[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]'))`:\\n\\n![enter image description here][2]\\n\\nHere's the code. If you save it as a Python script and run it, it should as a demo show the above two pictures in turtle windows (one after the other). And you can of course import it from other scripts and then it will only provide the class/functions and not show the demo.\\n\\n    class TreeNode:\\n        def __init__(self, val, left=None, right=None):\\n            self.val = val\\n            self.left = left\\n            self.right = right\\n        def __repr__(self):\\n            return 'TreeNode({})'.format(self.val)\\n        \\n    def deserialize(string):\\n        if string == '{}':\\n            return None\\n        nodes = [None if val == 'null' else TreeNode(int(val))\\n                 for val in string.strip('[]{}').split(',')]\\n        kids = nodes[::-1]\\n        root = kids.pop()\\n        for node in nodes:\\n            if node:\\n                if kids: node.left  = kids.pop()\\n                if kids: node.right = kids.pop()\\n        return root\\n    \\n    def drawtree(root):\\n        def height(root):\\n            return 1 + max(height(root.left), height(root.right)) if root else -1\\n        def jumpto(x, y):\\n            t.penup()\\n            t.goto(x, y)\\n            t.pendown()\\n        def draw(node, x, y, dx):\\n            if node:\\n                t.goto(x, y)\\n                jumpto(x, y-20)\\n                t.write(node.val, align='center', font=('Arial', 12, 'normal'))\\n                draw(node.left, x-dx, y-60, dx/2)\\n                jumpto(x, y-20)\\n                draw(node.right, x+dx, y-60, dx/2)\\n        import turtle\\n        t = turtle.Turtle()\\n        t.speed(0); turtle.delay(0)\\n        h = height(root)\\n        jumpto(0, 30*h)\\n        draw(root, 0, 30*h, 40*h)\\n        t.hideturtle()\\n        turtle.mainloop()\\n        \\n    if __name__ == '__main__':\\n        drawtree(deserialize('[1,2,3,null,null,4,null,null,5]'))\\n        drawtree(deserialize('[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]'))\\n\\n  [1]: http://pochmann.org/leetcode/images/tree1.png\\n  [2]: http://pochmann.org/leetcode/images/tree2.png",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "Wrote some tools for my own local testing. For example `deserialize('[1,2,3,null,null,4,null,null,5]')` will turn that into a tree and return the root [as explained in the FAQ](https://leetcode.com/faq/). I also wrote a visualizer. Two examples:\\n\\n`drawtree(deserialize('[1,2,3,null,null,4,null,null,5]'))`:\\n\\n![enter image description here][1]\\n\\n`drawtree(deserialize('[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]'))`:\\n\\n![enter image description here][2]\\n\\nHere's the code. If you save it as a Python script and run it, it should as a demo show the above two pictures in turtle windows (one after the other). And you can of course import it from other scripts and then it will only provide the class/functions and not show the demo.\\n\\n    class TreeNode:\\n        def __init__(self, val, left=None, right=None):\\n            self.val = val\\n            self.left = left\\n            self.right = right\\n        def __repr__(self):\\n            return 'TreeNode({})'.format(self.val)\\n        \\n    def deserialize(string):\\n        if string == '{}':\\n            return None\\n        nodes = [None if val == 'null' else TreeNode(int(val))\\n                 for val in string.strip('[]{}').split(',')]\\n        kids = nodes[::-1]\\n        root = kids.pop()\\n        for node in nodes:\\n            if node:\\n                if kids: node.left  = kids.pop()\\n                if kids: node.right = kids.pop()\\n        return root\\n    \\n    def drawtree(root):\\n        def height(root):\\n            return 1 + max(height(root.left), height(root.right)) if root else -1\\n        def jumpto(x, y):\\n            t.penup()\\n            t.goto(x, y)\\n            t.pendown()\\n        def draw(node, x, y, dx):\\n            if node:\\n                t.goto(x, y)\\n                jumpto(x, y-20)\\n                t.write(node.val, align='center', font=('Arial', 12, 'normal'))\\n                draw(node.left, x-dx, y-60, dx/2)\\n                jumpto(x, y-20)\\n                draw(node.right, x+dx, y-60, dx/2)\\n        import turtle\\n        t = turtle.Turtle()\\n        t.speed(0); turtle.delay(0)\\n        h = height(root)\\n        jumpto(0, 30*h)\\n        draw(root, 0, 30*h, 40*h)\\n        t.hideturtle()\\n        turtle.mainloop()\\n        \\n    if __name__ == '__main__':\\n        drawtree(deserialize('[1,2,3,null,null,4,null,null,5]'))\\n        drawtree(deserialize('[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]'))\\n\\n  [1]: http://pochmann.org/leetcode/images/tree1.png\\n  [2]: http://pochmann.org/leetcode/images/tree2.png",
                "codeTag": "Java"
            },
            {
                "id": 1962981,
                "title": "idea-inorder-traversal-easy-to-understand",
                "content": "I will try to explain the approach using diagrams and pseudo code : \\n\\n![image](https://assets.leetcode.com/users/images/452c1932-e252-4a64-a745-66cb4ef08b1a_1650349299.0155501.jpeg)\\n![image](https://assets.leetcode.com/users/images/66d468cc-dd11-4a36-958d-6ad68956ef96_1650349307.373912.jpeg)\\n\\nNow try to implement the actual problem.\\nHints : Firstly write the inorder traversal and try to follow the array approach of updating the prev,first and second and you will be able to solve it. \\nHere is my solution : \\n```\\nclass Solution {\\n    TreeNode prev=null,first=null,second=null;\\n    void inorder(TreeNode root){\\n        if(root==null)\\n            return ;\\n        inorder(root.left);\\n        if(prev!=null&&root.val<prev.val){\\n            if(first==null)\\n                first=prev;\\n            second=root;\\n        }\\n        prev=root;\\n        inorder(root.right);\\n    }\\n    public void recoverTree(TreeNode root) {\\n        if(root==null)\\n            return ; \\n        inorder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n}\\n```\\n\\nHope you understood the approach :)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev=null,first=null,second=null;\\n    void inorder(TreeNode root){\\n        if(root==null)\\n            return ;\\n        inorder(root.left);\\n        if(prev!=null&&root.val<prev.val){\\n            if(first==null)\\n                first=prev;\\n            second=root;\\n        }\\n        prev=root;\\n        inorder(root.right);\\n    }\\n    public void recoverTree(TreeNode root) {\\n        if(root==null)\\n            return ; \\n        inorder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32562,
                "title": "share-my-solutions-and-detailed-explanation-with-recursive-iterative-in-order-traversal-and-morris-traversal",
                "content": "In-order traversal is really useful in BST. Following in-order traversal, we should have following order: prev.val < curr.val. If not, then we found at least one incorrectly placed node\\n\\nSo the basic idea is to visit the tree with in-order traversal and search for two swapped nodes. Then swap them back.\\n\\nNow the problem is if we found an incorrect pair where prev.val > curr.val, how do we know which node is the incorrect one?  The answer is it depends on whether we have found incorrect node before. So What is that?\\n\\nSince we get two elements that are swapped by mistake, there must be a smaller TreeNode get a larger value and a larger TreeNode get a smaller value.\\nTheir value are swapped, but the incorrect smaller node is still in smaller tree and incorrect larger node is still in larger tree. So we will visit the incorrect smaller node first, and this node will be detected when we compare its value with next.val, i.e.  when it is treated as prev node. The incorrect larger node will be detected when we compare its value with prev.val. We don't know if it is close or not close to incorrect smaller node, so we should continue search BST and update it if we found another incorrect node.\\n\\nTherefore if it is the first time we found an incorrect pair, the prev node must be the first incorrect node.\\nIf it is not the first time we found an incorrect pair, the curr node must be the second incorrect node, though\\nwe may have corner case that two incorrect nodes are in same pair.\\n\\nRecursive in-order traversal based on above idea:\\n\\n    public void recoverTree(TreeNode root) {\\n        //use inorder traversal to detect incorrect node\\n        \\n        inOrder(root);\\n        \\n\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    TreeNode prev = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    \\n    public void inOrder(TreeNode root){\\n        if(root == null) return;\\n        //search left tree\\n        inOrder(root.left);\\n        \\n        //in inorder traversal of BST, prev should always have smaller value than current value\\n        if(prev != null && prev.val >= root.val){\\n            //incorrect smaller node is always found as prev node\\n            if(first == null) first = prev;\\n          //incorrect larger node is always found as curr(root) node\\n            second = root;\\n        }\\n        \\n        \\n        //update prev node\\n        prev = root;\\n\\n        //search right tree\\n        inOrder(root.right);\\n    }\\n\\n\\niterative in-order traversal based on above idea:\\n\\n\\n    public void recoverTree(TreeNode root) {\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        \\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        while(!stack.isEmpty() ||  curr != null){\\n            if(curr != null){\\n                //visit curr's left subtree\\n                stack.push(curr);\\n                curr = curr.left;\\n            }else{\\n                //done left subtree of curr Node\\n                curr = stack.pop();\\n                \\n                //compare curr.val with prev.val if we have one\\n                if(prev != null && curr.val <= prev.val){\\n                    //incorrect smaller node is always found as prev node\\n                    if(first == null) first = prev;\\n                    //incorrect larger node is always found as curr node\\n                    second = curr;         \\n                }  \\n                \\n                //visit curr's right subtree\\n                prev = curr;\\n                curr = curr.right;\\n            }\\n        }\\n        \\n        //recover swapped nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\nBoth recursive and iterative will occupy O(n) space in worst case, in which the tree is like a LinkedList\\n\\nTo reduce the space to constant space, we have to use Morris-traversal.\\n\\nMorris-traversal is similar to recursive/iterative traversal, but we need to modify the tree structure during the\\ntraversal.  before we visiting the left tree of a root, we will build a back-edge between rightmost node in left tree and the root. So we can go back to the root node after we are done with the left tree. Then we locate the rightmost node in left subtree again, cut the back-edge, recover the tree structure and start visit right subtree. The detection of two incorrect TreeNodes is similar to iterative/recursive in-order traversal.\\nWe don't use extra data structure here, so the space complexity is reduced to O(1) and the time complexity will be O(n)\\n\\nMorris-traversal based on above description:\\n\\n    public void recoverTree(TreeNode root) {\\n    \\t//Morris-traversal\\n    \\t\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        \\n        TreeNode pred = null; //rightmost node in left tree\\n        TreeNode prev = null; \\n        \\n        TreeNode curr = root;\\n        \\n        while(curr != null){\\n            //for each node, we compare it with prev node as we did in in-order-traversal\\n            if(prev != null && curr.val <= prev.val){\\n                if(first == null) first = prev;\\n                second = curr;\\n            }\\n            \\n            if(curr.left != null){\\n                //got left tree, then let's locate its rightmost node in left tree\\n                pred = curr.left;\\n                //we may have visited the left tree before, and connect the rightmost node with curr node (root node)\\n                while(pred.right != null && pred.right != curr){\\n                    pred = pred.right;\\n                }\\n                \\n                if(pred.right == curr){\\n                    //if this left tree has been visited before, then we are done with it\\n                    //cut the connection with currNode and start visit curr's right tree\\n                    pred.right = null;\\n                    prev = curr;\\n                    curr = curr.right;\\n                }else{\\n                    //if this left tree has not been visited before, then we create a back edge from rightmost node\\n                    // to curr node, so we can return to the start point after done the left tree\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }\\n                \\n            }else{\\n                //no left tree, then just visit its right tree\\n                prev = curr;\\n                curr = curr.right;\\n            }\\n        }\\n        \\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }",
                "solutionTags": [
                    "Recursion",
                    "Iterator"
                ],
                "code": "In-order traversal is really useful in BST. Following in-order traversal, we should have following order: prev.val < curr.val. If not, then we found at least one incorrectly placed node\\n\\nSo the basic idea is to visit the tree with in-order traversal and search for two swapped nodes. Then swap them back.\\n\\nNow the problem is if we found an incorrect pair where prev.val > curr.val, how do we know which node is the incorrect one?  The answer is it depends on whether we have found incorrect node before. So What is that?\\n\\nSince we get two elements that are swapped by mistake, there must be a smaller TreeNode get a larger value and a larger TreeNode get a smaller value.\\nTheir value are swapped, but the incorrect smaller node is still in smaller tree and incorrect larger node is still in larger tree. So we will visit the incorrect smaller node first, and this node will be detected when we compare its value with next.val, i.e.  when it is treated as prev node. The incorrect larger node will be detected when we compare its value with prev.val. We don't know if it is close or not close to incorrect smaller node, so we should continue search BST and update it if we found another incorrect node.\\n\\nTherefore if it is the first time we found an incorrect pair, the prev node must be the first incorrect node.\\nIf it is not the first time we found an incorrect pair, the curr node must be the second incorrect node, though\\nwe may have corner case that two incorrect nodes are in same pair.\\n\\nRecursive in-order traversal based on above idea:\\n\\n    public void recoverTree(TreeNode root) {\\n        //use inorder traversal to detect incorrect node\\n        \\n        inOrder(root);\\n        \\n\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    TreeNode prev = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    \\n    public void inOrder(TreeNode root){\\n        if(root == null) return;\\n        //search left tree\\n        inOrder(root.left);\\n        \\n        //in inorder traversal of BST, prev should always have smaller value than current value\\n        if(prev != null && prev.val >= root.val){\\n            //incorrect smaller node is always found as prev node\\n            if(first == null) first = prev;\\n          //incorrect larger node is always found as curr(root) node\\n            second = root;\\n        }\\n        \\n        \\n        //update prev node\\n        prev = root;\\n\\n        //search right tree\\n        inOrder(root.right);\\n    }\\n\\n\\niterative in-order traversal based on above idea:\\n\\n\\n    public void recoverTree(TreeNode root) {\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        \\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        while(!stack.isEmpty() ||  curr != null){\\n            if(curr != null){\\n                //visit curr's left subtree\\n                stack.push(curr);\\n                curr = curr.left;\\n            }else{\\n                //done left subtree of curr Node\\n                curr = stack.pop();\\n                \\n                //compare curr.val with prev.val if we have one\\n                if(prev != null && curr.val <= prev.val){\\n                    //incorrect smaller node is always found as prev node\\n                    if(first == null) first = prev;\\n                    //incorrect larger node is always found as curr node\\n                    second = curr;         \\n                }  \\n                \\n                //visit curr's right subtree\\n                prev = curr;\\n                curr = curr.right;\\n            }\\n        }\\n        \\n        //recover swapped nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\nBoth recursive and iterative will occupy O(n) space in worst case, in which the tree is like a LinkedList\\n\\nTo reduce the space to constant space, we have to use Morris-traversal.\\n\\nMorris-traversal is similar to recursive/iterative traversal, but we need to modify the tree structure during the\\ntraversal.  before we visiting the left tree of a root, we will build a back-edge between rightmost node in left tree and the root. So we can go back to the root node after we are done with the left tree. Then we locate the rightmost node in left subtree again, cut the back-edge, recover the tree structure and start visit right subtree. The detection of two incorrect TreeNodes is similar to iterative/recursive in-order traversal.\\nWe don't use extra data structure here, so the space complexity is reduced to O(1) and the time complexity will be O(n)\\n\\nMorris-traversal based on above description:\\n\\n    public void recoverTree(TreeNode root) {\\n    \\t//Morris-traversal\\n    \\t\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        \\n        TreeNode pred = null; //rightmost node in left tree\\n        TreeNode prev = null; \\n        \\n        TreeNode curr = root;\\n        \\n        while(curr != null){\\n            //for each node, we compare it with prev node as we did in in-order-traversal\\n            if(prev != null && curr.val <= prev.val){\\n                if(first == null) first = prev;\\n                second = curr;\\n            }\\n            \\n            if(curr.left != null){\\n                //got left tree, then let's locate its rightmost node in left tree\\n                pred = curr.left;\\n                //we may have visited the left tree before, and connect the rightmost node with curr node (root node)\\n                while(pred.right != null && pred.right != curr){\\n                    pred = pred.right;\\n                }\\n                \\n                if(pred.right == curr){\\n                    //if this left tree has been visited before, then we are done with it\\n                    //cut the connection with currNode and start visit curr's right tree\\n                    pred.right = null;\\n                    prev = curr;\\n                    curr = curr.right;\\n                }else{\\n                    //if this left tree has not been visited before, then we create a back edge from rightmost node\\n                    // to curr node, so we can return to the start point after done the left tree\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }\\n                \\n            }else{\\n                //no left tree, then just visit its right tree\\n                prev = curr;\\n                curr = curr.right;\\n            }\\n        }\\n        \\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 187407,
                "title": "python-short-and-slick-solution-108ms-beats-100-both-stack-and-morris-versions",
                "content": "Here\\'s a full solution using stack-based (iterative) inorder traversal. Just to demonstrate how efficient this code is, I\\'ve included the code for a regular inorder traversal on the right:\\n```python\\ndef recoverTree(self, root):                                               |  def inorder(self, root):\\n    cur, prev, drops, stack = root, TreeNode(float(\\'-inf\\')), [], []        |      cur, stack = root, []\\n    while cur or stack:                                                    |      while cur or stack:\\n        while cur:                                                         |          while cur:\\n            stack.append(cur)                                              |              stack.append(cur)\\n            cur = cur.left                                                 |              cur = cur.left\\n        node = stack.pop()                                                 |          node = stack.pop()\\n        if node.val < prev.val: drops.append((prev, node))                 |          print(node.val)\\n        prev, cur = node, node.right                                       |          cur = node.right\\n    drops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val  |\\n```\\nFull solution using Morris inorder traversal:\\n```python\\ndef recoverTree(self, root):                                               |  def inorderMorris(self, root):\\n    cur, prev, drops = root, TreeNode(float(\\'-inf\\')), []                   |      cur = root\\n    while cur:                                                             |      while cur:\\n        if cur.left:                                                       |          if cur.left:\\n            temp = cur.left                                                |              temp = cur.left\\n            while temp.right and temp.right != cur: temp = temp.right      |              while temp.right and temp.right != cur: temp = temp.right\\n            if not temp.right:                                             |              if not temp.right:\\n                temp.right, cur = cur, cur.left                            |                  temp.right, cur = cur, cur.left\\n                continue                                                   |                  continue\\n            temp.right = None                                              |              temp.right = None\\n        if cur.val < prev.val: drops.append((prev, cur))                   |          print(cur.val)\\n        prev, cur = cur, cur.right                                         |          cur = cur.right\\n    drops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val  |\\n```\\n---\\n\\n### Explanation\\n\\nI don\\'t have any new ideas; just a cool way to implement an old idea.\\n\\nUse whatever inorder traversal you like (recursion/stack = O(log n) extra space, Morris = O(1) extra space). As most people have figured out pretty easily, the idea is to remember the last value you saw and compare it with the current value. If `lastValue > currentValue`, then we know that something is \"wrong\", but it\\'s not immediately clear which values have to be swapped.\\n\\nThere are 2 cases: The values that need to be swapped are either adjacent or not adjacent. If they\\'re adjacent, then there will be one \"drop\"; if they\\'re not adjacent, then there will be two \"drops\".\\n```abc\\nadjacent: ... _ < _ < A > B < _ < _ ...\\n                      ^^^^^\\n                      drop #1\\n\\nnot adjacent: ... _ < _ < A > X < _ < Y > B < _ < _ ... (X may be the same as Y, but it\\'s irrelevant)\\n                          ^^^^^       ^^^^^\\n                          drop #1     drop #2\\n```\\nIn both cases, we want to swap `A` and `B`. So the idea is to keep a `drops` array and append a tuple of `(lastNode, currentNode)` whenever we come across `lastValue > currentValue`. At the end of the traversal, the `drops` array must have either 1 or 2 tuples (otherwise, there would be more than 2 nodes that need to be swapped).\\n\\nHere\\'s the clear but not-so-clean way to swap them:\\n```python\\nif len(drops) == 1: # drops == [(A, B)]\\n    drops[0][0].val, drops[0][1].val = drops[0][1].val, drops[0][0].val\\nelse: # drops == [(A, X), (Y, B)]\\n    drops[0][0].val, drops[1][1].val = drops[1][1].val, drops[0][0].val\\n```\\nHere\\'s the clean but not-so-clear way that gets rid of the conditional branching:\\n```python\\ndrops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val\\n```",
                "solutionTags": [],
                "code": "```python\\ndef recoverTree(self, root):                                               |  def inorder(self, root):\\n    cur, prev, drops, stack = root, TreeNode(float(\\'-inf\\')), [], []        |      cur, stack = root, []\\n    while cur or stack:                                                    |      while cur or stack:\\n        while cur:                                                         |          while cur:\\n            stack.append(cur)                                              |              stack.append(cur)\\n            cur = cur.left                                                 |              cur = cur.left\\n        node = stack.pop()                                                 |          node = stack.pop()\\n        if node.val < prev.val: drops.append((prev, node))                 |          print(node.val)\\n        prev, cur = node, node.right                                       |          cur = node.right\\n    drops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val  |\\n```\n```python\\ndef recoverTree(self, root):                                               |  def inorderMorris(self, root):\\n    cur, prev, drops = root, TreeNode(float(\\'-inf\\')), []                   |      cur = root\\n    while cur:                                                             |      while cur:\\n        if cur.left:                                                       |          if cur.left:\\n            temp = cur.left                                                |              temp = cur.left\\n            while temp.right and temp.right != cur: temp = temp.right      |              while temp.right and temp.right != cur: temp = temp.right\\n            if not temp.right:                                             |              if not temp.right:\\n                temp.right, cur = cur, cur.left                            |                  temp.right, cur = cur, cur.left\\n                continue                                                   |                  continue\\n            temp.right = None                                              |              temp.right = None\\n        if cur.val < prev.val: drops.append((prev, cur))                   |          print(cur.val)\\n        prev, cur = cur, cur.right                                         |          cur = cur.right\\n    drops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val  |\\n```\n```abc\\nadjacent: ... _ < _ < A > B < _ < _ ...\\n                      ^^^^^\\n                      drop #1\\n\\nnot adjacent: ... _ < _ < A > X < _ < Y > B < _ < _ ... (X may be the same as Y, but it\\'s irrelevant)\\n                          ^^^^^       ^^^^^\\n                          drop #1     drop #2\\n```\n```python\\nif len(drops) == 1: # drops == [(A, B)]\\n    drops[0][0].val, drops[0][1].val = drops[0][1].val, drops[0][0].val\\nelse: # drops == [(A, X), (Y, B)]\\n    drops[0][0].val, drops[1][1].val = drops[1][1].val, drops[0][0].val\\n```\n```python\\ndrops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1962281,
                "title": "c-easy-to-understand",
                "content": "If u use inorder traveral, problem will be find 2 mistakes in acending array and swap them\\nFor example array: 1 2 3 4 5 6 7\\n-> swap random two elments -> 1 2 6 4 5 3 7 (swap 3 and 6)\\n-> Question is how can know 2 elements is 3 and 6?\\n-> First: find the first number have index i satisfy arr[i - 1] > arr[i] => first mistake have index i - 1 (in the exam, first mistake is 6)\\n-> Second: continue but don\\'t change first mistake, if arr[i - 1] > arr[i] and u had found the first mistake => second mistake is i;\\nin the example second mistake in the first time is 4 change to 3\\n\\nIn the tree question, to keep compare, u need a variable is previous root.\\nBy @LemonHerbs :\\nif we encounter a tree looking like this:\\n\\n\\t   5\\n\\t  /   \\\\\\n\\t6     8\\n\\t\\t /\\n\\t\\t 4\\nfirstMistake will be assigned to 6, and in the same recursive call, secondMistake will be assigned to 5.\\nThen in the next recursive call, firstMistake will NOT be changed since it is not a null pointer, while secondMistake will be\\nupdated to 4. Then in the following recursions the 2 mistake nodes remain unchanged.\\nWhen inorder() returns to the main function recoverTree(), the 2 mistakes swap values and hence the correct BST.\\n\\n\\t   5\\n\\t  /   \\\\\\n\\t4     8\\n\\t\\t /\\n\\t\\t 6\\nCode:\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\t\\tvoid recoverTree(TreeNode* root) {\\n\\t\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\t\\tinorder(root);\\n\\t\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t\\t}\\n\\n\\t\\tvoid inorder(TreeNode* root) {\\n\\t\\t\\tif(root == nullptr) \\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tinorder(root->left);\\n\\n\\t\\t\\tif(firstMistake == nullptr && root->val < pre->val)\\n\\t\\t\\t\\tfirstMistake = pre;\\n\\t\\t\\tif(firstMistake != nullptr && root->val < pre->val)\\n\\t\\t\\t\\tsecondMistake = root;\\n\\t\\t\\tpre = root;\\n\\n\\t\\t\\tinorder(root->right);\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\t\\tvoid recoverTree(TreeNode* root) {\\n\\t\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\t\\tinorder(root);\\n\\t\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 917430,
                "title": "python-o-n-o-1-morris-traversal-explained",
                "content": "If we want to traverse our tree and do not use any additional memory, than as far as I know, Morris traversal is the only way how to do it. \\n\\nFor more details about Morris traversal, you can look at oficial solution of problem 94: Binary Tree Inorder Traversal: https://leetcode.com/problems/binary-tree-inorder-traversal/solution/.\\n\\nAlso, here we need to use variation of traversal, which keep the original structure of tree.\\n\\nLet us use this traversal and use `node` is current node we are in and `cands` are candidates for our swapped nodes. We will look at oddities in inorder traversal: in BST all numbers will always increase. So, if in inorder traversal some value is less than previous, we need to keep and eye on this node. There can be two main cases:\\n\\n1. We have `1, 2, 3, 4, 5` and swapped nodes are adjacent, for example `1, 2, 4, 3, 5`. In this case, we have only one oddity: `4` and `3`: and we save them to our `cands` list. And we need to change values for the first and for the last nodes in our `cands`.\\n2. We have `1, 2, 3, 4, 5` and swapped nodes are not adjacent, for example `1, 2, 5, 4, 3`. In this case we have two oddities: `5` and `4`; `4` and `3`.  In this case we again need to swap the first and the last nodes.\\n\\nSo, in both cases it is enough to run `cands[0].val, cands[-1].val = cands[-1].val, cands[0].val` to swap our nodes.\\n\\n**Complexity**: time complexity is `O(n)`: because we basically do Morris traverasal plus some additional `O(n)` operations. Space complexity is `O(1)`, becauswe we again do Morris traversal and also we have `node` and `cands`, where `cands` can have maximum size `4`.\\n\\n```\\nclass Solution:\\n    def recoverTree(self, root):\\n        cur, node, cands = root, TreeNode(-float(\"inf\")), []\\n        while cur:\\n            if cur.left:\\n                pre = cur.left\\n                while pre.right and pre.right != cur:\\n                    pre = pre.right\\n                if not pre.right:\\n                    pre.right = cur\\n                    cur = cur.left\\n                else:\\n                    pre.right = None\\n                    if cur.val < node.val:\\n                        cands += [node, cur]\\n                    node = cur\\n                    cur = cur.right\\n            else:\\n                if cur.val < node.val:\\n                    cands += [node, cur]\\n                node = cur\\n                cur = cur.right\\n            \\n        cands[0].val, cands[-1].val = cands[-1].val, cands[0].val\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root):\\n        cur, node, cands = root, TreeNode(-float(\"inf\")), []\\n        while cur:\\n            if cur.left:\\n                pre = cur.left\\n                while pre.right and pre.right != cur:\\n                    pre = pre.right\\n                if not pre.right:\\n                    pre.right = cur\\n                    cur = cur.left\\n                else:\\n                    pre.right = None\\n                    if cur.val < node.val:\\n                        cands += [node, cur]\\n                    node = cur\\n                    cur = cur.right\\n            else:\\n                if cur.val < node.val:\\n                    cands += [node, cur]\\n                node = cur\\n                cur = cur.right\\n            \\n        cands[0].val, cands[-1].val = cands[-1].val, cands[0].val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423225,
                "title": "c-clear-solution-with-explanation",
                "content": "In an inorder traversal, nodes should go from smallest to largest, if not we know there is an issue.\\nFor instance, if we have nodes 10 11 1 6 7 20 27, the inorder traversal should be\\n1 6 7 10 11 20 27. If it is anything else, you know two numbers are swapped. For instance, you could have:\\n1 7 6 10 11 20 27 (SITUATION 1), where two nodes sie by side are swapped, or 1 6  20 10 11 7 27 (SITUATION 2), where two nodes somewhere in the tree are flipped. We need to maintain a pointer to four locations:\\n\\n1. The previous node.  (prev)\\n2. The current node (root)\\n3. Our first flipped node (start)\\n4. Our second flipped node (end)\\n\\nAs we hit the first node in the inorder traversal, we mark it with prev (point prev to it). We then move onto the next node. This is when we want to start makiing the comparison. We then compare the previous node\\'s value to the current node\\'s value. So we\\'d compare 1 to 6. Since 6 is greater than 1, we continue. We compare 6 to 20. Since 20 is greater than 6, we continue. Then we get to 10, and 10 is less than 20, so we move our pointer to point to 20 as our first target. We set our second pointer (end) to the current node, since it may be the situation where the two flipped nodes are side by side (SITUATION 1). If that is NOT the case, our loop will be triggered again, and since our first pointer (start) is already occupied, our second pointer will now change to the second poorly placed node (SITUATION 2\\'s 7)\\n\\n```\\nclass Solution {\\nprivate:\\n    \\n    void markTree(TreeNode* root, TreeNode*& prev, TreeNode*& first, TreeNode*& end) {\\n        if (!root) return;\\n        markTree(root->left, prev, first, end);\\n        if (prev) {\\n            if (root->val < prev->val) {\\n                if (!first) {\\n                    first = prev;\\n                }\\n                end = root;\\n            }\\n        }\\n        prev = root;\\n        markTree(root->right, prev, first, end);\\n    }\\n    \\n    \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *prev = nullptr, *first = nullptr, *end = nullptr;\\n        markTree(root, prev, first, end);\\n        swap(first->val, end->val);\\n        return;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\nprivate:\\n    \\n    void markTree(TreeNode* root, TreeNode*& prev, TreeNode*& first, TreeNode*& end) {\\n        if (!root) return;\\n        markTree(root->left, prev, first, end);\\n        if (prev) {\\n            if (root->val < prev->val) {\\n                if (!first) {\\n                    first = prev;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 917502,
                "title": "c-o-n-time-o-1-space-short-easy-code-with-explanation",
                "content": "The space O(1) does not consider recursion stack space.\\nThe idea is that, if we swap any 2 values in an ascending sorted array, then we may find irregularity in our array (i.e. arr[i]>arr[i+1]) at 2 places, and if we swap any 2 adjacent numbers then such irregularity occurs at ony 1 place.\\nSo the idea is to traverse the tree in inorder fashion and keeping a check on previous node and comparing the value of current node with previous node of inorder traversal. We save all such pairs of {curr, prev} nodes in an array.\\nThe size of array == 1 if 2 adjacent numbers were swapped, else the size of array == 2.\\nSo we have to accordingly swap the numbers to get back the original tree.\\n```\\nvector<pair<TreeNode*,TreeNode*>> vec;\\n    TreeNode* prev = NULL;\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root) return;\\n        inorder(root->left);\\n        if(prev && prev->val>root->val) vec.push_back({prev,root});\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        if(vec.size()==1)\\n            swap(vec[0].first->val,vec[0].second->val);\\n        if(vec.size()==2)\\n            swap(vec[0].first->val,vec[1].second->val);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<pair<TreeNode*,TreeNode*>> vec;\\n    TreeNode* prev = NULL;\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root) return;\\n        inorder(root->left);\\n        if(prev && prev->val>root->val) vec.push_back({prev,root});\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        if(vec.size()==1)\\n            swap(vec[0].first->val,vec[0].second->val);\\n        if(vec.size()==2)\\n            swap(vec[0].first->val,vec[1].second->val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32580,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explaination",
                "content": "Just use the \"first\" and \"second\" pointer to find the 2 nodes that violate the order. Then change the value of the first node ad the second node by their value.\\n\\n    class Solution {\\n        TreeNode* first=NULL;\\n        TreeNode* second=NULL;\\n        TreeNode* prev = new TreeNode(INT_MIN);\\n    public:\\n        void recoverTree(TreeNode* root) {\\n            help(root);\\n            swp(first->val, second->val);\\n        }\\n        \\n        void help(TreeNode* root){\\n            if(root==NULL)  return;\\n            help(root->left);\\n            if(first==NULL && prev->val >= root->val)   first=prev;\\n            if(first!=NULL && prev->val >= root->val)   second=root;\\n            prev=root;\\n            help(root->right);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        TreeNode* first=NULL;\\n        TreeNode* second=NULL;\\n        TreeNode* prev = new TreeNode(INT_MIN);\\n    public:\\n        void recoverTree(TreeNode* root) {\\n            help(root);\\n            swp(first->val, second->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32624,
                "title": "python-easy-to-understand-solutions",
                "content": "```\\n\\nclass Solution(object): \\n    def recoverTree(self, root): # O(lg(n)) space\\n        pre = first = second = None\\n        stack = []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                break\\n            node = stack.pop()\\n            if not first and pre and pre.val > node.val:\\n                first = pre\\n            if first and pre and pre.val > node.val:\\n                second = node\\n            pre = node\\n            root = node.right\\n        first.val, second.val = second.val, first.val\\n      \\n    def recoverTree1(self, root): # O(n+lg(n)) space  \\n        res = []\\n        self.dfs(root, res)\\n        first, second = None, None\\n        for i in range(len(res)-1):\\n            if res[i].val > res[i+1].val and not first:\\n                first = res[i]\\n            if res[i].val > res[i+1].val and first:\\n                second = res[i+1]\\n        first.val, second.val = second.val, first.val\\n        \\n    def dfs(self, root, res):\\n        if root:\\n            self.dfs(root.left, res)\\n            res.append(root)\\n            self.dfs(root.right, res)\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\n\\nclass Solution(object): \\n    def recoverTree(self, root): # O(lg(n)) space\\n        pre = first = second = None\\n        stack = []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                break\\n            node = stack.pop()\\n            if not first and pre and pre.val > node.val:\\n                first = pre\\n            if first and pre and pre.val > node.val:\\n                second = node\\n            pre = node\\n            root = node.right\\n        first.val, second.val = second.val, first.val\\n      \\n    def recoverTree1(self, root): # O(n+lg(n)) space  \\n        res = []\\n        self.dfs(root, res)\\n        first, second = None, None\\n        for i in range(len(res)-1):\\n            if res[i].val > res[i+1].val and not first:\\n                first = res[i]\\n            if res[i].val > res[i+1].val and first:\\n                second = res[i+1]\\n        first.val, second.val = second.val, first.val\\n        \\n    def dfs(self, root, res):\\n        if root:\\n            self.dfs(root.left, res)\\n            res.append(root)\\n            self.dfs(root.right, res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962833,
                "title": "beginner-level-illustration-11-line-solution",
                "content": "Pretty sure mine is the easiest one to understand. \\n\\nIf you do not want to spend much time on that, you could read the examples below the orange highlight line and get the idea.\\n\\nIf you do not think so, please comment.\\n\\nIf you have additional questions, please let me know\\n\\n**Please upvote me if you think this is helpful :) Much Appreciated!**\\n\\n![image](https://assets.leetcode.com/users/images/f6d861cd-c19a-4ee2-b377-50851abe09d8_1650345918.5829039.jpeg)\\n\\n****\\n\\nPython Solution\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n\\t\\n        # the idea is the in order BST is always increasing, if not, then there is something wrong\\n        def inorderBST(root):\\n            if not root:    return\\n            \\n            # track left side to start with min\\n            inorderBST(root.left)\\n\\n            # so that the first prev is the smallest node\\n            # and update each time\\n            if self.prev:\\n                \\n                # when order is wrong\\n\\t\\t\\t\\t# check the examples in the illustration\\n                if self.prev.val > root.val:\\n                    if not self.first:\\n                        self.first = self.prev\\n                    self.second = root\\n            \\n            # update the prev node\\n            self.prev = root\\n            \\n            # check right side\\n            inorderBST(root.right)\\n        \\n        \\n        self.first = self.second = self.prev = None\\n        inorderBST(root)\\n        \\n        # swap the two wrong ones\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n        \\n        return\\n```\\n\\n****\\n\\nCompressed 11-line Python Solution\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n\\n        def inorderBST(root):\\n            if not root:    return\\n            \\n            inorderBST(root.left)\\n\\n            if self.prev and self.prev.val > root.val:\\n                if not self.first:  self.first = self.prev\\n                self.second = root\\n            self.prev = root\\n\\n            inorderBST(root.right)\\n        \\n        \\n        self.first = self.second = self.prev = None\\n        inorderBST(root)\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n\\t\\n        # the idea is the in order BST is always increasing, if not, then there is something wrong\\n        def inorderBST(root):\\n            if not root:    return\\n            \\n            # track left side to start with min\\n            inorderBST(root.left)\\n\\n            # so that the first prev is the smallest node\\n            # and update each time\\n            if self.prev:\\n                \\n                # when order is wrong\\n\\t\\t\\t\\t# check the examples in the illustration\\n                if self.prev.val > root.val:\\n                    if not self.first:\\n                        self.first = self.prev\\n                    self.second = root\\n            \\n            # update the prev node\\n            self.prev = root\\n            \\n            # check right side\\n            inorderBST(root.right)\\n        \\n        \\n        self.first = self.second = self.prev = None\\n        inorderBST(root)\\n        \\n        # swap the two wrong ones\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n        \\n        return\\n```\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n\\n        def inorderBST(root):\\n            if not root:    return\\n            \\n            inorderBST(root.left)\\n\\n            if self.prev and self.prev.val > root.val:\\n                if not self.first:  self.first = self.prev\\n                self.second = root\\n            self.prev = root\\n\\n            inorderBST(root.right)\\n        \\n        \\n        self.first = self.second = self.prev = None\\n        inorderBST(root)\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274892,
                "title": "java-easy-inorder-traversal-soln-faster-than-100-explained",
                "content": "Here, we leverage the fact that **Inorder Traversal of a BST gives a sorted list of elements.**\\nIf there are exactly 2 swapped nodes, we can check the mistake in the inorder traversal.\\nFor eg.,\\n`root = [6,2,5,null,null,null,3]`\\nInorder traversal: `[2,6,5,3]` (Not sorted).\\n\\n- First incorrect node/element is **6** because 6 > 5 `(first == null && prev > curr)` => `prev` is the first node.\\n- Second incorrect node/element is **3**, because 5 > 3 `(first != null && prev > curr)`, `curr` is the second node.\\n- To cover the edge-case of 2 consecutive elements to be swapped, we always assign `second = curr`.\\n\\nHence, after swapping, the root becomes: `[2,3,5,6]`.\\n\\nBelow is the code:\\n\\n```\\nclass Solution {\\n    TreeNode prev = null, first = null, second = null;\\n\\n    public void recoverTree(TreeNode root) {\\n        evalSwappedNodes(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\n    private void evalSwappedNodes(TreeNode curr) {\\n        if (curr == null)\\n            return;\\n        evalSwappedNodes(curr.left);\\n        if (prev != null && prev.val > curr.val) {\\n            if (first == null)\\n                first = prev;\\n            second = curr;\\n        }\\n        prev = curr;\\n        evalSwappedNodes(curr.right);\\n    }\\n}\\n```\\n\\n\\n-------------------------------------------------------------------------------------------------------------------\\nIf you find this post helpful, please do upvote!\\nHappy Coding!! :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev = null, first = null, second = null;\\n\\n    public void recoverTree(TreeNode root) {\\n        evalSwappedNodes(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\n    private void evalSwappedNodes(TreeNode curr) {\\n        if (curr == null)\\n            return;\\n        evalSwappedNodes(curr.left);\\n        if (prev != null && prev.val > curr.val) {\\n            if (first == null)\\n                first = prev;\\n            second = curr;\\n        }\\n        prev = curr;\\n        evalSwappedNodes(curr.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671363,
                "title": "on-paper-explanantion-well-commented-easy-understand",
                "content": "![image](https://assets.leetcode.com/users/akshit0699/image_1591339571.png)\\n\\nCASE 1:\\n4, 15, 7, 10, 14, 5, 17\\nWe reach 7, prev.val(15) >root.val(7) VIOLATION! Hence, found first.\\nfirst = 15(prev) and second = 7(root)\\nWe go to 7,10,14... all obey the sorted order.\\nWe reach 5, prev.val(14) > root.val(5) VIOLATION! Hence, found second.\\nsecond = 5 (root)\\nEverything else in the array is fine.\\nSwap first and second. Done!\\n\\nCase 2:\\n4,5, 7, 10, 15, 14, 17\\nReaches upto 15 safely.\\nComes to 14, VIOLATION. Found first.\\nfirst = 15(prev) and second = 14(root)\\nEverything else works fine.\\nSwap first and second. Done!\\n\\n\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: None Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        self.first, self.second, self.prevNode = None, None, None # Create three nodes.\\n        self.inOrder(root) # Calling the function\\n        self.first.val, self.second.val = self.second.val, self.first.val \\n        # Swapping the two elements needed to be swapped\\n        \\n    def inOrder(self, root):\\n        if not root:\\n            return\\n        self.inOrder(root.left)\\n        \\n        if self.prevNode: # To handle the case of first node, because we make it prev to begin with\\n            if self.prevNode.val > root.val: # Check property violation\\n                if not self.first: \\n                    self.first = self.prevNode # Found first pair\\n                self.second = root # If the second pair is found then simply assign the smaller element of the   pair as the second guy, it works for single pair easily, as it wont get             updated again in that case.\\n                \\n        self.prevNode = root\\n        \\n        self.inOrder(root.right)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: None Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        self.first, self.second, self.prevNode = None, None, None # Create three nodes.\\n        self.inOrder(root) # Calling the function\\n        self.first.val, self.second.val = self.second.val, self.first.val \\n        # Swapping the two elements needed to be swapped\\n        \\n    def inOrder(self, root):\\n        if not root:\\n            return\\n        self.inOrder(root.left)\\n        \\n        if self.prevNode: # To handle the case of first node, because we make it prev to begin with\\n            if self.prevNode.val > root.val: # Check property violation\\n                if not self.first: \\n                    self.first = self.prevNode # Found first pair\\n                self.second = root # If the second pair is found then simply assign the smaller element of the   pair as the second guy, it works for single pair easily, as it wont get             updated again in that case.\\n                \\n        self.prevNode = root\\n        \\n        self.inOrder(root.right)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962583,
                "title": "c-2-approach-brute-force-optimal",
                "content": "**1. Brute Force:**\\ntaking a vector, insert value into it according inorder traversal. Then sort, now again traverse the tree (in-order) & check the difference.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int i=0;\\n    void inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    void check(TreeNode* root){\\n        if(!root) return;\\n        check(root->left);\\n        if(v[i]!=root->val) swap(v[i],root->val);\\n        i++;\\n        check(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        sort(v.begin(),v.end());\\n        check(root);\\n    }\\n};\\n```\\n`TC-> O(NlogN), SC-> O(N)+O(N) [1 for vector, 1 for recursion space]`\\n\\n**2. Optimal:**\\n```\\nclass Solution {\\n    TreeNode* first, *last, *prev;\\npublic:\\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        inorder(root->left);\\n        if(prev!=NULL && (root->val<prev->val)){\\n            if(first==NULL){\\n                first=prev;\\n                last=root; \\n            }\\n            else\\n                last=root;\\n        }\\n        prev=root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        first=last=prev=NULL;\\n        inorder(root);\\n        swap(first->val,last->val);\\n    }\\n};\\n```\\n`TC-> O(N), SC->O(N) [for recursion space]`\\n\\n**Upvote if you like it**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int i=0;\\n    void inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    void check(TreeNode* root){\\n        if(!root) return;\\n        check(root->left);\\n        if(v[i]!=root->val) swap(v[i],root->val);\\n        i++;\\n        check(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        sort(v.begin(),v.end());\\n        check(root);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    TreeNode* first, *last, *prev;\\npublic:\\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        inorder(root->left);\\n        if(prev!=NULL && (root->val<prev->val)){\\n            if(first==NULL){\\n                first=prev;\\n                last=root; \\n            }\\n            else\\n                last=root;\\n        }\\n        prev=root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        first=last=prev=NULL;\\n        inorder(root);\\n        swap(first->val,last->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552230,
                "title": "c-morris-traversal-o-1-space",
                "content": "According to question statement there will be only one swap necessary to make recover BST.\\n- From observation inorder traversal in BST gives sorted arrays\\n- Now if there is any nodes in in wrong order it makes array irregular\\n- there can be one or two wrong ordered pairs of elements in inorders traversal array.\\n\\t- If one pair wrong ordered element then keep track of two element in that pair and swap their values.\\n\\t- If two wrong pair exist then swap first element of first pair with second element of second pair\\n\\t\\n\\tExample: \\n\\tBST inorder: **2, 1,** 3 // one pair wrong ordered. here swaping 2 and 1 makes a BST valid\\n\\tBST inorder: 1, **7, 3**, 5, **6, 2,** 8, // two pair wrong ordered. swaping 7 and 2 make valid BST\\n  \\n  **Upvote if you find this helpful. Thanks :)**\\n  \\n```\\nclass Solution {\\n    TreeNode* first{nullptr}, *second{nullptr}, *prev{nullptr};\\npublic:\\n    void verifyNode(TreeNode* node){\\n\\t\\n\\t// check if previous pointer == null or node values are correct inorder traversal i.e prev is smaller than current node\\n        if(prev == nullptr || (prev->val<node->val)){ \\n            prev = node;\\n            return;\\n        }\\n        \\n        if(first == nullptr ){\\n            first = prev;\\n            second = node;\\n        }else{ \\n            second = node;\\n        }\\n    }\\n    void morrisInorder(TreeNode* root){\\n        if(!root)return;\\n        while(root){\\n            if(root->left == nullptr){\\n                verifyNode(root);\\n                root = root->right;\\n            }else{\\n                TreeNode* iter = root->left;\\n                // find predecessor\\n                while(iter->right && iter->right!=root){\\n                    iter = iter->right;\\n                }\\n                \\n                if(iter->right == nullptr)//create morris thread\\n                {\\n                    iter->right = root;\\n                    root = root->left;\\n                }else{\\n                    iter->right = nullptr;\\n                    verifyNode(root);\\n                    root = root->right;\\n                }\\n            }\\n        }\\n    }\\n    void recoverTree(TreeNode* root) {\\n        morrisInorder(root);\\n        swap(first->val, second->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode* first{nullptr}, *second{nullptr}, *prev{nullptr};\\npublic:\\n    void verifyNode(TreeNode* node){\\n\\t\\n\\t// check if previous pointer == null or node values are correct inorder traversal i.e prev is smaller than current node\\n        if(prev == nullptr || (prev->val<node->val)){ \\n            prev = node;\\n            return;\\n        }\\n        \\n        if(first == nullptr ){\\n            first = prev;\\n            second = node;\\n        }else{ \\n            second = node;\\n        }\\n    }\\n    void morrisInorder(TreeNode* root){\\n        if(!root)return;\\n        while(root){\\n            if(root->left == nullptr){\\n                verifyNode(root);\\n                root = root->right;\\n            }else{\\n                TreeNode* iter = root->left;\\n                // find predecessor\\n                while(iter->right && iter->right!=root){\\n                    iter = iter->right;\\n                }\\n                \\n                if(iter->right == nullptr)//create morris thread\\n                {\\n                    iter->right = root;\\n                    root = root->left;\\n                }else{\\n                    iter->right = nullptr;\\n                    verifyNode(root);\\n                    root = root->right;\\n                }\\n            }\\n        }\\n    }\\n    void recoverTree(TreeNode* root) {\\n        morrisInorder(root);\\n        swap(first->val, second->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278113,
                "title": "come-on-in-no-explanation-can-be-more-straightforward-than-graph-for-this-problem",
                "content": "\\nFor BST, if we do the in-order traversal, and add to the list, then the nodes in the list are sorted in acsending order. If we put them in a graph, then it will be like below where:\\n- **dark nodes** represent the tree nodes\\n- **red line** represents the **node values trend**\\n\\n![image](https://assets.leetcode.com/users/images/b6fce400-bbdc-4718-8a2a-3b356d58ff2f_1623906705.6791987.jpeg)\\n\\n\\nSo, if 2 nodes are swapped mistakenly, then the graph will be changed to below graph where:\\n- **yellow nodes** represent the node after swapped mistakendly\\n- **blue line** represents the **changed trend**\\n\\n![image](https://assets.leetcode.com/users/images/3e500bc5-960a-4ac9-a8ce-47714a8163c4_1623906718.23329.jpeg)\\n\\nAs we can see:\\n- The 1st mistaken node is the **peak node** around the its neighbors\\n- The 2nd mistaken node is the **negative peak node** around its neighbors\\n\\n**However!!!** it is easy to ignore that there are **2 peaks**, and **2 negative peaks**!!!\\n\\n![image](https://assets.leetcode.com/users/images/f2eff705-102c-48ac-8912-1c6fdddef120_1623907741.1990602.jpeg)\\n\\n\\n\\nThen we can correct above statement to: \\n- The **1st peak node** is the 1st mistaken node\\n- The **2nd node** or **the last node** is the 2nd mistaken node\\n\\nSo we can add condition to deal with above cases:\\n- If we find a peak node, then it is the 1st mistaken node, and we will not update 1st node in the following process\\n- If we find the any negative peak node, then we just update the 2nd mistaken node directly. Then the last negative peak node will overwrite the previous one which is what we want \\n\\n---\\n**Code**\\n```java\\nclass Solution {\\n    public void recoverTree(TreeNode root) {\\n        List<TreeNode> nodes = new ArrayList<>();\\n        inorder(root, nodes);\\n\\n        TreeNode node1 = null;\\n        TreeNode node2 = null;\\n        int n = nodes.size();\\n        for(int i = 0; i < nodes.size(); i++){\\n            if(i == 0){\\n                if(nodes.get(0).val > nodes.get(1).val) node1 = nodes.get(0);\\n            }else if(i == n - 1){\\n                if(nodes.get(i).val < nodes.get(i - 1).val) node2 = nodes.get(i);\\n            }else{\\n                if(node1 == null && nodes.get(i).val > nodes.get(i - 1).val && nodes.get(i).val > nodes.get(i + 1).val)\\n                    node1 = nodes.get(i);\\n                else if(nodes.get(i).val < nodes.get(i - 1).val && nodes.get(i).val < nodes.get(i + 1).val)\\n                    node2 = nodes.get(i);\\n            }\\n        }\\n        \\n        // swap val of node1 and node2, instead of node1 and node2 to keep the structure\\n        int tmp = node1.val;\\n        node1.val = node2.val;\\n        node2.val = tmp;\\n    }\\n    \\n    public void inorder(TreeNode root, List<TreeNode> nodes){\\n        if(root == null) return;\\n        \\n        inorder(root.left, nodes);\\n        nodes.add(root);\\n        inorder(root.right, nodes);\\n    }\\n}\\n```\\n\\n---\\n**Complexity Analysis**\\nTC: O(n)\\nSC: O(n)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public void recoverTree(TreeNode root) {\\n        List<TreeNode> nodes = new ArrayList<>();\\n        inorder(root, nodes);\\n\\n        TreeNode node1 = null;\\n        TreeNode node2 = null;\\n        int n = nodes.size();\\n        for(int i = 0; i < nodes.size(); i++){\\n            if(i == 0){\\n                if(nodes.get(0).val > nodes.get(1).val) node1 = nodes.get(0);\\n            }else if(i == n - 1){\\n                if(nodes.get(i).val < nodes.get(i - 1).val) node2 = nodes.get(i);\\n            }else{\\n                if(node1 == null && nodes.get(i).val > nodes.get(i - 1).val && nodes.get(i).val > nodes.get(i + 1).val)\\n                    node1 = nodes.get(i);\\n                else if(nodes.get(i).val < nodes.get(i - 1).val && nodes.get(i).val < nodes.get(i + 1).val)\\n                    node2 = nodes.get(i);\\n            }\\n        }\\n        \\n        // swap val of node1 and node2, instead of node1 and node2 to keep the structure\\n        int tmp = node1.val;\\n        node1.val = node2.val;\\n        node2.val = tmp;\\n    }\\n    \\n    public void inorder(TreeNode root, List<TreeNode> nodes){\\n        if(root == null) return;\\n        \\n        inorder(root.left, nodes);\\n        nodes.add(root);\\n        inorder(root.right, nodes);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32650,
                "title": "share-my-java-solution-using-morris-traversal",
                "content": "The Key idea is to use Morris Traversal which only uses O(1) Space. Here is my code and comments.\\nThe code just uses the variable root as the current node.\\n\\n    public class Solution {\\n      public void recoverTree(TreeNode root) {  \\n    \\n        TreeNode first = null;     // first node need to be swap\\n        TreeNode second = null;    // second node need to be swap\\n        TreeNode pre = new TreeNode(Integer.MIN_VALUE);  //previous node.\\n    \\n        while(root!=null){\\n          TreeNode node = root.left;\\n    \\n          // If left is not null, we need to find the rightmost node of left subtree,\\n          // Set its right child to current node\\n          if(node!=null){ \\n         \\n            //find the rightmost\\n            while(node.right!=null && node.right != root){\\n              node = node.right;\\n            }\\n    \\n            //There are two cases,\\n            //null: first time we access current, set node.right to current and move to left child of current and continue;\\n            //current: we accessed current before, thus we've finished traversing left subtree, set node.right back to null;\\n            if(node.right == null){\\n              node.right = root;\\n              root = root.left;\\n              continue;\\n            }else{\\n              node.right = null;\\n            }\\n          }\\n    \\n          // compare current node with previous node\\n          if(root.val < pre.val ){\\n            // first time we enconter reversed order, we set previous node to first\\n            if( first == null ){\\n              first = pre;\\n            }\\n            //In case that two nodes are successive, we set second to current every time.\\n            second = root;\\n          }\\n          pre = root;\\n          root = root.right;      \\n        }\\n    \\n        //swap the value;\\n        int temp = second.val;\\n        second.val = first.val;\\n        first.val = temp;\\n      }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public void recoverTree(TreeNode root) {  \\n    \\n        TreeNode first = null;     // first node need to be swap\\n        TreeNode second = null;    // second node need to be swap\\n        TreeNode pre = new TreeNode(Integer.MIN_VALUE);  //previous node.\\n    \\n        while(root!=null){\\n          TreeNode node = root.left;\\n    \\n          // If left is not null, we need to find the rightmost node of left subtree,\\n          // Set its right child to current node\\n          if(node!=null){ \\n         \\n            //find the rightmost\\n            while(node.right!=null && node.right != root){\\n              node = node.right;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 256055,
                "title": "python-inorder-traversal",
                "content": "Since it\\'s a BST, so an inorder traversal returns a sorted array. And we can easily spot the midplaced nodes **first** and **second** as **first** is larger than the element next to it while **second** is smaller than the element ahead of it.\\n\\nSo we can run an inorder traversal. Between inorder(node.left) and inorder(node.right), we need to compare the current node with its neighbor.\\n\\nWe first identify the **first**, pointed by a helper pointer **prev**. And current **node** would be the node next to **prev** in sorted array. If prev.val >= node.val, we find the first node. Then we identify the **second**, which is now pointed by current **node** so that **prev** points to the node ahead of it. If node.val <= prev.val, we find the second node. So it\\'s like:\\n```\\nif not self.first and self.prev.val >= node.val:\\n\\tself.first = self.prev\\nif self.first and self.prev.val >= node.val:\\n\\tself.second = node\\n```\\nAnd we can combine the logic checks as:\\n```\\nif self.prev.val >= node.val:\\n\\tself.first = self.first or self.prev\\n\\tself.second = node\\n```\\nThere are at most two times of ```self.prev.val >= node.val```. That\\'s when **first** and **second** are not neighboring with each other. In such case, the **second** would be allocated to a false node in the first ```self.prev.val >= node.val``` occasion. But that doesn\\'t matter since it would be corrected in the second ```self.prev.val >= node.val```. Meanwhile, the **second** would be allocated to a correct node in the first and only time of ```self.prev.val >= node.val``` when **first** and **second** are neighbors.\\n\\nEventually, we swap the values between **first** and **second**.\\n```\\ndef recoverTree(root):\\n\\tself.first, self.second, self.prev = None, None, TreeNode(float(\\'-inf\\')) \\n\\tdef inorder(node):\\n\\t\\tif node:\\n\\t\\t\\tinorder(node.left)\\n\\t\\t\\tif self.prev.val >= node.val: \\n\\t\\t\\t\\tself.first = self.first or self.prev\\n\\t\\t\\t\\tself.second = node\\n\\t\\t\\tself.prev = node\\n\\t\\t\\tinorder(node.right)\\n\\tinorder(root)\\n\\tself.first.val, self.second.val = self.second.val, self.first.val\\n```",
                "solutionTags": [],
                "code": "```\\nif not self.first and self.prev.val >= node.val:\\n\\tself.first = self.prev\\nif self.first and self.prev.val >= node.val:\\n\\tself.second = node\\n```\n```\\nif self.prev.val >= node.val:\\n\\tself.first = self.first or self.prev\\n\\tself.second = node\\n```\n```self.prev.val >= node.val```\n```self.prev.val >= node.val```\n```self.prev.val >= node.val```\n```self.prev.val >= node.val```\n```\\ndef recoverTree(root):\\n\\tself.first, self.second, self.prev = None, None, TreeNode(float(\\'-inf\\')) \\n\\tdef inorder(node):\\n\\t\\tif node:\\n\\t\\t\\tinorder(node.left)\\n\\t\\t\\tif self.prev.val >= node.val: \\n\\t\\t\\t\\tself.first = self.first or self.prev\\n\\t\\t\\t\\tself.second = node\\n\\t\\t\\tself.prev = node\\n\\t\\t\\tinorder(node.right)\\n\\tinorder(root)\\n\\tself.first.val, self.second.val = self.second.val, self.first.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1962276,
                "title": "clear-n-easy-to-understand-code",
                "content": "***INORDER TRAVERSAL APPROACH***\\n```\\nclass Solution {\\n     // Creating three global pointers\\n    TreeNode previous = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        // Finding the two swapped nodes\\n        solve(root);\\n        \\n        //Swaping the value of nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n     //New Function to find the two nodes\\n    public void solve(TreeNode root){\\n        \\n        if(root == null){\\n            return;\\n        }\\n        \\n        //Doing inorder traversal i.e, sarting from left then right\\n        solve(root.left);\\n        \\n        // If current node is smaller than previous, then previous node is invalid\\n        if(previous != null && root.val < previous.val){\\n            \\n            //Storing previous node\\n            if(first == null){\\n                first = previous;\\n            }\\n            \\n            //If both nodes are adjacent, save the current node in that case\\n            second = root;\\n            \\n        }\\n        \\n        //Making current node as previous node\\n        previous = root;\\n        \\n        //Moving to right sub-tree\\n        solve(root.right);\\n        \\n    }\\n}\\n```\\n<hr>\\n<hr>\\n\\n***Time Complexity =O(N)***\\n***Space Complexity = O(N)***\\n\\n<hr>\\n<hr>",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     // Creating three global pointers\\n    TreeNode previous = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        // Finding the two swapped nodes\\n        solve(root);\\n        \\n        //Swaping the value of nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n     //New Function to find the two nodes\\n    public void solve(TreeNode root){\\n        \\n        if(root == null){\\n            return;\\n        }\\n        \\n        //Doing inorder traversal i.e, sarting from left then right\\n        solve(root.left);\\n        \\n        // If current node is smaller than previous, then previous node is invalid\\n        if(previous != null && root.val < previous.val){\\n            \\n            //Storing previous node\\n            if(first == null){\\n                first = previous;\\n            }\\n            \\n            //If both nodes are adjacent, save the current node in that case\\n            second = root;\\n            \\n        }\\n        \\n        //Making current node as previous node\\n        previous = root;\\n        \\n        //Moving to right sub-tree\\n        solve(root.right);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32532,
                "title": "my-javascript-solution",
                "content": "The idea is simple, find the two nodes that are swapped by mistake and then swap back their values. The question is how to find out those two nodes?\\n\\nAs we know, an inorder traversal of BST gives us a sorted array, if two elements in the array are swapped, we can find them out in one scan, that is whenever we see the previous value is larger than the current value, we can mark them.\\n\\nFor example, let's say we have a sorted array [0, 1] and we swap the values, so that array becomes [1, 0], when we scan through, we found that 1 > 0, we know that 1 and 0 are the nodes that are swapped by mistake.\\n\\nTake another example, in this array [0, 1, 2, 5, 4, 3], 3 and 5 are swapped by mistake, when we scan the array, we noticed that 5 > 4 and 4 > 3. How to get 3 and 5? Whenever we find a mistake, if it's the first one, mark both nodes as \"first\" and \"second\", for the second mistake, we just have to update the \"second\", see the codes below.\\n\\nBut we are not there yet, the question asks us to use constant space, so we can't store the values of the BST in an array, that will be O(n) space complexity. The solution is to use DFS and traverse the tree in inorder manner.\\n\\nSo time complexity is O(n), space complexity is O(1) (if we don't care about recursion stack, otherwise it's the height of the tree).\\n\\nBelow is the JavaScript code:\\n```\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar recoverTree = function(root) {\\n    // first and second are the two nodes that are swapped by mistake\\n    var prev, first, second;\\n    \\n    function inorder(root) {\\n        if (!root) return;\\n        \\n        inorder(root.left);\\n        \\n        if (prev && prev.val > root.val) {\\n            // Found a mistake\\n            if (!first) first = prev; // Only set the \"first\" once\\n            second = root; // Always update the \"second\"\\n        }\\n        prev = root;\\n        \\n        inorder(root.right);\\n    }\\n    \\n    inorder(root);\\n    \\n    // Swap the values of the two nodes\\n    var temp = first.val;\\n    first.val = second.val;\\n    second.val = temp;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar recoverTree = function(root) {\\n    // first and second are the two nodes that are swapped by mistake\\n    var prev, first, second;\\n    \\n    function inorder(root) {\\n        if (!root) return;\\n        \\n        inorder(root.left);\\n        \\n        if (prev && prev.val > root.val) {\\n            // Found a mistake\\n            if (!first) first = prev; // Only set the \"first\" once\\n            second = root; // Always update the \"second\"\\n        }\\n        prev = root;\\n        \\n        inorder(root.right);\\n    }\\n    \\n    inorder(root);\\n    \\n    // Swap the values of the two nodes\\n    var temp = first.val;\\n    first.val = second.val;\\n    second.val = temp;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32613,
                "title": "real-o-1-space-no-recursion-no-stack-etc-o-n-time-solution-48ms-c",
                "content": "Someone complained that a recursion solution isn't really a O(1) space solution. Ok, here comes the real O(1) solution. No recursion, no stack. Pure Morris traversal. 48 ms, C++ :\\n\\n    class Solution {\\n            TreeNode * wrong_node0 = nullptr, * wrong_node1 = nullptr, * prev = nullptr;\\n            void verify(TreeNode * cur)\\n            {\\n                if (prev != nullptr && prev -> val > cur -> val)\\n                {\\n                    if (wrong_node0 == nullptr)\\n                    {\\n                        wrong_node0 = prev;\\n                        wrong_node1 = cur; // in case the tree has only 2 elements.\\n                    }\\n                    else\\n                        wrong_node1 = cur;\\n                }\\n                prev = cur;\\n            }\\n            void morrisInorder(TreeNode * root)\\n            {\\n                TreeNode * cur = root;\\n                while (cur)\\n                {\\n                    if (cur->left == nullptr)\\n                    {\\n                        verify(cur);       \\n                        cur = cur->right;\\n                        continue;\\n                    }\\n                    TreeNode * pred = cur->left;\\n                    while (pred -> right != nullptr && pred -> right != cur)\\n                        pred = pred -> right; //finding predecessor\\n                    if (pred -> right == nullptr)\\n                    {\\n                        pred -> right = cur;\\n                        cur = cur -> left;\\n                    }else {//pred -> right == cur;\\n                        pred -> right = nullptr;\\n                        verify(cur);\\n                        cur = cur -> right;\\n                    }\\n                }\\n            }\\n        public:\\n            void recoverTree(TreeNode* root) {\\n                morrisInorder(root);\\n                swap(wrong_node0->val, wrong_node1->val);\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n            TreeNode * wrong_node0 = nullptr, * wrong_node1 = nullptr, * prev = nullptr;\\n            void verify(TreeNode * cur)\\n            {\\n                if (prev != nullptr && prev -> val > cur -> val)\\n                {\\n                    if (wrong_node0 == nullptr)\\n                    {\\n                        wrong_node0 = prev;\\n                        wrong_node1 = cur; // in case the tree has only 2 elements.\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1671711,
                "title": "constant-space-easy-in-order-traversal-with-explaination",
                "content": "The space taken by the recursion call is not considered as a space complexity here.\\nThe extra space is usually used to store the inorder traversal list. which is not used in this solution.\\n\\nInOrder traversal for BST means the tree is traversed in sorted order, so if any node breaks the sorted order that wll be our node to swap.\\nthat is the first and last node which breaks the sorting is our culprit !!\\n\\n```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n       \\n        res = []     \\n        startnode = None\\n        prev = None\\n        lastnode = None\\n        \\n        def dfs(root):\\n            nonlocal res, startnode, prev, lastnode\\n            if not root:\\n                return \\n            # go to left  (inorder step 1)  \\n            dfs(root.left)\\n\\t\\t\\t\\n            # do processing....(inorder step 2)\\n\\t\\t\\t# get the first node where the sorted order is broken the first time and the last time\\n            if prev and prev.val > root.val:\\n                if not startnode:\\n                    startnode = prev\\n                lastnode = root\\n                \\n            prev = root\\n\\t\\t\\t\\n            # go to right (inorder step 3)    \\n            dfs(root.right)\\n            \\n        \\n        dfs(root)\\n        # swap the nodes that are not in place\\n        if startnode and lastnode:\\n            startnode.val, lastnode.val = lastnode.val, startnode.val\\n```\\n\\n***Please upvote for motivation***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n       \\n        res = []     \\n        startnode = None\\n        prev = None\\n        lastnode = None\\n        \\n        def dfs(root):\\n            nonlocal res, startnode, prev, lastnode\\n            if not root:\\n                return \\n            # go to left  (inorder step 1)  \\n            dfs(root.left)\\n\\t\\t\\t\\n            # do processing....(inorder step 2)\\n\\t\\t\\t# get the first node where the sorted order is broken the first time and the last time\\n            if prev and prev.val > root.val:\\n                if not startnode:\\n                    startnode = prev\\n                lastnode = root\\n                \\n            prev = root\\n\\t\\t\\t\\n            # go to right (inorder step 3)    \\n            dfs(root.right)\\n            \\n        \\n        dfs(root)\\n        # swap the nodes that are not in place\\n        if startnode and lastnode:\\n            startnode.val, lastnode.val = lastnode.val, startnode.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1450119,
                "title": "intuitive-solution-explained-images",
                "content": "### Main idea - __*Inorder Traversal*__\\n\\n![image](https://assets.leetcode.com/users/images/dfb0dab7-b329-4fe6-9827-155227a556f1_1631084787.5005395.png)\\n![image](https://assets.leetcode.com/users/images/16060ed1-2d8c-479c-8d7f-1bc669f72f60_1631084843.3991785.png)\\n![image](https://assets.leetcode.com/users/images/023279fe-b5f2-4e4d-a203-e67a64e59826_1631016630.4750319.png)\\n![image](https://assets.leetcode.com/users/images/ff7e48bf-0485-4bc3-8d57-eb88a335a137_1631016655.0976954.png)\\n![image](https://assets.leetcode.com/users/images/51ab9566-fe0e-47d7-b418-db0fddef2476_1631016670.453483.png)\\n![image](https://assets.leetcode.com/users/images/6c3a4fcc-6088-413b-a357-6fce3dea0c06_1631016696.4263809.png)\\n\\ncode - \\n\\n```java\\n\\nclass Solution{\\npublic static ArrayList<TreeNode> arr;\\n\\n    public static void dfs(TreeNode root) {\\n        if (root == null) return;\\n        dfs(root.left);\\n        arr.add(root);\\n        dfs(root.right);\\n    }\\n\\n    public static void solve(TreeNode root) {\\n        arr = new ArrayList<TreeNode>();\\n        dfs(root);\\n        TreeNode a = null;\\n        TreeNode b = null;\\n        int n = arr.size();\\n        for (int i = 0; i < n; i++) {\\n            int left = i - 1 >= 0 ? arr.get(i - 1).val : Integer.MIN_VALUE;\\n            int right = i + 1 < n ? arr.get(i + 1).val : Integer.MAX_VALUE;\\n            int curr = arr.get(i).val;\\n            if (curr > left && curr > right && left < right) {\\n                a = arr.get(i);\\n            } else if (curr < left && curr < right && left < right) {\\n                b = arr.get(i);\\n            }\\n        }\\n        if (a != null && b != null) {\\n            int temp = a.val;\\n            a.val = b.val;\\n            b.val = temp;\\n        }\\n    }\\n}\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```java\\n\\nclass Solution{\\npublic static ArrayList<TreeNode> arr;\\n\\n    public static void dfs(TreeNode root) {\\n        if (root == null) return;\\n        dfs(root.left);\\n        arr.add(root);\\n        dfs(root.right);\\n    }\\n\\n    public static void solve(TreeNode root) {\\n        arr = new ArrayList<TreeNode>();\\n        dfs(root);\\n        TreeNode a = null;\\n        TreeNode b = null;\\n        int n = arr.size();\\n        for (int i = 0; i < n; i++) {\\n            int left = i - 1 >= 0 ? arr.get(i - 1).val : Integer.MIN_VALUE;\\n            int right = i + 1 < n ? arr.get(i + 1).val : Integer.MAX_VALUE;\\n            int curr = arr.get(i).val;\\n            if (curr > left && curr > right && left < right) {\\n                a = arr.get(i);\\n            } else if (curr < left && curr < right && left < right) {\\n                b = arr.get(i);\\n            }\\n        }\\n        if (a != null && b != null) {\\n            int temp = a.val;\\n            a.val = b.val;\\n            b.val = temp;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926227,
                "title": "100-fastest-swift-solution-time-o-n-space-o-h",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(h), where h is the height of the binary tree.\\n\\n    private var first: TreeNode?\\n    private var second: TreeNode?\\n    private var prev = TreeNode(Int.min)\\n\\n    \\n    func recoverTree(_ root: TreeNode?) {\\n        traverse(root)\\n\\n        guard let first = first, let second = second else { return }\\n\\n        let tmp = first.val\\n        first.val = second.val\\n        second.val = tmp\\n    }\\n\\n\\n    private func traverse(_ root: TreeNode?) {\\n        guard let root = root else { return }\\n        traverse(root.left)\\n\\n        if first == nil, prev.val >= root.val { first = prev }\\n        if first != nil, prev.val >= root.val { second = root }\\n        prev = root\\n\\n        traverse(root.right)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(h), where h is the height of the binary tree.\\n\\n    private var first: TreeNode?\\n    private var second: TreeNode?\\n    private var prev = TreeNode(Int.min)\\n\\n    \\n    func recoverTree(_ root: TreeNode?) {\\n        traverse(root)\\n\\n        guard let first = first, let second = second else { return }\\n\\n        let tmp = first.val\\n        first.val = second.val\\n        second.val = tmp\\n    }\\n\\n\\n    private func traverse(_ root: TreeNode?) {\\n        guard let root = root else { return }\\n        traverse(root.left)\\n\\n        if first == nil, prev.val >= root.val { first = prev }\\n        if first != nil, prev.val >= root.val { second = root }\\n        prev = root\\n\\n        traverse(root.right)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962740,
                "title": "python-simple-o-n-log-n-beats-94",
                "content": "This solution compares the in-order traversal of the tree, which in a correct binary tree should return the elements sorted in ascending order. We then compare this against the sorted elements and swap as soon as we find a mismatch.\\n\\n```python\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        in_order = []\\n        def inOrder(node):\\n            if node is None:\\n                return\\n            inOrder(node.left)\\n            in_order.append(node)\\n            inOrder(node.right)\\n        \\n        inOrder(root)\\n\\n        sorted_order = sorted(in_order, key=lambda x:x.val)\\n        for i in range(len(in_order)):\\n            if in_order[i] != sorted_order[i]:\\n                in_order[i].val, sorted_order[i].val = sorted_order[i].val, in_order[i].val\\n                return\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        in_order = []\\n        def inOrder(node):\\n            if node is None:\\n                return\\n            inOrder(node.left)\\n            in_order.append(node)\\n            inOrder(node.right)\\n        \\n        inOrder(root)\\n\\n        sorted_order = sorted(in_order, key=lambda x:x.val)\\n        for i in range(len(in_order)):\\n            if in_order[i] != sorted_order[i]:\\n                in_order[i].val, sorted_order[i].val = sorted_order[i].val, in_order[i].val\\n                return\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1356869,
                "title": "python-very-easy-to-understand-idea-inorder",
                "content": "\\n```\\nclass Solution:\\n    \\n    \"\"\"\\n        Brute force kind of thing\\n        -> Inorder Traversal returns sorted array\\n        -> find a swap btwn numbers to make sorted\\n        Make single swap to make array sorted\\n        [1, 2, 3, 4, 10, 6, 9, 5, 10, 12]\\n         x, x, x, x, x, No\\n            prev number is mismatch -> 10 is cause\\n        now go frm right to left\\n        [1, 2, 3, 4, 10, 6, 9, 5, 11, 12]\\n                            No x   x   x\\n                        mismatch with next number -> 5 is the cause\\n        swap 10, 5\\n        \\n        Eg: 2\\n        [3, 2, 1]\\n         x  No -> 3 is the cause\\n        [3, 2, 1]\\n         x  No -> 1 is the cause\\n        swap values -> 1, 3\\n    \"\"\"\\n    \\n    def inorder(self, root, li):\\n        if root is None:\\n            return li\\n        li = self.inorder(root.left, li)\\n        li.append(root)\\n        li = self.inorder(root.right, li)\\n        return li\\n    \\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        li = self.inorder(root, [])\\n        n = len(li)\\n        i, j = 1, n-2\\n        a = li[0]\\n        for i in range(1, n):\\n            if li[i].val < li[i-1].val:\\n                a = li[i-1]\\n                break\\n        b = li[-1]\\n        for i in range(n-2, -1, -1):\\n            if li[i].val > li[i+1].val:\\n                b = li[i+1]\\n                break\\n\\n        a.val,b.val = b.val, a.val\\n\\n```\\n\\nNote: We can do LDR, and RDL for 2 loops to get that root1, root2 values [Constant space Operation]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    \"\"\"\\n        Brute force kind of thing\\n        -> Inorder Traversal returns sorted array\\n        -> find a swap btwn numbers to make sorted\\n        Make single swap to make array sorted\\n        [1, 2, 3, 4, 10, 6, 9, 5, 10, 12]\\n         x, x, x, x, x, No\\n            prev number is mismatch -> 10 is cause\\n        now go frm right to left\\n        [1, 2, 3, 4, 10, 6, 9, 5, 11, 12]\\n                            No x   x   x\\n                        mismatch with next number -> 5 is the cause\\n        swap 10, 5\\n        \\n        Eg: 2\\n        [3, 2, 1]\\n         x  No -> 3 is the cause\\n        [3, 2, 1]\\n         x  No -> 1 is the cause\\n        swap values -> 1, 3\\n    \"\"\"\\n    \\n    def inorder(self, root, li):\\n        if root is None:\\n            return li\\n        li = self.inorder(root.left, li)\\n        li.append(root)\\n        li = self.inorder(root.right, li)\\n        return li\\n    \\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        li = self.inorder(root, [])\\n        n = len(li)\\n        i, j = 1, n-2\\n        a = li[0]\\n        for i in range(1, n):\\n            if li[i].val < li[i-1].val:\\n                a = li[i-1]\\n                break\\n        b = li[-1]\\n        for i in range(n-2, -1, -1):\\n            if li[i].val > li[i+1].val:\\n                b = li[i+1]\\n                break\\n\\n        a.val,b.val = b.val, a.val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448583,
                "title": "javascript-solution",
                "content": "### The Idea\\n1. In-order dfs traverse the tree in ascending order (very Important)\\n2. Save a record of the previous node, if the current node is smaller than the previous node, that means we\\'ve found 2 potential elements that will be swapped.\\n3. Out of the 2 potential elements, we are sure that the bigger one must be swapped, however, the smaller one aren\\'t sure, so we need to continue the dfs.\\n*The idea of the swapping mechanism is exactly the same in \"sorting an almost sorted array\"\\n``` javascript\\nvar recoverTree = function(root) {\\n    let prev = null, big = null, small = null;\\n    let dfs = function(root) {\\n        if (!root) return;\\n        dfs(root.left);\\n        if (prev != null && prev.val > root.val) {\\n            small = root; // potential smaller number that needs to be swapped\\n            if (!big) big = prev; // assured bigger number that needs to be swapped\\n            else return;\\n        }\\n        prev = root;\\n        dfs(root.right);\\n    }\\n    \\n    dfs(root);\\n    [big.val, small.val] = [small.val, big.val];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar recoverTree = function(root) {\\n    let prev = null, big = null, small = null;\\n    let dfs = function(root) {\\n        if (!root) return;\\n        dfs(root.left);\\n        if (prev != null && prev.val > root.val) {\\n            small = root; // potential smaller number that needs to be swapped\\n            if (!big) big = prev; // assured bigger number that needs to be swapped\\n            else return;\\n        }\\n        prev = root;\\n        dfs(root.right);\\n    }\\n    \\n    dfs(root);\\n    [big.val, small.val] = [small.val, big.val];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32646,
                "title": "python-inorder-traversal-solution-based-on-validate-binary-search-tree",
                "content": "    class Solution:\\n    # @param root, a tree node\\n    # @return a tree node\\n    def recoverTree(self, root):\\n        it = self.isValidBST(root)\\n        a, b = next(it)\\n        c = next(it, None)\\n        if c:\\n            _, c = c\\n            a.val, c.val = c.val, a.val\\n        else:\\n            a.val, b.val = b.val, a.val\\n        return root\\n\\n    def isValidBST(self, root):\\n        pre, cur, stack = None, root, []\\n        while stack or cur:\\n            while cur:\\n                stack.append(cur)\\n                cur = cur.left\\n            s = stack.pop()\\n            if pre and s.val <= pre.val:\\n                yield pre, s\\n            pre, cur = s, s.right\\n\\nThis is a simple O(n) space solution.\\n\\nAdd Java solution\\n\\n    TreeNode prev = null;\\n    LinkedList<TreeNode> result = new LinkedList<TreeNode>();\\n\\n    public void recoverTree(TreeNode root) {\\n        isValidBST(root);\\n        TreeNode first = result.poll();\\n        TreeNode last = result.pollLast();\\n        int temp = first.val;\\n        first.val = last.val;\\n        last.val = temp;\\n    }\\n\\n    private void isValidBST(TreeNode root) {\\n        if (root == null)\\n            return;\\n        isValidBST(root.left);\\n        if (prev != null && root.val < prev.val) {\\n            result.add(prev);\\n            result.add(root);\\n        }\\n        prev = root;\\n        isValidBST(root.right);\\n    }",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param root, a tree node\\n    # @return a tree node\\n    def recoverTree(self, root):\\n        it = self.isValidBST(root)\\n        a, b = next(it)\\n        c = next(it, None)\\n        if c:\\n            _, c = c\\n            a.val, c.val = c.val, a.val\\n        else:\\n            a.val, b.val = b.val, a.val\\n        return root\\n\\n    def isValidBST(self, root):\\n        pre, cur, stack = None, root, []\\n        while stack or cur:\\n            while cur:\\n                stack.append(cur)\\n                cur = cur.left\\n            s = stack.pop()\\n            if pre and s.val <= pre.val:\\n                yield pre, s\\n            pre, cur = s, s.right\\n\\nThis is a simple O(n) space solution.\\n\\nAdd Java solution\\n\\n    TreeNode prev = null;\\n    LinkedList<TreeNode> result = new LinkedList<TreeNode>();\\n\\n    public void recoverTree(TreeNode root) {\\n        isValidBST(root);\\n        TreeNode first = result.poll();\\n        TreeNode last = result.pollLast();\\n        int temp = first.val;\\n        first.val = last.val;\\n        last.val = temp;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1962728,
                "title": "easy-to-understand-java",
                "content": "```\\nclass Solution {\\n    private TreeNode first = null;\\n    private TreeNode second = null;\\n    private TreeNode pre = null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        if(root==null) return;\\n\\n        //find swapped nodes\\n        inorder(root);\\n        \\n        //swap the nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n        \\n        //find the first node which is at wrong position\\n        if(first==null && (pre==null ||pre.val>=root.val)){\\n            first = pre;\\n        }\\n        \\n        //find the second node which is at wrong position\\n        if(first!=null && pre.val>=root.val){\\n            second = root;\\n        }\\n        \\n        //store previus node to compare\\n        pre = root;\\n        inorder(root.right);\\n    }\\n}\\n```\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Don\\'t Forget to **upvote**\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private TreeNode first = null;\\n    private TreeNode second = null;\\n    private TreeNode pre = null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        if(root==null) return;\\n\\n        //find swapped nodes\\n        inorder(root);\\n        \\n        //swap the nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n        \\n        //find the first node which is at wrong position\\n        if(first==null && (pre==null ||pre.val>=root.val)){\\n            first = pre;\\n        }\\n        \\n        //find the second node which is at wrong position\\n        if(first!=null && pre.val>=root.val){\\n            second = root;\\n        }\\n        \\n        //store previus node to compare\\n        pre = root;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32607,
                "title": "beat-99-fast-java-solution-o-h-space-with-explanation",
                "content": "The basic idea is to use stack to do in-order traversal. In the processing of traversal, keep comparing the current value with the previous value. Since each previous value should be less than the current value, once an exception is found, record the previous node as the First Mistaken Node and the current node as Second. If one more exceptions are found, override the current node to the Second Mistaken Node. Because if a series of mistaken nodes are found, the only possible way to correct them with one swap is to switch the head and tail node. \\n\\n    public void recoverTree(TreeNode root) {\\n\\t\\tTreeNode pre = null, first = null, second = null;\\n\\t\\tDeque<TreeNode> stack = new LinkedList<TreeNode>();\\n\\t\\twhile (root != null) {\\n\\t\\t\\tstack.push(root);\\n\\t\\t\\troot = root.left;\\n\\t\\t}\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tTreeNode temp = stack.pop();\\n\\t\\t\\tif (pre != null)\\n\\t\\t\\t\\tif (pre.val > temp.val) {\\n\\t\\t\\t\\t\\tif (first == null)\\n\\t\\t\\t\\t\\t\\tfirst = pre;\\n\\t\\t\\t\\t\\tsecond = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\tpre = temp;\\n\\t\\t\\tif (temp.right != null) {\\n\\t\\t\\t\\ttemp = temp.right;\\n\\t\\t\\t\\twhile (temp != null) {\\n\\t\\t\\t\\t\\tstack.push(temp);\\n\\t\\t\\t\\t\\ttemp = temp.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint temp = first.val;\\n\\t\\tfirst.val = second.val;\\n\\t\\tsecond.val = temp;\\n\\t}",
                "solutionTags": [],
                "code": "The basic idea is to use stack to do in-order traversal. In the processing of traversal, keep comparing the current value with the previous value. Since each previous value should be less than the current value, once an exception is found, record the previous node as the First Mistaken Node and the current node as Second. If one more exceptions are found, override the current node to the Second Mistaken Node. Because if a series of mistaken nodes are found, the only possible way to correct them with one swap is to switch the head and tail node. \\n\\n    public void recoverTree(TreeNode root) {\\n\\t\\tTreeNode pre = null, first = null, second = null;\\n\\t\\tDeque<TreeNode> stack = new LinkedList<TreeNode>();\\n\\t\\twhile (root != null) {\\n\\t\\t\\tstack.push(root);\\n\\t\\t\\troot = root.left;\\n\\t\\t}\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tTreeNode temp = stack.pop();\\n\\t\\t\\tif (pre != null)\\n\\t\\t\\t\\tif (pre.val > temp.val) {\\n\\t\\t\\t\\t\\tif (first == null)\\n\\t\\t\\t\\t\\t\\tfirst = pre;\\n\\t\\t\\t\\t\\tsecond = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\tpre = temp;\\n\\t\\t\\tif (temp.right != null) {\\n\\t\\t\\t\\ttemp = temp.right;\\n\\t\\t\\t\\twhile (temp != null) {\\n\\t\\t\\t\\t\\tstack.push(temp);\\n\\t\\t\\t\\t\\ttemp = temp.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint temp = first.val;\\n\\t\\tfirst.val = second.val;\\n\\t\\tsecond.val = temp;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1138233,
                "title": "self-explanatory-easy-solution-for-hard-question",
                "content": "- Prerequisites [**Validate Binary Search Tree**](https://leetcode.com/problems/validate-binary-search-tree) \\n- My [Solution for Validate BST](https://leetcode.com/problems/validate-binary-search-tree/discuss/1138232/Self-Explanatory-Easy-DFS-Solution)\\n- By Saurav Kumar Gupta\\n- Please **upvote** if it helps you.\\n\\n```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *prev = nullptr;\\n        TreeNode *first = nullptr;\\n        TreeNode *second = nullptr;\\n        \\n        stack<TreeNode *> S;\\n        \\n        while(root || !S.empty()) {\\n            while(root) {\\n                S.push(root);\\n                root = root->left;\\n            }\\n            \\n            root = S.top(); S.pop();\\n            \\n            if(prev && prev->val > root->val) {\\n                if(!first) first = prev;\\n                second = root;\\n            }\\n            \\n            prev = root;\\n            root = root->right;\\n        }\\n        \\n        swap(first->val , second->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *prev = nullptr;\\n        TreeNode *first = nullptr;\\n        TreeNode *second = nullptr;\\n        \\n        stack<TreeNode *> S;\\n        \\n        while(root || !S.empty()) {\\n            while(root) {\\n                S.push(root);\\n                root = root->left;\\n            }\\n            \\n            root = S.top(); S.pop();\\n            \\n            if(prev && prev->val > root->val) {\\n                if(!first) first = prev;\\n                second = root;\\n            }\\n            \\n            prev = root;\\n            root = root->right;\\n        }\\n        \\n        swap(first->val , second->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32546,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Recover Binary Search Tree** https://leetcode.com/problems/recover-binary-search-tree/?tab=Description\\n\\n**Algorithm**\\n1. Use a tree example: [100, 50, 200, 25, 75, 99, 400]\\n2. Sorted Order: 25,50,75,100,150,200,400\\n3. You can have out of order 50 and 200: 25,**200**,75,100,150,**50**,400. Notice in this case we have 2 out of order pairs: (200,75) and (150,50). Simply swap 200 and 50.\\n4. What if 25/50 or 200/400 are swapped? In that case we will have just one out of order element.\\n5. 3 and 4 give us our algorithm.\\n\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        self.order = []\\n        self.prev = None\\n        self.inorder(root)\\n        if len(self.order) == 2:\\n            self.swap(self.order[0][0], self.order[1][1])\\n        elif len(self.order) == 1:\\n            self.swap(self.order[0][0], self.order[0][1])\\n        return\\n    \\n    def inorder(self, root):\\n        if root == None:\\n            return\\n        self.inorder(root.left)\\n        if self.prev and self.prev.val > root.val:\\n            self.order.append((self.prev, root))\\n        self.prev = root\\n        self.inorder(root.right)\\n        return\\n    \\n    def swap(self, r1, r2):\\n        r1.val, r2.val = r2.val, r1.val\\n        return\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        self.order = []\\n        self.prev = None\\n        self.inorder(root)\\n        if len(self.order) == 2:\\n            self.swap(self.order[0][0], self.order[1][1])\\n        elif len(self.order) == 1:\\n            self.swap(self.order[0][0], self.order[0][1])\\n        return\\n    \\n    def inorder(self, root):\\n        if root == None:\\n            return\\n        self.inorder(root.left)\\n        if self.prev and self.prev.val > root.val:\\n            self.order.append((self.prev, root))\\n        self.prev = root\\n        self.inorder(root.right)\\n        return\\n    \\n    def swap(self, r1, r2):\\n        r1.val, r2.val = r2.val, r1.val\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32592,
                "title": "an-elegent-o-n-time-complexity-and-o-1-space-complexity-algorithm",
                "content": "Note: 1. Given a sequence `{1, 4, 3, 7, 9}`, you find pair `4(!<=)3`, swap this pair and sequence is in order.<br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa02. Given a sequence `{1, 9, 4, 5, 3, 10}`, you get first pair `9(!<=)4` and second pair `5(!<=)3`, swap pair `9(!<=)3` and sequence is in order.<br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa03. Given a sequence, only in two above (general) cases, that you can just swap one pair numbers to convert an unordered sequence into ordered. <br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa04. You can tranverse BST inorder to get above sequence.<br/>So, my alg is:<br/>\\n\\n    void recover(TreeNode *root, TreeNode *&pre, TreeNode *&a, TreeNode *&b) {\\n        if (root)\\n        {\\n            recover(root->left, pre, a, b);\\n            \\n            if (root->val < pre->val)\\n            {\\n                if (!a) a = pre; //a should change once.\\n                b = root; //b could change twice.\\n            }\\n            pre = root;\\n            \\n            recover(root->right, pre, a, b);\\n        }\\n    }\\n    void recoverTree(TreeNode *root) {\\n        if (!root) return;\\n        \\n        TreeNode p(numeric_limits<int>::min());\\n        TreeNode *a, *b, *pre;\\n        a = b = 0;\\n        pre = &p;\\n        recover(root, pre, a, b);\\n        if (a && b)\\n        {\\n            swap(a->val, b->val);\\n        }\\n        return;\\n    }\\n\\nI think this problem requirement is strange. Does O(1) space complexity algorithm exists?\\n<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. Does BST should be tranversed?<br/>&nbsp;&nbsp;&nbsp;&nbsp; 2. If answer of `1` is true, I don't think an O(1) space complexity exists, for there does not exists a BST tranverse algorithm taking O(1) space complexity.<br/>&nbsp;&nbsp;&nbsp;&nbsp;3. If answer of `1` is false, I just wonder how can you find the disordered pair.",
                "solutionTags": [],
                "code": "Note: 1. Given a sequence `{1, 4, 3, 7, 9}`, you find pair `4(!<=)3`, swap this pair and sequence is in order.<br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa02. Given a sequence `{1, 9, 4, 5, 3, 10}`, you get first pair `9(!<=)4` and second pair `5(!<=)3`, swap pair `9(!<=)3` and sequence is in order.<br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa03. Given a sequence, only in two above (general) cases, that you can just swap one pair numbers to convert an unordered sequence into ordered. <br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa04. You can tranverse BST inorder to get above sequence.<br/>So, my alg is:<br/>\\n\\n    void recover(TreeNode *root, TreeNode *&pre, TreeNode *&a, TreeNode *&b) {\\n        if (root)\\n        {\\n            recover(root->left, pre, a, b);\\n            \\n            if (root->val < pre->val)\\n            {\\n                if (!a) a = pre; //a should change once.\\n                b = root; //b could change twice.\\n            }\\n            pre = root;\\n            \\n            recover(root->right, pre, a, b);\\n        }\\n    }\\n    void recoverTree(TreeNode *root) {\\n        if (!root) return;\\n        \\n        TreeNode p(numeric_limits<int>::min());\\n        TreeNode *a, *b, *pre;\\n        a = b = 0;\\n        pre = &p;\\n        recover(root, pre, a, b);\\n        if (a && b)\\n        {\\n            swap(a->val, b->val);\\n        }\\n        return;\\n    }\\n\\nI think this problem requirement is strange. Does O(1) space complexity algorithm exists?\\n<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. Does BST should be tranversed?<br/>&nbsp;&nbsp;&nbsp;&nbsp; 2. If answer of `1` is true, I don't think an O(1) space complexity exists, for there does not exists a BST tranverse algorithm taking O(1) space complexity.<br/>&nbsp;&nbsp;&nbsp;&nbsp;3. If answer of `1` is false, I just wonder how can you find the disordered pair.",
                "codeTag": "Unknown"
            },
            {
                "id": 1962388,
                "title": "c-cheating-with-sort-vector-and-inorder-traversal",
                "content": "Couldn\\'t figure it out the big brain way, so here is the cheater\\'s solution.\\n\\n**SOLVED LIVE ON STREAM.  Everyday 6pm PT. Link in profile**\\n\\n```\\nclass Solution {\\n\\n    void dfs(TreeNode* root, vector<int>& cheat) {\\n        if(!root) return;\\n        \\n        dfs(root->left, cheat);\\n        cheat.push_back(root->val);\\n        dfs(root->right, cheat);\\n    }\\n    \\n    void cheatAgain(TreeNode* root, vector<int>& cheat, int& i) {\\n        if(!root) return;\\n        cheatAgain(root->left, cheat, i);\\n        if(root->val != cheat[i]) {\\n            root->val = cheat[i];\\n        }\\n        i++;\\n        cheatAgain(root->right, cheat, i);\\n        \\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        vector<int> cheat;\\n        dfs(root, cheat);\\n        sort(cheat.begin(), cheat.end());\\n        int i = 0;\\n        cheatAgain(root, cheat, i);\\n        return;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    void dfs(TreeNode* root, vector<int>& cheat) {\\n        if(!root) return;\\n        \\n        dfs(root->left, cheat);\\n        cheat.push_back(root->val);\\n        dfs(root->right, cheat);\\n    }\\n    \\n    void cheatAgain(TreeNode* root, vector<int>& cheat, int& i) {\\n        if(!root) return;\\n        cheatAgain(root->left, cheat, i);\\n        if(root->val != cheat[i]) {\\n            root->val = cheat[i];\\n        }\\n        i++;\\n        cheatAgain(root->right, cheat, i);\\n        \\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        vector<int> cheat;\\n        dfs(root, cheat);\\n        sort(cheat.begin(), cheat.end());\\n        int i = 0;\\n        cheatAgain(root, cheat, i);\\n        return;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917951,
                "title": "python-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=XHx4OQ5BLoE)\\nhttps://www.youtube.com/watch?v=XHx4OQ5BLoE\\n```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        curr = root\\n        prev = TreeNode(float(\\'-inf\\'))\\n        replace = []\\n        stack = []\\n        \\n        while curr or stack:\\n            while curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            \\n            temp = stack.pop()\\n            \\n            if temp.val < prev.val:\\n                replace.append((prev, temp))\\n            \\n            prev = temp\\n            curr = temp.right\\n        \\n        replace[0][0].val, replace[-1][1].val = replace[-1][1].val, replace[0][0].val \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        curr = root\\n        prev = TreeNode(float(\\'-inf\\'))\\n        replace = []\\n        stack = []\\n        \\n        while curr or stack:\\n            while curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            \\n            temp = stack.pop()\\n            \\n            if temp.val < prev.val:\\n                replace.append((prev, temp))\\n            \\n            prev = temp\\n            curr = temp.right\\n        \\n        replace[0][0].val, replace[-1][1].val = replace[-1][1].val, replace[0][0].val \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772201,
                "title": "c-solutions-easy-to-solve",
                "content": "```\\nclass Solution {\\npublic:\\n\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(firstMistake == nullptr && root->val < pre->val)\\n\\t\\t\\tfirstMistake = pre;\\n\\t\\tif(firstMistake != nullptr && root->val < pre->val)\\n\\t\\t\\tsecondMistake = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(firstMistake == nullptr && root->val < pre->val)\\n\\t\\t\\tfirstMistake = pre;\\n\\t\\tif(firstMistake != nullptr && root->val < pre->val)\\n\\t\\t\\tsecondMistake = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339518,
                "title": "easy-to-understand-inorder-traversal",
                "content": "we first need to find the two nodes that are not valid under the condition for bst i.e the inorder of bst is always sorted, once we find the two nodes, we will normally swap it. \\nDone!!!\\n\\n\\n```\\nclass Solution {\\n    TreeNode prev = null;TreeNode first = null; TreeNode second = null;\\n    \\n    public void inorderHelper(TreeNode root)\\n    {\\n        if(root == null)  return;\\n        \\n        inorderHelper(root.left);\\n        \\n        if(first == null && prev != null && prev.val >= root.val)\\n            first = prev;\\n        \\n        if(first != null && prev.val >= root.val)\\n            second = root;\\n        \\n        prev = root;\\n        \\n        inorderHelper(root.right);\\n    }\\n    \\n    public void swap(TreeNode first, TreeNode second)\\n    {\\n        int temp = first.val;\\n        \\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    public void recoverTree(TreeNode root)\\n    {\\n        prev = null; first = null; second = null;\\n        \\n        inorderHelper(root);\\n        \\n        swap(first,second);\\n    \\n    }\\n}\\n```\\n\\nthe cpp solution for the same\\n```\\nclass Solution {\\npublic:\\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    TreeNode* prev = NULL;\\n    \\n    void inorderRecover(TreeNode*& root)\\n    {\\n        if(!root) return;\\n         \\n        inorderRecover(root->left);\\n        \\n        if(!first && prev && prev->val >= root->val)\\n            first = prev;\\n        \\n        if(first && prev->val >= root->val)\\n            second = root;\\n        \\n        prev = root;\\n        \\n        inorderRecover(root->right);\\n    }\\n    \\n    void swap(TreeNode*& first, TreeNode*& second)\\n    {\\n        int temp = first->val;\\n        \\n        first->val = second->val;\\n        second->val = temp;\\n    }\\n    \\n    void recoverTree(TreeNode* root) \\n    {\\n        inorderRecover(root);\\n        \\n        swap(first,second);\\n    }\\n};\\n```\\n Feel free to give your suggestions or correct me in the comments. Thanks for reading.\\uD83D\\uDE43\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev = null;TreeNode first = null; TreeNode second = null;\\n    \\n    public void inorderHelper(TreeNode root)\\n    {\\n        if(root == null)  return;\\n        \\n        inorderHelper(root.left);\\n        \\n        if(first == null && prev != null && prev.val >= root.val)\\n            first = prev;\\n        \\n        if(first != null && prev.val >= root.val)\\n            second = root;\\n        \\n        prev = root;\\n        \\n        inorderHelper(root.right);\\n    }\\n    \\n    public void swap(TreeNode first, TreeNode second)\\n    {\\n        int temp = first.val;\\n        \\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    public void recoverTree(TreeNode root)\\n    {\\n        prev = null; first = null; second = null;\\n        \\n        inorderHelper(root);\\n        \\n        swap(first,second);\\n    \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    TreeNode* prev = NULL;\\n    \\n    void inorderRecover(TreeNode*& root)\\n    {\\n        if(!root) return;\\n         \\n        inorderRecover(root->left);\\n        \\n        if(!first && prev && prev->val >= root->val)\\n            first = prev;\\n        \\n        if(first && prev->val >= root->val)\\n            second = root;\\n        \\n        prev = root;\\n        \\n        inorderRecover(root->right);\\n    }\\n    \\n    void swap(TreeNode*& first, TreeNode*& second)\\n    {\\n        int temp = first->val;\\n        \\n        first->val = second->val;\\n        second->val = temp;\\n    }\\n    \\n    void recoverTree(TreeNode* root) \\n    {\\n        inorderRecover(root);\\n        \\n        swap(first,second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225150,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func recoverTree(_ root: TreeNode?) {\\n        var lhs: TreeNode?, rhs: TreeNode?, prev: TreeNode?\\n        func bfs(_ root: TreeNode?) {\\n            guard let node = root else { return }\\n            bfs(node.left)\\n            if lhs == nil, let prev = prev, prev.val > node.val { lhs = prev }\\n            if lhs != nil, rhs == nil || node.val < rhs!.val { rhs = node }\\n            prev = node\\n            bfs(node.right)\\n        }\\n        bfs(root)\\n        if let lhs = lhs, let rhs = rhs {\\n            let tmp = lhs.val\\n            lhs.val = rhs.val\\n            rhs.val = tmp\\n        }\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.034 (0.036) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test1() {\\n        let tree = TreeNode([1,3,nil,nil,2])\\n        solution.recoverTree(tree)\\n        XCTAssertEqual(tree?.val, TreeNode([3,1,nil,nil,2])?.val)\\n    }\\n    \\n    func test2() {\\n        let tree = TreeNode([3,1,4,nil,nil,2])\\n        solution.recoverTree(tree)\\n        XCTAssertEqual(tree?.val, TreeNode([2,1,4,nil,nil,3])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n\\n<details>\\n<summary><b>TreeNode</b></summary>\\n\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ nums: [Int?]) {\\n        var arr = nums\\n        guard !arr.isEmpty, let head = arr.removeFirst() else { return nil }\\n        val = head; left = nil; right = nil\\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let root = queue.removeFirst()\\n            if !arr.isEmpty, let val = arr.removeFirst() {\\n                root.left = TreeNode(val)\\n                queue.append(root.left!)\\n            }\\n            if !arr.isEmpty, let val = arr.removeFirst() {\\n                root.right = TreeNode(val)\\n                queue.append(root.right!)\\n            }\\n        }\\n    }\\n}\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift",
                    "Breadth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func recoverTree(_ root: TreeNode?) {\\n        var lhs: TreeNode?, rhs: TreeNode?, prev: TreeNode?\\n        func bfs(_ root: TreeNode?) {\\n            guard let node = root else { return }\\n            bfs(node.left)\\n            if lhs == nil, let prev = prev, prev.val > node.val { lhs = prev }\\n            if lhs != nil, rhs == nil || node.val < rhs!.val { rhs = node }\\n            prev = node\\n            bfs(node.right)\\n        }\\n        bfs(root)\\n        if let lhs = lhs, let rhs = rhs {\\n            let tmp = lhs.val\\n            lhs.val = rhs.val\\n            rhs.val = tmp\\n        }\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test1() {\\n        let tree = TreeNode([1,3,nil,nil,2])\\n        solution.recoverTree(tree)\\n        XCTAssertEqual(tree?.val, TreeNode([3,1,nil,nil,2])?.val)\\n    }\\n    \\n    func test2() {\\n        let tree = TreeNode([3,1,4,nil,nil,2])\\n        solution.recoverTree(tree)\\n        XCTAssertEqual(tree?.val, TreeNode([2,1,4,nil,nil,3])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ nums: [Int?]) {\\n        var arr = nums\\n        guard !arr.isEmpty, let head = arr.removeFirst() else { return nil }\\n        val = head; left = nil; right = nil\\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let root = queue.removeFirst()\\n            if !arr.isEmpty, let val = arr.removeFirst() {\\n                root.left = TreeNode(val)\\n                queue.append(root.left!)\\n            }\\n            if !arr.isEmpty, let val = arr.removeFirst() {\\n                root.right = TreeNode(val)\\n                queue.append(root.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223843,
                "title": "detailed-explanation-of-solution-with-code",
                "content": "Inorder traversal of BST gives the elements in increasing order -> Almost all BST problems are based on this property.\\n\\nSolution 1: Using O(n) space, we can store the inorder traversal of the BST and then find the out-of-order elements, and swap them in the BST.\\nSolution 2: Using constant space and one pass of the BST. Let\\'s dive into it.\\n\\nThink about it. Do you really need to store all the elements to find the out-of-order numbers?\\nNo, you don\\'t. Since there are exactly 2 faulty nodes, we don\\'t need to store the entire traversal. How?\\nWe can keep track of the previously visited node, and compare its value with the current node. Whenever current.val < previous.val, we have found our anomaly.\\n\\nNow there can be 2 possible scenarios. Either the swapped elements are adjacent in the inorder traversal (not in the BST), or they are not.\\n\\nExample 1: Not adjacent\\n\\n        1\\n\\t  /\\n\\t3\\n      \\\\\\n        2\\n\\nThe inorder traversal of this tree is [3,2,1]. Here the swapped nodes are 1 and 3. \\n\\nExample 2: Adjacent\\n\\n        3\\n\\t  /   \\\\\\n\\t1       4\\n\\t      / \\n\\t    2 \\n\\nThe inorder traversal of this tree is [1,3,2,4]. Here the swapped nodes are 3 and 2. \\n\\n**Scenario 1**(Not adjacent) :\\n\\nIf you swap 2 non adjacent numbers in a sorted list, you would move a smaller number among bigger numbers and a bigger number among smaller numbers.\\n\\nFor instance, 1,2,3,4,5,6,7 => If you swap 3 with 6, you would move 6 between 2 and 4 (smaller than 6) and 3 between 5 and 7 (bigger than 3).\\nSo the faulty list will be [1,2,6,4,5,3,7]. Suppose this was our input to begin with. \\nWe will look for the anomaly now.\\n\\nprevious = 1, current = 2 Here previous < current => No anomaly. \\nprevious = 2, current = 6 Here previous < current => No anomaly.\\nprevious = 6, current = 4 Here previous > current => ANOMALY.\\nSimilarly, \\nprevious = 5, current = 3 Here previous > current => ANOMALY.\\n\\n**Scenario 2**(Adjacent)\\n\\nIn this case you will not find a second anomaly. So, swap previous with current.\\n\\nNow when we first encounter the anomaly, the faulty node is previous. But when we encounter 2nd anomaly, faulty node is current.\\n**Why? When you swap 2 non adjacent numbers in a sorted list, you would move a smaller number among bigger numbers and a bigger number among smaller numbers.**\\n\\nAlgorithm: \\n1. Initialise faultyA, faultyB, previous as null.\\n2. Visit every node, and keep track of the previous node.\\n3. if current < previous, then assign previous node to faultyA and current node to faultyB (for Scenario 2)\\n4. if current < previous is encountered again, or, if faultyA != null, assign currentNode to faultyB.\\n5. After traversal is complete, swap the faulty nodes.\\n\\nCode:\\n```\\nclass Solution {\\n    TreeNode faultyA = null;\\n    TreeNode faultyB = null;\\n    TreeNode mPrevious = null;\\n    public void recoverTree(TreeNode root) {\\n        findFaultyNodes(root);\\n        \\n        //Swap faulty nodes\\n        if(faultyA != null && faultyB != null) {\\n            int temp = faultyA.val;\\n            faultyA.val = faultyB.val;\\n            faultyB.val = temp;\\n        }\\n    }\\n    \\n    private void findFaultyNodes(TreeNode node) {\\n        if(node == null) {\\n            return;\\n        }\\n        \\n        findFaultyNodes(node.left);\\n        if(mPrevious != null) {\\n            if(node.val < mPrevious.val) {\\n                if(faultyA == null) {\\n                    faultyA = mPrevious;\\n                    faultyB = node;\\n                } else {\\n                    faultyB = node;\\n                }\\n            }\\n        }\\n        mPrevious = node;\\n        findFaultyNodes(node.right);\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    TreeNode faultyA = null;\\n    TreeNode faultyB = null;\\n    TreeNode mPrevious = null;\\n    public void recoverTree(TreeNode root) {\\n        findFaultyNodes(root);\\n        \\n        //Swap faulty nodes\\n        if(faultyA != null && faultyB != null) {\\n            int temp = faultyA.val;\\n            faultyA.val = faultyB.val;\\n            faultyB.val = temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3035927,
                "title": "c-inorder-traversal",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\nclass Solution {\\npublic:\\n  TreeNode *p = NULL;\\n  TreeNode *k = NULL;\\n  TreeNode *l = NULL;\\n  bool z = true;\\n  void solve(TreeNode *root) {\\n    if (root == NULL)\\n      return;\\n\\n    solve(root->left);\\n    if (z) {\\n      if (p == NULL || p->val < root->val) {\\n        p = root;\\n      } else {\\n        k = p;\\n        l = root;\\n        z = false;\\n        p = root;\\n      }\\n    } else {\\n        if (p == NULL || p->val < root->val) {\\n        p = root;\\n      } else {\\n        l = root;\\n      }\\n    }\\n    solve(root->right);\\n  }\\n\\n  void recoverTree(TreeNode *root) {\\n      solve(root);\\n      swap(k->val,l->val);\\n  }\\n};",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n  TreeNode *p = NULL;\\n  TreeNode *k = NULL;\\n  TreeNode *l = NULL;\\n  bool z = true;\\n  void solve(TreeNode *root) {\\n    if (root == NULL)\\n      return;\\n\\n    solve(root->left);\\n    if (z) {\\n      if (p == NULL || p->val < root->val) {\\n        p = root;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1548861,
                "title": "3-codes-using-vector",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    vector<TreeNode*> tree;\\n \\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root);\\n        inOrder(root->right);\\n    }\\n  int index = 0;\\n    \\n    void res(TreeNode* root)\\n    {\\n      if(!root)\\n          return;\\n        \\n        res(root->left);\\n        root->val = tree[index++];\\n        res(root->right);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n     inOrder(root);\\n        sort(tree.begin() , tree.end());\\n        res(root);\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n\\n    vector<TreeNode*> tree;\\n \\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root);\\n        inOrder(root->right);\\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n     inOrder(root);\\n            int i, j;\\n        int n = tree.size();\\n    for (i = 0; i < n-1; i++)    \\n    for (j = 0; j < n-i-1; j++)\\n        if (tree[j]->val > tree[j+1]->val)\\n            swap(tree[j]->val, tree[j+1]->val);\\n\\n    }\\n};\\n```\\n```\\nvoid getOrder(TreeNode* root, vector<TreeNode*> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root);\\n        getOrder(root->right, inOrder);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inOrder;\\n        getOrder(root, inOrder);\\n        int n = inOrder.size();\\n        \\n        for(int i = 1; i < n; i++)\\n            if(inOrder[i-1]->val > inOrder[i]->val)\\n            {\\n                int j = n-1;\\n                for(; j >= i; j--)\\n                {if(inOrder[j]->val < inOrder[j-1]->val) break;}\\n                swap(inOrder[j]->val, inOrder[i-1]->val);\\n                break;\\n            }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<TreeNode*> tree;\\n \\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root);\\n        inOrder(root->right);\\n    }\\n  int index = 0;\\n    \\n    void res(TreeNode* root)\\n    {\\n      if(!root)\\n          return;\\n        \\n        res(root->left);\\n        root->val = tree[index++];\\n        res(root->right);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n     inOrder(root);\\n        sort(tree.begin() , tree.end());\\n        res(root);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    vector<TreeNode*> tree;\\n \\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root);\\n        inOrder(root->right);\\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n     inOrder(root);\\n            int i, j;\\n        int n = tree.size();\\n    for (i = 0; i < n-1; i++)    \\n    for (j = 0; j < n-i-1; j++)\\n        if (tree[j]->val > tree[j+1]->val)\\n            swap(tree[j]->val, tree[j+1]->val);\\n\\n    }\\n};\\n```\n```\\nvoid getOrder(TreeNode* root, vector<TreeNode*> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root);\\n        getOrder(root->right, inOrder);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inOrder;\\n        getOrder(root, inOrder);\\n        int n = inOrder.size();\\n        \\n        for(int i = 1; i < n; i++)\\n            if(inOrder[i-1]->val > inOrder[i]->val)\\n            {\\n                int j = n-1;\\n                for(; j >= i; j--)\\n                {if(inOrder[j]->val < inOrder[j-1]->val) break;}\\n                swap(inOrder[j]->val, inOrder[i-1]->val);\\n                break;\\n            }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485362,
                "title": "python3-o-n",
                "content": "```\\n    def inorder(self,root,arr):  # return sorted array of nodes\\n        if not root:\\n            return \\n        self.inorder(root.left,arr)\\n        arr.append(root)\\n        self.inorder(root.right,arr)\\n        return arr\\n    \\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        res = self.inorder(root,[])\\n        n = len(res)\\n                      \\n        a = res[0]      # default 1st wrong value from start\\n        for i in range(1,n):\\n            if res[i].val < res[i-1].val:\\n                a = res[i-1]\\n                break\\n            \\n        b = res[-1]   #default 1st wrong value from end\\n        for i in range(n-2,-1,-1):\\n            if res[i].val > res[i+1].val:\\n                b = res[i+1]\\n                break\\n        a.val,b.val = b.val,a.val       # swap\\n\\t\\t```\\n\\t\\tfeel free to ask Q...\\n\\t\\t#happytohelpu",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def inorder(self,root,arr):  # return sorted array of nodes\\n        if not root:\\n            return \\n        self.inorder(root.left,arr)\\n        arr.append(root)\\n        self.inorder(root.right,arr)\\n        return arr\\n    \\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        res = self.inorder(root,[])\\n        n = len(res)\\n                      \\n        a = res[0]      # default 1st wrong value from start\\n        for i in range(1,n):\\n            if res[i].val < res[i-1].val:\\n                a = res[i-1]\\n                break\\n            \\n        b = res[-1]   #default 1st wrong value from end\\n        for i in range(n-2,-1,-1):\\n            if res[i].val > res[i+1].val:\\n                b = res[i+1]\\n                break\\n        a.val,b.val = b.val,a.val       # swap\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1466323,
                "title": "c-simple-approach",
                "content": "**Please Upvote if you like the Solution!**\\n\\n    TreeNode *prev=NULL,*first=NULL,*second=NULL;\\n    void fixBST(TreeNode* root) \\n    {\\n        if(root==NULL)\\n            return;\\n        fixBST(root->left);\\n        \\n        if(prev!=NULL && root->val<prev->val)\\n        {\\n            if(first==NULL)\\n                first=prev;\\n            second=root;\\n        }\\n        prev=root;\\n        fixBST(root->right);\\n        \\n    }\\n    void recoverTree(TreeNode* root) \\n    {\\n        fixBST(root);\\n        swap(first->val,second->val);\\n    }",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "**Please Upvote if you like the Solution!**\\n\\n    TreeNode *prev=NULL,*first=NULL,*second=NULL;\\n    void fixBST(TreeNode* root) \\n    {\\n        if(root==NULL)\\n            return;\\n        fixBST(root->left);\\n        \\n        if(prev!=NULL && root->val<prev->val)\\n        {\\n            if(first==NULL)\\n                first=prev;\\n            second=root;\\n        }\\n        prev=root;\\n        fixBST(root->right);\\n        \\n    }\\n    void recoverTree(TreeNode* root) \\n    {\\n        fixBST(root);\\n        swap(first->val,second->val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 818965,
                "title": "java-3-different-solutions-morris-traversal-recursive-inorder-traversal-stack",
                "content": "1. main idea is to use inorder traversal because it will keep the order of values.\\n\\nMorris Traversal\\n```\\npublic void recoverTree(TreeNode root) {\\n        TreeNode previous = null;\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        // binary tree inorder traversal iteratively\\n        TreeNode parent = null;\\n        TreeNode current = root;\\n        while (current != null) {\\n            if (current.left != null) {\\n                parent = current.left;\\n                while (parent.right != null && parent.right != current) {\\n                    parent = parent.right;\\n                }\\n                if (parent.right == null) {\\n                    parent.right = current;\\n                    current = current.left;\\n                    continue;\\n                } else {\\n                    parent.right = null;\\n                }\\n            }\\n            if (previous != null) {\\n                if (previous.val > current.val) {\\n                    if (first == null) {\\n                        first = previous;\\n                    }\\n                    second = current;\\n                }\\n            }\\n            previous = current;\\n            current = current.right;\\n        }\\n        // swap value\\n        final int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n```\\n\\n2. Recursive Inorder Traversal\\n```\\n public void recoverTree(TreeNode root) {\\n        final List<Integer> values = new ArrayList<>();\\n        final List<TreeNode> treeNodes = new ArrayList<>();\\n        inorderTraversal(root, values, treeNodes);\\n        Collections.sort(values);\\n        for (int i = 0; i < values.size(); i++) {\\n            treeNodes.get(i).val = values.get(i);\\n        }\\n    }\\n\\n    private void inorderTraversal(\\n            TreeNode root,\\n            List<Integer> values,\\n            List<TreeNode> treeNodes\\n    ) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, values, treeNodes);\\n        values.add(root.val);\\n        treeNodes.add(root);\\n        inorderTraversal(root.right, values, treeNodes);\\n    }\\n```\\n3. Stack Iterative Inorder Traversal\\n```\\n    public void recoverTree(TreeNode root) {\\n        TreeNode previous = null;\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        // template binary tree inorder traversal iteratively\\n        final Stack<TreeNode> stacks = new Stack<>();\\n        TreeNode current = root;\\n        while (current != null || !stacks.empty()) {\\n            while (current != null) {\\n                stacks.push(current);\\n                current = current.left;\\n            }\\n            current = stacks.pop();\\n            if (previous != null) {\\n                if (previous.val > current.val) {\\n                    if (first == null) {\\n                        first = previous;\\n                    }\\n                    second = current;\\n                }\\n            }\\n            previous = current;\\n            current = current.right;\\n        }\\n        // swap value\\n        final int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void recoverTree(TreeNode root) {\\n        TreeNode previous = null;\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        // binary tree inorder traversal iteratively\\n        TreeNode parent = null;\\n        TreeNode current = root;\\n        while (current != null) {\\n            if (current.left != null) {\\n                parent = current.left;\\n                while (parent.right != null && parent.right != current) {\\n                    parent = parent.right;\\n                }\\n                if (parent.right == null) {\\n                    parent.right = current;\\n                    current = current.left;\\n                    continue;\\n                } else {\\n                    parent.right = null;\\n                }\\n            }\\n            if (previous != null) {\\n                if (previous.val > current.val) {\\n                    if (first == null) {\\n                        first = previous;\\n                    }\\n                    second = current;\\n                }\\n            }\\n            previous = current;\\n            current = current.right;\\n        }\\n        // swap value\\n        final int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n```\n```\\n public void recoverTree(TreeNode root) {\\n        final List<Integer> values = new ArrayList<>();\\n        final List<TreeNode> treeNodes = new ArrayList<>();\\n        inorderTraversal(root, values, treeNodes);\\n        Collections.sort(values);\\n        for (int i = 0; i < values.size(); i++) {\\n            treeNodes.get(i).val = values.get(i);\\n        }\\n    }\\n\\n    private void inorderTraversal(\\n            TreeNode root,\\n            List<Integer> values,\\n            List<TreeNode> treeNodes\\n    ) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, values, treeNodes);\\n        values.add(root.val);\\n        treeNodes.add(root);\\n        inorderTraversal(root.right, values, treeNodes);\\n    }\\n```\n```\\n    public void recoverTree(TreeNode root) {\\n        TreeNode previous = null;\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        // template binary tree inorder traversal iteratively\\n        final Stack<TreeNode> stacks = new Stack<>();\\n        TreeNode current = root;\\n        while (current != null || !stacks.empty()) {\\n            while (current != null) {\\n                stacks.push(current);\\n                current = current.left;\\n            }\\n            current = stacks.pop();\\n            if (previous != null) {\\n                if (previous.val > current.val) {\\n                    if (first == null) {\\n                        first = previous;\\n                    }\\n                    second = current;\\n                }\\n            }\\n            previous = current;\\n            current = current.right;\\n        }\\n        // swap value\\n        final int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2129607,
                "title": "two-method-with-explanation",
                "content": "**Approch 1  O(N)**\\n1. traverse in inorder you get a sorted element if element is not sorted then mark the two element which are not sorted and swap it \\n2. In the question given only two element are not at it correct  position. you only need to point the two element \\n3. if you do inorder if previous element is greater than current element then you point that element.\\n```\\nclass Solution {\\n    TreeNode first=null, second=null, prev=null;\\n    public void recoverTree(TreeNode root) {\\n        inOrder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    void inOrder(TreeNode root){\\n        if(root==null)return;\\n        inOrder(root.left);\\n        if(prev!=null && prev.val>root.val){\\n            if(first==null)\\n            first=prev;\\n            second=root; \\n        }\\n        prev=root;\\n        inOrder(root.right);\\n    }\\n}\\n```\\n***Approch 2 O(NLOGN)***\\n1. in this approch inorder travese and store the element in the list and then sort the list and then traverse inorder if the list value if diffrent then root.val then store that list element to the root.val\\n```\\nclass Solution {\\n    int i=0;\\n    List <Integer> list;\\n    public void recoverTree(TreeNode root) {\\n        list=new ArrayList<>();\\n        inOrder(root);\\n        Collections.sort(list);\\n        change(root,list);\\n    }\\n    void inOrder(TreeNode root){\\n        if(root==null)return ;\\n        inOrder(root.left);\\n        list.add(root.val);\\n        inOrder(root.right);\\n    }\\n    void change(TreeNode root , List<Integer>list){\\n        if(root==null) return ;\\n        change(root.left,list);\\n        if(list.get(i)!=root.val){\\n           root.val=list.get(i); \\n        }\\n        i++;\\n        change(root.right,list);\\n    }\\n}\\n```\\n**please upvote \\nTHANKYOU***\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode first=null, second=null, prev=null;\\n    public void recoverTree(TreeNode root) {\\n        inOrder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    void inOrder(TreeNode root){\\n        if(root==null)return;\\n        inOrder(root.left);\\n        if(prev!=null && prev.val>root.val){\\n            if(first==null)\\n            first=prev;\\n            second=root; \\n        }\\n        prev=root;\\n        inOrder(root.right);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int i=0;\\n    List <Integer> list;\\n    public void recoverTree(TreeNode root) {\\n        list=new ArrayList<>();\\n        inOrder(root);\\n        Collections.sort(list);\\n        change(root,list);\\n    }\\n    void inOrder(TreeNode root){\\n        if(root==null)return ;\\n        inOrder(root.left);\\n        list.add(root.val);\\n        inOrder(root.right);\\n    }\\n    void change(TreeNode root , List<Integer>list){\\n        if(root==null) return ;\\n        change(root.left,list);\\n        if(list.get(i)!=root.val){\\n           root.val=list.get(i); \\n        }\\n        i++;\\n        change(root.right,list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963483,
                "title": "c-o-n-time-best-optimized-approach-recursive",
                "content": "Here I am using recusive approach to traverse the BST ;\\nYou can also use stack to traverse both will take same space ,depends on you as you wish ;\\n\\n\\n****upvote if it helps you****\\n\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n\\n\\tTreeNode*first;\\n    TreeNode*prev;\\n    TreeNode*last;\\n    void inorder(TreeNode*root){\\n        if(root==NULL) return ;\\n        inorder(root->left);\\n        if(prev!=NULL &&  (root->val < prev->val)) {\\n            if(first==NULL) {// this means that this the first voilation of rule;\\n                first = prev;\\n                last = root;\\n            }\\n            else \\n                last = root;    // if this is the second voilation of rule ;\\n        }\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        first = last = prev = NULL;\\n        inorder(root);\\n        if(first && last) swap(first->val, last->val);\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "Here I am using recusive approach to traverse the BST ;\\nYou can also use stack to traverse both will take same space ,depends on you as you wish ;\\n\\n\\n****upvote if it helps you****\\n\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n\\n\\tTreeNode*first;\\n    TreeNode*prev;\\n    TreeNode*last;\\n    void inorder(TreeNode*root){\\n        if(root==NULL) return ;\\n        inorder(root->left);\\n        if(prev!=NULL &&  (root->val < prev->val)) {\\n            if(first==NULL) {// this means that this the first voilation of rule;\\n                first = prev;\\n                last = root;\\n            }\\n            else \\n                last = root;    // if this is the second voilation of rule ;\\n        }\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        first = last = prev = NULL;\\n        inorder(root);\\n        if(first && last) swap(first->val, last->val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1962655,
                "title": "java-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n     TreeNode prev = null,first=null,second=null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        helper(root);\\n        swap(first,second);\\n        return ;\\n    }\\n    void swap(TreeNode a,TreeNode b)\\n    {\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n      void helper(TreeNode root)\\n    {\\n        if(root == null)\\n            return ;\\n        helper(root.left);\\n        \\n        if(prev!=null &&  prev.val > root.val)\\n        {\\n            if(first == null)\\n            {\\n                first = prev;\\n            }\\n            second = root;\\n        }\\n         \\n        prev = root;\\n        helper(root.right);\\n    }\\n    \\n  \\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n     TreeNode prev = null,first=null,second=null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        helper(root);\\n        swap(first,second);\\n        return ;\\n    }\\n    void swap(TreeNode a,TreeNode b)\\n    {\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n      void helper(TreeNode root)\\n    {\\n        if(root == null)\\n            return ;\\n        helper(root.left);\\n        \\n        if(prev!=null &&  prev.val > root.val)\\n        {\\n            if(first == null)\\n            {\\n                first = prev;\\n            }\\n            second = root;\\n        }\\n         \\n        prev = root;\\n        helper(root.right);\\n    }\\n    \\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962302,
                "title": "python-o-1-space-14-lines-of-code",
                "content": "```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        done = True\\n        def recur(node, not_less_than, not_greater_than):\\n            nonlocal done\\n            if not_less_than and node.val < not_less_than.val:\\n                node.val, not_less_than.val = not_less_than.val, node.val\\n                done = True                \\n            if not_greater_than and node.val > not_greater_than.val:\\n                node.val, not_greater_than.val = not_greater_than.val, node.val\\n                done = True                \\n            if not done and node.left: recur(node.left, not_less_than, node)\\n            if not done and node.right: recur(node.right, node, not_greater_than)\\n        while done:                \\n            done = False\\n            recur(root, None, None)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        done = True\\n        def recur(node, not_less_than, not_greater_than):\\n            nonlocal done\\n            if not_less_than and node.val < not_less_than.val:\\n                node.val, not_less_than.val = not_less_than.val, node.val\\n                done = True                \\n            if not_greater_than and node.val > not_greater_than.val:\\n                node.val, not_greater_than.val = not_greater_than.val, node.val\\n                done = True                \\n            if not done and node.left: recur(node.left, not_less_than, node)\\n            if not done and node.right: recur(node.right, node, not_greater_than)\\n        while done:                \\n            done = False\\n            recur(root, None, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811866,
                "title": "c-clean-concise-inorder-traversal-98-4-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n\\n    TreeNode *prev=NULL,*first=NULL,*second=NULL;\\n    \\n    void recover(TreeNode* root){\\n        if(root==NULL){\\n            return;\\n        }\\n        recover(root->left);\\n        if(prev!=NULL && root->val < prev->val){\\n            if(first==NULL){\\n                first=prev;\\n            }\\n            second=root;\\n        }\\n        prev=root;\\n        recover(root->right);  \\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        recover(root);  \\n        swap(first->val,second->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n    TreeNode *prev=NULL,*first=NULL,*second=NULL;\\n    \\n    void recover(TreeNode* root){\\n        if(root==NULL){\\n            return;\\n        }\\n        recover(root->left);\\n        if(prev!=NULL && root->val < prev->val){\\n            if(first==NULL){\\n                first=prev;\\n            }\\n            second=root;\\n        }\\n        prev=root;\\n        recover(root->right);  \\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        recover(root);  \\n        swap(first->val,second->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548853,
                "title": "c-o-n-solution-preorder-vector",
                "content": "```\\n    void getOrder(TreeNode* root, vector<TreeNode*> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root);\\n        getOrder(root->right, inOrder);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inOrder;\\n        getOrder(root, inOrder);\\n        int n = inOrder.size();\\n        \\n        for(int i = 1; i < n; i++) // Just swap the 2 values which are not in Order \\n            if(inOrder[i-1]->val > inOrder[i]->val)\\n            {\\n                int j = n-1;\\n                for(; j >= i; j--)\\n                {if(inOrder[j]->val < inOrder[j-1]->val) break;}\\n                swap(inOrder[j]->val, inOrder[i-1]->val);\\n                break;\\n            }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void getOrder(TreeNode* root, vector<TreeNode*> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root);\\n        getOrder(root->right, inOrder);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inOrder;\\n        getOrder(root, inOrder);\\n        int n = inOrder.size();\\n        \\n        for(int i = 1; i < n; i++) // Just swap the 2 values which are not in Order \\n            if(inOrder[i-1]->val > inOrder[i]->val)\\n            {\\n                int j = n-1;\\n                for(; j >= i; j--)\\n                {if(inOrder[j]->val < inOrder[j-1]->val) break;}\\n                swap(inOrder[j]->val, inOrder[i-1]->val);\\n                break;\\n            }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1306519,
                "title": "c-recursion-o-1-memory",
                "content": "class Solution {\\n\\n\\t TreeNode *first=NULL,*second=NULL,*prev=NULL;   \\n    public:\\n    void fix(TreeNode *root){\\n        if(!root) return;\\n        fix(root->left);\\n        \\n        if(prev && root->val<prev->val){\\n            if(!first) first=prev;\\n            second=root;\\n        }\\n        \\n        prev=root;\\n        fix(root->right);\\n    }\\n    \\n    void recoverTree(TreeNode *root) {\\n        fix(root);\\n        swap(first->val,second->val);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n\\t TreeNode *first=NULL,*second=NULL,*prev=NULL;   \\n    public:\\n    void fix(TreeNode *root){\\n        if(!root) return;\\n        fix(root->left);\\n        \\n        if(prev && root->val<prev->val){\\n            if(!first) first=prev;\\n            second=root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 917307,
                "title": "java-dfs-comments",
                "content": "If you liked this solution, please upvote it\\n\\n```\\nclass Solution {\\n    TreeNode x, y, prev;\\n    public void recoverTree(TreeNode root) {\\n        if (root == null) return;\\n\\t\\t// first find x and y\\n        find(root);\\n\\t\\t// then swap\\n        swap(x, y);\\n    }\\n\\t\\t\\n\\t// goind to the end on left\\n    // looking for the first node, which val is greater than parent (left > root)\\n\\t// if will be writen to X\\n\\t// Then from top to bottom checking for the next value\\n\\t// in this case parent (prev) value should be greater than next; (root > right)\\n    public void find(TreeNode root) {\\n        if (root == null) return;\\n        find(root.left);\\n\\t\\tif (prev != null && prev.val > root.val) {\\n            y = root;\\n            if (x == null) {\\n                x = prev;\\n            } else {\\n                return;\\n            }\\n        }\\n        prev = root;\\n        find(root.right);\\n    }\\n    \\n    private void swap(TreeNode one, TreeNode two) {\\n        int tmp = one.val;\\n        one.val = two.val;\\n        two.val = tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode x, y, prev;\\n    public void recoverTree(TreeNode root) {\\n        if (root == null) return;\\n\\t\\t// first find x and y\\n        find(root);\\n\\t\\t// then swap\\n        swap(x, y);\\n    }\\n\\t\\t\\n\\t// goind to the end on left\\n    // looking for the first node, which val is greater than parent (left > root)\\n\\t// if will be writen to X\\n\\t// Then from top to bottom checking for the next value\\n\\t// in this case parent (prev) value should be greater than next; (root > right)\\n    public void find(TreeNode root) {\\n        if (root == null) return;\\n        find(root.left);\\n\\t\\tif (prev != null && prev.val > root.val) {\\n            y = root;\\n            if (x == null) {\\n                x = prev;\\n            } else {\\n                return;\\n            }\\n        }\\n        prev = root;\\n        find(root.right);\\n    }\\n    \\n    private void swap(TreeNode one, TreeNode two) {\\n        int tmp = one.val;\\n        one.val = two.val;\\n        two.val = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 660186,
                "title": "worst-sol-ever",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int i=0;\\n    void recoverTree(TreeNode* root) {\\n     sol1(root);\\n        sort(v.begin(),v.end());\\n       sol2(root);\\n    }\\n    void sol1(TreeNode* n){\\n        if(!n)return;\\n        sol1(n->left);\\n        v.push_back(n->val);\\n        sol1(n->right);\\n    }\\n     void sol2(TreeNode* n){\\n         if(!n) return;\\n         sol2(n->left);\\n         n->val=v[i++];\\n         sol2(n->right);\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int i=0;\\n    void recoverTree(TreeNode* root) {\\n     sol1(root);\\n        sort(v.begin(),v.end());\\n       sol2(root);\\n    }\\n    void sol1(TreeNode* n){\\n        if(!n)return;\\n        sol1(n->left);\\n        v.push_back(n->val);\\n        sol1(n->right);\\n    }\\n     void sol2(TreeNode* n){\\n         if(!n) return;\\n         sol2(n->left);\\n         n->val=v[i++];\\n         sol2(n->right);\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338595,
                "title": "python-solution-with-comments-faster-than-99",
                "content": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n    # Idea: During in-order traversal, we keep checking that whether a node\\'s value is strictly larger than it\\'s predecessor\\'s value. If not, then abnormal nodes exist in the position.\\n        \\n        self.first, self.second, self.prev = None, None, TreeNode(float(\\'-inf\\'))\\n\\n        def inorder(node):\\n            if node:\\n                inorder(node.left)\\n                # find the abnormity -- self.prev.val >= node.val\\n                if self.prev.val >= node.val:\\n                    # When we find the first abnormal node first,\\n                    # we need to record the second one at the same time.\\n                    # When the first one is already found, we only need to update the second one\\n                    if not self.first:\\n                        self.first = self.prev\\n                    self.second = node\\n                self.prev = node  # prev is the pointer traversing the whole tree in in-order\\n                inorder(node.right)\\n\\n        inorder(root)\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n```\\n\\n- time complexity O(n)\\n- space complexity O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n    # Idea: During in-order traversal, we keep checking that whether a node\\'s value is strictly larger than it\\'s predecessor\\'s value. If not, then abnormal nodes exist in the position.\\n        \\n        self.first, self.second, self.prev = None, None, TreeNode(float(\\'-inf\\'))\\n\\n        def inorder(node):\\n            if node:\\n                inorder(node.left)\\n                # find the abnormity -- self.prev.val >= node.val\\n                if self.prev.val >= node.val:\\n                    # When we find the first abnormal node first,\\n                    # we need to record the second one at the same time.\\n                    # When the first one is already found, we only need to update the second one\\n                    if not self.first:\\n                        self.first = self.prev\\n                    self.second = node\\n                self.prev = node  # prev is the pointer traversing the whole tree in in-order\\n                inorder(node.right)\\n\\n        inorder(root)\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111021,
                "title": "o-n-space-c-solution",
                "content": "```\\n  void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> nodes;\\n        vector<int> vals;\\n        \\n        inorder(root, nodes, vals);\\n        sort(vals.begin(), vals.end());\\n        for (int i = 0; i < vals.size(); i++)\\n            nodes[i]->val = vals[i];\\n    }\\n    \\n    void inorder(TreeNode* root, vector<TreeNode*>& nodes, vector<int>& vals) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left, nodes, vals);\\n        nodes.push_back(root);\\n        vals.push_back(root->val);\\n        inorder(root->right, nodes, vals);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> nodes;\\n        vector<int> vals;\\n        \\n        inorder(root, nodes, vals);\\n        sort(vals.begin(), vals.end());\\n        for (int i = 0; i < vals.size(); i++)\\n            nodes[i]->val = vals[i];\\n    }\\n    \\n    void inorder(TreeNode* root, vector<TreeNode*>& nodes, vector<int>& vals) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left, nodes, vals);\\n        nodes.push_back(root);\\n        vals.push_back(root->val);\\n        inorder(root->right, nodes, vals);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32609,
                "title": "4ms-java-solution",
                "content": "    public class Solution {\\n        \\n         TreeNode first = null, second = null, pre = null;\\n        public void recoverTree(TreeNode root) {\\n            if(root==null)return;\\n            dfs(root);\\n            if(first!=null&&second!=null){\\n                int temp = first.val;\\n                first.val = second.val;\\n                second.val = temp;\\n            }\\n            \\n        }\\n        public void  dfs(TreeNode root){\\n            if(root.left!=null)dfs(root.left);\\n            if(pre!=null&&pre.val>root.val)\\n                {\\n                    if(first==null) first = pre;\\n                    if(first!=null)second = root;\\n                }\\n            pre = root;\\n            if(root.right!=null)dfs(root.right);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        \\n         TreeNode first = null, second = null, pre = null;\\n        public void recoverTree(TreeNode root) {\\n            if(root==null)return;\\n            dfs(root);\\n            if(first!=null&&second!=null){\\n                int temp = first.val;\\n                first.val = second.val;\\n                second.val = temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 32617,
                "title": "18-line-of-cpp-solution-48ms-dfs",
                "content": "    class Solution {\\n    public:\\n        TreeNode* errorNodes[3];\\n        TreeNode* preNode = NULL;\\n        int found = 0;\\n    \\n        void dfs(TreeNode* node) {\\n            if (NULL != node->left) dfs(node->left);\\n            if (NULL != preNode) {\\n                if (preNode->val > node->val){\\n                    errorNodes[found] = preNode;\\n                    errorNodes[++found] = node;\\n                }\\n            }\\n            preNode = node;\\n            if (NULL != node->right && found <= 1) dfs(node->right);\\n        }\\n    \\n        void recoverTree(TreeNode* root) {\\n            dfs(root);\\n            if (0 != found) swap(errorNodes[0]->val, errorNodes[found]->val);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        TreeNode* errorNodes[3];\\n        TreeNode* preNode = NULL;\\n        int found = 0;\\n    \\n        void dfs(TreeNode* node) {\\n            if (NULL != node->left) dfs(node->left);\\n            if (NULL != preNode) {\\n                if (preNode->val > node->val){\\n                    errorNodes[found] = preNode;\\n                    errorNodes[++found] = node;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3516912,
                "title": "easy-c-solution-using-inorder-traversal",
                "content": "\\n# Approach\\nPLS UPVOTE IF YOU FIND THE SOLUTION EASY \\uD83D\\uDE09\\uD83D\\uDE09 \\nusing Inorder traversal , it can be done but dont use a vector to store the elements but keep 2 pointer so that at end u can swap them   \\nNow lets see.\\n1)Take 3 pointer prev ,start, end and intialize them with null  \\n2)Make a inorder function and the pointers  and the root \\n3)For the first iteration prev,will be null so put it at last after  the condition check \\n4)2nd iteration onwards prev wont be null so now check if first is null if yes then first will be prev and end will be root and then prev will be root \\n5)If everything goes according to the plan then first can be changed only one time when first is null\\nsame\\xA0for\\xA0the\\xA0second\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, TreeNode*& prev, TreeNode*& first, TreeNode*& end) {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        // AS IN INORDER TRAVERSAL LNR SO LEFT TRAVERSAL WILL TAKE PLACE\\n        inorder(root->left, prev, first, end);\\n        if (prev!=NULL) \\n        {\\n            if (root->val < prev->val)\\n            {\\n                if(first==NULL)\\n                {\\n                    first = prev;\\n                }\\n            end = root;\\n            }\\n        }\\n        prev = root;\\n        inorder(root->right, prev, first, end);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *prev = nullptr, *first = nullptr, *end = nullptr;\\n        inorder(root, prev, first, end);\\n        swap(first->val, end->val);\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, TreeNode*& prev, TreeNode*& first, TreeNode*& end) {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        // AS IN INORDER TRAVERSAL LNR SO LEFT TRAVERSAL WILL TAKE PLACE\\n        inorder(root->left, prev, first, end);\\n        if (prev!=NULL) \\n        {\\n            if (root->val < prev->val)\\n            {\\n                if(first==NULL)\\n                {\\n                    first = prev;\\n                }\\n            end = root;\\n            }\\n        }\\n        prev = root;\\n        inorder(root->right, prev, first, end);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *prev = nullptr, *first = nullptr, *end = nullptr;\\n        inorder(root, prev, first, end);\\n        swap(first->val, end->val);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433687,
                "title": "java-100-faster-solution-using-inorder-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(log N) or O(H)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/f174fa1b-9f48-4193-9faf-7ca6c8884de1_1681883532.8229592.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private TreeNode first;   // The first node that violates the BST property\\n    private TreeNode middle;  // The middle node that violates the BST property\\n    private TreeNode last;    // The last node that violates the BST property\\n    private TreeNode prev;    // The previous node during the inorder traversal\\n\\n    public void inorder(TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n\\n        // Traverse the left subtree\\n        inorder(root.left);\\n\\n        // Check if the current node violates the BST property\\n        if(prev != null && (root.val < prev.val)){\\n            // If this is the first time we\\'ve found a violation,\\n            // set first and middle to the nodes that violate the BST property\\n            if(first == null){\\n                first = prev;\\n                middle = root;\\n            }\\n            // If we\\'ve already found a violation, set last to the node that violates the BST property\\n            else{\\n                last = root;\\n            }\\n        }\\n        // Set prev to the current node, so that we can compare it to the next node\\n        prev = root;\\n\\n        // Traverse the right subtree\\n        inorder(root.right);\\n    }\\n\\n    public void recoverTree(TreeNode root) {\\n        // Initialize the variables\\n        first = middle = last = null;\\n        // Initialize prev to a node with the minimum possible value, so that it will not violate the BST property\\n        prev = new TreeNode(Integer.MIN_VALUE);\\n\\n        // Perform an inorder traversal of the tree\\n        inorder(root);\\n\\n        // Swap the values of the nodes that violate the BST property, if any\\n        if(first != null && last != null){\\n            // If there are two nodes that violate the BST property,\\n            // and they are not adjacent to each other, swap the values of the first and last nodes\\n            int temp = first.val;\\n            first.val = last.val;\\n            last.val = temp;\\n        }\\n        else if(first != null && middle != null){\\n            // If there are two nodes that violate the BST property,\\n            // and they are adjacent to each other, swap the values of the first and middle nodes\\n            int temp = first.val;\\n            first.val = middle.val;\\n            middle.val = temp;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private TreeNode first;   // The first node that violates the BST property\\n    private TreeNode middle;  // The middle node that violates the BST property\\n    private TreeNode last;    // The last node that violates the BST property\\n    private TreeNode prev;    // The previous node during the inorder traversal\\n\\n    public void inorder(TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n\\n        // Traverse the left subtree\\n        inorder(root.left);\\n\\n        // Check if the current node violates the BST property\\n        if(prev != null && (root.val < prev.val)){\\n            // If this is the first time we\\'ve found a violation,\\n            // set first and middle to the nodes that violate the BST property\\n            if(first == null){\\n                first = prev;\\n                middle = root;\\n            }\\n            // If we\\'ve already found a violation, set last to the node that violates the BST property\\n            else{\\n                last = root;\\n            }\\n        }\\n        // Set prev to the current node, so that we can compare it to the next node\\n        prev = root;\\n\\n        // Traverse the right subtree\\n        inorder(root.right);\\n    }\\n\\n    public void recoverTree(TreeNode root) {\\n        // Initialize the variables\\n        first = middle = last = null;\\n        // Initialize prev to a node with the minimum possible value, so that it will not violate the BST property\\n        prev = new TreeNode(Integer.MIN_VALUE);\\n\\n        // Perform an inorder traversal of the tree\\n        inorder(root);\\n\\n        // Swap the values of the nodes that violate the BST property, if any\\n        if(first != null && last != null){\\n            // If there are two nodes that violate the BST property,\\n            // and they are not adjacent to each other, swap the values of the first and last nodes\\n            int temp = first.val;\\n            first.val = last.val;\\n            last.val = temp;\\n        }\\n        else if(first != null && middle != null){\\n            // If there are two nodes that violate the BST property,\\n            // and they are adjacent to each other, swap the values of the first and middle nodes\\n            int temp = first.val;\\n            first.val = middle.val;\\n            middle.val = temp;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963163,
                "title": "two-approaches-easy-understanding-solution",
                "content": "# BY TWO METHODS\\n**In O(n) Space**\\n```\\n//Please upvote if you like my solution :)\\nvoid solve(TreeNode* root,vector<TreeNode*> &inf){\\n        if(!root) return;\\n        solve(root->left,inf);\\n        inf.push_back(root);\\n        solve(root->right,inf);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inf;\\n        solve(root,inf);\\n        TreeNode* first, *second;\\n        for(int i=0;i<inf.size()-1;i++){\\n            if(inf[i]->val > inf[i+1]->val){\\n                first = inf[i];\\n                break;\\n            }\\n        }\\n        for(int i=inf.size()-1;i>=0;i--){\\n            if(inf[i]->val < first->val){\\n                second = inf[i];\\n                break;\\n            }\\n        }\\n        swap(first->val,second->val);\\n    }\\n```\\n**In O(1) Space**\\n```\\n//Please upvote if you like my solution :)\\nvoid inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        if(root->val < prev->val){\\n            if(!first){\\n                first = prev;\\n                middle = root;\\n            }else{\\n                last = root;\\n            }\\n        }\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    TreeNode* first, *last , *middle , *prev;\\n    void recoverTree(TreeNode* root) {\\n        first = last = middle = NULL;\\n        prev = new TreeNode(INT_MIN);\\n        inorder(root);\\n        if(!last) swap(first->val,middle->val);\\n        else swap(first->val,last->val);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n//Please upvote if you like my solution :)\\nvoid solve(TreeNode* root,vector<TreeNode*> &inf){\\n        if(!root) return;\\n        solve(root->left,inf);\\n        inf.push_back(root);\\n        solve(root->right,inf);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inf;\\n        solve(root,inf);\\n        TreeNode* first, *second;\\n        for(int i=0;i<inf.size()-1;i++){\\n            if(inf[i]->val > inf[i+1]->val){\\n                first = inf[i];\\n                break;\\n            }\\n        }\\n        for(int i=inf.size()-1;i>=0;i--){\\n            if(inf[i]->val < first->val){\\n                second = inf[i];\\n                break;\\n            }\\n        }\\n        swap(first->val,second->val);\\n    }\\n```\n```\\n//Please upvote if you like my solution :)\\nvoid inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        if(root->val < prev->val){\\n            if(!first){\\n                first = prev;\\n                middle = root;\\n            }else{\\n                last = root;\\n            }\\n        }\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    TreeNode* first, *last , *middle , *prev;\\n    void recoverTree(TreeNode* root) {\\n        first = last = middle = NULL;\\n        prev = new TreeNode(INT_MIN);\\n        inorder(root);\\n        if(!last) swap(first->val,middle->val);\\n        else swap(first->val,last->val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1476690,
                "title": "c-use-inorder-traversal",
                "content": "```\\nTreeNode *node_1 = NULL, *node_2 = NULL, *prev = NULL;\\n\\nvoid recoverTree(TreeNode* root) {\\n    // write your code here\\n    if (root == NULL) return;\\n    \\n    inorder(root);\\n    if (node_1 && node_2)\\n        swap(node_1->val, node_2->val);\\n}\\n\\nvoid inorder(TreeNode *root) {\\n    if (root == NULL) return;\\n    inorder(root->left);\\n    if (prev != NULL && root->val < prev->val) {\\n        if (node_1 == NULL) {\\n            node_1 = prev;\\n        } \\n        if (node_1 != NULL) {\\n            node_2 = root;\\n        }\\n    }\\n    prev = root;\\n    inorder(root->right);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTreeNode *node_1 = NULL, *node_2 = NULL, *prev = NULL;\\n\\nvoid recoverTree(TreeNode* root) {\\n    // write your code here\\n    if (root == NULL) return;\\n    \\n    inorder(root);\\n    if (node_1 && node_2)\\n        swap(node_1->val, node_2->val);\\n}\\n\\nvoid inorder(TreeNode *root) {\\n    if (root == NULL) return;\\n    inorder(root->left);\\n    if (prev != NULL && root->val < prev->val) {\\n        if (node_1 == NULL) {\\n            node_1 = prev;\\n        } \\n        if (node_1 != NULL) {\\n            node_2 = root;\\n        }\\n    }\\n    prev = root;\\n    inorder(root->right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 917661,
                "title": "java-recover-bst-100-well-explained",
                "content": "\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n \\n    private TreeNode prev, node1, node2;\\n\\t //for a BST inorder traversal returns an increasing order, we keep a track of previous value and do inorder, if any value is smaller than prev, than we need to swap it with other similar value\\n  //since only 2 nodes were swapped this works\\n  \\n    public void recoverTree(TreeNode root) {\\n      inOrder(root);\\n      int temp = node2.val;\\n      node2.val = node1.val;\\n      node1.val = temp;\\n    }\\n  \\n  private void inOrder(TreeNode root){\\n    if(root==null)\\n      return;\\n\\n      inOrder(root.left);\\n      if(prev!=null && prev.val>root.val){\\n\\t  \\n        if(node1==null)\\n          node1 = prev;\\n        node2 = root;\\n      }\\n      prev = root;\\n      inOrder(root.right);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n \\n    private TreeNode prev, node1, node2;\\n\\t //for a BST inorder traversal returns an increasing order, we keep a track of previous value and do inorder, if any value is smaller than prev, than we need to swap it with other similar value\\n  //since only 2 nodes were swapped this works\\n  \\n    public void recoverTree(TreeNode root) {\\n      inOrder(root);\\n      int temp = node2.val;\\n      node2.val = node1.val;\\n      node1.val = temp;\\n    }\\n  \\n  private void inOrder(TreeNode root){\\n    if(root==null)\\n      return;\\n\\n      inOrder(root.left);\\n      if(prev!=null && prev.val>root.val){\\n\\t  \\n        if(node1==null)\\n          node1 = prev;\\n        node2 = root;\\n      }\\n      prev = root;\\n      inOrder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531700,
                "title": "python-3-recursive-o-n",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        nodes = []\\n        values = []\\n        self.inorder(root, nodes, values)\\n        values.sort()\\n        for i in range(len(nodes)):\\n            nodes[i].val = values[i]\\n        \\n    def inorder(self, root, nodes, values):\\n        if root:\\n            self.inorder(root.left, nodes, values)\\n            nodes.append(root)\\n            values.append(root.val)\\n            self.inorder(root.right, nodes, values)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        nodes = []\\n        values = []\\n        self.inorder(root, nodes, values)\\n        values.sort()\\n        for i in range(len(nodes)):\\n            nodes[i].val = values[i]\\n        \\n    def inorder(self, root, nodes, values):\\n        if root:\\n            self.inorder(root.left, nodes, values)\\n            nodes.append(root)\\n            values.append(root.val)\\n            self.inorder(root.right, nodes, values)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231800,
                "title": "python-solution",
                "content": "Idea: We use the property that the inorder traversal of a BST is increasing. If two elements of a BST are swapped, then we can use inorder traversal to detect the two points where the increasing property breaks down. \\n\\nWe illustrate the algorithm with an example:\\n\\nSuppose the inorder traversal of a BST is the following: `[1,3,8,6,7,5,10]`. We initialize two pointers `left = None`, and `right = None` to denote the two elements that have been swapped. We use a pointer `trav` to denote the current node we are visiting during the traversal, and a pointer `prev` to denote the previous node. Suppose `prev.val > trav.val`, and `left == None`, (in this example, `prev.val = 8`, `trav.val = 6`) it means that we are at the first point where the increasing property breaks down. We assign `left = prev`, and another pointer `curr = trav` to record the current node. We continue with our tree traversal, and suppose  we are again in the scenario where `prev.val > trav.val`, but this time, `left != None`, (in this example, `prev.val = 7`, `trav.val = 5`) it means that we are at the second point where the increasing property breaks down. We assign `right = trav`. Finally, we swap the value of `left` and `right`: `left.val, right.val == right.val, left.val`.\\n\\nOne caveat is that, after the tree traversal, it might happen that `right` is still `None`. This happens whenever the two elements swapped are right next to each other. For example, if the inorder traversal of a tree yields `[1,3,5,7,6,8,10]`. Then after the traversal, we will find that `left.val = 7`, `curr.val = 6`, `right = None`. In this case, we just need to swap the value of `left` and `curr`: `left.val, curr.val = curr.val, left.val`. \\n\\nTime complexity: `O(n)`, space complexity: `O(n)`.\\n\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        trav = root\\n        prev = None\\n        left = None\\n        right = None\\n        while stack or trav:\\n            if trav:\\n                stack.append(trav)\\n                trav = trav.left\\n            else:\\n                u = stack.pop()\\n                if prev and prev.val > u.val:\\n                    if not left:\\n                        left = prev\\n                        curr = u\\n                    else:\\n                        right = u\\n                prev = u\\n                trav = u.right\\n        if right:\\n            left.val, right.val = right.val, left.val\\n        else:\\n            left.val, curr.val = curr.val, left.val\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        trav = root\\n        prev = None\\n        left = None\\n        right = None\\n        while stack or trav:\\n            if trav:\\n                stack.append(trav)\\n                trav = trav.left\\n            else:\\n                u = stack.pop()\\n                if prev and prev.val > u.val:\\n                    if not left:\\n                        left = prev\\n                        curr = u\\n                    else:\\n                        right = u\\n                prev = u\\n                trav = u.right\\n        if right:\\n            left.val, right.val = right.val, left.val\\n        else:\\n            left.val, curr.val = curr.val, left.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32530,
                "title": "std-cout-influence-test-result",
                "content": "The following cpp code can pass a specific test case\\n```\\n...\\nTreeNode *now;\\n...\\nwhile (now != NULL) {\\n...\\n}\\n```\\nLater I add a std::cout like this:\\n```\\n...\\nTreeNode *now;\\n...\\nwhile (now != NULL) {\\nstd::cout << now->val << std::endl;\\n...\\n}\\n```\\nSurprisingly,  the result, or the structure of the tree changed. It seems that std::cout influenced result, because if I annotate the line, the result will come back to an expected one. \\nMaybe something is wrong with pointers causing a memory pollution. Maybe the compiler misunderstood my code while optimizing it. But I can't understand how std::cout did it?",
                "solutionTags": [],
                "code": "```\\n...\\nTreeNode *now;\\n...\\nwhile (now != NULL) {\\n...\\n}\\n```\n```\\n...\\nTreeNode *now;\\n...\\nwhile (now != NULL) {\\nstd::cout << now->val << std::endl;\\n...\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 32637,
                "title": "javascript-solution-with-inorder-traversal",
                "content": "    var recoverTree = function(root) {\\n      var node1, node2;\\n      var prev = new TreeNode(-Number.MAX_VALUE);\\n      traverse(root);\\n      var tmp = node1.val;\\n      node1.val = node2.val;\\n      node2.val = tmp;\\n      function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        if (node.val < prev.val) {\\n          node2 = node;\\n          if (!node1) node1 = prev;\\n        }\\n        prev = node;\\n        traverse(node.right);\\n      }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var recoverTree = function(root) {\\n      var node1, node2;\\n      var prev = new TreeNode(-Number.MAX_VALUE);\\n      traverse(root);\\n      var tmp = node1.val;\\n      node1.val = node2.val;\\n      node2.val = tmp;\\n      function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        if (node.val < prev.val) {\\n          node2 = node;\\n          if (!node1) node1 = prev;\\n        }\\n        prev = node;\\n        traverse(node.right);\\n      }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 32614,
                "title": "a-concise-java-solution-using-morris-inorder-o-n-time-o-1-space",
                "content": "    public class Solution {\\n        public void recoverTree(TreeNode root) {\\n            TreeNode first = null, second = null;\\n            TreeNode pre = new TreeNode(Integer.MIN_VALUE);\\n            while (root != null)\\n            {\\n                if (root.left != null)\\n                {\\n                    TreeNode p = root.left;\\n                    while (p.right != null && p.right != root)\\n                        p = p.right;\\n                    if (p.right == null)\\n                    {\\n                        p.right = root;\\n                        root = root.left;\\n                        continue;\\n                    }\\n                    else\\n                        p.right = null;\\n                }\\n                if (root.val < pre.val)\\n                {\\n                    if (first == null)\\n                    {\\n                        first = pre;\\n                    }\\n                    second = root;\\n                }\\n                pre = root;\\n                root = root.right;\\n            }\\n            int tmp = first.val;\\n            first.val = second.val;\\n            second.val = tmp;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void recoverTree(TreeNode root) {\\n            TreeNode first = null, second = null;\\n            TreeNode pre = new TreeNode(Integer.MIN_VALUE);\\n            while (root != null)\\n            {\\n                if (root.left != null)\\n                {\\n                    TreeNode p = root.left;\\n                    while (p.right != null && p.right != root)\\n                        p = p.right;\\n                    if (p.right == null)\\n                    {\\n                        p.right = root;\\n                        root = root.left;\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3554734,
                "title": "morris-traversal-o-1-s-c-c-code-with-explanation",
                "content": "# Please Do Upvote if it\\'s helpful \\n\\n# Intuition\\n* As we know the inorder traversal of a bst gives the nodes in sorted order and in this only two nodes aren\\'t in their sorted pos.\\n* We will find them and swap their values.\\n* We will use Morris Trversal for inorder to solve this problem.\\n* Morris Traversal will reduce the space complexity to O(1).\\n\\n\\n# Approach\\n\\n* Here we can see 2 cases\\n* *Case-1:* The swapped nodes aren\\'t adjacents.\\n    - eg: here is the inorder of a bst: `3 25 7 8 10 15 5`. See the node `25` and `5` are swapped and they aren\\'t adjacents.\\n* *Case-2:* The swapped nodes are adjacents.\\n    - eg: here is the inorder of a bst: `3 5 8 7 10 15 25`. See the node `8` and `7` are swapped and they are adjacents.\\n\\n* We will take 3 pointers first,mid and last.\\n* first will point to the node which violates the sorted condition first.\\n* mid will point to the next node of first (in inorder traversal).\\n* last will point to the node which violates the sorted condition second.\\n\\n* we will take another pointer prev which will point the last visited node in inorder.\\n* everytime we need to check if the curr node\\'s val is less than it\\'s prev node\\'s value or not if yes then the node violates the sorted condition.\\n\\n* In case-2 the sorted condition gets violated only 1 time. So the last pointer will be null in this case. So we will swap the first and middle.\\n* In case-1 the sorted condition gets violated 2 times so none of the 3 pointers will be null. So here we will swap first and last.\\n\\n---\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *first,*mid,*last,*prev;\\n        first=mid=last=nullptr;\\n        prev=new TreeNode(INT_MIN);\\n        TreeNode *curr=root;\\n        while(curr){\\n            if(!curr->left){ // left was done and we are at curr node\\n                // curr node is less than it\\'s inorder predecessor (not folllowing sorted conditi[[[[[[[[[[[[]()]()]()]()]()]()]()]()]()]()]()]()on)\\n                if(curr->val<prev->val){\\n                    // condition gets violated for the first time\\n                    if(!first){\\n                        first=prev;\\n                        mid=curr;\\n                    }\\n                    else last=curr;\\n                }\\n                prev=curr;\\n                curr=curr->right;\\n            }\\n            else{\\n                TreeNode *now=curr->left;\\n                while(now->right && now->right!=curr)\\n                    now=now->right;\\n                if(!now->right){\\n                    now->right=curr;\\n                    curr=curr->left;\\n                }\\n                else{\\n                    now->right=nullptr;\\n                    if(curr->val<prev->val){\\n                        if(!first){\\n                            first=prev;\\n                            mid=curr;\\n                        }\\n                        else last=curr;\\n                    }\\n                    prev=curr;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        if(!last) swap(first->val,mid->val); // Case-2\\n        else swap(first->val,last->val); // Case-1\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *first,*mid,*last,*prev;\\n        first=mid=last=nullptr;\\n        prev=new TreeNode(INT_MIN);\\n        TreeNode *curr=root;\\n        while(curr){\\n            if(!curr->left){ // left was done and we are at curr node\\n                // curr node is less than it\\'s inorder predecessor (not folllowing sorted conditi[[[[[[[[[[[[]()]()]()]()]()]()]()]()]()]()]()]()on)\\n                if(curr->val<prev->val){\\n                    // condition gets violated for the first time\\n                    if(!first){\\n                        first=prev;\\n                        mid=curr;\\n                    }\\n                    else last=curr;\\n                }\\n                prev=curr;\\n                curr=curr->right;\\n            }\\n            else{\\n                TreeNode *now=curr->left;\\n                while(now->right && now->right!=curr)\\n                    now=now->right;\\n                if(!now->right){\\n                    now->right=curr;\\n                    curr=curr->left;\\n                }\\n                else{\\n                    now->right=nullptr;\\n                    if(curr->val<prev->val){\\n                        if(!first){\\n                            first=prev;\\n                            mid=curr;\\n                        }\\n                        else last=curr;\\n                    }\\n                    prev=curr;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        if(!last) swap(first->val,mid->val); // Case-2\\n        else swap(first->val,last->val); // Case-1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280265,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector <int> nodes;\\n    int i = 0;\\nprivate:\\n    void traversal(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL)\\n            return;\\n        traversal(root->left, nodes);\\n        nodes.push_back(root->val);\\n        traversal(root->right, nodes);    \\n    }\\n    void inorder(TreeNode* root, vector <int> nodes, int& i) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left, nodes, i);\\n        if (root->val != nodes[i])\\n            root->val = nodes[i];\\n        i++;    \\n        inorder(root->right, nodes, i);    \\n    }        \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        traversal(root, nodes);\\n        sort(nodes.begin(), nodes.end());\\n        inorder(root, nodes, i);\\n    }\\n};\\n```\\n\\n# Approach 2\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(h)$$ --> h is height of the BST\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    TreeNode* prev = new TreeNode(INT_MIN);\\n    TreeNode* first = NULL;\\n    TreeNode* middle = NULL;\\n    TreeNode* last = NULL;\\nprivate:\\n    void inorder(TreeNode* root) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left);\\n        if (prev->val > root->val) {\\n            if (first == NULL) {\\n                first = prev;\\n                middle = root;\\n            } else {\\n                last = root;\\n            }\\n        }  \\n        prev = root; \\n        inorder(root->right);    \\n    }        \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        if (last != NULL)\\n            swap(first->val, last->val);\\n        else\\n            swap(first->val, middle->val);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector <int> nodes;\\n    int i = 0;\\nprivate:\\n    void traversal(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL)\\n            return;\\n        traversal(root->left, nodes);\\n        nodes.push_back(root->val);\\n        traversal(root->right, nodes);    \\n    }\\n    void inorder(TreeNode* root, vector <int> nodes, int& i) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left, nodes, i);\\n        if (root->val != nodes[i])\\n            root->val = nodes[i];\\n        i++;    \\n        inorder(root->right, nodes, i);    \\n    }        \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        traversal(root, nodes);\\n        sort(nodes.begin(), nodes.end());\\n        inorder(root, nodes, i);\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    TreeNode* prev = new TreeNode(INT_MIN);\\n    TreeNode* first = NULL;\\n    TreeNode* middle = NULL;\\n    TreeNode* last = NULL;\\nprivate:\\n    void inorder(TreeNode* root) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left);\\n        if (prev->val > root->val) {\\n            if (first == NULL) {\\n                first = prev;\\n                middle = root;\\n            } else {\\n                last = root;\\n            }\\n        }  \\n        prev = root; \\n        inorder(root->right);    \\n    }        \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        if (last != NULL)\\n            swap(first->val, last->val);\\n        else\\n            swap(first->val, middle->val);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992577,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* first=NULL;\\n    TreeNode* sec=NULL;\\n    TreeNode* prev=NULL;\\n    void dfs(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return;\\n        dfs(root->left);\\n        if(prev && prev->val>root->val)\\n        {\\n            if(first==NULL)\\n            first=prev;\\n            sec=root;\\n        }\\n        prev=root;\\n        dfs(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        dfs(root);\\n        int t=first->val;\\n        first->val=sec->val;\\n        sec->val=t;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* first=NULL;\\n    TreeNode* sec=NULL;\\n    TreeNode* prev=NULL;\\n    void dfs(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return;\\n        dfs(root->left);\\n        if(prev && prev->val>root->val)\\n        {\\n            if(first==NULL)\\n            first=prev;\\n            sec=root;\\n        }\\n        prev=root;\\n        dfs(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        dfs(root);\\n        int t=first->val;\\n        first->val=sec->val;\\n        sec->val=t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892538,
                "title": "easy-to-understand",
                "content": "\\n\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        inorder_nodes = []\\n        def inorder(root):\\n            if root:\\n                inorder(root.left)\\n                inorder_nodes.append(root)\\n                inorder(root.right)\\n                 \\n        inorder(root)\\n        sorted_nodes = sorted(inorder_nodes, key = lambda x: x.val)\\n        \\n        wrong = []\\n        for (i, node) in enumerate(sorted_nodes):\\n            if inorder_nodes[i].val != node.val:\\n                wrong.append(node)\\n                \\n        wrong[0].val, wrong[1].val = wrong[1].val, wrong[0].val\\n```\\n\\nThe time complexity of this solution is O(n log n), where n is the number of nodes in the tree. This is because the DFS traversal takes O(n) time, and sorting the keys in the dictionary takes O(n log n) time.\\n\\nThe space complexity of this solution is O(n), where n is the number of nodes in the tree. This is because the nodes dictionary and the sorted_keys list both take up O(n) space.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        inorder_nodes = []\\n        def inorder(root):\\n            if root:\\n                inorder(root.left)\\n                inorder_nodes.append(root)\\n                inorder(root.right)\\n                 \\n        inorder(root)\\n        sorted_nodes = sorted(inorder_nodes, key = lambda x: x.val)\\n        \\n        wrong = []\\n        for (i, node) in enumerate(sorted_nodes):\\n            if inorder_nodes[i].val != node.val:\\n                wrong.append(node)\\n                \\n        wrong[0].val, wrong[1].val = wrong[1].val, wrong[0].val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671908,
                "title": "2-approaches-with-line-to-line-explanation",
                "content": "Best Approach Using Inorder Traversal\\n    *TC: O(N)  \\n\\tSC: O(1)*\\n    \"prev\" stores the previous value in \"Inorder Travesal\"\\n   \"f\" -> first mis-placed element, \\n\\t\"s\" -> second im-positioned element \\n```\\nclass Solution {\\npublic:\\n    TreeNode *f=0,*s=0,*prev=new TreeNode(INT_MIN);\\n    void recoverTree(TreeNode* root) {\\n       traverse(root);\\n        int t=f->val;\\n        f->val=s->val;\\n        s->val=t;\\n    }\\n    void traverse(TreeNode* root){\\n        if(!root)return;\\n        traverse(root->left);\\n\\t\\t//if first element itself not found and and an order mis-match found in inorder, assing it to first element i.e. \\'f\\'\\n        if(!f and prev->val>root->val)f=prev;\\n\\t\\t\\n\\t\\t//if first element already found and and an order mis-match found in inorder, assing it to second element i.e. \\'s\\'\\n        if(f and prev->val>root->val)s=root;\\n        prev=root;\\n        traverse(root->right);\\n    }\\n};\\n```\\n\\n```\\n\\nSecond Approach\\nUsing Property: Inorder Travesal must give Sorted Result *TC: O(N)  SC: O(N)*\\n\\n vector<int>v;\\n    void recoverTree(TreeNode* root) {\\n\\t\\t//any tree traversal to store values of tree\\n        inorder(root);\\n\\t\\t// genearting inorder travesal of BST by sorting\\n        sort(v.begin(),v.end());\\n        int k=0;\\n\\t\\t//Level Order Traversal to assign values from sorted array to tree simply (copying)\\n        create(root,k);\\n    }\\n\\t//Any Travesal Method, Here Using Inorder\\n    void inorder(TreeNode* root){\\n        if(!root)return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n        return ;   \\n    }\\n\\t\\n\\t//Inorder for copying sorted values from array\\n    void create(TreeNode* root,int &k){\\n        if(!root)return;\\n        if(root->left) {create(root->left,k);}\\n        root->val=v[k++];\\n        if(root->right) create(root->right,k);\\n         return ; \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *f=0,*s=0,*prev=new TreeNode(INT_MIN);\\n    void recoverTree(TreeNode* root) {\\n       traverse(root);\\n        int t=f->val;\\n        f->val=s->val;\\n        s->val=t;\\n    }\\n    void traverse(TreeNode* root){\\n        if(!root)return;\\n        traverse(root->left);\\n\\t\\t//if first element itself not found and and an order mis-match found in inorder, assing it to first element i.e. \\'f\\'\\n        if(!f and prev->val>root->val)f=prev;\\n\\t\\t\\n\\t\\t//if first element already found and and an order mis-match found in inorder, assing it to second element i.e. \\'s\\'\\n        if(f and prev->val>root->val)s=root;\\n        prev=root;\\n        traverse(root->right);\\n    }\\n};\\n```\n```\\n\\nSecond Approach\\nUsing Property: Inorder Travesal must give Sorted Result *TC: O(N)  SC: O(N)*\\n\\n vector<int>v;\\n    void recoverTree(TreeNode* root) {\\n\\t\\t//any tree traversal to store values of tree\\n        inorder(root);\\n\\t\\t// genearting inorder travesal of BST by sorting\\n        sort(v.begin(),v.end());\\n        int k=0;\\n\\t\\t//Level Order Traversal to assign values from sorted array to tree simply (copying)\\n        create(root,k);\\n    }\\n\\t//Any Travesal Method, Here Using Inorder\\n    void inorder(TreeNode* root){\\n        if(!root)return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n        return ;   \\n    }\\n\\t\\n\\t//Inorder for copying sorted values from array\\n    void create(TreeNode* root,int &k){\\n        if(!root)return;\\n        if(root->left) {create(root->left,k);}\\n        root->val=v[k++];\\n        if(root->right) create(root->right,k);\\n         return ; \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451929,
                "title": "simple-c-inorder-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tTreeNode* first, *second, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(first->val, second->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(first == nullptr && root->val < pre->val)\\n\\t\\t\\tfirst = pre;\\n\\t\\tif(first != nullptr && root->val < pre->val)\\n\\t\\t\\tsecond = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```\\n**Please Upvote\\nthank you!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tTreeNode* first, *second, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(first->val, second->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(first == nullptr && root->val < pre->val)\\n\\t\\t\\tfirst = pre;\\n\\t\\tif(first != nullptr && root->val < pre->val)\\n\\t\\t\\tsecond = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967352,
                "title": "c-3-approaches-with-explanation-brute-optimised",
                "content": "Brute Force O(nlogn) time complexity and O(n) space\\n\\nAlgorithm:\\n\\n1. Traverse with Inorder Traversal and store data in Array\\n2. sort that Array\\n3. copy that Array with One more Inorder Traversal\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,vector<int> &v){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,v);\\n    \\n        v.push_back(root->val);\\n               \\n        rec(root->right,v);\\n        \\n    }\\n    \\n    void rec_add(TreeNode* root,vector<int> &v,int &i){\\n         if(root == NULL) return;\\n        \\n        rec_add(root->left,v,i);\\n    \\n        root->val = v[i++];\\n               \\n        rec_add(root->right,v,i);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        vector<int> v;\\n        \\n        rec(root,v);\\n        sort(v.begin(),v.end());\\n        int i = 0;\\n        \\n        rec_add(root,v,i);\\n    }\\n\\n};\\n```\\n\\nO(n) time complexity and O(n) space\\n\\nIn this solution we reduced the time of sorting part , as we know that there will be exactly 2 numbers which are not in place we have to find them\\n\\nso we will traverse on array the first element we get with a[i] < a[i-1] at i-1 will be first one to swap , after geting this i-1 we will go for 2nd element we will store every num from first element with a[i] < a[i-1] and at last we end up getting 2nd number to be swaped.\\n\\nAlgorithm:\\n\\n1.Traverse Inorder on BST and store in Array\\n2.find first element and 2nd element to be swaped\\n3.swap that 2 numbers\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,vector<TreeNode*> &v){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,v);\\n    \\n        v.push_back(root);\\n               \\n        rec(root->right,v);\\n        \\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        vector<TreeNode*> v;\\n        \\n        rec(root,v);\\n       \\n        int swap_idx = -1;\\n        int swap_idx2 = -1;\\n        \\n        int i;\\n        \\n        for(i = 1;i<v.size();i++){\\n            if( v[i]->val < v[i-1]->val){\\n                if(swap_idx == -1 ){ \\n                \\n                 swap_idx = i-1;\\n                 swap_idx2 = i;\\n                \\n                }\\n                else {\\n                    \\n                    swap_idx2 = i;\\n                \\n                }\\n            }\\n        }\\n         \\n             int t = v[swap_idx]->val;\\n             v[swap_idx]->val = v[swap_idx2]->val;\\n             v[swap_idx2]->val = t;\\n        \\n    }\\n\\n};\\n```\\n\\nOptimised : O(n) time complexty with O(1) space complexity\\n\\nHere to get those 2 nodes to be swaped we will maintain 3 TreeNodes prev,TreeNode first,TreeNode second \\nand while traversing Inorderly we will check for those conditions as prev->val > root->val and update 1st and second node\\nafter rec calls ends we will have those 2 nodes finally we will swap them\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,TreeNode* &prev,TreeNode* &first,TreeNode* &second){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,prev,first,second);\\n    \\n        if(root->val < prev->val){\\n            \\n            if(first == NULL){\\n                first = prev;\\n                second = root;\\n            }else{\\n                second = root;\\n            }\\n            \\n        }\\n \\n        prev = root;\\n        rec(root->right,prev,first,second);\\n        \\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        TreeNode* prev = new TreeNode(INT_MIN);\\n        TreeNode* a = NULL;\\n        TreeNode* b = NULL;\\n        \\n        rec(root,prev,a,b);\\n        \\n        int t = a->val;\\n        a->val = b->val;\\n        b->val = t;\\n       \\n    }\\n\\n};\\n```\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,vector<int> &v){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,v);\\n    \\n        v.push_back(root->val);\\n               \\n        rec(root->right,v);\\n        \\n    }\\n    \\n    void rec_add(TreeNode* root,vector<int> &v,int &i){\\n         if(root == NULL) return;\\n        \\n        rec_add(root->left,v,i);\\n    \\n        root->val = v[i++];\\n               \\n        rec_add(root->right,v,i);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        vector<int> v;\\n        \\n        rec(root,v);\\n        sort(v.begin(),v.end());\\n        int i = 0;\\n        \\n        rec_add(root,v,i);\\n    }\\n\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,vector<TreeNode*> &v){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,v);\\n    \\n        v.push_back(root);\\n               \\n        rec(root->right,v);\\n        \\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        vector<TreeNode*> v;\\n        \\n        rec(root,v);\\n       \\n        int swap_idx = -1;\\n        int swap_idx2 = -1;\\n        \\n        int i;\\n        \\n        for(i = 1;i<v.size();i++){\\n            if( v[i]->val < v[i-1]->val){\\n                if(swap_idx == -1 ){ \\n                \\n                 swap_idx = i-1;\\n                 swap_idx2 = i;\\n                \\n                }\\n                else {\\n                    \\n                    swap_idx2 = i;\\n                \\n                }\\n            }\\n        }\\n         \\n             int t = v[swap_idx]->val;\\n             v[swap_idx]->val = v[swap_idx2]->val;\\n             v[swap_idx2]->val = t;\\n        \\n    }\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,TreeNode* &prev,TreeNode* &first,TreeNode* &second){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,prev,first,second);\\n    \\n        if(root->val < prev->val){\\n            \\n            if(first == NULL){\\n                first = prev;\\n                second = root;\\n            }else{\\n                second = root;\\n            }\\n            \\n        }\\n \\n        prev = root;\\n        rec(root->right,prev,first,second);\\n        \\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        TreeNode* prev = new TreeNode(INT_MIN);\\n        TreeNode* a = NULL;\\n        TreeNode* b = NULL;\\n        \\n        rec(root,prev,a,b);\\n        \\n        int t = a->val;\\n        a->val = b->val;\\n        b->val = t;\\n       \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963371,
                "title": "2-java-solution-from-extra-space-to-optimized",
                "content": "\\n**Approach 1->**\\n\\nFirst thing that comes into mind is that in-order traversal is sorted. so if we store in-order of tree to list and then we just need to find two nodes on which we want to swap values. i.e. start and end node.\\n1.iterate the list to check first occurence where ith element > i+1th element. now,we have start node \\n2.if we have start node with us . now check further if any value exists whose value is smaller then start node. store it as end node and break out of loop\\n3.now just swap start and end values.\\n\\nexample->\\ninorder if suppose is -> \\n-33,321,55,71,231,-13,399\\nfirst we will get start as 321. as 321>55\\nnow, we have start then we meet 321<399 condition. in such case -13 will be end.\\n\\n```\\npublic void recoverTree(TreeNode root) {\\n\\t\\tList<TreeNode> list = new ArrayList<>();\\n\\t\\tinorder(root, list);\\n\\t\\tint start = -1;\\n\\t\\tint end = list.size() - 1;\\n\\t\\tfor (int i = 0; i < list.size() - 1; i++) {\\n\\t\\t\\tif (start == -1 && list.get(i).val > list.get(i + 1).val) {\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t} else if (start != -1 && list.get(start).val < list.get(i + 1).val) {\\n\\t\\t\\t\\tend = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint temp = list.get(start).val;\\n\\t\\tlist.get(start).val = list.get(end).val;\\n\\t\\tlist.get(end).val = temp;\\n\\t}\\n\\n\\tprivate void inorder(TreeNode root, List<TreeNode> list) {\\n\\t\\tif (root != null) {\\n\\t\\t\\tinorder(root.left, list);\\n\\t\\t\\tlist.add(root);\\n\\t\\t\\tinorder(root.right, list);\\n\\t\\t}\\n\\t}\\n```\\n\\n\\n**Approach 2->**\\n\\n1. we can observe that at a time we just need ith and i+1th node to compare. i.e. prev and curr element. and once found start and end node also needed. i.e. total 4 nodes can serve the purpose. instead of entire list.\\n2. just convert above iterative loop into recursive approach->\\n```\\npublic class Solution {\\n\\n\\tTreeNode start = null;\\n\\tTreeNode end = null;\\n\\tTreeNode prev = null;\\n\\n\\tpublic void recoverTree(TreeNode root) {\\n\\t\\tprev = new TreeNode(Integer.MIN_VALUE);\\n\\t\\tinorder(root);\\n\\t\\tint temp = start.val;\\n\\t\\t//case where last node itself needed to be swapped\\n\\t\\tif (end == null) {\\n\\t\\t\\tend = prev;\\n\\t\\t}\\n\\t\\tstart.val = end.val;\\n\\t\\tend.val = temp;\\n\\t}\\n\\n\\tprivate void inorder(TreeNode root) {\\n\\t\\tif (root != null) {\\n\\t\\t\\tinorder(root.left);\\n\\t\\t\\tif (start == null && prev.val > root.val) {\\n\\t\\t\\t\\tstart = prev;\\n\\t\\t\\t} else if (start != null && start.val < root.val) {\\n\\t\\t\\t\\tend = prev;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tprev = root;\\n\\t\\t\\tinorder(root.right);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic void recoverTree(TreeNode root) {\\n\\t\\tList<TreeNode> list = new ArrayList<>();\\n\\t\\tinorder(root, list);\\n\\t\\tint start = -1;\\n\\t\\tint end = list.size() - 1;\\n\\t\\tfor (int i = 0; i < list.size() - 1; i++) {\\n\\t\\t\\tif (start == -1 && list.get(i).val > list.get(i + 1).val) {\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t} else if (start != -1 && list.get(start).val < list.get(i + 1).val) {\\n\\t\\t\\t\\tend = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint temp = list.get(start).val;\\n\\t\\tlist.get(start).val = list.get(end).val;\\n\\t\\tlist.get(end).val = temp;\\n\\t}\\n\\n\\tprivate void inorder(TreeNode root, List<TreeNode> list) {\\n\\t\\tif (root != null) {\\n\\t\\t\\tinorder(root.left, list);\\n\\t\\t\\tlist.add(root);\\n\\t\\t\\tinorder(root.right, list);\\n\\t\\t}\\n\\t}\\n```\n```\\npublic class Solution {\\n\\n\\tTreeNode start = null;\\n\\tTreeNode end = null;\\n\\tTreeNode prev = null;\\n\\n\\tpublic void recoverTree(TreeNode root) {\\n\\t\\tprev = new TreeNode(Integer.MIN_VALUE);\\n\\t\\tinorder(root);\\n\\t\\tint temp = start.val;\\n\\t\\t//case where last node itself needed to be swapped\\n\\t\\tif (end == null) {\\n\\t\\t\\tend = prev;\\n\\t\\t}\\n\\t\\tstart.val = end.val;\\n\\t\\tend.val = temp;\\n\\t}\\n\\n\\tprivate void inorder(TreeNode root) {\\n\\t\\tif (root != null) {\\n\\t\\t\\tinorder(root.left);\\n\\t\\t\\tif (start == null && prev.val > root.val) {\\n\\t\\t\\t\\tstart = prev;\\n\\t\\t\\t} else if (start != null && start.val < root.val) {\\n\\t\\t\\t\\tend = prev;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tprev = root;\\n\\t\\t\\tinorder(root.right);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963292,
                "title": "python-easy-python-solution-using-inorder-traversal-and-array",
                "content": "# If You Like My Solution Please UpVote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n\\tclass Solution:\\n\\t\\tdef recoverTree(self, root: Optional[TreeNode]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify root in-place instead.\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tarray = []\\n\\n\\t\\t\\tdef InOrder(node):\\n\\n\\t\\t\\t\\tif node != None:\\n\\n\\t\\t\\t\\t\\tInOrder(node.left)\\n\\t\\t\\t\\t\\tarray.append(node)\\n\\t\\t\\t\\t\\tInOrder(node.right)\\n\\n\\t\\t\\tInOrder(root)\\n\\n\\t\\t\\tlength = len(array)\\n\\n\\t\\t\\tfirst_node = array[0]\\n\\n\\t\\t\\tsecond_node = array[-1]\\n\\n\\t\\t\\tfor i in range(1,length):\\n\\t\\t\\t\\tif array[i].val < array[i-1].val:\\n\\t\\t\\t\\t\\tfirst_node = array[i-1]\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\tfor i in range(length-2,-1,-1):\\n\\t\\t\\t\\tif array[i].val > array[i+1].val:\\n\\t\\t\\t\\t\\tsecond_node = array[i+1]\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\tfirst_node.val , second_node.val = second_node.val , first_node.val",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "# If You Like My Solution Please UpVote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n\\tclass Solution:\\n\\t\\tdef recoverTree(self, root: Optional[TreeNode]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify root in-place instead.\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tarray = []\\n\\n\\t\\t\\tdef InOrder(node):\\n\\n\\t\\t\\t\\tif node != None:\\n\\n\\t\\t\\t\\t\\tInOrder(node.left)\\n\\t\\t\\t\\t\\tarray.append(node)\\n\\t\\t\\t\\t\\tInOrder(node.right)\\n\\n\\t\\t\\tInOrder(root)\\n\\n\\t\\t\\tlength = len(array)\\n\\n\\t\\t\\tfirst_node = array[0]\\n\\n\\t\\t\\tsecond_node = array[-1]\\n\\n\\t\\t\\tfor i in range(1,length):\\n\\t\\t\\t\\tif array[i].val < array[i-1].val:\\n\\t\\t\\t\\t\\tfirst_node = array[i-1]\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\tfor i in range(length-2,-1,-1):\\n\\t\\t\\t\\tif array[i].val > array[i+1].val:\\n\\t\\t\\t\\t\\tsecond_node = array[i+1]\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\tfirst_node.val , second_node.val = second_node.val , first_node.val",
                "codeTag": "Java"
            },
            {
                "id": 1962494,
                "title": "go-inorder-dfs-clear-solution",
                "content": "```\\nfunc recoverTree(root *TreeNode)  {\\n    var prev, first, second *TreeNode\\n    \\n    var dfs func(node *TreeNode)\\n    dfs = func(node *TreeNode) {\\n        if node == nil { return }\\n        dfs(node.Left)\\n        if prev != nil {\\n            if first == nil && prev.Val >= node.Val { first = prev }\\n            if first != nil && prev.Val >= node.Val { second = node }\\n        }\\n        prev = node\\n        dfs(node.Right)\\n    }\\n    dfs(root)\\n\\t\\n    first.Val, second.Val = second.Val, first.Val\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc recoverTree(root *TreeNode)  {\\n    var prev, first, second *TreeNode\\n    \\n    var dfs func(node *TreeNode)\\n    dfs = func(node *TreeNode) {\\n        if node == nil { return }\\n        dfs(node.Left)\\n        if prev != nil {\\n            if first == nil && prev.Val >= node.Val { first = prev }\\n            if first != nil && prev.Val >= node.Val { second = node }\\n        }\\n        prev = node\\n        dfs(node.Right)\\n    }\\n    dfs(root)\\n\\t\\n    first.Val, second.Val = second.Val, first.Val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1962329,
                "title": "two-js-solutions-recursive-and-iterative",
                "content": "# Iterative Solution: \\n```\\nconst recoverTree = function (root) {\\n\\tconst stack = [];\\n\\tlet node = root,\\n\\t\\tprev = null,\\n\\t\\tx = null,\\n\\t\\ty = null;\\n\\twhile (stack.length || node) {\\n\\t\\tif (node) {\\n\\t\\t\\tstack.push(node);\\n\\t\\t\\tnode = node.left;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tnode = stack.pop();\\n\\t\\tif (prev && prev.val > node.val) {\\n\\t\\t\\ty = node;\\n\\t\\t\\tif (!x) x = prev;\\n\\t\\t\\telse break;\\n\\t\\t}\\n\\t\\tprev = node;\\n\\t\\tnode = node.right;\\n\\t}\\n\\t[x.val, y.val] = [y.val, x.val];\\n};\\n```\\n# Recursive Solution:\\n```\\nconst recoverTree = function (root) {\\n\\tlet x = null,\\n\\t\\ty = null,\\n\\t\\tprev = null;\\n\\tconst dfs = (node) => {\\n\\t\\tif (!node) return;\\n\\t\\tdfs(node.left);\\n\\t\\tif (prev && node.val < prev.val) {\\n\\t\\t\\tif (x == null) x = prev;\\n\\t\\t\\ty = node;\\n\\t\\t}\\n\\t\\tprev = node;\\n\\t\\tdfs(node.right);\\n\\t};\\n\\tdfs(root);\\n\\t[x.val, y.val] = [y.val, x.val];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nconst recoverTree = function (root) {\\n\\tconst stack = [];\\n\\tlet node = root,\\n\\t\\tprev = null,\\n\\t\\tx = null,\\n\\t\\ty = null;\\n\\twhile (stack.length || node) {\\n\\t\\tif (node) {\\n\\t\\t\\tstack.push(node);\\n\\t\\t\\tnode = node.left;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tnode = stack.pop();\\n\\t\\tif (prev && prev.val > node.val) {\\n\\t\\t\\ty = node;\\n\\t\\t\\tif (!x) x = prev;\\n\\t\\t\\telse break;\\n\\t\\t}\\n\\t\\tprev = node;\\n\\t\\tnode = node.right;\\n\\t}\\n\\t[x.val, y.val] = [y.val, x.val];\\n};\\n```\n```\\nconst recoverTree = function (root) {\\n\\tlet x = null,\\n\\t\\ty = null,\\n\\t\\tprev = null;\\n\\tconst dfs = (node) => {\\n\\t\\tif (!node) return;\\n\\t\\tdfs(node.left);\\n\\t\\tif (prev && node.val < prev.val) {\\n\\t\\t\\tif (x == null) x = prev;\\n\\t\\t\\ty = node;\\n\\t\\t}\\n\\t\\tprev = node;\\n\\t\\tdfs(node.right);\\n\\t};\\n\\tdfs(root);\\n\\t[x.val, y.val] = [y.val, x.val];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534309,
                "title": "c-solution-with-easy-to-understand-explanation",
                "content": "```\\n    void recoverTree(TreeNode* root) {\\n        // when inorder traversing a BST, we would traverse the node with the values in increasing order\\n        // if there are only two nodes in the BST that their values are wrong, there\\'s only one situation:\\n        // a node with a larger value appears before a node with a smaller value in the inorder traversal result\\n        // during the inorder traversing, the first node which value is greater than the its successor must be one of the wrong nodes which has a larger value\\n        // for the smaller value wrong node, we can see that its value must be smaller than its predecessor\\n        // we can see that the last node which value is smaller than its predecessor in the inorder traversal must be the smaller wrong node.\\n        // to better understanding we can see that for an inorder traversal result 1 2 6 4 5 3 7\\n        // the first node that its value greater than its successor is the node with value 6\\n        // and the last node which value is smaller than its predecessor is the node with value 3\\n        // for an other example, 1 3 2 4\\n        // 3 is the first value which is greater than its successor and 2 is the last value which value is smaller than its predecessor\\n        TreeNode* largeNode = NULL;\\n        TreeNode* smallNode = NULL;\\n        TreeNode* preNode = NULL;\\n        inorderTraversal(root, largeNode, smallNode, preNode);\\n        int smallVal = smallNode->val;\\n        smallNode->val = largeNode->val;\\n        largeNode->val = smallVal;\\n    }\\n    \\n    void inorderTraversal(TreeNode* node, TreeNode*& largeNode, TreeNode*& smallNode, TreeNode*& preNode) {\\n        if (node == NULL) {\\n            return;\\n        }\\n        inorderTraversal(node->left, largeNode, smallNode, preNode);\\n        // the first node has no predecessor so we can\\'t tell whether it\\'s greater or smaller than its predecessor\\n        if (preNode != NULL && node->val < preNode->val) {\\n            // largeNode equals NULL means preNode is the first node whose value is greater than its successor\\n            // so preNode is the wrong larger node\\n            if (largeNode == NULL) {\\n                largeNode = preNode;\\n            }\\n            // there maybe two nodes with a smaller value than its predecessor, the successor of the larger wrong node and the real smaller wrong node\\n            // the last smallNode is the smaller wrong node which we want to get\\n            smallNode = node;\\n        }\\n        // node becomes preNode of the next node after being traversed\\n        preNode = node;\\n        inorderTraversal(node->right, largeNode, smallNode, preNode);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void recoverTree(TreeNode* root) {\\n        // when inorder traversing a BST, we would traverse the node with the values in increasing order\\n        // if there are only two nodes in the BST that their values are wrong, there\\'s only one situation:\\n        // a node with a larger value appears before a node with a smaller value in the inorder traversal result\\n        // during the inorder traversing, the first node which value is greater than the its successor must be one of the wrong nodes which has a larger value\\n        // for the smaller value wrong node, we can see that its value must be smaller than its predecessor\\n        // we can see that the last node which value is smaller than its predecessor in the inorder traversal must be the smaller wrong node.\\n        // to better understanding we can see that for an inorder traversal result 1 2 6 4 5 3 7\\n        // the first node that its value greater than its successor is the node with value 6\\n        // and the last node which value is smaller than its predecessor is the node with value 3\\n        // for an other example, 1 3 2 4\\n        // 3 is the first value which is greater than its successor and 2 is the last value which value is smaller than its predecessor\\n        TreeNode* largeNode = NULL;\\n        TreeNode* smallNode = NULL;\\n        TreeNode* preNode = NULL;\\n        inorderTraversal(root, largeNode, smallNode, preNode);\\n        int smallVal = smallNode->val;\\n        smallNode->val = largeNode->val;\\n        largeNode->val = smallVal;\\n    }\\n    \\n    void inorderTraversal(TreeNode* node, TreeNode*& largeNode, TreeNode*& smallNode, TreeNode*& preNode) {\\n        if (node == NULL) {\\n            return;\\n        }\\n        inorderTraversal(node->left, largeNode, smallNode, preNode);\\n        // the first node has no predecessor so we can\\'t tell whether it\\'s greater or smaller than its predecessor\\n        if (preNode != NULL && node->val < preNode->val) {\\n            // largeNode equals NULL means preNode is the first node whose value is greater than its successor\\n            // so preNode is the wrong larger node\\n            if (largeNode == NULL) {\\n                largeNode = preNode;\\n            }\\n            // there maybe two nodes with a smaller value than its predecessor, the successor of the larger wrong node and the real smaller wrong node\\n            // the last smallNode is the smaller wrong node which we want to get\\n            smallNode = node;\\n        }\\n        // node becomes preNode of the next node after being traversed\\n        preNode = node;\\n        inorderTraversal(node->right, largeNode, smallNode, preNode);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1402315,
                "title": "c-solution-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    int i=0;\\n    void find(TreeNode*root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        find(root->left);\\n        v.push_back(root->val);\\n        find(root->right);\\n    }\\n    void check(TreeNode*root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        check(root->left);\\n         root->val=v[i++];\\n        check(root->right);\\n    }\\n    void recoverTree(TreeNode* root)\\n    {\\n        find(root);\\n        sort(v.begin(),v.end());\\n        check(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    int i=0;\\n    void find(TreeNode*root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        find(root->left);\\n        v.push_back(root->val);\\n        find(root->right);\\n    }\\n    void check(TreeNode*root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        check(root->left);\\n         root->val=v[i++];\\n        check(root->right);\\n    }\\n    void recoverTree(TreeNode* root)\\n    {\\n        find(root);\\n        sort(v.begin(),v.end());\\n        check(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381752,
                "title": "simple-recursion-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    TreeNode* prev =NULL;\\n    \\n    void help(TreeNode*root){\\n        \\n        \\n    if(root == NULL) return;\\n    help(root->left);\\n    if(prev && first==NULL && prev->val>root->val) first = prev;\\n    if(prev && first!=NULL && prev->val>root->val) second = root;\\n    prev = root;\\n    help(root->right);\\n        \\n        \\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        \\n    help(root);\\n    swap(first->val,second->val);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    TreeNode* prev =NULL;\\n    \\n    void help(TreeNode*root){\\n        \\n        \\n    if(root == NULL) return;\\n    help(root->left);\\n    if(prev && first==NULL && prev->val>root->val) first = prev;\\n    if(prev && first!=NULL && prev->val>root->val) second = root;\\n    prev = root;\\n    help(root->right);\\n        \\n        \\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        \\n    help(root);\\n    swap(first->val,second->val);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282486,
                "title": "o-1-space-time-complexity",
                "content": "```\\nclass Solution {\\n    TreeNode first=null;\\n    TreeNode second=null;\\n    TreeNode prev=null;\\n    \\n    public void fix(TreeNode root){\\n        if(root==null) return;\\n        \\n        //traverse for left\\n        fix(root.left);\\n        \\n        //check for mistake\\n        if(prev!=null&&root.val<prev.val){\\n            if(first==null) first=prev;\\n            second=root;\\n        }\\n        \\n        //update previous to be root\\n        prev=root;\\n        \\n        //traverse for right\\n        fix(root.right);\\n    }\\n    \\n    public void recoverTree(TreeNode root) {\\n        fix(root);\\n        \\n        //swap first and second\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode first=null;\\n    TreeNode second=null;\\n    TreeNode prev=null;\\n    \\n    public void fix(TreeNode root){\\n        if(root==null) return;\\n        \\n        //traverse for left\\n        fix(root.left);\\n        \\n        //check for mistake\\n        if(prev!=null&&root.val<prev.val){\\n            if(first==null) first=prev;\\n            second=root;\\n        }\\n        \\n        //update previous to be root\\n        prev=root;\\n        \\n        //traverse for right\\n        fix(root.right);\\n    }\\n    \\n    public void recoverTree(TreeNode root) {\\n        fix(root);\\n        \\n        //swap first and second\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194053,
                "title": "python-easy-and-understandable",
                "content": "```\\nimport math\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        first = None\\n        sec = None\\n        prev = TreeNode(-math.inf)\\n        def check(root):\\n            nonlocal prev,first,sec\\n            if root==None:\\n                return\\n            check(root.left)\\n            if root.val<prev.val:\\n                if not first:\\n                    first = prev\\n                sec = root\\n            prev = root\\n            check(root.right)\\n        check(root)\\n        first.val,sec.val = sec.val,first.val\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nimport math\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        first = None\\n        sec = None\\n        prev = TreeNode(-math.inf)\\n        def check(root):\\n            nonlocal prev,first,sec\\n            if root==None:\\n                return\\n            check(root.left)\\n            if root.val<prev.val:\\n                if not first:\\n                    first = prev\\n                sec = root\\n            prev = root\\n            check(root.right)\\n        check(root)\\n        first.val,sec.val = sec.val,first.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920369,
                "title": "python3-morris-in-order-traversal-generator-recover-binary-search-tree",
                "content": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        def morrisInOrder(root):\\n            while root:\\n                if not root.left:\\n                    yield root\\n                    root = root.right\\n                else:    \\n                    prev = root.left\\n                    while prev.right and prev.right != root:\\n                        prev = prev.right\\n                    if not prev.right:\\n                        prev.right = root\\n                        root = root.left\\n                    else:\\n                        yield root\\n                        prev.right = None\\n                        root = root.right\\n        prev, first, second = None, None, None\\n        for curr in morrisInOrder(root):\\n            if prev and prev.val > curr.val:\\n                if not first:\\n                    first = prev\\n                second = curr\\n            prev = curr\\n        first.val, second.val = second.val, first.val \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        def morrisInOrder(root):\\n            while root:\\n                if not root.left:\\n                    yield root\\n                    root = root.right\\n                else:    \\n                    prev = root.left\\n                    while prev.right and prev.right != root:\\n                        prev = prev.right\\n                    if not prev.right:\\n                        prev.right = root\\n                        root = root.left\\n                    else:\\n                        yield root\\n                        prev.right = None\\n                        root = root.right\\n        prev, first, second = None, None, None\\n        for curr in morrisInOrder(root):\\n            if prev and prev.val > curr.val:\\n                if not first:\\n                    first = prev\\n                second = curr\\n            prev = curr\\n        first.val, second.val = second.val, first.val \\n```",
                "codeTag": "Java"
            },
            {
                "id": 856474,
                "title": "commented-fully-explained",
                "content": "```\\n// There are two nodes not in their places, so one will be larger than the other, \\n// let\\'s say a is the larger node and b is the smaller node and both of them needs\\n// to be swapped in order to correct the binary search tree, so now, surely a is \\n// taking the place of a smaller number(b), so a will come earlier in the inorder\\n// traversal, so whenever we find a pair not following the non dec order in the \\n// inorder traversal, the first element is always the prev node. And to handle case\\n// when only the first occuring problematic pair needs to be sorted, we assign\\n// second to the current node as well, but if we a pair like this again, we will \\n// simply assign second to the current node as it is taking a place of a bigger node\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n// first points to first misplaced node and second points\\n// to the second one, prev points to the prev node in the\\n// inorder traversal.\\nTreeNode * first = NULL;\\nTreeNode * second = NULL;\\nTreeNode * prev = new TreeNode(INT_MIN);\\n    \\n    void recoverTree(TreeNode* root) \\n    {\\n        if(!root)\\n            return;\\n        \\n        find(root);\\n        swap(first->val, second->val);   \\n    }\\n    \\n    void find(TreeNode * root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        find(root->left);\\n        \\n        // in case we find inorder is not in non dec order, we assign first\\n        // as prev, we have talked about in brief earlier.\\n        if(prev->val > root->val && first ==NULL)\\n            first = prev;\\n        \\n        \\n        // we have not used else if here to avoid corner cases, whenever some\\n        // pair not following the non dec order occurs, we assign first and second\\n        // pointers to the nodes respectively, to handle the case where only both \\n        // of them are to be swapped. If we find some other node not following the \\n        // order, we will assign second to that node as this if condition will\\n        // satisfy for that as well.\\n        if(prev->val > root->val && first !=NULL)\\n            second = root;\\n        \\n        prev = root;   \\n        \\n        find(root->right);\\n        \\n        return;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// There are two nodes not in their places, so one will be larger than the other, \\n// let\\'s say a is the larger node and b is the smaller node and both of them needs\\n// to be swapped in order to correct the binary search tree, so now, surely a is \\n// taking the place of a smaller number(b), so a will come earlier in the inorder\\n// traversal, so whenever we find a pair not following the non dec order in the \\n// inorder traversal, the first element is always the prev node. And to handle case\\n// when only the first occuring problematic pair needs to be sorted, we assign\\n// second to the current node as well, but if we a pair like this again, we will \\n// simply assign second to the current node as it is taking a place of a bigger node\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n// first points to first misplaced node and second points\\n// to the second one, prev points to the prev node in the\\n// inorder traversal.\\nTreeNode * first = NULL;\\nTreeNode * second = NULL;\\nTreeNode * prev = new TreeNode(INT_MIN);\\n    \\n    void recoverTree(TreeNode* root) \\n    {\\n        if(!root)\\n            return;\\n        \\n        find(root);\\n        swap(first->val, second->val);   \\n    }\\n    \\n    void find(TreeNode * root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        find(root->left);\\n        \\n        // in case we find inorder is not in non dec order, we assign first\\n        // as prev, we have talked about in brief earlier.\\n        if(prev->val > root->val && first ==NULL)\\n            first = prev;\\n        \\n        \\n        // we have not used else if here to avoid corner cases, whenever some\\n        // pair not following the non dec order occurs, we assign first and second\\n        // pointers to the nodes respectively, to handle the case where only both \\n        // of them are to be swapped. If we find some other node not following the \\n        // order, we will assign second to that node as this if condition will\\n        // satisfy for that as well.\\n        if(prev->val > root->val && first !=NULL)\\n            second = root;\\n        \\n        prev = root;   \\n        \\n        find(root->right);\\n        \\n        return;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543745,
                "title": "simple-and-efficient-java-solution-runs-in-1ms-in-order-traversal",
                "content": "```\\nclass Solution {\\n    private int preVal = Integer.MIN_VALUE;\\n    private TreeNode first;\\n    private TreeNode second;\\n    \\n    public void recoverTree(TreeNode root) {\\n        traverse(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if(root == null)\\n            return;\\n        \\n        traverse(root.left);\\n        \\n        if(preVal > root.val) second = root;\\n        if(second == null) first = root;\\n        preVal = root.val;\\n        \\n        traverse(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int preVal = Integer.MIN_VALUE;\\n    private TreeNode first;\\n    private TreeNode second;\\n    \\n    public void recoverTree(TreeNode root) {\\n        traverse(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if(root == null)\\n            return;\\n        \\n        traverse(root.left);\\n        \\n        if(preVal > root.val) second = root;\\n        if(second == null) first = root;\\n        preVal = root.val;\\n        \\n        traverse(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533030,
                "title": "java-simple-in-order-traversal-constant-space-with-detailed-explanation",
                "content": "When we meet BST, there are two features must be appeared in mind\\n1, in-order traversal is ascending\\n2, `root.left.val < root.val && root.right.val > root.val`, and recursively.\\n\\nThis question use first feature.\\n\\nIf we print the in-order array, correct BST\\'s picture will be a ascending line,\\nbut if we swap two node\\'s value, there will be two obviously point.\\n![image](https://assets.leetcode.com/users/yoha/image_1583660730.png)\\na is correct, b and c is two situation with swap.\\n```\\n    TreeNode pre = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    boolean one = false;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n\\t\\t// do swap\\n        int tmp = first.val;\\n        first.val = second.val;\\n        second.val = tmp;\\n    }\\n    \\n    private void inorder(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorder(root.left);\\n        if (pre != null) {\\n            if (pre.val > root.val) {\\n                if (!one) {\\n                    first = pre;\\n                    one = true;\\n                }\\n                second = root;\\n            }\\n        }\\n        pre = root;\\n        inorder(root.right);\\n    }\\n```\\nAbove is recursion method, and you could use Stack to implement iterative method.",
                "solutionTags": [],
                "code": "```\\n    TreeNode pre = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    boolean one = false;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n\\t\\t// do swap\\n        int tmp = first.val;\\n        first.val = second.val;\\n        second.val = tmp;\\n    }\\n    \\n    private void inorder(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorder(root.left);\\n        if (pre != null) {\\n            if (pre.val > root.val) {\\n                if (!one) {\\n                    first = pre;\\n                    one = true;\\n                }\\n                second = root;\\n            }\\n        }\\n        pre = root;\\n        inorder(root.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256063,
                "title": "java-in-order-traversal-with-detailed-analysis-of-the-in-order-solution",
                "content": "There are several facts to know to solve this problem:\\nLet\\'s consider the in-order traversal of a normal bst, the sequence will be:\\n```\\n1 2 3 4 5 6\\n```\\nIf we swap any two nodes, like 2 and 5, the sequence can be:\\n```\\n1 [5] 3 4 [2] 6\\n```\\nSo how to detect the first node and the second node? We can keep checking that whether a node\\'s value is strictly larger than it\\'s predecessor\\'s value. If at some point this rule is broken, we know that there is some abnormal nodes. Let\\'s see when this will happen:\\nWhen we check 3, we will find 5 > 3. The rule is broken, and 5 is the **predecessor** of 3.\\nWhen we check 6, we will find 6 > 2. The rule is broken again, and 2 is the **predecessor** of 6.\\n\\nYou will find that no matter which nodes we swap, we can obey this rule to get the first and the second node that we need to swap them back. \\n\\nThere is another fact about how to keep track of the predecessor. For in-order traversal, we keep going left until there is no left child, then visit the node, and then visit right child. Thus, if the node choose to go left, there is no predecessor update. After the node visited itself and start going right, there should be a predecessor-update. \\n\\nAnd finally, according to these two facts, we can find the first & second node, with O(logn) space complexity and O(n) time complexity.\\n\\n```\\nclass Solution {\\n    TreeNode first = null, second = null, pred = null;\\n    public void recoverTree(TreeNode root) {\\n        recover(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void recover(TreeNode node) {\\n        if (node == null) return;\\n        recover(node.left);\\n        if (first == null && pred != null && pred.val > node.val) {\\n            first = pred;\\n        }\\n        if (first != null && pred.val > node.val) {\\n            second = node;\\n        }\\n        pred = node;\\n        recover(node.right);    \\n    }  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1 2 3 4 5 6\\n```\n```\\n1 [5] 3 4 [2] 6\\n```\n```\\nclass Solution {\\n    TreeNode first = null, second = null, pred = null;\\n    public void recoverTree(TreeNode root) {\\n        recover(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void recover(TreeNode node) {\\n        if (node == null) return;\\n        recover(node.left);\\n        if (first == null && pred != null && pred.val > node.val) {\\n            first = pred;\\n        }\\n        if (first != null && pred.val > node.val) {\\n            second = node;\\n        }\\n        pred = node;\\n        recover(node.right);    \\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244861,
                "title": "in-place-solution-with-explanation-44ms-and-28-4mb-beats-96-12-and-87-5-repectively",
                "content": "First of all, **Keep in mind there are only two elements place are wrong in BST**\\n\\nSo here are three different scenarios and its base solution for this problem:\\n1. One larger node locates at the left side of a subtree. try to find it, and store the larger node as ```largerNode```and its parent as ```tmpNode```. Swap the value of ```largerNode``` and ```tmpNode```.\\n2. One smaller node locates at the right side of a subtree. try to find it, and store the smaller node ```smallerNode``` and its parent as ```tmpNode```. Swap the value of ```smallerNode``` and ```tmpNode```.\\n3. Both 1 and 2 happens, swap ```largerNode``` and ```smallerNode```.\\n\\nBut the solution in 1 and 2 are not stable, obviously, so as 3. Considering BST [1,2,null,3]. after using current solution in case 1, the result BST is [2,1,null,3]. Recall, **only two elements place are wrong**. we need to thoroughly find every node which are larger than its parent or even higher - grandparent. But there are **Only two wrong placed elements**, image we reach TreeNode(5), and its left children or grandchildren are TreeNode(6), TreeNode(7), TreeNode(8). Swap the TreeNode(6) or TreeNode(7) cannot help us fix the BST, since TreeNode(8) is still larger than its grandparents. **Thus, for case 1, this reminder us we only need to save the largest node locates at left side of a subtree whose root has smaller value, the problem only could be solved by swapping the largest node and the subtree root (where the violation begins).** This also could be proven by contradiction, if this cannot fix BST for case 1, any other swap cannot as well.\\n\\nTo avoid of using any container, we only could solve it recursively, BFS or DFS. With above analysis, since we need to find the largest or smallest violation node exhaustively, DFS is the first choice. \\n\\nRecall above case 1-3 are highly depends on the given BST structure, our solution would need to try to find both ```largerNode``` and ```smallerNode```, and the make swap decision depends on whether ```largerNode``` and ```smallerNode``` is found after DFS finished.\\n\\n**Another DFS feature with BST is, the search order is predefined, left or right.** Assume left first, so that the search would firstly find ```largerNode``` and then ```smallerNode```. In each DFS, we also need to update the minimal node value and maximum node vaule to check the violation for current node, and more importantly, **find largeNode as larger as possible, find smallNode as smaller as possible, which violate BST feature**. \\n\\nWith above analysis, remaining issue is how to update search space in each DFS. Similarly, this also have three different scenarios:\\n1. No violation, using current node as a division point, search space for left children (curMinNode, curNode), search space for right childeren (curNode, curMaxNode)\\n2. Violate curMaxNode, which means the largeNode show at the left side of the subtree(or root). For left children, same search space as current one, due to this violation node may swap away, and we need to keep current maxNode smaller to narrow down the space for its left children. For right children, assume we may swap curNode with curMaxNode, so that the curNode becomes its grandparents, and curNode->right is its grandparent\\'s left grandchildren but its prarent\\'s right children, so that the search space is (curMaxNode, curNode)\\n3. Violate curMinNode, which means the smallNode show at the right side of the subtree (or root). Similar as 2, but with symmetry.\\n\\nAfter all, here is the solution:\\n\\n```\\nclass Solution {\\n    TreeNode* largeNode = nullptr;\\n    TreeNode* smallNode = nullptr; \\n    TreeNode* tmpNode = nullptr;\\n    \\n    void swapNodeValue(TreeNode* a, TreeNode* b) {\\n        if (!a || !b) return;\\n        int tVal = a->val;\\n        a->val = b->val;\\n        b->val = tVal;\\n        return;\\n    }\\n\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        dfs(root, nullptr, nullptr);\\n        if (largeNode && smallNode) {\\n            swapNodeValue(largeNode, smallNode);\\n        } else if (largeNode) {\\n            swapNodeValue(largeNode, tmpNode);\\n        } else if (smallNode) {\\n            swapNodeValue(smallNode, tmpNode);\\n        }\\n        return;\\n    }\\n    \\n    void dfs(TreeNode* node, TreeNode* minNode, TreeNode* maxNode) {\\n        if (node == nullptr) return;\\n\\t\\t// this is largeNode only if it is larger than its upper limit\\n        if (maxNode && node->val > maxNode->val) {\\n            if (!tmpNode) tmpNode = maxNode;\\n            if (!largeNode) largeNode = node;\\n            if (node->val > largeNode->val) largeNode = node;\\n            dfs(node->left, minNode, maxNode);\\n            dfs(node->right, maxNode, node);\\n            return;\\n        }\\n\\t\\t// this is smallNode only if it is larget than its lower limit\\n        if (minNode && node->val < minNode->val) {\\n            if (!tmpNode) tmpNode = minNode;\\n            if (!smallNode) smallNode = node;\\n            if (node->val < smallNode->val) smallNode = node;\\n            dfs(node->left, node, maxNode);\\n            dfs(node->right, minNode, maxNode);\\n            return;\\n        }\\n        dfs(node->left, minNode, node);\\n        dfs(node->right, node, maxNode);\\n        return;\\n    }\\n};\\n```\\n\\nWe only need to store ```tmpNode``` once for case 1 or case 2. When case 3 happens, we only need to swap ```largeNode``` and ```smallNode```, so that ```tmpNode```is not useful anymore.\\n\\nOverall, this is a good practice to solve tree problem using recursion, with the constant space challenge (stricktly speaking, function overheads also takes space in each recursion, I\\'d like to say it is IN-PLACE solution). It helps me a lot to utilize tree features and DFS in problem solving. Althought it is also my most failure submissions problem so far, but it feels really great when you finally solve it on your own **:)**\\n\\n",
                "solutionTags": [],
                "code": "```largerNode```\n```tmpNode```\n```largerNode```\n```tmpNode```\n```smallerNode```\n```tmpNode```\n```smallerNode```\n```tmpNode```\n```largerNode```\n```smallerNode```\n```largerNode```\n```smallerNode```\n```largerNode```\n```smallerNode```\n```largerNode```\n```smallerNode```\n```\\nclass Solution {\\n    TreeNode* largeNode = nullptr;\\n    TreeNode* smallNode = nullptr; \\n    TreeNode* tmpNode = nullptr;\\n    \\n    void swapNodeValue(TreeNode* a, TreeNode* b) {\\n        if (!a || !b) return;\\n        int tVal = a->val;\\n        a->val = b->val;\\n        b->val = tVal;\\n        return;\\n    }\\n\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        dfs(root, nullptr, nullptr);\\n        if (largeNode && smallNode) {\\n            swapNodeValue(largeNode, smallNode);\\n        } else if (largeNode) {\\n            swapNodeValue(largeNode, tmpNode);\\n        } else if (smallNode) {\\n            swapNodeValue(smallNode, tmpNode);\\n        }\\n        return;\\n    }\\n    \\n    void dfs(TreeNode* node, TreeNode* minNode, TreeNode* maxNode) {\\n        if (node == nullptr) return;\\n\\t\\t// this is largeNode only if it is larger than its upper limit\\n        if (maxNode && node->val > maxNode->val) {\\n            if (!tmpNode) tmpNode = maxNode;\\n            if (!largeNode) largeNode = node;\\n            if (node->val > largeNode->val) largeNode = node;\\n            dfs(node->left, minNode, maxNode);\\n            dfs(node->right, maxNode, node);\\n            return;\\n        }\\n\\t\\t// this is smallNode only if it is larget than its lower limit\\n        if (minNode && node->val < minNode->val) {\\n            if (!tmpNode) tmpNode = minNode;\\n            if (!smallNode) smallNode = node;\\n            if (node->val < smallNode->val) smallNode = node;\\n            dfs(node->left, node, maxNode);\\n            dfs(node->right, minNode, maxNode);\\n            return;\\n        }\\n        dfs(node->left, minNode, node);\\n        dfs(node->right, node, maxNode);\\n        return;\\n    }\\n};\\n```\n```tmpNode```\n```largeNode```\n```smallNode```\n```tmpNode```",
                "codeTag": "Java"
            },
            {
                "id": 223902,
                "title": "inorder-traversal-logical-thinking",
                "content": "> How do we detect swapped nodes?\\n> Inorder traversal of BST meets nodes in the sorted order - the swapped nodes break this rule.\\n\\n> We observe that 1 swap results in 1 or 2 decreasing flow\\n-  1 decreasing:\\ne.g. [1 2 3 4 5]\\nswap 2 and 3 to [1 3 2 4 5]\\n3 -> 2 decreasing -- the second to swap right after the first to swap\\n- 2 decreasing:\\ne.g. [1 2 3 4 5]\\nswap 2 and 4 to [1 4 3 2 5]\\n4 -> 3 decreasing\\n3 -> 2 decreasing -- the second to swap is the latter element of the second decreasing flow  \\n\\n****\\n> Scala\\n```\\n  var prevNode, fstToSwap, sndToSwap: TreeNode = _\\n\\n  def recoverTree(root: TreeNode): Unit = {\\n    prevNode = null\\n    fstToSwap = null\\n    sndToSwap = null\\n    \\n    inorderTraverse(root)\\n    \\n    val fstToSwapValue = fstToSwap.value\\n    fstToSwap.value = sndToSwap.value\\n    sndToSwap.value = fstToSwapValue\\n  }\\n  \\n  def inorderTraverse(root: TreeNode): Unit = {\\n    if (root != null) {\\n      inorderTraverse(root.left)\\n      \\n      if (prevNode != null && prevNode.value > root.value && fstToSwap == null) fstToSwap = prevNode\\n      if (prevNode != null && prevNode.value > root.value && fstToSwap != null) sndToSwap = root\\n\\n      prevNode = root\\n      \\n      inorderTraverse(root.right)\\n    }\\n  }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n  var prevNode, fstToSwap, sndToSwap: TreeNode = _\\n\\n  def recoverTree(root: TreeNode): Unit = {\\n    prevNode = null\\n    fstToSwap = null\\n    sndToSwap = null\\n    \\n    inorderTraverse(root)\\n    \\n    val fstToSwapValue = fstToSwap.value\\n    fstToSwap.value = sndToSwap.value\\n    sndToSwap.value = fstToSwapValue\\n  }\\n  \\n  def inorderTraverse(root: TreeNode): Unit = {\\n    if (root != null) {\\n      inorderTraverse(root.left)\\n      \\n      if (prevNode != null && prevNode.value > root.value && fstToSwap == null) fstToSwap = prevNode\\n      if (prevNode != null && prevNode.value > root.value && fstToSwap != null) sndToSwap = root\\n\\n      prevNode = root\\n      \\n      inorderTraverse(root.right)\\n    }\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 187755,
                "title": "go-solution",
                "content": "```\\nfunc Swap(x, y *TreeNode) {\\n    x.Val, y.Val = y.Val, x.Val\\n}\\n\\nfunc Inorder(c chan *TreeNode, root *TreeNode) {\\n    if root == nil {\\n        return\\n    }\\n    Inorder(c, root.Left)\\n    c <- root\\n    Inorder(c, root.Right)\\n}\\n\\nfunc recoverTree(root *TreeNode) {\\n    c := make(chan *TreeNode)\\n    go func() {\\n        Inorder(c, root)\\n        close(c)\\n    }()\\n\\n    var first, second *TreeNode\\n    prev := <-c\\n    for x := range c {\\n        if x.Val < prev.Val {\\n            if first == nil {\\n                first = prev\\n            } \\n            if first != nil {\\n                second = x\\n            }\\n        }\\n        prev = x\\n    }\\n    Swap(first, second)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc Swap(x, y *TreeNode) {\\n    x.Val, y.Val = y.Val, x.Val\\n}\\n\\nfunc Inorder(c chan *TreeNode, root *TreeNode) {\\n    if root == nil {\\n        return\\n    }\\n    Inorder(c, root.Left)\\n    c <- root\\n    Inorder(c, root.Right)\\n}\\n\\nfunc recoverTree(root *TreeNode) {\\n    c := make(chan *TreeNode)\\n    go func() {\\n        Inorder(c, root)\\n        close(c)\\n    }()\\n\\n    var first, second *TreeNode\\n    prev := <-c\\n    for x := range c {\\n        if x.Val < prev.Val {\\n            if first == nil {\\n                first = prev\\n            } \\n            if first != nil {\\n                second = x\\n            }\\n        }\\n        prev = x\\n    }\\n    Swap(first, second)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32582,
                "title": "simple-python-solution-with-real-o-1-space-by-using-morris-traversal-with-comments",
                "content": "\\n    def recoverTree(self, root):\\n        cur, prev, first, second, predec = root, None, None, None, None\\n        while cur:\\n            if cur.left is None:  # I have no left child so it's my turn\\n                if predec is not None and cur.val < predec.val:\\n                    if not first:\\n                        first = predec\\n                    second = cur\\n                predec = cur\\n                cur = cur.right  # After visit, go right\\n            else:\\n                # I need to find my predecessor and make me its right child\\n                # Second check in right is to make sure that I don't loop\\n                prev = cur.left\\n                while prev.right is not None and prev.right != cur:\\n                    prev = prev.right\\n                if prev.right is None:  # Not visited yet\\n                    prev.right = cur\\n                    cur = cur.left\\n                else:  # It's my turn\\n                    if predec is not None and cur.val < predec.val:\\n                        if not first:\\n                            first = predec\\n                        second = cur\\n                    predec = cur\\n                    # I remove the link after having visited\\n                    prev.right = None\\n                    cur = cur.right\\n        first.val, second.val = second.val, first.val",
                "solutionTags": [],
                "code": "\\n    def recoverTree(self, root):\\n        cur, prev, first, second, predec = root, None, None, None, None\\n        while cur:\\n            if cur.left is None:  # I have no left child so it's my turn\\n                if predec is not None and cur.val < predec.val:\\n                    if not first:\\n                        first = predec\\n                    second = cur\\n                predec = cur\\n                cur = cur.right  # After visit, go right\\n            else:\\n                # I need to find my predecessor and make me its right child\\n                # Second check in right is to make sure that I don't loop\\n                prev = cur.left\\n                while prev.right is not None and prev.right != cur:\\n                    prev = prev.right\\n                if prev.right is None:  # Not visited yet\\n                    prev.right = cur\\n                    cur = cur.left\\n                else:  # It's my turn\\n                    if predec is not None and cur.val < predec.val:\\n                        if not first:\\n                            first = predec\\n                        second = cur\\n                    predec = cur\\n                    # I remove the link after having visited\\n                    prev.right = None\\n                    cur = cur.right\\n        first.val, second.val = second.val, first.val",
                "codeTag": "Python3"
            },
            {
                "id": 32604,
                "title": "18ms-java-solution-with-in-order-traversal-and-sorting-o-nlogn-time-and-o-n-space",
                "content": "    public class Solution {\\n        public void recoverTree(TreeNode root) {\\n            // in-order traversal of treenodes, followed by sorting and reassignment of values\\n            List<TreeNode> inorder = inorder(root);\\n            List<Integer> inorderNumbers = new ArrayList<Integer>();\\n            for (TreeNode node : inorder) {\\n                inorderNumbers.add(node.val);\\n            }\\n            inorderNumbers.sort(null);\\n            for (int i = 0; i < inorder.size(); i++) {\\n                inorder.get(i).val = inorderNumbers.get(i);\\n            }\\n        }\\n        \\n        private List<TreeNode> inorder (TreeNode root) {\\n            List<TreeNode> result = new ArrayList<TreeNode>();\\n            if (root == null) {\\n                return result;\\n            }\\n            result.addAll(inorder(root.left));\\n            result.add(root);\\n            result.addAll(inorder(root.right));\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void recoverTree(TreeNode root) {\\n            // in-order traversal of treenodes, followed by sorting and reassignment of values\\n            List<TreeNode> inorder = inorder(root);\\n            List<Integer> inorderNumbers = new ArrayList<Integer>();\\n            for (TreeNode node : inorder) {\\n                inorderNumbers.add(node.val);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 32649,
                "title": "is-there-any-other-solution-which-doesn-t-apply-morris-traversal-to-satisfy-o-1-space-complexity",
                "content": "    // my solution is just applying the morris inorder traversal\\n    // O(2N) time complexity, O(1) space complexity\\n        \\n    TreeNode *first = NULL;\\n        TreeNode *second = NULL;\\n        TreeNode *previous = NULL;\\n        \\n        void recoverTree(TreeNode *root) {\\n            if (!root) return;\\n            previous = new TreeNode(INT_MIN);\\n            \\n            morris_inorder(root);\\n            int t = first->val;\\n            first->val = second->val;\\n            second->val = t;\\n        }\\n        \\n        void morris_inorder(TreeNode *root) {\\n            TreeNode *cur = root, *pre = NULL;\\n            \\n            while (cur) {\\n    \\t\\t    if (cur->left == NULL) {\\n    \\t\\t        if (cur->val <= previous->val && !first) first = previous;\\n    \\t\\t\\t    if (cur->val <= previous->val && first) second = cur;\\n    \\t\\t\\t    previous = cur;\\n    \\t\\t\\t    cur = cur->right;\\n     \\t\\t    }\\n     \\t\\t    else {\\n     \\t\\t\\t    // find the predecessor\\n     \\t\\t\\t    pre = cur->left;\\n     \\t\\t\\t    while (pre->right && pre->right != cur)\\n     \\t\\t\\t\\t    pre = pre->right;\\n    \\n     \\t\\t\\t    if (pre->right == NULL) {\\n     \\t\\t\\t\\t    // set the backtrace link\\n     \\t\\t\\t\\t    pre->right = cur;\\n     \\t\\t\\t\\t    cur = cur->left;\\n     \\t\\t\\t    }\\n     \\t\\t\\t    else {\\n     \\t\\t\\t        if (cur->val <= previous->val && !first) first = previous;\\n    \\t\\t\\t        if (cur->val <= previous->val && first) second = cur;\\n    \\t\\t\\t        previous = cur;\\n     \\t\\t\\t\\t    pre->right = NULL;\\n     \\t\\t\\t\\t    cur = cur->right;\\n     \\t\\t\\t    }\\n     \\t\\t    }\\n     \\t    }\\n        }",
                "solutionTags": [],
                "code": "    // my solution is just applying the morris inorder traversal\\n    // O(2N) time complexity, O(1) space complexity\\n        \\n    TreeNode *first = NULL;\\n        TreeNode *second = NULL;\\n        TreeNode *previous = NULL;\\n        \\n        void recoverTree(TreeNode *root) {\\n            if (!root) return;\\n            previous = new TreeNode(INT_MIN);\\n            \\n            morris_inorder(root);\\n            int t = first->val;\\n            first->val = second->val;\\n            second->val = t;\\n        }\\n        \\n        void morris_inorder(TreeNode *root) {\\n            TreeNode *cur = root, *pre = NULL;\\n            \\n            while (cur) {\\n    \\t\\t    if (cur->left == NULL) {\\n    \\t\\t        if (cur->val <= previous->val && !first) first = previous;\\n    \\t\\t\\t    if (cur->val <= previous->val && first) second = cur;\\n    \\t\\t\\t    previous = cur;\\n    \\t\\t\\t    cur = cur->right;\\n     \\t\\t    }\\n     \\t\\t    else {\\n     \\t\\t\\t    // find the predecessor\\n     \\t\\t\\t    pre = cur->left;\\n     \\t\\t\\t    while (pre->right && pre->right != cur)\\n     \\t\\t\\t\\t    pre = pre->right;\\n    \\n     \\t\\t\\t    if (pre->right == NULL) {\\n     \\t\\t\\t\\t    // set the backtrace link\\n     \\t\\t\\t\\t    pre->right = cur;\\n     \\t\\t\\t\\t    cur = cur->left;\\n     \\t\\t\\t    }\\n     \\t\\t\\t    else {\\n     \\t\\t\\t        if (cur->val <= previous->val && !first) first = previous;\\n    \\t\\t\\t        if (cur->val <= previous->val && first) second = cur;\\n    \\t\\t\\t        previous = cur;\\n     \\t\\t\\t\\t    pre->right = NULL;\\n     \\t\\t\\t\\t    cur = cur->right;\\n     \\t\\t\\t    }\\n     \\t\\t    }\\n     \\t    }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3758168,
                "title": "java-solution-with-inorder-traversal-beats-100",
                "content": "# Intuition\\n-  We will traverse the tree in inorder fashion and check whether previous node had value less than the root.\\n- If yes, than note both of them.\\n- After the traversal we  will simply, swap both the nodes.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n) (Stack space for recursion)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private TreeNode prev = null , first = null , sec = null;\\n    public void recoverTree(TreeNode root) {\\n        helper(root);\\n        swap(first , sec);\\n        return;\\n    }\\n    private void swap (TreeNode a , TreeNode b){\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n    private void helper (TreeNode root){\\n        if(root == null)\\n        return;\\n\\n        helper(root.left);\\n\\n        if(prev != null && prev.val > root.val){\\n            if(first == null)\\n                first = prev;\\n            sec = root;\\n        }\\n\\n        prev = root;\\n\\n        helper(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private TreeNode prev = null , first = null , sec = null;\\n    public void recoverTree(TreeNode root) {\\n        helper(root);\\n        swap(first , sec);\\n        return;\\n    }\\n    private void swap (TreeNode a , TreeNode b){\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n    private void helper (TreeNode root){\\n        if(root == null)\\n        return;\\n\\n        helper(root.left);\\n\\n        if(prev != null && prev.val > root.val){\\n            if(first == null)\\n                first = prev;\\n            sec = root;\\n        }\\n\\n        prev = root;\\n\\n        helper(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647453,
                "title": "easy-c-solution-inorder-efficient",
                "content": "# Intuition\\nSo the intuition here was that the inorder traversal of a binary search tree is always sorted . so if we find any element while traversing through the BST that it\\'s value is smaller than the previos node we visited we simple swap them until we traverse through the whole BST.\\n\\n# Approach\\nSo the basic approach here is maintaining four pointers previous , first, middle, last.\\ninitially the previous pointer holds the value of minimum integer value and others are null.\\nwhen we find the first elemnt we simply make it prev then if the value of root is less then previous means in inorder if the value is smaller of the enct elemnt while traversing through the bst it means it is not acceptaable and we will make it first violation into our code but that is not the end of the code , we keep traversing through the binary search tree to find the last violation and if we find last violation we simply swap first and last but if that is not the case we swap our first violation with middle elemnt whol violated the traversal.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity:O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    private: \\n    TreeNode* prev;\\n    TreeNode* first;\\n    TreeNode* middle;\\n    TreeNode* last;\\n    private:\\n    void inorder( TreeNode* root){\\n        if(root==NULL) return;\\n        inorder( root->left);\\n        if( prev!=NULL && root->val < prev->val){\\n            if(first==NULL){\\n                first = prev;\\n                middle = root;\\n            }\\n            else last = root;\\n        }\\n        prev = root;\\n        inorder(root-> right);\\n    }\\npublic:\\n\\n    void recoverTree(TreeNode* root) {\\n        first = middle = last = NULL;\\n        prev = new TreeNode(INT_MIN);\\n        inorder(root);\\n         if( first && last){\\n            swap(first -> val, last->val);\\n        }\\n        \\n        else if( first && middle ){\\n            swap(first->val, middle-> val);\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private: \\n    TreeNode* prev;\\n    TreeNode* first;\\n    TreeNode* middle;\\n    TreeNode* last;\\n    private:\\n    void inorder( TreeNode* root){\\n        if(root==NULL) return;\\n        inorder( root->left);\\n        if( prev!=NULL && root->val < prev->val){\\n            if(first==NULL){\\n                first = prev;\\n                middle = root;\\n            }\\n            else last = root;\\n        }\\n        prev = root;\\n        inorder(root-> right);\\n    }\\npublic:\\n\\n    void recoverTree(TreeNode* root) {\\n        first = middle = last = NULL;\\n        prev = new TreeNode(INT_MIN);\\n        inorder(root);\\n         if( first && last){\\n            swap(first -> val, last->val);\\n        }\\n        \\n        else if( first && middle ){\\n            swap(first->val, middle-> val);\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519166,
                "title": "pure-o-1-solution-using-morris-traversal",
                "content": "# Approach\\n1) Initialise the previous, start, middle, and end pointers with null.\\n2) Use Morris Traversal to perform an inorder traversal.\\n3) Keep the first and last numbers that are not in ascending sequence, and the middle element is the number next to the first.\\n4) Swap first and last if there is a second (final) descending element; otherwise, swap first and mid.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode* prev = NULL, *first = NULL, *mid = NULL, *last = NULL;\\n        TreeNode* cur = root;\\n        while(cur){\\n            if(!cur -> left){\\n                if(prev and cur -> val < prev -> val){\\n                    if(!first){\\n                        first = prev;\\n                        mid = cur;\\n                    }\\n                    else last = cur;\\n                }\\n                prev = cur;\\n                cur = cur -> right;\\n            }\\n            else{\\n                TreeNode* temp = cur -> left;\\n                while(temp -> right and temp -> right != cur) temp = temp -> right;\\n                if(!temp -> right){\\n                    temp -> right = cur;\\n                    cur = cur -> left;\\n                }\\n                else{\\n                    temp -> right = NULL;\\n                    if(prev and cur -> val < prev -> val){\\n                        if(!first){\\n                            first = prev;\\n                            mid = cur;\\n                        }\\n                        else last = cur;\\n                    }\\n                    prev = cur;\\n                    cur = cur -> right;\\n                }\\n            }\\n        }\\n        if(first and last) swap(first -> val, last -> val);\\n        else if(first and mid) swap(first -> val, mid -> val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode* prev = NULL, *first = NULL, *mid = NULL, *last = NULL;\\n        TreeNode* cur = root;\\n        while(cur){\\n            if(!cur -> left){\\n                if(prev and cur -> val < prev -> val){\\n                    if(!first){\\n                        first = prev;\\n                        mid = cur;\\n                    }\\n                    else last = cur;\\n                }\\n                prev = cur;\\n                cur = cur -> right;\\n            }\\n            else{\\n                TreeNode* temp = cur -> left;\\n                while(temp -> right and temp -> right != cur) temp = temp -> right;\\n                if(!temp -> right){\\n                    temp -> right = cur;\\n                    cur = cur -> left;\\n                }\\n                else{\\n                    temp -> right = NULL;\\n                    if(prev and cur -> val < prev -> val){\\n                        if(!first){\\n                            first = prev;\\n                            mid = cur;\\n                        }\\n                        else last = cur;\\n                    }\\n                    prev = cur;\\n                    cur = cur -> right;\\n                }\\n            }\\n        }\\n        if(first and last) swap(first -> val, last -> val);\\n        else if(first and mid) swap(first -> val, mid -> val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187784,
                "title": "recover-binary-search-tree-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn this problem, we need to recover the binary search tree by fixing two nodes that were swapped by mistake. The solution to this problem can be achieved in two steps. In the first step, we will find the two nodes that are swapped, and in the second step, we will swap the nodes.\\n\\nTo find the two nodes that are swapped, we will use Morris Inorder Traversal. Morris Inorder Traversal is a space-optimized inorder traversal algorithm that allows us to traverse the tree using constant space.\\n\\nAlgorithm:\\n\\n1. Initialize two pointers current and pre to root.\\n2. While current is not null, do the following:\\na. If the current node does not have a left child, then move to the right child of the current node.\\nb. Else, find the inorder predecessor of the current node, i.e., the rightmost node in the left subtree of the current node.\\ni. If the right child of the inorder predecessor is null, then set it to the current node and move to the left child of the current node.\\nii. If the right child of the inorder predecessor is current, then set it to null, check if the pre node is not null, and if pre.val > current.val, then update the second node as current. Also, if pre is not null, then set pre.right to null. Finally, move to the right child of the current node.\\n3. If second node is not null, then swap the values of the first and second nodes.\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the number of nodes in the binary search tree.\\n\\n- Space complexity:\\nO(1).\\n\\n# Code\\n```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        first, second, pre = None, None, None\\n        current = root\\n        \\n        while current is not None:\\n            if current.left is None:\\n                if pre is not None and pre.val > current.val:\\n                    if first is None:\\n                        first = pre\\n                    second = current\\n                pre = current\\n                current = current.right\\n            else:\\n                node = current.left\\n                while node.right is not None and node.right != current:\\n                    node = node.right\\n                if node.right is None:\\n                    node.right = current\\n                    current = current.left\\n                else:\\n                    node.right = None\\n                    if pre is not None and pre.val > current.val:\\n                        if first is None:\\n                            first = pre\\n                        second = current\\n                    pre = current\\n                    current = current.right\\n        \\n        if first is not None and second is not None:\\n            first.val, second.val = second.val, first.val\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        first, second, pre = None, None, None\\n        current = root\\n        \\n        while current is not None:\\n            if current.left is None:\\n                if pre is not None and pre.val > current.val:\\n                    if first is None:\\n                        first = pre\\n                    second = current\\n                pre = current\\n                current = current.right\\n            else:\\n                node = current.left\\n                while node.right is not None and node.right != current:\\n                    node = node.right\\n                if node.right is None:\\n                    node.right = current\\n                    current = current.left\\n                else:\\n                    node.right = None\\n                    if pre is not None and pre.val > current.val:\\n                        if first is None:\\n                            first = pre\\n                        second = current\\n                    pre = current\\n                    current = current.right\\n        \\n        if first is not None and second is not None:\\n            first.val, second.val = second.val, first.val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172286,
                "title": "c-brute-force-nlogn",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Depth-First Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void dfs(TreeNode* root, vector<int>& vec) {\\n        if(!root) return;\\n        dfs(root -> left, vec);\\n        vec.push_back(root -> val);\\n        dfs(root -> right, vec);\\n    }\\n    void in(TreeNode* root, vector<int>& vec, int &i) {\\n        if(!root) return;\\n        // i++;\\n        in(root -> left, vec, i);\\n        if(root -> val != vec[i]) root -> val = vec[i];\\n        i++;\\n        in(root -> right, vec, i);\\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        vector<int> vec;\\n        dfs(root, vec);\\n        sort(vec.begin(), vec.end());\\n        int i = 0;\\n        in(root, vec, i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void dfs(TreeNode* root, vector<int>& vec) {\\n        if(!root) return;\\n        dfs(root -> left, vec);\\n        vec.push_back(root -> val);\\n        dfs(root -> right, vec);\\n    }\\n    void in(TreeNode* root, vector<int>& vec, int &i) {\\n        if(!root) return;\\n        // i++;\\n        in(root -> left, vec, i);\\n        if(root -> val != vec[i]) root -> val = vec[i];\\n        i++;\\n        in(root -> right, vec, i);\\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        vector<int> vec;\\n        dfs(root, vec);\\n        sort(vec.begin(), vec.end());\\n        int i = 0;\\n        in(root, vec, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034824,
                "title": "solution-using-inorder-traversal-explained-in-details",
                "content": "# Intuition\\nA major property of Binary Search Tree is that if you get the inorder traversal of the tree, the resultant array will be sorted. Therefore, to solve this question, we can traverse the tree in an inorder fashion to obtain the sorted array which will have exactly two elements swapped. Then we can traverse the tree again and fix the swapped elements.\\n\\n# Approach\\nWe do an inorder traversal of the tree. Run a loop on the resultant array to obtain the swapped elements and save then in two globally declared variables. Traverse the tree again and swap the elements when when encountered!\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int a, b;\\n\\n    void inorder(TreeNode*& root) {\\n        if (!root) \\n            return;\\n        \\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n\\n    void swap(TreeNode*& root) {\\n        if (!root) \\n            return;\\n        \\n        if (root->val == a)\\n            root->val = b;\\n        else if (root->val == b) \\n            root->val = a;\\n        \\n        swap(root->left);\\n        swap(root->right);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n\\n        for(int i = 0; i < v.size()-1; i++) {\\n            if (v[i] > v[i+1]) {\\n                a = v[i];\\n                break;\\n            }\\n        }\\n\\n        for(int i = v.size()-1; i > 0; i--) {\\n            if (v[i] < v[i-1]) {\\n                b = v[i];\\n                break;\\n            }\\n        }\\n\\n        swap(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int a, b;\\n\\n    void inorder(TreeNode*& root) {\\n        if (!root) \\n            return;\\n        \\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n\\n    void swap(TreeNode*& root) {\\n        if (!root) \\n            return;\\n        \\n        if (root->val == a)\\n            root->val = b;\\n        else if (root->val == b) \\n            root->val = a;\\n        \\n        swap(root->left);\\n        swap(root->right);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n\\n        for(int i = 0; i < v.size()-1; i++) {\\n            if (v[i] > v[i+1]) {\\n                a = v[i];\\n                break;\\n            }\\n        }\\n\\n        for(int i = v.size()-1; i > 0; i--) {\\n            if (v[i] < v[i-1]) {\\n                b = v[i];\\n                break;\\n            }\\n        }\\n\\n        swap(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796037,
                "title": "c-inorder-traversal",
                "content": "Please upvote if u like the solution\\n```\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root, vector<TreeNode*>& v) {\\n        if (root == NULL) return;\\n        inorderTraversal(root->left, v);\\n        v.push_back(root);\\n        inorderTraversal(root->right, v);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> v;\\n        inorderTraversal(root, v);\\n        pair<TreeNode*, TreeNode*> p{v[0], v.back()};\\n        for (int i = 1; i < v.size() - 1; ++ i ) {\\n            if (v[i]->val > v[i - 1]->val && v[i]->val > v[i + 1]->val && v[i - 1]->val < v[i + 1]->val) p.first = v[i];\\n            if (v[i]->val < v[i - 1]->val && v[i]->val < v[i + 1]->val && v[i - 1]->val < v[i + 1]->val) p.second = v[i];\\n        }\\n        swap(p.first->val, p.second->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root, vector<TreeNode*>& v) {\\n        if (root == NULL) return;\\n        inorderTraversal(root->left, v);\\n        v.push_back(root);\\n        inorderTraversal(root->right, v);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> v;\\n        inorderTraversal(root, v);\\n        pair<TreeNode*, TreeNode*> p{v[0], v.back()};\\n        for (int i = 1; i < v.size() - 1; ++ i ) {\\n            if (v[i]->val > v[i - 1]->val && v[i]->val > v[i + 1]->val && v[i - 1]->val < v[i + 1]->val) p.first = v[i];\\n            if (v[i]->val < v[i - 1]->val && v[i]->val < v[i + 1]->val && v[i - 1]->val < v[i + 1]->val) p.second = v[i];\\n        }\\n        swap(p.first->val, p.second->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674879,
                "title": "inorder-traversal-best-explanation-easy-java",
                "content": "\\n#### **Explanation:**\\nif two values are swapped then its inorder will be something like this\\n 2 3 4 **8** 6 7 **5**\\n\\nin this case \\n  - first element will always be greater than its next element (8>6)\\n  - second element will always be lesser than its prev element (5<7)\\n\\nusing this, we can mark first and second element during inorder traversal.\\nand then we will swap the value of these two nodes.\\n\\n#### **Solution:**\\n\\n```\\nclass Solution {\\n    TreeNode first=null;\\n    TreeNode second=null;\\n    TreeNode prev=new TreeNode(Integer.MIN_VALUE);\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        \\n\\t\\t// swap values\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    private void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n\\t\\t\\n        //mark first node\\n        if(first==null && prev.val>root.val)\\n            first=prev;\\n\\t\\t\\t\\n\\t\\t// mark second node\\n        if(first!=null && prev.val>root.val)\\n            second=root;\\n        \\n        prev=root;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode first=null;\\n    TreeNode second=null;\\n    TreeNode prev=new TreeNode(Integer.MIN_VALUE);\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        \\n\\t\\t// swap values\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    private void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n\\t\\t\\n        //mark first node\\n        if(first==null && prev.val>root.val)\\n            first=prev;\\n\\t\\t\\t\\n\\t\\t// mark second node\\n        if(first!=null && prev.val>root.val)\\n            second=root;\\n        \\n        prev=root;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668048,
                "title": "c-highly-commented-code-recursive-and-morris-both-free-meme",
                "content": "For complexity analysis and other stuff, **please** go [here](https://garmadon.notion.site/Recover-Binary-Search-Tree-f6bf43525e5a4a66be4c875e4740385d).\\n\\n**Recursive inorder traversal way**\\n```\\n//Global variables\\nTreeNode* firstNode = NULL;\\nTreeNode* secondNode = NULL;\\nTreeNode* prevNode = NULL;\\n\\n//Recursive inorder traversal to find the anomaly\\nvoid inorder(TreeNode* root)\\n{\\n    if(root != NULL)\\n    {\\n        inorder(root->left);\\n        \\n        //if this isn\\'t the first node you\\'re checking \\n        //and it\\'s value is less than prevNode, then \\n        //something\\'s fishy!\\n        if(prevNode != NULL and prevNode->val > root->val)\\n        {\\n            //if you haven\\'t found the first anomaly, then this is it!\\n            if(firstNode == NULL)\\n            firstNode = prevNode;\\n            \\n            //the current element may also be the anomaly\\n            secondNode = root;\\n        }\\n\\n        //update prevNode with the current node\\n        prevNode = root;\\n\\n        inorder(root->right);\\n    }\\n}\\n\\n//Program starts here\\nvoid recoverTree(TreeNode* root) \\n{\\n    //edge case - if 0 or 1 elements exist, return\\n    if(root == NULL or (root->left == NULL and root->right == NULL))\\n        return;        \\n\\n    //Search the BST using inorder traversal\\n    inorder(root);\\n\\n    //if there actually exists an anomaly... \\n    if(firstNode and secondNode)\\n        //...fix it\\n        swap(firstNode->val, secondNode->val);\\n}\\n```\\n\\n**Morris Inorder traversal way**\\n```\\n//Global variables\\nTreeNode* firstNode = NULL;\\nTreeNode* secondNode = NULL;\\nTreeNode* prevNode = NULL;\\n\\n//Program starts here\\nvoid recoverTree(TreeNode* root) \\n{\\n    //edge case - if 0 or 1 elements exist, return\\n    if(root == NULL or (root->left == NULL and root->right == NULL))\\n        return;        \\n\\n    //Search the BST using inorder traversal\\n    inorder(root);\\n\\n    //if there actually exists an anomaly... \\n    if(firstNode and secondNode)\\n        //...fix it\\n        swap(firstNode->val, secondNode->val);\\n}\\n\\n//-------------------------------\\n\\n//Inorder using Morris Traversal\\nvoid inorder(TreeNode* root) \\n{\\n    //Initialise a pointer to traverse the tree\\n    TreeNode* curr = root;\\n\\n    while(curr != NULL)\\n    {\\n        //if there\\'s no left subtree, all you need to do is...\\n        if(curr->left == NULL)\\n        {\\n            //...find anomalies and...\\n            findAnomaly(curr);\\n            //traverse the right subtree.\\n            curr = curr->right;\\n        }\\n        //But if there is a left subtree,\\n        else\\n        {\\n            //Create a new pointer on left subtree\\'s root, \\n            TreeNode* findRight = curr->left;\\n\\n            //and go to the extreme right, until you find NULL or \\n            //a thread (link) to curr\\n            while(findRight->right != NULL and findRight->right != curr)\\n            {\\n                findRight = findRight->right;\\n            }\\n\\n            //If the extreme right is a NULL, create a thread to curr, \\n            //because that\\'s where we\\'ll go after this subtree is traversed\\n            if(findRight->right == NULL)\\n            {\\n                //Create the thread (link) to curr\\n                findRight->right = curr;\\n                //Now curr can traverse the left subtree (safely, lol)\\n                curr = curr->left;\\n            }\\n            //If the extreme right was a link to curr, \\n            //the left subtree has already been visited\\n            else \\n            {\\n                //So remove the link to curr \\n                findRight->right = NULL;\\n                //Find anomalies\\n                findAnomaly(curr);\\n                //And start traversing the right subtree\\n                curr = curr->right;\\n            }\\n        }\\n    }        \\n}\\n\\nvoid findAnomaly(TreeNode* root)\\n{\\n    //if this isn\\'t the first node you\\'re checking \\n    //and it\\'s value is less than prevNode, then \\n    //something\\'s fishy!\\n    if(prevNode != NULL and prevNode->val > root->val)\\n    {\\n        //if you haven\\'t found the first anomaly, then this is it!\\n        if(firstNode == NULL)\\n        firstNode = prevNode;\\n        \\n        //the current element may also be the anomaly\\n        secondNode = root;\\n    }\\n\\n    //update prevNode with the current node\\n    prevNode = root;\\n}\\n```\\n\\nFREE MEME\\n![image](https://assets.leetcode.com/users/images/9f989468-842e-4389-a3b0-05ba669e6e6e_1665049640.0128303.png)\\n\\n*Don\\'t you illiterate people forget to upvote!*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//Global variables\\nTreeNode* firstNode = NULL;\\nTreeNode* secondNode = NULL;\\nTreeNode* prevNode = NULL;\\n\\n//Recursive inorder traversal to find the anomaly\\nvoid inorder(TreeNode* root)\\n{\\n    if(root != NULL)\\n    {\\n        inorder(root->left);\\n        \\n        //if this isn\\'t the first node you\\'re checking \\n        //and it\\'s value is less than prevNode, then \\n        //something\\'s fishy!\\n        if(prevNode != NULL and prevNode->val > root->val)\\n        {\\n            //if you haven\\'t found the first anomaly, then this is it!\\n            if(firstNode == NULL)\\n            firstNode = prevNode;\\n            \\n            //the current element may also be the anomaly\\n            secondNode = root;\\n        }\\n\\n        //update prevNode with the current node\\n        prevNode = root;\\n\\n        inorder(root->right);\\n    }\\n}\\n\\n//Program starts here\\nvoid recoverTree(TreeNode* root) \\n{\\n    //edge case - if 0 or 1 elements exist, return\\n    if(root == NULL or (root->left == NULL and root->right == NULL))\\n        return;        \\n\\n    //Search the BST using inorder traversal\\n    inorder(root);\\n\\n    //if there actually exists an anomaly... \\n    if(firstNode and secondNode)\\n        //...fix it\\n        swap(firstNode->val, secondNode->val);\\n}\\n```\n```\\n//Global variables\\nTreeNode* firstNode = NULL;\\nTreeNode* secondNode = NULL;\\nTreeNode* prevNode = NULL;\\n\\n//Program starts here\\nvoid recoverTree(TreeNode* root) \\n{\\n    //edge case - if 0 or 1 elements exist, return\\n    if(root == NULL or (root->left == NULL and root->right == NULL))\\n        return;        \\n\\n    //Search the BST using inorder traversal\\n    inorder(root);\\n\\n    //if there actually exists an anomaly... \\n    if(firstNode and secondNode)\\n        //...fix it\\n        swap(firstNode->val, secondNode->val);\\n}\\n\\n//-------------------------------\\n\\n//Inorder using Morris Traversal\\nvoid inorder(TreeNode* root) \\n{\\n    //Initialise a pointer to traverse the tree\\n    TreeNode* curr = root;\\n\\n    while(curr != NULL)\\n    {\\n        //if there\\'s no left subtree, all you need to do is...\\n        if(curr->left == NULL)\\n        {\\n            //...find anomalies and...\\n            findAnomaly(curr);\\n            //traverse the right subtree.\\n            curr = curr->right;\\n        }\\n        //But if there is a left subtree,\\n        else\\n        {\\n            //Create a new pointer on left subtree\\'s root, \\n            TreeNode* findRight = curr->left;\\n\\n            //and go to the extreme right, until you find NULL or \\n            //a thread (link) to curr\\n            while(findRight->right != NULL and findRight->right != curr)\\n            {\\n                findRight = findRight->right;\\n            }\\n\\n            //If the extreme right is a NULL, create a thread to curr, \\n            //because that\\'s where we\\'ll go after this subtree is traversed\\n            if(findRight->right == NULL)\\n            {\\n                //Create the thread (link) to curr\\n                findRight->right = curr;\\n                //Now curr can traverse the left subtree (safely, lol)\\n                curr = curr->left;\\n            }\\n            //If the extreme right was a link to curr, \\n            //the left subtree has already been visited\\n            else \\n            {\\n                //So remove the link to curr \\n                findRight->right = NULL;\\n                //Find anomalies\\n                findAnomaly(curr);\\n                //And start traversing the right subtree\\n                curr = curr->right;\\n            }\\n        }\\n    }        \\n}\\n\\nvoid findAnomaly(TreeNode* root)\\n{\\n    //if this isn\\'t the first node you\\'re checking \\n    //and it\\'s value is less than prevNode, then \\n    //something\\'s fishy!\\n    if(prevNode != NULL and prevNode->val > root->val)\\n    {\\n        //if you haven\\'t found the first anomaly, then this is it!\\n        if(firstNode == NULL)\\n        firstNode = prevNode;\\n        \\n        //the current element may also be the anomaly\\n        secondNode = root;\\n    }\\n\\n    //update prevNode with the current node\\n    prevNode = root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2464305,
                "title": "java-recursion",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode a;\\n    TreeNode b;\\n    TreeNode prev = new TreeNode(Integer.MIN_VALUE);\\n\\n    void inorder(TreeNode root) {\\n        if (root == null)\\n            return;\\n        inorder(root.left);\\n        if (root.val < prev.val && a == null) {\\n            a = prev;\\n            b = root;\\n        } else if (root.val < prev.val && a != null) {\\n            b = root;\\n        }\\n        prev = root;\\n        inorder(root.right);\\n    }\\n\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode a;\\n    TreeNode b;\\n    TreeNode prev = new TreeNode(Integer.MIN_VALUE);\\n\\n    void inorder(TreeNode root) {\\n        if (root == null)\\n            return;\\n        inorder(root.left);\\n        if (root.val < prev.val && a == null) {\\n            a = prev;\\n            b = root;\\n        } else if (root.val < prev.val && a != null) {\\n            b = root;\\n        }\\n        prev = root;\\n        inorder(root.right);\\n    }\\n\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394811,
                "title": "c-o-n-time-o-1-space",
                "content": "* Assume we have been given a sorted array where only 2 elements are swapped and the array then becomes unsorted.\\n\\n* How to find the Two swapped elements ?? \\n\\n* We keep traversing the array and when the previous element becomes greater than next element, we can say there is a violation. **prev > next** and we store the index in some variable.\\n\\n* And When at some point in array , next violation occurs we store that position in some other variable.\\n\\n* In BST this behaviour can be achieved by keeping a `prev` pointer just behind the `root` pointer and checking the **violation condition**.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode *f  = nullptr , *s = nullptr , *prev = nullptr ;\\n    void solve(TreeNode * root){\\n        if(!root) return ;\\n        solve(root->left) ;\\n        if(!prev) prev = root ;\\n        else{\\n            if(prev ->val > root->val){\\n                if(!f) f = prev ;\\n                s = root ;\\n            }\\n        }\\n        prev = root ;\\n        \\n        solve(root->right) ;\\n        \\n    }\\n    void recoverTree(TreeNode* root) {\\n        solve(root) ;\\n        swap(f->val,s->val) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *f  = nullptr , *s = nullptr , *prev = nullptr ;\\n    void solve(TreeNode * root){\\n        if(!root) return ;\\n        solve(root->left) ;\\n        if(!prev) prev = root ;\\n        else{\\n            if(prev ->val > root->val){\\n                if(!f) f = prev ;\\n                s = root ;\\n            }\\n        }\\n        prev = root ;\\n        \\n        solve(root->right) ;\\n        \\n    }\\n    void recoverTree(TreeNode* root) {\\n        solve(root) ;\\n        swap(f->val,s->val) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346135,
                "title": "c-in-order-traversal-solution",
                "content": "1. Do the inorder traversal and store the the value in inorder.\\n2. sort the vector in increasing order, because BST inorder traversal is increasing.\\n3. Traverse the tree in inorder again, but this time change the value of node according to previously sorted array.\\n```c++\\nclass Solution {\\npublic:\\n\\t//This function will do the inorder traversal and store the value in vector v.\\n    void makeTree(TreeNode* root, vector<int>& v){\\n        if(!root) return;\\n        makeTree(root->left, v);\\n        v.push_back(root->val);\\n        makeTree(root->right, v);\\n    }\\n\\t//This function will change the value of old given BST according to sorted data value.\\n    void changeNodeVal(TreeNode* root, vector<int>::iterator& it){\\n        if(!root) return;\\n        changeNodeVal(root->left, it);\\n        root->val = *it; it++;\\n        changeNodeVal(root->right, it);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<int> v;\\n        makeTree(root, v);\\n        sort(v.begin(), v.end());\\n\\t\\t//creating & Passing vector iterator to the function so that we won\\'t lose the track.\\n        vector<int>::iterator it = v.begin();\\n        changeNodeVal(root, it);\\n        return;\\n    }\\n};\\n```\\n\\nIf you have any doubt or optimization, comment below.\\n**Upvote if found useful. plz :)**\\nThanks, have a nice day!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n\\t//This function will do the inorder traversal and store the value in vector v.\\n    void makeTree(TreeNode* root, vector<int>& v){\\n        if(!root) return;\\n        makeTree(root->left, v);\\n        v.push_back(root->val);\\n        makeTree(root->right, v);\\n    }\\n\\t//This function will change the value of old given BST according to sorted data value.\\n    void changeNodeVal(TreeNode* root, vector<int>::iterator& it){\\n        if(!root) return;\\n        changeNodeVal(root->left, it);\\n        root->val = *it; it++;\\n        changeNodeVal(root->right, it);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<int> v;\\n        makeTree(root, v);\\n        sort(v.begin(), v.end());\\n\\t\\t//creating & Passing vector iterator to the function so that we won\\'t lose the track.\\n        vector<int>::iterator it = v.begin();\\n        changeNodeVal(root, it);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345652,
                "title": "java-easy-understandable",
                "content": "```\\nclass Solution {\\n\\tTreeNode first = null;\\n\\tTreeNode second = null;\\n\\tTreeNode prev = null;\\n\\n\\tpublic void recoverTree(TreeNode root) {\\n\\t\\tinOrder(root);\\n\\t\\tif (first != null && second != null) {\\n\\t\\t\\tint temp = first.val;\\n\\t\\t\\tfirst.val = second.val;\\n\\t\\t\\tsecond.val = temp;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic void inOrder(TreeNode root) {\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tinOrder(root.left);\\n\\t\\tif (prev != null && root.val < prev.val) {\\n\\t\\t\\tif (first == null) {\\n\\t\\t\\t\\tfirst = prev;\\n\\t\\t\\t\\tsecond = root;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsecond = root;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprev = root;\\n\\t\\tinOrder(root.right);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tTreeNode first = null;\\n\\tTreeNode second = null;\\n\\tTreeNode prev = null;\\n\\n\\tpublic void recoverTree(TreeNode root) {\\n\\t\\tinOrder(root);\\n\\t\\tif (first != null && second != null) {\\n\\t\\t\\tint temp = first.val;\\n\\t\\t\\tfirst.val = second.val;\\n\\t\\t\\tsecond.val = temp;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic void inOrder(TreeNode root) {\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tinOrder(root.left);\\n\\t\\tif (prev != null && root.val < prev.val) {\\n\\t\\t\\tif (first == null) {\\n\\t\\t\\t\\tfirst = prev;\\n\\t\\t\\t\\tsecond = root;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsecond = root;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprev = root;\\n\\t\\tinOrder(root.right);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312758,
                "title": "java-optimizing-from-o-n-extra-space-to-o-1-excluding-call-stack",
                "content": "The question asks us to swap two values in a BST to make it valid.\\n##### But how do we know which elements are to be swapped?\\nAs we know the inorder traversal of a BST is in ascending order. We need to swap the first greatest element with the last smallest element.\\nFor eg. If we have our inorder traversal as: 5 2 3 4 1, we need to swap 5 and 1 such that 5 > 2 (first greatest element) and 4 > 1 (last smallest element)\\n\\nA very straight-forward approach will be storing the inorder traversal of the invalid BST provided to us in a List and then checking which elements are to be swapped.\\n\\n### Approach: \\n\\n```\\n    public void recoverTree(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        getInorderList(root, list);\\n\\n        int i = 1;\\n        Integer first = null, second = null; \\n\\n        // Getting the first largest element and last smallest element\\n        while (i < list.size()) {\\n            if (first == null && list.get(i - 1) > list.get(i))\\n                first = list.get(i - 1);\\n            if (first != null && list.get(i - 1) > list.get(i))\\n                second = list.get(i);\\n            \\n            i++;\\n        }\\n\\n        swapValues(root, first, second);\\n    }\\n    \\n    public void getInorderList(TreeNode root, List<Integer> list) {\\n        if (root == null)\\n            return;\\n\\n        getInorderList(root.left, list);\\n        list.add(root.val);\\n        getInorderList(root.right, list);\\n    }\\n\\n    // Swapping the values of the two nodes in BST\\n    public void swapValues(TreeNode root, Integer num1, Integer num2) {\\n        if (root == null)\\n            return;\\n\\n        if (root.val == num1) \\n            root.val = num2;\\n        else if (root.val == num2)\\n            root.val = num1;\\n\\n        swapValues(root.left, num1, num2);\\n        swapValues(root.right, num1, num2);\\n    }\\n```\\n\\t\\nThis approach is time consuming and it uses extra O(n) space, to further optimize it, we can directly keep track of first and second nodes to be swapped while inorder traversing.\\n\\n### Optimized Approach:\\n\\n```\\n    // First and second nodes\\'s values are to be swapped\\n    // Prev is used to compare current node to previous node\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    TreeNode prev = new TreeNode(Integer.MIN_VALUE);\\n\\n    public void recoverTree(TreeNode root) {\\n\\t\\tinorder(root);\\n\\n        // Swapping the values\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    public void inorder(TreeNode root) {\\n        if (root == null)\\n            return;\\n\\n        inorder(root.left);\\n\\n        // If first isn\\'t assigned we will make first equals to the greater value (prev)\\n        // If first is assigned we keep updating second to the smaller value (root)\\n        if (first == null && prev.val > root.val)\\n            first = prev;\\n        if (first != null && prev.val > root.val)\\n            second = root;\\n\\n        prev = root;\\n\\n        inorder(root.right);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\n    public void recoverTree(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        getInorderList(root, list);\\n\\n        int i = 1;\\n        Integer first = null, second = null; \\n\\n        // Getting the first largest element and last smallest element\\n        while (i < list.size()) {\\n            if (first == null && list.get(i - 1) > list.get(i))\\n                first = list.get(i - 1);\\n            if (first != null && list.get(i - 1) > list.get(i))\\n                second = list.get(i);\\n            \\n            i++;\\n        }\\n\\n        swapValues(root, first, second);\\n    }\\n    \\n    public void getInorderList(TreeNode root, List<Integer> list) {\\n        if (root == null)\\n            return;\\n\\n        getInorderList(root.left, list);\\n        list.add(root.val);\\n        getInorderList(root.right, list);\\n    }\\n\\n    // Swapping the values of the two nodes in BST\\n    public void swapValues(TreeNode root, Integer num1, Integer num2) {\\n        if (root == null)\\n            return;\\n\\n        if (root.val == num1) \\n            root.val = num2;\\n        else if (root.val == num2)\\n            root.val = num1;\\n\\n        swapValues(root.left, num1, num2);\\n        swapValues(root.right, num1, num2);\\n    }\\n```\n```\\n    // First and second nodes\\'s values are to be swapped\\n    // Prev is used to compare current node to previous node\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    TreeNode prev = new TreeNode(Integer.MIN_VALUE);\\n\\n    public void recoverTree(TreeNode root) {\\n\\t\\tinorder(root);\\n\\n        // Swapping the values\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    public void inorder(TreeNode root) {\\n        if (root == null)\\n            return;\\n\\n        inorder(root.left);\\n\\n        // If first isn\\'t assigned we will make first equals to the greater value (prev)\\n        // If first is assigned we keep updating second to the smaller value (root)\\n        if (first == null && prev.val > root.val)\\n            first = prev;\\n        if (first != null && prev.val > root.val)\\n            second = root;\\n\\n        prev = root;\\n\\n        inorder(root.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086394,
                "title": "c-inorder",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* prev = NULL;\\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    void inorder(TreeNode* root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        if(!first && prev && prev->val >= root->val) first = prev;\\n        if(first && prev->val >= root->val) second = root;\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        int temp = first->val;\\n        first->val = second->val;\\n        second->val = temp;\\n    }\\n};\\n// please upvote if you like\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* prev = NULL;\\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    void inorder(TreeNode* root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        if(!first && prev && prev->val >= root->val) first = prev;\\n        if(first && prev->val >= root->val) second = root;\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        int temp = first->val;\\n        first->val = second->val;\\n        second->val = temp;\\n    }\\n};\\n// please upvote if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989317,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\nclass Solution {\\n    TreeNode prev = null, first = null, second = null;\\n\\n    public void recoverTree(TreeNode root) {\\n        evalSwappedNodes(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\n    private void evalSwappedNodes(TreeNode curr) {\\n        if (curr == null)\\n            return;\\n        evalSwappedNodes(curr.left);\\n        if (prev != null && prev.val > curr.val) {\\n            if (first == null)\\n                first = prev;\\n            second = curr;\\n        }\\n        prev = curr;\\n        evalSwappedNodes(curr.right);\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(firstMistake == nullptr && root->val < pre->val)\\n\\t\\t\\tfirstMistake = pre;\\n\\t\\tif(firstMistake != nullptr && root->val < pre->val)\\n\\t\\t\\tsecondMistake = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```\\n\\n***Python***\\n```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n        in_order = []\\n        def inOrder(node):\\n            if node is None:\\n                return\\n            inOrder(node.left)\\n            in_order.append(node)\\n            inOrder(node.right)\\n        \\n        inOrder(root)\\n\\n        sorted_order = sorted(in_order, key=lambda x:x.val)\\n        for i in range(len(in_order)):\\n            if in_order[i] != sorted_order[i]:\\n                in_order[i].val, sorted_order[i].val = sorted_order[i].val, in_order[i].val\\n                return\\n```\\n\\n***JavaScript***\\n```\\nvar recoverTree = function(root) {\\n    let pre = null, n1 = null, n2 = null\\n    \\n    const dfs = (root) => {\\n        if (!root) return\\n        dfs(root.left)\\n        if (pre && pre.val > root.val) {\\n            n2 = root\\n            if (!n1) n1 = pre\\n        }\\n        pre = root\\n        dfs(root.right)\\n    }\\n    \\n    dfs(root)\\n    swap(n1, n2)\\n};\\n\\nconst swap = (n1, n2) => [n1.val, n2.val] = [n2.val, n1.val]\\n```\\n\\n***Kotlin***\\n```\\n  class Solution {\\n\\n  fun recoverTree(root: TreeNode?): Unit {\\n    var first: TreeNode? = null\\n    var second: TreeNode? = null\\n    var pre: TreeNode = TreeNode(Int.MIN_VALUE)\\n\\n    fun traverse(node: TreeNode?){\\n        if (node == null) return\\n        traverse(node.left)\\n\\n        if (first == null && pre.`val` > node.`val`){\\n            first = pre\\n        }\\n        if (first != null && pre.`val` > node.`val`){\\n            second = node\\n        }\\n        pre = node\\n\\n        traverse(node.right)\\n    }\\n    traverse(root)\\n    val temp = first!!.`val`\\n    first!!.`val` = second!!.`val`\\n    second!!.`val` = temp\\n\\t}\\n\\t}\\n```\\n\\n***Swift***\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(h), where h is the height of the binary tree.\\n\\n    private var first: TreeNode?\\n    private var second: TreeNode?\\n    private var prev = TreeNode(Int.min)\\n\\n    \\n    func recoverTree(_ root: TreeNode?) {\\n        traverse(root)\\n\\n        guard let first = first, let second = second else { return }\\n\\n        let tmp = first.val\\n        first.val = second.val\\n        second.val = tmp\\n    }\\n\\n\\n    private func traverse(_ root: TreeNode?) {\\n        guard let root = root else { return }\\n        traverse(root.left)\\n\\n        if first == nil, prev.val >= root.val { first = prev }\\n        if first != nil, prev.val >= root.val { second = root }\\n        prev = root\\n\\n        traverse(root.right)\\n    }\\n\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***\\n***\"Open your eyes.\"***",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev = null, first = null, second = null;\\n\\n    public void recoverTree(TreeNode root) {\\n        evalSwappedNodes(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\n    private void evalSwappedNodes(TreeNode curr) {\\n        if (curr == null)\\n            return;\\n        evalSwappedNodes(curr.left);\\n        if (prev != null && prev.val > curr.val) {\\n            if (first == null)\\n                first = prev;\\n            second = curr;\\n        }\\n        prev = curr;\\n        evalSwappedNodes(curr.right);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(firstMistake == nullptr && root->val < pre->val)\\n\\t\\t\\tfirstMistake = pre;\\n\\t\\tif(firstMistake != nullptr && root->val < pre->val)\\n\\t\\t\\tsecondMistake = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```\n```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n        in_order = []\\n        def inOrder(node):\\n            if node is None:\\n                return\\n            inOrder(node.left)\\n            in_order.append(node)\\n            inOrder(node.right)\\n        \\n        inOrder(root)\\n\\n        sorted_order = sorted(in_order, key=lambda x:x.val)\\n        for i in range(len(in_order)):\\n            if in_order[i] != sorted_order[i]:\\n                in_order[i].val, sorted_order[i].val = sorted_order[i].val, in_order[i].val\\n                return\\n```\n```\\nvar recoverTree = function(root) {\\n    let pre = null, n1 = null, n2 = null\\n    \\n    const dfs = (root) => {\\n        if (!root) return\\n        dfs(root.left)\\n        if (pre && pre.val > root.val) {\\n            n2 = root\\n            if (!n1) n1 = pre\\n        }\\n        pre = root\\n        dfs(root.right)\\n    }\\n    \\n    dfs(root)\\n    swap(n1, n2)\\n};\\n\\nconst swap = (n1, n2) => [n1.val, n2.val] = [n2.val, n1.val]\\n```\n```\\n  class Solution {\\n\\n  fun recoverTree(root: TreeNode?): Unit {\\n    var first: TreeNode? = null\\n    var second: TreeNode? = null\\n    var pre: TreeNode = TreeNode(Int.MIN_VALUE)\\n\\n    fun traverse(node: TreeNode?){\\n        if (node == null) return\\n        traverse(node.left)\\n\\n        if (first == null && pre.`val` > node.`val`){\\n            first = pre\\n        }\\n        if (first != null && pre.`val` > node.`val`){\\n            second = node\\n        }\\n        pre = node\\n\\n        traverse(node.right)\\n    }\\n    traverse(root)\\n    val temp = first!!.`val`\\n    first!!.`val` = second!!.`val`\\n    second!!.`val` = temp\\n\\t}\\n\\t}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(h), where h is the height of the binary tree.\\n\\n    private var first: TreeNode?\\n    private var second: TreeNode?\\n    private var prev = TreeNode(Int.min)\\n\\n    \\n    func recoverTree(_ root: TreeNode?) {\\n        traverse(root)\\n\\n        guard let first = first, let second = second else { return }\\n\\n        let tmp = first.val\\n        first.val = second.val\\n        second.val = tmp\\n    }\\n\\n\\n    private func traverse(_ root: TreeNode?) {\\n        guard let root = root else { return }\\n        traverse(root.left)\\n\\n        if first == nil, prev.val >= root.val { first = prev }\\n        if first != nil, prev.val >= root.val { second = root }\\n        prev = root\\n\\n        traverse(root.right)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963268,
                "title": "c-o-1-space-solution-w-full-explanations",
                "content": "**Case 1**: When both faulty node are not consecutive then swap( a with c) . Because bigger value must have \\ngone to array starting(a ) and smaller value(c) must have come to array ending side.\\n{ ![image](https://assets.leetcode.com/users/images/e3288207-2d6c-4d1f-ab40-80b282c16ada_1650358332.8541582.png)\\n\\n**Case 2**: When both faulty nodes are consecutive , all you need to do is swap both nodes value.\\n![image](https://assets.leetcode.com/users/images/56bacd50-4531-404a-8ecb-358711053a92_1650358332.8427744.png)\\t\\n\\t\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t//first and second fault in an inorder sorted arrray\\n\\t\\tTreeNode *f=NULL,*s=NULL;\\n\\t\\tTreeNode *prev=new TreeNode(INT_MIN);\\n\\t\\tvoid help(TreeNode *root,TreeNode *parent)\\n\\t\\t{\\n\\t\\t\\tif(root){\\n\\t\\t\\t\\thelp(root->left,root);\\n\\t\\t\\t\\tif(root->val<prev->val){\\n\\t\\t\\t\\t\\tif(f==s)\\n\\t\\t\\t\\t\\t\\tf=prev;\\n\\t\\t\\t\\t\\t\\ts=root;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\ts=root;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev=root;\\n\\t\\t\\t\\thelp(root->right,root);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvoid recoverTree(TreeNode* root) {\\n\\t\\t\\thelp(root,nullptr);\\n\\t\\t\\tswap(f->val,s->val);\\n\\t\\t}\\n\\t};\\n\\t\\nPlease **Upvote** IF It was **helpful** !\\t",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t//first and second fault in an inorder sorted arrray\\n\\t\\tTreeNode *f=NULL,*s=NULL;\\n\\t\\tTreeNode *prev=new TreeNode(INT_MIN);\\n\\t\\tvoid help(TreeNode *root,TreeNode *parent)\\n\\t\\t{\\n\\t\\t\\tif(root){\\n\\t\\t\\t\\thelp(root->left,root);\\n\\t\\t\\t\\tif(root->val<prev->val){\\n\\t\\t\\t\\t\\tif(f==s)\\n\\t\\t\\t\\t\\t\\tf=prev;\\n\\t\\t\\t\\t\\t\\ts=root;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1963094,
                "title": "python-inorder-solution-very-simple",
                "content": "We first get all the contents of a input BST using inorder traversal and store the contents in the list named as \"dfs\".\\n\\nIf you have noticed, then you would know that the inorder traversal of a BST is always sorted. So inorder to recover our original(correct) BST, we need to sort the list dfs.\\nNow we have to change the values of input BST. i.e we have to insert the sorted values into the tree. We do this by using same inorder travesal.\\nAnd all the stuff is done. No fancy alogirthm.Just 2 inorder traversal. \\n\\n(You could also avoid writing the same inorder function twice by passing the two differnt smaller functions for getting and inserting. refer to the first comment. Thanks to Tom.)\\n\\n```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        dfs = []\\n        def inorder(root):\\n            \\n            if not root: return root\\n            inorder(root.left)\\n            dfs.append(root.val)\\n            inorder(root.right)\\n            \\n            \\n        inorder(root)\\n        dfs.sort()\\n        \\n        def inorder2(root):\\n            if not root: return root\\n            inorder2(root.left)\\n            root.val = dfs.pop(0)\\n            inorder2(root.right)\\n        \\n        inorder2(root)\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        dfs = []\\n        def inorder(root):\\n            \\n            if not root: return root\\n            inorder(root.left)\\n            dfs.append(root.val)\\n            inorder(root.right)\\n            \\n            \\n        inorder(root)\\n        dfs.sort()\\n        \\n        def inorder2(root):\\n            if not root: return root\\n            inorder2(root.left)\\n            root.val = dfs.pop(0)\\n            inorder2(root.right)\\n        \\n        inorder2(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1962956,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    vector<TreeNode*>t;\\n    void inorder(TreeNode *root)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        t.push_back(root);\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        TreeNode *first,*mid,*last;\\n        first=mid=last=NULL;\\n        for(int i=0;i<t.size()-1;i++)\\n        {\\n            if(!first && t[i]->val>t[i+1]->val)\\n            {\\n                first=t[i];\\n                mid=t[i+1];\\n            }\\n            else if(t[i]->val>t[i+1]->val)\\n            {\\n                last=t[i+1];\\n            }\\n        }\\n        if(first && last)\\n            swap(first->val,last->val);\\n        else if(first && mid)\\n            swap(first->val,mid->val);\\n    }\\n};",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\npublic:\\n    vector<TreeNode*>t;\\n    void inorder(TreeNode *root)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        t.push_back(root);\\n        inorder(root->right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1962779,
                "title": "o-n-time-o-h-space-c",
                "content": "The idea is simple: When you do inorder traversal, you should going up (increasing) normally. If you notice going down, then something is off. \\nO(H) space is because of the recursion stack.\\n```\\nclass Solution {\\n    TreeNode *n1{nullptr}, *n2{nullptr}, *lastnode{nullptr}; //n1: first anomly, n2: second anomly, lastnode: last visited node\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        swap(n1->val, n2->val);\\n    }\\n    \\n    void inorder(TreeNode* root){\\n        if(not root) return;\\n        inorder(root->left);\\n        if(lastnode and root->val < lastnode->val){\\n            if(n1) {\\n                n2 = root;\\n                return;\\n            }\\n            else //first anomly. Let n2 be current root first, in case it is ajacent swap\\n                n1 = lastnode, n2 = root;\\n        }\\n        lastnode = root;\\n        inorder(root->right);\\n    }\\n};\\n```\\nYou can check [Morris  Traversal](https://leetcode.com/problems/recover-binary-search-tree/discuss/1964374/O(1)-space-oror-O(n)-time-oror-Morris-traversal) for a true O(1) space solution. Although the difference is pretty small for the samples used here, after testing. (I guess tree provided are quite balanced)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode *n1{nullptr}, *n2{nullptr}, *lastnode{nullptr}; //n1: first anomly, n2: second anomly, lastnode: last visited node\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        swap(n1->val, n2->val);\\n    }\\n    \\n    void inorder(TreeNode* root){\\n        if(not root) return;\\n        inorder(root->left);\\n        if(lastnode and root->val < lastnode->val){\\n            if(n1) {\\n                n2 = root;\\n                return;\\n            }\\n            else //first anomly. Let n2 be current root first, in case it is ajacent swap\\n                n1 = lastnode, n2 = root;\\n        }\\n        lastnode = root;\\n        inorder(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962490,
                "title": "simple-and-efficient-java-o-n-solution",
                "content": "The Solution is Based on a observation that,\\n1. Since Inorder traversal gives sorted order, so we start looking from smaller values to larger values and hence we first get bigger part of the swapped integers\\n2. once we get the bigger part that is when x,y,z and x<y and y>z then we are sure that we need to remove y from this position\\n3. Henceforth we start finding a smaller value \\n```\\n\\nclass Solution {\\n    TreeNode big,small,prev;\\n    public void recoverTree(TreeNode root) {\\n        big=null;small=null;prev=null;\\n        rec(root);\\n        if(big!=null && small!=null){\\n            int temp=big.val;\\n            big.val=small.val;\\n            small.val=temp;     \\n        }\\n    }\\n    \\n    private void rec(TreeNode root){\\n        if(root==null) return ;\\n        rec(root.left);\\n        if(big!=null){\\n            if(small==null && root.val>big.val) big=root;\\n            else if(small!=null && root.val<small.val){\\n                small=root;\\n            }else if(small==null && root.val<prev.val){\\n                small=root;\\n            }\\n        }else{\\n            big=root;\\n        }\\n        prev=root;\\n        rec(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    TreeNode big,small,prev;\\n    public void recoverTree(TreeNode root) {\\n        big=null;small=null;prev=null;\\n        rec(root);\\n        if(big!=null && small!=null){\\n            int temp=big.val;\\n            big.val=small.val;\\n            small.val=temp;     \\n        }\\n    }\\n    \\n    private void rec(TreeNode root){\\n        if(root==null) return ;\\n        rec(root.left);\\n        if(big!=null){\\n            if(small==null && root.val>big.val) big=root;\\n            else if(small!=null && root.val<small.val){\\n                small=root;\\n            }else if(small==null && root.val<prev.val){\\n                small=root;\\n            }\\n        }else{\\n            big=root;\\n        }\\n        prev=root;\\n        rec(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962486,
                "title": "python-simple-morris-space-o-1",
                "content": "We can use Morris Traversal which takes space **O(1)**. We will be using inorder variant to go through the BST in increasing order.\\n\\n```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"                \\n        curr, prev, a, b = root, None, None, None        \\n        while curr:\\n            if not curr.left:   \\n\\t\\t\\t\\t# find the node that is violating the ordering \\n                if prev and curr.val < prev.val:\\t\\t\\t\\t\\t\\n                    if not a: # find the first node to swap\\n                        a = prev\\n                    b = curr                   \\n                prev = curr\\n                curr = curr.right                \\n            else:\\n                temp = curr.left\\n                while temp.right and temp.right is not curr:\\n                    temp = temp.right\\n                if temp.right is curr:\\n                    temp.right = None \\n                    if prev and curr.val < prev.val:\\n                        if not a:\\n                            a = prev\\n                        b = curr   \\n                    prev = curr\\n                    curr = curr.right\\n                else:\\n                    temp.right = curr\\n                    curr = curr.left\\n\\n\\t\\t# swap bide values\\n        a.val,b.val = b.val, a.val\\n```\\n\\n**Time = O(N) - Iterate through all nodes\\nSpace = O(1)**\\n\\n---\\n***Please upvote if you find it useful. Also feel free to share your thoughts in comments*.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"                \\n        curr, prev, a, b = root, None, None, None        \\n        while curr:\\n            if not curr.left:   \\n\\t\\t\\t\\t# find the node that is violating the ordering \\n                if prev and curr.val < prev.val:\\t\\t\\t\\t\\t\\n                    if not a: # find the first node to swap\\n                        a = prev\\n                    b = curr                   \\n                prev = curr\\n                curr = curr.right                \\n            else:\\n                temp = curr.left\\n                while temp.right and temp.right is not curr:\\n                    temp = temp.right\\n                if temp.right is curr:\\n                    temp.right = None \\n                    if prev and curr.val < prev.val:\\n                        if not a:\\n                            a = prev\\n                        b = curr   \\n                    prev = curr\\n                    curr = curr.right\\n                else:\\n                    temp.right = curr\\n                    curr = curr.left\\n\\n\\t\\t# swap bide values\\n        a.val,b.val = b.val, a.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962414,
                "title": "c-fast-easy-inordertraversal-explained",
                "content": "In the question, we do inorder traversal and find out the wrong placed numbers and there are two cases for that:\\n(i) both nodes are adjacent and hence there wont be third number wrong placed.\\n(ii)otherwise, if a number is misplaced, it\\'s next element will also seem to be mispalced as we\\'re checking with parent node. hence we store both parent and root as first and middle.\\n\\nWe\\'ll swap first and last if both nodes are separated or will swap first and middle if both nodes are adjacent.\\n#HareKrishna!\\n\\n```\\nclass Solution {\\n    #define Node TreeNode\\n    Node*prev;\\n    Node*first;\\n    Node*middle;\\n    Node*last;\\n    void solve(Node*root)\\n    {\\n        if(root==NULL)\\n            return;\\n        solve(root->left);\\n        if(root->val<prev->val)\\n        {\\n            if(first==NULL)\\n            {\\n                first=prev;\\n                middle=root;\\n            }\\n            else\\n            {\\n                last=root;\\n            }\\n        }\\n        prev=root;\\n        solve(root->right);\\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        first=middle=last=NULL;\\n        prev=new Node(INT_MIN); //keeps track of parent node\\n        solve(root);\\n        if(first&&last)\\n        {\\n            swap(first->val,last->val);\\n        }\\n        else\\n            swap(first->val,middle->val);\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    #define Node TreeNode\\n    Node*prev;\\n    Node*first;\\n    Node*middle;\\n    Node*last;\\n    void solve(Node*root)\\n    {\\n        if(root==NULL)\\n            return;\\n        solve(root->left);\\n        if(root->val<prev->val)\\n        {\\n            if(first==NULL)\\n            {\\n                first=prev;\\n                middle=root;\\n            }\\n            else\\n            {\\n                last=root;\\n            }\\n        }\\n        prev=root;\\n        solve(root->right);\\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        first=middle=last=NULL;\\n        prev=new Node(INT_MIN); //keeps track of parent node\\n        solve(root);\\n        if(first&&last)\\n        {\\n            swap(first->val,last->val);\\n        }\\n        else\\n            swap(first->val,middle->val);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734486,
                "title": "using-inorder-traversal-and-then-sorting-elements",
                "content": "If we do traversal(here inorder) in the tree and store the values in an arraylist and sort the arraylist, we can get the right tree after inserting the sorted values in the tree again by inorder traversal.\\n```\\n//Doing inorderTraversal in the tree and then storing it in an arraylist and then sorting the list and again inserting the sorted values in the tree by doing inorder traversal.\\nclass Solution {\\n    ArrayList<Integer> list=new ArrayList<>();\\n    int count=0;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        Collections.sort(list); // Sorting the list \\n        insertinorder(root);\\n        \\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val); // Adding to the list\\n        inorder(root.right);\\n    }\\n\\tpublic void insertinorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        insertinorder(root.left);\\n        root.val=list.get(count); // Changing the value of the node as per the sorted list\\n        count++;\\n        insertinorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Doing inorderTraversal in the tree and then storing it in an arraylist and then sorting the list and again inserting the sorted values in the tree by doing inorder traversal.\\nclass Solution {\\n    ArrayList<Integer> list=new ArrayList<>();\\n    int count=0;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        Collections.sort(list); // Sorting the list \\n        insertinorder(root);\\n        \\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val); // Adding to the list\\n        inorder(root.right);\\n    }\\n\\tpublic void insertinorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        insertinorder(root.left);\\n        root.val=list.get(count); // Changing the value of the node as per the sorted list\\n        count++;\\n        insertinorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680987,
                "title": "c-in-order-traversal-only-3-extra-treenode",
                "content": "````\\nclass Solution {\\npublic:\\n    TreeNode* prev;\\n    TreeNode* x;\\n    TreeNode* y;\\n    void bfs(TreeNode* root){\\n        if(!root) return;\\n        bfs(root->left); // for in-order traversal: 1) left, 2) visit, 3) right\\n        \\n        if(prev && prev->val > root->val){\\n            if(!x){ // it is the first time we meet an unsorted value\\n                x = prev;\\n                y = root;\\n            } \\n            else if(x){ // if there is a second time it means we have to update the node\\n                y = root; \\n                return; // there are no more unsorted nodes, so we can exit\\n            } \\n        }\\n        prev = root;\\n        \\n        bfs(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        bfs(root); // by in-order traversal we go through the tree in a sorted order\\n        swap(x->val,y->val); // swap the values which make the tree unsorted\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* prev;\\n    TreeNode* x;\\n    TreeNode* y;\\n    void bfs(TreeNode* root){\\n        if(!root) return;\\n        bfs(root->left); // for in-order traversal: 1) left, 2) visit, 3) right\\n        \\n        if(prev && prev->val > root->val){\\n            if(!x){ // it is the first time we meet an unsorted value\\n                x = prev;\\n                y = root;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1529163,
                "title": "c-solution",
                "content": "```\\n    \\n    private TreeNode firstNode = null;\\n    private TreeNode secondNode = null;\\n    private TreeNode prev = new TreeNode(Int32.MinValue);\\n    \\n    public void RecoverTree(TreeNode root) {\\n        \\n        if(root == null)\\n            return;\\n        \\n        dfs(root);        \\n        int tmp = firstNode.val;\\n        firstNode.val = secondNode.val;\\n        secondNode.val = tmp;\\n    }\\n    \\n    private void dfs(TreeNode root)\\n    {\\n        if(root == null)\\n            return;\\n        \\n        dfs(root.left);\\n        \\n        if(firstNode == null && root.val < prev.val)\\n            firstNode = prev;\\n        \\n        if(firstNode != null && root.val < prev.val)\\n            secondNode = root;\\n        \\n        prev = root;\\n        \\n        dfs(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    \\n    private TreeNode firstNode = null;\\n    private TreeNode secondNode = null;\\n    private TreeNode prev = new TreeNode(Int32.MinValue);\\n    \\n    public void RecoverTree(TreeNode root) {\\n        \\n        if(root == null)\\n            return;\\n        \\n        dfs(root);        \\n        int tmp = firstNode.val;\\n        firstNode.val = secondNode.val;\\n        secondNode.val = tmp;\\n    }\\n    \\n    private void dfs(TreeNode root)\\n    {\\n        if(root == null)\\n            return;\\n        \\n        dfs(root.left);\\n        \\n        if(firstNode == null && root.val < prev.val)\\n            firstNode = prev;\\n        \\n        if(firstNode != null && root.val < prev.val)\\n            secondNode = root;\\n        \\n        prev = root;\\n        \\n        dfs(root.right);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1507268,
                "title": "c-easy-to-understand-2-methods-o-1-space",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Time complexity O(N)\\nspace complexity O(N)**\\n```\\nclass Solution {\\npublic:\\n    TreeNode *first=NULL,*second=NULL;\\n    TreeNode* prev=new TreeNode(INT_MIN);\\n    void inorder(TreeNode* root,vector<int> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,v);\\n        if(first==NULL&&prev->val>root->val)\\n        first=prev;\\n        if(first!=NULL&&prev->val>root->val)\\n        second=root;\\n        prev=root;\\n        inorder(root->right,v);\\n    }    \\n    void recoverTree(TreeNode* root) {\\n        vector<int> v;\\n        inorder(root,v);\\n        int temp=second->val;\\n        second->val=first->val;\\n        first->val=temp;\\n    }\\n};\\n```\\n**Time complexity O(N)\\nSpace complexity O(1)**\\n```\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *first=NULL,*second=NULL;\\n    TreeNode* prev=new TreeNode(INT_MIN);\\n    void inorder(TreeNode* root,vector<int> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,v);\\n        if(first==NULL&&prev->val>root->val)\\n        first=prev;\\n        if(first!=NULL&&prev->val>root->val)\\n        second=root;\\n        prev=root;\\n        inorder(root->right,v);\\n    }    \\n    void recoverTree(TreeNode* root) {\\n        vector<int> v;\\n        inorder(root,v);\\n        int temp=second->val;\\n        second->val=first->val;\\n        first->val=temp;\\n    }\\n};\\n```\n```\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466747,
                "title": "c-super-simple-and-clean",
                "content": "///2 Nodes of a BST are swapped by mistake. Recover the BST by reverse swapping those swapped nodes.\\n    /// Solution: Since BST Inorder traversal gives elements in increasing order, we can traverse bst in inorder and look \\n    /// for nodes which violates the increasing order.\\n    /// We just have to find and swap the violating keys\\n    /// \\n    /// There can be 2 cases.\\n    /// Case 1: When adjucent nodes are swapped  i.e. eg: 1,2,4,3,5,6\\n    ///  In this case we get only one violation (3) and that and it\\'s previous (4) needed to be swapped.\\n    ///  i.e. swap 4 and 3 and we get 1,2,3,4,5,6\\n    ///  \\n    /// Case 2: When non adjucent nodes are swapped i.e. eg: 1,6,3,4,5,2  {6 and 2 are swapped}\\n    /// Then first violation\\'s = 3\\n    /// 2nd violation = 2\\n    /// Swap previous of first violation with 2nd violation\\n    /// and we get 1,2,3,4,5,6\\n```\\n\\npublic class Solution {\\n    public void RecoverTree(TreeNode root) {\\n            TreeNode First = null;\\n            TreeNode Second = null;\\n            TreeNode Prev = null;\\n            InOrder(root,ref First,ref Second,ref Prev);\\n        \\n            var a = First.val;\\n            First.val = Second.val;\\n            Second.val = a;\\n    }\\n    public static void InOrder(TreeNode root, ref TreeNode First, ref TreeNode Second, ref TreeNode Prev)\\n        {\\n            if (root == null) return;\\n            InOrder(root.left,ref First, ref Second, ref Prev);\\n            if (Prev != null && root.val <Prev.val )\\n            {\\n                if (First == null) First = Prev;\\n                Second = root;\\n            }\\n\\n            Prev = root;\\n            InOrder(root.right, ref First, ref Second, ref Prev);\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public void RecoverTree(TreeNode root) {\\n            TreeNode First = null;\\n            TreeNode Second = null;\\n            TreeNode Prev = null;\\n            InOrder(root,ref First,ref Second,ref Prev);\\n        \\n            var a = First.val;\\n            First.val = Second.val;\\n            Second.val = a;\\n    }\\n    public static void InOrder(TreeNode root, ref TreeNode First, ref TreeNode Second, ref TreeNode Prev)\\n        {\\n            if (root == null) return;\\n            InOrder(root.left,ref First, ref Second, ref Prev);\\n            if (Prev != null && root.val <Prev.val )\\n            {\\n                if (First == null) First = Prev;\\n                Second = root;\\n            }\\n\\n            Prev = root;\\n            InOrder(root.right, ref First, ref Second, ref Prev);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413793,
                "title": "nice-explanation-inorder-traversal-c-implementation-time-o-n",
                "content": "the key to solve this problem is : The **inorder traversal** of a BST produces a sorted array\\n\\n1.  a simple method is to store inorder traversal of the input tree in an auxiliary array. Sort the auxiliary       array. Finally, insert the auxiliary array elements back to the BST, keeping the structure of the BST         same. The time complexity of this method is O(nLogn) and the auxiliary space needed is O(n).w can     also make here some optimization by using insertion sort(for minimum complexity).\\n\\n2.  We can solve this in O(n) time and with a single traversal of the given BST. Since inorder traversal        of BST is always a sorted array, the problem can be reduced to a problem where two elements of a      sorted array are swapped. \\n\\n     Example : For example, Nodes 2 and 3 are swapped in [1,2,3]. \\n                      The inorder traversal of the given tree is [3,2,1] \\n\\tIf we observe carefully, during inorder traversal, we find node 2 is smaller than the previous visited      node 3. Here save the context of node 3 (previous node). Again, we find that node 1 is smaller      than the previous node 2. This time, we save the context of node 1 (the current node ). Finally, swap the two node\\u2019s values.\\n\\t\\n\\tExample, Nodes 2 and 3 are swapped in [1,2,3,4]. \\n  The inorder traversal of the given tree is [1,3,2,4]\\n  unlike previous example ,here only one point exists where a node value is smaller than the previous    node value.\\n  \\n    so, here we can note that when two elements of a sorted array are swapped. \\n   There are two cases that we need to handle:\\n   Firts : The swapped nodes are not adjacent in the inorder traversal of the BST. \\n   Second :  The swapped nodes are adjacent in the inorder traversal of BST.\\n   \\n    we can handle two cases by using FirstNode , SecondNode , PreviousNode For every node (except     the leftmost node of the tree), keep track of its previous node in prev. The current node being processed is stored in the curr.\\nIf during the traversal, we find a node that violates the BST order  previousNode->val > CurrentNode->val .we store PreviousNode into fFirst and CurrentNode into Second.\\nDuring further traversal, if we find another node that violates the BST criteria , previousNode->val > CurrentNode->val. but since, the First node had been already assigned a value. so we assign the current node(which violates BST criteria) to Second.\\nAfter execution of inorder traversal. swap the data of First and Second nodes and The tree gets fixed.\\n\\n\\n```\\n    void RecoverBinarySearchTree(TreeNode* CurrentNode ,TreeNode* &PreviousNode ,TreeNode* &First, TreeNode* &Second) {\\n        if(CurrentNode == NULL) return;\\n        RecoverBinarySearchTree(CurrentNode->left,PreviousNode,First,Second);\\n        if(PreviousNode != NULL && PreviousNode->val > CurrentNode->val) {\\n            if(First == NULL){\\n                First = PreviousNode;\\n                Second = CurrentNode;\\n            }else Second = CurrentNode;\\n        }\\n        PreviousNode = CurrentNode;\\n        RecoverBinarySearchTree(CurrentNode->right,PreviousNode,First,Second);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        TreeNode* First = NULL; TreeNode* Second = NULL; TreeNode* PreviousNode = NULL;\\n        RecoverBinarySearchTree(root,PreviousNode,First,Second);\\n        int temp = First->val;\\n        First->val = Second->val;\\n        Second->val = temp;\\n    }\\n```\\nTime Complexity : O(n)\\nSpace Complexity : O(1), nor data structure neither recursion stack space used.\\n\\nnote : in above code we pass First,Second and PreviousNode to function by refrence\\n          and it\\'s important! \\n\\t\\t  if we take a simple tset case : \\n\\t\\t  ![image](https://assets.leetcode.com/users/images/2b7f8775-5d5d-4d77-a017-03d57b0fb24c_1629391275.4167056.png)\\n1. here we pass to function :  node(1) and First = NULL , Second = NULL  and Previous = NULL\\n2. we will go to left : node(3) and  First = NULL , Second = NULL  and Previous = NULL\\n    and we go to left we will find NULL node so we will return and  update PreviousNode = node(3) \\n3. we will go to right : node(2) left is NULL and we will find previous is not NULL and previous is greater     than current node so it\\'s ok we will update First = PreviousNode , Second = CurrentNode\\n\\tand update PerviousNode : node(2) and it\\'s so important to keep track it with others node\\n\\tand will find right is NULL and i will return to : node : (3) , First :node(3) , Second : node(1) and     PreviousNode : node(2) and this why i call it by refrence to save it\\'s value when i return !\\n\\t\\ni hope you find this is helpful !\\n\\t\\t  \\n\\t\\t  \\n\\t\\t \\n\\t\\t  \\n\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\n    void RecoverBinarySearchTree(TreeNode* CurrentNode ,TreeNode* &PreviousNode ,TreeNode* &First, TreeNode* &Second) {\\n        if(CurrentNode == NULL) return;\\n        RecoverBinarySearchTree(CurrentNode->left,PreviousNode,First,Second);\\n        if(PreviousNode != NULL && PreviousNode->val > CurrentNode->val) {\\n            if(First == NULL){\\n                First = PreviousNode;\\n                Second = CurrentNode;\\n            }else Second = CurrentNode;\\n        }\\n        PreviousNode = CurrentNode;\\n        RecoverBinarySearchTree(CurrentNode->right,PreviousNode,First,Second);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        TreeNode* First = NULL; TreeNode* Second = NULL; TreeNode* PreviousNode = NULL;\\n        RecoverBinarySearchTree(root,PreviousNode,First,Second);\\n        int temp = First->val;\\n        First->val = Second->val;\\n        Second->val = temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1384474,
                "title": "c-o-1-space-well-commented",
                "content": "```\\nclass Solution {\\n    public:\\n    vector<pair<TreeNode*,TreeNode*>> vec; // To store pairs that violates BST  \\n    TreeNode* prev = NULL; // keep track of previous node\\n    \\n    void solve(TreeNode* root)\\n    {\\n        if(root == NULL)  return; // Base Condition\\n        \\n        solve(root->left); // First left\\n        // Than deal with Val \\n        \\n        /* if statement says : if previous node exists and previous node has a value more than next or any root that comes to the \\n\\t\\tright of prev than\\tin such case it violates BST condition so push that pair in vec for now, will deal withit later */\\n        if(prev && prev->val > root->val) vec.push_back({prev,root}); \\n        \\n        prev = root; // keep updating prev, for checking BST condition further\\n        solve(root->right); // At last right, this is inorder manner\\n    }\\n    \\n    void recoverTree(TreeNode* root) \\n    {    \\n        solve(root); // Inorder traversal\\n        \\n        /* If just 2 adjacent nodes violated BST , than there will be 1 key value pair in           \\n\\t\\tvec and we will swap it and problem is solved */\\n        if(vec.size() == 1) \\n            swap(vec[0].first->val, vec[0].second->val);\\n        \\n        /* We know its given in question that only 2 nodes of the tree were swapped, but what if those 2 nodes are not adjacent, in that case \\n\\t\\twe have 2 key value pairs which shows there is irregularity in 4 elements. (so size of vec is 2). eg: 1 2 3 4 , we change it to : 4 2 3 1 \\n\\t\\twhich leads to inconsistency in {4,2} and {3,1} so to solve it we swap first of 0th and second of 1th which are 4 and 1 respectively, \\n\\t\\twe can get 1 2 3 4 back, same is done below : */\\n        if(vec.size() == 2)\\n            swap(vec[0].first->val, vec[1].second->val);\\n    }\\n};\\n\\n// Time : O(N)\\n// Space : O(1)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    vector<pair<TreeNode*,TreeNode*>> vec; // To store pairs that violates BST  \\n    TreeNode* prev = NULL; // keep track of previous node\\n    \\n    void solve(TreeNode* root)\\n    {\\n        if(root == NULL)  return; // Base Condition\\n        \\n        solve(root->left); // First left\\n        // Than deal with Val \\n        \\n        /* if statement says : if previous node exists and previous node has a value more than next or any root that comes to the \\n\\t\\tright of prev than\\tin such case it violates BST condition so push that pair in vec for now, will deal withit later */\\n        if(prev && prev->val > root->val) vec.push_back({prev,root}); \\n        \\n        prev = root; // keep updating prev, for checking BST condition further\\n        solve(root->right); // At last right, this is inorder manner\\n    }\\n    \\n    void recoverTree(TreeNode* root) \\n    {    \\n        solve(root); // Inorder traversal\\n        \\n        /* If just 2 adjacent nodes violated BST , than there will be 1 key value pair in           \\n\\t\\tvec and we will swap it and problem is solved */\\n        if(vec.size() == 1) \\n            swap(vec[0].first->val, vec[0].second->val);\\n        \\n        /* We know its given in question that only 2 nodes of the tree were swapped, but what if those 2 nodes are not adjacent, in that case \\n\\t\\twe have 2 key value pairs which shows there is irregularity in 4 elements. (so size of vec is 2). eg: 1 2 3 4 , we change it to : 4 2 3 1 \\n\\t\\twhich leads to inconsistency in {4,2} and {3,1} so to solve it we swap first of 0th and second of 1th which are 4 and 1 respectively, \\n\\t\\twe can get 1 2 3 4 back, same is done below : */\\n        if(vec.size() == 2)\\n            swap(vec[0].first->val, vec[1].second->val);\\n    }\\n};\\n\\n// Time : O(N)\\n// Space : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379643,
                "title": "java-o-1-space-simple-in-order-traversal-with-detailed-explanation",
                "content": "```\\nclass Solution {\\n    \\n    // It is true that if we swap any 2 nodes in a BST, both of those nodes\\n    // will break the rules of a BST. They are lawbreakers! (naughty). We need\\n    // to keep track of both of them. Left is the leftmost lawbreaker and right is \\n    // the rightmost lawbreaker aaccording to the BST\\'s in-order sequence.\\n    private TreeNode lawbreakerLeft, lawbreakerRight;\\n    \\n    // To check whether a node is a lawbreaker we need to see whether the current node\\n    // of an in-order traversal is not... well... in-order. If this was a BST of ascending\\n    // order, the highest value would be the current node and the second highest would be\\n    // the previous that we visited - unless we have a lawbreaker on our hands.\\n    private TreeNode secondHighestValue, highestValue;\\n    \\n    public void recoverTree(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        // Start performing the in-order traversal recursively.\\n        traverse(root);\\n        \\n        // Swap the values of the two lawbreakers so they are abiding the law once more.\\n        int temp = lawbreakerLeft.val;\\n        lawbreakerLeft.val = lawbreakerRight.val;\\n        lawbreakerRight.val = temp;\\n    }\\n    \\n    public void traverse(TreeNode curr) {\\n        if (curr == null) {\\n            return;\\n        }\\n        \\n        // As per in-order traversal rules, we will go left as much as possible, then visit the\\n        // current node, then go right. The rest of this method does just that.\\n        traverse(curr.left);\\n        \\n        // The special part comes with the \"visiting\" of the current node. The first thing we do\\n        // is make note of the current value. Since this is in-order traversal of a BST, the current value\\n        // must be the largest value, and the previously visited value must be the the second largest.\\n        secondHighestValue = highestValue;\\n        highestValue = curr;\\n        \\n        // If for some reason the previous value is greater than the current value... We have found a lawbreaker.\\n        //\\n        // The null check here is just for the case that we\\'re at the leftmost node, in which we can\\'t have set the previous\\n        // value just yet.\\n        if (secondHighestValue != null && secondHighestValue.val > highestValue.val) {\\n            \\n            // If we have not yet found our first lawbreaker, we must set it, while remembering to swap the\\n            // secondHighest and highest value around so that the ordering is correct. Otherwise we can be in a position\\n            // in the next recursion where the highest is not in fact the actual highest. We also set the right in the case that\\n            // by chance the two nodes that were swapped are right next to each other (otherwise it will be skipped).\\n            if (lawbreakerLeft == null) {\\n                lawbreakerLeft = secondHighestValue;\\n                lawbreakerRight = highestValue;\\n                \\n                highestValue = lawbreakerLeft;\\n            } else {\\n                // If the left lawbreaker has been found then we have found a right lawbreaker. You may notice if this has\\n                // already been set then we overwrite it - this is because we always set the right when we find the left most one\\n                // for that one-off case in the previous comment, but if it is not the case the right most lawbreaker node will\\n                // exist somewhere else in the tree.\\n                lawbreakerRight = highestValue;\\n            }\\n        }\\n        \\n        // Finally go and visit the right node!\\n        traverse(curr.right);\\n    }\\n}\\n```\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // It is true that if we swap any 2 nodes in a BST, both of those nodes\\n    // will break the rules of a BST. They are lawbreakers! (naughty). We need\\n    // to keep track of both of them. Left is the leftmost lawbreaker and right is \\n    // the rightmost lawbreaker aaccording to the BST\\'s in-order sequence.\\n    private TreeNode lawbreakerLeft, lawbreakerRight;\\n    \\n    // To check whether a node is a lawbreaker we need to see whether the current node\\n    // of an in-order traversal is not... well... in-order. If this was a BST of ascending\\n    // order, the highest value would be the current node and the second highest would be\\n    // the previous that we visited - unless we have a lawbreaker on our hands.\\n    private TreeNode secondHighestValue, highestValue;\\n    \\n    public void recoverTree(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        // Start performing the in-order traversal recursively.\\n        traverse(root);\\n        \\n        // Swap the values of the two lawbreakers so they are abiding the law once more.\\n        int temp = lawbreakerLeft.val;\\n        lawbreakerLeft.val = lawbreakerRight.val;\\n        lawbreakerRight.val = temp;\\n    }\\n    \\n    public void traverse(TreeNode curr) {\\n        if (curr == null) {\\n            return;\\n        }\\n        \\n        // As per in-order traversal rules, we will go left as much as possible, then visit the\\n        // current node, then go right. The rest of this method does just that.\\n        traverse(curr.left);\\n        \\n        // The special part comes with the \"visiting\" of the current node. The first thing we do\\n        // is make note of the current value. Since this is in-order traversal of a BST, the current value\\n        // must be the largest value, and the previously visited value must be the the second largest.\\n        secondHighestValue = highestValue;\\n        highestValue = curr;\\n        \\n        // If for some reason the previous value is greater than the current value... We have found a lawbreaker.\\n        //\\n        // The null check here is just for the case that we\\'re at the leftmost node, in which we can\\'t have set the previous\\n        // value just yet.\\n        if (secondHighestValue != null && secondHighestValue.val > highestValue.val) {\\n            \\n            // If we have not yet found our first lawbreaker, we must set it, while remembering to swap the\\n            // secondHighest and highest value around so that the ordering is correct. Otherwise we can be in a position\\n            // in the next recursion where the highest is not in fact the actual highest. We also set the right in the case that\\n            // by chance the two nodes that were swapped are right next to each other (otherwise it will be skipped).\\n            if (lawbreakerLeft == null) {\\n                lawbreakerLeft = secondHighestValue;\\n                lawbreakerRight = highestValue;\\n                \\n                highestValue = lawbreakerLeft;\\n            } else {\\n                // If the left lawbreaker has been found then we have found a right lawbreaker. You may notice if this has\\n                // already been set then we overwrite it - this is because we always set the right when we find the left most one\\n                // for that one-off case in the previous comment, but if it is not the case the right most lawbreaker node will\\n                // exist somewhere else in the tree.\\n                lawbreakerRight = highestValue;\\n            }\\n        }\\n        \\n        // Finally go and visit the right node!\\n        traverse(curr.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370723,
                "title": "99-faster",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n\\n**Explanation :-** 1. There can be two cases where nodes are need to be swapped in the inorder traversal i.e. either they are adjacant to each other or are far from each other. \\n\\n**(a)** For example, Nodes 5 and 25 are swapped in {3 5 7 8 10 15 20 25}. \\n The inorder traversal of the given tree is 3 **25** 7 8 10 15 20 **5**\\nIf we observe carefully, during inorder traversal, we find node 7 is smaller than the previous visited node 25. Here save the context of node 25 (previous node). Again, we find that node 5 is smaller than the previous node 20. This time, we save the context of node 5 ( current node ). Finally swap the two node\\u2019s values.\\n\\n**(b)** The swapped nodes are adjacent in the inorder traversal of BST.\\n\\n  For example, Nodes 7 and 8 are swapped in {3 5 7 8 10 15 20 25}. \\n  The inorder traversal of the given tree is 3 5 **8** **7** 10 15 20 25 \\nUnlike case #1, here only one point exists where a node value is smaller than previous node value. e.g. node 7 is smaller than node 8.\\n\\n**How to Solve?** \\n**In case #1**\\nWe will maintain three pointers, first, prev and second. When we find the first point where current node value is smaller than previous node value, we update the first with the previous node. When we find the second point where current node value is smaller than previous node value, we update the second with the current node. Second will be updated when nodes are not adjacent.\\n**In case #2**\\nWe will find the first and second point only once when two swapped nodes of BST are adjacent.\\n```\\nclass Solution {\\npublic:\\n      void inorder(TreeNode *root , TreeNode *&first , TreeNode *&second , TreeNode *&prev)\\n      {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        inorder(root -> left , first , second , prev);\\n        if(prev != NULL && prev -> val > root -> val)\\n        {\\n            if(first == NULL)\\n            {\\n                first = prev;\\n            }\\n            second = root;\\n        }\\n        prev = root;\\n        inorder(root -> right , first , second , prev);\\n     }\\n    \\n    void recoverTree(TreeNode* root)\\n    {\\n       TreeNode *first , *second , *prev;\\n       first = second = prev = NULL;\\n       inorder(root , first , second , prev);\\n       swap(first -> val , second -> val);\\n    } \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n      void inorder(TreeNode *root , TreeNode *&first , TreeNode *&second , TreeNode *&prev)\\n      {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        inorder(root -> left , first , second , prev);\\n        if(prev != NULL && prev -> val > root -> val)\\n        {\\n            if(first == NULL)\\n            {\\n                first = prev;\\n            }\\n            second = root;\\n        }\\n        prev = root;\\n        inorder(root -> right , first , second , prev);\\n     }\\n    \\n    void recoverTree(TreeNode* root)\\n    {\\n       TreeNode *first , *second , *prev;\\n       first = second = prev = NULL;\\n       inorder(root , first , second , prev);\\n       swap(first -> val , second -> val);\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347121,
                "title": "java-easy-recursive-solution-inorder",
                "content": "```\\nclass Solution {\\n    TreeNode prev=null,first=null,second=null;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left);\\n        if(prev!=null && root.val<prev.val){\\n            if(first==null){\\n                first=prev;\\n            }\\n              second=root; \\n        }\\n        prev=root;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev=null,first=null,second=null;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left);\\n        if(prev!=null && root.val<prev.val){\\n            if(first==null){\\n                first=prev;\\n            }\\n              second=root; \\n        }\\n        prev=root;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314888,
                "title": "deal-with-duplicate-values-swap-nodes-instead-of-just-values-w-python-implementation",
                "content": "Submitting a solution that passes all test cases of this problem is simple. However, there are two points of this problem setting that really do NOT make sense. Neither does the official solution article take them into account:\\n1. According to the official solution article and all test cases used in this problem, we know that it\\'s assumed that there are no duplicate values in a tree, which is however never stated in the problem description.\\nIn general, the definition of BST includes \"equal\" situation, namely: the value in each node is **greater than or equal to** (less than or equal to) any values stored in its left (right) subtree. So a BST does not necessarily have unique value for each node. \\nSo the question would be be: \"how to handle duplicate cases?\" which is raised already by many other guys in the Discussion part (see: https://leetcode.com/problems/recover-binary-search-tree/discuss/32673/Does-the-BST-in-this-problem-include-duplicate-nodes, https://leetcode.com/problems/recover-binary-search-tree/discuss/32656/How-to-handle-the-case-when-there-are-duplicate-values-in-the-BST, and [etc](https://leetcode.com/problems/recover-binary-search-tree/discuss?currentPage=1&orderBy=most_relevant&query=duplicate).)\\n\\n2. It is assumed in this problem that it is the **values**(i.e., key of the node) of two nodes that got swapped. In a more reasonable setting, the two **TreeNodes** are swapped other than the mere values. (For example, in real application, a tree node might carry some satellite data.) In such scenarios,  we want a solution that swap nodes instead of just their (key) values.\\n\\n**To address the above concerns:**\\n\\n\\nThis is a more general solution that is able to handle duplicate values (only 1 pass)\\n```\\n# This solution uses stack. You can also do the similar thing with recursion or Morris traversal\\n# This solution is able to deal with duplicate values; therefore it\\'s a more general solution\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(H) where H is the height of the tree. In the worst case it can deteriorate to O(N)\\nclass Solution:\\n    def recoverTree(self, root: TreeNode):\\n        \"\"\"\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        x = y = pred = None\\n        \\n        while stack or root:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            \\n            ### this is what we do to each traversed node ###\\n            if pred:\\n                if x is None:\\n                    if root.val < pred.val:\\n                        x = pred \\n                        y = root\\n                else:\\n                    if root.val <= y.val:\\n                        y = root\\n                    if root.val > x.val:\\n                        break\\n            if pred is None or root.val != pred.val:\\n                pred = root\\n            ### this is what we do to each traversed node ###\\n                \\n            root = root.right\\n        x.val, y.val = y.val, x.val\\n```\\n\\n\\nIf you also want to consider swapping nodes instead of values, here is what you need:\\n```\\n# This solution:\\n#    1. is able to deal with duplicate values\\n#    2. swaps nodes instead of values\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(H) where H is the height of the tree. In the worst case it can deteriorate to O(N)\\nclass Solution:\\n    def recoverTree(self, root: TreeNode):\\n        \"\"\"\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        x = y = pred = None\\n        parent = None\\n        while stack or root:\\n            while root:\\n                stack.append((root, parent))\\n                root, parent = root.left, root\\n            root, parent = stack.pop()\\n            \\n            ### this is what we do to each traversed node ###\\n            if pred:\\n                if x is None:\\n                    if root.val < pred.val:\\n                        x, x_parent = pred, pred_parent\\n                        y, y_parent = root, parent\\n                else:\\n                    if root.val <= y.val:\\n                        y, y_parent = root, parent\\n                    if root.val > x.val:\\n                        break\\n            if pred is None or root.val != pred.val:\\n                pred, pred_parent = root, parent\\n            ### this is what we do to each traversed node ###\\n                \\n            root, parent = root.right, root\\n        swap_nodes(x, y, x_parent, y_parent)\\n    \\ndef swap_nodes(x: TreeNode, y: TreeNode, x_parent: TreeNode, y_parent: TreeNode):\\n    if x_parent is y:\\n        if y_parent:\\n            if y_parent.left is y:\\n                y_parent.left = x\\n            else:\\n                y_parent.right = x\\n        if y.left is x:\\n            x.left, x.right, y.left, y.right = y, y.right, x.left, x.right\\n        else:\\n            x.left, x.right, y.left, y.right = y.left, y, x.left, x.right\\n\\n    elif y_parent is x:\\n        if x_parent:\\n            if x_parent.left is x:\\n                x_parent.left = y\\n            else:\\n                x_parent.right = y\\n        if x.left is y:\\n            x.left, x.right, y.left, y.right = y.left, y.right, x, x.right\\n        else:\\n            x.left, x.right, y.left, y.right = y.left, y.right, x.left, x\\n\\n    else:    \\n        x.left, x.right, y.left, y.right = y.left, y.right, x.left, x.right\\n        if x_parent:\\n            if x_parent.left is x:\\n                x_parent.left = y\\n            else:\\n                x_parent.right = y\\n        if y_parent:\\n            if y_parent.left is y:\\n                y_parent.left = x\\n            else:\\n                y_parent.right = x\\n```\\n\\n\\nFinally, I provide an optimal solution which has the asymtotically best time & space complexity (O(n) time and O(1) space) and also takes into account the aforementioned two points, using Morris traversal.\\n\\n```\\n# Morris traversal\\n# This solution:\\n#    1. is able to deal with duplicate values\\n#    2. swaps nodes instead of values\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(1)\\nclass Solution:\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        x = y = predecessor = pred = None\\n        \\n        node = root\\n        while node:\\n            if not node.left: \\n                \\n                ### this is what we do to each traversed node ###\\n                if pred:\\n                    if x is None:\\n                        if node.val < pred.val:\\n                            x = pred \\n                            y = node\\n                    else:\\n                        if node.val <= y.val:\\n                            y = node\\n                if pred is None or node.val != pred.val:\\n                    pred = node\\n                ### this is what we do to each traversed node ###\\n                \\n                node = node.right            \\n            else:\\n                predecessor = node.left\\n                while predecessor.right and predecessor.right is not node:\\n                    predecessor = predecessor.right\\n                \\n                if not predecessor.right:\\n                    predecessor.right = node\\n                    node = node.left\\n                else:\\n                    predecessor.right = None \\n                    \\n                    ### this is what we do to each traversed node ###\\n                    if pred:\\n                        if x is None:\\n                            if node.val < pred.val:\\n                                x = pred \\n                                y = node\\n                        else:\\n                            if node.val <= y.val:\\n                                y = node\\n                    if pred is None or node.val != pred.val:\\n                        pred = node\\n                    ### this is what we do to each traversed node ###\\n                    \\n                    node = node.right \\n                    \\n        x_parent, y_parent = self.morris_preorder(root, x, y)\\n        swap_nodes(x, y, x_parent, y_parent)\\n    \\n    def morris_preorder(self, root, x, y):\\n        \\'\\'\\'\\n        This is used to find the parents of x, y in linear time and constant space\\n        \\'\\'\\'\\n        node, parent = root, None\\n        while node:\\n            if not node.left: \\n                \\n                ### check if we meet the parent ###\\n                if node is x:\\n                    x_parent = parent\\n                elif node is y:\\n                    y_parent = parent\\n                ### check if we meet the parent ###\\n                \\n                node, parent = node.right, node            \\n            else:\\n                predecessor = node.left\\n                while predecessor.right and predecessor.right is not node:\\n                    predecessor = predecessor.right\\n                \\n                if not predecessor.right:\\n                    \\n                    ### check if we meet the parent ###\\n                    if node is x:\\n                        x_parent = parent\\n                    elif node is y:\\n                        y_parent = parent\\n                    ### check if we meet the parent ###\\n                    \\n                    predecessor.right = node\\n                    node, parent = node.left, node\\n                else:\\n                    predecessor.right = None                     \\n                    node, parent = node.right, node\\n                    \\n        return x_parent, y_parent\\n```\\nNote that if your implementation swaps nodes instead of values, then the code won\\'t pass the test cases of this problem, since in some cases it swaps the root node and the LeetCode testing code of this problem won\\'t change the pointer to the original root to the new root so that you eventually end up with a subtree instead of the original entire tree.",
                "solutionTags": [],
                "code": "```\\n# This solution uses stack. You can also do the similar thing with recursion or Morris traversal\\n# This solution is able to deal with duplicate values; therefore it\\'s a more general solution\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(H) where H is the height of the tree. In the worst case it can deteriorate to O(N)\\nclass Solution:\\n    def recoverTree(self, root: TreeNode):\\n        \"\"\"\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        x = y = pred = None\\n        \\n        while stack or root:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            \\n            ### this is what we do to each traversed node ###\\n            if pred:\\n                if x is None:\\n                    if root.val < pred.val:\\n                        x = pred \\n                        y = root\\n                else:\\n                    if root.val <= y.val:\\n                        y = root\\n                    if root.val > x.val:\\n                        break\\n            if pred is None or root.val != pred.val:\\n                pred = root\\n            ### this is what we do to each traversed node ###\\n                \\n            root = root.right\\n        x.val, y.val = y.val, x.val\\n```\n```\\n# This solution:\\n#    1. is able to deal with duplicate values\\n#    2. swaps nodes instead of values\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(H) where H is the height of the tree. In the worst case it can deteriorate to O(N)\\nclass Solution:\\n    def recoverTree(self, root: TreeNode):\\n        \"\"\"\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        x = y = pred = None\\n        parent = None\\n        while stack or root:\\n            while root:\\n                stack.append((root, parent))\\n                root, parent = root.left, root\\n            root, parent = stack.pop()\\n            \\n            ### this is what we do to each traversed node ###\\n            if pred:\\n                if x is None:\\n                    if root.val < pred.val:\\n                        x, x_parent = pred, pred_parent\\n                        y, y_parent = root, parent\\n                else:\\n                    if root.val <= y.val:\\n                        y, y_parent = root, parent\\n                    if root.val > x.val:\\n                        break\\n            if pred is None or root.val != pred.val:\\n                pred, pred_parent = root, parent\\n            ### this is what we do to each traversed node ###\\n                \\n            root, parent = root.right, root\\n        swap_nodes(x, y, x_parent, y_parent)\\n    \\ndef swap_nodes(x: TreeNode, y: TreeNode, x_parent: TreeNode, y_parent: TreeNode):\\n    if x_parent is y:\\n        if y_parent:\\n            if y_parent.left is y:\\n                y_parent.left = x\\n            else:\\n                y_parent.right = x\\n        if y.left is x:\\n            x.left, x.right, y.left, y.right = y, y.right, x.left, x.right\\n        else:\\n            x.left, x.right, y.left, y.right = y.left, y, x.left, x.right\\n\\n    elif y_parent is x:\\n        if x_parent:\\n            if x_parent.left is x:\\n                x_parent.left = y\\n            else:\\n                x_parent.right = y\\n        if x.left is y:\\n            x.left, x.right, y.left, y.right = y.left, y.right, x, x.right\\n        else:\\n            x.left, x.right, y.left, y.right = y.left, y.right, x.left, x\\n\\n    else:    \\n        x.left, x.right, y.left, y.right = y.left, y.right, x.left, x.right\\n        if x_parent:\\n            if x_parent.left is x:\\n                x_parent.left = y\\n            else:\\n                x_parent.right = y\\n        if y_parent:\\n            if y_parent.left is y:\\n                y_parent.left = x\\n            else:\\n                y_parent.right = x\\n```\n```\\n# Morris traversal\\n# This solution:\\n#    1. is able to deal with duplicate values\\n#    2. swaps nodes instead of values\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(1)\\nclass Solution:\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        x = y = predecessor = pred = None\\n        \\n        node = root\\n        while node:\\n            if not node.left: \\n                \\n                ### this is what we do to each traversed node ###\\n                if pred:\\n                    if x is None:\\n                        if node.val < pred.val:\\n                            x = pred \\n                            y = node\\n                    else:\\n                        if node.val <= y.val:\\n                            y = node\\n                if pred is None or node.val != pred.val:\\n                    pred = node\\n                ### this is what we do to each traversed node ###\\n                \\n                node = node.right            \\n            else:\\n                predecessor = node.left\\n                while predecessor.right and predecessor.right is not node:\\n                    predecessor = predecessor.right\\n                \\n                if not predecessor.right:\\n                    predecessor.right = node\\n                    node = node.left\\n                else:\\n                    predecessor.right = None \\n                    \\n                    ### this is what we do to each traversed node ###\\n                    if pred:\\n                        if x is None:\\n                            if node.val < pred.val:\\n                                x = pred \\n                                y = node\\n                        else:\\n                            if node.val <= y.val:\\n                                y = node\\n                    if pred is None or node.val != pred.val:\\n                        pred = node\\n                    ### this is what we do to each traversed node ###\\n                    \\n                    node = node.right \\n                    \\n        x_parent, y_parent = self.morris_preorder(root, x, y)\\n        swap_nodes(x, y, x_parent, y_parent)\\n    \\n    def morris_preorder(self, root, x, y):\\n        \\'\\'\\'\\n        This is used to find the parents of x, y in linear time and constant space\\n        \\'\\'\\'\\n        node, parent = root, None\\n        while node:\\n            if not node.left: \\n                \\n                ### check if we meet the parent ###\\n                if node is x:\\n                    x_parent = parent\\n                elif node is y:\\n                    y_parent = parent\\n                ### check if we meet the parent ###\\n                \\n                node, parent = node.right, node            \\n            else:\\n                predecessor = node.left\\n                while predecessor.right and predecessor.right is not node:\\n                    predecessor = predecessor.right\\n                \\n                if not predecessor.right:\\n                    \\n                    ### check if we meet the parent ###\\n                    if node is x:\\n                        x_parent = parent\\n                    elif node is y:\\n                        y_parent = parent\\n                    ### check if we meet the parent ###\\n                    \\n                    predecessor.right = node\\n                    node, parent = node.left, node\\n                else:\\n                    predecessor.right = None                     \\n                    node, parent = node.right, node\\n                    \\n        return x_parent, y_parent\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264842,
                "title": "o-n-time-o-1-space-handles-duplicates-explanation-and-lessons-learned",
                "content": "I feel that the few comments I perused mostly contained code of which I did not fully understand what to do with it. Also I have a slight criticism to the task because it does not say that node-values are distinct, albeit in the test cases they are. For my solution, I will not assume that they are.\\n\\nThings I learned:\\n1) **Morris traversal**, you can traverse a binary tree with constant space (note that the recursion stack also counts as space). There are better explanations out in the internet, so I am not going to explain it. My function *inOrderTraversal* is an implementation of it.\\n2) **Pointers to member functions**, first time I encountered them and heard that they are difficult to normal function pointers. You have this crazy ->* syntax. Something to learn.\\n3) **Reduce to easier problems**. In my opinion this is the secret behind every good problem solver and it helped me understand the solution here to. I will jut down my thinking.\\n\\nHow I found my solution:\\nNormally, I do not like to bother people with how I came up with my solution (who cares), but here I do, since it gives me insights into how to solve general problems.\\n1) *First considering a list (ordered) with distinct values. Write one down and swap a) two consecutive values, b) two values one apart, c) two values two apart*. You will notices that in the resulting list the swapped values are found easily: It is the first value, which is larger then the follow-up value and the last value, which is smaller than its predecessor. Let us call them *firstFaulty* and *lastFaulty*.\\n2) *Now consider lists with non-distinct values.* You will notice that you have to replace *firstFaulty* by the last item, which has the value *firstFaulty* and *lastFaulty* with the first value which is equal to *lastFaulty*. I think you can quickly figure out that this is correct on paper and thus I will omit a proof of formal correctness. If you want to see one, quickly shoot me a comment and I will provide one.\\n3) *Now consider the general problem with trees*. Can we transform a tree into an ordered list? Not using O(1) space and \\'remembering\\' the tree-structure. But we can go through the tree in-order using *Morris-traversal* and O(1) space; it is similar to transforming the tree into a singly-linked list. We will traverse through our tree twice. First finding *firstFaulty* and *lastFaulty* as described in 1), then updating them as described in 2). Voila that is our algorithm.\\n\\nThe implementation was also a bit tricky. To avoid duplication of code, I only implemented the Morris-traversal once and learned a lot about method-function pointers in the process. But this is at most interesting to the C++-nerds among us; if at all.\\n\\n```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        firstFaulty=lastFaulty=0;\\n        previous=0;\\n        inOrderTraversal(root, &Solution::findFirstLastFaulty);\\n        if(firstFaulty){\\n            handleDuplicateValues(root);\\n            swap(firstFaulty->val,lastFaulty->val);\\n        }\\n    }\\nprivate:\\n    TreeNode* firstFaulty;\\n    TreeNode* lastFaulty;\\n    TreeNode* previous=0;\\n    bool lastFaultyFound;\\n    \\n    void inOrderTraversal(TreeNode *root, void (Solution::*check)(TreeNode*)){\\n        TreeNode* current=root;\\n        \\n        while(current){\\n            if(! current->left){\\n                (this->*check)(current);\\n                current=current->right;\\n            }else{\\n                TreeNode* predecessor=current->left;\\n                while(predecessor->right && predecessor->right!=current){\\n                    predecessor=predecessor->right;\\n                }\\n                if(!predecessor->right){\\n                    predecessor->right=current;\\n                    current=current->left;\\n                }else{\\n                    predecessor->right=0;\\n                    (this->*check)(current);\\n                    current=current->right;\\n                }\\n            }\\n        }\\n    }\\n    void findFirstLastFaulty(TreeNode* node){\\n        if(previous && previous->val > node->val){\\n            if(!firstFaulty)\\n                firstFaulty=previous;\\n            lastFaulty=node;\\n        }\\n        previous=node;\\n    }\\n    void handleDuplicateValues(TreeNode *root){\\n        lastFaultyFound=false;\\n        inOrderTraversal(root, &Solution::incorporateSimilarValues);\\n    }\\n    void incorporateSimilarValues(TreeNode* node){\\n        if(!lastFaultyFound && node->val == lastFaulty->val){\\n            lastFaultyFound=true;\\n            lastFaulty=node;\\n        }\\n        if(node->val == firstFaulty->val){\\n            firstFaulty=node;\\n        }\\n    }\\n};\\n```\\n\\n**Please comment** if you have questions, want explanations or even better find some way I can improve. I hope to use this site to learn how to explain well and code clean, next to helping people understanding how to solve problems (or learning from people how to solve problems -- thanks for the folks in prior discussions mentioning Morris traversal!).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        firstFaulty=lastFaulty=0;\\n        previous=0;\\n        inOrderTraversal(root, &Solution::findFirstLastFaulty);\\n        if(firstFaulty){\\n            handleDuplicateValues(root);\\n            swap(firstFaulty->val,lastFaulty->val);\\n        }\\n    }\\nprivate:\\n    TreeNode* firstFaulty;\\n    TreeNode* lastFaulty;\\n    TreeNode* previous=0;\\n    bool lastFaultyFound;\\n    \\n    void inOrderTraversal(TreeNode *root, void (Solution::*check)(TreeNode*)){\\n        TreeNode* current=root;\\n        \\n        while(current){\\n            if(! current->left){\\n                (this->*check)(current);\\n                current=current->right;\\n            }else{\\n                TreeNode* predecessor=current->left;\\n                while(predecessor->right && predecessor->right!=current){\\n                    predecessor=predecessor->right;\\n                }\\n                if(!predecessor->right){\\n                    predecessor->right=current;\\n                    current=current->left;\\n                }else{\\n                    predecessor->right=0;\\n                    (this->*check)(current);\\n                    current=current->right;\\n                }\\n            }\\n        }\\n    }\\n    void findFirstLastFaulty(TreeNode* node){\\n        if(previous && previous->val > node->val){\\n            if(!firstFaulty)\\n                firstFaulty=previous;\\n            lastFaulty=node;\\n        }\\n        previous=node;\\n    }\\n    void handleDuplicateValues(TreeNode *root){\\n        lastFaultyFound=false;\\n        inOrderTraversal(root, &Solution::incorporateSimilarValues);\\n    }\\n    void incorporateSimilarValues(TreeNode* node){\\n        if(!lastFaultyFound && node->val == lastFaulty->val){\\n            lastFaultyFound=true;\\n            lastFaulty=node;\\n        }\\n        if(node->val == firstFaulty->val){\\n            firstFaulty=node;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139057,
                "title": "simple-java-dfs-beating-100-in-time",
                "content": "```\\nclass Solution {\\n    TreeNode left=null;\\n    TreeNode right=null;\\n    TreeNode last=null;\\n    public void recoverTree(TreeNode root) {\\n        dfs(root);\\n        int temp=left.val;\\n        left.val=right.val;\\n        right.val=temp;\\n    }\\n    private void dfs(TreeNode root){\\n        if(root==null) return;\\n        dfs(root.left);\\n        if(last!=null && left==null && last.val>root.val) left=last;\\n        if(last!=null && last.val>root.val) right=root;\\n        last=root;\\n        dfs(root.right);   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode left=null;\\n    TreeNode right=null;\\n    TreeNode last=null;\\n    public void recoverTree(TreeNode root) {\\n        dfs(root);\\n        int temp=left.val;\\n        left.val=right.val;\\n        right.val=temp;\\n    }\\n    private void dfs(TreeNode root){\\n        if(root==null) return;\\n        dfs(root.left);\\n        if(last!=null && left==null && last.val>root.val) left=last;\\n        if(last!=null && last.val>root.val) right=root;\\n        last=root;\\n        dfs(root.right);   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053192,
                "title": "simple-c-o-1-inorder-traversal",
                "content": "```\\nclass Solution {\\n\\n        TreeNode* prev {};\\n        TreeNode* badNode1 {};\\n        TreeNode* badNode2 {};\\n\\n        void locateBadNodes(TreeNode* node) {\\n                if(node) {\\n                        locateBadNodes(node->left);\\n                        if(prev && prev->val > node->val) {\\n                                if(!badNode1) {\\n                                        badNode1 = prev;\\n                                        badNode2 = node;\\n                                }       else {\\n                                        badNode2 = node;\\n                                        return;\\n                                }\\n                        }\\n                        prev = node;\\n                        locateBadNodes(node->right);\\n                }\\n        }\\n\\npublic:\\n\\n        void recoverTree(TreeNode* root) {\\n                        locateBadNodes(root);\\n                        if(badNode1 && badNode2) {\\n                                std::swap(badNode1->val, badNode2->val);\\n                        }\\n        }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n        TreeNode* prev {};\\n        TreeNode* badNode1 {};\\n        TreeNode* badNode2 {};\\n\\n        void locateBadNodes(TreeNode* node) {\\n                if(node) {\\n                        locateBadNodes(node->left);\\n                        if(prev && prev->val > node->val) {\\n                                if(!badNode1) {\\n                                        badNode1 = prev;\\n                                        badNode2 = node;\\n                                }       else {\\n                                        badNode2 = node;\\n                                        return;\\n                                }\\n                        }\\n                        prev = node;\\n                        locateBadNodes(node->right);\\n                }\\n        }\\n\\npublic:\\n\\n        void recoverTree(TreeNode* root) {\\n                        locateBadNodes(root);\\n                        if(badNode1 && badNode2) {\\n                                std::swap(badNode1->val, badNode2->val);\\n                        }\\n        }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918268,
                "title": "python-inorder-traverse",
                "content": "Inorder traverse the tree, store the vals of nodes into a vector. Then sort the vals and change the val of nodes in order.\\n```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n\\t    def inorder(root):\\n            if not root: return []\\n            return inorder(root.left)+[root]+inorder(root.right)\\n            \\n        v=inorder(root)\\n        vals = sorted(x.val for x in v)\\n        \\n        for i in range(len(v)):\\n            v[i].val = vals[i]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n\\t    def inorder(root):\\n            if not root: return []\\n            return inorder(root.left)+[root]+inorder(root.right)\\n            \\n        v=inorder(root)\\n        vals = sorted(x.val for x in v)\\n        \\n        for i in range(len(v)):\\n            v[i].val = vals[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917633,
                "title": "intutive-inorder-traversal",
                "content": "First time I am posting my solution:\\n\\nDo inorder traversal. Find the node whose previous value and current node is not in order. (prevElement > currElement)\\nKeep track of first node and last node encountered like this and swap them.\\n**Explanation:** \\n1.The inorder traversal of BST should always give us ascending order but not when nodes are swapped.\\n2.Now if we know the point where the order is violated, we can find the nodes which violate it and then swap them.\\n```\\nclass Solution {\\nTreeNode preNode = null;\\nTreeNode firstNode =null, secondNode =null;\\n\\npublic void recoverTree(TreeNode root) {\\n    inorderTraversal(root);\\n    int temp = firstNode.val;\\n    firstNode.val = secondNode.val;\\n    secondNode.val = temp;\\n}\\npublic void inorderTraversal(TreeNode curr) {\\n    if(curr == null)\\n        return;\\n    inorderTraversal(curr.left);\\n    //Do the work\\n    if(preNode != null) {\\n        if(preNode.val > curr.val) {\\n            if(firstNode == null) {\\n                firstNode = preNode;\\n            }\\n            secondNode = curr;\\n        }\\n    }\\n    preNode = curr;\\n    inorderTraversal(curr.right);\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nTreeNode preNode = null;\\nTreeNode firstNode =null, secondNode =null;\\n\\npublic void recoverTree(TreeNode root) {\\n    inorderTraversal(root);\\n    int temp = firstNode.val;\\n    firstNode.val = secondNode.val;\\n    secondNode.val = temp;\\n}\\npublic void inorderTraversal(TreeNode curr) {\\n    if(curr == null)\\n        return;\\n    inorderTraversal(curr.left);\\n    //Do the work\\n    if(preNode != null) {\\n        if(preNode.val > curr.val) {\\n            if(firstNode == null) {\\n                firstNode = preNode;\\n            }\\n            secondNode = curr;\\n        }\\n    }\\n    preNode = curr;\\n    inorderTraversal(curr.right);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917330,
                "title": "c-simple-inorder-traversal-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>&bs){\\n        if(root==NULL){\\n            return;\\n        }\\n        inorder(root->left,bs);\\n        bs.push_back(root->val);\\n        inorder(root->right,bs);\\n    }\\n    void recover(TreeNode* root,int &a,int &b,TreeNode* &r){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->val==a && root!=r){\\n            root->val=b;\\n            r=root;\\n        }else if(root->val==b && root!=r){\\n            root->val=a;\\n            r=root;\\n        }\\n        recover(root->left,a,b,r);\\n        recover(root->right,a,b,r);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<int>bs;\\n        inorder(root,bs);\\n        int a=-1,b=-1;\\n        int count=0;\\n        for(int i=0;i<bs.size()-1;i++){\\n            if(bs[i]>bs[i+1] && count==0){\\n                a=i;\\n                count++;\\n            }else if(bs[i]>bs[i+1] && count==1){\\n                b=bs[i+1];\\n                break;\\n            }\\n        }\\n        if(b==-1){\\n            b=bs[a+1];\\n        }\\n        a=bs[a];\\n        TreeNode* r;\\n        recover(root,a,b,r);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>&bs){\\n        if(root==NULL){\\n            return;\\n        }\\n        inorder(root->left,bs);\\n        bs.push_back(root->val);\\n        inorder(root->right,bs);\\n    }\\n    void recover(TreeNode* root,int &a,int &b,TreeNode* &r){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->val==a && root!=r){\\n            root->val=b;\\n            r=root;\\n        }else if(root->val==b && root!=r){\\n            root->val=a;\\n            r=root;\\n        }\\n        recover(root->left,a,b,r);\\n        recover(root->right,a,b,r);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<int>bs;\\n        inorder(root,bs);\\n        int a=-1,b=-1;\\n        int count=0;\\n        for(int i=0;i<bs.size()-1;i++){\\n            if(bs[i]>bs[i+1] && count==0){\\n                a=i;\\n                count++;\\n            }else if(bs[i]>bs[i+1] && count==1){\\n                b=bs[i+1];\\n                break;\\n            }\\n        }\\n        if(b==-1){\\n            b=bs[a+1];\\n        }\\n        a=bs[a];\\n        TreeNode* r;\\n        recover(root,a,b,r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916653,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    boolean swapped = true;\\n    public void recoverTree(TreeNode root) {\\n        while(swapped) {\\n            swapped = false;\\n            dfs(root, null, null);\\n        }\\n    }\\n    \\n    public void dfs(TreeNode root, TreeNode min, TreeNode max) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        if(max != null) {\\n            if (root.val > max.val) {\\n                swapped = swapped || true;\\n                swap(root, max);   \\n            }\\n        }\\n        \\n        if(min != null) {\\n            if(root.val < min.val) {\\n                swapped = swapped || true;\\n                swap(root, min);\\n            }\\n        }\\n        \\n        dfs(root.left, min, root);\\n        dfs(root.right, root, max);\\n        \\n    }\\n    \\n    private void swap(TreeNode a, TreeNode b) {\\n        int tmp = a.val;\\n        a.val = b.val;\\n        b.val = tmp;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean swapped = true;\\n    public void recoverTree(TreeNode root) {\\n        while(swapped) {\\n            swapped = false;\\n            dfs(root, null, null);\\n        }\\n    }\\n    \\n    public void dfs(TreeNode root, TreeNode min, TreeNode max) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        if(max != null) {\\n            if (root.val > max.val) {\\n                swapped = swapped || true;\\n                swap(root, max);   \\n            }\\n        }\\n        \\n        if(min != null) {\\n            if(root.val < min.val) {\\n                swapped = swapped || true;\\n                swap(root, min);\\n            }\\n        }\\n        \\n        dfs(root.left, min, root);\\n        dfs(root.right, root, max);\\n        \\n    }\\n    \\n    private void swap(TreeNode a, TreeNode b) {\\n        int tmp = a.val;\\n        a.val = b.val;\\n        b.val = tmp;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831158,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\n    TreeNode *prev = NULL;\\n    TreeNode *mistake1 = NULL, *mistake2 = NULL;\\n    \\n    void inorder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        \\n        inorder(root->left);\\n        \\n        if (prev and root->val < prev->val) {\\n            if (!mistake1)\\n                mistake1 = prev;\\n            \\n            if (mistake1)\\n                mistake2 = root;\\n        }\\n    \\n        prev = root;\\n        \\n        inorder(root->right);\\n    }\\n    \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        \\n        swap(mistake1->val, mistake2->val);\\n        \\n        return;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    TreeNode *prev = NULL;\\n    TreeNode *mistake1 = NULL, *mistake2 = NULL;\\n    \\n    void inorder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        \\n        inorder(root->left);\\n        \\n        if (prev and root->val < prev->val) {\\n            if (!mistake1)\\n                mistake1 = prev;\\n            \\n            if (mistake1)\\n                mistake2 = root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 791960,
                "title": "intuitive-solution-explaining-no-fancy-code",
                "content": "```\\nclass Solution {\\n    /*\\n\\t\\n\\tWe know the inorder of a binary search tree is a sorted array. \\n\\t\\n    The idea is essentailly to solve the problem:\\n    Recover an almost sorted array with TWO elements swapped. Swap them back to make \\n    the array sorted. \\n    \\n\\tSo, let\\'s first get the inorder list and find the two mismatched values\\n\\t\\n    To find the two values: \\n\\tTraverse the array from left side and find the first out of order element \\n\\t(element which is bigger than next element).\\n\\tTraverse from rightmost side and find the first out of order element \\n\\t(element at i which is smaller than previous element at i-1).\\n    \\n    */\\n\\t//Time: O(N)\\n\\t//Space: O(N)\\n    TreeNode m1 = null;\\n    TreeNode m2 = null;\\n    public void recoverTree(TreeNode root) {\\n        List<Integer> lst = new ArrayList<>();\\n        getInorder(root, lst);\\n        \\n        // An almost sorted array with two elements swapped\\n        int mismatch1 = 0;\\n        int mismatch2 = 0;\\n        // from left to right\\n        for(int i = 0; i < lst.size()-1; i++){\\n            if(lst.get(i) > lst.get(i+1)){\\n                mismatch1 = lst.get(i);\\n                break;\\n            }\\n        }\\n        \\n        // from right to left\\n        for(int i = lst.size()-1; i > 0; i--){\\n            if(lst.get(i) < lst.get(i-1)){\\n                mismatch2 = lst.get(i);\\n                break;\\n            }\\n        }\\n        \\n        // find the two nodes with val to mismatch1 and 2\\n        dfs(root, mismatch1, mismatch2);\\n        \\n        // swap the value\\n        int temp = m1.val;\\n        m1.val = m2.val;\\n        m2.val = temp;\\n    }\\n    \\n    public void getInorder(TreeNode root, List<Integer> lst){\\n        if(root == null) return;\\n        getInorder(root.left, lst);\\n        lst.add(root.val);\\n        getInorder(root.right, lst);\\n    }\\n    \\n    public void dfs(TreeNode root, int mismatch1, int mismatch2){\\n        if(root == null) return;\\n        if(root.val == mismatch1){\\n            m1 = root;\\n        }else if(root.val == mismatch2){\\n            m2 = root;\\n        }\\n        \\n        dfs(root.left, mismatch1, mismatch2);\\n        dfs(root.right, mismatch1, mismatch2);\\n    }\\n    \\n}\\n```\\n\\nA slightly shorter version without populating into a List.\\nSame idea but just finding two mismatch while traversing \\nin inorder forward and backward\\n\\n```\\n// Time: O(N)\\n// Space: O(1) except the recursive stack\\nclass Solution {\\n    TreeNode m1 = null;\\n    TreeNode m2 = null;\\n    boolean foundM1 = false;\\n    boolean foundM2 = false;\\n    public void recoverTree(TreeNode root) {\\n        inorderForward(root); // forward\\n        inorderBackward(root); // backward\\n       \\n        int temp = m1.val;\\n        m1.val = m2.val;\\n        m2.val = temp;\\n    }\\n    \\n    public void inorderForward(TreeNode root){\\n        if(root == null) return;\\n        inorderForward(root.left);\\n        \\n        if(m1 != null && m1.val > root.val){\\n            foundM1 = true;\\n            return;\\n        }\\n        if(!foundM1)\\n            m1 = root;\\n        inorderForward(root.right);\\n    }\\n    \\n    public void inorderBackward(TreeNode root){\\n        if(root == null) return;\\n        inorderBackward(root.right);\\n        if(m2 != null && m2.val < root.val){\\n            foundM2 = true;\\n            return;\\n        }\\n       \\n        if(!foundM2)\\n            m2 = root;\\n        inorderBackward(root.left);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n\\t\\n\\tWe know the inorder of a binary search tree is a sorted array. \\n\\t\\n    The idea is essentailly to solve the problem:\\n    Recover an almost sorted array with TWO elements swapped. Swap them back to make \\n    the array sorted. \\n    \\n\\tSo, let\\'s first get the inorder list and find the two mismatched values\\n\\t\\n    To find the two values: \\n\\tTraverse the array from left side and find the first out of order element \\n\\t(element which is bigger than next element).\\n\\tTraverse from rightmost side and find the first out of order element \\n\\t(element at i which is smaller than previous element at i-1).\\n    \\n    */\\n\\t//Time: O(N)\\n\\t//Space: O(N)\\n    TreeNode m1 = null;\\n    TreeNode m2 = null;\\n    public void recoverTree(TreeNode root) {\\n        List<Integer> lst = new ArrayList<>();\\n        getInorder(root, lst);\\n        \\n        // An almost sorted array with two elements swapped\\n        int mismatch1 = 0;\\n        int mismatch2 = 0;\\n        // from left to right\\n        for(int i = 0; i < lst.size()-1; i++){\\n            if(lst.get(i) > lst.get(i+1)){\\n                mismatch1 = lst.get(i);\\n                break;\\n            }\\n        }\\n        \\n        // from right to left\\n        for(int i = lst.size()-1; i > 0; i--){\\n            if(lst.get(i) < lst.get(i-1)){\\n                mismatch2 = lst.get(i);\\n                break;\\n            }\\n        }\\n        \\n        // find the two nodes with val to mismatch1 and 2\\n        dfs(root, mismatch1, mismatch2);\\n        \\n        // swap the value\\n        int temp = m1.val;\\n        m1.val = m2.val;\\n        m2.val = temp;\\n    }\\n    \\n    public void getInorder(TreeNode root, List<Integer> lst){\\n        if(root == null) return;\\n        getInorder(root.left, lst);\\n        lst.add(root.val);\\n        getInorder(root.right, lst);\\n    }\\n    \\n    public void dfs(TreeNode root, int mismatch1, int mismatch2){\\n        if(root == null) return;\\n        if(root.val == mismatch1){\\n            m1 = root;\\n        }else if(root.val == mismatch2){\\n            m2 = root;\\n        }\\n        \\n        dfs(root.left, mismatch1, mismatch2);\\n        dfs(root.right, mismatch1, mismatch2);\\n    }\\n    \\n}\\n```\n```\\n// Time: O(N)\\n// Space: O(1) except the recursive stack\\nclass Solution {\\n    TreeNode m1 = null;\\n    TreeNode m2 = null;\\n    boolean foundM1 = false;\\n    boolean foundM2 = false;\\n    public void recoverTree(TreeNode root) {\\n        inorderForward(root); // forward\\n        inorderBackward(root); // backward\\n       \\n        int temp = m1.val;\\n        m1.val = m2.val;\\n        m2.val = temp;\\n    }\\n    \\n    public void inorderForward(TreeNode root){\\n        if(root == null) return;\\n        inorderForward(root.left);\\n        \\n        if(m1 != null && m1.val > root.val){\\n            foundM1 = true;\\n            return;\\n        }\\n        if(!foundM1)\\n            m1 = root;\\n        inorderForward(root.right);\\n    }\\n    \\n    public void inorderBackward(TreeNode root){\\n        if(root == null) return;\\n        inorderBackward(root.right);\\n        if(m2 != null && m2.val < root.val){\\n            foundM2 = true;\\n            return;\\n        }\\n       \\n        if(!foundM2)\\n            m2 = root;\\n        inorderBackward(root.left);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779010,
                "title": "python-in-order-traversal",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        # get in-order traversal, sort, check the difference\\n        container = []\\n        def traverse(node):\\n            if not node:\\n                return\\n            traverse(node.left)\\n            container.append((node.val, node))\\n            traverse(node.right)\\n        traverse(root)\\n        target = sorted(container)\\n        for i in range(len(container)):\\n            currNode, targetNode = container[i][1], target[i][1]\\n            if currNode != targetNode:\\n                currNode.val, targetNode.val = targetNode.val, currNode.val\\n                break\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        # get in-order traversal, sort, check the difference\\n        container = []\\n        def traverse(node):\\n            if not node:\\n                return\\n            traverse(node.left)\\n            container.append((node.val, node))\\n            traverse(node.right)\\n        traverse(root)\\n        target = sorted(container)\\n        for i in range(len(container)):\\n            currNode, targetNode = container[i][1], target[i][1]\\n            if currNode != targetNode:\\n                currNode.val, targetNode.val = targetNode.val, currNode.val\\n                break\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 744137,
                "title": "simple-golang-in-order-and-pointer-based-solution",
                "content": "```\\n/*\\nWe need to find the first and second elements that are not in order right?\\n\\nHow do we find these two elements? For example, we have the following tree that is printed as in order traversal:\\n\\n6, 3, 4, 5, 2\\n\\nWe compare each node with its next one and we can find out that 6 is the first element to swap because 6 > 3 and 2 is the second element to swap because 2 < 5.\\n\\nReally, what we are comparing is the current node and its previous node in the \"in order traversal\".\\n\\ncc https://leetcode.com/problems/recover-binary-search-tree/discuss/32535/No-Fancy-Algorithm-just-Simple-and-Powerful-In-Order-Traversal\\n*/\\nfunc recoverTree(root *TreeNode)  {\\n    var prevEle,firstEle,secondEle *TreeNode\\n    firstEle,secondEle = nil,nil\\n    INT_MIN := -1*int(1e10)\\n    prevEle = &TreeNode{Val:INT_MIN,Left:nil,Right:nil}\\n    traverse(root,&prevEle,&firstEle,&secondEle)\\n    if firstEle != nil && secondEle!= nil{\\n        firstEle.Val,secondEle.Val = secondEle.Val,firstEle.Val\\n    }\\n}\\n\\nfunc traverse(root *TreeNode, prevEle,firstEle,secondEle **TreeNode) {\\n    if root==nil{\\n        return\\n    }\\n    traverse(root.Left,prevEle,firstEle,secondEle)\\n    //fmt.Println(root.Val,(*prevEle).Val,*firstEle,*secondEle)\\n    if *firstEle == nil && (*prevEle).Val >= root.Val{\\n        *firstEle = *prevEle    \\n    }\\n    if *firstEle != nil && (*prevEle).Val >= root.Val{\\n        *secondEle = root    \\n    }\\n    *prevEle = root\\n    traverse(root.Right,prevEle,firstEle,secondEle)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/*\\nWe need to find the first and second elements that are not in order right?\\n\\nHow do we find these two elements? For example, we have the following tree that is printed as in order traversal:\\n\\n6, 3, 4, 5, 2\\n\\nWe compare each node with its next one and we can find out that 6 is the first element to swap because 6 > 3 and 2 is the second element to swap because 2 < 5.\\n\\nReally, what we are comparing is the current node and its previous node in the \"in order traversal\".\\n\\ncc https://leetcode.com/problems/recover-binary-search-tree/discuss/32535/No-Fancy-Algorithm-just-Simple-and-Powerful-In-Order-Traversal\\n*/\\nfunc recoverTree(root *TreeNode)  {\\n    var prevEle,firstEle,secondEle *TreeNode\\n    firstEle,secondEle = nil,nil\\n    INT_MIN := -1*int(1e10)\\n    prevEle = &TreeNode{Val:INT_MIN,Left:nil,Right:nil}\\n    traverse(root,&prevEle,&firstEle,&secondEle)\\n    if firstEle != nil && secondEle!= nil{\\n        firstEle.Val,secondEle.Val = secondEle.Val,firstEle.Val\\n    }\\n}\\n\\nfunc traverse(root *TreeNode, prevEle,firstEle,secondEle **TreeNode) {\\n    if root==nil{\\n        return\\n    }\\n    traverse(root.Left,prevEle,firstEle,secondEle)\\n    //fmt.Println(root.Val,(*prevEle).Val,*firstEle,*secondEle)\\n    if *firstEle == nil && (*prevEle).Val >= root.Val{\\n        *firstEle = *prevEle    \\n    }\\n    if *firstEle != nil && (*prevEle).Val >= root.Val{\\n        *secondEle = root    \\n    }\\n    *prevEle = root\\n    traverse(root.Right,prevEle,firstEle,secondEle)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 712943,
                "title": "c-concise-morris-traversal",
                "content": "We know Inorder Traversal of BST gives elements in increasing order and if a pair of elements are swapped in BST then we will have two junction points at which increasing sequence is not followed. If all elements are distinct in BST, then at those junction points first element is greater than second element(which comes just after first element in Inorder Traversal).\\n\\nIn code below flag=0 represents 1st junction point and flag=1 represents 2nd junction point, also a and b represents first and second element respectively at a junction.\\nWe need to store first element at 1st junction and second element at 2nd junction and swap them at last to correct BST.\\nFor example Inorder traversal of a BST is given **[1, 2, 3, 4, 5, 6, 7, 8]** and **3 & 7** are swapped.\\nSo sequence we will have **[1, 2, 7, 4, 5, 6, 3, 8]** making **7,4** and **6,3** two junctions. Store *needed* values in variables and swap them at 2nd junction.\\nIf **4 & 5** is swapped then the two junctions will overlap and in this we need to do swapping of variables outside while loop.\\n\\nInorder Traversal can be done using recursion or stack, but then space complexity will be O(h) where h is height of tree.\\nUse Morris Traversal to do Inorder Traversal for O(1) space complexity.\\nTime Complexity: O(n).\\n\\nSee Morris Traversal at : https://youtu.be/wGXB9OWhPTg?list=PLrmLmBdmIlpv_jNDXtJGYTPNQ2L1gdHxu\\n\\n    class Solution {\\n    public:\\n    void recoverTree(TreeNode* A) {\\n        TreeNode *root=A;\\n        TreeNode *a=NULL, *b=NULL;\\n        int flag=0;\\n        TreeNode *l, *r;\\n        \\n        while(root){\\n            if(root->left==NULL){\\n                a=b;\\n                b=root;\\n                \\n                if(a && b && flag==0 && a->val>b->val){\\n                    l=a;\\n                    r=b;\\n                    flag=1;\\n                }\\n                else if(a && b && flag==1 && a->val>b->val){\\n                    r=b;\\n                    swap(l->val,r->val);\\n                    flag=2;\\n                }\\n                \\n                root=root->right;\\n            }\\n            else{\\n                TreeNode* pred=root->left;\\n                while(pred->right!=root && pred->right!=NULL){\\n                    pred=pred->right;\\n                }\\n                \\n                if(pred->right==NULL){\\n                    pred->right=root;\\n                    root=root->left;\\n                }\\n                else{\\n                    pred->right=NULL;\\n                    a=b;\\n                    b=root;\\n\\n                    if(a && b && flag==0 && a->val>b->val){\\n                        l=a;\\n                        r=b;\\n                        flag=1;\\n                    }\\n                    else if(a && b && flag==1 && a->val>b->val){\\n                        r=b;\\n                        swap(l->val,r->val);\\n                        flag=2;\\n                    }\\n                    \\n                    root=root->right;\\n                }\\n            }\\n        }\\n        \\n        if(flag==1) swap(l->val,r->val);\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    void recoverTree(TreeNode* A) {\\n        TreeNode *root=A;\\n        TreeNode *a=NULL, *b=NULL;\\n        int flag=0;\\n        TreeNode *l, *r;\\n        \\n        while(root){\\n            if(root->left==NULL){\\n                a=b;\\n                b=root;\\n                \\n                if(a && b && flag==0 && a->val>b->val){\\n                    l=a;\\n                    r=b;\\n                    flag=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 544391,
                "title": "go-inorder-traversal-solution",
                "content": "```\\nfunc recoverTree(root *TreeNode) {\\n\\tvar first, second, prev *TreeNode\\n\\ttraverse(root, &first, &second, &prev)\\n\\tfirst.Val, second.Val = second.Val, first.Val\\n}\\n\\nfunc traverse(root *TreeNode, first, second, prev **TreeNode) {\\n\\tif root == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\ttraverse(root.Left, first, second, prev)\\n\\tif *prev != nil && (*prev).Val >= root.Val {\\n\\t\\tif *first == nil {\\n\\t\\t\\t*first = *prev\\n\\t\\t}\\n\\t\\t*second = root\\n\\t}\\n\\t*prev = root\\n\\ttraverse(root.Right, first, second, prev)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc recoverTree(root *TreeNode) {\\n\\tvar first, second, prev *TreeNode\\n\\ttraverse(root, &first, &second, &prev)\\n\\tfirst.Val, second.Val = second.Val, first.Val\\n}\\n\\nfunc traverse(root *TreeNode, first, second, prev **TreeNode) {\\n\\tif root == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\ttraverse(root.Left, first, second, prev)\\n\\tif *prev != nil && (*prev).Val >= root.Val {\\n\\t\\tif *first == nil {\\n\\t\\t\\t*first = *prev\\n\\t\\t}\\n\\t\\t*second = root\\n\\t}\\n\\t*prev = root\\n\\ttraverse(root.Right, first, second, prev)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 489570,
                "title": "java-solution-2ms-beats-90-java-submissions",
                "content": "My approach is simple I maintain two nodes (First and sec) and a node to keep track of prev Node.\\nWhenever I have prev node and value in prev is > val of current node (In Inorder Traversal) I check if I have first node == null or not.. If i have first == null -> I make sure first node will be prev (as prev.val > cur_node.val) and also i keep track of sec, make sec = cur_node\\n**Time Complexity -> O(N)**\\n**Space Complexity -> O(h) where h - height of BST O(logN)**\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode first;\\n    public TreeNode sec;\\n    public TreeNode prev;\\n    public void recover(TreeNode root) {\\n        if (root == null) return;\\n        // go to left side \\n        recover(root.left);\\n        if (prev != null && prev.val > root.val) {\\n            if (first == null) {\\n                first = prev;\\n            }\\n            sec = root;\\n        }\\n        prev = root;\\n        // go to right side\\n        recover(root.right);\\n    }\\n    public void recoverTree(TreeNode root) {\\n        recover(root);\\n        // swap the nodes\\n        if (first != null) {\\n            int tmp = first.val;\\n            first.val = sec.val;\\n            sec.val = tmp;\\n        }\\n    }\\n}\\n**Here is my code for swapping two nodes to correct a BST**\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode first;\\n    public TreeNode sec;\\n    public TreeNode prev;\\n    public void recover(TreeNode root) {\\n        if (root == null) return;\\n        // go to left side \\n        recover(root.left);\\n        if (prev != null && prev.val > root.val) {\\n            if (first == null) {\\n                first = prev;\\n            }\\n            sec = root;\\n        }\\n        prev = root;\\n        // go to right side\\n        recover(root.right);\\n    }\\n    public void recoverTree(TreeNode root) {\\n        recover(root);\\n        // swap the nodes\\n        if (first != null) {\\n            int tmp = first.val;\\n            first.val = sec.val;\\n            sec.val = tmp;\\n        }\\n    }\\n}\\n**Here is my code for swapping two nodes to correct a BST**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466643,
                "title": "2ms-java-solution-96-5-with-explanation",
                "content": "Let\\'s start with hypothesis that one swapped element is in the left subtree and another is in the right subtree.  In a valid BST we expect largest element in left subtree should be less than smallest element in the right subtree.  Let\\'s find largest element on the left and smallest element on the right.\\nIf largest on the left is larger than smallest on the right - congrats  - we have found two anomalies, let\\'s swap them and we are done.  If not, let\\'s check hypotehsis that root is one of the swapped elements, by checking the largest and smallest in subtrees against the root.  If the hypothesis that root is one of the swapped elements turns out to be wrong as well, the swap has happened in one of the subtrees, either in the left or right, so we apply our method recursively to left and right subtrees.\\n\\n```\\nclass Solution {\\n    \\n    public void recoverTree(TreeNode root) {\\n        if (root== null) {\\n            return;\\n        }\\n        TreeNode largest = findLargest(root.left, root);\\n        TreeNode smallest = findSmallest(root.right, root);       \\n        if (largest.val > smallest.val) {  //two anomalies are found\\n            swap(largest, smallest);\\n        } else if (smallest.val < root.val) { //root is one of the swapped elements\\n            swap(root, smallest);\\n        } else if (largest.val > root.val) {  //root is one of the swapped elements\\n            swap(largest, root); \\n        } else {  // swap has happened in one of the subtrees\\n            recoverTree(root.left);\\n            recoverTree(root.right);\\n        }\\n    }\\n    \\n\\n        \\n    TreeNode findLargest(TreeNode root, TreeNode max) {\\n        if (root==null) return max;\\n        if (root.val > max.val) {\\n            max = root;\\n        }\\n        TreeNode left = findLargest(root.left, max);\\n        if (left.val > max.val) {\\n            max = left;\\n        }\\n        TreeNode right = findLargest(root.right, max);\\n        if (right.val > max.val) {\\n            max = right;\\n        }\\n        return max;\\n    }\\n    \\n    TreeNode findSmallest(TreeNode root, TreeNode min) {\\n        if (root==null) return min;\\n        if (root.val < min.val) {\\n            min = root;\\n        }\\n        TreeNode left = findSmallest(root.left, min);\\n        if (left.val < min.val) {\\n            min = left;\\n        }\\n        TreeNode right = findSmallest(root.right, min);\\n        if (right.val < min.val) {\\n            min = right;\\n        }\\n        return min;\\n    }\\n    \\n    void swap(TreeNode a, TreeNode b) {\\n        int temp  = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public void recoverTree(TreeNode root) {\\n        if (root== null) {\\n            return;\\n        }\\n        TreeNode largest = findLargest(root.left, root);\\n        TreeNode smallest = findSmallest(root.right, root);       \\n        if (largest.val > smallest.val) {  //two anomalies are found\\n            swap(largest, smallest);\\n        } else if (smallest.val < root.val) { //root is one of the swapped elements\\n            swap(root, smallest);\\n        } else if (largest.val > root.val) {  //root is one of the swapped elements\\n            swap(largest, root); \\n        } else {  // swap has happened in one of the subtrees\\n            recoverTree(root.left);\\n            recoverTree(root.right);\\n        }\\n    }\\n    \\n\\n        \\n    TreeNode findLargest(TreeNode root, TreeNode max) {\\n        if (root==null) return max;\\n        if (root.val > max.val) {\\n            max = root;\\n        }\\n        TreeNode left = findLargest(root.left, max);\\n        if (left.val > max.val) {\\n            max = left;\\n        }\\n        TreeNode right = findLargest(root.right, max);\\n        if (right.val > max.val) {\\n            max = right;\\n        }\\n        return max;\\n    }\\n    \\n    TreeNode findSmallest(TreeNode root, TreeNode min) {\\n        if (root==null) return min;\\n        if (root.val < min.val) {\\n            min = root;\\n        }\\n        TreeNode left = findSmallest(root.left, min);\\n        if (left.val < min.val) {\\n            min = left;\\n        }\\n        TreeNode right = findSmallest(root.right, min);\\n        if (right.val < min.val) {\\n            min = right;\\n        }\\n        return min;\\n    }\\n    \\n    void swap(TreeNode a, TreeNode b) {\\n        int temp  = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319748,
                "title": "swift-100-beaten-using-van-morrison-traversal-o-n-lewptie-lewpz",
                "content": "The harder you lewp, the more you poop.\\n\\n```\\nclass Solution {\\n    func recoverTree(_ root: TreeNode?) {\\n        \\n        var node: TreeNode! = root\\n        var prev: TreeNode!\\n        var parent: TreeNode!\\n        \\n        var swap1: TreeNode!\\n        var swap2: TreeNode!\\n        \\n        while node !== nil {\\n            \\n            if node.left === nil {\\n                if parent !== nil && node !== nil && parent.val > node.val {\\n                    if swap1 == nil { swap1 = parent }\\n                    swap2 = node\\n                }\\n                \\n                parent = node\\n                node = node.right\\n            } else {\\n                \\n                prev = node.left\\n                while prev.right !== nil && prev.right !== node { prev = prev.right }\\n                \\n                if prev.right === nil {\\n                    prev.right = node\\n                    node = node.left\\n                } else {\\n                    if parent !== nil && node !== nil && parent.val > node.val {\\n                        if swap1 == nil { swap1 = parent }\\n                        swap2 = node\\n                    }\\n                    parent = node\\n                    node = node.right\\n                    prev.right = nil\\n                }\\n            }\\n        }\\n        \\n        if swap1 !== nil && swap2 !== nil {\\n            var hold = swap1.val\\n            swap1.val = swap2.val\\n            swap2.val = hold\\n        }\\n    }\\n}\\n```\\n\\nKaboom, baby. We got the nukez.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func recoverTree(_ root: TreeNode?) {\\n        \\n        var node: TreeNode! = root\\n        var prev: TreeNode!\\n        var parent: TreeNode!\\n        \\n        var swap1: TreeNode!\\n        var swap2: TreeNode!\\n        \\n        while node !== nil {\\n            \\n            if node.left === nil {\\n                if parent !== nil && node !== nil && parent.val > node.val {\\n                    if swap1 == nil { swap1 = parent }\\n                    swap2 = node\\n                }\\n                \\n                parent = node\\n                node = node.right\\n            } else {\\n                \\n                prev = node.left\\n                while prev.right !== nil && prev.right !== node { prev = prev.right }\\n                \\n                if prev.right === nil {\\n                    prev.right = node\\n                    node = node.left\\n                } else {\\n                    if parent !== nil && node !== nil && parent.val > node.val {\\n                        if swap1 == nil { swap1 = parent }\\n                        swap2 = node\\n                    }\\n                    parent = node\\n                    node = node.right\\n                    prev.right = nil\\n                }\\n            }\\n        }\\n        \\n        if swap1 !== nil && swap2 !== nil {\\n            var hold = swap1.val\\n            swap1.val = swap2.val\\n            swap2.val = hold\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319133,
                "title": "c-using-morrison-traversal-o-n-no-recursion-no-bad-looping",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        TreeNode *aNode = root;\\n        TreeNode *aPrev = NULL;\\n        TreeNode *aParent = NULL;\\n        \\n        TreeNode *aSwap1 = NULL;\\n        TreeNode *aSwap2 = NULL;\\n        \\n        while (aNode != NULL) {\\n            \\n            if (!aNode->left) {\\n                \\n                if (aParent != NULL && aNode != NULL && aParent->val > aNode->val) {\\n                    if (aSwap1 == NULL) { aSwap1 = aParent; }\\n                    aSwap2 = aNode;\\n                }\\n                \\n                aParent = aNode;\\n                aNode = aNode->right;\\n            } else {\\n             \\n                aPrev = aNode->left;\\n                while (aPrev->right != NULL && aPrev->right != aNode) {\\n                    aPrev = aPrev->right;\\n                }\\n                \\n                if (aPrev->right == NULL) {\\n                    aPrev->right = aNode;\\n                    aNode = aNode->left;\\n                } else {\\n                    aPrev->right = NULL;\\n                    if (aParent != NULL && aNode != NULL && aParent->val > aNode->val) {\\n                        if (aSwap1 == NULL) { aSwap1 = aParent; }\\n                        aSwap2 = aNode;\\n                    }\\n                    aParent = aNode;\\n                    aNode = aNode->right;\\n                }\\n            }\\n        }\\n        if (aSwap1 != NULL && aSwap2 != NULL) { swap(aSwap1->val, aSwap2->val); }\\n    }\\n    \\n    \\n};\\n```\\n\\nKaboom, awesome. Enjoy.",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        TreeNode *aNode = root;\\n        TreeNode *aPrev = NULL;\\n        TreeNode *aParent = NULL;\\n        \\n        TreeNode *aSwap1 = NULL;\\n        TreeNode *aSwap2 = NULL;\\n        \\n        while (aNode != NULL) {\\n            \\n            if (!aNode->left) {\\n                \\n                if (aParent != NULL && aNode != NULL && aParent->val > aNode->val) {\\n                    if (aSwap1 == NULL) { aSwap1 = aParent; }\\n                    aSwap2 = aNode;\\n                }\\n                \\n                aParent = aNode;\\n                aNode = aNode->right;\\n            } else {\\n             \\n                aPrev = aNode->left;\\n                while (aPrev->right != NULL && aPrev->right != aNode) {\\n                    aPrev = aPrev->right;\\n                }\\n                \\n                if (aPrev->right == NULL) {\\n                    aPrev->right = aNode;\\n                    aNode = aNode->left;\\n                } else {\\n                    aPrev->right = NULL;\\n                    if (aParent != NULL && aNode != NULL && aParent->val > aNode->val) {\\n                        if (aSwap1 == NULL) { aSwap1 = aParent; }\\n                        aSwap2 = aNode;\\n                    }\\n                    aParent = aNode;\\n                    aNode = aNode->right;\\n                }\\n            }\\n        }\\n        if (aSwap1 != NULL && aSwap2 != NULL) { swap(aSwap1->val, aSwap2->val); }\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317222,
                "title": "java-inorder-traversal",
                "content": "Simple Java traversal.\\n\\n   \\n\\tpublic void recoverTree(TreeNode root) {\\n       \\n\\t    if (root == null) return;\\n\\t\\t\\n        TreeNode n1 = null, n2 = null;\\n        TreeNode last = null;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while (root != null) {\\n            stack.push(root);\\n            root = root.left;\\n        }\\n        \\n        while (!stack.isEmpty()) {\\n            TreeNode cur = stack.pop();\\n            if (last != null) {\\n                if (cur.val < last.val) {\\n                    n2 = cur;\\n                    if (n1 == null) n1 = last;\\n                }\\n            }\\n            last = cur;\\n            if (cur.right != null) {\\n                cur = cur.right;\\n                while (cur != null) {\\n                    stack.push(cur);\\n                    cur = cur.left;\\n                }\\n            } else {\\n                while (!stack.isEmpty() && stack.peek().right == cur) {\\n                    cur = stack.pop();\\n                }\\n            }\\n        }\\n        \\n        int temp = n1.val;\\n        n1.val = n2.val;\\n        n2.val = temp;\\n    }",
                "solutionTags": [],
                "code": "Simple Java traversal.\\n\\n   \\n\\tpublic void recoverTree(TreeNode root) {\\n       \\n\\t    if (root == null) return;\\n\\t\\t\\n        TreeNode n1 = null, n2 = null;\\n        TreeNode last = null;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while (root != null) {\\n            stack.push(root);\\n            root = root.left;\\n        }\\n        \\n        while (!stack.isEmpty()) {\\n            TreeNode cur = stack.pop();\\n            if (last != null) {\\n                if (cur.val < last.val) {\\n                    n2 = cur;\\n                    if (n1 == null) n1 = last;\\n                }\\n            }\\n            last = cur;\\n            if (cur.right != null) {\\n                cur = cur.right;\\n                while (cur != null) {\\n                    stack.push(cur);\\n                    cur = cur.left;\\n                }\\n            } else {\\n                while (!stack.isEmpty() && stack.peek().right == cur) {\\n                    cur = stack.pop();\\n                }\\n            }\\n        }\\n        \\n        int temp = n1.val;\\n        n1.val = n2.val;\\n        n2.val = temp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 295724,
                "title": "java-solution-with-explanation",
                "content": "**Idea**\\nIt is not hard to see that in-order traversal on BST should reveal misplaced elements. But the key point to understand is how do you judge which elements are misplaced when you do in-order since you only have min element to compare curr with and no max.\\nThat is, say BST min property violated at  `curr`, we found the first element (`min`) that is misplaced.\\nIf there is another element violating min property, then we found the two elements we need (`val1` is `min` identified eralier and `val2` is `curr`). But there could be a case, you do not see another element violating min property. In that case, both `min` and `curr` when we saw min property violated must be the elements swapped For ex: `[3,1,4,null,null,2]`.\\n\\n```\\nclass Solution {\\n    TreeNode val1 = null, val2 = null;\\n    TreeNode min = null;\\n    public void recoverTree(TreeNode root) {\\n        walk(root);\\n        int tmp = val1.val;\\n        val1.val = val2.val;\\n        val2.val = tmp;\\n    }\\n    private void walk(TreeNode curr){\\n        if(curr == null) return;\\n        walk(curr.left);\\n        if(min != null && curr.val < min.val){\\n            if(val1 == null){\\n                val1 = min;\\n                val2 = curr;\\n            }else\\n                val2 = curr; //override previous val2 since there are only two misplaced elems\\n        }\\n        min = curr;\\n        walk(curr.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode val1 = null, val2 = null;\\n    TreeNode min = null;\\n    public void recoverTree(TreeNode root) {\\n        walk(root);\\n        int tmp = val1.val;\\n        val1.val = val2.val;\\n        val2.val = tmp;\\n    }\\n    private void walk(TreeNode curr){\\n        if(curr == null) return;\\n        walk(curr.left);\\n        if(min != null && curr.val < min.val){\\n            if(val1 == null){\\n                val1 = min;\\n                val2 = curr;\\n            }else\\n                val2 = curr; //override previous val2 since there are only two misplaced elems\\n        }\\n        min = curr;\\n        walk(curr.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229230,
                "title": "python-in-order-traversal",
                "content": "Inspired by the brilient solution and explanation from @qwl5004 ([Link](https://leetcode.com/problems/recover-binary-search-tree/discuss/32535/No-Fancy-Algorithm-just-Simple-and-Powerful-In-Order-Traversal)). Here is the python version of the solution:\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def __init__(self):\\n        self.prevEle = TreeNode(-float(\\'inf\\'))\\n        self.firstEle = None\\n        self.secondEle = None\\n    \\n    def inOrder(self, root):\\n        if not root:\\n            return\\n        self.inOrder(root.left)\\n        \\n        if not self.firstEle and (root.val < self.prevEle.val):\\n            self.firstEle = self.prevEle\\n        if self.firstEle and (root.val < self.prevEle.val):\\n            self.secondEle = root\\n        \\n        self.prevEle = root\\n        self.inOrder(root.right)\\n    \\n    \\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        \\n        self.inOrder(root)\\n        if not self.firstEle or not self.secondEle:\\n            return\\n        self.firstEle.val, self.secondEle.val = self.secondEle.val, self.firstEle.val\\n        return\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def __init__(self):\\n        self.prevEle = TreeNode(-float(\\'inf\\'))\\n        self.firstEle = None\\n        self.secondEle = None\\n    \\n    def inOrder(self, root):\\n        if not root:\\n            return\\n        self.inOrder(root.left)\\n        \\n        if not self.firstEle and (root.val < self.prevEle.val):\\n            self.firstEle = self.prevEle\\n        if self.firstEle and (root.val < self.prevEle.val):\\n            self.secondEle = root\\n        \\n        self.prevEle = root\\n        self.inOrder(root.right)\\n    \\n    \\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        \\n        self.inOrder(root)\\n        if not self.firstEle or not self.secondEle:\\n            return\\n        self.firstEle.val, self.secondEle.val = self.secondEle.val, self.firstEle.val\\n        return\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567676,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1565658,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1723131,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1566715,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1567858,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1787057,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1575663,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1568921,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1575958,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1572172,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1567676,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1565658,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1723131,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1566715,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1567858,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1787057,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1575663,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1568921,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1575958,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1572172,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1963829,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 1572798,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 1572032,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 1571212,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 2071864,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 2049985,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 2027652,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 2026209,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 2004429,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 1991777,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            }
        ]
    }
]